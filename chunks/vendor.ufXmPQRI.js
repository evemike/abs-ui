var eae = Object.defineProperty;
var tae = (n, e, t) => e in n ? eae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var Zr = (n, e, t) => (tae(n, typeof e != "symbol" ? e + "" : e, t), t), t2 = (n, e, t) => {
  if (!e.has(n))
    throw TypeError("Cannot " + t);
};
var Z = (n, e, t) => (t2(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Mt = (n, e, t) => {
  if (e.has(n))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(n) : e.set(n, t);
}, ut = (n, e, t, r) => (t2(n, e, "write to private field"), r ? r.call(n, t) : e.set(n, t), t);
var r1 = (n, e, t, r) => ({
  set _(i) {
    ut(n, e, i, t);
  },
  get _() {
    return Z(n, e, r);
  }
}), tt = (n, e, t) => (t2(n, e, "access private method"), t);
import "../css/vendor-BycN2tkO.css";
import { defineComponent as U, openBlock as V, createElementBlock as q, createElementVNode as J, shallowRef as di, watchEffect as sl, readonly as o_, ref as z, watch as he, getCurrentScope as kG, onScopeDispose as KD, unref as T, getCurrentInstance as wt, onMounted as ht, nextTick as Ke, computed as B, warn as nae, isVNode as gl, onBeforeUnmount as xi, inject as Re, isRef as So, onBeforeMount as JD, provide as Wt, renderSlot as ke, mergeProps as xa, toRef as ba, onUnmounted as ub, reactive as dr, toRefs as bu, normalizeClass as Q, onUpdated as yd, createVNode as de, Fragment as yn, useSlots as Tl, withCtx as fe, createBlock as ve, resolveDynamicComponent as cn, normalizeStyle as vt, createTextVNode as Ri, toDisplayString as ze, createCommentVNode as pe, TransitionGroup as rae, useAttrs as PG, withDirectives as At, withModifiers as kt, vShow as On, Transition as kl, cloneVNode as iae, Text as EG, Comment as MG, Teleport as a_, onDeactivated as oae, toRaw as rx, vModelCheckbox as ix, vModelRadio as DG, h as et, resolveComponent as Ct, renderList as qi, onBeforeUpdate as aae, withKeys as Rr, vModelText as LG, toHandlers as sae, createSlots as lae, resolveDirective as eL, render as Tc, shallowReactive as uae, customRef as cae, markRaw as hae, createApp as fae } from "vue";
var IG = typeof global == "object" && global && global.Object === Object && global, dae = typeof self == "object" && self && self.Object === Object && self, ys = IG || dae || Function("return this")(), ka = ys.Symbol, RG = Object.prototype, pae = RG.hasOwnProperty, gae = RG.toString, Hv = ka ? ka.toStringTag : void 0;
function vae(n) {
  var e = pae.call(n, Hv), t = n[Hv];
  try {
    n[Hv] = void 0;
    var r = !0;
  } catch {
  }
  var i = gae.call(n);
  return r && (e ? n[Hv] = t : delete n[Hv]), i;
}
var mae = Object.prototype, yae = mae.toString;
function bae(n) {
  return yae.call(n);
}
var Oae = "[object Null]", wae = "[object Undefined]", R$ = ka ? ka.toStringTag : void 0;
function Ou(n) {
  return n == null ? n === void 0 ? wae : Oae : R$ && R$ in Object(n) ? vae(n) : bae(n);
}
function Pa(n) {
  return n != null && typeof n == "object";
}
var xae = "[object Symbol]";
function vl(n) {
  return typeof n == "symbol" || Pa(n) && Ou(n) == xae;
}
function Mf(n, e) {
  for (var t = -1, r = n == null ? 0 : n.length, i = Array(r); ++t < r; )
    i[t] = e(n[t], t, n);
  return i;
}
var Yr = Array.isArray, Sae = 1 / 0, N$ = ka ? ka.prototype : void 0, $$ = N$ ? N$.toString : void 0;
function NG(n) {
  if (typeof n == "string")
    return n;
  if (Yr(n))
    return Mf(n, NG) + "";
  if (vl(n))
    return $$ ? $$.call(n) : "";
  var e = n + "";
  return e == "0" && 1 / n == -Sae ? "-0" : e;
}
var _ae = /\s/;
function Cae(n) {
  for (var e = n.length; e-- && _ae.test(n.charAt(e)); )
    ;
  return e;
}
var Aae = /^\s+/;
function Tae(n) {
  return n && n.slice(0, Cae(n) + 1).replace(Aae, "");
}
function tr(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var B$ = NaN, kae = /^[-+]0x[0-9a-f]+$/i, Pae = /^0b[01]+$/i, Eae = /^0o[0-7]+$/i, Mae = parseInt;
function Rp(n) {
  if (typeof n == "number")
    return n;
  if (vl(n))
    return B$;
  if (tr(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = tr(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = Tae(n);
  var t = Pae.test(n);
  return t || Eae.test(n) ? Mae(n.slice(2), t ? 2 : 8) : kae.test(n) ? B$ : +n;
}
var V$ = 1 / 0, Dae = 17976931348623157e292;
function Lae(n) {
  if (!n)
    return n === 0 ? n : 0;
  if (n = Rp(n), n === V$ || n === -V$) {
    var e = n < 0 ? -1 : 1;
    return e * Dae;
  }
  return n === n ? n : 0;
}
function tL(n) {
  var e = Lae(n), t = e % 1;
  return e === e ? t ? e - t : e : 0;
}
function nh(n) {
  return n;
}
var Iae = "[object AsyncFunction]", Rae = "[object Function]", Nae = "[object GeneratorFunction]", $ae = "[object Proxy]";
function nL(n) {
  if (!tr(n))
    return !1;
  var e = Ou(n);
  return e == Rae || e == Nae || e == Iae || e == $ae;
}
var n2 = ys["__core-js_shared__"], z$ = function() {
  var n = /[^.]+$/.exec(n2 && n2.keys && n2.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function Bae(n) {
  return !!z$ && z$ in n;
}
var Vae = Function.prototype, zae = Vae.toString;
function bd(n) {
  if (n != null) {
    try {
      return zae.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var Fae = /[\\^$.*+?()[\]{}|]/g, Qae = /^\[object .+?Constructor\]$/, Zae = Function.prototype, Wae = Object.prototype, Gae = Zae.toString, jae = Wae.hasOwnProperty, Hae = RegExp(
  "^" + Gae.call(jae).replace(Fae, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function qae(n) {
  if (!tr(n) || Bae(n))
    return !1;
  var e = nL(n) ? Hae : Qae;
  return e.test(bd(n));
}
function Yae(n, e) {
  return n == null ? void 0 : n[e];
}
function Od(n, e) {
  var t = Yae(n, e);
  return qae(t) ? t : void 0;
}
var Zk = Od(ys, "WeakMap"), F$ = Object.create, Xae = /* @__PURE__ */ function() {
  function n() {
  }
  return function(e) {
    if (!tr(e))
      return {};
    if (F$)
      return F$(e);
    n.prototype = e;
    var t = new n();
    return n.prototype = void 0, t;
  };
}();
function $G(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
function Uae() {
}
function BG(n, e) {
  var t = -1, r = n.length;
  for (e || (e = Array(r)); ++t < r; )
    e[t] = n[t];
  return e;
}
var Kae = 800, Jae = 16, ese = Date.now;
function tse(n) {
  var e = 0, t = 0;
  return function() {
    var r = ese(), i = Jae - (r - t);
    if (t = r, i > 0) {
      if (++e >= Kae)
        return arguments[0];
    } else
      e = 0;
    return n.apply(void 0, arguments);
  };
}
function nse(n) {
  return function() {
    return n;
  };
}
var ox = function() {
  try {
    var n = Od(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), rse = ox ? function(n, e) {
  return ox(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: nse(e),
    writable: !0
  });
} : nh;
const ise = rse;
var VG = tse(ise);
function ose(n, e) {
  for (var t = -1, r = n == null ? 0 : n.length; ++t < r && e(n[t], t, n) !== !1; )
    ;
  return n;
}
function rL(n, e, t, r) {
  for (var i = n.length, o = t + (r ? 1 : -1); r ? o-- : ++o < i; )
    if (e(n[o], o, n))
      return o;
  return -1;
}
function ase(n) {
  return n !== n;
}
function sse(n, e, t) {
  for (var r = t - 1, i = n.length; ++r < i; )
    if (n[r] === e)
      return r;
  return -1;
}
function lse(n, e, t) {
  return e === e ? sse(n, e, t) : rL(n, ase, t);
}
function zG(n, e) {
  var t = n == null ? 0 : n.length;
  return !!t && lse(n, e, 0) > -1;
}
var use = 9007199254740991, cse = /^(?:0|[1-9]\d*)$/;
function s_(n, e) {
  var t = typeof n;
  return e = e ?? use, !!e && (t == "number" || t != "symbol" && cse.test(n)) && n > -1 && n % 1 == 0 && n < e;
}
function l_(n, e, t) {
  e == "__proto__" && ox ? ox(n, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : n[e] = t;
}
function iv(n, e) {
  return n === e || n !== n && e !== e;
}
var hse = Object.prototype, fse = hse.hasOwnProperty;
function u_(n, e, t) {
  var r = n[e];
  (!(fse.call(n, e) && iv(r, t)) || t === void 0 && !(e in n)) && l_(n, e, t);
}
function wd(n, e, t, r) {
  var i = !t;
  t || (t = {});
  for (var o = -1, a = e.length; ++o < a; ) {
    var s = e[o], l = r ? r(t[s], n[s], s, t, n) : void 0;
    l === void 0 && (l = n[s]), i ? l_(t, s, l) : u_(t, s, l);
  }
  return t;
}
var Q$ = Math.max;
function FG(n, e, t) {
  return e = Q$(e === void 0 ? n.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, o = Q$(r.length - e, 0), a = Array(o); ++i < o; )
      a[i] = r[e + i];
    i = -1;
    for (var s = Array(e + 1); ++i < e; )
      s[i] = r[i];
    return s[e] = t(a), $G(n, this, s);
  };
}
function ov(n, e) {
  return VG(FG(n, e, nh), n + "");
}
var dse = 9007199254740991;
function iL(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= dse;
}
function rh(n) {
  return n != null && iL(n.length) && !nL(n);
}
function jy(n, e, t) {
  if (!tr(t))
    return !1;
  var r = typeof e;
  return (r == "number" ? rh(t) && s_(e, t.length) : r == "string" && e in t) ? iv(t[e], n) : !1;
}
function oL(n) {
  return ov(function(e, t) {
    var r = -1, i = t.length, o = i > 1 ? t[i - 1] : void 0, a = i > 2 ? t[2] : void 0;
    for (o = n.length > 3 && typeof o == "function" ? (i--, o) : void 0, a && jy(t[0], t[1], a) && (o = i < 3 ? void 0 : o, i = 1), e = Object(e); ++r < i; ) {
      var s = t[r];
      s && n(e, s, r, o);
    }
    return e;
  });
}
var pse = Object.prototype;
function cb(n) {
  var e = n && n.constructor, t = typeof e == "function" && e.prototype || pse;
  return n === t;
}
function gse(n, e) {
  for (var t = -1, r = Array(n); ++t < n; )
    r[t] = e(t);
  return r;
}
var vse = "[object Arguments]";
function Z$(n) {
  return Pa(n) && Ou(n) == vse;
}
var QG = Object.prototype, mse = QG.hasOwnProperty, yse = QG.propertyIsEnumerable, sg = Z$(/* @__PURE__ */ function() {
  return arguments;
}()) ? Z$ : function(n) {
  return Pa(n) && mse.call(n, "callee") && !yse.call(n, "callee");
};
function bse() {
  return !1;
}
var ZG = typeof exports == "object" && exports && !exports.nodeType && exports, W$ = ZG && typeof module == "object" && module && !module.nodeType && module, Ose = W$ && W$.exports === ZG, G$ = Ose ? ys.Buffer : void 0, wse = G$ ? G$.isBuffer : void 0, lg = wse || bse, xse = "[object Arguments]", Sse = "[object Array]", _se = "[object Boolean]", Cse = "[object Date]", Ase = "[object Error]", Tse = "[object Function]", kse = "[object Map]", Pse = "[object Number]", Ese = "[object Object]", Mse = "[object RegExp]", Dse = "[object Set]", Lse = "[object String]", Ise = "[object WeakMap]", Rse = "[object ArrayBuffer]", Nse = "[object DataView]", $se = "[object Float32Array]", Bse = "[object Float64Array]", Vse = "[object Int8Array]", zse = "[object Int16Array]", Fse = "[object Int32Array]", Qse = "[object Uint8Array]", Zse = "[object Uint8ClampedArray]", Wse = "[object Uint16Array]", Gse = "[object Uint32Array]", Rn = {};
Rn[$se] = Rn[Bse] = Rn[Vse] = Rn[zse] = Rn[Fse] = Rn[Qse] = Rn[Zse] = Rn[Wse] = Rn[Gse] = !0;
Rn[xse] = Rn[Sse] = Rn[Rse] = Rn[_se] = Rn[Nse] = Rn[Cse] = Rn[Ase] = Rn[Tse] = Rn[kse] = Rn[Pse] = Rn[Ese] = Rn[Mse] = Rn[Dse] = Rn[Lse] = Rn[Ise] = !1;
function jse(n) {
  return Pa(n) && iL(n.length) && !!Rn[Ou(n)];
}
function hb(n) {
  return function(e) {
    return n(e);
  };
}
var WG = typeof exports == "object" && exports && !exports.nodeType && exports, ay = WG && typeof module == "object" && module && !module.nodeType && module, Hse = ay && ay.exports === WG, r2 = Hse && IG.process, ug = function() {
  try {
    var n = ay && ay.require && ay.require("util").types;
    return n || r2 && r2.binding && r2.binding("util");
  } catch {
  }
}(), j$ = ug && ug.isTypedArray, qse = j$ ? hb(j$) : jse;
const c_ = qse;
var Yse = Object.prototype, Xse = Yse.hasOwnProperty;
function GG(n, e) {
  var t = Yr(n), r = !t && sg(n), i = !t && !r && lg(n), o = !t && !r && !i && c_(n), a = t || r || i || o, s = a ? gse(n.length, String) : [], l = s.length;
  for (var u in n)
    (e || Xse.call(n, u)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    s_(u, l))) && s.push(u);
  return s;
}
function jG(n, e) {
  return function(t) {
    return n(e(t));
  };
}
var Use = jG(Object.keys, Object), Kse = Object.prototype, Jse = Kse.hasOwnProperty;
function HG(n) {
  if (!cb(n))
    return Use(n);
  var e = [];
  for (var t in Object(n))
    Jse.call(n, t) && t != "constructor" && e.push(t);
  return e;
}
function av(n) {
  return rh(n) ? GG(n) : HG(n);
}
var ele = Object.prototype, tle = ele.hasOwnProperty, nle = oL(function(n, e) {
  if (cb(e) || rh(e)) {
    wd(e, av(e), n);
    return;
  }
  for (var t in e)
    tle.call(e, t) && u_(n, t, e[t]);
});
const mFt = nle;
function rle(n) {
  var e = [];
  if (n != null)
    for (var t in Object(n))
      e.push(t);
  return e;
}
var ile = Object.prototype, ole = ile.hasOwnProperty;
function ale(n) {
  if (!tr(n))
    return rle(n);
  var e = cb(n), t = [];
  for (var r in n)
    r == "constructor" && (e || !ole.call(n, r)) || t.push(r);
  return t;
}
function sv(n) {
  return rh(n) ? GG(n, !0) : ale(n);
}
var sle = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, lle = /^\w*$/;
function aL(n, e) {
  if (Yr(n))
    return !1;
  var t = typeof n;
  return t == "number" || t == "symbol" || t == "boolean" || n == null || vl(n) ? !0 : lle.test(n) || !sle.test(n) || e != null && n in Object(e);
}
var Hy = Od(Object, "create");
function ule() {
  this.__data__ = Hy ? Hy(null) : {}, this.size = 0;
}
function cle(n) {
  var e = this.has(n) && delete this.__data__[n];
  return this.size -= e ? 1 : 0, e;
}
var hle = "__lodash_hash_undefined__", fle = Object.prototype, dle = fle.hasOwnProperty;
function ple(n) {
  var e = this.__data__;
  if (Hy) {
    var t = e[n];
    return t === hle ? void 0 : t;
  }
  return dle.call(e, n) ? e[n] : void 0;
}
var gle = Object.prototype, vle = gle.hasOwnProperty;
function mle(n) {
  var e = this.__data__;
  return Hy ? e[n] !== void 0 : vle.call(e, n);
}
var yle = "__lodash_hash_undefined__";
function ble(n, e) {
  var t = this.__data__;
  return this.size += this.has(n) ? 0 : 1, t[n] = Hy && e === void 0 ? yle : e, this;
}
function qf(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
qf.prototype.clear = ule;
qf.prototype.delete = cle;
qf.prototype.get = ple;
qf.prototype.has = mle;
qf.prototype.set = ble;
function Ole() {
  this.__data__ = [], this.size = 0;
}
function h_(n, e) {
  for (var t = n.length; t--; )
    if (iv(n[t][0], e))
      return t;
  return -1;
}
var wle = Array.prototype, xle = wle.splice;
function Sle(n) {
  var e = this.__data__, t = h_(e, n);
  if (t < 0)
    return !1;
  var r = e.length - 1;
  return t == r ? e.pop() : xle.call(e, t, 1), --this.size, !0;
}
function _le(n) {
  var e = this.__data__, t = h_(e, n);
  return t < 0 ? void 0 : e[t][1];
}
function Cle(n) {
  return h_(this.__data__, n) > -1;
}
function Ale(n, e) {
  var t = this.__data__, r = h_(t, n);
  return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this;
}
function wu(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
wu.prototype.clear = Ole;
wu.prototype.delete = Sle;
wu.prototype.get = _le;
wu.prototype.has = Cle;
wu.prototype.set = Ale;
var qy = Od(ys, "Map");
function Tle() {
  this.size = 0, this.__data__ = {
    hash: new qf(),
    map: new (qy || wu)(),
    string: new qf()
  };
}
function kle(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
}
function f_(n, e) {
  var t = n.__data__;
  return kle(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function Ple(n) {
  var e = f_(this, n).delete(n);
  return this.size -= e ? 1 : 0, e;
}
function Ele(n) {
  return f_(this, n).get(n);
}
function Mle(n) {
  return f_(this, n).has(n);
}
function Dle(n, e) {
  var t = f_(this, n), r = t.size;
  return t.set(n, e), this.size += t.size == r ? 0 : 1, this;
}
function xu(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
xu.prototype.clear = Tle;
xu.prototype.delete = Ple;
xu.prototype.get = Ele;
xu.prototype.has = Mle;
xu.prototype.set = Dle;
var Lle = "Expected a function";
function sL(n, e) {
  if (typeof n != "function" || e != null && typeof e != "function")
    throw new TypeError(Lle);
  var t = function() {
    var r = arguments, i = e ? e.apply(this, r) : r[0], o = t.cache;
    if (o.has(i))
      return o.get(i);
    var a = n.apply(this, r);
    return t.cache = o.set(i, a) || o, a;
  };
  return t.cache = new (sL.Cache || xu)(), t;
}
sL.Cache = xu;
var Ile = 500;
function Rle(n) {
  var e = sL(n, function(r) {
    return t.size === Ile && t.clear(), r;
  }), t = e.cache;
  return e;
}
var Nle = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, $le = /\\(\\)?/g, Ble = Rle(function(n) {
  var e = [];
  return n.charCodeAt(0) === 46 && e.push(""), n.replace(Nle, function(t, r, i, o) {
    e.push(i ? o.replace($le, "$1") : r || t);
  }), e;
});
function fb(n) {
  return n == null ? "" : NG(n);
}
function lv(n, e) {
  return Yr(n) ? n : aL(n, e) ? [n] : Ble(fb(n));
}
var Vle = 1 / 0;
function uv(n) {
  if (typeof n == "string" || vl(n))
    return n;
  var e = n + "";
  return e == "0" && 1 / n == -Vle ? "-0" : e;
}
function db(n, e) {
  e = lv(e, n);
  for (var t = 0, r = e.length; n != null && t < r; )
    n = n[uv(e[t++])];
  return t && t == r ? n : void 0;
}
function ga(n, e, t) {
  var r = n == null ? void 0 : db(n, e);
  return r === void 0 ? t : r;
}
function lL(n, e) {
  for (var t = -1, r = e.length, i = n.length; ++t < r; )
    n[i + t] = e[t];
  return n;
}
var H$ = ka ? ka.isConcatSpreadable : void 0;
function zle(n) {
  return Yr(n) || sg(n) || !!(H$ && n && n[H$]);
}
function xd(n, e, t, r, i) {
  var o = -1, a = n.length;
  for (t || (t = zle), i || (i = []); ++o < a; ) {
    var s = n[o];
    e > 0 && t(s) ? e > 1 ? xd(s, e - 1, t, r, i) : lL(i, s) : r || (i[i.length] = s);
  }
  return i;
}
function Fle(n) {
  var e = n == null ? 0 : n.length;
  return e ? xd(n, 1) : [];
}
function qG(n) {
  return VG(FG(n, void 0, Fle), n + "");
}
var uL = jG(Object.getPrototypeOf, Object), Qle = "[object Object]", Zle = Function.prototype, Wle = Object.prototype, YG = Zle.toString, Gle = Wle.hasOwnProperty, jle = YG.call(Object);
function bs(n) {
  if (!Pa(n) || Ou(n) != Qle)
    return !1;
  var e = uL(n);
  if (e === null)
    return !0;
  var t = Gle.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && YG.call(t) == jle;
}
function cL(n, e, t) {
  var r = -1, i = n.length;
  e < 0 && (e = -e > i ? 0 : i + e), t = t > i ? i : t, t < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0;
  for (var o = Array(i); ++r < i; )
    o[r] = n[r + e];
  return o;
}
function Hle(n, e, t) {
  var r = n.length;
  return t = t === void 0 ? r : t, !e && t >= r ? n : cL(n, e, t);
}
var qle = "\\ud800-\\udfff", Yle = "\\u0300-\\u036f", Xle = "\\ufe20-\\ufe2f", Ule = "\\u20d0-\\u20ff", Kle = Yle + Xle + Ule, Jle = "\\ufe0e\\ufe0f", eue = "\\u200d", tue = RegExp("[" + eue + qle + Kle + Jle + "]");
function XG(n) {
  return tue.test(n);
}
function nue(n) {
  return n.split("");
}
var UG = "\\ud800-\\udfff", rue = "\\u0300-\\u036f", iue = "\\ufe20-\\ufe2f", oue = "\\u20d0-\\u20ff", aue = rue + iue + oue, sue = "\\ufe0e\\ufe0f", lue = "[" + UG + "]", Wk = "[" + aue + "]", Gk = "\\ud83c[\\udffb-\\udfff]", uue = "(?:" + Wk + "|" + Gk + ")", KG = "[^" + UG + "]", JG = "(?:\\ud83c[\\udde6-\\uddff]){2}", ej = "[\\ud800-\\udbff][\\udc00-\\udfff]", cue = "\\u200d", tj = uue + "?", nj = "[" + sue + "]?", hue = "(?:" + cue + "(?:" + [KG, JG, ej].join("|") + ")" + nj + tj + ")*", fue = nj + tj + hue, due = "(?:" + [KG + Wk + "?", Wk, JG, ej, lue].join("|") + ")", pue = RegExp(Gk + "(?=" + Gk + ")|" + due + fue, "g");
function gue(n) {
  return n.match(pue) || [];
}
function vue(n) {
  return XG(n) ? gue(n) : nue(n);
}
function rj(n) {
  return function(e) {
    e = fb(e);
    var t = XG(e) ? vue(e) : void 0, r = t ? t[0] : e.charAt(0), i = t ? Hle(t, 1).join("") : e.slice(1);
    return r[n]() + i;
  };
}
var ax = rj("toUpperCase");
function mue(n) {
  return ax(fb(n).toLowerCase());
}
function yue(n, e, t, r) {
  var i = -1, o = n == null ? 0 : n.length;
  for (r && o && (t = n[++i]); ++i < o; )
    t = e(t, n[i], i, n);
  return t;
}
function bue(n) {
  return function(e) {
    return n == null ? void 0 : n[e];
  };
}
var Oue = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, wue = bue(Oue);
const xue = wue;
var Sue = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, _ue = "\\u0300-\\u036f", Cue = "\\ufe20-\\ufe2f", Aue = "\\u20d0-\\u20ff", Tue = _ue + Cue + Aue, kue = "[" + Tue + "]", Pue = RegExp(kue, "g");
function Eue(n) {
  return n = fb(n), n && n.replace(Sue, xue).replace(Pue, "");
}
var Mue = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function Due(n) {
  return n.match(Mue) || [];
}
var Lue = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Iue(n) {
  return Lue.test(n);
}
var ij = "\\ud800-\\udfff", Rue = "\\u0300-\\u036f", Nue = "\\ufe20-\\ufe2f", $ue = "\\u20d0-\\u20ff", Bue = Rue + Nue + $ue, oj = "\\u2700-\\u27bf", aj = "a-z\\xdf-\\xf6\\xf8-\\xff", Vue = "\\xac\\xb1\\xd7\\xf7", zue = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Fue = "\\u2000-\\u206f", Que = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", sj = "A-Z\\xc0-\\xd6\\xd8-\\xde", Zue = "\\ufe0e\\ufe0f", lj = Vue + zue + Fue + Que, uj = "['’]", q$ = "[" + lj + "]", Wue = "[" + Bue + "]", cj = "\\d+", Gue = "[" + oj + "]", hj = "[" + aj + "]", fj = "[^" + ij + lj + cj + oj + aj + sj + "]", jue = "\\ud83c[\\udffb-\\udfff]", Hue = "(?:" + Wue + "|" + jue + ")", que = "[^" + ij + "]", dj = "(?:\\ud83c[\\udde6-\\uddff]){2}", pj = "[\\ud800-\\udbff][\\udc00-\\udfff]", yp = "[" + sj + "]", Yue = "\\u200d", Y$ = "(?:" + hj + "|" + fj + ")", Xue = "(?:" + yp + "|" + fj + ")", X$ = "(?:" + uj + "(?:d|ll|m|re|s|t|ve))?", U$ = "(?:" + uj + "(?:D|LL|M|RE|S|T|VE))?", gj = Hue + "?", vj = "[" + Zue + "]?", Uue = "(?:" + Yue + "(?:" + [que, dj, pj].join("|") + ")" + vj + gj + ")*", Kue = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Jue = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ece = vj + gj + Uue, tce = "(?:" + [Gue, dj, pj].join("|") + ")" + ece, nce = RegExp([
  yp + "?" + hj + "+" + X$ + "(?=" + [q$, yp, "$"].join("|") + ")",
  Xue + "+" + U$ + "(?=" + [q$, yp + Y$, "$"].join("|") + ")",
  yp + "?" + Y$ + "+" + X$,
  yp + "+" + U$,
  Jue,
  Kue,
  cj,
  tce
].join("|"), "g");
function rce(n) {
  return n.match(nce) || [];
}
function ice(n, e, t) {
  return n = fb(n), e = t ? void 0 : e, e === void 0 ? Iue(n) ? rce(n) : Due(n) : n.match(e) || [];
}
var oce = "['’]", ace = RegExp(oce, "g");
function hL(n) {
  return function(e) {
    return yue(ice(Eue(e).replace(ace, "")), n, "");
  };
}
var d_ = hL(function(n, e, t) {
  return e = e.toLowerCase(), n + (t ? mue(e) : e);
});
function Yy() {
  if (!arguments.length)
    return [];
  var n = arguments[0];
  return Yr(n) ? n : [n];
}
var sce = Math.ceil, lce = Math.max;
function yFt(n, e, t) {
  (t ? jy(n, e, t) : e === void 0) ? e = 1 : e = lce(tL(e), 0);
  var r = n == null ? 0 : n.length;
  if (!r || e < 1)
    return [];
  for (var i = 0, o = 0, a = Array(sce(r / e)); i < r; )
    a[o++] = cL(n, i, i += e);
  return a;
}
function uce(n, e, t) {
  return n === n && (t !== void 0 && (n = n <= t ? n : t), e !== void 0 && (n = n >= e ? n : e)), n;
}
function wo(n, e, t) {
  return t === void 0 && (t = e, e = void 0), t !== void 0 && (t = Rp(t), t = t === t ? t : 0), e !== void 0 && (e = Rp(e), e = e === e ? e : 0), uce(Rp(n), e, t);
}
function cce() {
  this.__data__ = new wu(), this.size = 0;
}
function hce(n) {
  var e = this.__data__, t = e.delete(n);
  return this.size = e.size, t;
}
function fce(n) {
  return this.__data__.get(n);
}
function dce(n) {
  return this.__data__.has(n);
}
var pce = 200;
function gce(n, e) {
  var t = this.__data__;
  if (t instanceof wu) {
    var r = t.__data__;
    if (!qy || r.length < pce - 1)
      return r.push([n, e]), this.size = ++t.size, this;
    t = this.__data__ = new xu(r);
  }
  return t.set(n, e), this.size = t.size, this;
}
function as(n) {
  var e = this.__data__ = new wu(n);
  this.size = e.size;
}
as.prototype.clear = cce;
as.prototype.delete = hce;
as.prototype.get = fce;
as.prototype.has = dce;
as.prototype.set = gce;
function vce(n, e) {
  return n && wd(e, av(e), n);
}
function mce(n, e) {
  return n && wd(e, sv(e), n);
}
var mj = typeof exports == "object" && exports && !exports.nodeType && exports, K$ = mj && typeof module == "object" && module && !module.nodeType && module, yce = K$ && K$.exports === mj, J$ = yce ? ys.Buffer : void 0, e3 = J$ ? J$.allocUnsafe : void 0;
function yj(n, e) {
  if (e)
    return n.slice();
  var t = n.length, r = e3 ? e3(t) : new n.constructor(t);
  return n.copy(r), r;
}
function bce(n, e) {
  for (var t = -1, r = n == null ? 0 : n.length, i = 0, o = []; ++t < r; ) {
    var a = n[t];
    e(a, t, n) && (o[i++] = a);
  }
  return o;
}
function bj() {
  return [];
}
var Oce = Object.prototype, wce = Oce.propertyIsEnumerable, t3 = Object.getOwnPropertySymbols, fL = t3 ? function(n) {
  return n == null ? [] : (n = Object(n), bce(t3(n), function(e) {
    return wce.call(n, e);
  }));
} : bj;
function xce(n, e) {
  return wd(n, fL(n), e);
}
var Sce = Object.getOwnPropertySymbols, Oj = Sce ? function(n) {
  for (var e = []; n; )
    lL(e, fL(n)), n = uL(n);
  return e;
} : bj;
function _ce(n, e) {
  return wd(n, Oj(n), e);
}
function wj(n, e, t) {
  var r = e(n);
  return Yr(n) ? r : lL(r, t(n));
}
function jk(n) {
  return wj(n, av, fL);
}
function xj(n) {
  return wj(n, sv, Oj);
}
var Hk = Od(ys, "DataView"), qk = Od(ys, "Promise"), Np = Od(ys, "Set"), n3 = "[object Map]", Cce = "[object Object]", r3 = "[object Promise]", i3 = "[object Set]", o3 = "[object WeakMap]", a3 = "[object DataView]", Ace = bd(Hk), Tce = bd(qy), kce = bd(qk), Pce = bd(Np), Ece = bd(Zk), Gh = Ou;
(Hk && Gh(new Hk(new ArrayBuffer(1))) != a3 || qy && Gh(new qy()) != n3 || qk && Gh(qk.resolve()) != r3 || Np && Gh(new Np()) != i3 || Zk && Gh(new Zk()) != o3) && (Gh = function(n) {
  var e = Ou(n), t = e == Cce ? n.constructor : void 0, r = t ? bd(t) : "";
  if (r)
    switch (r) {
      case Ace:
        return a3;
      case Tce:
        return n3;
      case kce:
        return r3;
      case Pce:
        return i3;
      case Ece:
        return o3;
    }
  return e;
});
const cg = Gh;
var Mce = Object.prototype, Dce = Mce.hasOwnProperty;
function Lce(n) {
  var e = n.length, t = new n.constructor(e);
  return e && typeof n[0] == "string" && Dce.call(n, "index") && (t.index = n.index, t.input = n.input), t;
}
var sx = ys.Uint8Array;
function dL(n) {
  var e = new n.constructor(n.byteLength);
  return new sx(e).set(new sx(n)), e;
}
function Ice(n, e) {
  var t = e ? dL(n.buffer) : n.buffer;
  return new n.constructor(t, n.byteOffset, n.byteLength);
}
var Rce = /\w*$/;
function Nce(n) {
  var e = new n.constructor(n.source, Rce.exec(n));
  return e.lastIndex = n.lastIndex, e;
}
var s3 = ka ? ka.prototype : void 0, l3 = s3 ? s3.valueOf : void 0;
function $ce(n) {
  return l3 ? Object(l3.call(n)) : {};
}
function Sj(n, e) {
  var t = e ? dL(n.buffer) : n.buffer;
  return new n.constructor(t, n.byteOffset, n.length);
}
var Bce = "[object Boolean]", Vce = "[object Date]", zce = "[object Map]", Fce = "[object Number]", Qce = "[object RegExp]", Zce = "[object Set]", Wce = "[object String]", Gce = "[object Symbol]", jce = "[object ArrayBuffer]", Hce = "[object DataView]", qce = "[object Float32Array]", Yce = "[object Float64Array]", Xce = "[object Int8Array]", Uce = "[object Int16Array]", Kce = "[object Int32Array]", Jce = "[object Uint8Array]", ehe = "[object Uint8ClampedArray]", the = "[object Uint16Array]", nhe = "[object Uint32Array]";
function rhe(n, e, t) {
  var r = n.constructor;
  switch (e) {
    case jce:
      return dL(n);
    case Bce:
    case Vce:
      return new r(+n);
    case Hce:
      return Ice(n, t);
    case qce:
    case Yce:
    case Xce:
    case Uce:
    case Kce:
    case Jce:
    case ehe:
    case the:
    case nhe:
      return Sj(n, t);
    case zce:
      return new r();
    case Fce:
    case Wce:
      return new r(n);
    case Qce:
      return Nce(n);
    case Zce:
      return new r();
    case Gce:
      return $ce(n);
  }
}
function _j(n) {
  return typeof n.constructor == "function" && !cb(n) ? Xae(uL(n)) : {};
}
var ihe = "[object Map]";
function ohe(n) {
  return Pa(n) && cg(n) == ihe;
}
var u3 = ug && ug.isMap, ahe = u3 ? hb(u3) : ohe, she = "[object Set]";
function lhe(n) {
  return Pa(n) && cg(n) == she;
}
var c3 = ug && ug.isSet, uhe = c3 ? hb(c3) : lhe, che = 1, hhe = 2, fhe = 4, Cj = "[object Arguments]", dhe = "[object Array]", phe = "[object Boolean]", ghe = "[object Date]", vhe = "[object Error]", Aj = "[object Function]", mhe = "[object GeneratorFunction]", yhe = "[object Map]", bhe = "[object Number]", Tj = "[object Object]", Ohe = "[object RegExp]", whe = "[object Set]", xhe = "[object String]", She = "[object Symbol]", _he = "[object WeakMap]", Che = "[object ArrayBuffer]", Ahe = "[object DataView]", The = "[object Float32Array]", khe = "[object Float64Array]", Phe = "[object Int8Array]", Ehe = "[object Int16Array]", Mhe = "[object Int32Array]", Dhe = "[object Uint8Array]", Lhe = "[object Uint8ClampedArray]", Ihe = "[object Uint16Array]", Rhe = "[object Uint32Array]", Pn = {};
Pn[Cj] = Pn[dhe] = Pn[Che] = Pn[Ahe] = Pn[phe] = Pn[ghe] = Pn[The] = Pn[khe] = Pn[Phe] = Pn[Ehe] = Pn[Mhe] = Pn[yhe] = Pn[bhe] = Pn[Tj] = Pn[Ohe] = Pn[whe] = Pn[xhe] = Pn[She] = Pn[Dhe] = Pn[Lhe] = Pn[Ihe] = Pn[Rhe] = !0;
Pn[vhe] = Pn[Aj] = Pn[_he] = !1;
function $p(n, e, t, r, i, o) {
  var a, s = e & che, l = e & hhe, u = e & fhe;
  if (t && (a = i ? t(n, r, i, o) : t(n)), a !== void 0)
    return a;
  if (!tr(n))
    return n;
  var c = Yr(n);
  if (c) {
    if (a = Lce(n), !s)
      return BG(n, a);
  } else {
    var h = cg(n), f = h == Aj || h == mhe;
    if (lg(n))
      return yj(n, s);
    if (h == Tj || h == Cj || f && !i) {
      if (a = l || f ? {} : _j(n), !s)
        return l ? _ce(n, mce(a, n)) : xce(n, vce(a, n));
    } else {
      if (!Pn[h])
        return i ? n : {};
      a = rhe(n, h, s);
    }
  }
  o || (o = new as());
  var d = o.get(n);
  if (d)
    return d;
  o.set(n, a), uhe(n) ? n.forEach(function(v) {
    a.add($p(v, e, t, v, n, o));
  }) : ahe(n) && n.forEach(function(v, m) {
    a.set(m, $p(v, e, t, m, n, o));
  });
  var p = u ? l ? xj : jk : l ? sv : av, g = c ? void 0 : p(n);
  return ose(g || n, function(v, m) {
    g && (m = v, v = n[m]), u_(a, m, $p(v, e, t, m, n, o));
  }), a;
}
var Nhe = 4;
function Xy(n) {
  return $p(n, Nhe);
}
var $he = 1, Bhe = 4;
function Sn(n) {
  return $p(n, $he | Bhe);
}
var Vhe = "__lodash_hash_undefined__";
function zhe(n) {
  return this.__data__.set(n, Vhe), this;
}
function Fhe(n) {
  return this.__data__.has(n);
}
function hg(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.__data__ = new xu(); ++e < t; )
    this.add(n[e]);
}
hg.prototype.add = hg.prototype.push = zhe;
hg.prototype.has = Fhe;
function Qhe(n, e) {
  for (var t = -1, r = n == null ? 0 : n.length; ++t < r; )
    if (e(n[t], t, n))
      return !0;
  return !1;
}
function pL(n, e) {
  return n.has(e);
}
var Zhe = 1, Whe = 2;
function kj(n, e, t, r, i, o) {
  var a = t & Zhe, s = n.length, l = e.length;
  if (s != l && !(a && l > s))
    return !1;
  var u = o.get(n), c = o.get(e);
  if (u && c)
    return u == e && c == n;
  var h = -1, f = !0, d = t & Whe ? new hg() : void 0;
  for (o.set(n, e), o.set(e, n); ++h < s; ) {
    var p = n[h], g = e[h];
    if (r)
      var v = a ? r(g, p, h, e, n, o) : r(p, g, h, n, e, o);
    if (v !== void 0) {
      if (v)
        continue;
      f = !1;
      break;
    }
    if (d) {
      if (!Qhe(e, function(m, y) {
        if (!pL(d, y) && (p === m || i(p, m, t, r, o)))
          return d.push(y);
      })) {
        f = !1;
        break;
      }
    } else if (!(p === g || i(p, g, t, r, o))) {
      f = !1;
      break;
    }
  }
  return o.delete(n), o.delete(e), f;
}
function Ghe(n) {
  var e = -1, t = Array(n.size);
  return n.forEach(function(r, i) {
    t[++e] = [i, r];
  }), t;
}
function gL(n) {
  var e = -1, t = Array(n.size);
  return n.forEach(function(r) {
    t[++e] = r;
  }), t;
}
var jhe = 1, Hhe = 2, qhe = "[object Boolean]", Yhe = "[object Date]", Xhe = "[object Error]", Uhe = "[object Map]", Khe = "[object Number]", Jhe = "[object RegExp]", efe = "[object Set]", tfe = "[object String]", nfe = "[object Symbol]", rfe = "[object ArrayBuffer]", ife = "[object DataView]", h3 = ka ? ka.prototype : void 0, i2 = h3 ? h3.valueOf : void 0;
function ofe(n, e, t, r, i, o, a) {
  switch (t) {
    case ife:
      if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
        return !1;
      n = n.buffer, e = e.buffer;
    case rfe:
      return !(n.byteLength != e.byteLength || !o(new sx(n), new sx(e)));
    case qhe:
    case Yhe:
    case Khe:
      return iv(+n, +e);
    case Xhe:
      return n.name == e.name && n.message == e.message;
    case Jhe:
    case tfe:
      return n == e + "";
    case Uhe:
      var s = Ghe;
    case efe:
      var l = r & jhe;
      if (s || (s = gL), n.size != e.size && !l)
        return !1;
      var u = a.get(n);
      if (u)
        return u == e;
      r |= Hhe, a.set(n, e);
      var c = kj(s(n), s(e), r, i, o, a);
      return a.delete(n), c;
    case nfe:
      if (i2)
        return i2.call(n) == i2.call(e);
  }
  return !1;
}
var afe = 1, sfe = Object.prototype, lfe = sfe.hasOwnProperty;
function ufe(n, e, t, r, i, o) {
  var a = t & afe, s = jk(n), l = s.length, u = jk(e), c = u.length;
  if (l != c && !a)
    return !1;
  for (var h = l; h--; ) {
    var f = s[h];
    if (!(a ? f in e : lfe.call(e, f)))
      return !1;
  }
  var d = o.get(n), p = o.get(e);
  if (d && p)
    return d == e && p == n;
  var g = !0;
  o.set(n, e), o.set(e, n);
  for (var v = a; ++h < l; ) {
    f = s[h];
    var m = n[f], y = e[f];
    if (r)
      var b = a ? r(y, m, f, e, n, o) : r(m, y, f, n, e, o);
    if (!(b === void 0 ? m === y || i(m, y, t, r, o) : b)) {
      g = !1;
      break;
    }
    v || (v = f == "constructor");
  }
  if (g && !v) {
    var O = n.constructor, w = e.constructor;
    O != w && "constructor" in n && "constructor" in e && !(typeof O == "function" && O instanceof O && typeof w == "function" && w instanceof w) && (g = !1);
  }
  return o.delete(n), o.delete(e), g;
}
var cfe = 1, f3 = "[object Arguments]", d3 = "[object Array]", i1 = "[object Object]", hfe = Object.prototype, p3 = hfe.hasOwnProperty;
function ffe(n, e, t, r, i, o) {
  var a = Yr(n), s = Yr(e), l = a ? d3 : cg(n), u = s ? d3 : cg(e);
  l = l == f3 ? i1 : l, u = u == f3 ? i1 : u;
  var c = l == i1, h = u == i1, f = l == u;
  if (f && lg(n)) {
    if (!lg(e))
      return !1;
    a = !0, c = !1;
  }
  if (f && !c)
    return o || (o = new as()), a || c_(n) ? kj(n, e, t, r, i, o) : ofe(n, e, l, t, r, i, o);
  if (!(t & cfe)) {
    var d = c && p3.call(n, "__wrapped__"), p = h && p3.call(e, "__wrapped__");
    if (d || p) {
      var g = d ? n.value() : n, v = p ? e.value() : e;
      return o || (o = new as()), i(g, v, t, r, o);
    }
  }
  return f ? (o || (o = new as()), ufe(n, e, t, r, i, o)) : !1;
}
function p_(n, e, t, r, i) {
  return n === e ? !0 : n == null || e == null || !Pa(n) && !Pa(e) ? n !== n && e !== e : ffe(n, e, t, r, p_, i);
}
var dfe = 1, pfe = 2;
function gfe(n, e, t, r) {
  var i = t.length, o = i, a = !r;
  if (n == null)
    return !o;
  for (n = Object(n); i--; ) {
    var s = t[i];
    if (a && s[2] ? s[1] !== n[s[0]] : !(s[0] in n))
      return !1;
  }
  for (; ++i < o; ) {
    s = t[i];
    var l = s[0], u = n[l], c = s[1];
    if (a && s[2]) {
      if (u === void 0 && !(l in n))
        return !1;
    } else {
      var h = new as();
      if (r)
        var f = r(u, c, l, n, e, h);
      if (!(f === void 0 ? p_(c, u, dfe | pfe, r, h) : f))
        return !1;
    }
  }
  return !0;
}
function Pj(n) {
  return n === n && !tr(n);
}
function vfe(n) {
  for (var e = av(n), t = e.length; t--; ) {
    var r = e[t], i = n[r];
    e[t] = [r, i, Pj(i)];
  }
  return e;
}
function Ej(n, e) {
  return function(t) {
    return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t));
  };
}
function mfe(n) {
  var e = vfe(n);
  return e.length == 1 && e[0][2] ? Ej(e[0][0], e[0][1]) : function(t) {
    return t === n || gfe(t, n, e);
  };
}
function yfe(n, e) {
  return n != null && e in Object(n);
}
function Mj(n, e, t) {
  e = lv(e, n);
  for (var r = -1, i = e.length, o = !1; ++r < i; ) {
    var a = uv(e[r]);
    if (!(o = n != null && t(n, a)))
      break;
    n = n[a];
  }
  return o || ++r != i ? o : (i = n == null ? 0 : n.length, !!i && iL(i) && s_(a, i) && (Yr(n) || sg(n)));
}
function Dj(n, e) {
  return n != null && Mj(n, e, yfe);
}
var bfe = 1, Ofe = 2;
function wfe(n, e) {
  return aL(n) && Pj(e) ? Ej(uv(n), e) : function(t) {
    var r = ga(t, n);
    return r === void 0 && r === e ? Dj(t, n) : p_(e, r, bfe | Ofe);
  };
}
function xfe(n) {
  return function(e) {
    return e == null ? void 0 : e[n];
  };
}
function Sfe(n) {
  return function(e) {
    return db(e, n);
  };
}
function _fe(n) {
  return aL(n) ? xfe(uv(n)) : Sfe(n);
}
function cv(n) {
  return typeof n == "function" ? n : n == null ? nh : typeof n == "object" ? Yr(n) ? wfe(n[0], n[1]) : mfe(n) : _fe(n);
}
function Cfe(n, e, t, r) {
  for (var i = -1, o = n == null ? 0 : n.length; ++i < o; ) {
    var a = n[i];
    e(r, a, t(a), n);
  }
  return r;
}
function Afe(n) {
  return function(e, t, r) {
    for (var i = -1, o = Object(e), a = r(e), s = a.length; s--; ) {
      var l = a[n ? s : ++i];
      if (t(o[l], l, o) === !1)
        break;
    }
    return e;
  };
}
var Lj = Afe();
function Tfe(n, e) {
  return n && Lj(n, e, av);
}
function kfe(n, e) {
  return function(t, r) {
    if (t == null)
      return t;
    if (!rh(t))
      return n(t, r);
    for (var i = t.length, o = e ? i : -1, a = Object(t); (e ? o-- : ++o < i) && r(a[o], o, a) !== !1; )
      ;
    return t;
  };
}
var Ij = kfe(Tfe);
function Pfe(n, e, t, r) {
  return Ij(n, function(i, o, a) {
    e(r, i, t(i), a);
  }), r;
}
function Efe(n, e) {
  return function(t, r) {
    var i = Yr(t) ? Cfe : Pfe, o = e ? e() : {};
    return i(t, n, cv(r), o);
  };
}
var o2 = function() {
  return ys.Date.now();
}, Mfe = "Expected a function", Dfe = Math.max, Lfe = Math.min;
function kc(n, e, t) {
  var r, i, o, a, s, l, u = 0, c = !1, h = !1, f = !0;
  if (typeof n != "function")
    throw new TypeError(Mfe);
  e = Rp(e) || 0, tr(t) && (c = !!t.leading, h = "maxWait" in t, o = h ? Dfe(Rp(t.maxWait) || 0, e) : o, f = "trailing" in t ? !!t.trailing : f);
  function d(x) {
    var S = r, _ = i;
    return r = i = void 0, u = x, a = n.apply(_, S), a;
  }
  function p(x) {
    return u = x, s = setTimeout(m, e), c ? d(x) : a;
  }
  function g(x) {
    var S = x - l, _ = x - u, C = e - S;
    return h ? Lfe(C, o - _) : C;
  }
  function v(x) {
    var S = x - l, _ = x - u;
    return l === void 0 || S >= e || S < 0 || h && _ >= o;
  }
  function m() {
    var x = o2();
    if (v(x))
      return y(x);
    s = setTimeout(m, g(x));
  }
  function y(x) {
    return s = void 0, f && r ? d(x) : (r = i = void 0, a);
  }
  function b() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = i = s = void 0;
  }
  function O() {
    return s === void 0 ? a : y(o2());
  }
  function w() {
    var x = o2(), S = v(x);
    if (r = arguments, i = this, l = x, S) {
      if (s === void 0)
        return p(l);
      if (h)
        return clearTimeout(s), s = setTimeout(m, e), d(l);
    }
    return s === void 0 && (s = setTimeout(m, e)), a;
  }
  return w.cancel = b, w.flush = O, w;
}
var Rj = Object.prototype, Ife = Rj.hasOwnProperty, Rfe = ov(function(n, e) {
  n = Object(n);
  var t = -1, r = e.length, i = r > 2 ? e[2] : void 0;
  for (i && jy(e[0], e[1], i) && (r = 1); ++t < r; )
    for (var o = e[t], a = sv(o), s = -1, l = a.length; ++s < l; ) {
      var u = a[s], c = n[u];
      (c === void 0 || iv(c, Rj[u]) && !Ife.call(n, u)) && (n[u] = o[u]);
    }
  return n;
});
function Yk(n, e, t) {
  (t !== void 0 && !iv(n[e], t) || t === void 0 && !(e in n)) && l_(n, e, t);
}
function lx(n) {
  return Pa(n) && rh(n);
}
function Xk(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
function Nfe(n) {
  return wd(n, sv(n));
}
function $fe(n, e, t, r, i, o, a) {
  var s = Xk(n, t), l = Xk(e, t), u = a.get(l);
  if (u) {
    Yk(n, t, u);
    return;
  }
  var c = o ? o(s, l, t + "", n, e, a) : void 0, h = c === void 0;
  if (h) {
    var f = Yr(l), d = !f && lg(l), p = !f && !d && c_(l);
    c = l, f || d || p ? Yr(s) ? c = s : lx(s) ? c = BG(s) : d ? (h = !1, c = yj(l, !0)) : p ? (h = !1, c = Sj(l, !0)) : c = [] : bs(l) || sg(l) ? (c = s, sg(s) ? c = Nfe(s) : (!tr(s) || nL(s)) && (c = _j(l))) : h = !1;
  }
  h && (a.set(l, c), i(c, l, r, o, a), a.delete(l)), Yk(n, t, c);
}
function g_(n, e, t, r, i) {
  n !== e && Lj(e, function(o, a) {
    if (i || (i = new as()), tr(o))
      $fe(n, e, a, t, g_, r, i);
    else {
      var s = r ? r(Xk(n, a), o, a + "", n, e, i) : void 0;
      s === void 0 && (s = o), Yk(n, a, s);
    }
  }, sv);
}
function Nj(n, e, t, r, i, o) {
  return tr(n) && tr(e) && (o.set(e, n), g_(n, e, void 0, Nj, o), o.delete(e)), n;
}
var Bfe = oL(function(n, e, t, r) {
  g_(n, e, t, r);
});
const Vfe = Bfe;
var $j = ov(function(n) {
  return n.push(void 0, Nj), $G(Vfe, void 0, n);
});
function Bj(n, e, t) {
  for (var r = -1, i = n == null ? 0 : n.length; ++r < i; )
    if (t(e, n[r]))
      return !0;
  return !1;
}
var zfe = 200;
function Ffe(n, e, t, r) {
  var i = -1, o = zG, a = !0, s = n.length, l = [], u = e.length;
  if (!s)
    return l;
  t && (e = Mf(e, hb(t))), r ? (o = Bj, a = !1) : e.length >= zfe && (o = pL, a = !1, e = new hg(e));
  e:
    for (; ++i < s; ) {
      var c = n[i], h = t == null ? c : t(c);
      if (c = r || c !== 0 ? c : 0, a && h === h) {
        for (var f = u; f--; )
          if (e[f] === h)
            continue e;
        l.push(c);
      } else
        o(e, h, r) || l.push(c);
    }
  return l;
}
var Qfe = ov(function(n, e) {
  return lx(n) ? Ffe(n, xd(e, 1, lx, !0)) : [];
});
function Zfe(n) {
  var e = n == null ? 0 : n.length;
  return e ? n[e - 1] : void 0;
}
var Wfe = Math.max;
function bFt(n, e, t) {
  var r = n == null ? 0 : n.length;
  if (!r)
    return -1;
  var i = t == null ? 0 : tL(t);
  return i < 0 && (i = Wfe(r + i, 0)), rL(n, cv(e), i);
}
var Gfe = Math.max, jfe = Math.min;
function Hfe(n, e, t) {
  var r = n == null ? 0 : n.length;
  if (!r)
    return -1;
  var i = r - 1;
  return t !== void 0 && (i = tL(t), i = t < 0 ? Gfe(r + i, 0) : jfe(i, r - 1)), rL(n, cv(e), i, !0);
}
function Vj(n, e) {
  var t = -1, r = rh(n) ? Array(n.length) : [];
  return Ij(n, function(i, o, a) {
    r[++t] = e(i, o, a);
  }), r;
}
function qfe(n, e) {
  var t = Yr(n) ? Mf : Vj;
  return t(n, cv(e));
}
function Yfe(n, e) {
  return xd(qfe(n, e), 1);
}
var Xfe = 1 / 0;
function Ufe(n) {
  var e = n == null ? 0 : n.length;
  return e ? xd(n, Xfe) : [];
}
function ux(n) {
  for (var e = -1, t = n == null ? 0 : n.length, r = {}; ++e < t; ) {
    var i = n[e];
    r[i[0]] = i[1];
  }
  return r;
}
var Kfe = Object.prototype, Jfe = Kfe.hasOwnProperty, g3 = Efe(function(n, e, t) {
  Jfe.call(n, t) ? n[t].push(e) : l_(n, t, [e]);
});
function ede(n, e) {
  return n > e;
}
var tde = Object.prototype, nde = tde.hasOwnProperty;
function rde(n, e) {
  return n != null && nde.call(n, e);
}
function o1(n, e) {
  return n != null && Mj(n, e, rde);
}
function ide(n, e) {
  return e.length < 2 ? n : db(n, cL(e, 0, -1));
}
var ode = "[object Boolean]";
function OFt(n) {
  return n === !0 || n === !1 || Pa(n) && Ou(n) == ode;
}
var ade = "[object Map]", sde = "[object Set]", lde = Object.prototype, ude = lde.hasOwnProperty;
function zj(n) {
  if (n == null)
    return !0;
  if (rh(n) && (Yr(n) || typeof n == "string" || typeof n.splice == "function" || lg(n) || c_(n) || sg(n)))
    return !n.length;
  var e = cg(n);
  if (e == ade || e == sde)
    return !n.size;
  if (cb(n))
    return !HG(n).length;
  for (var t in n)
    if (ude.call(n, t))
      return !1;
  return !0;
}
function hr(n, e) {
  return p_(n, e);
}
var cde = "[object Number]";
function v3(n) {
  return typeof n == "number" || Pa(n) && Ou(n) == cde;
}
function _o(n) {
  return n == null;
}
function Fj(n) {
  return n === void 0;
}
var hde = hL(function(n, e, t) {
  return n + (t ? "-" : "") + e.toLowerCase();
});
const wFt = hde;
var fde = rj("toLowerCase");
function dde(n, e) {
  return n < e;
}
function Qj(n, e, t) {
  for (var r = -1, i = n.length; ++r < i; ) {
    var o = n[r], a = e(o);
    if (a != null && (s === void 0 ? a === a && !vl(a) : t(a, s)))
      var s = a, l = o;
  }
  return l;
}
function pde(n) {
  return n && n.length ? Qj(n, nh, ede) : void 0;
}
function gde(n, e) {
  for (var t, r = -1, i = n.length; ++r < i; ) {
    var o = e(n[r]);
    o !== void 0 && (t = t === void 0 ? o : t + o);
  }
  return t;
}
var vde = NaN;
function mde(n, e) {
  var t = n == null ? 0 : n.length;
  return t ? gde(n, e) / t : vde;
}
function xFt(n) {
  return mde(n, nh);
}
var er = oL(function(n, e, t) {
  g_(n, e, t);
});
function SFt(n) {
  return n && n.length ? Qj(n, nh, dde) : void 0;
}
function Zj(n, e) {
  return e = lv(e, n), n = ide(n, e), n == null || delete n[uv(Zfe(e))];
}
function yde(n) {
  return bs(n) ? void 0 : n;
}
var bde = 1, Ode = 2, wde = 4, _Ft = qG(function(n, e) {
  var t = {};
  if (n == null)
    return t;
  var r = !1;
  e = Mf(e, function(o) {
    return o = lv(o, n), r || (r = o.length > 1), o;
  }), wd(n, xj(n), t), r && (t = $p(t, bde | Ode | wde, yde));
  for (var i = e.length; i--; )
    Zj(t, e[i]);
  return t;
});
function Wj(n, e, t, r) {
  if (!tr(n))
    return n;
  e = lv(e, n);
  for (var i = -1, o = e.length, a = o - 1, s = n; s != null && ++i < o; ) {
    var l = uv(e[i]), u = t;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return n;
    if (i != a) {
      var c = s[l];
      u = r ? r(c, l, s) : void 0, u === void 0 && (u = tr(c) ? c : s_(e[i + 1]) ? [] : {});
    }
    u_(s, l, u), s = s[l];
  }
  return n;
}
function xde(n, e, t) {
  for (var r = -1, i = e.length, o = {}; ++r < i; ) {
    var a = e[r], s = db(n, a);
    t(s, a) && Wj(o, lv(a, n), s);
  }
  return o;
}
function Sde(n, e) {
  var t = n.length;
  for (n.sort(e); t--; )
    n[t] = n[t].value;
  return n;
}
function _de(n, e) {
  if (n !== e) {
    var t = n !== void 0, r = n === null, i = n === n, o = vl(n), a = e !== void 0, s = e === null, l = e === e, u = vl(e);
    if (!s && !u && !o && n > e || o && a && l && !s && !u || r && a && l || !t && l || !i)
      return 1;
    if (!r && !o && !u && n < e || u && t && i && !r && !o || s && t && i || !a && i || !l)
      return -1;
  }
  return 0;
}
function Cde(n, e, t) {
  for (var r = -1, i = n.criteria, o = e.criteria, a = i.length, s = t.length; ++r < a; ) {
    var l = _de(i[r], o[r]);
    if (l) {
      if (r >= s)
        return l;
      var u = t[r];
      return l * (u == "desc" ? -1 : 1);
    }
  }
  return n.index - e.index;
}
function Ade(n, e, t) {
  e.length ? e = Mf(e, function(o) {
    return Yr(o) ? function(a) {
      return db(a, o.length === 1 ? o[0] : o);
    } : o;
  }) : e = [nh];
  var r = -1;
  e = Mf(e, hb(cv));
  var i = Vj(n, function(o, a, s) {
    var l = Mf(e, function(u) {
      return u(o);
    });
    return { criteria: l, index: ++r, value: o };
  });
  return Sde(i, function(o, a) {
    return Cde(o, a, t);
  });
}
function Tde(n, e) {
  return xde(n, e, function(t, r) {
    return Dj(n, r);
  });
}
var Uk = qG(function(n, e) {
  return n == null ? {} : Tde(n, e);
});
function kde(n, e, t) {
  return n == null ? n : Wj(n, e, t);
}
var Gj = ov(function(n, e) {
  if (n == null)
    return [];
  var t = e.length;
  return t > 1 && jy(n, e[0], e[1]) ? e = [] : t > 2 && jy(e[0], e[1], e[2]) && (e = [e[0]]), Ade(n, xd(e, 1), []);
}), Pde = 4294967295, Ede = Pde - 1, Mde = Math.floor, Dde = Math.min;
function jj(n, e, t, r) {
  var i = 0, o = n == null ? 0 : n.length;
  if (o === 0)
    return 0;
  e = t(e);
  for (var a = e !== e, s = e === null, l = vl(e), u = e === void 0; i < o; ) {
    var c = Mde((i + o) / 2), h = t(n[c]), f = h !== void 0, d = h === null, p = h === h, g = vl(h);
    if (a)
      var v = r || p;
    else
      u ? v = p && (r || f) : s ? v = p && f && (r || !d) : l ? v = p && f && !d && (r || !g) : d || g ? v = !1 : v = r ? h <= e : h < e;
    v ? i = c + 1 : o = c;
  }
  return Dde(o, Ede);
}
var Lde = 4294967295, Ide = Lde >>> 1;
function Rde(n, e, t) {
  var r = 0, i = n == null ? r : n.length;
  if (typeof e == "number" && e === e && i <= Ide) {
    for (; r < i; ) {
      var o = r + i >>> 1, a = n[o];
      a !== null && !vl(a) && (t ? a <= e : a < e) ? r = o + 1 : i = o;
    }
    return i;
  }
  return jj(n, e, nh, t);
}
function Nde(n, e) {
  return Rde(n, e);
}
function $de(n, e, t) {
  return jj(n, e, cv(t));
}
var Bde = hL(function(n, e, t) {
  return n + (t ? " " : "") + ax(e);
}), Vde = "Expected a function";
function zde(n, e, t) {
  var r = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(Vde);
  return tr(t) && (r = "leading" in t ? !!t.leading : r, i = "trailing" in t ? !!t.trailing : i), kc(n, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
var Fde = 1 / 0, Qde = Np && 1 / gL(new Np([, -0]))[1] == Fde ? function(n) {
  return new Np(n);
} : Uae, Zde = 200;
function Hj(n, e, t) {
  var r = -1, i = zG, o = n.length, a = !0, s = [], l = s;
  if (t)
    a = !1, i = Bj;
  else if (o >= Zde) {
    var u = e ? null : Qde(n);
    if (u)
      return gL(u);
    a = !1, i = pL, l = new hg();
  } else
    l = e ? [] : s;
  e:
    for (; ++r < o; ) {
      var c = n[r], h = e ? e(c) : c;
      if (c = t || c !== 0 ? c : 0, a && h === h) {
        for (var f = l.length; f--; )
          if (l[f] === h)
            continue e;
        e && l.push(h), s.push(c);
      } else
        i(l, h, t) || (l !== s && l.push(h), s.push(c));
    }
  return s;
}
var m3 = ov(function(n) {
  return Hj(xd(n, 1, lx, !0));
});
function qj(n) {
  return n && n.length ? Hj(n) : [];
}
function CFt(n, e) {
  return n == null ? !0 : Zj(n, e);
}
/*! Element Plus Icons Vue v2.3.1 */
var Wde = /* @__PURE__ */ U({
  name: "ArrowDown",
  __name: "arrow-down",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
      })
    ]));
  }
}), pb = Wde, Gde = /* @__PURE__ */ U({
  name: "ArrowLeft",
  __name: "arrow-left",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), vL = Gde, jde = /* @__PURE__ */ U({
  name: "ArrowRight",
  __name: "arrow-right",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), Sd = jde, Hde = /* @__PURE__ */ U({
  name: "ArrowUp",
  __name: "arrow-up",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
      })
    ]));
  }
}), Yj = Hde, qde = /* @__PURE__ */ U({
  name: "CaretRight",
  __name: "caret-right",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M384 192v640l384-320.064z"
      })
    ]));
  }
}), Yde = qde, Xde = /* @__PURE__ */ U({
  name: "Check",
  __name: "check",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      })
    ]));
  }
}), mL = Xde, Ude = /* @__PURE__ */ U({
  name: "CircleCheck",
  __name: "circle-check",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      J("path", {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
      })
    ]));
  }
}), Xj = Ude, Kde = /* @__PURE__ */ U({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
}), Uj = Kde, Jde = /* @__PURE__ */ U({
  name: "CircleClose",
  __name: "circle-close",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
      }),
      J("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), gb = Jde, epe = /* @__PURE__ */ U({
  name: "Close",
  __name: "close",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
}), Pc = epe, tpe = /* @__PURE__ */ U({
  name: "CopyDocument",
  __name: "copy-document",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M768 832a128 128 0 0 1-128 128H192A128 128 0 0 1 64 832V384a128 128 0 0 1 128-128v64a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64z"
      }),
      J("path", {
        fill: "currentColor",
        d: "M384 128a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64zm0-64h448a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H384a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64"
      })
    ]));
  }
}), AFt = tpe, npe = /* @__PURE__ */ U({
  name: "DArrowLeft",
  __name: "d-arrow-left",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
      })
    ]));
  }
}), rpe = npe, ipe = /* @__PURE__ */ U({
  name: "DArrowRight",
  __name: "d-arrow-right",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
      })
    ]));
  }
}), ope = ipe, ape = /* @__PURE__ */ U({
  name: "Delete",
  __name: "delete",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
      })
    ]));
  }
}), TFt = ape, spe = /* @__PURE__ */ U({
  name: "Download",
  __name: "download",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64z"
      })
    ]));
  }
}), kFt = spe, lpe = /* @__PURE__ */ U({
  name: "Edit",
  __name: "edit",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M832 512a32 32 0 1 1 64 0v352a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h352a32 32 0 0 1 0 64H192v640h640z"
      }),
      J("path", {
        fill: "currentColor",
        d: "m469.952 554.24 52.8-7.552L847.104 222.4a32 32 0 1 0-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 0 1 0 135.808l-331.84 331.84a32 32 0 0 1-18.112 9.088L436.8 623.68a32 32 0 0 1-36.224-36.224l15.104-105.6a32 32 0 0 1 9.024-18.112l331.904-331.84a96 96 0 0 1 135.744 0z"
      })
    ]));
  }
}), PFt = lpe, upe = /* @__PURE__ */ U({
  name: "Files",
  __name: "files",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M128 384v448h768V384zm-32-64h832a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32m64-128h704v64H160zm96-128h512v64H256z"
      })
    ]));
  }
}), EFt = upe, cpe = /* @__PURE__ */ U({
  name: "Fold",
  __name: "fold",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M896 192H128v128h768zm0 256H384v128h512zm0 256H128v128h768zM320 384 128 512l192 128z"
      })
    ]));
  }
}), MFt = cpe, hpe = /* @__PURE__ */ U({
  name: "FullScreen",
  __name: "full-screen",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
      })
    ]));
  }
}), DFt = hpe, fpe = /* @__PURE__ */ U({
  name: "Help",
  __name: "help",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "m759.936 805.248-90.944-91.008A254.912 254.912 0 0 1 512 768a254.912 254.912 0 0 1-156.992-53.76l-90.944 91.008A382.464 382.464 0 0 0 512 896c94.528 0 181.12-34.176 247.936-90.752m45.312-45.312A382.464 382.464 0 0 0 896 512c0-94.528-34.176-181.12-90.752-247.936l-91.008 90.944C747.904 398.4 768 452.864 768 512c0 59.136-20.096 113.6-53.76 156.992l91.008 90.944zm-45.312-541.184A382.464 382.464 0 0 0 512 128c-94.528 0-181.12 34.176-247.936 90.752l90.944 91.008A254.912 254.912 0 0 1 512 256c59.136 0 113.6 20.096 156.992 53.76l90.944-91.008zm-541.184 45.312A382.464 382.464 0 0 0 128 512c0 94.528 34.176 181.12 90.752 247.936l91.008-90.944A254.912 254.912 0 0 1 256 512c0-59.136 20.096-113.6 53.76-156.992zm417.28 394.496a194.56 194.56 0 0 0 22.528-22.528C686.912 602.56 704 559.232 704 512a191.232 191.232 0 0 0-67.968-146.56A191.296 191.296 0 0 0 512 320a191.232 191.232 0 0 0-146.56 67.968C337.088 421.44 320 464.768 320 512a191.232 191.232 0 0 0 67.968 146.56C421.44 686.912 464.768 704 512 704c47.296 0 90.56-17.088 124.032-45.44zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), LFt = fpe, dpe = /* @__PURE__ */ U({
  name: "Hide",
  __name: "hide",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
      }),
      J("path", {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
      })
    ]));
  }
}), ppe = dpe, gpe = /* @__PURE__ */ U({
  name: "InfoFilled",
  __name: "info-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
}), Kj = gpe, vpe = /* @__PURE__ */ U({
  name: "Loading",
  __name: "loading",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
      })
    ]));
  }
}), _d = vpe, mpe = /* @__PURE__ */ U({
  name: "MagicStick",
  __name: "magic-stick",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64h64v192h-64zm0 576h64v192h-64zM160 480v-64h192v64zm576 0v-64h192v64zM249.856 199.04l45.248-45.184L430.848 289.6 385.6 334.848 249.856 199.104zM657.152 606.4l45.248-45.248 135.744 135.744-45.248 45.248zM114.048 923.2 68.8 877.952l316.8-316.8 45.248 45.248zM702.4 334.848 657.152 289.6l135.744-135.744 45.248 45.248z"
      })
    ]));
  }
}), IFt = mpe, ype = /* @__PURE__ */ U({
  name: "Minus",
  __name: "minus",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
      })
    ]));
  }
}), bpe = ype, Ope = /* @__PURE__ */ U({
  name: "MoreFilled",
  __name: "more-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
      })
    ]));
  }
}), y3 = Ope, wpe = /* @__PURE__ */ U({
  name: "Plus",
  __name: "plus",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), Jj = wpe, xpe = /* @__PURE__ */ U({
  name: "QuestionFilled",
  __name: "question-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
      })
    ]));
  }
}), RFt = xpe, Spe = /* @__PURE__ */ U({
  name: "RefreshLeft",
  __name: "refresh-left",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
      })
    ]));
  }
}), NFt = Spe, _pe = /* @__PURE__ */ U({
  name: "RefreshRight",
  __name: "refresh-right",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
      })
    ]));
  }
}), $Ft = _pe, Cpe = /* @__PURE__ */ U({
  name: "Refresh",
  __name: "refresh",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M771.776 794.88A384 384 0 0 1 128 512h64a320 320 0 0 0 555.712 216.448H654.72a32 32 0 1 1 0-64h149.056a32 32 0 0 1 32 32v148.928a32 32 0 1 1-64 0v-50.56zM276.288 295.616h92.992a32 32 0 0 1 0 64H220.16a32 32 0 0 1-32-32V178.56a32 32 0 0 1 64 0v50.56A384 384 0 0 1 896.128 512h-64a320 320 0 0 0-555.776-216.384z"
      })
    ]));
  }
}), BFt = Cpe, Ape = /* @__PURE__ */ U({
  name: "Refrigerator",
  __name: "refrigerator",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M256 448h512V160a32 32 0 0 0-32-32H288a32 32 0 0 0-32 32zm0 64v352a32 32 0 0 0 32 32h448a32 32 0 0 0 32-32V512zm32-448h448a96 96 0 0 1 96 96v704a96 96 0 0 1-96 96H288a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96m32 224h64v96h-64zm0 288h64v96h-64z"
      })
    ]));
  }
}), VFt = Ape, Tpe = /* @__PURE__ */ U({
  name: "RemoveFilled",
  __name: "remove-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896M288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512"
      })
    ]));
  }
}), zFt = Tpe, kpe = /* @__PURE__ */ U({
  name: "Search",
  __name: "search",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
      })
    ]));
  }
}), Ppe = kpe, Epe = /* @__PURE__ */ U({
  name: "Select",
  __name: "select",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M77.248 415.04a64 64 0 0 1 90.496 0l226.304 226.304L846.528 188.8a64 64 0 1 1 90.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 0 1 0-90.496z"
      })
    ]));
  }
}), FFt = Epe, Mpe = /* @__PURE__ */ U({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), e7 = Mpe, Dpe = /* @__PURE__ */ U({
  name: "Tickets",
  __name: "tickets",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M192 128v768h640V128zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h192v64H320zm0 384h384v64H320z"
      })
    ]));
  }
}), QFt = Dpe, Lpe = /* @__PURE__ */ U({
  name: "Tools",
  __name: "tools",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72-166.272 96-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96 54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0 192 192 0 0 0 384 0"
      })
    ]));
  }
}), ZFt = Lpe, Ipe = /* @__PURE__ */ U({
  name: "TrendCharts",
  __name: "trend-charts",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M128 896V128h768v768zm291.712-327.296 128 102.4 180.16-201.792-47.744-42.624-139.84 156.608-128-102.4-180.16 201.792 47.744 42.624 139.84-156.608zM816 352a48 48 0 1 0-96 0 48 48 0 0 0 96 0"
      })
    ]));
  }
}), WFt = Ipe, Rpe = /* @__PURE__ */ U({
  name: "Upload",
  __name: "upload",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248z"
      })
    ]));
  }
}), GFt = Rpe, Npe = /* @__PURE__ */ U({
  name: "View",
  __name: "view",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
      })
    ]));
  }
}), $pe = Npe, Bpe = /* @__PURE__ */ U({
  name: "WarnTriangleFilled",
  __name: "warn-triangle-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      "xml:space": "preserve",
      style: { "enable-background": "new 0 0 1024 1024" },
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M928.99 755.83 574.6 203.25c-12.89-20.16-36.76-32.58-62.6-32.58s-49.71 12.43-62.6 32.58L95.01 755.83c-12.91 20.12-12.9 44.91.01 65.03 12.92 20.12 36.78 32.51 62.59 32.49h708.78c25.82.01 49.68-12.37 62.59-32.49 12.91-20.12 12.92-44.91.01-65.03M554.67 768h-85.33v-85.33h85.33zm0-426.67v298.66h-85.33V341.32z"
      })
    ]));
  }
}), jFt = Bpe, Vpe = /* @__PURE__ */ U({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
}), yL = Vpe, zpe = /* @__PURE__ */ U({
  name: "Warning",
  __name: "warning",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m48-176a48 48 0 1 1-96 0 48 48 0 0 1 96 0m-48-464a32 32 0 0 1 32 32v288a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
      })
    ]));
  }
}), HFt = zpe, Fpe = /* @__PURE__ */ U({
  name: "ZoomIn",
  __name: "zoom-in",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), qFt = Fpe, Qpe = /* @__PURE__ */ U({
  name: "ZoomOut",
  __name: "zoom-out",
  setup(n) {
    return (e, t) => (V(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      J("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
      })
    ]));
  }
}), YFt = Qpe;
function hf() {
  return hf = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, hf.apply(this, arguments);
}
function Zpe(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n, Uy(n, e);
}
function Kk(n) {
  return Kk = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Kk(n);
}
function Uy(n, e) {
  return Uy = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, Uy(n, e);
}
function Wpe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function ew(n, e, t) {
  return Wpe() ? ew = Reflect.construct.bind() : ew = function(i, o, a) {
    var s = [null];
    s.push.apply(s, o);
    var l = Function.bind.apply(i, s), u = new l();
    return a && Uy(u, a.prototype), u;
  }, ew.apply(null, arguments);
}
function Gpe(n) {
  return Function.toString.call(n).indexOf("[native code]") !== -1;
}
function Jk(n) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Jk = function(r) {
    if (r === null || !Gpe(r))
      return r;
    if (typeof r != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof e < "u") {
      if (e.has(r))
        return e.get(r);
      e.set(r, i);
    }
    function i() {
      return ew(r, arguments, Kk(this).constructor);
    }
    return i.prototype = Object.create(r.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Uy(i, r);
  }, Jk(n);
}
var jpe = /%[sdj%]/g, t7 = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (t7 = function(e, t) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && t.every(function(r) {
    return typeof r == "string";
  }) && console.warn(e, t);
});
function eP(n) {
  if (!n || !n.length)
    return null;
  var e = {};
  return n.forEach(function(t) {
    var r = t.field;
    e[r] = e[r] || [], e[r].push(t);
  }), e;
}
function Wo(n) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    t[r - 1] = arguments[r];
  var i = 0, o = t.length;
  if (typeof n == "function")
    return n.apply(null, t);
  if (typeof n == "string") {
    var a = n.replace(jpe, function(s) {
      if (s === "%%")
        return "%";
      if (i >= o)
        return s;
      switch (s) {
        case "%s":
          return String(t[i++]);
        case "%d":
          return Number(t[i++]);
        case "%j":
          try {
            return JSON.stringify(t[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return a;
  }
  return n;
}
function Hpe(n) {
  return n === "string" || n === "url" || n === "hex" || n === "email" || n === "date" || n === "pattern";
}
function zr(n, e) {
  return !!(n == null || e === "array" && Array.isArray(n) && !n.length || Hpe(e) && typeof n == "string" && !n);
}
function qpe(n, e, t) {
  var r = [], i = 0, o = n.length;
  function a(s) {
    r.push.apply(r, s || []), i++, i === o && t(r);
  }
  n.forEach(function(s) {
    e(s, a);
  });
}
function b3(n, e, t) {
  var r = 0, i = n.length;
  function o(a) {
    if (a && a.length) {
      t(a);
      return;
    }
    var s = r;
    r = r + 1, s < i ? e(n[s], o) : t([]);
  }
  o([]);
}
function Ype(n) {
  var e = [];
  return Object.keys(n).forEach(function(t) {
    e.push.apply(e, n[t] || []);
  }), e;
}
var O3 = /* @__PURE__ */ function(n) {
  Zpe(e, n);
  function e(t, r) {
    var i;
    return i = n.call(this, "Async Validation Error") || this, i.errors = t, i.fields = r, i;
  }
  return e;
}(/* @__PURE__ */ Jk(Error));
function Xpe(n, e, t, r, i) {
  if (e.first) {
    var o = new Promise(function(f, d) {
      var p = function(m) {
        return r(m), m.length ? d(new O3(m, eP(m))) : f(i);
      }, g = Ype(n);
      b3(g, t, p);
    });
    return o.catch(function(f) {
      return f;
    }), o;
  }
  var a = e.firstFields === !0 ? Object.keys(n) : e.firstFields || [], s = Object.keys(n), l = s.length, u = 0, c = [], h = new Promise(function(f, d) {
    var p = function(v) {
      if (c.push.apply(c, v), u++, u === l)
        return r(c), c.length ? d(new O3(c, eP(c))) : f(i);
    };
    s.length || (r(c), f(i)), s.forEach(function(g) {
      var v = n[g];
      a.indexOf(g) !== -1 ? b3(v, t, p) : qpe(v, t, p);
    });
  });
  return h.catch(function(f) {
    return f;
  }), h;
}
function Upe(n) {
  return !!(n && n.message !== void 0);
}
function Kpe(n, e) {
  for (var t = n, r = 0; r < e.length; r++) {
    if (t == null)
      return t;
    t = t[e[r]];
  }
  return t;
}
function w3(n, e) {
  return function(t) {
    var r;
    return n.fullFields ? r = Kpe(e, n.fullFields) : r = e[t.field || n.fullField], Upe(t) ? (t.field = t.field || n.fullField, t.fieldValue = r, t) : {
      message: typeof t == "function" ? t() : t,
      fieldValue: r,
      field: t.field || n.fullField
    };
  };
}
function x3(n, e) {
  if (e) {
    for (var t in e)
      if (e.hasOwnProperty(t)) {
        var r = e[t];
        typeof r == "object" && typeof n[t] == "object" ? n[t] = hf({}, n[t], r) : n[t] = r;
      }
  }
  return n;
}
var n7 = function(e, t, r, i, o, a) {
  e.required && (!r.hasOwnProperty(e.field) || zr(t, a || e.type)) && i.push(Wo(o.messages.required, e.fullField));
}, Jpe = function(e, t, r, i, o) {
  (/^\s+$/.test(t) || t === "") && i.push(Wo(o.messages.whitespace, e.fullField));
}, a1, ege = function() {
  if (a1)
    return a1;
  var n = "[a-fA-F\\d:]", e = function(O) {
    return O && O.includeBoundaries ? "(?:(?<=\\s|^)(?=" + n + ")|(?<=" + n + ")(?=\\s|$))" : "";
  }, t = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", r = "[a-fA-F\\d]{1,4}", i = (`
(?:
(?:` + r + ":){7}(?:" + r + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + r + ":){6}(?:" + t + "|:" + r + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + r + ":){5}(?::" + t + "|(?::" + r + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + r + ":){4}(?:(?::" + r + "){0,1}:" + t + "|(?::" + r + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + r + ":){3}(?:(?::" + r + "){0,2}:" + t + "|(?::" + r + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + r + ":){2}(?:(?::" + r + "){0,3}:" + t + "|(?::" + r + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + r + ":){1}(?:(?::" + r + "){0,4}:" + t + "|(?::" + r + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + r + "){0,5}:" + t + "|(?::" + r + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), o = new RegExp("(?:^" + t + "$)|(?:^" + i + "$)"), a = new RegExp("^" + t + "$"), s = new RegExp("^" + i + "$"), l = function(O) {
    return O && O.exact ? o : new RegExp("(?:" + e(O) + t + e(O) + ")|(?:" + e(O) + i + e(O) + ")", "g");
  };
  l.v4 = function(b) {
    return b && b.exact ? a : new RegExp("" + e(b) + t + e(b), "g");
  }, l.v6 = function(b) {
    return b && b.exact ? s : new RegExp("" + e(b) + i + e(b), "g");
  };
  var u = "(?:(?:[a-z]+:)?//)", c = "(?:\\S+(?::\\S*)?@)?", h = l.v4().source, f = l.v6().source, d = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", p = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", g = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", v = "(?::\\d{2,5})?", m = '(?:[/?#][^\\s"]*)?', y = "(?:" + u + "|www\\.)" + c + "(?:localhost|" + h + "|" + f + "|" + d + p + g + ")" + v + m;
  return a1 = new RegExp("(?:^" + y + "$)", "i"), a1;
}, S3 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Rm = {
  integer: function(e) {
    return Rm.number(e) && parseInt(e, 10) === e;
  },
  float: function(e) {
    return Rm.number(e) && !Rm.integer(e);
  },
  array: function(e) {
    return Array.isArray(e);
  },
  regexp: function(e) {
    if (e instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(e);
    } catch {
      return !1;
    }
  },
  date: function(e) {
    return typeof e.getTime == "function" && typeof e.getMonth == "function" && typeof e.getYear == "function" && !isNaN(e.getTime());
  },
  number: function(e) {
    return isNaN(e) ? !1 : typeof e == "number";
  },
  object: function(e) {
    return typeof e == "object" && !Rm.array(e);
  },
  method: function(e) {
    return typeof e == "function";
  },
  email: function(e) {
    return typeof e == "string" && e.length <= 320 && !!e.match(S3.email);
  },
  url: function(e) {
    return typeof e == "string" && e.length <= 2048 && !!e.match(ege());
  },
  hex: function(e) {
    return typeof e == "string" && !!e.match(S3.hex);
  }
}, tge = function(e, t, r, i, o) {
  if (e.required && t === void 0) {
    n7(e, t, r, i, o);
    return;
  }
  var a = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = e.type;
  a.indexOf(s) > -1 ? Rm[s](t) || i.push(Wo(o.messages.types[s], e.fullField, e.type)) : s && typeof t !== e.type && i.push(Wo(o.messages.types[s], e.fullField, e.type));
}, nge = function(e, t, r, i, o) {
  var a = typeof e.len == "number", s = typeof e.min == "number", l = typeof e.max == "number", u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = t, h = null, f = typeof t == "number", d = typeof t == "string", p = Array.isArray(t);
  if (f ? h = "number" : d ? h = "string" : p && (h = "array"), !h)
    return !1;
  p && (c = t.length), d && (c = t.replace(u, "_").length), a ? c !== e.len && i.push(Wo(o.messages[h].len, e.fullField, e.len)) : s && !l && c < e.min ? i.push(Wo(o.messages[h].min, e.fullField, e.min)) : l && !s && c > e.max ? i.push(Wo(o.messages[h].max, e.fullField, e.max)) : s && l && (c < e.min || c > e.max) && i.push(Wo(o.messages[h].range, e.fullField, e.min, e.max));
}, Qd = "enum", rge = function(e, t, r, i, o) {
  e[Qd] = Array.isArray(e[Qd]) ? e[Qd] : [], e[Qd].indexOf(t) === -1 && i.push(Wo(o.messages[Qd], e.fullField, e[Qd].join(", ")));
}, ige = function(e, t, r, i, o) {
  if (e.pattern) {
    if (e.pattern instanceof RegExp)
      e.pattern.lastIndex = 0, e.pattern.test(t) || i.push(Wo(o.messages.pattern.mismatch, e.fullField, t, e.pattern));
    else if (typeof e.pattern == "string") {
      var a = new RegExp(e.pattern);
      a.test(t) || i.push(Wo(o.messages.pattern.mismatch, e.fullField, t, e.pattern));
    }
  }
}, jt = {
  required: n7,
  whitespace: Jpe,
  type: tge,
  range: nge,
  enum: rge,
  pattern: ige
}, oge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t, "string") && !e.required)
      return r();
    jt.required(e, t, i, a, o, "string"), zr(t, "string") || (jt.type(e, t, i, a, o), jt.range(e, t, i, a, o), jt.pattern(e, t, i, a, o), e.whitespace === !0 && jt.whitespace(e, t, i, a, o));
  }
  r(a);
}, age = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), t !== void 0 && jt.type(e, t, i, a, o);
  }
  r(a);
}, sge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (t === "" && (t = void 0), zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), t !== void 0 && (jt.type(e, t, i, a, o), jt.range(e, t, i, a, o));
  }
  r(a);
}, lge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), t !== void 0 && jt.type(e, t, i, a, o);
  }
  r(a);
}, uge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), zr(t) || jt.type(e, t, i, a, o);
  }
  r(a);
}, cge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), t !== void 0 && (jt.type(e, t, i, a, o), jt.range(e, t, i, a, o));
  }
  r(a);
}, hge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), t !== void 0 && (jt.type(e, t, i, a, o), jt.range(e, t, i, a, o));
  }
  r(a);
}, fge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (t == null && !e.required)
      return r();
    jt.required(e, t, i, a, o, "array"), t != null && (jt.type(e, t, i, a, o), jt.range(e, t, i, a, o));
  }
  r(a);
}, dge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), t !== void 0 && jt.type(e, t, i, a, o);
  }
  r(a);
}, pge = "enum", gge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o), t !== void 0 && jt[pge](e, t, i, a, o);
  }
  r(a);
}, vge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t, "string") && !e.required)
      return r();
    jt.required(e, t, i, a, o), zr(t, "string") || jt.pattern(e, t, i, a, o);
  }
  r(a);
}, mge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t, "date") && !e.required)
      return r();
    if (jt.required(e, t, i, a, o), !zr(t, "date")) {
      var l;
      t instanceof Date ? l = t : l = new Date(t), jt.type(e, l, i, a, o), l && jt.range(e, l.getTime(), i, a, o);
    }
  }
  r(a);
}, yge = function(e, t, r, i, o) {
  var a = [], s = Array.isArray(t) ? "array" : typeof t;
  jt.required(e, t, i, a, o, s), r(a);
}, a2 = function(e, t, r, i, o) {
  var a = e.type, s = [], l = e.required || !e.required && i.hasOwnProperty(e.field);
  if (l) {
    if (zr(t, a) && !e.required)
      return r();
    jt.required(e, t, i, s, o, a), zr(t, a) || jt.type(e, t, i, s, o);
  }
  r(s);
}, bge = function(e, t, r, i, o) {
  var a = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (zr(t) && !e.required)
      return r();
    jt.required(e, t, i, a, o);
  }
  r(a);
}, sy = {
  string: oge,
  method: age,
  number: sge,
  boolean: lge,
  regexp: uge,
  integer: cge,
  float: hge,
  array: fge,
  object: dge,
  enum: gge,
  pattern: vge,
  date: mge,
  url: a2,
  hex: a2,
  email: a2,
  required: yge,
  any: bge
};
function tP() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var e = JSON.parse(JSON.stringify(this));
      return e.clone = this.clone, e;
    }
  };
}
var nP = tP(), vb = /* @__PURE__ */ function() {
  function n(t) {
    this.rules = null, this._messages = nP, this.define(t);
  }
  var e = n.prototype;
  return e.define = function(r) {
    var i = this;
    if (!r)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof r != "object" || Array.isArray(r))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(r).forEach(function(o) {
      var a = r[o];
      i.rules[o] = Array.isArray(a) ? a : [a];
    });
  }, e.messages = function(r) {
    return r && (this._messages = x3(tP(), r)), this._messages;
  }, e.validate = function(r, i, o) {
    var a = this;
    i === void 0 && (i = {}), o === void 0 && (o = function() {
    });
    var s = r, l = i, u = o;
    if (typeof l == "function" && (u = l, l = {}), !this.rules || Object.keys(this.rules).length === 0)
      return u && u(null, s), Promise.resolve(s);
    function c(g) {
      var v = [], m = {};
      function y(O) {
        if (Array.isArray(O)) {
          var w;
          v = (w = v).concat.apply(w, O);
        } else
          v.push(O);
      }
      for (var b = 0; b < g.length; b++)
        y(g[b]);
      v.length ? (m = eP(v), u(v, m)) : u(null, s);
    }
    if (l.messages) {
      var h = this.messages();
      h === nP && (h = tP()), x3(h, l.messages), l.messages = h;
    } else
      l.messages = this.messages();
    var f = {}, d = l.keys || Object.keys(this.rules);
    d.forEach(function(g) {
      var v = a.rules[g], m = s[g];
      v.forEach(function(y) {
        var b = y;
        typeof b.transform == "function" && (s === r && (s = hf({}, s)), m = s[g] = b.transform(m)), typeof b == "function" ? b = {
          validator: b
        } : b = hf({}, b), b.validator = a.getValidationMethod(b), b.validator && (b.field = g, b.fullField = b.fullField || g, b.type = a.getType(b), f[g] = f[g] || [], f[g].push({
          rule: b,
          value: m,
          source: s,
          field: g
        }));
      });
    });
    var p = {};
    return Xpe(f, l, function(g, v) {
      var m = g.rule, y = (m.type === "object" || m.type === "array") && (typeof m.fields == "object" || typeof m.defaultField == "object");
      y = y && (m.required || !m.required && g.value), m.field = g.field;
      function b(x, S) {
        return hf({}, S, {
          fullField: m.fullField + "." + x,
          fullFields: m.fullFields ? [].concat(m.fullFields, [x]) : [x]
        });
      }
      function O(x) {
        x === void 0 && (x = []);
        var S = Array.isArray(x) ? x : [x];
        !l.suppressWarning && S.length && n.warning("async-validator:", S), S.length && m.message !== void 0 && (S = [].concat(m.message));
        var _ = S.map(w3(m, s));
        if (l.first && _.length)
          return p[m.field] = 1, v(_);
        if (!y)
          v(_);
        else {
          if (m.required && !g.value)
            return m.message !== void 0 ? _ = [].concat(m.message).map(w3(m, s)) : l.error && (_ = [l.error(m, Wo(l.messages.required, m.field))]), v(_);
          var C = {};
          m.defaultField && Object.keys(g.value).map(function(P) {
            C[P] = m.defaultField;
          }), C = hf({}, C, g.rule.fields);
          var A = {};
          Object.keys(C).forEach(function(P) {
            var L = C[P], D = Array.isArray(L) ? L : [L];
            A[P] = D.map(b.bind(null, P));
          });
          var k = new n(A);
          k.messages(l.messages), g.rule.options && (g.rule.options.messages = l.messages, g.rule.options.error = l.error), k.validate(g.value, g.rule.options || l, function(P) {
            var L = [];
            _ && _.length && L.push.apply(L, _), P && P.length && L.push.apply(L, P), v(L.length ? L : null);
          });
        }
      }
      var w;
      if (m.asyncValidator)
        w = m.asyncValidator(m, g.value, O, g.source, l);
      else if (m.validator) {
        try {
          w = m.validator(m, g.value, O, g.source, l);
        } catch (x) {
          console.error == null || console.error(x), l.suppressValidatorError || setTimeout(function() {
            throw x;
          }, 0), O(x.message);
        }
        w === !0 ? O() : w === !1 ? O(typeof m.message == "function" ? m.message(m.fullField || m.field) : m.message || (m.fullField || m.field) + " fails") : w instanceof Array ? O(w) : w instanceof Error && O(w.message);
      }
      w && w.then && w.then(function() {
        return O();
      }, function(x) {
        return O(x);
      });
    }, function(g) {
      c(g);
    }, s);
  }, e.getType = function(r) {
    if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"), typeof r.validator != "function" && r.type && !sy.hasOwnProperty(r.type))
      throw new Error(Wo("Unknown rule type %s", r.type));
    return r.type || "string";
  }, e.getValidationMethod = function(r) {
    if (typeof r.validator == "function")
      return r.validator;
    var i = Object.keys(r), o = i.indexOf("message");
    return o !== -1 && i.splice(o, 1), i.length === 1 && i[0] === "required" ? sy.required : sy[this.getType(r)] || void 0;
  }, n;
}();
vb.register = function(e, t) {
  if (typeof t != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  sy[e] = t;
};
vb.warning = t7;
vb.messages = nP;
vb.validators = sy;
const Oge = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', wge = (n) => process.env.NODE_ENV === "test" ? !0 : getComputedStyle(n).position === "fixed" ? !1 : n.offsetParent !== null, _3 = (n) => Array.from(n.querySelectorAll(Oge)).filter((e) => xge(e) && wge(e)), xge = (n) => {
  if (n.tabIndex > 0 || n.tabIndex === 0 && n.getAttribute("tabIndex") !== null)
    return !0;
  if (n.disabled)
    return !1;
  switch (n.nodeName) {
    case "A":
      return !!n.href && n.rel !== "ignore";
    case "INPUT":
      return !(n.type === "hidden" || n.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return !0;
    default:
      return !1;
  }
}, r7 = (n) => !n.getAttribute("aria-owns"), i7 = (n, e, t) => {
  const { parentNode: r } = n;
  if (!r)
    return null;
  const i = r.querySelectorAll(t), o = Array.prototype.indexOf.call(i, n);
  return i[o + e] || null;
}, tw = (n) => {
  n && (n.focus(), !r7(n) && n.click());
}, zl = (n, e, { checkForDefaultPrevented: t = !0 } = {}) => (i) => {
  const o = n == null ? void 0 : n(i);
  if (t === !1 || !o)
    return e == null ? void 0 : e(i);
};
var Sge = Object.defineProperty, _ge = Object.defineProperties, Cge = Object.getOwnPropertyDescriptors, C3 = Object.getOwnPropertySymbols, Age = Object.prototype.hasOwnProperty, Tge = Object.prototype.propertyIsEnumerable, A3 = (n, e, t) => e in n ? Sge(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, kge = (n, e) => {
  for (var t in e || (e = {}))
    Age.call(e, t) && A3(n, t, e[t]);
  if (C3)
    for (var t of C3(e))
      Tge.call(e, t) && A3(n, t, e[t]);
  return n;
}, Pge = (n, e) => _ge(n, Cge(e));
function T3(n, e) {
  var t;
  const r = di();
  return sl(() => {
    r.value = n();
  }, Pge(kge({}, e), {
    flush: (t = e == null ? void 0 : e.flush) != null ? t : "sync"
  })), o_(r);
}
var k3;
const qt = typeof window < "u", Ege = (n) => typeof n == "string", cx = () => {
}, Mge = qt && ((k3 = window == null ? void 0 : window.navigator) == null ? void 0 : k3.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Yf(n) {
  return typeof n == "function" ? n() : T(n);
}
function Dge(n, e) {
  function t(...r) {
    return new Promise((i, o) => {
      Promise.resolve(n(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(o);
    });
  }
  return t;
}
function Lge(n, e = {}) {
  let t, r, i = cx;
  const o = (s) => {
    clearTimeout(s), i(), i = cx;
  };
  return (s) => {
    const l = Yf(n), u = Yf(e.maxWait);
    return t && o(t), l <= 0 || u !== void 0 && u <= 0 ? (r && (o(r), r = null), Promise.resolve(s())) : new Promise((c, h) => {
      i = e.rejectOnCancel ? h : c, u && !r && (r = setTimeout(() => {
        t && o(t), r = null, c(s());
      }, u)), t = setTimeout(() => {
        r && o(r), r = null, c(s());
      }, l);
    });
  };
}
function Ige(n) {
  return n;
}
function mb(n) {
  return kG() ? (KD(n), !0) : !1;
}
function Rge(n, e = 200, t = {}) {
  return Dge(Lge(e, t), n);
}
function Nge(n, e = 200, t = {}) {
  const r = z(n.value), i = Rge(() => {
    r.value = n.value;
  }, e, t);
  return he(n, () => i()), r;
}
function $ge(n, e = !0) {
  wt() ? ht(n) : e ? n() : Ke(n);
}
function hx(n, e, t = {}) {
  const {
    immediate: r = !0
  } = t, i = z(!1);
  let o = null;
  function a() {
    o && (clearTimeout(o), o = null);
  }
  function s() {
    i.value = !1, a();
  }
  function l(...u) {
    a(), i.value = !0, o = setTimeout(() => {
      i.value = !1, o = null, n(...u);
    }, Yf(e));
  }
  return r && (i.value = !0, qt && l()), mb(s), {
    isPending: o_(i),
    start: l,
    stop: s
  };
}
function Us(n) {
  var e;
  const t = Yf(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const hv = qt ? window : void 0, Bge = qt ? window.document : void 0;
function Yi(...n) {
  let e, t, r, i;
  if (Ege(n[0]) || Array.isArray(n[0]) ? ([t, r, i] = n, e = hv) : [e, t, r, i] = n, !e)
    return cx;
  Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]);
  const o = [], a = () => {
    o.forEach((c) => c()), o.length = 0;
  }, s = (c, h, f, d) => (c.addEventListener(h, f, d), () => c.removeEventListener(h, f, d)), l = he(() => [Us(e), Yf(i)], ([c, h]) => {
    a(), c && o.push(...t.flatMap((f) => r.map((d) => s(c, f, d, h))));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), a();
  };
  return mb(u), u;
}
let P3 = !1;
function Vge(n, e, t = {}) {
  const { window: r = hv, ignore: i = [], capture: o = !0, detectIframe: a = !1 } = t;
  if (!r)
    return;
  Mge && !P3 && (P3 = !0, Array.from(r.document.body.children).forEach((f) => f.addEventListener("click", cx)));
  let s = !0;
  const l = (f) => i.some((d) => {
    if (typeof d == "string")
      return Array.from(r.document.querySelectorAll(d)).some((p) => p === f.target || f.composedPath().includes(p));
    {
      const p = Us(d);
      return p && (f.target === p || f.composedPath().includes(p));
    }
  }), c = [
    Yi(r, "click", (f) => {
      const d = Us(n);
      if (!(!d || d === f.target || f.composedPath().includes(d))) {
        if (f.detail === 0 && (s = !l(f)), !s) {
          s = !0;
          return;
        }
        e(f);
      }
    }, { passive: !0, capture: o }),
    Yi(r, "pointerdown", (f) => {
      const d = Us(n);
      d && (s = !f.composedPath().includes(d) && !l(f));
    }, { passive: !0 }),
    a && Yi(r, "blur", (f) => {
      var d;
      const p = Us(n);
      ((d = r.document.activeElement) == null ? void 0 : d.tagName) === "IFRAME" && !(p != null && p.contains(r.document.activeElement)) && e(f);
    })
  ].filter(Boolean);
  return () => c.forEach((f) => f());
}
function o7(n, e = !1) {
  const t = z(), r = () => t.value = !!n();
  return r(), $ge(r, e), t;
}
const E3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, M3 = "__vueuse_ssr_handlers__";
E3[M3] = E3[M3] || {};
function zge(n, e, { window: t = hv, initialValue: r = "" } = {}) {
  const i = z(r), o = B(() => {
    var a;
    return Us(e) || ((a = t == null ? void 0 : t.document) == null ? void 0 : a.documentElement);
  });
  return he([o, () => Yf(n)], ([a, s]) => {
    var l;
    if (a && t) {
      const u = (l = t.getComputedStyle(a).getPropertyValue(s)) == null ? void 0 : l.trim();
      i.value = u || r;
    }
  }, { immediate: !0 }), he(i, (a) => {
    var s;
    (s = o.value) != null && s.style && o.value.style.setProperty(Yf(n), a);
  }), i;
}
function Fge({ document: n = Bge } = {}) {
  if (!n)
    return z("visible");
  const e = z(n.visibilityState);
  return Yi(n, "visibilitychange", () => {
    e.value = n.visibilityState;
  }), e;
}
var D3 = Object.getOwnPropertySymbols, Qge = Object.prototype.hasOwnProperty, Zge = Object.prototype.propertyIsEnumerable, Wge = (n, e) => {
  var t = {};
  for (var r in n)
    Qge.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && D3)
    for (var r of D3(n))
      e.indexOf(r) < 0 && Zge.call(n, r) && (t[r] = n[r]);
  return t;
};
function Ei(n, e, t = {}) {
  const r = t, { window: i = hv } = r, o = Wge(r, ["window"]);
  let a;
  const s = o7(() => i && "ResizeObserver" in i), l = () => {
    a && (a.disconnect(), a = void 0);
  }, u = he(() => Us(n), (h) => {
    l(), s.value && i && h && (a = new ResizeObserver(e), a.observe(h, o));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), u();
  };
  return mb(c), {
    isSupported: s,
    stop: c
  };
}
var L3 = Object.getOwnPropertySymbols, Gge = Object.prototype.hasOwnProperty, jge = Object.prototype.propertyIsEnumerable, Hge = (n, e) => {
  var t = {};
  for (var r in n)
    Gge.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && L3)
    for (var r of L3(n))
      e.indexOf(r) < 0 && jge.call(n, r) && (t[r] = n[r]);
  return t;
};
function qge(n, e, t = {}) {
  const r = t, { window: i = hv } = r, o = Hge(r, ["window"]);
  let a;
  const s = o7(() => i && "MutationObserver" in i), l = () => {
    a && (a.disconnect(), a = void 0);
  }, u = he(() => Us(n), (h) => {
    l(), s.value && i && h && (a = new MutationObserver(e), a.observe(h, o));
  }, { immediate: !0 }), c = () => {
    l(), u();
  };
  return mb(c), {
    isSupported: s,
    stop: c
  };
}
var I3;
(function(n) {
  n.UP = "UP", n.RIGHT = "RIGHT", n.DOWN = "DOWN", n.LEFT = "LEFT", n.NONE = "NONE";
})(I3 || (I3 = {}));
var Yge = Object.defineProperty, R3 = Object.getOwnPropertySymbols, Xge = Object.prototype.hasOwnProperty, Uge = Object.prototype.propertyIsEnumerable, N3 = (n, e, t) => e in n ? Yge(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Kge = (n, e) => {
  for (var t in e || (e = {}))
    Xge.call(e, t) && N3(n, t, e[t]);
  if (R3)
    for (var t of R3(e))
      Uge.call(e, t) && N3(n, t, e[t]);
  return n;
};
const Jge = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Kge({
  linear: Ige
}, Jge);
function eve({ window: n = hv } = {}) {
  if (!n)
    return z(!1);
  const e = z(n.document.hasFocus());
  return Yi(n, "blur", () => {
    e.value = !1;
  }), Yi(n, "focus", () => {
    e.value = !0;
  }), e;
}
const tve = () => qt && /firefox/i.test(window.navigator.userAgent), bL = (n) => {
  let e, t;
  return n.type === "touchend" ? (t = n.changedTouches[0].clientY, e = n.changedTouches[0].clientX) : n.type.startsWith("touch") ? (t = n.touches[0].clientY, e = n.touches[0].clientX) : (t = n.clientY, e = n.clientX), {
    clientX: e,
    clientY: t
  };
};
/**
* @vue/shared v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const ll = () => {
}, a7 = Object.assign, nve = Object.prototype.hasOwnProperty, To = (n, e) => nve.call(n, e), _n = Array.isArray, fn = (n) => typeof n == "function", Ut = (n) => typeof n == "string", rve = (n) => typeof n == "symbol", Nr = (n) => n !== null && typeof n == "object", rP = (n) => (Nr(n) || fn(n)) && fn(n.then) && fn(n.catch), ive = Object.prototype.toString, ove = (n) => ive.call(n), s2 = (n) => ove(n).slice(8, -1), s7 = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, ave = /-(\w)/g, sve = s7((n) => n.replace(ave, (e, t) => t ? t.toUpperCase() : "")), lve = s7((n) => n.charAt(0).toUpperCase() + n.slice(1)), uve = (n, e) => !Object.is(n, e), Li = (n) => n === void 0, pi = (n) => typeof n == "boolean", _t = (n) => typeof n == "number", Gs = (n) => !n && n !== 0 || _n(n) && n.length === 0 || Nr(n) && !Object.keys(n).length, hs = (n) => typeof Element > "u" ? !1 : n instanceof Element, cve = (n) => Ut(n) ? !Number.isNaN(Number(n)) : !1, hve = (n = "") => n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), js = (n) => lve(n), $3 = (n) => Object.keys(n), nw = (n, e, t) => ({
  get value() {
    return ga(n, e, t);
  },
  set value(r) {
    kde(n, e, r);
  }
});
class l7 extends Error {
  constructor(e) {
    super(e), this.name = "ElementPlusError";
  }
}
function Su(n, e) {
  throw new l7(`[${n}] ${e}`);
}
function Ht(n, e) {
  if (process.env.NODE_ENV !== "production") {
    const t = Ut(n) ? new l7(`[${n}] ${e}`) : n;
    console.warn(t);
  }
}
const fve = "utils/dom/style", u7 = (n = "") => n.split(" ").filter((e) => !!e.trim()), Bp = (n, e) => {
  if (!n || !e)
    return !1;
  if (e.includes(" "))
    throw new Error("className should not contain space.");
  return n.classList.contains(e);
}, fg = (n, e) => {
  !n || !e.trim() || n.classList.add(...u7(e));
}, Ul = (n, e) => {
  !n || !e.trim() || n.classList.remove(...u7(e));
}, dve = (n, e) => {
  var t;
  if (!qt || !n || !e)
    return "";
  let r = sve(e);
  r === "float" && (r = "cssFloat");
  try {
    const i = n.style[r];
    if (i)
      return i;
    const o = (t = document.defaultView) == null ? void 0 : t.getComputedStyle(n, "");
    return o ? o[r] : "";
  } catch {
    return n.style[r];
  }
};
function Xo(n, e = "px") {
  if (!n)
    return "";
  if (_t(n) || cve(n))
    return `${n}${e}`;
  if (Ut(n))
    return n;
  Ht(fve, "binding value must be a string or number");
}
let s1;
const pve = (n) => {
  var e;
  if (!qt)
    return 0;
  if (s1 !== void 0)
    return s1;
  const t = document.createElement("div");
  t.className = `${n}-scrollbar__wrap`, t.style.visibility = "hidden", t.style.width = "100px", t.style.position = "absolute", t.style.top = "-9999px", document.body.appendChild(t);
  const r = t.offsetWidth;
  t.style.overflow = "scroll";
  const i = document.createElement("div");
  i.style.width = "100%", t.appendChild(i);
  const o = i.offsetWidth;
  return (e = t.parentNode) == null || e.removeChild(t), s1 = r - o, s1;
};
function c7(n, e) {
  if (!qt)
    return;
  if (!e) {
    n.scrollTop = 0;
    return;
  }
  const t = [];
  let r = e.offsetParent;
  for (; r !== null && n !== r && n.contains(r); )
    t.push(r), r = r.offsetParent;
  const i = e.offsetTop + t.reduce((l, u) => l + u.offsetTop, 0), o = i + e.offsetHeight, a = n.scrollTop, s = a + n.clientHeight;
  i < a ? n.scrollTop = i : o > s && (n.scrollTop = o - n.clientHeight);
}
const h7 = "__epPropKey", Ae = (n) => n, gve = (n) => Nr(n) && !!n[h7], v_ = (n, e) => {
  if (!Nr(n) || gve(n))
    return n;
  const { values: t, required: r, default: i, type: o, validator: a } = n, l = {
    type: o,
    required: !!r,
    validator: t || a ? (u) => {
      let c = !1, h = [];
      if (t && (h = Array.from(t), To(n, "default") && h.push(i), c || (c = h.includes(u))), a && (c || (c = a(u))), !c && h.length > 0) {
        const f = [...new Set(h)].map((d) => JSON.stringify(d)).join(", ");
        nae(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${f}], got value ${JSON.stringify(u)}.`);
      }
      return c;
    } : void 0,
    [h7]: !0
  };
  return To(n, "default") && (l.default = i), l;
}, Ye = (n) => ux(Object.entries(n).map(([e, t]) => [
  e,
  v_(t, e)
])), $r = Ae([
  String,
  Object,
  Function
]), f7 = {
  Close: Pc
}, d7 = {
  Close: Pc,
  SuccessFilled: e7,
  InfoFilled: Kj,
  WarningFilled: yL,
  CircleCloseFilled: Uj
}, dg = {
  success: e7,
  warning: yL,
  error: Uj,
  info: Kj
}, p7 = {
  validating: _d,
  success: Xj,
  error: gb
}, zn = (n, e) => {
  if (n.install = (t) => {
    for (const r of [n, ...Object.values(e ?? {})])
      t.component(r.name, r);
  }, e)
    for (const [t, r] of Object.entries(e))
      n[t] = r;
  return n;
}, g7 = (n, e) => (n.install = (t) => {
  n._context = t._context, t.config.globalProperties[e] = n;
}, n), vve = (n, e) => (n.install = (t) => {
  t.directive(e, n);
}, n), Os = (n) => (n.install = ll, n), mve = (...n) => (e) => {
  n.forEach((t) => {
    fn(t) ? t(e) : t.value = e;
  });
}, Ft = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, Dt = "update:modelValue", yi = "change", Df = "input", Cd = ["", "default", "small", "large"], v7 = (n) => ["", ...Cd].includes(n);
var rw = /* @__PURE__ */ ((n) => (n[n.TEXT = 1] = "TEXT", n[n.CLASS = 2] = "CLASS", n[n.STYLE = 4] = "STYLE", n[n.PROPS = 8] = "PROPS", n[n.FULL_PROPS = 16] = "FULL_PROPS", n[n.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", n[n.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", n[n.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", n[n.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", n[n.NEED_PATCH = 512] = "NEED_PATCH", n[n.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", n[n.HOISTED = -1] = "HOISTED", n[n.BAIL = -2] = "BAIL", n))(rw || {});
const iw = (n) => {
  const e = _n(n) ? n : [n], t = [];
  return e.forEach((r) => {
    var i;
    _n(r) ? t.push(...iw(r)) : gl(r) && _n(r.children) ? t.push(...iw(r.children)) : (t.push(r), gl(r) && ((i = r.component) != null && i.subTree) && t.push(...iw(r.component.subTree)));
  }), t;
}, B3 = (n) => [...new Set(n)], V3 = (n) => !n && n !== 0 ? [] : Array.isArray(n) ? n : [n], OL = (n) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(n), yve = (n) => qt ? window.requestAnimationFrame(n) : setTimeout(n, 16), ih = (n) => n, bve = ["class", "style"], Ove = /^on[A-Z]/, wve = (n = {}) => {
  const { excludeListeners: e = !1, excludeKeys: t } = n, r = B(() => ((t == null ? void 0 : t.value) || []).concat(bve)), i = wt();
  return i ? B(() => {
    var o;
    return ux(Object.entries((o = i.proxy) == null ? void 0 : o.$attrs).filter(([a]) => !r.value.includes(a) && !(e && Ove.test(a))));
  }) : (Ht("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), B(() => ({})));
}, Xf = ({ from: n, replacement: e, scope: t, version: r, ref: i, type: o = "API" }, a) => {
  he(() => T(a), (s) => {
    s && Ht(t, `[${o}] ${n} is about to be deprecated in version ${r}, please use ${e} instead.
For more detail, please visit: ${i}
`);
  }, {
    immediate: !0
  });
}, m7 = (n, e, t, r) => {
  let i = {
    offsetX: 0,
    offsetY: 0
  };
  const o = (l) => {
    const u = l.clientX, c = l.clientY, { offsetX: h, offsetY: f } = i, d = n.value.getBoundingClientRect(), p = d.left, g = d.top, v = d.width, m = d.height, y = document.documentElement.clientWidth, b = document.documentElement.clientHeight, O = -p + h, w = -g + f, x = y - p - v + h, S = b - g - m + f, _ = (A) => {
      let k = h + A.clientX - u, P = f + A.clientY - c;
      r != null && r.value || (k = Math.min(Math.max(k, O), x), P = Math.min(Math.max(P, w), S)), i = {
        offsetX: k,
        offsetY: P
      }, n.value && (n.value.style.transform = `translate(${Xo(k)}, ${Xo(P)})`);
    }, C = () => {
      document.removeEventListener("mousemove", _), document.removeEventListener("mouseup", C);
    };
    document.addEventListener("mousemove", _), document.addEventListener("mouseup", C);
  }, a = () => {
    e.value && n.value && e.value.addEventListener("mousedown", o);
  }, s = () => {
    e.value && n.value && e.value.removeEventListener("mousedown", o);
  };
  ht(() => {
    sl(() => {
      t.value ? a() : s();
    });
  }), xi(() => {
    s();
  });
};
var xve = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
const Sve = (n) => (e, t) => _ve(e, t, T(n)), _ve = (n, e, t) => ga(t, n, n).replace(/\{(\w+)\}/g, (r, i) => {
  var o;
  return `${(o = e == null ? void 0 : e[i]) != null ? o : `{${i}}`}`;
}), Cve = (n) => {
  const e = B(() => T(n).name), t = So(n) ? n : z(n);
  return {
    lang: e,
    locale: t,
    t: Sve(n)
  };
}, y7 = Symbol("localeContextKey"), Ar = (n) => {
  const e = n || Re(y7, z());
  return Cve(B(() => e.value || xve));
};
/**
* @vue/reactivity v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function b7(n, ...e) {
  console.warn(`[Vue warn] ${n}`, ...e);
}
let Ave;
function Tve(n, e = Ave) {
  e && e.active && e.effects.push(n);
}
let ly;
class kve {
  constructor(e, t, r, i) {
    this.fn = e, this.trigger = t, this.scheduler = r, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, Tve(this, i);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1, Eve();
      for (let e = 0; e < this._depsLength; e++) {
        const t = this.deps[e];
        if (t.computed && (Pve(t.computed), this._dirtyLevel >= 4))
          break;
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), Mve();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(e) {
    this._dirtyLevel = e ? 4 : 0;
  }
  run() {
    if (this._dirtyLevel = 0, !this.active)
      return this.fn();
    let e = Lf, t = ly;
    try {
      return Lf = !0, ly = this, this._runnings++, z3(this), this.fn();
    } finally {
      F3(this), this._runnings--, ly = t, Lf = e;
    }
  }
  stop() {
    var e;
    this.active && (z3(this), F3(this), (e = this.onStop) == null || e.call(this), this.active = !1);
  }
}
function Pve(n) {
  return n.value;
}
function z3(n) {
  n._trackId++, n._depsLength = 0;
}
function F3(n) {
  if (n.deps.length > n._depsLength) {
    for (let e = n._depsLength; e < n.deps.length; e++)
      O7(n.deps[e], n);
    n.deps.length = n._depsLength;
  }
}
function O7(n, e) {
  const t = n.get(e);
  t !== void 0 && e._trackId !== t && (n.delete(e), n.size === 0 && n.cleanup());
}
let Lf = !0, iP = 0;
const w7 = [];
function Eve() {
  w7.push(Lf), Lf = !1;
}
function Mve() {
  const n = w7.pop();
  Lf = n === void 0 ? !0 : n;
}
function Dve() {
  iP++;
}
function Lve() {
  for (iP--; !iP && oP.length; )
    oP.shift()();
}
function Ive(n, e, t) {
  var r;
  if (e.get(n) !== n._trackId) {
    e.set(n, n._trackId);
    const i = n.deps[n._depsLength];
    i !== e ? (i && O7(i, n), n.deps[n._depsLength++] = e) : n._depsLength++, process.env.NODE_ENV !== "production" && ((r = n.onTrack) == null || r.call(n, a7({ effect: n }, t)));
  }
}
const oP = [];
function Rve(n, e, t) {
  var r;
  Dve();
  for (const i of n.keys()) {
    let o;
    i._dirtyLevel < e && (o ?? (o = n.get(i) === i._trackId)) && (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0), i._dirtyLevel = e), i._shouldSchedule && (o ?? (o = n.get(i) === i._trackId)) && (process.env.NODE_ENV !== "production" && ((r = i.onTrigger) == null || r.call(i, a7({ effect: i }, t))), i.trigger(), (!i._runnings || i.allowRecurse) && i._dirtyLevel !== 2 && (i._shouldSchedule = !1, i.scheduler && oP.push(i.scheduler)));
  }
  Lve();
}
const Nve = (n, e) => {
  const t = /* @__PURE__ */ new Map();
  return t.cleanup = n, t.computed = e, t;
};
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(rve)
);
function m_(n) {
  const e = n && n.__v_raw;
  return e ? m_(e) : n;
}
const $ve = "Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free";
class x7 {
  constructor(e, t, r, i) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new kve(
      () => e(this._value),
      () => l2(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    ), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = r;
  }
  get value() {
    const e = m_(this);
    return (!e._cacheable || e.effect.dirty) && uve(e._value, e._value = e.effect.run()) && l2(e, 4), Vve(e), e.effect._dirtyLevel >= 2 && (process.env.NODE_ENV !== "production" && b7($ve), l2(e, 2)), e._value;
  }
  set value(e) {
    this._setter(e);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(e) {
    this.effect.dirty = e;
  }
  // #endregion
}
function Bve(n, e, t = !1) {
  let r, i;
  const o = fn(n);
  o ? (r = n, i = process.env.NODE_ENV !== "production" ? () => {
    b7("Write operation failed: computed value is readonly");
  } : ll) : (r = n.get, i = n.set);
  const a = new x7(r, i, o || !i, t);
  return process.env.NODE_ENV !== "production" && e && !t && (a.effect.onTrack = e.onTrack, a.effect.onTrigger = e.onTrigger), a;
}
function Vve(n) {
  var e;
  Lf && ly && (n = m_(n), Ive(
    ly,
    (e = n.dep) != null ? e : n.dep = Nve(
      () => n.dep = void 0,
      n instanceof x7 ? n : void 0
    ),
    process.env.NODE_ENV !== "production" ? {
      target: n,
      type: "get",
      key: "value"
    } : void 0
  ));
}
function l2(n, e = 4, t) {
  n = m_(n);
  const r = n.dep;
  r && Rve(
    r,
    e,
    process.env.NODE_ENV !== "production" ? {
      target: n,
      type: "set",
      key: "value",
      newValue: t
    } : void 0
  );
}
const uy = "el", zve = "is-", vh = (n, e, t, r, i) => {
  let o = `${n}-${e}`;
  return t && (o += `-${t}`), r && (o += `__${r}`), i && (o += `--${i}`), o;
}, S7 = Symbol("namespaceContextKey"), wL = (n) => {
  const e = n || (wt() ? Re(S7, z(uy)) : z(uy));
  return B(() => T(e) || uy);
}, Pe = (n, e) => {
  const t = wL(e);
  return {
    namespace: t,
    b: (g = "") => vh(t.value, n, g, "", ""),
    e: (g) => g ? vh(t.value, n, "", g, "") : "",
    m: (g) => g ? vh(t.value, n, "", "", g) : "",
    be: (g, v) => g && v ? vh(t.value, n, g, v, "") : "",
    em: (g, v) => g && v ? vh(t.value, n, "", g, v) : "",
    bm: (g, v) => g && v ? vh(t.value, n, g, "", v) : "",
    bem: (g, v, m) => g && v && m ? vh(t.value, n, g, v, m) : "",
    is: (g, ...v) => {
      const m = v.length >= 1 ? v[0] : !0;
      return g && m ? `${zve}${g}` : "";
    },
    cssVar: (g) => {
      const v = {};
      for (const m in g)
        g[m] && (v[`--${t.value}-${m}`] = g[m]);
      return v;
    },
    cssVarName: (g) => `--${t.value}-${g}`,
    cssVarBlock: (g) => {
      const v = {};
      for (const m in g)
        g[m] && (v[`--${t.value}-${n}-${m}`] = g[m]);
      return v;
    },
    cssVarBlockName: (g) => `--${t.value}-${n}-${g}`
  };
}, _7 = (n, e = {}) => {
  So(n) || Su("[useLockscreen]", "You need to pass a ref param to this function");
  const t = e.ns || Pe("popup"), r = Bve(() => t.bm("parent", "hidden"));
  if (!qt || Bp(document.body, r.value))
    return;
  let i = 0, o = !1, a = "0";
  const s = () => {
    setTimeout(() => {
      Ul(document == null ? void 0 : document.body, r.value), o && document && (document.body.style.width = a);
    }, 200);
  };
  he(n, (l) => {
    if (!l) {
      s();
      return;
    }
    o = !Bp(document.body, r.value), o && (a = document.body.style.width), i = pve(t.namespace.value);
    const u = document.documentElement.clientHeight < document.body.scrollHeight, c = dve(document.body, "overflowY");
    i > 0 && (u || c === "scroll") && o && (document.body.style.width = `calc(100% - ${i}px)`), fg(document.body, r.value);
  }), KD(() => s());
}, Fve = v_({
  type: Ae(Boolean),
  default: null
}), Qve = v_({
  type: Ae(Function)
}), C7 = (n) => {
  const e = `update:${n}`, t = `onUpdate:${n}`, r = [e], i = {
    [n]: Fve,
    [t]: Qve
  };
  return {
    useModelToggle: ({
      indicator: a,
      toggleReason: s,
      shouldHideWhenRouteChanges: l,
      shouldProceed: u,
      onShow: c,
      onHide: h
    }) => {
      const f = wt(), { emit: d } = f, p = f.props, g = B(() => fn(p[t])), v = B(() => p[n] === null), m = (S) => {
        a.value !== !0 && (a.value = !0, s && (s.value = S), fn(c) && c(S));
      }, y = (S) => {
        a.value !== !1 && (a.value = !1, s && (s.value = S), fn(h) && h(S));
      }, b = (S) => {
        if (p.disabled === !0 || fn(u) && !u())
          return;
        const _ = g.value && qt;
        _ && d(e, !0), (v.value || !_) && m(S);
      }, O = (S) => {
        if (p.disabled === !0 || !qt)
          return;
        const _ = g.value && qt;
        _ && d(e, !1), (v.value || !_) && y(S);
      }, w = (S) => {
        pi(S) && (p.disabled && S ? g.value && d(e, !1) : a.value !== S && (S ? m() : y()));
      }, x = () => {
        a.value ? O() : b();
      };
      return he(() => p[n], w), l && f.appContext.config.globalProperties.$route !== void 0 && he(() => ({
        ...f.proxy.$route
      }), () => {
        l.value && a.value && O();
      }), ht(() => {
        w(p[n]);
      }), {
        hide: O,
        show: b,
        toggle: x,
        hasUpdateHandler: g
      };
    },
    useModelToggleProps: i,
    useModelToggleEmits: r
  };
};
C7("modelValue");
const A7 = (n) => {
  const e = wt();
  return B(() => {
    var t, r;
    return (r = (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$props) == null ? void 0 : r[n];
  });
};
var Co = "top", Ea = "bottom", Ma = "right", Ao = "left", xL = "auto", yb = [Co, Ea, Ma, Ao], pg = "start", Ky = "end", Zve = "clippingParents", T7 = "viewport", qv = "popper", Wve = "reference", Q3 = yb.reduce(function(n, e) {
  return n.concat([e + "-" + pg, e + "-" + Ky]);
}, []), y_ = [].concat(yb, [xL]).reduce(function(n, e) {
  return n.concat([e, e + "-" + pg, e + "-" + Ky]);
}, []), Gve = "beforeRead", jve = "read", Hve = "afterRead", qve = "beforeMain", Yve = "main", Xve = "afterMain", Uve = "beforeWrite", Kve = "write", Jve = "afterWrite", eme = [Gve, jve, Hve, qve, Yve, Xve, Uve, Kve, Jve];
function ml(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function ws(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var e = n.ownerDocument;
    return e && e.defaultView || window;
  }
  return n;
}
function gg(n) {
  var e = ws(n).Element;
  return n instanceof e || n instanceof Element;
}
function Sa(n) {
  var e = ws(n).HTMLElement;
  return n instanceof e || n instanceof HTMLElement;
}
function SL(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = ws(n).ShadowRoot;
  return n instanceof e || n instanceof ShadowRoot;
}
function tme(n) {
  var e = n.state;
  Object.keys(e.elements).forEach(function(t) {
    var r = e.styles[t] || {}, i = e.attributes[t] || {}, o = e.elements[t];
    !Sa(o) || !ml(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function(a) {
      var s = i[a];
      s === !1 ? o.removeAttribute(a) : o.setAttribute(a, s === !0 ? "" : s);
    }));
  });
}
function nme(n) {
  var e = n.state, t = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], o = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : t[r]), s = a.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !Sa(i) || !ml(i) || (Object.assign(i.style, s), Object.keys(o).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
var k7 = { name: "applyStyles", enabled: !0, phase: "write", fn: tme, effect: nme, requires: ["computeStyles"] };
function ul(n) {
  return n.split("-")[0];
}
var If = Math.max, fx = Math.min, vg = Math.round;
function mg(n, e) {
  e === void 0 && (e = !1);
  var t = n.getBoundingClientRect(), r = 1, i = 1;
  if (Sa(n) && e) {
    var o = n.offsetHeight, a = n.offsetWidth;
    a > 0 && (r = vg(t.width) / a || 1), o > 0 && (i = vg(t.height) / o || 1);
  }
  return { width: t.width / r, height: t.height / i, top: t.top / i, right: t.right / r, bottom: t.bottom / i, left: t.left / r, x: t.left / r, y: t.top / i };
}
function _L(n) {
  var e = mg(n), t = n.offsetWidth, r = n.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: n.offsetLeft, y: n.offsetTop, width: t, height: r };
}
function P7(n, e) {
  var t = e.getRootNode && e.getRootNode();
  if (n.contains(e))
    return !0;
  if (t && SL(t)) {
    var r = e;
    do {
      if (r && n.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function ou(n) {
  return ws(n).getComputedStyle(n);
}
function rme(n) {
  return ["table", "td", "th"].indexOf(ml(n)) >= 0;
}
function oh(n) {
  return ((gg(n) ? n.ownerDocument : n.document) || window.document).documentElement;
}
function b_(n) {
  return ml(n) === "html" ? n : n.assignedSlot || n.parentNode || (SL(n) ? n.host : null) || oh(n);
}
function Z3(n) {
  return !Sa(n) || ou(n).position === "fixed" ? null : n.offsetParent;
}
function ime(n) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, t = navigator.userAgent.indexOf("Trident") !== -1;
  if (t && Sa(n)) {
    var r = ou(n);
    if (r.position === "fixed")
      return null;
  }
  var i = b_(n);
  for (SL(i) && (i = i.host); Sa(i) && ["html", "body"].indexOf(ml(i)) < 0; ) {
    var o = ou(i);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function bb(n) {
  for (var e = ws(n), t = Z3(n); t && rme(t) && ou(t).position === "static"; )
    t = Z3(t);
  return t && (ml(t) === "html" || ml(t) === "body" && ou(t).position === "static") ? e : t || ime(n) || e;
}
function CL(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function cy(n, e, t) {
  return If(n, fx(e, t));
}
function ome(n, e, t) {
  var r = cy(n, e, t);
  return r > t ? t : r;
}
function E7() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function M7(n) {
  return Object.assign({}, E7(), n);
}
function D7(n, e) {
  return e.reduce(function(t, r) {
    return t[r] = n, t;
  }, {});
}
var ame = function(n, e) {
  return n = typeof n == "function" ? n(Object.assign({}, e.rects, { placement: e.placement })) : n, M7(typeof n != "number" ? n : D7(n, yb));
};
function sme(n) {
  var e, t = n.state, r = n.name, i = n.options, o = t.elements.arrow, a = t.modifiersData.popperOffsets, s = ul(t.placement), l = CL(s), u = [Ao, Ma].indexOf(s) >= 0, c = u ? "height" : "width";
  if (!(!o || !a)) {
    var h = ame(i.padding, t), f = _L(o), d = l === "y" ? Co : Ao, p = l === "y" ? Ea : Ma, g = t.rects.reference[c] + t.rects.reference[l] - a[l] - t.rects.popper[c], v = a[l] - t.rects.reference[l], m = bb(o), y = m ? l === "y" ? m.clientHeight || 0 : m.clientWidth || 0 : 0, b = g / 2 - v / 2, O = h[d], w = y - f[c] - h[p], x = y / 2 - f[c] / 2 + b, S = cy(O, x, w), _ = l;
    t.modifiersData[r] = (e = {}, e[_] = S, e.centerOffset = S - x, e);
  }
}
function lme(n) {
  var e = n.state, t = n.options, r = t.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || !P7(e.elements.popper, i) || (e.elements.arrow = i));
}
var ume = { name: "arrow", enabled: !0, phase: "main", fn: sme, effect: lme, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function yg(n) {
  return n.split("-")[1];
}
var cme = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function hme(n) {
  var e = n.x, t = n.y, r = window, i = r.devicePixelRatio || 1;
  return { x: vg(e * i) / i || 0, y: vg(t * i) / i || 0 };
}
function W3(n) {
  var e, t = n.popper, r = n.popperRect, i = n.placement, o = n.variation, a = n.offsets, s = n.position, l = n.gpuAcceleration, u = n.adaptive, c = n.roundOffsets, h = n.isFixed, f = a.x, d = f === void 0 ? 0 : f, p = a.y, g = p === void 0 ? 0 : p, v = typeof c == "function" ? c({ x: d, y: g }) : { x: d, y: g };
  d = v.x, g = v.y;
  var m = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), b = Ao, O = Co, w = window;
  if (u) {
    var x = bb(t), S = "clientHeight", _ = "clientWidth";
    if (x === ws(t) && (x = oh(t), ou(x).position !== "static" && s === "absolute" && (S = "scrollHeight", _ = "scrollWidth")), x = x, i === Co || (i === Ao || i === Ma) && o === Ky) {
      O = Ea;
      var C = h && x === w && w.visualViewport ? w.visualViewport.height : x[S];
      g -= C - r.height, g *= l ? 1 : -1;
    }
    if (i === Ao || (i === Co || i === Ea) && o === Ky) {
      b = Ma;
      var A = h && x === w && w.visualViewport ? w.visualViewport.width : x[_];
      d -= A - r.width, d *= l ? 1 : -1;
    }
  }
  var k = Object.assign({ position: s }, u && cme), P = c === !0 ? hme({ x: d, y: g }) : { x: d, y: g };
  if (d = P.x, g = P.y, l) {
    var L;
    return Object.assign({}, k, (L = {}, L[O] = y ? "0" : "", L[b] = m ? "0" : "", L.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + g + "px)" : "translate3d(" + d + "px, " + g + "px, 0)", L));
  }
  return Object.assign({}, k, (e = {}, e[O] = y ? g + "px" : "", e[b] = m ? d + "px" : "", e.transform = "", e));
}
function fme(n) {
  var e = n.state, t = n.options, r = t.gpuAcceleration, i = r === void 0 ? !0 : r, o = t.adaptive, a = o === void 0 ? !0 : o, s = t.roundOffsets, l = s === void 0 ? !0 : s, u = { placement: ul(e.placement), variation: yg(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, W3(Object.assign({}, u, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, W3(Object.assign({}, u, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var L7 = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: fme, data: {} }, l1 = { passive: !0 };
function dme(n) {
  var e = n.state, t = n.instance, r = n.options, i = r.scroll, o = i === void 0 ? !0 : i, a = r.resize, s = a === void 0 ? !0 : a, l = ws(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return o && u.forEach(function(c) {
    c.addEventListener("scroll", t.update, l1);
  }), s && l.addEventListener("resize", t.update, l1), function() {
    o && u.forEach(function(c) {
      c.removeEventListener("scroll", t.update, l1);
    }), s && l.removeEventListener("resize", t.update, l1);
  };
}
var I7 = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: dme, data: {} }, pme = { left: "right", right: "left", bottom: "top", top: "bottom" };
function ow(n) {
  return n.replace(/left|right|bottom|top/g, function(e) {
    return pme[e];
  });
}
var gme = { start: "end", end: "start" };
function G3(n) {
  return n.replace(/start|end/g, function(e) {
    return gme[e];
  });
}
function AL(n) {
  var e = ws(n), t = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: t, scrollTop: r };
}
function TL(n) {
  return mg(oh(n)).left + AL(n).scrollLeft;
}
function vme(n) {
  var e = ws(n), t = oh(n), r = e.visualViewport, i = t.clientWidth, o = t.clientHeight, a = 0, s = 0;
  return r && (i = r.width, o = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: i, height: o, x: a + TL(n), y: s };
}
function mme(n) {
  var e, t = oh(n), r = AL(n), i = (e = n.ownerDocument) == null ? void 0 : e.body, o = If(t.scrollWidth, t.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = If(t.scrollHeight, t.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + TL(n), l = -r.scrollTop;
  return ou(i || t).direction === "rtl" && (s += If(t.clientWidth, i ? i.clientWidth : 0) - o), { width: o, height: a, x: s, y: l };
}
function kL(n) {
  var e = ou(n), t = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + i + r);
}
function R7(n) {
  return ["html", "body", "#document"].indexOf(ml(n)) >= 0 ? n.ownerDocument.body : Sa(n) && kL(n) ? n : R7(b_(n));
}
function hy(n, e) {
  var t;
  e === void 0 && (e = []);
  var r = R7(n), i = r === ((t = n.ownerDocument) == null ? void 0 : t.body), o = ws(r), a = i ? [o].concat(o.visualViewport || [], kL(r) ? r : []) : r, s = e.concat(a);
  return i ? s : s.concat(hy(b_(a)));
}
function aP(n) {
  return Object.assign({}, n, { left: n.x, top: n.y, right: n.x + n.width, bottom: n.y + n.height });
}
function yme(n) {
  var e = mg(n);
  return e.top = e.top + n.clientTop, e.left = e.left + n.clientLeft, e.bottom = e.top + n.clientHeight, e.right = e.left + n.clientWidth, e.width = n.clientWidth, e.height = n.clientHeight, e.x = e.left, e.y = e.top, e;
}
function j3(n, e) {
  return e === T7 ? aP(vme(n)) : gg(e) ? yme(e) : aP(mme(oh(n)));
}
function bme(n) {
  var e = hy(b_(n)), t = ["absolute", "fixed"].indexOf(ou(n).position) >= 0, r = t && Sa(n) ? bb(n) : n;
  return gg(r) ? e.filter(function(i) {
    return gg(i) && P7(i, r) && ml(i) !== "body";
  }) : [];
}
function Ome(n, e, t) {
  var r = e === "clippingParents" ? bme(n) : [].concat(e), i = [].concat(r, [t]), o = i[0], a = i.reduce(function(s, l) {
    var u = j3(n, l);
    return s.top = If(u.top, s.top), s.right = fx(u.right, s.right), s.bottom = fx(u.bottom, s.bottom), s.left = If(u.left, s.left), s;
  }, j3(n, o));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function N7(n) {
  var e = n.reference, t = n.element, r = n.placement, i = r ? ul(r) : null, o = r ? yg(r) : null, a = e.x + e.width / 2 - t.width / 2, s = e.y + e.height / 2 - t.height / 2, l;
  switch (i) {
    case Co:
      l = { x: a, y: e.y - t.height };
      break;
    case Ea:
      l = { x: a, y: e.y + e.height };
      break;
    case Ma:
      l = { x: e.x + e.width, y: s };
      break;
    case Ao:
      l = { x: e.x - t.width, y: s };
      break;
    default:
      l = { x: e.x, y: e.y };
  }
  var u = i ? CL(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (o) {
      case pg:
        l[u] = l[u] - (e[c] / 2 - t[c] / 2);
        break;
      case Ky:
        l[u] = l[u] + (e[c] / 2 - t[c] / 2);
        break;
    }
  }
  return l;
}
function Jy(n, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, i = r === void 0 ? n.placement : r, o = t.boundary, a = o === void 0 ? Zve : o, s = t.rootBoundary, l = s === void 0 ? T7 : s, u = t.elementContext, c = u === void 0 ? qv : u, h = t.altBoundary, f = h === void 0 ? !1 : h, d = t.padding, p = d === void 0 ? 0 : d, g = M7(typeof p != "number" ? p : D7(p, yb)), v = c === qv ? Wve : qv, m = n.rects.popper, y = n.elements[f ? v : c], b = Ome(gg(y) ? y : y.contextElement || oh(n.elements.popper), a, l), O = mg(n.elements.reference), w = N7({ reference: O, element: m, strategy: "absolute", placement: i }), x = aP(Object.assign({}, m, w)), S = c === qv ? x : O, _ = { top: b.top - S.top + g.top, bottom: S.bottom - b.bottom + g.bottom, left: b.left - S.left + g.left, right: S.right - b.right + g.right }, C = n.modifiersData.offset;
  if (c === qv && C) {
    var A = C[i];
    Object.keys(_).forEach(function(k) {
      var P = [Ma, Ea].indexOf(k) >= 0 ? 1 : -1, L = [Co, Ea].indexOf(k) >= 0 ? "y" : "x";
      _[k] += A[L] * P;
    });
  }
  return _;
}
function wme(n, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, i = t.boundary, o = t.rootBoundary, a = t.padding, s = t.flipVariations, l = t.allowedAutoPlacements, u = l === void 0 ? y_ : l, c = yg(r), h = c ? s ? Q3 : Q3.filter(function(p) {
    return yg(p) === c;
  }) : yb, f = h.filter(function(p) {
    return u.indexOf(p) >= 0;
  });
  f.length === 0 && (f = h);
  var d = f.reduce(function(p, g) {
    return p[g] = Jy(n, { placement: g, boundary: i, rootBoundary: o, padding: a })[ul(g)], p;
  }, {});
  return Object.keys(d).sort(function(p, g) {
    return d[p] - d[g];
  });
}
function xme(n) {
  if (ul(n) === xL)
    return [];
  var e = ow(n);
  return [G3(n), e, G3(e)];
}
function Sme(n) {
  var e = n.state, t = n.options, r = n.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = t.mainAxis, o = i === void 0 ? !0 : i, a = t.altAxis, s = a === void 0 ? !0 : a, l = t.fallbackPlacements, u = t.padding, c = t.boundary, h = t.rootBoundary, f = t.altBoundary, d = t.flipVariations, p = d === void 0 ? !0 : d, g = t.allowedAutoPlacements, v = e.options.placement, m = ul(v), y = m === v, b = l || (y || !p ? [ow(v)] : xme(v)), O = [v].concat(b).reduce(function(X, ie) {
      return X.concat(ul(ie) === xL ? wme(e, { placement: ie, boundary: c, rootBoundary: h, padding: u, flipVariations: p, allowedAutoPlacements: g }) : ie);
    }, []), w = e.rects.reference, x = e.rects.popper, S = /* @__PURE__ */ new Map(), _ = !0, C = O[0], A = 0; A < O.length; A++) {
      var k = O[A], P = ul(k), L = yg(k) === pg, D = [Co, Ea].indexOf(P) >= 0, E = D ? "width" : "height", M = Jy(e, { placement: k, boundary: c, rootBoundary: h, altBoundary: f, padding: u }), R = D ? L ? Ma : Ao : L ? Ea : Co;
      w[E] > x[E] && (R = ow(R));
      var N = ow(R), $ = [];
      if (o && $.push(M[P] <= 0), s && $.push(M[R] <= 0, M[N] <= 0), $.every(function(X) {
        return X;
      })) {
        C = k, _ = !1;
        break;
      }
      S.set(k, $);
    }
    if (_)
      for (var F = p ? 3 : 1, W = function(X) {
        var ie = O.find(function(ae) {
          var ee = S.get(ae);
          if (ee)
            return ee.slice(0, X).every(function(ne) {
              return ne;
            });
        });
        if (ie)
          return C = ie, "break";
      }, j = F; j > 0; j--) {
        var Y = W(j);
        if (Y === "break")
          break;
      }
    e.placement !== C && (e.modifiersData[r]._skip = !0, e.placement = C, e.reset = !0);
  }
}
var _me = { name: "flip", enabled: !0, phase: "main", fn: Sme, requiresIfExists: ["offset"], data: { _skip: !1 } };
function H3(n, e, t) {
  return t === void 0 && (t = { x: 0, y: 0 }), { top: n.top - e.height - t.y, right: n.right - e.width + t.x, bottom: n.bottom - e.height + t.y, left: n.left - e.width - t.x };
}
function q3(n) {
  return [Co, Ma, Ea, Ao].some(function(e) {
    return n[e] >= 0;
  });
}
function Cme(n) {
  var e = n.state, t = n.name, r = e.rects.reference, i = e.rects.popper, o = e.modifiersData.preventOverflow, a = Jy(e, { elementContext: "reference" }), s = Jy(e, { altBoundary: !0 }), l = H3(a, r), u = H3(s, i, o), c = q3(l), h = q3(u);
  e.modifiersData[t] = { referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: h }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": h });
}
var Ame = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: Cme };
function Tme(n, e, t) {
  var r = ul(n), i = [Ao, Co].indexOf(r) >= 0 ? -1 : 1, o = typeof t == "function" ? t(Object.assign({}, e, { placement: n })) : t, a = o[0], s = o[1];
  return a = a || 0, s = (s || 0) * i, [Ao, Ma].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
}
function kme(n) {
  var e = n.state, t = n.options, r = n.name, i = t.offset, o = i === void 0 ? [0, 0] : i, a = y_.reduce(function(c, h) {
    return c[h] = Tme(h, e.rects, o), c;
  }, {}), s = a[e.placement], l = s.x, u = s.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = a;
}
var Pme = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: kme };
function Eme(n) {
  var e = n.state, t = n.name;
  e.modifiersData[t] = N7({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var $7 = { name: "popperOffsets", enabled: !0, phase: "read", fn: Eme, data: {} };
function Mme(n) {
  return n === "x" ? "y" : "x";
}
function Dme(n) {
  var e = n.state, t = n.options, r = n.name, i = t.mainAxis, o = i === void 0 ? !0 : i, a = t.altAxis, s = a === void 0 ? !1 : a, l = t.boundary, u = t.rootBoundary, c = t.altBoundary, h = t.padding, f = t.tether, d = f === void 0 ? !0 : f, p = t.tetherOffset, g = p === void 0 ? 0 : p, v = Jy(e, { boundary: l, rootBoundary: u, padding: h, altBoundary: c }), m = ul(e.placement), y = yg(e.placement), b = !y, O = CL(m), w = Mme(O), x = e.modifiersData.popperOffsets, S = e.rects.reference, _ = e.rects.popper, C = typeof g == "function" ? g(Object.assign({}, e.rects, { placement: e.placement })) : g, A = typeof C == "number" ? { mainAxis: C, altAxis: C } : Object.assign({ mainAxis: 0, altAxis: 0 }, C), k = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, P = { x: 0, y: 0 };
  if (x) {
    if (o) {
      var L, D = O === "y" ? Co : Ao, E = O === "y" ? Ea : Ma, M = O === "y" ? "height" : "width", R = x[O], N = R + v[D], $ = R - v[E], F = d ? -_[M] / 2 : 0, W = y === pg ? S[M] : _[M], j = y === pg ? -_[M] : -S[M], Y = e.elements.arrow, X = d && Y ? _L(Y) : { width: 0, height: 0 }, ie = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : E7(), ae = ie[D], ee = ie[E], ne = cy(0, S[M], X[M]), ye = b ? S[M] / 2 - F - ne - ae - A.mainAxis : W - ne - ae - A.mainAxis, te = b ? -S[M] / 2 + F + ne + ee + A.mainAxis : j + ne + ee + A.mainAxis, ue = e.elements.arrow && bb(e.elements.arrow), xe = ue ? O === "y" ? ue.clientTop || 0 : ue.clientLeft || 0 : 0, dt = (L = k == null ? void 0 : k[O]) != null ? L : 0, Ue = R + ye - dt - xe, Rt = R + te - dt, zt = cy(d ? fx(N, Ue) : N, R, d ? If($, Rt) : $);
      x[O] = zt, P[O] = zt - R;
    }
    if (s) {
      var tn, jn = O === "x" ? Co : Ao, An = O === "x" ? Ea : Ma, Tn = x[w], Un = w === "y" ? "height" : "width", Vi = Tn + v[jn], Jr = Tn - v[An], _i = [Co, Ao].indexOf(m) !== -1, Oe = (tn = k == null ? void 0 : k[w]) != null ? tn : 0, xt = _i ? Vi : Tn - S[Un] - _[Un] - Oe + A.altAxis, wn = _i ? Tn + S[Un] + _[Un] - Oe - A.altAxis : Jr, oo = d && _i ? ome(xt, Tn, wn) : cy(d ? xt : Vi, Tn, d ? wn : Jr);
      x[w] = oo, P[w] = oo - Tn;
    }
    e.modifiersData[r] = P;
  }
}
var Lme = { name: "preventOverflow", enabled: !0, phase: "main", fn: Dme, requiresIfExists: ["offset"] };
function Ime(n) {
  return { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop };
}
function Rme(n) {
  return n === ws(n) || !Sa(n) ? AL(n) : Ime(n);
}
function Nme(n) {
  var e = n.getBoundingClientRect(), t = vg(e.width) / n.offsetWidth || 1, r = vg(e.height) / n.offsetHeight || 1;
  return t !== 1 || r !== 1;
}
function $me(n, e, t) {
  t === void 0 && (t = !1);
  var r = Sa(e), i = Sa(e) && Nme(e), o = oh(e), a = mg(n, i), s = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 };
  return (r || !r && !t) && ((ml(e) !== "body" || kL(o)) && (s = Rme(e)), Sa(e) ? (l = mg(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = TL(o))), { x: a.left + s.scrollLeft - l.x, y: a.top + s.scrollTop - l.y, width: a.width, height: a.height };
}
function Bme(n) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), r = [];
  n.forEach(function(o) {
    e.set(o.name, o);
  });
  function i(o) {
    t.add(o.name);
    var a = [].concat(o.requires || [], o.requiresIfExists || []);
    a.forEach(function(s) {
      if (!t.has(s)) {
        var l = e.get(s);
        l && i(l);
      }
    }), r.push(o);
  }
  return n.forEach(function(o) {
    t.has(o.name) || i(o);
  }), r;
}
function Vme(n) {
  var e = Bme(n);
  return eme.reduce(function(t, r) {
    return t.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function zme(n) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(n());
      });
    })), e;
  };
}
function Fme(n) {
  var e = n.reduce(function(t, r) {
    var i = t[r.name];
    return t[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var Y3 = { placement: "bottom", modifiers: [], strategy: "absolute" };
function X3() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function PL(n) {
  n === void 0 && (n = {});
  var e = n, t = e.defaultModifiers, r = t === void 0 ? [] : t, i = e.defaultOptions, o = i === void 0 ? Y3 : i;
  return function(a, s, l) {
    l === void 0 && (l = o);
    var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Y3, o), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, c = [], h = !1, f = { state: u, setOptions: function(g) {
      var v = typeof g == "function" ? g(u.options) : g;
      p(), u.options = Object.assign({}, o, u.options, v), u.scrollParents = { reference: gg(a) ? hy(a) : a.contextElement ? hy(a.contextElement) : [], popper: hy(s) };
      var m = Vme(Fme([].concat(r, u.options.modifiers)));
      return u.orderedModifiers = m.filter(function(y) {
        return y.enabled;
      }), d(), f.update();
    }, forceUpdate: function() {
      if (!h) {
        var g = u.elements, v = g.reference, m = g.popper;
        if (X3(v, m)) {
          u.rects = { reference: $me(v, bb(m), u.options.strategy === "fixed"), popper: _L(m) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(_) {
            return u.modifiersData[_.name] = Object.assign({}, _.data);
          });
          for (var y = 0; y < u.orderedModifiers.length; y++) {
            if (u.reset === !0) {
              u.reset = !1, y = -1;
              continue;
            }
            var b = u.orderedModifiers[y], O = b.fn, w = b.options, x = w === void 0 ? {} : w, S = b.name;
            typeof O == "function" && (u = O({ state: u, options: x, name: S, instance: f }) || u);
          }
        }
      }
    }, update: zme(function() {
      return new Promise(function(g) {
        f.forceUpdate(), g(u);
      });
    }), destroy: function() {
      p(), h = !0;
    } };
    if (!X3(a, s))
      return f;
    f.setOptions(l).then(function(g) {
      !h && l.onFirstUpdate && l.onFirstUpdate(g);
    });
    function d() {
      u.orderedModifiers.forEach(function(g) {
        var v = g.name, m = g.options, y = m === void 0 ? {} : m, b = g.effect;
        if (typeof b == "function") {
          var O = b({ state: u, name: v, instance: f, options: y }), w = function() {
          };
          c.push(O || w);
        }
      });
    }
    function p() {
      c.forEach(function(g) {
        return g();
      }), c = [];
    }
    return f;
  };
}
PL();
var Qme = [I7, $7, L7, k7];
PL({ defaultModifiers: Qme });
var Zme = [I7, $7, L7, k7, Pme, _me, Lme, ume, Ame], Wme = PL({ defaultModifiers: Zme });
const Gme = (n, e, t = {}) => {
  const r = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const u = jme(l);
      Object.assign(a.value, u);
    },
    requires: ["computeStyles"]
  }, i = B(() => {
    const { onFirstUpdate: l, placement: u, strategy: c, modifiers: h } = T(t);
    return {
      onFirstUpdate: l,
      placement: u || "bottom",
      strategy: c || "absolute",
      modifiers: [
        ...h || [],
        r,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), o = di(), a = z({
    styles: {
      popper: {
        position: T(i).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), s = () => {
    o.value && (o.value.destroy(), o.value = void 0);
  };
  return he(i, (l) => {
    const u = T(o);
    u && u.setOptions(l);
  }, {
    deep: !0
  }), he([n, e], ([l, u]) => {
    s(), !(!l || !u) && (o.value = Wme(l, u, T(i)));
  }), xi(() => {
    s();
  }), {
    state: B(() => {
      var l;
      return { ...((l = T(o)) == null ? void 0 : l.state) || {} };
    }),
    styles: B(() => T(a).styles),
    attributes: B(() => T(a).attributes),
    update: () => {
      var l;
      return (l = T(o)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = T(o)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: B(() => T(o))
  };
};
function jme(n) {
  const e = Object.keys(n.elements), t = ux(e.map((i) => [i, n.styles[i] || {}])), r = ux(e.map((i) => [i, n.attributes[i]]));
  return {
    styles: t,
    attributes: r
  };
}
const EL = (n) => {
  if (!n)
    return { onClick: ll, onMousedown: ll, onMouseup: ll };
  let e = !1, t = !1;
  return { onClick: (a) => {
    e && t && n(a), e = t = !1;
  }, onMousedown: (a) => {
    e = a.target === a.currentTarget;
  }, onMouseup: (a) => {
    t = a.target === a.currentTarget;
  } };
};
function U3() {
  let n;
  const e = (r, i) => {
    t(), n = window.setTimeout(r, i);
  }, t = () => window.clearTimeout(n);
  return mb(() => t()), {
    registerTimeout: e,
    cancelTimeout: t
  };
}
const sP = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, Hme = Symbol("elIdInjection"), ML = () => wt() ? Re(Hme, sP) : sP, fs = (n) => {
  const e = ML();
  !qt && e === sP && Ht("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const t = wL();
  return B(() => T(n) || `${t.value}-id-${e.prefix}-${e.current++}`);
};
let bp = [];
const K3 = (n) => {
  const e = n;
  e.key === Ft.esc && bp.forEach((t) => t(e));
}, qme = (n) => {
  ht(() => {
    bp.length === 0 && document.addEventListener("keydown", K3), qt && bp.push(n);
  }), xi(() => {
    bp = bp.filter((e) => e !== n), bp.length === 0 && qt && document.removeEventListener("keydown", K3);
  });
};
let J3;
const B7 = () => {
  const n = wL(), e = ML(), t = B(() => `${n.value}-popper-container-${e.prefix}`), r = B(() => `#${t.value}`);
  return {
    id: t,
    selector: r
  };
}, Yme = (n) => {
  const e = document.createElement("div");
  return e.id = n, document.body.appendChild(e), e;
}, Xme = () => {
  const { id: n, selector: e } = B7();
  return JD(() => {
    qt && (process.env.NODE_ENV === "test" || !J3 && !document.body.querySelector(e.value)) && (J3 = Yme(n.value));
  }), {
    id: n,
    selector: e
  };
}, Ume = Ye({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), Kme = ({
  showAfter: n,
  hideAfter: e,
  autoClose: t,
  open: r,
  close: i
}) => {
  const { registerTimeout: o } = U3(), {
    registerTimeout: a,
    cancelTimeout: s
  } = U3();
  return {
    onOpen: (c) => {
      o(() => {
        r(c);
        const h = T(t);
        _t(h) && h > 0 && a(() => {
          i(c);
        }, h);
      }, T(n));
    },
    onClose: (c) => {
      s(), o(() => {
        i(c);
      }, T(e));
    }
  };
}, V7 = Symbol("elForwardRef"), Jme = (n) => {
  Wt(V7, {
    setForwardRef: (t) => {
      n.value = t;
    }
  });
}, eye = (n) => ({
  mounted(e) {
    n(e);
  },
  updated(e) {
    n(e);
  },
  unmounted() {
    n(null);
  }
}), eB = z(0), z7 = 2e3, F7 = Symbol("zIndexContextKey"), DL = (n) => {
  const e = n || (wt() ? Re(F7, void 0) : void 0), t = B(() => {
    const o = T(e);
    return _t(o) ? o : z7;
  }), r = B(() => t.value + eB.value);
  return {
    initialZIndex: t,
    currentZIndex: r,
    nextZIndex: () => (eB.value++, r.value)
  };
};
function tye(n) {
  const e = z();
  function t() {
    if (n.value == null)
      return;
    const { selectionStart: i, selectionEnd: o, value: a } = n.value;
    if (i == null || o == null)
      return;
    const s = a.slice(0, Math.max(0, i)), l = a.slice(Math.max(0, o));
    e.value = {
      selectionStart: i,
      selectionEnd: o,
      value: a,
      beforeTxt: s,
      afterTxt: l
    };
  }
  function r() {
    if (n.value == null || e.value == null)
      return;
    const { value: i } = n.value, { beforeTxt: o, afterTxt: a, selectionStart: s } = e.value;
    if (o == null || a == null || s == null)
      return;
    let l = i.length;
    if (i.endsWith(a))
      l = i.length - a.length;
    else if (i.startsWith(o))
      l = o.length;
    else {
      const u = o[s - 1], c = i.indexOf(u, s - 1);
      c !== -1 && (l = c + 1);
    }
    n.value.setSelectionRange(l, l);
  }
  return [t, r];
}
const nye = (n, e, t) => iw(n.subTree).filter((o) => {
  var a;
  return gl(o) && ((a = o.type) == null ? void 0 : a.name) === e && !!o.component;
}).map((o) => o.component.uid).map((o) => t[o]).filter((o) => !!o), rye = (n, e) => {
  const t = {}, r = di([]);
  return {
    children: r,
    addChild: (a) => {
      t[a.uid] = a, r.value = nye(n, e, t);
    },
    removeChild: (a) => {
      delete t[a], r.value = r.value.filter((s) => s.uid !== a);
    }
  };
}, Ra = v_({
  type: String,
  values: Cd,
  required: !1
}), Q7 = Symbol("size"), iye = () => {
  const n = Re(Q7, {});
  return B(() => T(n.size) || "");
};
function LL(n, { afterFocus: e, beforeBlur: t, afterBlur: r } = {}) {
  const i = wt(), { emit: o } = i, a = di(), s = z(!1), l = (h) => {
    s.value || (s.value = !0, o("focus", h), e == null || e());
  }, u = (h) => {
    var f;
    fn(t) && t(h) || h.relatedTarget && ((f = a.value) != null && f.contains(h.relatedTarget)) || (s.value = !1, o("blur", h), r == null || r());
  }, c = () => {
    var h;
    (h = n.value) == null || h.focus();
  };
  return he(a, (h) => {
    h && h.setAttribute("tabindex", "-1");
  }), Yi(a, "click", c), {
    wrapperRef: a,
    isFocused: s,
    handleFocus: l,
    handleBlur: u
  };
}
const Z7 = Symbol(), dx = z();
function O_(n, e = void 0) {
  const t = wt() ? Re(Z7, dx) : dx;
  return n ? B(() => {
    var r, i;
    return (i = (r = t.value) == null ? void 0 : r[n]) != null ? i : e;
  }) : t;
}
function IL(n, e) {
  const t = O_(), r = Pe(n, B(() => {
    var s;
    return ((s = t.value) == null ? void 0 : s.namespace) || uy;
  })), i = Ar(B(() => {
    var s;
    return (s = t.value) == null ? void 0 : s.locale;
  })), o = DL(B(() => {
    var s;
    return ((s = t.value) == null ? void 0 : s.zIndex) || z7;
  })), a = B(() => {
    var s;
    return T(e) || ((s = t.value) == null ? void 0 : s.size) || "";
  });
  return W7(B(() => T(t) || {})), {
    ns: r,
    locale: i,
    zIndex: o,
    size: a
  };
}
const W7 = (n, e, t = !1) => {
  var r;
  const i = !!wt(), o = i ? O_() : void 0, a = (r = e == null ? void 0 : e.provide) != null ? r : i ? Wt : void 0;
  if (!a) {
    Ht("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const s = B(() => {
    const l = T(n);
    return o != null && o.value ? oye(o.value, l) : l;
  });
  return a(Z7, s), a(y7, B(() => s.value.locale)), a(S7, B(() => s.value.namespace)), a(F7, B(() => s.value.zIndex)), a(Q7, {
    size: B(() => s.value.size || "")
  }), (t || !dx.value) && (dx.value = s.value), s;
}, oye = (n, e) => {
  var t;
  const r = [.../* @__PURE__ */ new Set([...$3(n), ...$3(e)])], i = {};
  for (const o of r)
    i[o] = (t = e[o]) != null ? t : n[o];
  return i;
}, aye = Ye({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: Ae(Object)
  },
  size: Ra,
  button: {
    type: Ae(Object)
  },
  experimentalFeatures: {
    type: Ae(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: Ae(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
}), lP = {};
U({
  name: "ElConfigProvider",
  props: aye,
  setup(n, { slots: e }) {
    he(() => n.message, (r) => {
      Object.assign(lP, r ?? {});
    }, { immediate: !0, deep: !0 });
    const t = W7(n);
    return () => ke(e, "default", { config: t == null ? void 0 : t.value });
  }
});
var Ve = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, i] of e)
    t[r] = i;
  return t;
};
const sye = Ye({
  size: {
    type: Ae([Number, String])
  },
  color: {
    type: String
  }
}), lye = U({
  name: "ElIcon",
  inheritAttrs: !1
}), uye = /* @__PURE__ */ U({
  ...lye,
  props: sye,
  setup(n) {
    const e = n, t = Pe("icon"), r = B(() => {
      const { size: i, color: o } = e;
      return !i && !o ? {} : {
        fontSize: Li(i) ? void 0 : Xo(i),
        "--color": o
      };
    });
    return (i, o) => (V(), q("i", xa({
      class: T(t).b(),
      style: T(r)
    }, i.$attrs), [
      ke(i.$slots, "default")
    ], 16));
  }
});
var cye = /* @__PURE__ */ Ve(uye, [["__file", "icon.vue"]]);
const bt = zn(cye), fv = Symbol("formContextKey"), Ec = Symbol("formItemContextKey"), ko = (n, e = {}) => {
  const t = z(void 0), r = e.prop ? t : A7("size"), i = e.global ? t : iye(), o = e.form ? { size: void 0 } : Re(fv, void 0), a = e.formItem ? { size: void 0 } : Re(Ec, void 0);
  return B(() => r.value || T(n) || (a == null ? void 0 : a.size) || (o == null ? void 0 : o.size) || i.value || "");
}, ah = (n) => {
  const e = A7("disabled"), t = Re(fv, void 0);
  return B(() => e.value || T(n) || (t == null ? void 0 : t.disabled) || !1);
}, Na = () => {
  const n = Re(fv, void 0), e = Re(Ec, void 0);
  return {
    form: n,
    formItem: e
  };
}, Ad = (n, {
  formItemContext: e,
  disableIdGeneration: t,
  disableIdManagement: r
}) => {
  t || (t = z(!1)), r || (r = z(!1));
  const i = z();
  let o;
  const a = B(() => {
    var s;
    return !!(!n.label && e && e.inputIds && ((s = e.inputIds) == null ? void 0 : s.length) <= 1);
  });
  return ht(() => {
    o = he([ba(n, "id"), t], ([s, l]) => {
      const u = s ?? (l ? void 0 : fs().value);
      u !== i.value && (e != null && e.removeInputId && (i.value && e.removeInputId(i.value), !(r != null && r.value) && !l && u && e.addInputId(u)), i.value = u);
    }, { immediate: !0 });
  }), ub(() => {
    o && o(), e != null && e.removeInputId && i.value && e.removeInputId(i.value);
  }), {
    isLabeledByFormItem: a,
    inputId: i
  };
}, hye = Ye({
  size: {
    type: String,
    values: Cd
  },
  disabled: Boolean
}), fye = Ye({
  ...hye,
  model: Object,
  rules: {
    type: Ae(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: !0
  },
  validateOnRuleChange: {
    type: Boolean,
    default: !0
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: [Object, Boolean]
  }
}), dye = {
  validate: (n, e, t) => (_n(n) || Ut(n)) && pi(e) && Ut(t)
}, pye = "ElForm";
function gye() {
  const n = z([]), e = B(() => {
    if (!n.value.length)
      return "0";
    const o = Math.max(...n.value);
    return o ? `${o}px` : "";
  });
  function t(o) {
    const a = n.value.indexOf(o);
    return a === -1 && e.value === "0" && Ht(pye, `unexpected width ${o}`), a;
  }
  function r(o, a) {
    if (o && a) {
      const s = t(a);
      n.value.splice(s, 1, o);
    } else
      o && n.value.push(o);
  }
  function i(o) {
    const a = t(o);
    a > -1 && n.value.splice(a, 1);
  }
  return {
    autoLabelWidth: e,
    registerLabelWidth: r,
    deregisterLabelWidth: i
  };
}
const u1 = (n, e) => {
  const t = Yy(e);
  return t.length > 0 ? n.filter((r) => r.prop && t.includes(r.prop)) : n;
}, aw = "ElForm", vye = U({
  name: aw
}), mye = /* @__PURE__ */ U({
  ...vye,
  props: fye,
  emits: dye,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = [], o = ko(), a = Pe("form"), s = B(() => {
      const { labelPosition: b, inline: O } = r;
      return [
        a.b(),
        a.m(o.value || "default"),
        {
          [a.m(`label-${b}`)]: b,
          [a.m("inline")]: O
        }
      ];
    }), l = (b) => i.find((O) => O.prop === b), u = (b) => {
      i.push(b);
    }, c = (b) => {
      b.prop && i.splice(i.indexOf(b), 1);
    }, h = (b = []) => {
      if (!r.model) {
        Ht(aw, "model is required for resetFields to work.");
        return;
      }
      u1(i, b).forEach((O) => O.resetField());
    }, f = (b = []) => {
      u1(i, b).forEach((O) => O.clearValidate());
    }, d = B(() => {
      const b = !!r.model;
      return b || Ht(aw, "model is required for validate to work."), b;
    }), p = (b) => {
      if (i.length === 0)
        return [];
      const O = u1(i, b);
      return O.length ? O : (Ht(aw, "please pass correct props!"), []);
    }, g = async (b) => m(void 0, b), v = async (b = []) => {
      if (!d.value)
        return !1;
      const O = p(b);
      if (O.length === 0)
        return !0;
      let w = {};
      for (const x of O)
        try {
          await x.validate("");
        } catch (S) {
          w = {
            ...w,
            ...S
          };
        }
      return Object.keys(w).length === 0 ? !0 : Promise.reject(w);
    }, m = async (b = [], O) => {
      const w = !fn(O);
      try {
        const x = await v(b);
        return x === !0 && (O == null || O(x)), x;
      } catch (x) {
        if (x instanceof Error)
          throw x;
        const S = x;
        return r.scrollToError && y(Object.keys(S)[0]), O == null || O(!1, S), w && Promise.reject(S);
      }
    }, y = (b) => {
      var O;
      const w = u1(i, b)[0];
      w && ((O = w.$el) == null || O.scrollIntoView(r.scrollIntoViewOptions));
    };
    return he(() => r.rules, () => {
      r.validateOnRuleChange && g().catch((b) => Ht(b));
    }, { deep: !0 }), Wt(fv, dr({
      ...bu(r),
      emit: t,
      resetFields: h,
      clearValidate: f,
      validateField: m,
      getField: l,
      addField: u,
      removeField: c,
      ...gye()
    })), e({
      validate: g,
      validateField: m,
      resetFields: h,
      clearValidate: f,
      scrollToField: y
    }), (b, O) => (V(), q("form", {
      class: Q(T(s))
    }, [
      ke(b.$slots, "default")
    ], 2));
  }
});
var yye = /* @__PURE__ */ Ve(mye, [["__file", "form.vue"]]);
const bye = [
  "",
  "error",
  "validating",
  "success"
], Oye = Ye({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: Ae([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: Ae([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: bye
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: !0
  },
  size: {
    type: String,
    values: Cd
  }
}), tB = "ElLabelWrap";
var wye = U({
  name: tB,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(n, {
    slots: e
  }) {
    const t = Re(fv, void 0), r = Re(Ec);
    r || Su(tB, "usage: <el-form-item><label-wrap /></el-form-item>");
    const i = Pe("form"), o = z(), a = z(0), s = () => {
      var c;
      if ((c = o.value) != null && c.firstElementChild) {
        const h = window.getComputedStyle(o.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(h));
      } else
        return 0;
    }, l = (c = "update") => {
      Ke(() => {
        e.default && n.isAutoWidth && (c === "update" ? a.value = s() : c === "remove" && (t == null || t.deregisterLabelWidth(a.value)));
      });
    }, u = () => l("update");
    return ht(() => {
      u();
    }), xi(() => {
      l("remove");
    }), yd(() => u()), he(a, (c, h) => {
      n.updateAll && (t == null || t.registerLabelWidth(c, h));
    }), Ei(B(() => {
      var c, h;
      return (h = (c = o.value) == null ? void 0 : c.firstElementChild) != null ? h : null;
    }), u), () => {
      var c, h;
      if (!e)
        return null;
      const {
        isAutoWidth: f
      } = n;
      if (f) {
        const d = t == null ? void 0 : t.autoLabelWidth, p = r == null ? void 0 : r.hasLabel, g = {};
        if (p && d && d !== "auto") {
          const v = Math.max(0, Number.parseInt(d, 10) - a.value), m = t.labelPosition === "left" ? "marginRight" : "marginLeft";
          v && (g[m] = `${v}px`);
        }
        return de("div", {
          ref: o,
          class: [i.be("item", "label-wrap")],
          style: g
        }, [(c = e.default) == null ? void 0 : c.call(e)]);
      } else
        return de(yn, {
          ref: o
        }, [(h = e.default) == null ? void 0 : h.call(e)]);
    };
  }
});
const xye = ["role", "aria-labelledby"], Sye = U({
  name: "ElFormItem"
}), _ye = /* @__PURE__ */ U({
  ...Sye,
  props: Oye,
  setup(n, { expose: e }) {
    const t = n, r = Tl(), i = Re(fv, void 0), o = Re(Ec, void 0), a = ko(void 0, { formItem: !1 }), s = Pe("form-item"), l = fs().value, u = z([]), c = z(""), h = Nge(c, 100), f = z(""), d = z();
    let p, g = !1;
    const v = B(() => {
      if ((i == null ? void 0 : i.labelPosition) === "top")
        return {};
      const ee = Xo(t.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
      return ee ? { width: ee } : {};
    }), m = B(() => {
      if ((i == null ? void 0 : i.labelPosition) === "top" || i != null && i.inline)
        return {};
      if (!t.label && !t.labelWidth && C)
        return {};
      const ee = Xo(t.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
      return !t.label && !r.label ? { marginLeft: ee } : {};
    }), y = B(() => [
      s.b(),
      s.m(a.value),
      s.is("error", c.value === "error"),
      s.is("validating", c.value === "validating"),
      s.is("success", c.value === "success"),
      s.is("required", D.value || t.required),
      s.is("no-asterisk", i == null ? void 0 : i.hideRequiredAsterisk),
      (i == null ? void 0 : i.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      { [s.m("feedback")]: i == null ? void 0 : i.statusIcon }
    ]), b = B(() => pi(t.inlineMessage) ? t.inlineMessage : (i == null ? void 0 : i.inlineMessage) || !1), O = B(() => [
      s.e("error"),
      { [s.em("error", "inline")]: b.value }
    ]), w = B(() => t.prop ? Ut(t.prop) ? t.prop : t.prop.join(".") : ""), x = B(() => !!(t.label || r.label)), S = B(() => t.for || (u.value.length === 1 ? u.value[0] : void 0)), _ = B(() => !S.value && x.value), C = !!o, A = B(() => {
      const ee = i == null ? void 0 : i.model;
      if (!(!ee || !t.prop))
        return nw(ee, t.prop).value;
    }), k = B(() => {
      const { required: ee } = t, ne = [];
      t.rules && ne.push(...Yy(t.rules));
      const ye = i == null ? void 0 : i.rules;
      if (ye && t.prop) {
        const te = nw(ye, t.prop).value;
        te && ne.push(...Yy(te));
      }
      if (ee !== void 0) {
        const te = ne.map((ue, xe) => [ue, xe]).filter(([ue]) => Object.keys(ue).includes("required"));
        if (te.length > 0)
          for (const [ue, xe] of te)
            ue.required !== ee && (ne[xe] = { ...ue, required: ee });
        else
          ne.push({ required: ee });
      }
      return ne;
    }), P = B(() => k.value.length > 0), L = (ee) => k.value.filter((ye) => !ye.trigger || !ee ? !0 : Array.isArray(ye.trigger) ? ye.trigger.includes(ee) : ye.trigger === ee).map(({ trigger: ye, ...te }) => te), D = B(() => k.value.some((ee) => ee.required)), E = B(() => {
      var ee;
      return h.value === "error" && t.showMessage && ((ee = i == null ? void 0 : i.showMessage) != null ? ee : !0);
    }), M = B(() => `${t.label || ""}${(i == null ? void 0 : i.labelSuffix) || ""}`), R = (ee) => {
      c.value = ee;
    }, N = (ee) => {
      var ne, ye;
      const { errors: te, fields: ue } = ee;
      (!te || !ue) && console.error(ee), R("error"), f.value = te ? (ye = (ne = te == null ? void 0 : te[0]) == null ? void 0 : ne.message) != null ? ye : `${t.prop} is required` : "", i == null || i.emit("validate", t.prop, !1, f.value);
    }, $ = () => {
      R("success"), i == null || i.emit("validate", t.prop, !0, "");
    }, F = async (ee) => {
      const ne = w.value;
      return new vb({
        [ne]: ee
      }).validate({ [ne]: A.value }, { firstFields: !0 }).then(() => ($(), !0)).catch((te) => (N(te), Promise.reject(te)));
    }, W = async (ee, ne) => {
      if (g || !t.prop)
        return !1;
      const ye = fn(ne);
      if (!P.value)
        return ne == null || ne(!1), !1;
      const te = L(ee);
      return te.length === 0 ? (ne == null || ne(!0), !0) : (R("validating"), F(te).then(() => (ne == null || ne(!0), !0)).catch((ue) => {
        const { fields: xe } = ue;
        return ne == null || ne(!1, xe), ye ? !1 : Promise.reject(xe);
      }));
    }, j = () => {
      R(""), f.value = "", g = !1;
    }, Y = async () => {
      const ee = i == null ? void 0 : i.model;
      if (!ee || !t.prop)
        return;
      const ne = nw(ee, t.prop);
      g = !0, ne.value = Xy(p), await Ke(), j(), g = !1;
    }, X = (ee) => {
      u.value.includes(ee) || u.value.push(ee);
    }, ie = (ee) => {
      u.value = u.value.filter((ne) => ne !== ee);
    };
    he(() => t.error, (ee) => {
      f.value = ee || "", R(ee ? "error" : "");
    }, { immediate: !0 }), he(() => t.validateStatus, (ee) => R(ee || ""));
    const ae = dr({
      ...bu(t),
      $el: d,
      size: a,
      validateState: c,
      labelId: l,
      inputIds: u,
      isGroup: _,
      hasLabel: x,
      fieldValue: A,
      addInputId: X,
      removeInputId: ie,
      resetField: Y,
      clearValidate: j,
      validate: W
    });
    return Wt(Ec, ae), ht(() => {
      t.prop && (i == null || i.addField(ae), p = Xy(A.value));
    }), xi(() => {
      i == null || i.removeField(ae);
    }), e({
      size: a,
      validateMessage: f,
      validateState: c,
      validate: W,
      clearValidate: j,
      resetField: Y
    }), (ee, ne) => {
      var ye;
      return V(), q("div", {
        ref_key: "formItemRef",
        ref: d,
        class: Q(T(y)),
        role: T(_) ? "group" : void 0,
        "aria-labelledby": T(_) ? T(l) : void 0
      }, [
        de(T(wye), {
          "is-auto-width": T(v).width === "auto",
          "update-all": ((ye = T(i)) == null ? void 0 : ye.labelWidth) === "auto"
        }, {
          default: fe(() => [
            T(x) ? (V(), ve(cn(T(S) ? "label" : "div"), {
              key: 0,
              id: T(l),
              for: T(S),
              class: Q(T(s).e("label")),
              style: vt(T(v))
            }, {
              default: fe(() => [
                ke(ee.$slots, "label", { label: T(M) }, () => [
                  Ri(ze(T(M)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : pe("v-if", !0)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        J("div", {
          class: Q(T(s).e("content")),
          style: vt(T(m))
        }, [
          ke(ee.$slots, "default"),
          de(rae, {
            name: `${T(s).namespace.value}-zoom-in-top`
          }, {
            default: fe(() => [
              T(E) ? ke(ee.$slots, "error", {
                key: 0,
                error: f.value
              }, () => [
                J("div", {
                  class: Q(T(O))
                }, ze(f.value), 3)
              ]) : pe("v-if", !0)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, xye);
    };
  }
});
var G7 = /* @__PURE__ */ Ve(_ye, [["__file", "form-item.vue"]]);
const XFt = zn(yye, {
  FormItem: G7
}), UFt = Os(G7);
let Fa;
const Cye = `
  height:0 !important;
  visibility:hidden !important;
  ${tve() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, Aye = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function Tye(n) {
  const e = window.getComputedStyle(n), t = e.getPropertyValue("box-sizing"), r = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top")), i = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
  return { contextStyle: Aye.map((a) => `${a}:${e.getPropertyValue(a)}`).join(";"), paddingSize: r, borderSize: i, boxSizing: t };
}
function nB(n, e = 1, t) {
  var r;
  Fa || (Fa = document.createElement("textarea"), document.body.appendChild(Fa));
  const { paddingSize: i, borderSize: o, boxSizing: a, contextStyle: s } = Tye(n);
  Fa.setAttribute("style", `${s};${Cye}`), Fa.value = n.value || n.placeholder || "";
  let l = Fa.scrollHeight;
  const u = {};
  a === "border-box" ? l = l + o : a === "content-box" && (l = l - i), Fa.value = "";
  const c = Fa.scrollHeight - i;
  if (_t(e)) {
    let h = c * e;
    a === "border-box" && (h = h + i + o), l = Math.max(h, l), u.minHeight = `${h}px`;
  }
  if (_t(t)) {
    let h = c * t;
    a === "border-box" && (h = h + i + o), l = Math.min(h, l);
  }
  return u.height = `${l}px`, (r = Fa.parentNode) == null || r.removeChild(Fa), Fa = void 0, u;
}
const kye = Ye({
  id: {
    type: String,
    default: void 0
  },
  size: Ra,
  disabled: Boolean,
  modelValue: {
    type: Ae([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: Ae([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: $r
  },
  prefixIcon: {
    type: $r
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: Ae([Object, Array, String]),
    default: () => ih({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
}), Pye = {
  [Dt]: (n) => Ut(n),
  input: (n) => Ut(n),
  change: (n) => Ut(n),
  focus: (n) => n instanceof FocusEvent,
  blur: (n) => n instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (n) => n instanceof MouseEvent,
  mouseenter: (n) => n instanceof MouseEvent,
  keydown: (n) => n instanceof Event,
  compositionstart: (n) => n instanceof CompositionEvent,
  compositionupdate: (n) => n instanceof CompositionEvent,
  compositionend: (n) => n instanceof CompositionEvent
}, Eye = ["role"], Mye = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], Dye = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], Lye = U({
  name: "ElInput",
  inheritAttrs: !1
}), Iye = /* @__PURE__ */ U({
  ...Lye,
  props: kye,
  emits: Pye,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = PG(), o = Tl(), a = B(() => {
      const Oe = {};
      return r.containerRole === "combobox" && (Oe["aria-haspopup"] = i["aria-haspopup"], Oe["aria-owns"] = i["aria-owns"], Oe["aria-expanded"] = i["aria-expanded"]), Oe;
    }), s = B(() => [
      r.type === "textarea" ? v.b() : g.b(),
      g.m(d.value),
      g.is("disabled", p.value),
      g.is("exceed", X.value),
      {
        [g.b("group")]: o.prepend || o.append,
        [g.bm("group", "append")]: o.append,
        [g.bm("group", "prepend")]: o.prepend,
        [g.m("prefix")]: o.prefix || r.prefixIcon,
        [g.m("suffix")]: o.suffix || r.suffixIcon || r.clearable || r.showPassword,
        [g.bm("suffix", "password-clear")]: F.value && W.value
      },
      i.class
    ]), l = B(() => [
      g.e("wrapper"),
      g.is("focus", A.value)
    ]), u = wve({
      excludeKeys: B(() => Object.keys(a.value))
    }), { form: c, formItem: h } = Na(), { inputId: f } = Ad(r, {
      formItemContext: h
    }), d = ko(), p = ah(), g = Pe("input"), v = Pe("textarea"), m = di(), y = di(), b = z(!1), O = z(!1), w = z(!1), x = z(), S = di(r.inputStyle), _ = B(() => m.value || y.value), { wrapperRef: C, isFocused: A, handleFocus: k, handleBlur: P } = LL(_, {
      afterBlur() {
        var Oe;
        r.validateEvent && ((Oe = h == null ? void 0 : h.validate) == null || Oe.call(h, "blur").catch((xt) => Ht(xt)));
      }
    }), L = B(() => {
      var Oe;
      return (Oe = c == null ? void 0 : c.statusIcon) != null ? Oe : !1;
    }), D = B(() => (h == null ? void 0 : h.validateState) || ""), E = B(() => D.value && p7[D.value]), M = B(() => w.value ? $pe : ppe), R = B(() => [
      i.style
    ]), N = B(() => [
      r.inputStyle,
      S.value,
      { resize: r.resize }
    ]), $ = B(() => _o(r.modelValue) ? "" : String(r.modelValue)), F = B(() => r.clearable && !p.value && !r.readonly && !!$.value && (A.value || b.value)), W = B(() => r.showPassword && !p.value && !r.readonly && !!$.value && (!!$.value || A.value)), j = B(() => r.showWordLimit && !!r.maxlength && (r.type === "text" || r.type === "textarea") && !p.value && !r.readonly && !r.showPassword), Y = B(() => $.value.length), X = B(() => !!j.value && Y.value > Number(r.maxlength)), ie = B(() => !!o.suffix || !!r.suffixIcon || F.value || r.showPassword || j.value || !!D.value && L.value), [ae, ee] = tye(m);
    Ei(y, (Oe) => {
      if (te(), !j.value || r.resize !== "both")
        return;
      const xt = Oe[0], { width: wn } = xt.contentRect;
      x.value = {
        right: `calc(100% - ${wn + 15 + 6}px)`
      };
    });
    const ne = () => {
      const { type: Oe, autosize: xt } = r;
      if (!(!qt || Oe !== "textarea" || !y.value))
        if (xt) {
          const wn = Nr(xt) ? xt.minRows : void 0, oo = Nr(xt) ? xt.maxRows : void 0, Eu = nB(y.value, wn, oo);
          S.value = {
            overflowY: "hidden",
            ...Eu
          }, Ke(() => {
            y.value.offsetHeight, S.value = Eu;
          });
        } else
          S.value = {
            minHeight: nB(y.value).minHeight
          };
    }, te = ((Oe) => {
      let xt = !1;
      return () => {
        var wn;
        if (xt || !r.autosize)
          return;
        ((wn = y.value) == null ? void 0 : wn.offsetParent) === null || (Oe(), xt = !0);
      };
    })(ne), ue = () => {
      const Oe = _.value, xt = r.formatter ? r.formatter($.value) : $.value;
      !Oe || Oe.value === xt || (Oe.value = xt);
    }, xe = async (Oe) => {
      ae();
      let { value: xt } = Oe.target;
      if (r.formatter && (xt = r.parser ? r.parser(xt) : xt), !O.value) {
        if (xt === $.value) {
          ue();
          return;
        }
        t(Dt, xt), t("input", xt), await Ke(), ue(), ee();
      }
    }, dt = (Oe) => {
      t("change", Oe.target.value);
    }, Ue = (Oe) => {
      t("compositionstart", Oe), O.value = !0;
    }, Rt = (Oe) => {
      var xt;
      t("compositionupdate", Oe);
      const wn = (xt = Oe.target) == null ? void 0 : xt.value, oo = wn[wn.length - 1] || "";
      O.value = !OL(oo);
    }, zt = (Oe) => {
      t("compositionend", Oe), O.value && (O.value = !1, xe(Oe));
    }, tn = () => {
      w.value = !w.value, jn();
    }, jn = async () => {
      var Oe;
      await Ke(), (Oe = _.value) == null || Oe.focus();
    }, An = () => {
      var Oe;
      return (Oe = _.value) == null ? void 0 : Oe.blur();
    }, Tn = (Oe) => {
      b.value = !1, t("mouseleave", Oe);
    }, Un = (Oe) => {
      b.value = !0, t("mouseenter", Oe);
    }, Vi = (Oe) => {
      t("keydown", Oe);
    }, Jr = () => {
      var Oe;
      (Oe = _.value) == null || Oe.select();
    }, _i = () => {
      t(Dt, ""), t("change", ""), t("clear"), t("input", "");
    };
    return he(() => r.modelValue, () => {
      var Oe;
      Ke(() => ne()), r.validateEvent && ((Oe = h == null ? void 0 : h.validate) == null || Oe.call(h, "change").catch((xt) => Ht(xt)));
    }), he($, () => ue()), he(() => r.type, async () => {
      await Ke(), ue(), ne();
    }), ht(() => {
      !r.formatter && r.parser && Ht("ElInput", "If you set the parser, you also need to set the formatter."), ue(), Ke(ne);
    }), e({
      input: m,
      textarea: y,
      ref: _,
      textareaStyle: N,
      autosize: ba(r, "autosize"),
      focus: jn,
      blur: An,
      select: Jr,
      clear: _i,
      resizeTextarea: ne
    }), (Oe, xt) => At((V(), q("div", xa(T(a), {
      class: T(s),
      style: T(R),
      role: Oe.containerRole,
      onMouseenter: Un,
      onMouseleave: Tn
    }), [
      pe(" input "),
      Oe.type !== "textarea" ? (V(), q(yn, { key: 0 }, [
        pe(" prepend slot "),
        Oe.$slots.prepend ? (V(), q("div", {
          key: 0,
          class: Q(T(g).be("group", "prepend"))
        }, [
          ke(Oe.$slots, "prepend")
        ], 2)) : pe("v-if", !0),
        J("div", {
          ref_key: "wrapperRef",
          ref: C,
          class: Q(T(l))
        }, [
          pe(" prefix slot "),
          Oe.$slots.prefix || Oe.prefixIcon ? (V(), q("span", {
            key: 0,
            class: Q(T(g).e("prefix"))
          }, [
            J("span", {
              class: Q(T(g).e("prefix-inner"))
            }, [
              ke(Oe.$slots, "prefix"),
              Oe.prefixIcon ? (V(), ve(T(bt), {
                key: 0,
                class: Q(T(g).e("icon"))
              }, {
                default: fe(() => [
                  (V(), ve(cn(Oe.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : pe("v-if", !0)
            ], 2)
          ], 2)) : pe("v-if", !0),
          J("input", xa({
            id: T(f),
            ref_key: "input",
            ref: m,
            class: T(g).e("inner")
          }, T(u), {
            minlength: Oe.minlength,
            maxlength: Oe.maxlength,
            type: Oe.showPassword ? w.value ? "text" : "password" : Oe.type,
            disabled: T(p),
            readonly: Oe.readonly,
            autocomplete: Oe.autocomplete,
            tabindex: Oe.tabindex,
            "aria-label": Oe.label,
            placeholder: Oe.placeholder,
            style: Oe.inputStyle,
            form: Oe.form,
            autofocus: Oe.autofocus,
            onCompositionstart: Ue,
            onCompositionupdate: Rt,
            onCompositionend: zt,
            onInput: xe,
            onFocus: xt[0] || (xt[0] = (...wn) => T(k) && T(k)(...wn)),
            onBlur: xt[1] || (xt[1] = (...wn) => T(P) && T(P)(...wn)),
            onChange: dt,
            onKeydown: Vi
          }), null, 16, Mye),
          pe(" suffix slot "),
          T(ie) ? (V(), q("span", {
            key: 1,
            class: Q(T(g).e("suffix"))
          }, [
            J("span", {
              class: Q(T(g).e("suffix-inner"))
            }, [
              !T(F) || !T(W) || !T(j) ? (V(), q(yn, { key: 0 }, [
                ke(Oe.$slots, "suffix"),
                Oe.suffixIcon ? (V(), ve(T(bt), {
                  key: 0,
                  class: Q(T(g).e("icon"))
                }, {
                  default: fe(() => [
                    (V(), ve(cn(Oe.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : pe("v-if", !0)
              ], 64)) : pe("v-if", !0),
              T(F) ? (V(), ve(T(bt), {
                key: 1,
                class: Q([T(g).e("icon"), T(g).e("clear")]),
                onMousedown: kt(T(ll), ["prevent"]),
                onClick: _i
              }, {
                default: fe(() => [
                  de(T(gb))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : pe("v-if", !0),
              T(W) ? (V(), ve(T(bt), {
                key: 2,
                class: Q([T(g).e("icon"), T(g).e("password")]),
                onClick: tn
              }, {
                default: fe(() => [
                  (V(), ve(cn(T(M))))
                ]),
                _: 1
              }, 8, ["class"])) : pe("v-if", !0),
              T(j) ? (V(), q("span", {
                key: 3,
                class: Q(T(g).e("count"))
              }, [
                J("span", {
                  class: Q(T(g).e("count-inner"))
                }, ze(T(Y)) + " / " + ze(Oe.maxlength), 3)
              ], 2)) : pe("v-if", !0),
              T(D) && T(E) && T(L) ? (V(), ve(T(bt), {
                key: 4,
                class: Q([
                  T(g).e("icon"),
                  T(g).e("validateIcon"),
                  T(g).is("loading", T(D) === "validating")
                ])
              }, {
                default: fe(() => [
                  (V(), ve(cn(T(E))))
                ]),
                _: 1
              }, 8, ["class"])) : pe("v-if", !0)
            ], 2)
          ], 2)) : pe("v-if", !0)
        ], 2),
        pe(" append slot "),
        Oe.$slots.append ? (V(), q("div", {
          key: 1,
          class: Q(T(g).be("group", "append"))
        }, [
          ke(Oe.$slots, "append")
        ], 2)) : pe("v-if", !0)
      ], 64)) : (V(), q(yn, { key: 1 }, [
        pe(" textarea "),
        J("textarea", xa({
          id: T(f),
          ref_key: "textarea",
          ref: y,
          class: T(v).e("inner")
        }, T(u), {
          minlength: Oe.minlength,
          maxlength: Oe.maxlength,
          tabindex: Oe.tabindex,
          disabled: T(p),
          readonly: Oe.readonly,
          autocomplete: Oe.autocomplete,
          style: T(N),
          "aria-label": Oe.label,
          placeholder: Oe.placeholder,
          form: Oe.form,
          autofocus: Oe.autofocus,
          onCompositionstart: Ue,
          onCompositionupdate: Rt,
          onCompositionend: zt,
          onInput: xe,
          onFocus: xt[2] || (xt[2] = (...wn) => T(k) && T(k)(...wn)),
          onBlur: xt[3] || (xt[3] = (...wn) => T(P) && T(P)(...wn)),
          onChange: dt,
          onKeydown: Vi
        }), null, 16, Dye),
        T(j) ? (V(), q("span", {
          key: 0,
          style: vt(x.value),
          class: Q(T(g).e("count"))
        }, ze(T(Y)) + " / " + ze(Oe.maxlength), 7)) : pe("v-if", !0)
      ], 64))
    ], 16, Eye)), [
      [On, Oe.type !== "hidden"]
    ]);
  }
});
var Rye = /* @__PURE__ */ Ve(Iye, [["__file", "input.vue"]]);
const Td = zn(Rye), Zd = 4, Nye = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, $ye = ({
  move: n,
  size: e,
  bar: t
}) => ({
  [t.size]: e,
  transform: `translate${t.axis}(${n}%)`
}), RL = Symbol("scrollbarContextKey"), Bye = Ye({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), Vye = "Thumb", zye = /* @__PURE__ */ U({
  __name: "thumb",
  props: Bye,
  setup(n) {
    const e = n, t = Re(RL), r = Pe("scrollbar");
    t || Su(Vye, "can not inject scrollbar context");
    const i = z(), o = z(), a = z({}), s = z(!1);
    let l = !1, u = !1, c = qt ? document.onselectstart : null;
    const h = B(() => Nye[e.vertical ? "vertical" : "horizontal"]), f = B(() => $ye({
      size: e.size,
      move: e.move,
      bar: h.value
    })), d = B(() => i.value[h.value.offset] ** 2 / t.wrapElement[h.value.scrollSize] / e.ratio / o.value[h.value.offset]), p = (x) => {
      var S;
      if (x.stopPropagation(), x.ctrlKey || [1, 2].includes(x.button))
        return;
      (S = window.getSelection()) == null || S.removeAllRanges(), v(x);
      const _ = x.currentTarget;
      _ && (a.value[h.value.axis] = _[h.value.offset] - (x[h.value.client] - _.getBoundingClientRect()[h.value.direction]));
    }, g = (x) => {
      if (!o.value || !i.value || !t.wrapElement)
        return;
      const S = Math.abs(x.target.getBoundingClientRect()[h.value.direction] - x[h.value.client]), _ = o.value[h.value.offset] / 2, C = (S - _) * 100 * d.value / i.value[h.value.offset];
      t.wrapElement[h.value.scroll] = C * t.wrapElement[h.value.scrollSize] / 100;
    }, v = (x) => {
      x.stopImmediatePropagation(), l = !0, document.addEventListener("mousemove", m), document.addEventListener("mouseup", y), c = document.onselectstart, document.onselectstart = () => !1;
    }, m = (x) => {
      if (!i.value || !o.value || l === !1)
        return;
      const S = a.value[h.value.axis];
      if (!S)
        return;
      const _ = (i.value.getBoundingClientRect()[h.value.direction] - x[h.value.client]) * -1, C = o.value[h.value.offset] - S, A = (_ - C) * 100 * d.value / i.value[h.value.offset];
      t.wrapElement[h.value.scroll] = A * t.wrapElement[h.value.scrollSize] / 100;
    }, y = () => {
      l = !1, a.value[h.value.axis] = 0, document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", y), w(), u && (s.value = !1);
    }, b = () => {
      u = !1, s.value = !!e.size;
    }, O = () => {
      u = !0, s.value = l;
    };
    xi(() => {
      w(), document.removeEventListener("mouseup", y);
    });
    const w = () => {
      document.onselectstart !== c && (document.onselectstart = c);
    };
    return Yi(ba(t, "scrollbarElement"), "mousemove", b), Yi(ba(t, "scrollbarElement"), "mouseleave", O), (x, S) => (V(), ve(kl, {
      name: T(r).b("fade"),
      persisted: ""
    }, {
      default: fe(() => [
        At(J("div", {
          ref_key: "instance",
          ref: i,
          class: Q([T(r).e("bar"), T(r).is(T(h).key)]),
          onMousedown: g
        }, [
          J("div", {
            ref_key: "thumb",
            ref: o,
            class: Q(T(r).e("thumb")),
            style: vt(T(f)),
            onMousedown: p
          }, null, 38)
        ], 34), [
          [On, x.always || s.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var rB = /* @__PURE__ */ Ve(zye, [["__file", "thumb.vue"]]);
const Fye = Ye({
  always: {
    type: Boolean,
    default: !0
  },
  minSize: {
    type: Number,
    required: !0
  }
}), Qye = /* @__PURE__ */ U({
  __name: "bar",
  props: Fye,
  setup(n, { expose: e }) {
    const t = n, r = Re(RL), i = z(0), o = z(0), a = z(""), s = z(""), l = z(1), u = z(1);
    return e({
      handleScroll: (f) => {
        if (f) {
          const d = f.offsetHeight - Zd, p = f.offsetWidth - Zd;
          o.value = f.scrollTop * 100 / d * l.value, i.value = f.scrollLeft * 100 / p * u.value;
        }
      },
      update: () => {
        const f = r == null ? void 0 : r.wrapElement;
        if (!f)
          return;
        const d = f.offsetHeight - Zd, p = f.offsetWidth - Zd, g = d ** 2 / f.scrollHeight, v = p ** 2 / f.scrollWidth, m = Math.max(g, t.minSize), y = Math.max(v, t.minSize);
        l.value = g / (d - g) / (m / (d - m)), u.value = v / (p - v) / (y / (p - y)), s.value = m + Zd < d ? `${m}px` : "", a.value = y + Zd < p ? `${y}px` : "";
      }
    }), (f, d) => (V(), q(yn, null, [
      de(rB, {
        move: i.value,
        ratio: u.value,
        size: a.value,
        always: f.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      de(rB, {
        move: o.value,
        ratio: l.value,
        size: s.value,
        vertical: "",
        always: f.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var Zye = /* @__PURE__ */ Ve(Qye, [["__file", "bar.vue"]]);
const Wye = Ye({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: Ae([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
}), Gye = {
  scroll: ({
    scrollTop: n,
    scrollLeft: e
  }) => [n, e].every(_t)
}, uP = "ElScrollbar", jye = U({
  name: uP
}), Hye = /* @__PURE__ */ U({
  ...jye,
  props: Wye,
  emits: Gye,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = Pe("scrollbar");
    let o, a;
    const s = z(), l = z(), u = z(), c = z(), h = B(() => {
      const b = {};
      return r.height && (b.height = Xo(r.height)), r.maxHeight && (b.maxHeight = Xo(r.maxHeight)), [r.wrapStyle, b];
    }), f = B(() => [
      r.wrapClass,
      i.e("wrap"),
      { [i.em("wrap", "hidden-default")]: !r.native }
    ]), d = B(() => [i.e("view"), r.viewClass]), p = () => {
      var b;
      l.value && ((b = c.value) == null || b.handleScroll(l.value), t("scroll", {
        scrollTop: l.value.scrollTop,
        scrollLeft: l.value.scrollLeft
      }));
    };
    function g(b, O) {
      Nr(b) ? l.value.scrollTo(b) : _t(b) && _t(O) && l.value.scrollTo(b, O);
    }
    const v = (b) => {
      if (!_t(b)) {
        Ht(uP, "value must be a number");
        return;
      }
      l.value.scrollTop = b;
    }, m = (b) => {
      if (!_t(b)) {
        Ht(uP, "value must be a number");
        return;
      }
      l.value.scrollLeft = b;
    }, y = () => {
      var b;
      (b = c.value) == null || b.update();
    };
    return he(() => r.noresize, (b) => {
      b ? (o == null || o(), a == null || a()) : ({ stop: o } = Ei(u, y), a = Yi("resize", y));
    }, { immediate: !0 }), he(() => [r.maxHeight, r.height], () => {
      r.native || Ke(() => {
        var b;
        y(), l.value && ((b = c.value) == null || b.handleScroll(l.value));
      });
    }), Wt(RL, dr({
      scrollbarElement: s,
      wrapElement: l
    })), ht(() => {
      r.native || Ke(() => {
        y();
      });
    }), yd(() => y()), e({
      wrapRef: l,
      update: y,
      scrollTo: g,
      setScrollTop: v,
      setScrollLeft: m,
      handleScroll: p
    }), (b, O) => (V(), q("div", {
      ref_key: "scrollbarRef",
      ref: s,
      class: Q(T(i).b())
    }, [
      J("div", {
        ref_key: "wrapRef",
        ref: l,
        class: Q(T(f)),
        style: vt(T(h)),
        onScroll: p
      }, [
        (V(), ve(cn(b.tag), {
          id: b.id,
          ref_key: "resizeRef",
          ref: u,
          class: Q(T(d)),
          style: vt(b.viewStyle),
          role: b.role,
          "aria-label": b.ariaLabel,
          "aria-orientation": b.ariaOrientation
        }, {
          default: fe(() => [
            ke(b.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      b.native ? pe("v-if", !0) : (V(), ve(Zye, {
        key: 0,
        ref_key: "barRef",
        ref: c,
        always: b.always,
        "min-size": b.minSize
      }, null, 8, ["always", "min-size"]))
    ], 2));
  }
});
var qye = /* @__PURE__ */ Ve(Hye, [["__file", "scrollbar.vue"]]);
const Ob = zn(qye), NL = Symbol("popper"), j7 = Symbol("popperContent"), Yye = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], H7 = Ye({
  role: {
    type: String,
    values: Yye,
    default: "tooltip"
  }
}), Xye = U({
  name: "ElPopper",
  inheritAttrs: !1
}), Uye = /* @__PURE__ */ U({
  ...Xye,
  props: H7,
  setup(n, { expose: e }) {
    const t = n, r = z(), i = z(), o = z(), a = z(), s = B(() => t.role), l = {
      triggerRef: r,
      popperInstanceRef: i,
      contentRef: o,
      referenceRef: a,
      role: s
    };
    return e(l), Wt(NL, l), (u, c) => ke(u.$slots, "default");
  }
});
var Kye = /* @__PURE__ */ Ve(Uye, [["__file", "popper.vue"]]);
const q7 = Ye({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), Jye = U({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), e0e = /* @__PURE__ */ U({
  ...Jye,
  props: q7,
  setup(n, { expose: e }) {
    const t = n, r = Pe("popper"), { arrowOffset: i, arrowRef: o, arrowStyle: a } = Re(j7, void 0);
    return he(() => t.arrowOffset, (s) => {
      i.value = s;
    }), xi(() => {
      o.value = void 0;
    }), e({
      arrowRef: o
    }), (s, l) => (V(), q("span", {
      ref_key: "arrowRef",
      ref: o,
      class: Q(T(r).e("arrow")),
      style: vt(T(a)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var t0e = /* @__PURE__ */ Ve(e0e, [["__file", "arrow.vue"]]);
const u2 = "ElOnlyChild", n0e = U({
  name: u2,
  setup(n, {
    slots: e,
    attrs: t
  }) {
    var r;
    const i = Re(V7), o = eye((r = i == null ? void 0 : i.setForwardRef) != null ? r : ll);
    return () => {
      var a;
      const s = (a = e.default) == null ? void 0 : a.call(e, t);
      if (!s)
        return null;
      if (s.length > 1)
        return Ht(u2, "requires exact only one valid child."), null;
      const l = Y7(s);
      return l ? At(iae(l, t), [[o]]) : (Ht(u2, "no valid child node found"), null);
    };
  }
});
function Y7(n) {
  if (!n)
    return null;
  const e = n;
  for (const t of e) {
    if (Nr(t))
      switch (t.type) {
        case MG:
          continue;
        case EG:
        case "svg":
          return iB(t);
        case yn:
          return Y7(t.children);
        default:
          return t;
      }
    return iB(t);
  }
  return null;
}
function iB(n) {
  const e = Pe("only-child");
  return de("span", {
    class: e.e("content")
  }, [n]);
}
const X7 = Ye({
  virtualRef: {
    type: Ae(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Ae(Function)
  },
  onMouseleave: {
    type: Ae(Function)
  },
  onClick: {
    type: Ae(Function)
  },
  onKeydown: {
    type: Ae(Function)
  },
  onFocus: {
    type: Ae(Function)
  },
  onBlur: {
    type: Ae(Function)
  },
  onContextmenu: {
    type: Ae(Function)
  },
  id: String,
  open: Boolean
}), r0e = U({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), i0e = /* @__PURE__ */ U({
  ...r0e,
  props: X7,
  setup(n, { expose: e }) {
    const t = n, { role: r, triggerRef: i } = Re(NL, void 0);
    Jme(i);
    const o = B(() => s.value ? t.id : void 0), a = B(() => {
      if (r && r.value === "tooltip")
        return t.open && t.id ? t.id : void 0;
    }), s = B(() => {
      if (r && r.value !== "tooltip")
        return r.value;
    }), l = B(() => s.value ? `${t.open}` : void 0);
    let u;
    return ht(() => {
      he(() => t.virtualRef, (c) => {
        c && (i.value = Us(c));
      }, {
        immediate: !0
      }), he(i, (c, h) => {
        u == null || u(), u = void 0, hs(c) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((f) => {
          var d;
          const p = t[f];
          p && (c.addEventListener(f.slice(2).toLowerCase(), p), (d = h == null ? void 0 : h.removeEventListener) == null || d.call(h, f.slice(2).toLowerCase(), p));
        }), u = he([o, a, s, l], (f) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((d, p) => {
            _o(f[p]) ? c.removeAttribute(d) : c.setAttribute(d, f[p]);
          });
        }, { immediate: !0 })), hs(h) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((f) => h.removeAttribute(f));
      }, {
        immediate: !0
      });
    }), xi(() => {
      u == null || u(), u = void 0;
    }), e({
      triggerRef: i
    }), (c, h) => c.virtualTriggering ? pe("v-if", !0) : (V(), ve(T(n0e), xa({ key: 0 }, c.$attrs, {
      "aria-controls": T(o),
      "aria-describedby": T(a),
      "aria-expanded": T(l),
      "aria-haspopup": T(s)
    }), {
      default: fe(() => [
        ke(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var o0e = /* @__PURE__ */ Ve(i0e, [["__file", "trigger.vue"]]);
const c2 = "focus-trap.focus-after-trapped", h2 = "focus-trap.focus-after-released", a0e = "focus-trap.focusout-prevented", oB = {
  cancelable: !0,
  bubbles: !1
}, s0e = {
  cancelable: !0,
  bubbles: !1
}, aB = "focusAfterTrapped", sB = "focusAfterReleased", U7 = Symbol("elFocusTrap"), $L = z(), w_ = z(0), BL = z(0);
let c1 = 0;
const K7 = (n) => {
  const e = [], t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; t.nextNode(); )
    e.push(t.currentNode);
  return e;
}, lB = (n, e) => {
  for (const t of n)
    if (!l0e(t, e))
      return t;
}, l0e = (n, e) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(n).visibility === "hidden")
    return !0;
  for (; n; ) {
    if (e && n === e)
      return !1;
    if (getComputedStyle(n).display === "none")
      return !0;
    n = n.parentElement;
  }
  return !1;
}, u0e = (n) => {
  const e = K7(n), t = lB(e, n), r = lB(e.reverse(), n);
  return [t, r];
}, c0e = (n) => n instanceof HTMLInputElement && "select" in n, Qu = (n, e) => {
  if (n && n.focus) {
    const t = document.activeElement;
    n.focus({ preventScroll: !0 }), BL.value = window.performance.now(), n !== t && c0e(n) && e && n.select();
  }
};
function uB(n, e) {
  const t = [...n], r = n.indexOf(e);
  return r !== -1 && t.splice(r, 1), t;
}
const h0e = () => {
  let n = [];
  return {
    push: (r) => {
      const i = n[0];
      i && r !== i && i.pause(), n = uB(n, r), n.unshift(r);
    },
    remove: (r) => {
      var i, o;
      n = uB(n, r), (o = (i = n[0]) == null ? void 0 : i.resume) == null || o.call(i);
    }
  };
}, f0e = (n, e = !1) => {
  const t = document.activeElement;
  for (const r of n)
    if (Qu(r, e), document.activeElement !== t)
      return;
}, cB = h0e(), d0e = () => w_.value > BL.value, h1 = () => {
  $L.value = "pointer", w_.value = window.performance.now();
}, hB = () => {
  $L.value = "keyboard", w_.value = window.performance.now();
}, p0e = () => (ht(() => {
  c1 === 0 && (document.addEventListener("mousedown", h1), document.addEventListener("touchstart", h1), document.addEventListener("keydown", hB)), c1++;
}), xi(() => {
  c1--, c1 <= 0 && (document.removeEventListener("mousedown", h1), document.removeEventListener("touchstart", h1), document.removeEventListener("keydown", hB));
}), {
  focusReason: $L,
  lastUserFocusTimestamp: w_,
  lastAutomatedFocusTimestamp: BL
}), f1 = (n) => new CustomEvent(a0e, {
  ...s0e,
  detail: n
}), g0e = U({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    aB,
    sB,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(n, { emit: e }) {
    const t = z();
    let r, i;
    const { focusReason: o } = p0e();
    qme((p) => {
      n.trapped && !a.paused && e("release-requested", p);
    });
    const a = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, s = (p) => {
      if (!n.loop && !n.trapped || a.paused)
        return;
      const { key: g, altKey: v, ctrlKey: m, metaKey: y, currentTarget: b, shiftKey: O } = p, { loop: w } = n, x = g === Ft.tab && !v && !m && !y, S = document.activeElement;
      if (x && S) {
        const _ = b, [C, A] = u0e(_);
        if (C && A) {
          if (!O && S === A) {
            const P = f1({
              focusReason: o.value
            });
            e("focusout-prevented", P), P.defaultPrevented || (p.preventDefault(), w && Qu(C, !0));
          } else if (O && [C, _].includes(S)) {
            const P = f1({
              focusReason: o.value
            });
            e("focusout-prevented", P), P.defaultPrevented || (p.preventDefault(), w && Qu(A, !0));
          }
        } else if (S === _) {
          const P = f1({
            focusReason: o.value
          });
          e("focusout-prevented", P), P.defaultPrevented || p.preventDefault();
        }
      }
    };
    Wt(U7, {
      focusTrapRef: t,
      onKeydown: s
    }), he(() => n.focusTrapEl, (p) => {
      p && (t.value = p);
    }, { immediate: !0 }), he([t], ([p], [g]) => {
      p && (p.addEventListener("keydown", s), p.addEventListener("focusin", c), p.addEventListener("focusout", h)), g && (g.removeEventListener("keydown", s), g.removeEventListener("focusin", c), g.removeEventListener("focusout", h));
    });
    const l = (p) => {
      e(aB, p);
    }, u = (p) => e(sB, p), c = (p) => {
      const g = T(t);
      if (!g)
        return;
      const v = p.target, m = p.relatedTarget, y = v && g.contains(v);
      n.trapped || m && g.contains(m) || (r = m), y && e("focusin", p), !a.paused && n.trapped && (y ? i = v : Qu(i, !0));
    }, h = (p) => {
      const g = T(t);
      if (!(a.paused || !g))
        if (n.trapped) {
          const v = p.relatedTarget;
          !_o(v) && !g.contains(v) && setTimeout(() => {
            if (!a.paused && n.trapped) {
              const m = f1({
                focusReason: o.value
              });
              e("focusout-prevented", m), m.defaultPrevented || Qu(i, !0);
            }
          }, 0);
        } else {
          const v = p.target;
          v && g.contains(v) || e("focusout", p);
        }
    };
    async function f() {
      await Ke();
      const p = T(t);
      if (p) {
        cB.push(a);
        const g = p.contains(document.activeElement) ? r : document.activeElement;
        if (r = g, !p.contains(g)) {
          const m = new Event(c2, oB);
          p.addEventListener(c2, l), p.dispatchEvent(m), m.defaultPrevented || Ke(() => {
            let y = n.focusStartEl;
            Ut(y) || (Qu(y), document.activeElement !== y && (y = "first")), y === "first" && f0e(K7(p), !0), (document.activeElement === g || y === "container") && Qu(p);
          });
        }
      }
    }
    function d() {
      const p = T(t);
      if (p) {
        p.removeEventListener(c2, l);
        const g = new CustomEvent(h2, {
          ...oB,
          detail: {
            focusReason: o.value
          }
        });
        p.addEventListener(h2, u), p.dispatchEvent(g), !g.defaultPrevented && (o.value == "keyboard" || !d0e() || p.contains(document.activeElement)) && Qu(r ?? document.body), p.removeEventListener(h2, u), cB.remove(a);
      }
    }
    return ht(() => {
      n.trapped && f(), he(() => n.trapped, (p) => {
        p ? f() : d();
      });
    }), xi(() => {
      n.trapped && d();
    }), {
      onKeydown: s
    };
  }
});
function v0e(n, e, t, r, i, o) {
  return ke(n.$slots, "default", { handleKeydown: n.onKeydown });
}
var x_ = /* @__PURE__ */ Ve(g0e, [["render", v0e], ["__file", "focus-trap.vue"]]);
const m0e = ["fixed", "absolute"], y0e = Ye({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: Ae(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: y_,
    default: "bottom"
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: m0e,
    default: "absolute"
  }
}), J7 = Ye({
  ...y0e,
  id: String,
  style: {
    type: Ae([String, Array, Object])
  },
  className: {
    type: Ae([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: Ae([String, Array, Object])
  },
  popperStyle: {
    type: Ae([String, Array, Object])
  },
  referenceEl: {
    type: Ae(Object)
  },
  triggerTargetEl: {
    type: Ae(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), b0e = {
  mouseenter: (n) => n instanceof MouseEvent,
  mouseleave: (n) => n instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, O0e = (n, e = []) => {
  const { placement: t, strategy: r, popperOptions: i } = n, o = {
    placement: t,
    strategy: r,
    ...i,
    modifiers: [...x0e(n), ...e]
  };
  return S0e(o, i == null ? void 0 : i.modifiers), o;
}, w0e = (n) => {
  if (qt)
    return Us(n);
};
function x0e(n) {
  const { offset: e, gpuAcceleration: t, fallbackPlacements: r } = n;
  return [
    {
      name: "offset",
      options: {
        offset: [0, e ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: r
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: t
      }
    }
  ];
}
function S0e(n, e) {
  e && (n.modifiers = [...n.modifiers, ...e ?? []]);
}
const _0e = 0, C0e = (n) => {
  const { popperInstanceRef: e, contentRef: t, triggerRef: r, role: i } = Re(NL, void 0), o = z(), a = z(), s = B(() => ({
    name: "eventListeners",
    enabled: !!n.visible
  })), l = B(() => {
    var m;
    const y = T(o), b = (m = T(a)) != null ? m : _0e;
    return {
      name: "arrow",
      enabled: !Fj(y),
      options: {
        element: y,
        padding: b
      }
    };
  }), u = B(() => ({
    onFirstUpdate: () => {
      p();
    },
    ...O0e(n, [
      T(l),
      T(s)
    ])
  })), c = B(() => w0e(n.referenceEl) || T(r)), { attributes: h, state: f, styles: d, update: p, forceUpdate: g, instanceRef: v } = Gme(c, t, u);
  return he(v, (m) => e.value = m), ht(() => {
    he(() => {
      var m;
      return (m = T(c)) == null ? void 0 : m.getBoundingClientRect();
    }, () => {
      p();
    });
  }), {
    attributes: h,
    arrowRef: o,
    contentRef: t,
    instanceRef: v,
    state: f,
    styles: d,
    role: i,
    forceUpdate: g,
    update: p
  };
}, A0e = (n, {
  attributes: e,
  styles: t,
  role: r
}) => {
  const { nextZIndex: i } = DL(), o = Pe("popper"), a = B(() => T(e).popper), s = z(_t(n.zIndex) ? n.zIndex : i()), l = B(() => [
    o.b(),
    o.is("pure", n.pure),
    o.is(n.effect),
    n.popperClass
  ]), u = B(() => [
    { zIndex: T(s) },
    T(t).popper,
    n.popperStyle || {}
  ]), c = B(() => r.value === "dialog" ? "false" : void 0), h = B(() => T(t).arrow || {});
  return {
    ariaModal: c,
    arrowStyle: h,
    contentAttrs: a,
    contentClass: l,
    contentStyle: u,
    contentZIndex: s,
    updateZIndex: () => {
      s.value = _t(n.zIndex) ? n.zIndex : i();
    }
  };
}, T0e = (n, e) => {
  const t = z(!1), r = z();
  return {
    focusStartRef: r,
    trapped: t,
    onFocusAfterReleased: (u) => {
      var c;
      ((c = u.detail) == null ? void 0 : c.focusReason) !== "pointer" && (r.value = "first", e("blur"));
    },
    onFocusAfterTrapped: () => {
      e("focus");
    },
    onFocusInTrap: (u) => {
      n.visible && !t.value && (u.target && (r.value = u.target), t.value = !0);
    },
    onFocusoutPrevented: (u) => {
      n.trapping || (u.detail.focusReason === "pointer" && u.preventDefault(), t.value = !1);
    },
    onReleaseRequested: () => {
      t.value = !1, e("close");
    }
  };
}, k0e = U({
  name: "ElPopperContent"
}), P0e = /* @__PURE__ */ U({
  ...k0e,
  props: J7,
  emits: b0e,
  setup(n, { expose: e, emit: t }) {
    const r = n, {
      focusStartRef: i,
      trapped: o,
      onFocusAfterReleased: a,
      onFocusAfterTrapped: s,
      onFocusInTrap: l,
      onFocusoutPrevented: u,
      onReleaseRequested: c
    } = T0e(r, t), { attributes: h, arrowRef: f, contentRef: d, styles: p, instanceRef: g, role: v, update: m } = C0e(r), {
      ariaModal: y,
      arrowStyle: b,
      contentAttrs: O,
      contentClass: w,
      contentStyle: x,
      updateZIndex: S
    } = A0e(r, {
      styles: p,
      attributes: h,
      role: v
    }), _ = Re(Ec, void 0), C = z();
    Wt(j7, {
      arrowStyle: b,
      arrowRef: f,
      arrowOffset: C
    }), _ && (_.addInputId || _.removeInputId) && Wt(Ec, {
      ..._,
      addInputId: ll,
      removeInputId: ll
    });
    let A;
    const k = (L = !0) => {
      m(), L && S();
    }, P = () => {
      k(!1), r.visible && r.focusOnShow ? o.value = !0 : r.visible === !1 && (o.value = !1);
    };
    return ht(() => {
      he(() => r.triggerTargetEl, (L, D) => {
        A == null || A(), A = void 0;
        const E = T(L || d.value), M = T(D || d.value);
        hs(E) && (A = he([v, () => r.ariaLabel, y, () => r.id], (R) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((N, $) => {
            _o(R[$]) ? E.removeAttribute(N) : E.setAttribute(N, R[$]);
          });
        }, { immediate: !0 })), M !== E && hs(M) && ["role", "aria-label", "aria-modal", "id"].forEach((R) => {
          M.removeAttribute(R);
        });
      }, { immediate: !0 }), he(() => r.visible, P, { immediate: !0 });
    }), xi(() => {
      A == null || A(), A = void 0;
    }), e({
      popperContentRef: d,
      popperInstanceRef: g,
      updatePopper: k,
      contentStyle: x
    }), (L, D) => (V(), q("div", xa({
      ref_key: "contentRef",
      ref: d
    }, T(O), {
      style: T(x),
      class: T(w),
      tabindex: "-1",
      onMouseenter: D[0] || (D[0] = (E) => L.$emit("mouseenter", E)),
      onMouseleave: D[1] || (D[1] = (E) => L.$emit("mouseleave", E))
    }), [
      de(T(x_), {
        trapped: T(o),
        "trap-on-focus-in": !0,
        "focus-trap-el": T(d),
        "focus-start-el": T(i),
        onFocusAfterTrapped: T(s),
        onFocusAfterReleased: T(a),
        onFocusin: T(l),
        onFocusoutPrevented: T(u),
        onReleaseRequested: T(c)
      }, {
        default: fe(() => [
          ke(L.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var E0e = /* @__PURE__ */ Ve(P0e, [["__file", "content.vue"]]);
const M0e = zn(Kye), VL = Symbol("elTooltip"), po = Ye({
  ...Ume,
  ...J7,
  appendTo: {
    type: Ae([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: Ae(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), e0 = Ye({
  ...X7,
  disabled: Boolean,
  trigger: {
    type: Ae([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: Ae(Array),
    default: () => [Ft.enter, Ft.space]
  }
}), {
  useModelToggleProps: D0e,
  useModelToggleEmits: L0e,
  useModelToggle: I0e
} = C7("visible"), R0e = Ye({
  ...H7,
  ...D0e,
  ...po,
  ...e0,
  ...q7,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), N0e = [
  ...L0e,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], $0e = (n, e) => _n(n) ? n.includes(e) : n === e, Wd = (n, e, t) => (r) => {
  $0e(T(n), e) && t(r);
}, B0e = U({
  name: "ElTooltipTrigger"
}), V0e = /* @__PURE__ */ U({
  ...B0e,
  props: e0,
  setup(n, { expose: e }) {
    const t = n, r = Pe("tooltip"), { controlled: i, id: o, open: a, onOpen: s, onClose: l, onToggle: u } = Re(VL, void 0), c = z(null), h = () => {
      if (T(i) || t.disabled)
        return !0;
    }, f = ba(t, "trigger"), d = zl(h, Wd(f, "hover", s)), p = zl(h, Wd(f, "hover", l)), g = zl(h, Wd(f, "click", (O) => {
      O.button === 0 && u(O);
    })), v = zl(h, Wd(f, "focus", s)), m = zl(h, Wd(f, "focus", l)), y = zl(h, Wd(f, "contextmenu", (O) => {
      O.preventDefault(), u(O);
    })), b = zl(h, (O) => {
      const { code: w } = O;
      t.triggerKeys.includes(w) && (O.preventDefault(), u(O));
    });
    return e({
      triggerRef: c
    }), (O, w) => (V(), ve(T(o0e), {
      id: T(o),
      "virtual-ref": O.virtualRef,
      open: T(a),
      "virtual-triggering": O.virtualTriggering,
      class: Q(T(r).e("trigger")),
      onBlur: T(m),
      onClick: T(g),
      onContextmenu: T(y),
      onFocus: T(v),
      onMouseenter: T(d),
      onMouseleave: T(p),
      onKeydown: T(b)
    }, {
      default: fe(() => [
        ke(O.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var z0e = /* @__PURE__ */ Ve(V0e, [["__file", "trigger.vue"]]);
const F0e = U({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), Q0e = /* @__PURE__ */ U({
  ...F0e,
  props: po,
  setup(n, { expose: e }) {
    const t = n, { selector: r } = B7(), i = Pe("tooltip"), o = z(null), a = z(!1), {
      controlled: s,
      id: l,
      open: u,
      trigger: c,
      onClose: h,
      onOpen: f,
      onShow: d,
      onHide: p,
      onBeforeShow: g,
      onBeforeHide: v
    } = Re(VL, void 0), m = B(() => t.transition || `${i.namespace.value}-fade-in-linear`), y = B(() => process.env.NODE_ENV === "test" ? !0 : t.persistent);
    xi(() => {
      a.value = !0;
    });
    const b = B(() => T(y) ? !0 : T(u)), O = B(() => t.disabled ? !1 : T(u)), w = B(() => t.appendTo || r.value), x = B(() => {
      var R;
      return (R = t.style) != null ? R : {};
    }), S = B(() => !T(u)), _ = () => {
      p();
    }, C = () => {
      if (T(s))
        return !0;
    }, A = zl(C, () => {
      t.enterable && T(c) === "hover" && f();
    }), k = zl(C, () => {
      T(c) === "hover" && h();
    }), P = () => {
      var R, N;
      (N = (R = o.value) == null ? void 0 : R.updatePopper) == null || N.call(R), g == null || g();
    }, L = () => {
      v == null || v();
    }, D = () => {
      d(), M = Vge(B(() => {
        var R;
        return (R = o.value) == null ? void 0 : R.popperContentRef;
      }), () => {
        if (T(s))
          return;
        T(c) !== "hover" && h();
      });
    }, E = () => {
      t.virtualTriggering || h();
    };
    let M;
    return he(() => T(u), (R) => {
      R || M == null || M();
    }, {
      flush: "post"
    }), he(() => t.content, () => {
      var R, N;
      (N = (R = o.value) == null ? void 0 : R.updatePopper) == null || N.call(R);
    }), e({
      contentRef: o
    }), (R, N) => (V(), ve(a_, {
      disabled: !R.teleported,
      to: T(w)
    }, [
      de(kl, {
        name: T(m),
        onAfterLeave: _,
        onBeforeEnter: P,
        onAfterEnter: D,
        onBeforeLeave: L
      }, {
        default: fe(() => [
          T(b) ? At((V(), ve(T(E0e), xa({
            key: 0,
            id: T(l),
            ref_key: "contentRef",
            ref: o
          }, R.$attrs, {
            "aria-label": R.ariaLabel,
            "aria-hidden": T(S),
            "boundaries-padding": R.boundariesPadding,
            "fallback-placements": R.fallbackPlacements,
            "gpu-acceleration": R.gpuAcceleration,
            offset: R.offset,
            placement: R.placement,
            "popper-options": R.popperOptions,
            strategy: R.strategy,
            effect: R.effect,
            enterable: R.enterable,
            pure: R.pure,
            "popper-class": R.popperClass,
            "popper-style": [R.popperStyle, T(x)],
            "reference-el": R.referenceEl,
            "trigger-target-el": R.triggerTargetEl,
            visible: T(O),
            "z-index": R.zIndex,
            onMouseenter: T(A),
            onMouseleave: T(k),
            onBlur: E,
            onClose: T(h)
          }), {
            default: fe(() => [
              a.value ? pe("v-if", !0) : ke(R.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [On, T(O)]
          ]) : pe("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var Z0e = /* @__PURE__ */ Ve(Q0e, [["__file", "content.vue"]]);
const W0e = ["innerHTML"], G0e = { key: 1 }, j0e = U({
  name: "ElTooltip"
}), H0e = /* @__PURE__ */ U({
  ...j0e,
  props: R0e,
  emits: N0e,
  setup(n, { expose: e, emit: t }) {
    const r = n;
    Xme();
    const i = fs(), o = z(), a = z(), s = () => {
      var m;
      const y = T(o);
      y && ((m = y.popperInstanceRef) == null || m.update());
    }, l = z(!1), u = z(), { show: c, hide: h, hasUpdateHandler: f } = I0e({
      indicator: l,
      toggleReason: u
    }), { onOpen: d, onClose: p } = Kme({
      showAfter: ba(r, "showAfter"),
      hideAfter: ba(r, "hideAfter"),
      autoClose: ba(r, "autoClose"),
      open: c,
      close: h
    }), g = B(() => pi(r.visible) && !f.value);
    Wt(VL, {
      controlled: g,
      id: i,
      open: o_(l),
      trigger: ba(r, "trigger"),
      onOpen: (m) => {
        d(m);
      },
      onClose: (m) => {
        p(m);
      },
      onToggle: (m) => {
        T(l) ? p(m) : d(m);
      },
      onShow: () => {
        t("show", u.value);
      },
      onHide: () => {
        t("hide", u.value);
      },
      onBeforeShow: () => {
        t("before-show", u.value);
      },
      onBeforeHide: () => {
        t("before-hide", u.value);
      },
      updatePopper: s
    }), he(() => r.disabled, (m) => {
      m && l.value && (l.value = !1);
    });
    const v = (m) => {
      var y, b;
      const O = (b = (y = a.value) == null ? void 0 : y.contentRef) == null ? void 0 : b.popperContentRef, w = (m == null ? void 0 : m.relatedTarget) || document.activeElement;
      return O && O.contains(w);
    };
    return oae(() => l.value && h()), e({
      popperRef: o,
      contentRef: a,
      isFocusInsideContent: v,
      updatePopper: s,
      onOpen: d,
      onClose: p,
      hide: h
    }), (m, y) => (V(), ve(T(M0e), {
      ref_key: "popperRef",
      ref: o,
      role: m.role
    }, {
      default: fe(() => [
        de(z0e, {
          disabled: m.disabled,
          trigger: m.trigger,
          "trigger-keys": m.triggerKeys,
          "virtual-ref": m.virtualRef,
          "virtual-triggering": m.virtualTriggering
        }, {
          default: fe(() => [
            m.$slots.default ? ke(m.$slots, "default", { key: 0 }) : pe("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        de(Z0e, {
          ref_key: "contentRef",
          ref: a,
          "aria-label": m.ariaLabel,
          "boundaries-padding": m.boundariesPadding,
          content: m.content,
          disabled: m.disabled,
          effect: m.effect,
          enterable: m.enterable,
          "fallback-placements": m.fallbackPlacements,
          "hide-after": m.hideAfter,
          "gpu-acceleration": m.gpuAcceleration,
          offset: m.offset,
          persistent: m.persistent,
          "popper-class": m.popperClass,
          "popper-style": m.popperStyle,
          placement: m.placement,
          "popper-options": m.popperOptions,
          pure: m.pure,
          "raw-content": m.rawContent,
          "reference-el": m.referenceEl,
          "trigger-target-el": m.triggerTargetEl,
          "show-after": m.showAfter,
          strategy: m.strategy,
          teleported: m.teleported,
          transition: m.transition,
          "virtual-triggering": m.virtualTriggering,
          "z-index": m.zIndex,
          "append-to": m.appendTo
        }, {
          default: fe(() => [
            ke(m.$slots, "content", {}, () => [
              m.rawContent ? (V(), q("span", {
                key: 0,
                innerHTML: m.content
              }, null, 8, W0e)) : (V(), q("span", G0e, ze(m.content), 1))
            ]),
            m.showArrow ? (V(), ve(T(t0e), {
              key: 0,
              "arrow-offset": m.arrowOffset
            }, null, 8, ["arrow-offset"])) : pe("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var q0e = /* @__PURE__ */ Ve(H0e, [["__file", "tooltip.vue"]]);
const Uf = zn(q0e), Y0e = Ye({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
}), X0e = ["textContent"], U0e = U({
  name: "ElBadge"
}), K0e = /* @__PURE__ */ U({
  ...U0e,
  props: Y0e,
  setup(n, { expose: e }) {
    const t = n, r = Pe("badge"), i = B(() => t.isDot ? "" : _t(t.value) && _t(t.max) ? t.max < t.value ? `${t.max}+` : `${t.value}` : `${t.value}`);
    return e({
      content: i
    }), (o, a) => (V(), q("div", {
      class: Q(T(r).b())
    }, [
      ke(o.$slots, "default"),
      de(kl, {
        name: `${T(r).namespace.value}-zoom-in-center`,
        persisted: ""
      }, {
        default: fe(() => [
          At(J("sup", {
            class: Q([
              T(r).e("content"),
              T(r).em("content", o.type),
              T(r).is("fixed", !!o.$slots.default),
              T(r).is("dot", o.isDot)
            ]),
            textContent: ze(T(i))
          }, null, 10, X0e), [
            [On, !o.hidden && (T(i) || o.isDot)]
          ])
        ]),
        _: 1
      }, 8, ["name"])
    ], 2));
  }
});
var J0e = /* @__PURE__ */ Ve(K0e, [["__file", "badge.vue"]]);
const ebe = zn(J0e), eH = Symbol("buttonGroupContextKey"), tbe = (n, e) => {
  Xf({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, B(() => n.type === "text"));
  const t = Re(eH, void 0), r = O_("button"), { form: i } = Na(), o = ko(B(() => t == null ? void 0 : t.size)), a = ah(), s = z(), l = Tl(), u = B(() => n.type || (t == null ? void 0 : t.type) || ""), c = B(() => {
    var p, g, v;
    return (v = (g = n.autoInsertSpace) != null ? g : (p = r.value) == null ? void 0 : p.autoInsertSpace) != null ? v : !1;
  }), h = B(() => n.tag === "button" ? {
    ariaDisabled: a.value || n.loading,
    disabled: a.value || n.loading,
    autofocus: n.autofocus,
    type: n.nativeType
  } : {}), f = B(() => {
    var p;
    const g = (p = l.default) == null ? void 0 : p.call(l);
    if (c.value && (g == null ? void 0 : g.length) === 1) {
      const v = g[0];
      if ((v == null ? void 0 : v.type) === EG) {
        const m = v.children;
        return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(m.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: a,
    _size: o,
    _type: u,
    _ref: s,
    _props: h,
    shouldAddSpace: f,
    handleClick: (p) => {
      n.nativeType === "reset" && (i == null || i.resetFields()), e("click", p);
    }
  };
}, nbe = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], rbe = ["button", "submit", "reset"], cP = Ye({
  size: Ra,
  disabled: Boolean,
  type: {
    type: String,
    values: nbe,
    default: ""
  },
  icon: {
    type: $r
  },
  nativeType: {
    type: String,
    values: rbe,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: $r,
    default: () => _d
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: Ae([String, Object]),
    default: "button"
  }
}), ibe = {
  click: (n) => n instanceof MouseEvent
};
function gi(n, e) {
  obe(n) && (n = "100%");
  var t = abe(n);
  return n = e === 360 ? n : Math.min(e, Math.max(0, parseFloat(n))), t && (n = parseInt(String(n * e), 10) / 100), Math.abs(n - e) < 1e-6 ? 1 : (e === 360 ? n = (n < 0 ? n % e + e : n % e) / parseFloat(String(e)) : n = n % e / parseFloat(String(e)), n);
}
function d1(n) {
  return Math.min(1, Math.max(0, n));
}
function obe(n) {
  return typeof n == "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function abe(n) {
  return typeof n == "string" && n.indexOf("%") !== -1;
}
function tH(n) {
  return n = parseFloat(n), (isNaN(n) || n < 0 || n > 1) && (n = 1), n;
}
function p1(n) {
  return n <= 1 ? "".concat(Number(n) * 100, "%") : n;
}
function ff(n) {
  return n.length === 1 ? "0" + n : String(n);
}
function sbe(n, e, t) {
  return {
    r: gi(n, 255) * 255,
    g: gi(e, 255) * 255,
    b: gi(t, 255) * 255
  };
}
function fB(n, e, t) {
  n = gi(n, 255), e = gi(e, 255), t = gi(t, 255);
  var r = Math.max(n, e, t), i = Math.min(n, e, t), o = 0, a = 0, s = (r + i) / 2;
  if (r === i)
    a = 0, o = 0;
  else {
    var l = r - i;
    switch (a = s > 0.5 ? l / (2 - r - i) : l / (r + i), r) {
      case n:
        o = (e - t) / l + (e < t ? 6 : 0);
        break;
      case e:
        o = (t - n) / l + 2;
        break;
      case t:
        o = (n - e) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: a, l: s };
}
function f2(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * (6 * t) : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function lbe(n, e, t) {
  var r, i, o;
  if (n = gi(n, 360), e = gi(e, 100), t = gi(t, 100), e === 0)
    i = t, o = t, r = t;
  else {
    var a = t < 0.5 ? t * (1 + e) : t + e - t * e, s = 2 * t - a;
    r = f2(s, a, n + 1 / 3), i = f2(s, a, n), o = f2(s, a, n - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: o * 255 };
}
function dB(n, e, t) {
  n = gi(n, 255), e = gi(e, 255), t = gi(t, 255);
  var r = Math.max(n, e, t), i = Math.min(n, e, t), o = 0, a = r, s = r - i, l = r === 0 ? 0 : s / r;
  if (r === i)
    o = 0;
  else {
    switch (r) {
      case n:
        o = (e - t) / s + (e < t ? 6 : 0);
        break;
      case e:
        o = (t - n) / s + 2;
        break;
      case t:
        o = (n - e) / s + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: l, v: a };
}
function ube(n, e, t) {
  n = gi(n, 360) * 6, e = gi(e, 100), t = gi(t, 100);
  var r = Math.floor(n), i = n - r, o = t * (1 - e), a = t * (1 - i * e), s = t * (1 - (1 - i) * e), l = r % 6, u = [t, a, o, o, s, t][l], c = [s, t, t, a, o, o][l], h = [o, o, s, t, t, a][l];
  return { r: u * 255, g: c * 255, b: h * 255 };
}
function pB(n, e, t, r) {
  var i = [
    ff(Math.round(n).toString(16)),
    ff(Math.round(e).toString(16)),
    ff(Math.round(t).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function cbe(n, e, t, r, i) {
  var o = [
    ff(Math.round(n).toString(16)),
    ff(Math.round(e).toString(16)),
    ff(Math.round(t).toString(16)),
    ff(hbe(r))
  ];
  return i && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) && o[3].startsWith(o[3].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("");
}
function hbe(n) {
  return Math.round(parseFloat(n) * 255).toString(16);
}
function gB(n) {
  return Io(n) / 255;
}
function Io(n) {
  return parseInt(n, 16);
}
function fbe(n) {
  return {
    r: n >> 16,
    g: (n & 65280) >> 8,
    b: n & 255
  };
}
var hP = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function dbe(n) {
  var e = { r: 0, g: 0, b: 0 }, t = 1, r = null, i = null, o = null, a = !1, s = !1;
  return typeof n == "string" && (n = vbe(n)), typeof n == "object" && (Nl(n.r) && Nl(n.g) && Nl(n.b) ? (e = sbe(n.r, n.g, n.b), a = !0, s = String(n.r).substr(-1) === "%" ? "prgb" : "rgb") : Nl(n.h) && Nl(n.s) && Nl(n.v) ? (r = p1(n.s), i = p1(n.v), e = ube(n.h, r, i), a = !0, s = "hsv") : Nl(n.h) && Nl(n.s) && Nl(n.l) && (r = p1(n.s), o = p1(n.l), e = lbe(n.h, r, o), a = !0, s = "hsl"), Object.prototype.hasOwnProperty.call(n, "a") && (t = n.a)), t = tH(t), {
    ok: a,
    format: n.format || s,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: t
  };
}
var pbe = "[-\\+]?\\d+%?", gbe = "[-\\+]?\\d*\\.\\d+%?", ac = "(?:".concat(gbe, ")|(?:").concat(pbe, ")"), d2 = "[\\s|\\(]+(".concat(ac, ")[,|\\s]+(").concat(ac, ")[,|\\s]+(").concat(ac, ")\\s*\\)?"), p2 = "[\\s|\\(]+(".concat(ac, ")[,|\\s]+(").concat(ac, ")[,|\\s]+(").concat(ac, ")[,|\\s]+(").concat(ac, ")\\s*\\)?"), Za = {
  CSS_UNIT: new RegExp(ac),
  rgb: new RegExp("rgb" + d2),
  rgba: new RegExp("rgba" + p2),
  hsl: new RegExp("hsl" + d2),
  hsla: new RegExp("hsla" + p2),
  hsv: new RegExp("hsv" + d2),
  hsva: new RegExp("hsva" + p2),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function vbe(n) {
  if (n = n.trim().toLowerCase(), n.length === 0)
    return !1;
  var e = !1;
  if (hP[n])
    n = hP[n], e = !0;
  else if (n === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var t = Za.rgb.exec(n);
  return t ? { r: t[1], g: t[2], b: t[3] } : (t = Za.rgba.exec(n), t ? { r: t[1], g: t[2], b: t[3], a: t[4] } : (t = Za.hsl.exec(n), t ? { h: t[1], s: t[2], l: t[3] } : (t = Za.hsla.exec(n), t ? { h: t[1], s: t[2], l: t[3], a: t[4] } : (t = Za.hsv.exec(n), t ? { h: t[1], s: t[2], v: t[3] } : (t = Za.hsva.exec(n), t ? { h: t[1], s: t[2], v: t[3], a: t[4] } : (t = Za.hex8.exec(n), t ? {
    r: Io(t[1]),
    g: Io(t[2]),
    b: Io(t[3]),
    a: gB(t[4]),
    format: e ? "name" : "hex8"
  } : (t = Za.hex6.exec(n), t ? {
    r: Io(t[1]),
    g: Io(t[2]),
    b: Io(t[3]),
    format: e ? "name" : "hex"
  } : (t = Za.hex4.exec(n), t ? {
    r: Io(t[1] + t[1]),
    g: Io(t[2] + t[2]),
    b: Io(t[3] + t[3]),
    a: gB(t[4] + t[4]),
    format: e ? "name" : "hex8"
  } : (t = Za.hex3.exec(n), t ? {
    r: Io(t[1] + t[1]),
    g: Io(t[2] + t[2]),
    b: Io(t[3] + t[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function Nl(n) {
  return !!Za.CSS_UNIT.exec(String(n));
}
var mbe = (
  /** @class */
  function() {
    function n(e, t) {
      e === void 0 && (e = ""), t === void 0 && (t = {});
      var r;
      if (e instanceof n)
        return e;
      typeof e == "number" && (e = fbe(e)), this.originalInput = e;
      var i = dbe(e);
      this.originalInput = e, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = t.format) !== null && r !== void 0 ? r : i.format, this.gradientType = t.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return n.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, n.prototype.isLight = function() {
      return !this.isDark();
    }, n.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
    }, n.prototype.getLuminance = function() {
      var e = this.toRgb(), t, r, i, o = e.r / 255, a = e.g / 255, s = e.b / 255;
      return o <= 0.03928 ? t = o / 12.92 : t = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? r = a / 12.92 : r = Math.pow((a + 0.055) / 1.055, 2.4), s <= 0.03928 ? i = s / 12.92 : i = Math.pow((s + 0.055) / 1.055, 2.4), 0.2126 * t + 0.7152 * r + 0.0722 * i;
    }, n.prototype.getAlpha = function() {
      return this.a;
    }, n.prototype.setAlpha = function(e) {
      return this.a = tH(e), this.roundA = Math.round(100 * this.a) / 100, this;
    }, n.prototype.isMonochrome = function() {
      var e = this.toHsl().s;
      return e === 0;
    }, n.prototype.toHsv = function() {
      var e = dB(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
    }, n.prototype.toHsvString = function() {
      var e = dB(this.r, this.g, this.b), t = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.v * 100);
      return this.a === 1 ? "hsv(".concat(t, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(t, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, n.prototype.toHsl = function() {
      var e = fB(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
    }, n.prototype.toHslString = function() {
      var e = fB(this.r, this.g, this.b), t = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.l * 100);
      return this.a === 1 ? "hsl(".concat(t, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(t, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, n.prototype.toHex = function(e) {
      return e === void 0 && (e = !1), pB(this.r, this.g, this.b, e);
    }, n.prototype.toHexString = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex(e);
    }, n.prototype.toHex8 = function(e) {
      return e === void 0 && (e = !1), cbe(this.r, this.g, this.b, this.a, e);
    }, n.prototype.toHex8String = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex8(e);
    }, n.prototype.toHexShortString = function(e) {
      return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
    }, n.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, n.prototype.toRgbString = function() {
      var e = Math.round(this.r), t = Math.round(this.g), r = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(e, ", ").concat(t, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(t, ", ").concat(r, ", ").concat(this.roundA, ")");
    }, n.prototype.toPercentageRgb = function() {
      var e = function(t) {
        return "".concat(Math.round(gi(t, 255) * 100), "%");
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      };
    }, n.prototype.toPercentageRgbString = function() {
      var e = function(t) {
        return Math.round(gi(t, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
    }, n.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + pB(this.r, this.g, this.b, !1), t = 0, r = Object.entries(hP); t < r.length; t++) {
        var i = r[t], o = i[0], a = i[1];
        if (e === a)
          return o;
      }
      return !1;
    }, n.prototype.toString = function(e) {
      var t = !!e;
      e = e ?? this.format;
      var r = !1, i = this.a < 1 && this.a >= 0, o = !t && i && (e.startsWith("hex") || e === "name");
      return o ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), r || this.toHexString());
    }, n.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, n.prototype.clone = function() {
      return new n(this.toString());
    }, n.prototype.lighten = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.l += e / 100, t.l = d1(t.l), new n(t);
    }, n.prototype.brighten = function(e) {
      e === void 0 && (e = 10);
      var t = this.toRgb();
      return t.r = Math.max(0, Math.min(255, t.r - Math.round(255 * -(e / 100)))), t.g = Math.max(0, Math.min(255, t.g - Math.round(255 * -(e / 100)))), t.b = Math.max(0, Math.min(255, t.b - Math.round(255 * -(e / 100)))), new n(t);
    }, n.prototype.darken = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.l -= e / 100, t.l = d1(t.l), new n(t);
    }, n.prototype.tint = function(e) {
      return e === void 0 && (e = 10), this.mix("white", e);
    }, n.prototype.shade = function(e) {
      return e === void 0 && (e = 10), this.mix("black", e);
    }, n.prototype.desaturate = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.s -= e / 100, t.s = d1(t.s), new n(t);
    }, n.prototype.saturate = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.s += e / 100, t.s = d1(t.s), new n(t);
    }, n.prototype.greyscale = function() {
      return this.desaturate(100);
    }, n.prototype.spin = function(e) {
      var t = this.toHsl(), r = (t.h + e) % 360;
      return t.h = r < 0 ? 360 + r : r, new n(t);
    }, n.prototype.mix = function(e, t) {
      t === void 0 && (t = 50);
      var r = this.toRgb(), i = new n(e).toRgb(), o = t / 100, a = {
        r: (i.r - r.r) * o + r.r,
        g: (i.g - r.g) * o + r.g,
        b: (i.b - r.b) * o + r.b,
        a: (i.a - r.a) * o + r.a
      };
      return new n(a);
    }, n.prototype.analogous = function(e, t) {
      e === void 0 && (e = 6), t === void 0 && (t = 30);
      var r = this.toHsl(), i = 360 / t, o = [this];
      for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
        r.h = (r.h + i) % 360, o.push(new n(r));
      return o;
    }, n.prototype.complement = function() {
      var e = this.toHsl();
      return e.h = (e.h + 180) % 360, new n(e);
    }, n.prototype.monochromatic = function(e) {
      e === void 0 && (e = 6);
      for (var t = this.toHsv(), r = t.h, i = t.s, o = t.v, a = [], s = 1 / e; e--; )
        a.push(new n({ h: r, s: i, v: o })), o = (o + s) % 1;
      return a;
    }, n.prototype.splitcomplement = function() {
      var e = this.toHsl(), t = e.h;
      return [
        this,
        new n({ h: (t + 72) % 360, s: e.s, l: e.l }),
        new n({ h: (t + 216) % 360, s: e.s, l: e.l })
      ];
    }, n.prototype.onBackground = function(e) {
      var t = this.toRgb(), r = new n(e).toRgb(), i = t.a + r.a * (1 - t.a);
      return new n({
        r: (t.r * t.a + r.r * r.a * (1 - t.a)) / i,
        g: (t.g * t.a + r.g * r.a * (1 - t.a)) / i,
        b: (t.b * t.a + r.b * r.a * (1 - t.a)) / i,
        a: i
      });
    }, n.prototype.triad = function() {
      return this.polyad(3);
    }, n.prototype.tetrad = function() {
      return this.polyad(4);
    }, n.prototype.polyad = function(e) {
      for (var t = this.toHsl(), r = t.h, i = [this], o = 360 / e, a = 1; a < e; a++)
        i.push(new n({ h: (r + a * o) % 360, s: t.s, l: t.l }));
      return i;
    }, n.prototype.equals = function(e) {
      return this.toRgbString() === new n(e).toRgbString();
    }, n;
  }()
);
function Du(n, e = 20) {
  return n.mix("#141414", e).toString();
}
function ybe(n) {
  const e = ah(), t = Pe("button");
  return B(() => {
    let r = {};
    const i = n.color;
    if (i) {
      const o = new mbe(i), a = n.dark ? o.tint(20).toString() : Du(o, 20);
      if (n.plain)
        r = t.cssVarBlock({
          "bg-color": n.dark ? Du(o, 90) : o.tint(90).toString(),
          "text-color": i,
          "border-color": n.dark ? Du(o, 50) : o.tint(50).toString(),
          "hover-text-color": `var(${t.cssVarName("color-white")})`,
          "hover-bg-color": i,
          "hover-border-color": i,
          "active-bg-color": a,
          "active-text-color": `var(${t.cssVarName("color-white")})`,
          "active-border-color": a
        }), e.value && (r[t.cssVarBlockName("disabled-bg-color")] = n.dark ? Du(o, 90) : o.tint(90).toString(), r[t.cssVarBlockName("disabled-text-color")] = n.dark ? Du(o, 50) : o.tint(50).toString(), r[t.cssVarBlockName("disabled-border-color")] = n.dark ? Du(o, 80) : o.tint(80).toString());
      else {
        const s = n.dark ? Du(o, 30) : o.tint(30).toString(), l = o.isDark() ? `var(${t.cssVarName("color-white")})` : `var(${t.cssVarName("color-black")})`;
        if (r = t.cssVarBlock({
          "bg-color": i,
          "text-color": l,
          "border-color": i,
          "hover-bg-color": s,
          "hover-text-color": l,
          "hover-border-color": s,
          "active-bg-color": a,
          "active-border-color": a
        }), e.value) {
          const u = n.dark ? Du(o, 50) : o.tint(50).toString();
          r[t.cssVarBlockName("disabled-bg-color")] = u, r[t.cssVarBlockName("disabled-text-color")] = n.dark ? "rgba(255, 255, 255, 0.5)" : `var(${t.cssVarName("color-white")})`, r[t.cssVarBlockName("disabled-border-color")] = u;
        }
      }
    }
    return r;
  });
}
const bbe = U({
  name: "ElButton"
}), Obe = /* @__PURE__ */ U({
  ...bbe,
  props: cP,
  emits: ibe,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = ybe(r), o = Pe("button"), { _ref: a, _size: s, _type: l, _disabled: u, _props: c, shouldAddSpace: h, handleClick: f } = tbe(r, t);
    return e({
      ref: a,
      size: s,
      type: l,
      disabled: u,
      shouldAddSpace: h
    }), (d, p) => (V(), ve(cn(d.tag), xa({
      ref_key: "_ref",
      ref: a
    }, T(c), {
      class: [
        T(o).b(),
        T(o).m(T(l)),
        T(o).m(T(s)),
        T(o).is("disabled", T(u)),
        T(o).is("loading", d.loading),
        T(o).is("plain", d.plain),
        T(o).is("round", d.round),
        T(o).is("circle", d.circle),
        T(o).is("text", d.text),
        T(o).is("link", d.link),
        T(o).is("has-bg", d.bg)
      ],
      style: T(i),
      onClick: T(f)
    }), {
      default: fe(() => [
        d.loading ? (V(), q(yn, { key: 0 }, [
          d.$slots.loading ? ke(d.$slots, "loading", { key: 0 }) : (V(), ve(T(bt), {
            key: 1,
            class: Q(T(o).is("loading"))
          }, {
            default: fe(() => [
              (V(), ve(cn(d.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : d.icon || d.$slots.icon ? (V(), ve(T(bt), { key: 1 }, {
          default: fe(() => [
            d.icon ? (V(), ve(cn(d.icon), { key: 0 })) : ke(d.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : pe("v-if", !0),
        d.$slots.default ? (V(), q("span", {
          key: 2,
          class: Q({ [T(o).em("text", "expand")]: T(h) })
        }, [
          ke(d.$slots, "default")
        ], 2)) : pe("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var wbe = /* @__PURE__ */ Ve(Obe, [["__file", "button.vue"]]);
const xbe = {
  size: cP.size,
  type: cP.type
}, Sbe = U({
  name: "ElButtonGroup"
}), _be = /* @__PURE__ */ U({
  ...Sbe,
  props: xbe,
  setup(n) {
    const e = n;
    Wt(eH, dr({
      size: ba(e, "size"),
      type: ba(e, "type")
    }));
    const t = Pe("button");
    return (r, i) => (V(), q("div", {
      class: Q(`${T(t).b("group")}`)
    }, [
      ke(r.$slots, "default")
    ], 2));
  }
});
var nH = /* @__PURE__ */ Ve(_be, [["__file", "button-group.vue"]]);
const t0 = zn(wbe, {
  ButtonGroup: nH
});
Os(nH);
var Cbe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function wb(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Abe(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
const Zu = /* @__PURE__ */ new Map();
let vB;
qt && (document.addEventListener("mousedown", (n) => vB = n), document.addEventListener("mouseup", (n) => {
  for (const e of Zu.values())
    for (const { documentHandler: t } of e)
      t(n, vB);
}));
function mB(n, e) {
  let t = [];
  return Array.isArray(e.arg) ? t = e.arg : hs(e.arg) && t.push(e.arg), function(r, i) {
    const o = e.instance.popperRef, a = r.target, s = i == null ? void 0 : i.target, l = !e || !e.instance, u = !a || !s, c = n.contains(a) || n.contains(s), h = n === a, f = t.length && t.some((p) => p == null ? void 0 : p.contains(a)) || t.length && t.includes(s), d = o && (o.contains(a) || o.contains(s));
    l || u || c || h || f || d || e.value(r, i);
  };
}
const S_ = {
  beforeMount(n, e) {
    Zu.has(n) || Zu.set(n, []), Zu.get(n).push({
      documentHandler: mB(n, e),
      bindingFn: e.value
    });
  },
  updated(n, e) {
    Zu.has(n) || Zu.set(n, []);
    const t = Zu.get(n), r = t.findIndex((o) => o.bindingFn === e.oldValue), i = {
      documentHandler: mB(n, e),
      bindingFn: e.value
    };
    r >= 0 ? t.splice(r, 1, i) : t.push(i);
  },
  unmounted(n) {
    Zu.delete(n);
  }
}, Tbe = 100, kbe = 600, yB = {
  beforeMount(n, e) {
    const t = e.value, { interval: r = Tbe, delay: i = kbe } = fn(t) ? {} : t;
    let o, a;
    const s = () => fn(t) ? t() : t.handler(), l = () => {
      a && (clearTimeout(a), a = void 0), o && (clearInterval(o), o = void 0);
    };
    n.addEventListener("mousedown", (u) => {
      u.button === 0 && (l(), s(), document.addEventListener("mouseup", () => l(), {
        once: !0
      }), a = setTimeout(() => {
        o = setInterval(() => {
          s();
        }, r);
      }, i));
    });
  }
}, fP = "_trap-focus-children", df = [], bB = (n) => {
  var e;
  if (df.length === 0)
    return;
  const t = df[df.length - 1][fP];
  if (t.length > 0 && n.code === Ft.tab) {
    if (t.length === 1) {
      n.preventDefault(), document.activeElement !== t[0] && t[0].focus();
      return;
    }
    const r = n.shiftKey, i = n.target === t[0], o = n.target === t[t.length - 1];
    if (i && r && (n.preventDefault(), t[t.length - 1].focus()), o && !r && (n.preventDefault(), t[0].focus()), process.env.NODE_ENV === "test") {
      const a = t.indexOf(n.target);
      a !== -1 && ((e = t[r ? a - 1 : a + 1]) == null || e.focus());
    }
  }
}, Pbe = {
  beforeMount(n) {
    n[fP] = _3(n), df.push(n), df.length <= 1 && document.addEventListener("keydown", bB);
  },
  updated(n) {
    Ke(() => {
      n[fP] = _3(n);
    });
  },
  unmounted() {
    df.shift(), df.length === 0 && document.removeEventListener("keydown", bB);
  }
};
var OB = !1, ef, dP, pP, sw, lw, rH, uw, gP, vP, mP, iH, yP, bP, oH, aH;
function ao() {
  if (!OB) {
    OB = !0;
    var n = navigator.userAgent, e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(n), t = /(Mac OS X)|(Windows)|(Linux)/.exec(n);
    if (yP = /\b(iPhone|iP[ao]d)/.exec(n), bP = /\b(iP[ao]d)/.exec(n), mP = /Android/i.exec(n), oH = /FBAN\/\w+;/i.exec(n), aH = /Mobile/i.exec(n), iH = !!/Win64/.exec(n), e) {
      ef = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN, ef && document && document.documentMode && (ef = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(n);
      rH = r ? parseFloat(r[1]) + 4 : ef, dP = e[2] ? parseFloat(e[2]) : NaN, pP = e[3] ? parseFloat(e[3]) : NaN, sw = e[4] ? parseFloat(e[4]) : NaN, sw ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(n), lw = e && e[1] ? parseFloat(e[1]) : NaN) : lw = NaN;
    } else
      ef = dP = pP = lw = sw = NaN;
    if (t) {
      if (t[1]) {
        var i = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(n);
        uw = i ? parseFloat(i[1].replace("_", ".")) : !0;
      } else
        uw = !1;
      gP = !!t[2], vP = !!t[3];
    } else
      uw = gP = vP = !1;
  }
}
var OP = { ie: function() {
  return ao() || ef;
}, ieCompatibilityMode: function() {
  return ao() || rH > ef;
}, ie64: function() {
  return OP.ie() && iH;
}, firefox: function() {
  return ao() || dP;
}, opera: function() {
  return ao() || pP;
}, webkit: function() {
  return ao() || sw;
}, safari: function() {
  return OP.webkit();
}, chrome: function() {
  return ao() || lw;
}, windows: function() {
  return ao() || gP;
}, osx: function() {
  return ao() || uw;
}, linux: function() {
  return ao() || vP;
}, iphone: function() {
  return ao() || yP;
}, mobile: function() {
  return ao() || yP || bP || mP || aH;
}, nativeApp: function() {
  return ao() || oH;
}, android: function() {
  return ao() || mP;
}, ipad: function() {
  return ao() || bP;
} }, Ebe = OP, g1 = !!(typeof window < "u" && window.document && window.document.createElement), Mbe = { canUseDOM: g1, canUseWorkers: typeof Worker < "u", canUseEventListeners: g1 && !!(window.addEventListener || window.attachEvent), canUseViewport: g1 && !!window.screen, isInWorker: !g1 }, sH = Mbe, lH;
sH.canUseDOM && (lH = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function Dbe(n, e) {
  if (!sH.canUseDOM || e && !("addEventListener" in document))
    return !1;
  var t = "on" + n, r = t in document;
  if (!r) {
    var i = document.createElement("div");
    i.setAttribute(t, "return;"), r = typeof i[t] == "function";
  }
  return !r && lH && n === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var Lbe = Dbe, wB = 10, xB = 40, SB = 800;
function uH(n) {
  var e = 0, t = 0, r = 0, i = 0;
  return "detail" in n && (t = n.detail), "wheelDelta" in n && (t = -n.wheelDelta / 120), "wheelDeltaY" in n && (t = -n.wheelDeltaY / 120), "wheelDeltaX" in n && (e = -n.wheelDeltaX / 120), "axis" in n && n.axis === n.HORIZONTAL_AXIS && (e = t, t = 0), r = e * wB, i = t * wB, "deltaY" in n && (i = n.deltaY), "deltaX" in n && (r = n.deltaX), (r || i) && n.deltaMode && (n.deltaMode == 1 ? (r *= xB, i *= xB) : (r *= SB, i *= SB)), r && !e && (e = r < 1 ? -1 : 1), i && !t && (t = i < 1 ? -1 : 1), { spinX: e, spinY: t, pixelX: r, pixelY: i };
}
uH.getEventType = function() {
  return Ebe.firefox() ? "DOMMouseScroll" : Lbe("wheel") ? "wheel" : "mousewheel";
};
var Ibe = uH;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const Rbe = function(n, e) {
  if (n && n.addEventListener) {
    const t = function(r) {
      const i = Ibe(r);
      e && Reflect.apply(e, this, [r, i]);
    };
    n.addEventListener("wheel", t, { passive: !0 });
  }
}, Nbe = {
  beforeMount(n, e) {
    Rbe(n, e.value);
  }
}, cH = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: Ra,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, hH = {
  [Dt]: (n) => Ut(n) || _t(n) || pi(n),
  change: (n) => Ut(n) || _t(n) || pi(n)
}, dv = Symbol("checkboxGroupContextKey"), $be = ({
  model: n,
  isChecked: e
}) => {
  const t = Re(dv, void 0), r = B(() => {
    var o, a;
    const s = (o = t == null ? void 0 : t.max) == null ? void 0 : o.value, l = (a = t == null ? void 0 : t.min) == null ? void 0 : a.value;
    return !Li(s) && n.value.length >= s && !e.value || !Li(l) && n.value.length <= l && e.value;
  });
  return {
    isDisabled: ah(B(() => (t == null ? void 0 : t.disabled.value) || r.value)),
    isLimitDisabled: r
  };
}, Bbe = (n, {
  model: e,
  isLimitExceeded: t,
  hasOwnLabel: r,
  isDisabled: i,
  isLabeledByFormItem: o
}) => {
  const a = Re(dv, void 0), { formItem: s } = Na(), { emit: l } = wt();
  function u(p) {
    var g, v;
    return p === n.trueLabel || p === !0 ? (g = n.trueLabel) != null ? g : !0 : (v = n.falseLabel) != null ? v : !1;
  }
  function c(p, g) {
    l("change", u(p), g);
  }
  function h(p) {
    if (t.value)
      return;
    const g = p.target;
    l("change", u(g.checked), p);
  }
  async function f(p) {
    t.value || !r.value && !i.value && o.value && (p.composedPath().some((m) => m.tagName === "LABEL") || (e.value = u([!1, n.falseLabel].includes(e.value)), await Ke(), c(e.value, p)));
  }
  const d = B(() => (a == null ? void 0 : a.validateEvent) || n.validateEvent);
  return he(() => n.modelValue, () => {
    d.value && (s == null || s.validate("change").catch((p) => Ht(p)));
  }), {
    handleChange: h,
    onClickRoot: f
  };
}, Vbe = (n) => {
  const e = z(!1), { emit: t } = wt(), r = Re(dv, void 0), i = B(() => Li(r) === !1), o = z(!1), a = B({
    get() {
      var s, l;
      return i.value ? (s = r == null ? void 0 : r.modelValue) == null ? void 0 : s.value : (l = n.modelValue) != null ? l : e.value;
    },
    set(s) {
      var l, u;
      i.value && _n(s) ? (o.value = ((l = r == null ? void 0 : r.max) == null ? void 0 : l.value) !== void 0 && s.length > (r == null ? void 0 : r.max.value) && s.length > a.value.length, o.value === !1 && ((u = r == null ? void 0 : r.changeEvent) == null || u.call(r, s))) : (t(Dt, s), e.value = s);
    }
  });
  return {
    model: a,
    isGroup: i,
    isLimitExceeded: o
  };
}, zbe = (n, e, { model: t }) => {
  const r = Re(dv, void 0), i = z(!1), o = B(() => {
    const u = t.value;
    return pi(u) ? u : _n(u) ? Nr(n.label) ? u.map(rx).some((c) => hr(c, n.label)) : u.map(rx).includes(n.label) : u != null ? u === n.trueLabel : !!u;
  }), a = ko(B(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  }), {
    prop: !0
  }), s = ko(B(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  })), l = B(() => !!e.default || !_o(n.label));
  return {
    checkboxButtonSize: a,
    isChecked: o,
    isFocused: i,
    checkboxSize: s,
    hasOwnLabel: l
  };
}, Fbe = (n, { model: e }) => {
  function t() {
    _n(e.value) && !e.value.includes(n.label) ? e.value.push(n.label) : e.value = n.trueLabel || !0;
  }
  n.checked && t();
}, fH = (n, e) => {
  const { formItem: t } = Na(), { model: r, isGroup: i, isLimitExceeded: o } = Vbe(n), {
    isFocused: a,
    isChecked: s,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c
  } = zbe(n, e, { model: r }), { isDisabled: h } = $be({ model: r, isChecked: s }), { inputId: f, isLabeledByFormItem: d } = Ad(n, {
    formItemContext: t,
    disableIdGeneration: c,
    disableIdManagement: i
  }), { handleChange: p, onClickRoot: g } = Bbe(n, {
    model: r,
    isLimitExceeded: o,
    hasOwnLabel: c,
    isDisabled: h,
    isLabeledByFormItem: d
  });
  return Fbe(n, { model: r }), {
    inputId: f,
    isLabeledByFormItem: d,
    isChecked: s,
    isDisabled: h,
    isFocused: a,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c,
    model: r,
    handleChange: p,
    onClickRoot: g
  };
}, Qbe = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], Zbe = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], Wbe = U({
  name: "ElCheckbox"
}), Gbe = /* @__PURE__ */ U({
  ...Wbe,
  props: cH,
  emits: hH,
  setup(n) {
    const e = n, t = Tl(), {
      inputId: r,
      isLabeledByFormItem: i,
      isChecked: o,
      isDisabled: a,
      isFocused: s,
      checkboxSize: l,
      hasOwnLabel: u,
      model: c,
      handleChange: h,
      onClickRoot: f
    } = fH(e, t), d = Pe("checkbox"), p = B(() => [
      d.b(),
      d.m(l.value),
      d.is("disabled", a.value),
      d.is("bordered", e.border),
      d.is("checked", o.value)
    ]), g = B(() => [
      d.e("input"),
      d.is("disabled", a.value),
      d.is("checked", o.value),
      d.is("indeterminate", e.indeterminate),
      d.is("focus", s.value)
    ]);
    return (v, m) => (V(), ve(cn(!T(u) && T(i) ? "span" : "label"), {
      class: Q(T(p)),
      "aria-controls": v.indeterminate ? v.controls : null,
      onClick: T(f)
    }, {
      default: fe(() => [
        J("span", {
          class: Q(T(g))
        }, [
          v.trueLabel || v.falseLabel ? At((V(), q("input", {
            key: 0,
            id: T(r),
            "onUpdate:modelValue": m[0] || (m[0] = (y) => So(c) ? c.value = y : null),
            class: Q(T(d).e("original")),
            type: "checkbox",
            indeterminate: v.indeterminate,
            name: v.name,
            tabindex: v.tabindex,
            disabled: T(a),
            "true-value": v.trueLabel,
            "false-value": v.falseLabel,
            onChange: m[1] || (m[1] = (...y) => T(h) && T(h)(...y)),
            onFocus: m[2] || (m[2] = (y) => s.value = !0),
            onBlur: m[3] || (m[3] = (y) => s.value = !1),
            onClick: m[4] || (m[4] = kt(() => {
            }, ["stop"]))
          }, null, 42, Qbe)), [
            [ix, T(c)]
          ]) : At((V(), q("input", {
            key: 1,
            id: T(r),
            "onUpdate:modelValue": m[5] || (m[5] = (y) => So(c) ? c.value = y : null),
            class: Q(T(d).e("original")),
            type: "checkbox",
            indeterminate: v.indeterminate,
            disabled: T(a),
            value: v.label,
            name: v.name,
            tabindex: v.tabindex,
            onChange: m[6] || (m[6] = (...y) => T(h) && T(h)(...y)),
            onFocus: m[7] || (m[7] = (y) => s.value = !0),
            onBlur: m[8] || (m[8] = (y) => s.value = !1),
            onClick: m[9] || (m[9] = kt(() => {
            }, ["stop"]))
          }, null, 42, Zbe)), [
            [ix, T(c)]
          ]),
          J("span", {
            class: Q(T(d).e("inner"))
          }, null, 2)
        ], 2),
        T(u) ? (V(), q("span", {
          key: 0,
          class: Q(T(d).e("label"))
        }, [
          ke(v.$slots, "default"),
          v.$slots.default ? pe("v-if", !0) : (V(), q(yn, { key: 0 }, [
            Ri(ze(v.label), 1)
          ], 64))
        ], 2)) : pe("v-if", !0)
      ]),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var jbe = /* @__PURE__ */ Ve(Gbe, [["__file", "checkbox.vue"]]);
const Hbe = ["name", "tabindex", "disabled", "true-value", "false-value"], qbe = ["name", "tabindex", "disabled", "value"], Ybe = U({
  name: "ElCheckboxButton"
}), Xbe = /* @__PURE__ */ U({
  ...Ybe,
  props: cH,
  emits: hH,
  setup(n) {
    const e = n, t = Tl(), {
      isFocused: r,
      isChecked: i,
      isDisabled: o,
      checkboxButtonSize: a,
      model: s,
      handleChange: l
    } = fH(e, t), u = Re(dv, void 0), c = Pe("checkbox"), h = B(() => {
      var d, p, g, v;
      const m = (p = (d = u == null ? void 0 : u.fill) == null ? void 0 : d.value) != null ? p : "";
      return {
        backgroundColor: m,
        borderColor: m,
        color: (v = (g = u == null ? void 0 : u.textColor) == null ? void 0 : g.value) != null ? v : "",
        boxShadow: m ? `-1px 0 0 0 ${m}` : void 0
      };
    }), f = B(() => [
      c.b("button"),
      c.bm("button", a.value),
      c.is("disabled", o.value),
      c.is("checked", i.value),
      c.is("focus", r.value)
    ]);
    return (d, p) => (V(), q("label", {
      class: Q(T(f))
    }, [
      d.trueLabel || d.falseLabel ? At((V(), q("input", {
        key: 0,
        "onUpdate:modelValue": p[0] || (p[0] = (g) => So(s) ? s.value = g : null),
        class: Q(T(c).be("button", "original")),
        type: "checkbox",
        name: d.name,
        tabindex: d.tabindex,
        disabled: T(o),
        "true-value": d.trueLabel,
        "false-value": d.falseLabel,
        onChange: p[1] || (p[1] = (...g) => T(l) && T(l)(...g)),
        onFocus: p[2] || (p[2] = (g) => r.value = !0),
        onBlur: p[3] || (p[3] = (g) => r.value = !1),
        onClick: p[4] || (p[4] = kt(() => {
        }, ["stop"]))
      }, null, 42, Hbe)), [
        [ix, T(s)]
      ]) : At((V(), q("input", {
        key: 1,
        "onUpdate:modelValue": p[5] || (p[5] = (g) => So(s) ? s.value = g : null),
        class: Q(T(c).be("button", "original")),
        type: "checkbox",
        name: d.name,
        tabindex: d.tabindex,
        disabled: T(o),
        value: d.label,
        onChange: p[6] || (p[6] = (...g) => T(l) && T(l)(...g)),
        onFocus: p[7] || (p[7] = (g) => r.value = !0),
        onBlur: p[8] || (p[8] = (g) => r.value = !1),
        onClick: p[9] || (p[9] = kt(() => {
        }, ["stop"]))
      }, null, 42, qbe)), [
        [ix, T(s)]
      ]),
      d.$slots.default || d.label ? (V(), q("span", {
        key: 2,
        class: Q(T(c).be("button", "inner")),
        style: vt(T(i) ? T(h) : void 0)
      }, [
        ke(d.$slots, "default", {}, () => [
          Ri(ze(d.label), 1)
        ])
      ], 6)) : pe("v-if", !0)
    ], 2));
  }
});
var dH = /* @__PURE__ */ Ve(Xbe, [["__file", "checkbox-button.vue"]]);
const Ube = Ye({
  modelValue: {
    type: Ae(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: Ra,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), Kbe = {
  [Dt]: (n) => _n(n),
  change: (n) => _n(n)
}, Jbe = U({
  name: "ElCheckboxGroup"
}), e1e = /* @__PURE__ */ U({
  ...Jbe,
  props: Ube,
  emits: Kbe,
  setup(n, { emit: e }) {
    const t = n, r = Pe("checkbox"), { formItem: i } = Na(), { inputId: o, isLabeledByFormItem: a } = Ad(t, {
      formItemContext: i
    }), s = async (u) => {
      e(Dt, u), await Ke(), e("change", u);
    }, l = B({
      get() {
        return t.modelValue;
      },
      set(u) {
        s(u);
      }
    });
    return Wt(dv, {
      ...Uk(bu(t), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: l,
      changeEvent: s
    }), he(() => t.modelValue, () => {
      t.validateEvent && (i == null || i.validate("change").catch((u) => Ht(u)));
    }), (u, c) => {
      var h;
      return V(), ve(cn(u.tag), {
        id: T(o),
        class: Q(T(r).b("group")),
        role: "group",
        "aria-label": T(a) ? void 0 : u.label || "checkbox-group",
        "aria-labelledby": T(a) ? (h = T(i)) == null ? void 0 : h.labelId : void 0
      }, {
        default: fe(() => [
          ke(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var pH = /* @__PURE__ */ Ve(e1e, [["__file", "checkbox-group.vue"]]);
const yl = zn(jbe, {
  CheckboxButton: dH,
  CheckboxGroup: pH
});
Os(dH);
const t1e = Os(pH), gH = Ye({
  size: Ra,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
}), n1e = Ye({
  ...gH,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}), vH = {
  [Dt]: (n) => Ut(n) || _t(n) || pi(n),
  [yi]: (n) => Ut(n) || _t(n) || pi(n)
}, mH = Symbol("radioGroupKey"), yH = (n, e) => {
  const t = z(), r = Re(mH, void 0), i = B(() => !!r), o = B({
    get() {
      return i.value ? r.modelValue : n.modelValue;
    },
    set(c) {
      i.value ? r.changeEvent(c) : e && e(Dt, c), t.value.checked = n.modelValue === n.label;
    }
  }), a = ko(B(() => r == null ? void 0 : r.size)), s = ah(B(() => r == null ? void 0 : r.disabled)), l = z(!1), u = B(() => s.value || i.value && o.value !== n.label ? -1 : 0);
  return {
    radioRef: t,
    isGroup: i,
    radioGroup: r,
    focus: l,
    size: a,
    disabled: s,
    tabIndex: u,
    modelValue: o
  };
}, r1e = ["value", "name", "disabled"], i1e = U({
  name: "ElRadio"
}), o1e = /* @__PURE__ */ U({
  ...i1e,
  props: n1e,
  emits: vH,
  setup(n, { emit: e }) {
    const t = n, r = Pe("radio"), { radioRef: i, radioGroup: o, focus: a, size: s, disabled: l, modelValue: u } = yH(t, e);
    function c() {
      Ke(() => e("change", u.value));
    }
    return (h, f) => {
      var d;
      return V(), q("label", {
        class: Q([
          T(r).b(),
          T(r).is("disabled", T(l)),
          T(r).is("focus", T(a)),
          T(r).is("bordered", h.border),
          T(r).is("checked", T(u) === h.label),
          T(r).m(T(s))
        ])
      }, [
        J("span", {
          class: Q([
            T(r).e("input"),
            T(r).is("disabled", T(l)),
            T(r).is("checked", T(u) === h.label)
          ])
        }, [
          At(J("input", {
            ref_key: "radioRef",
            ref: i,
            "onUpdate:modelValue": f[0] || (f[0] = (p) => So(u) ? u.value = p : null),
            class: Q(T(r).e("original")),
            value: h.label,
            name: h.name || ((d = T(o)) == null ? void 0 : d.name),
            disabled: T(l),
            type: "radio",
            onFocus: f[1] || (f[1] = (p) => a.value = !0),
            onBlur: f[2] || (f[2] = (p) => a.value = !1),
            onChange: c,
            onClick: f[3] || (f[3] = kt(() => {
            }, ["stop"]))
          }, null, 42, r1e), [
            [DG, T(u)]
          ]),
          J("span", {
            class: Q(T(r).e("inner"))
          }, null, 2)
        ], 2),
        J("span", {
          class: Q(T(r).e("label")),
          onKeydown: f[4] || (f[4] = kt(() => {
          }, ["stop"]))
        }, [
          ke(h.$slots, "default", {}, () => [
            Ri(ze(h.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var a1e = /* @__PURE__ */ Ve(o1e, [["__file", "radio.vue"]]);
const s1e = Ye({
  ...gH,
  name: {
    type: String,
    default: ""
  }
}), l1e = ["value", "name", "disabled"], u1e = U({
  name: "ElRadioButton"
}), c1e = /* @__PURE__ */ U({
  ...u1e,
  props: s1e,
  setup(n) {
    const e = n, t = Pe("radio"), { radioRef: r, focus: i, size: o, disabled: a, modelValue: s, radioGroup: l } = yH(e), u = B(() => ({
      backgroundColor: (l == null ? void 0 : l.fill) || "",
      borderColor: (l == null ? void 0 : l.fill) || "",
      boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
      color: (l == null ? void 0 : l.textColor) || ""
    }));
    return (c, h) => {
      var f;
      return V(), q("label", {
        class: Q([
          T(t).b("button"),
          T(t).is("active", T(s) === c.label),
          T(t).is("disabled", T(a)),
          T(t).is("focus", T(i)),
          T(t).bm("button", T(o))
        ])
      }, [
        At(J("input", {
          ref_key: "radioRef",
          ref: r,
          "onUpdate:modelValue": h[0] || (h[0] = (d) => So(s) ? s.value = d : null),
          class: Q(T(t).be("button", "original-radio")),
          value: c.label,
          type: "radio",
          name: c.name || ((f = T(l)) == null ? void 0 : f.name),
          disabled: T(a),
          onFocus: h[1] || (h[1] = (d) => i.value = !0),
          onBlur: h[2] || (h[2] = (d) => i.value = !1),
          onClick: h[3] || (h[3] = kt(() => {
          }, ["stop"]))
        }, null, 42, l1e), [
          [DG, T(s)]
        ]),
        J("span", {
          class: Q(T(t).be("button", "inner")),
          style: vt(T(s) === c.label ? T(u) : {}),
          onKeydown: h[4] || (h[4] = kt(() => {
          }, ["stop"]))
        }, [
          ke(c.$slots, "default", {}, () => [
            Ri(ze(c.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var bH = /* @__PURE__ */ Ve(c1e, [["__file", "radio-button.vue"]]);
const h1e = Ye({
  id: {
    type: String,
    default: void 0
  },
  size: Ra,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), f1e = vH, d1e = ["id", "aria-label", "aria-labelledby"], p1e = U({
  name: "ElRadioGroup"
}), g1e = /* @__PURE__ */ U({
  ...p1e,
  props: h1e,
  emits: f1e,
  setup(n, { emit: e }) {
    const t = n, r = Pe("radio"), i = fs(), o = z(), { formItem: a } = Na(), { inputId: s, isLabeledByFormItem: l } = Ad(t, {
      formItemContext: a
    }), u = (h) => {
      e(Dt, h), Ke(() => e("change", h));
    };
    ht(() => {
      const h = o.value.querySelectorAll("[type=radio]"), f = h[0];
      !Array.from(h).some((d) => d.checked) && f && (f.tabIndex = 0);
    });
    const c = B(() => t.name || i.value);
    return Wt(mH, dr({
      ...bu(t),
      changeEvent: u,
      name: c
    })), he(() => t.modelValue, () => {
      t.validateEvent && (a == null || a.validate("change").catch((h) => Ht(h)));
    }), (h, f) => (V(), q("div", {
      id: T(s),
      ref_key: "radioGroupRef",
      ref: o,
      class: Q(T(r).b("group")),
      role: "radiogroup",
      "aria-label": T(l) ? void 0 : h.label || "radio-group",
      "aria-labelledby": T(l) ? T(a).labelId : void 0
    }, [
      ke(h.$slots, "default")
    ], 10, d1e));
  }
});
var OH = /* @__PURE__ */ Ve(g1e, [["__file", "radio-group.vue"]]);
const v1e = zn(a1e, {
  RadioButton: bH,
  RadioGroup: OH
}), KFt = Os(OH), JFt = Os(bH);
var m1e = U({
  name: "NodeContent",
  setup() {
    return {
      ns: Pe("cascader-node")
    };
  },
  render() {
    const { ns: n } = this, { node: e, panel: t } = this.$parent, { data: r, label: i } = e, { renderLabelFn: o } = t;
    return et("span", { class: n.e("label") }, o ? o({ node: e, data: r }) : i);
  }
});
const zL = Symbol(), y1e = U({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: yl,
    ElRadio: v1e,
    NodeContent: m1e,
    ElIcon: bt,
    Check: mL,
    Loading: _d,
    ArrowRight: Sd
  },
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(n, { emit: e }) {
    const t = Re(zL), r = Pe("cascader-node"), i = B(() => t.isHoverMenu), o = B(() => t.config.multiple), a = B(() => t.config.checkStrictly), s = B(() => {
      var x;
      return (x = t.checkedNodes[0]) == null ? void 0 : x.uid;
    }), l = B(() => n.node.isDisabled), u = B(() => n.node.isLeaf), c = B(() => a.value && !u.value || !l.value), h = B(() => d(t.expandingNode)), f = B(() => a.value && t.checkedNodes.some(d)), d = (x) => {
      var S;
      const { level: _, uid: C } = n.node;
      return ((S = x == null ? void 0 : x.pathNodes[_ - 1]) == null ? void 0 : S.uid) === C;
    }, p = () => {
      h.value || t.expandNode(n.node);
    }, g = (x) => {
      const { node: S } = n;
      x !== S.checked && t.handleCheckChange(S, x);
    }, v = () => {
      t.lazyLoad(n.node, () => {
        u.value || p();
      });
    }, m = (x) => {
      i.value && (y(), !u.value && e("expand", x));
    }, y = () => {
      const { node: x } = n;
      !c.value || x.loading || (x.loaded ? p() : v());
    }, b = () => {
      i.value && !u.value || (u.value && !l.value && !a.value && !o.value ? w(!0) : y());
    }, O = (x) => {
      a.value ? (g(x), n.node.loaded && p()) : w(x);
    }, w = (x) => {
      n.node.loaded ? (g(x), !a.value && p()) : v();
    };
    return {
      panel: t,
      isHoverMenu: i,
      multiple: o,
      checkStrictly: a,
      checkedNodeId: s,
      isDisabled: l,
      isLeaf: u,
      expandable: c,
      inExpandingPath: h,
      inCheckedPath: f,
      ns: r,
      handleHoverExpand: m,
      handleExpand: y,
      handleClick: b,
      handleCheck: w,
      handleSelectCheck: O
    };
  }
}), b1e = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], O1e = /* @__PURE__ */ J("span", null, null, -1);
function w1e(n, e, t, r, i, o) {
  const a = Ct("el-checkbox"), s = Ct("el-radio"), l = Ct("check"), u = Ct("el-icon"), c = Ct("node-content"), h = Ct("loading"), f = Ct("arrow-right");
  return V(), q("li", {
    id: `${n.menuId}-${n.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !n.isLeaf,
    "aria-owns": n.isLeaf ? null : n.menuId,
    "aria-expanded": n.inExpandingPath,
    tabindex: n.expandable ? -1 : void 0,
    class: Q([
      n.ns.b(),
      n.ns.is("selectable", n.checkStrictly),
      n.ns.is("active", n.node.checked),
      n.ns.is("disabled", !n.expandable),
      n.inExpandingPath && "in-active-path",
      n.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: e[2] || (e[2] = (...d) => n.handleHoverExpand && n.handleHoverExpand(...d)),
    onFocus: e[3] || (e[3] = (...d) => n.handleHoverExpand && n.handleHoverExpand(...d)),
    onClick: e[4] || (e[4] = (...d) => n.handleClick && n.handleClick(...d))
  }, [
    pe(" prefix "),
    n.multiple ? (V(), ve(a, {
      key: 0,
      "model-value": n.node.checked,
      indeterminate: n.node.indeterminate,
      disabled: n.isDisabled,
      onClick: e[0] || (e[0] = kt(() => {
      }, ["stop"])),
      "onUpdate:modelValue": n.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : n.checkStrictly ? (V(), ve(s, {
      key: 1,
      "model-value": n.checkedNodeId,
      label: n.node.uid,
      disabled: n.isDisabled,
      "onUpdate:modelValue": n.handleSelectCheck,
      onClick: e[1] || (e[1] = kt(() => {
      }, ["stop"]))
    }, {
      default: fe(() => [
        pe(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
        O1e
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : n.isLeaf && n.node.checked ? (V(), ve(u, {
      key: 2,
      class: Q(n.ns.e("prefix"))
    }, {
      default: fe(() => [
        de(l)
      ]),
      _: 1
    }, 8, ["class"])) : pe("v-if", !0),
    pe(" content "),
    de(c),
    pe(" postfix "),
    n.isLeaf ? pe("v-if", !0) : (V(), q(yn, { key: 3 }, [
      n.node.loading ? (V(), ve(u, {
        key: 0,
        class: Q([n.ns.is("loading"), n.ns.e("postfix")])
      }, {
        default: fe(() => [
          de(h)
        ]),
        _: 1
      }, 8, ["class"])) : (V(), ve(u, {
        key: 1,
        class: Q(["arrow-right", n.ns.e("postfix")])
      }, {
        default: fe(() => [
          de(f)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64))
  ], 42, b1e);
}
var x1e = /* @__PURE__ */ Ve(y1e, [["render", w1e], ["__file", "node.vue"]]);
const S1e = U({
  name: "ElCascaderMenu",
  components: {
    Loading: _d,
    ElIcon: bt,
    ElScrollbar: Ob,
    ElCascaderNode: x1e
  },
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(n) {
    const e = wt(), t = Pe("cascader-menu"), { t: r } = Ar(), i = fs();
    let o = null, a = null;
    const s = Re(zL), l = z(null), u = B(() => !n.nodes.length), c = B(() => !s.initialLoaded), h = B(() => `${i.value}-${n.index}`), f = (v) => {
      o = v.target;
    }, d = (v) => {
      if (!(!s.isHoverMenu || !o || !l.value))
        if (o.contains(v.target)) {
          p();
          const m = e.vnode.el, { left: y } = m.getBoundingClientRect(), { offsetWidth: b, offsetHeight: O } = m, w = v.clientX - y, x = o.offsetTop, S = x + o.offsetHeight;
          l.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${w} ${x} L${b} 0 V${x} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${w} ${S} L${b} ${O} V${S} Z" />
        `;
        } else
          a || (a = window.setTimeout(g, s.config.hoverThreshold));
    }, p = () => {
      a && (clearTimeout(a), a = null);
    }, g = () => {
      l.value && (l.value.innerHTML = "", p());
    };
    return {
      ns: t,
      panel: s,
      hoverZone: l,
      isEmpty: u,
      isLoading: c,
      menuId: h,
      t: r,
      handleExpand: f,
      handleMouseMove: d,
      clearHoverZone: g
    };
  }
});
function _1e(n, e, t, r, i, o) {
  const a = Ct("el-cascader-node"), s = Ct("loading"), l = Ct("el-icon"), u = Ct("el-scrollbar");
  return V(), ve(u, {
    key: n.menuId,
    tag: "ul",
    role: "menu",
    class: Q(n.ns.b()),
    "wrap-class": n.ns.e("wrap"),
    "view-class": [n.ns.e("list"), n.ns.is("empty", n.isEmpty)],
    onMousemove: n.handleMouseMove,
    onMouseleave: n.clearHoverZone
  }, {
    default: fe(() => {
      var c;
      return [
        (V(!0), q(yn, null, qi(n.nodes, (h) => (V(), ve(a, {
          key: h.uid,
          node: h,
          "menu-id": n.menuId,
          onExpand: n.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
        n.isLoading ? (V(), q("div", {
          key: 0,
          class: Q(n.ns.e("empty-text"))
        }, [
          de(l, {
            size: "14",
            class: Q(n.ns.is("loading"))
          }, {
            default: fe(() => [
              de(s)
            ]),
            _: 1
          }, 8, ["class"]),
          Ri(" " + ze(n.t("el.cascader.loading")), 1)
        ], 2)) : n.isEmpty ? (V(), q("div", {
          key: 1,
          class: Q(n.ns.e("empty-text"))
        }, ze(n.t("el.cascader.noData")), 3)) : (c = n.panel) != null && c.isHoverMenu ? (V(), q("svg", {
          key: 2,
          ref: "hoverZone",
          class: Q(n.ns.e("hover-zone"))
        }, null, 2)) : pe("v-if", !0)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var C1e = /* @__PURE__ */ Ve(S1e, [["render", _1e], ["__file", "menu.vue"]]);
let A1e = 0;
const T1e = (n) => {
  const e = [n];
  let { parent: t } = n;
  for (; t; )
    e.unshift(t), t = t.parent;
  return e;
};
let wP = class xP {
  constructor(e, t, r, i = !1) {
    this.data = e, this.config = t, this.parent = r, this.root = i, this.uid = A1e++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
    const { value: o, label: a, children: s } = t, l = e[s], u = T1e(this);
    this.level = i ? 0 : r ? r.level + 1 : 1, this.value = e[o], this.label = e[a], this.pathNodes = u, this.pathValues = u.map((c) => c.value), this.pathLabels = u.map((c) => c.label), this.childrenData = l, this.children = (l || []).map((c) => new xP(c, t, this)), this.loaded = !t.lazy || this.isLeaf || !Gs(l);
  }
  get isDisabled() {
    const { data: e, parent: t, config: r } = this, { disabled: i, checkStrictly: o } = r;
    return (fn(i) ? i(e, this) : !!e[i]) || !o && (t == null ? void 0 : t.isDisabled);
  }
  get isLeaf() {
    const { data: e, config: t, childrenData: r, loaded: i } = this, { lazy: o, leaf: a } = t, s = fn(a) ? a(e, this) : e[a];
    return Li(s) ? o && !i ? !1 : !(Array.isArray(r) && r.length) : !!s;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(e) {
    const { childrenData: t, children: r } = this, i = new xP(e, this.config, this);
    return Array.isArray(t) ? t.push(e) : this.childrenData = [e], r.push(i), i;
  }
  calcText(e, t) {
    const r = e ? this.pathLabels.join(t) : this.label;
    return this.text = r, r;
  }
  broadcast(e, ...t) {
    const r = `onParent${js(e)}`;
    this.children.forEach((i) => {
      i && (i.broadcast(e, ...t), i[r] && i[r](...t));
    });
  }
  emit(e, ...t) {
    const { parent: r } = this, i = `onChild${js(e)}`;
    r && (r[i] && r[i](...t), r.emit(e, ...t));
  }
  onParentCheck(e) {
    this.isDisabled || this.setCheckState(e);
  }
  onChildCheck() {
    const { children: e } = this, t = e.filter((i) => !i.isDisabled), r = t.length ? t.every((i) => i.checked) : !1;
    this.setCheckState(r);
  }
  setCheckState(e) {
    const t = this.children.length, r = this.children.reduce((i, o) => {
      const a = o.checked ? 1 : o.indeterminate ? 0.5 : 0;
      return i + a;
    }, 0);
    this.checked = this.loaded && this.children.filter((i) => !i.isDisabled).every((i) => i.loaded && i.checked) && e, this.indeterminate = this.loaded && r !== t && r > 0;
  }
  doCheck(e) {
    if (this.checked === e)
      return;
    const { checkStrictly: t, multiple: r } = this.config;
    t || !r ? this.checked = e : (this.broadcast("check", e), this.setCheckState(e), this.emit("check"));
  }
};
const SP = (n, e) => n.reduce((t, r) => (r.isLeaf ? t.push(r) : (!e && t.push(r), t = t.concat(SP(r.children, e))), t), []);
let _B = class {
  constructor(e, t) {
    this.config = t;
    const r = (e || []).map((i) => new wP(i, this.config));
    this.nodes = r, this.allNodes = SP(r, !1), this.leafNodes = SP(r, !0);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(e) {
    return e ? this.leafNodes : this.allNodes;
  }
  appendNode(e, t) {
    const r = t ? t.appendChild(e) : new wP(e, this.config);
    t || this.nodes.push(r), this.allNodes.push(r), r.isLeaf && this.leafNodes.push(r);
  }
  appendNodes(e, t) {
    e.forEach((r) => this.appendNode(r, t));
  }
  getNodeByValue(e, t = !1) {
    return !e && e !== 0 ? null : this.getFlattedNodes(t).find((i) => hr(i.value, e) || hr(i.pathValues, e)) || null;
  }
  getSameNode(e) {
    return e && this.getFlattedNodes(!1).find(({ value: r, level: i }) => hr(e.value, r) && e.level === i) || null;
  }
};
const wH = Ye({
  modelValue: {
    type: Ae([Number, String, Array])
  },
  options: {
    type: Ae(Array),
    default: () => []
  },
  props: {
    type: Ae(Object),
    default: () => ({})
  }
}), k1e = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: ll,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}, P1e = (n) => B(() => ({
  ...k1e,
  ...n.props
})), CB = (n) => {
  if (!n)
    return 0;
  const e = n.id.split("-");
  return Number(e[e.length - 2]);
}, E1e = (n) => {
  if (!n)
    return;
  const e = n.querySelector("input");
  e ? e.click() : r7(n) && n.click();
}, M1e = (n, e) => {
  const t = e.slice(0), r = t.map((o) => o.uid), i = n.reduce((o, a) => {
    const s = r.indexOf(a.uid);
    return s > -1 && (o.push(a), t.splice(s, 1), r.splice(s, 1)), o;
  }, []);
  return i.push(...t), i;
}, D1e = U({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: C1e
  },
  props: {
    ...wH,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: Function
  },
  emits: [Dt, yi, "close", "expand-change"],
  setup(n, { emit: e, slots: t }) {
    let r = !1;
    const i = Pe("cascader"), o = P1e(n);
    let a = null;
    const s = z(!0), l = z([]), u = z(null), c = z([]), h = z(null), f = z([]), d = B(() => o.value.expandTrigger === "hover"), p = B(() => n.renderLabel || t.default), g = () => {
      const { options: P } = n, L = o.value;
      r = !1, a = new _B(P, L), c.value = [a.getNodes()], L.lazy && Gs(n.options) ? (s.value = !1, v(void 0, (D) => {
        D && (a = new _B(D, L), c.value = [a.getNodes()]), s.value = !0, _(!1, !0);
      })) : _(!1, !0);
    }, v = (P, L) => {
      const D = o.value;
      P = P || new wP({}, D, void 0, !0), P.loading = !0;
      const E = (M) => {
        const R = P, N = R.root ? null : R;
        M && (a == null || a.appendNodes(M, N)), R.loading = !1, R.loaded = !0, R.childrenData = R.childrenData || [], L && L(M);
      };
      D.lazyLoad(P, E);
    }, m = (P, L) => {
      var D;
      const { level: E } = P, M = c.value.slice(0, E);
      let R;
      P.isLeaf ? R = P.pathNodes[E - 2] : (R = P, M.push(P.children)), ((D = h.value) == null ? void 0 : D.uid) !== (R == null ? void 0 : R.uid) && (h.value = P, c.value = M, !L && e("expand-change", (P == null ? void 0 : P.pathValues) || []));
    }, y = (P, L, D = !0) => {
      const { checkStrictly: E, multiple: M } = o.value, R = f.value[0];
      r = !0, !M && (R == null || R.doCheck(!1)), P.doCheck(L), S(), D && !M && !E && e("close"), !D && !M && !E && b(P);
    }, b = (P) => {
      P && (P = P.parent, b(P), P && m(P));
    }, O = (P) => a == null ? void 0 : a.getFlattedNodes(P), w = (P) => {
      var L;
      return (L = O(P)) == null ? void 0 : L.filter((D) => D.checked !== !1);
    }, x = () => {
      f.value.forEach((P) => P.doCheck(!1)), S(), c.value = c.value.slice(0, 1), h.value = null, e("expand-change", []);
    }, S = () => {
      var P;
      const { checkStrictly: L, multiple: D } = o.value, E = f.value, M = w(!L), R = M1e(E, M), N = R.map(($) => $.valueByOption);
      f.value = R, u.value = D ? N : (P = N[0]) != null ? P : null;
    }, _ = (P = !1, L = !1) => {
      const { modelValue: D } = n, { lazy: E, multiple: M, checkStrictly: R } = o.value, N = !R;
      if (!(!s.value || r || !L && hr(D, u.value)))
        if (E && !P) {
          const F = B3(Ufe(V3(D))).map((W) => a == null ? void 0 : a.getNodeByValue(W)).filter((W) => !!W && !W.loaded && !W.loading);
          F.length ? F.forEach((W) => {
            v(W, () => _(!1, L));
          }) : _(!0, L);
        } else {
          const $ = M ? V3(D) : [D], F = B3($.map((W) => a == null ? void 0 : a.getNodeByValue(W, N)));
          C(F, L), u.value = Sn(D);
        }
    }, C = (P, L = !0) => {
      const { checkStrictly: D } = o.value, E = f.value, M = P.filter(($) => !!$ && (D || $.isLeaf)), R = a == null ? void 0 : a.getSameNode(h.value), N = L && R || M[0];
      N ? N.pathNodes.forEach(($) => m($, !0)) : h.value = null, E.forEach(($) => $.doCheck(!1)), n.props.multiple ? dr(M).forEach(($) => $.doCheck(!0)) : M.forEach(($) => $.doCheck(!0)), f.value = M, Ke(A);
    }, A = () => {
      qt && l.value.forEach((P) => {
        const L = P == null ? void 0 : P.$el;
        if (L) {
          const D = L.querySelector(`.${i.namespace.value}-scrollbar__wrap`), E = L.querySelector(`.${i.b("node")}.${i.is("active")}`) || L.querySelector(`.${i.b("node")}.in-active-path`);
          c7(D, E);
        }
      });
    }, k = (P) => {
      const L = P.target, { code: D } = P;
      switch (D) {
        case Ft.up:
        case Ft.down: {
          P.preventDefault();
          const E = D === Ft.up ? -1 : 1;
          tw(i7(L, E, `.${i.b("node")}[tabindex="-1"]`));
          break;
        }
        case Ft.left: {
          P.preventDefault();
          const E = l.value[CB(L) - 1], M = E == null ? void 0 : E.$el.querySelector(`.${i.b("node")}[aria-expanded="true"]`);
          tw(M);
          break;
        }
        case Ft.right: {
          P.preventDefault();
          const E = l.value[CB(L) + 1], M = E == null ? void 0 : E.$el.querySelector(`.${i.b("node")}[tabindex="-1"]`);
          tw(M);
          break;
        }
        case Ft.enter:
          E1e(L);
          break;
      }
    };
    return Wt(zL, dr({
      config: o,
      expandingNode: h,
      checkedNodes: f,
      isHoverMenu: d,
      initialLoaded: s,
      renderLabelFn: p,
      lazyLoad: v,
      expandNode: m,
      handleCheckChange: y
    })), he([o, () => n.options], g, {
      deep: !0,
      immediate: !0
    }), he(() => n.modelValue, () => {
      r = !1, _();
    }, {
      deep: !0
    }), he(() => u.value, (P) => {
      hr(P, n.modelValue) || (e(Dt, P), e(yi, P));
    }), aae(() => l.value = []), ht(() => !Gs(n.modelValue) && _()), {
      ns: i,
      menuList: l,
      menus: c,
      checkedNodes: f,
      handleKeyDown: k,
      handleCheckChange: y,
      getFlattedNodes: O,
      getCheckedNodes: w,
      clearCheckedNodes: x,
      calculateCheckedValue: S,
      scrollToExpandingNode: A
    };
  }
});
function L1e(n, e, t, r, i, o) {
  const a = Ct("el-cascader-menu");
  return V(), q("div", {
    class: Q([n.ns.b("panel"), n.ns.is("bordered", n.border)]),
    onKeydown: e[0] || (e[0] = (...s) => n.handleKeyDown && n.handleKeyDown(...s))
  }, [
    (V(!0), q(yn, null, qi(n.menus, (s, l) => (V(), ve(a, {
      key: l,
      ref_for: !0,
      ref: (u) => n.menuList[l] = u,
      index: l,
      nodes: [...s]
    }, null, 8, ["index", "nodes"]))), 128))
  ], 34);
}
var cw = /* @__PURE__ */ Ve(D1e, [["render", L1e], ["__file", "index.vue"]]);
cw.install = (n) => {
  n.component(cw.name, cw);
};
const I1e = cw, FL = Ye({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: String,
  size: {
    type: String,
    values: Cd
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), R1e = {
  close: (n) => n instanceof MouseEvent,
  click: (n) => n instanceof MouseEvent
}, N1e = U({
  name: "ElTag"
}), $1e = /* @__PURE__ */ U({
  ...N1e,
  props: FL,
  emits: R1e,
  setup(n, { emit: e }) {
    const t = n, r = ko(), i = Pe("tag"), o = B(() => {
      const { type: l, hit: u, effect: c, closable: h, round: f } = t;
      return [
        i.b(),
        i.is("closable", h),
        i.m(l || "primary"),
        i.m(r.value),
        i.m(c),
        i.is("hit", u),
        i.is("round", f)
      ];
    }), a = (l) => {
      e("close", l);
    }, s = (l) => {
      e("click", l);
    };
    return (l, u) => l.disableTransitions ? (V(), q("span", {
      key: 0,
      class: Q(T(o)),
      style: vt({ backgroundColor: l.color }),
      onClick: s
    }, [
      J("span", {
        class: Q(T(i).e("content"))
      }, [
        ke(l.$slots, "default")
      ], 2),
      l.closable ? (V(), ve(T(bt), {
        key: 0,
        class: Q(T(i).e("close")),
        onClick: kt(a, ["stop"])
      }, {
        default: fe(() => [
          de(T(Pc))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : pe("v-if", !0)
    ], 6)) : (V(), ve(kl, {
      key: 1,
      name: `${T(i).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: fe(() => [
        J("span", {
          class: Q(T(o)),
          style: vt({ backgroundColor: l.color }),
          onClick: s
        }, [
          J("span", {
            class: Q(T(i).e("content"))
          }, [
            ke(l.$slots, "default")
          ], 2),
          l.closable ? (V(), ve(T(bt), {
            key: 0,
            class: Q(T(i).e("close")),
            onClick: kt(a, ["stop"])
          }, {
            default: fe(() => [
              de(T(Pc))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : pe("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var B1e = /* @__PURE__ */ Ve($1e, [["__file", "tag.vue"]]);
const _P = zn(B1e), V1e = Ye({
  ...wH,
  size: Ra,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: Ae(Function),
    default: (n, e) => n.text.includes(e)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: Ae(Function),
    default: () => !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: po.teleported,
  tagType: { ...FL.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), z1e = {
  [Dt]: (n) => !!n || n === null,
  [yi]: (n) => !!n || n === null,
  focus: (n) => n instanceof FocusEvent,
  blur: (n) => n instanceof FocusEvent,
  visibleChange: (n) => pi(n),
  expandChange: (n) => !!n,
  removeTag: (n) => !!n
}, F1e = { key: 0 }, Q1e = ["placeholder", "onKeydown"], Z1e = ["onClick"], W1e = "ElCascader", G1e = U({
  name: W1e
}), j1e = /* @__PURE__ */ U({
  ...G1e,
  props: V1e,
  emits: z1e,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: !0,
          phase: "main",
          fn: ({ state: oe }) => {
            const { modifiersData: ge, placement: Se } = oe;
            ["right", "left", "bottom", "top"].includes(Se) || (ge.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, o = PG();
    let a = 0, s = 0;
    const l = Pe("cascader"), u = Pe("input"), { t: c } = Ar(), { form: h, formItem: f } = Na(), d = z(null), p = z(null), g = z(null), v = z(null), m = z(null), y = z(!1), b = z(!1), O = z(!1), w = z(!1), x = z(""), S = z(""), _ = z([]), C = z([]), A = z([]), k = z(!1), P = B(() => o.style), L = B(() => r.disabled || (h == null ? void 0 : h.disabled)), D = B(() => r.placeholder || c("el.cascader.placeholder")), E = B(() => S.value || _.value.length > 0 || k.value ? "" : D.value), M = ko(), R = B(() => ["small"].includes(M.value) ? "small" : "default"), N = B(() => !!r.props.multiple), $ = B(() => !r.filterable || N.value), F = B(() => N.value ? S.value : x.value), W = B(() => {
      var oe;
      return ((oe = v.value) == null ? void 0 : oe.checkedNodes) || [];
    }), j = B(() => !r.clearable || L.value || O.value || !b.value ? !1 : !!W.value.length), Y = B(() => {
      const { showAllLevels: oe, separator: ge } = r, Se = W.value;
      return Se.length ? N.value ? "" : Se[0].calcText(oe, ge) : "";
    }), X = B({
      get() {
        return Sn(r.modelValue);
      },
      set(oe) {
        t(Dt, oe), t(yi, oe), r.validateEvent && (f == null || f.validate("change").catch((ge) => Ht(ge)));
      }
    }), ie = B(() => [
      l.b(),
      l.m(M.value),
      l.is("disabled", L.value),
      o.class
    ]), ae = B(() => [
      u.e("icon"),
      "icon-arrow-down",
      l.is("reverse", y.value)
    ]), ee = B(() => l.is("focus", y.value || w.value)), ne = B(() => {
      var oe, ge;
      return (ge = (oe = d.value) == null ? void 0 : oe.popperRef) == null ? void 0 : ge.contentRef;
    }), ye = (oe) => {
      var ge, Se, yt;
      L.value || (oe = oe ?? !y.value, oe !== y.value && (y.value = oe, (Se = (ge = p.value) == null ? void 0 : ge.input) == null || Se.setAttribute("aria-expanded", `${oe}`), oe ? (te(), Ke((yt = v.value) == null ? void 0 : yt.scrollToExpandingNode)) : r.filterable && Jr(), t("visibleChange", oe)));
    }, te = () => {
      Ke(() => {
        var oe;
        (oe = d.value) == null || oe.updatePopper();
      });
    }, ue = () => {
      O.value = !1;
    }, xe = (oe) => {
      const { showAllLevels: ge, separator: Se } = r;
      return {
        node: oe,
        key: oe.uid,
        text: oe.calcText(ge, Se),
        hitState: !1,
        closable: !L.value && !oe.isDisabled,
        isCollapseTag: !1
      };
    }, dt = (oe) => {
      var ge;
      const Se = oe.node;
      Se.doCheck(!1), (ge = v.value) == null || ge.calculateCheckedValue(), t("removeTag", Se.valueByOption);
    }, Ue = () => {
      if (!N.value)
        return;
      const oe = W.value, ge = [], Se = [];
      if (oe.forEach((yt) => Se.push(xe(yt))), C.value = Se, oe.length) {
        oe.slice(0, r.maxCollapseTags).forEach((Tr) => ge.push(xe(Tr)));
        const yt = oe.slice(r.maxCollapseTags), Fn = yt.length;
        Fn && (r.collapseTags ? ge.push({
          key: -1,
          text: `+ ${Fn}`,
          closable: !1,
          isCollapseTag: !0
        }) : yt.forEach((Tr) => ge.push(xe(Tr))));
      }
      _.value = ge;
    }, Rt = () => {
      var oe, ge;
      const { filterMethod: Se, showAllLevels: yt, separator: Fn } = r, Tr = (ge = (oe = v.value) == null ? void 0 : oe.getFlattedNodes(!r.props.checkStrictly)) == null ? void 0 : ge.filter((ir) => ir.isDisabled ? !1 : (ir.calcText(yt, Fn), Se(ir, F.value)));
      N.value && (_.value.forEach((ir) => {
        ir.hitState = !1;
      }), C.value.forEach((ir) => {
        ir.hitState = !1;
      })), O.value = !0, A.value = Tr, te();
    }, zt = () => {
      var oe;
      let ge;
      O.value && m.value ? ge = m.value.$el.querySelector(`.${l.e("suggestion-item")}`) : ge = (oe = v.value) == null ? void 0 : oe.$el.querySelector(`.${l.b("node")}[tabindex="-1"]`), ge && (ge.focus(), !O.value && ge.click());
    }, tn = () => {
      var oe, ge;
      const Se = (oe = p.value) == null ? void 0 : oe.input, yt = g.value, Fn = (ge = m.value) == null ? void 0 : ge.$el;
      if (!(!qt || !Se)) {
        if (Fn) {
          const Tr = Fn.querySelector(`.${l.e("suggestion-list")}`);
          Tr.style.minWidth = `${Se.offsetWidth}px`;
        }
        if (yt) {
          const { offsetHeight: Tr } = yt, ir = _.value.length > 0 ? `${Math.max(Tr + 6, a)}px` : `${a}px`;
          Se.style.height = ir, te();
        }
      }
    }, jn = (oe) => {
      var ge;
      return (ge = v.value) == null ? void 0 : ge.getCheckedNodes(oe);
    }, An = (oe) => {
      te(), t("expandChange", oe);
    }, Tn = (oe) => {
      var ge;
      const Se = (ge = oe.target) == null ? void 0 : ge.value;
      if (oe.type === "compositionend")
        k.value = !1, Ke(() => Ge(Se));
      else {
        const yt = Se[Se.length - 1] || "";
        k.value = !OL(yt);
      }
    }, Un = (oe) => {
      if (!k.value)
        switch (oe.code) {
          case Ft.enter:
            ye();
            break;
          case Ft.down:
            ye(!0), Ke(zt), oe.preventDefault();
            break;
          case Ft.esc:
            y.value === !0 && (oe.preventDefault(), oe.stopPropagation(), ye(!1));
            break;
          case Ft.tab:
            ye(!1);
            break;
        }
    }, Vi = () => {
      var oe;
      (oe = v.value) == null || oe.clearCheckedNodes(), !y.value && r.filterable && Jr(), ye(!1);
    }, Jr = () => {
      const { value: oe } = Y;
      x.value = oe, S.value = oe;
    }, _i = (oe) => {
      var ge, Se;
      const { checked: yt } = oe;
      N.value ? (ge = v.value) == null || ge.handleCheckChange(oe, !yt, !1) : (!yt && ((Se = v.value) == null || Se.handleCheckChange(oe, !0, !1)), ye(!1));
    }, Oe = (oe) => {
      const ge = oe.target, { code: Se } = oe;
      switch (Se) {
        case Ft.up:
        case Ft.down: {
          const yt = Se === Ft.up ? -1 : 1;
          tw(i7(ge, yt, `.${l.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case Ft.enter:
          ge.click();
          break;
      }
    }, xt = () => {
      const oe = _.value, ge = oe[oe.length - 1];
      s = S.value ? 0 : s + 1, !(!ge || !s || r.collapseTags && oe.length > 1) && (ge.hitState ? dt(ge) : ge.hitState = !0);
    }, wn = (oe) => {
      const ge = oe.target, Se = l.e("search-input");
      ge.className === Se && (w.value = !0), t("focus", oe);
    }, oo = (oe) => {
      w.value = !1, t("blur", oe);
    }, Eu = kc(() => {
      const { value: oe } = F;
      if (!oe)
        return;
      const ge = r.beforeFilter(oe);
      rP(ge) ? ge.then(Rt).catch(() => {
      }) : ge !== !1 ? Rt() : ue();
    }, r.debounce), Ge = (oe, ge) => {
      !y.value && ye(!0), !(ge != null && ge.isComposing) && (oe ? Eu() : ue());
    }, at = (oe) => Number.parseFloat(zge(u.cssVarName("input-height"), oe).value) - 2;
    return he(O, te), he([W, L], Ue), he(_, () => {
      Ke(() => tn());
    }), he(M, async () => {
      await Ke();
      const oe = p.value.input;
      a = at(oe) || a, tn();
    }), he(Y, Jr, { immediate: !0 }), ht(() => {
      const oe = p.value.input, ge = at(oe);
      a = oe.offsetHeight || ge, Ei(oe, tn);
    }), e({
      getCheckedNodes: jn,
      cascaderPanelRef: v,
      togglePopperVisible: ye,
      contentRef: ne
    }), (oe, ge) => (V(), ve(T(Uf), {
      ref_key: "tooltipRef",
      ref: d,
      visible: y.value,
      teleported: oe.teleported,
      "popper-class": [T(l).e("dropdown"), oe.popperClass],
      "popper-options": i,
      "fallback-placements": [
        "bottom-start",
        "bottom",
        "top-start",
        "top",
        "right",
        "left"
      ],
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      placement: "bottom-start",
      transition: `${T(l).namespace.value}-zoom-in-top`,
      effect: "light",
      pure: "",
      persistent: "",
      onHide: ue
    }, {
      default: fe(() => [
        At((V(), q("div", {
          class: Q(T(ie)),
          style: vt(T(P)),
          onClick: ge[5] || (ge[5] = () => ye(T($) ? void 0 : !0)),
          onKeydown: Un,
          onMouseenter: ge[6] || (ge[6] = (Se) => b.value = !0),
          onMouseleave: ge[7] || (ge[7] = (Se) => b.value = !1)
        }, [
          de(T(Td), {
            ref_key: "input",
            ref: p,
            modelValue: x.value,
            "onUpdate:modelValue": ge[1] || (ge[1] = (Se) => x.value = Se),
            placeholder: T(E),
            readonly: T($),
            disabled: T(L),
            "validate-event": !1,
            size: T(M),
            class: Q(T(ee)),
            tabindex: T(N) && oe.filterable && !T(L) ? -1 : void 0,
            onCompositionstart: Tn,
            onCompositionupdate: Tn,
            onCompositionend: Tn,
            onFocus: wn,
            onBlur: oo,
            onInput: Ge
          }, {
            suffix: fe(() => [
              T(j) ? (V(), ve(T(bt), {
                key: "clear",
                class: Q([T(u).e("icon"), "icon-circle-close"]),
                onClick: kt(Vi, ["stop"])
              }, {
                default: fe(() => [
                  de(T(gb))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (V(), ve(T(bt), {
                key: "arrow-down",
                class: Q(T(ae)),
                onClick: ge[0] || (ge[0] = kt((Se) => ye(), ["stop"]))
              }, {
                default: fe(() => [
                  de(T(pb))
                ]),
                _: 1
              }, 8, ["class"]))
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]),
          T(N) ? (V(), q("div", {
            key: 0,
            ref_key: "tagWrapper",
            ref: g,
            class: Q(T(l).e("tags"))
          }, [
            (V(!0), q(yn, null, qi(_.value, (Se) => (V(), ve(T(_P), {
              key: Se.key,
              type: oe.tagType,
              size: T(R),
              hit: Se.hitState,
              closable: Se.closable,
              "disable-transitions": "",
              onClose: (yt) => dt(Se)
            }, {
              default: fe(() => [
                Se.isCollapseTag === !1 ? (V(), q("span", F1e, ze(Se.text), 1)) : (V(), ve(T(Uf), {
                  key: 1,
                  disabled: y.value || !oe.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: fe(() => [
                    J("span", null, ze(Se.text), 1)
                  ]),
                  content: fe(() => [
                    J("div", {
                      class: Q(T(l).e("collapse-tags"))
                    }, [
                      (V(!0), q(yn, null, qi(C.value.slice(oe.maxCollapseTags), (yt, Fn) => (V(), q("div", {
                        key: Fn,
                        class: Q(T(l).e("collapse-tag"))
                      }, [
                        (V(), ve(T(_P), {
                          key: yt.key,
                          class: "in-tooltip",
                          type: oe.tagType,
                          size: T(R),
                          hit: yt.hitState,
                          closable: yt.closable,
                          "disable-transitions": "",
                          onClose: (Tr) => dt(yt)
                        }, {
                          default: fe(() => [
                            J("span", null, ze(yt.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)),
            oe.filterable && !T(L) ? At((V(), q("input", {
              key: 0,
              "onUpdate:modelValue": ge[2] || (ge[2] = (Se) => S.value = Se),
              type: "text",
              class: Q(T(l).e("search-input")),
              placeholder: T(Y) ? "" : T(D),
              onInput: ge[3] || (ge[3] = (Se) => Ge(S.value, Se)),
              onClick: ge[4] || (ge[4] = kt((Se) => ye(!0), ["stop"])),
              onKeydown: Rr(xt, ["delete"]),
              onCompositionstart: Tn,
              onCompositionupdate: Tn,
              onCompositionend: Tn,
              onFocus: wn,
              onBlur: oo
            }, null, 42, Q1e)), [
              [LG, S.value]
            ]) : pe("v-if", !0)
          ], 2)) : pe("v-if", !0)
        ], 38)), [
          [T(S_), () => ye(!1), T(ne)]
        ])
      ]),
      content: fe(() => [
        At(de(T(I1e), {
          ref_key: "cascaderPanelRef",
          ref: v,
          modelValue: T(X),
          "onUpdate:modelValue": ge[8] || (ge[8] = (Se) => So(X) ? X.value = Se : null),
          options: oe.options,
          props: r.props,
          border: !1,
          "render-label": oe.$slots.default,
          onExpandChange: An,
          onClose: ge[9] || (ge[9] = (Se) => oe.$nextTick(() => ye(!1)))
        }, null, 8, ["modelValue", "options", "props", "render-label"]), [
          [On, !O.value]
        ]),
        oe.filterable ? At((V(), ve(T(Ob), {
          key: 0,
          ref_key: "suggestionPanel",
          ref: m,
          tag: "ul",
          class: Q(T(l).e("suggestion-panel")),
          "view-class": T(l).e("suggestion-list"),
          onKeydown: Oe
        }, {
          default: fe(() => [
            A.value.length ? (V(!0), q(yn, { key: 0 }, qi(A.value, (Se) => (V(), q("li", {
              key: Se.uid,
              class: Q([
                T(l).e("suggestion-item"),
                T(l).is("checked", Se.checked)
              ]),
              tabindex: -1,
              onClick: (yt) => _i(Se)
            }, [
              J("span", null, ze(Se.text), 1),
              Se.checked ? (V(), ve(T(bt), { key: 0 }, {
                default: fe(() => [
                  de(T(mL))
                ]),
                _: 1
              })) : pe("v-if", !0)
            ], 10, Z1e))), 128)) : ke(oe.$slots, "empty", { key: 1 }, () => [
              J("li", {
                class: Q(T(l).e("empty-text"))
              }, ze(T(c)("el.cascader.noMatch")), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [On, O.value]
        ]) : pe("v-if", !0)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "transition"]));
  }
});
var hw = /* @__PURE__ */ Ve(j1e, [["__file", "cascader.vue"]]);
hw.install = (n) => {
  n.component(hw.name, hw);
};
const H1e = hw, t6t = H1e, AB = (n) => _t(n) || Ut(n) || _n(n), q1e = Ye({
  accordion: Boolean,
  modelValue: {
    type: Ae([Array, String, Number]),
    default: () => ih([])
  }
}), Y1e = {
  [Dt]: AB,
  [yi]: AB
}, xH = Symbol("collapseContextKey"), X1e = (n, e) => {
  const t = z(Yy(n.modelValue)), r = (o) => {
    t.value = o;
    const a = n.accordion ? t.value[0] : t.value;
    e(Dt, a), e(yi, a);
  }, i = (o) => {
    if (n.accordion)
      r([t.value[0] === o ? "" : o]);
    else {
      const a = [...t.value], s = a.indexOf(o);
      s > -1 ? a.splice(s, 1) : a.push(o), r(a);
    }
  };
  return he(() => n.modelValue, () => t.value = Yy(n.modelValue), { deep: !0 }), Wt(xH, {
    activeNames: t,
    handleItemClick: i
  }), {
    activeNames: t,
    setActiveNames: r
  };
}, U1e = () => {
  const n = Pe("collapse");
  return {
    rootKls: B(() => n.b())
  };
}, K1e = U({
  name: "ElCollapse"
}), J1e = /* @__PURE__ */ U({
  ...K1e,
  props: q1e,
  emits: Y1e,
  setup(n, { expose: e, emit: t }) {
    const r = n, { activeNames: i, setActiveNames: o } = X1e(r, t), { rootKls: a } = U1e();
    return e({
      activeNames: i,
      setActiveNames: o
    }), (s, l) => (V(), q("div", {
      class: Q(T(a))
    }, [
      ke(s.$slots, "default")
    ], 2));
  }
});
var eOe = /* @__PURE__ */ Ve(J1e, [["__file", "collapse.vue"]]);
const tOe = U({
  name: "ElCollapseTransition"
}), nOe = /* @__PURE__ */ U({
  ...tOe,
  setup(n) {
    const e = Pe("collapse-transition"), t = (i) => {
      i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom;
    }, r = {
      beforeEnter(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.style.height && (i.dataset.elExistsHeight = i.style.height), i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0;
      },
      enter(i) {
        requestAnimationFrame(() => {
          i.dataset.oldOverflow = i.style.overflow, i.dataset.elExistsHeight ? i.style.maxHeight = i.dataset.elExistsHeight : i.scrollHeight !== 0 ? i.style.maxHeight = `${i.scrollHeight}px` : i.style.maxHeight = 0, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom, i.style.overflow = "hidden";
        });
      },
      afterEnter(i) {
        i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow;
      },
      enterCancelled(i) {
        t(i);
      },
      beforeLeave(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.dataset.oldOverflow = i.style.overflow, i.style.maxHeight = `${i.scrollHeight}px`, i.style.overflow = "hidden";
      },
      leave(i) {
        i.scrollHeight !== 0 && (i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0);
      },
      afterLeave(i) {
        t(i);
      },
      leaveCancelled(i) {
        t(i);
      }
    };
    return (i, o) => (V(), ve(kl, xa({
      name: T(e).b()
    }, sae(r)), {
      default: fe(() => [
        ke(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var fw = /* @__PURE__ */ Ve(nOe, [["__file", "collapse-transition.vue"]]);
fw.install = (n) => {
  n.component(fw.name, fw);
};
const SH = fw, rOe = Ye({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: Ae([String, Number]),
    default: void 0
  },
  disabled: Boolean
}), iOe = (n) => {
  const e = Re(xH), { namespace: t } = Pe("collapse"), r = z(!1), i = z(!1), o = ML(), a = B(() => o.current++), s = B(() => {
    var f;
    return (f = n.name) != null ? f : `${t.value}-id-${o.prefix}-${T(a)}`;
  }), l = B(() => e == null ? void 0 : e.activeNames.value.includes(T(s)));
  return {
    focusing: r,
    id: a,
    isActive: l,
    handleFocus: () => {
      setTimeout(() => {
        i.value ? i.value = !1 : r.value = !0;
      }, 50);
    },
    handleHeaderClick: () => {
      n.disabled || (e == null || e.handleItemClick(T(s)), r.value = !1, i.value = !0);
    },
    handleEnterClick: () => {
      e == null || e.handleItemClick(T(s));
    }
  };
}, oOe = (n, { focusing: e, isActive: t, id: r }) => {
  const i = Pe("collapse"), o = B(() => [
    i.b("item"),
    i.is("active", T(t)),
    i.is("disabled", n.disabled)
  ]), a = B(() => [
    i.be("item", "header"),
    i.is("active", T(t)),
    { focusing: T(e) && !n.disabled }
  ]), s = B(() => [
    i.be("item", "arrow"),
    i.is("active", T(t))
  ]), l = B(() => i.be("item", "wrap")), u = B(() => i.be("item", "content")), c = B(() => i.b(`content-${T(r)}`)), h = B(() => i.b(`head-${T(r)}`));
  return {
    arrowKls: s,
    headKls: a,
    rootKls: o,
    itemWrapperKls: l,
    itemContentKls: u,
    scopedContentId: c,
    scopedHeadId: h
  };
}, aOe = ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex"], sOe = ["id", "aria-hidden", "aria-labelledby"], lOe = U({
  name: "ElCollapseItem"
}), uOe = /* @__PURE__ */ U({
  ...lOe,
  props: rOe,
  setup(n, { expose: e }) {
    const t = n, {
      focusing: r,
      id: i,
      isActive: o,
      handleFocus: a,
      handleHeaderClick: s,
      handleEnterClick: l
    } = iOe(t), {
      arrowKls: u,
      headKls: c,
      rootKls: h,
      itemWrapperKls: f,
      itemContentKls: d,
      scopedContentId: p,
      scopedHeadId: g
    } = oOe(t, { focusing: r, isActive: o, id: i });
    return e({
      isActive: o
    }), (v, m) => (V(), q("div", {
      class: Q(T(h))
    }, [
      J("button", {
        id: T(g),
        class: Q(T(c)),
        "aria-expanded": T(o),
        "aria-controls": T(p),
        "aria-describedby": T(p),
        tabindex: v.disabled ? -1 : 0,
        type: "button",
        onClick: m[0] || (m[0] = (...y) => T(s) && T(s)(...y)),
        onKeydown: m[1] || (m[1] = Rr(kt((...y) => T(l) && T(l)(...y), ["stop", "prevent"]), ["space", "enter"])),
        onFocus: m[2] || (m[2] = (...y) => T(a) && T(a)(...y)),
        onBlur: m[3] || (m[3] = (y) => r.value = !1)
      }, [
        ke(v.$slots, "title", {}, () => [
          Ri(ze(v.title), 1)
        ]),
        de(T(bt), {
          class: Q(T(u))
        }, {
          default: fe(() => [
            de(T(Sd))
          ]),
          _: 1
        }, 8, ["class"])
      ], 42, aOe),
      de(T(SH), null, {
        default: fe(() => [
          At(J("div", {
            id: T(p),
            role: "region",
            class: Q(T(f)),
            "aria-hidden": !T(o),
            "aria-labelledby": T(g)
          }, [
            J("div", {
              class: Q(T(d))
            }, [
              ke(v.$slots, "default")
            ], 2)
          ], 10, sOe), [
            [On, T(o)]
          ])
        ]),
        _: 3
      })
    ], 2));
  }
});
var _H = /* @__PURE__ */ Ve(uOe, [["__file", "collapse-item.vue"]]);
const n6t = zn(eOe, {
  CollapseItem: _H
}), r6t = Os(_H), cOe = Ye({
  color: {
    type: Ae(Object),
    required: !0
  },
  vertical: {
    type: Boolean,
    default: !1
  }
});
let g2 = !1;
function n0(n, e) {
  if (!qt)
    return;
  const t = function(o) {
    var a;
    (a = e.drag) == null || a.call(e, o);
  }, r = function(o) {
    var a;
    document.removeEventListener("mousemove", t), document.removeEventListener("mouseup", r), document.removeEventListener("touchmove", t), document.removeEventListener("touchend", r), document.onselectstart = null, document.ondragstart = null, g2 = !1, (a = e.end) == null || a.call(e, o);
  }, i = function(o) {
    var a;
    g2 || (o.preventDefault(), document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", t), document.addEventListener("mouseup", r), document.addEventListener("touchmove", t), document.addEventListener("touchend", r), g2 = !0, (a = e.start) == null || a.call(e, o));
  };
  n.addEventListener("mousedown", i), n.addEventListener("touchstart", i);
}
const hOe = (n) => {
  const e = wt(), t = di(), r = di();
  function i(a) {
    a.target !== t.value && o(a);
  }
  function o(a) {
    if (!r.value || !t.value)
      return;
    const l = e.vnode.el.getBoundingClientRect(), { clientX: u, clientY: c } = bL(a);
    if (n.vertical) {
      let h = c - l.top;
      h = Math.max(t.value.offsetHeight / 2, h), h = Math.min(h, l.height - t.value.offsetHeight / 2), n.color.set("alpha", Math.round((h - t.value.offsetHeight / 2) / (l.height - t.value.offsetHeight) * 100));
    } else {
      let h = u - l.left;
      h = Math.max(t.value.offsetWidth / 2, h), h = Math.min(h, l.width - t.value.offsetWidth / 2), n.color.set("alpha", Math.round((h - t.value.offsetWidth / 2) / (l.width - t.value.offsetWidth) * 100));
    }
  }
  return {
    thumb: t,
    bar: r,
    handleDrag: o,
    handleClick: i
  };
}, fOe = (n, {
  bar: e,
  thumb: t,
  handleDrag: r
}) => {
  const i = wt(), o = Pe("color-alpha-slider"), a = z(0), s = z(0), l = z();
  function u() {
    if (!t.value || n.vertical)
      return 0;
    const y = i.vnode.el, b = n.color.get("alpha");
    return y ? Math.round(b * (y.offsetWidth - t.value.offsetWidth / 2) / 100) : 0;
  }
  function c() {
    if (!t.value)
      return 0;
    const y = i.vnode.el;
    if (!n.vertical)
      return 0;
    const b = n.color.get("alpha");
    return y ? Math.round(b * (y.offsetHeight - t.value.offsetHeight / 2) / 100) : 0;
  }
  function h() {
    if (n.color && n.color.value) {
      const { r: y, g: b, b: O } = n.color.toRgb();
      return `linear-gradient(to right, rgba(${y}, ${b}, ${O}, 0) 0%, rgba(${y}, ${b}, ${O}, 1) 100%)`;
    }
    return "";
  }
  function f() {
    a.value = u(), s.value = c(), l.value = h();
  }
  ht(() => {
    if (!e.value || !t.value)
      return;
    const y = {
      drag: (b) => {
        r(b);
      },
      end: (b) => {
        r(b);
      }
    };
    n0(e.value, y), n0(t.value, y), f();
  }), he(() => n.color.get("alpha"), () => f()), he(() => n.color.value, () => f());
  const d = B(() => [o.b(), o.is("vertical", n.vertical)]), p = B(() => o.e("bar")), g = B(() => o.e("thumb")), v = B(() => ({ background: l.value })), m = B(() => ({
    left: Xo(a.value),
    top: Xo(s.value)
  }));
  return { rootKls: d, barKls: p, barStyle: v, thumbKls: g, thumbStyle: m, update: f };
}, dOe = "ElColorAlphaSlider", pOe = U({
  name: dOe
}), gOe = /* @__PURE__ */ U({
  ...pOe,
  props: cOe,
  setup(n, { expose: e }) {
    const t = n, { bar: r, thumb: i, handleDrag: o, handleClick: a } = hOe(t), { rootKls: s, barKls: l, barStyle: u, thumbKls: c, thumbStyle: h, update: f } = fOe(t, {
      bar: r,
      thumb: i,
      handleDrag: o
    });
    return e({
      update: f,
      bar: r,
      thumb: i
    }), (d, p) => (V(), q("div", {
      class: Q(T(s))
    }, [
      J("div", {
        ref_key: "bar",
        ref: r,
        class: Q(T(l)),
        style: vt(T(u)),
        onClick: p[0] || (p[0] = (...g) => T(a) && T(a)(...g))
      }, null, 6),
      J("div", {
        ref_key: "thumb",
        ref: i,
        class: Q(T(c)),
        style: vt(T(h))
      }, null, 6)
    ], 2));
  }
});
var vOe = /* @__PURE__ */ Ve(gOe, [["__file", "alpha-slider.vue"]]);
const mOe = U({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: !0
    },
    vertical: Boolean
  },
  setup(n) {
    const e = Pe("color-hue-slider"), t = wt(), r = z(), i = z(), o = z(0), a = z(0), s = B(() => n.color.get("hue"));
    he(() => s.value, () => {
      f();
    });
    function l(d) {
      d.target !== r.value && u(d);
    }
    function u(d) {
      if (!i.value || !r.value)
        return;
      const g = t.vnode.el.getBoundingClientRect(), { clientX: v, clientY: m } = bL(d);
      let y;
      if (n.vertical) {
        let b = m - g.top;
        b = Math.min(b, g.height - r.value.offsetHeight / 2), b = Math.max(r.value.offsetHeight / 2, b), y = Math.round((b - r.value.offsetHeight / 2) / (g.height - r.value.offsetHeight) * 360);
      } else {
        let b = v - g.left;
        b = Math.min(b, g.width - r.value.offsetWidth / 2), b = Math.max(r.value.offsetWidth / 2, b), y = Math.round((b - r.value.offsetWidth / 2) / (g.width - r.value.offsetWidth) * 360);
      }
      n.color.set("hue", y);
    }
    function c() {
      if (!r.value)
        return 0;
      const d = t.vnode.el;
      if (n.vertical)
        return 0;
      const p = n.color.get("hue");
      return d ? Math.round(p * (d.offsetWidth - r.value.offsetWidth / 2) / 360) : 0;
    }
    function h() {
      if (!r.value)
        return 0;
      const d = t.vnode.el;
      if (!n.vertical)
        return 0;
      const p = n.color.get("hue");
      return d ? Math.round(p * (d.offsetHeight - r.value.offsetHeight / 2) / 360) : 0;
    }
    function f() {
      o.value = c(), a.value = h();
    }
    return ht(() => {
      if (!i.value || !r.value)
        return;
      const d = {
        drag: (p) => {
          u(p);
        },
        end: (p) => {
          u(p);
        }
      };
      n0(i.value, d), n0(r.value, d), f();
    }), {
      bar: i,
      thumb: r,
      thumbLeft: o,
      thumbTop: a,
      hueValue: s,
      handleClick: l,
      update: f,
      ns: e
    };
  }
});
function yOe(n, e, t, r, i, o) {
  return V(), q("div", {
    class: Q([n.ns.b(), n.ns.is("vertical", n.vertical)])
  }, [
    J("div", {
      ref: "bar",
      class: Q(n.ns.e("bar")),
      onClick: e[0] || (e[0] = (...a) => n.handleClick && n.handleClick(...a))
    }, null, 2),
    J("div", {
      ref: "thumb",
      class: Q(n.ns.e("thumb")),
      style: vt({
        left: n.thumbLeft + "px",
        top: n.thumbTop + "px"
      })
    }, null, 6)
  ], 2);
}
var bOe = /* @__PURE__ */ Ve(mOe, [["render", yOe], ["__file", "hue-slider.vue"]]);
const OOe = Ye({
  modelValue: String,
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  size: Ra,
  popperClass: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  predefine: {
    type: Ae(Array)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), wOe = {
  [Dt]: (n) => Ut(n) || _o(n),
  [yi]: (n) => Ut(n) || _o(n),
  activeChange: (n) => Ut(n) || _o(n),
  focus: (n) => n instanceof FocusEvent,
  blur: (n) => n instanceof FocusEvent
}, CH = Symbol("colorPickerContextKey"), TB = function(n, e, t) {
  return [
    n,
    e * t / ((n = (2 - e) * t) < 1 ? n : 2 - n) || 0,
    n / 2
  ];
}, xOe = function(n) {
  return typeof n == "string" && n.includes(".") && Number.parseFloat(n) === 1;
}, SOe = function(n) {
  return typeof n == "string" && n.includes("%");
}, Vp = function(n, e) {
  xOe(n) && (n = "100%");
  const t = SOe(n);
  return n = Math.min(e, Math.max(0, Number.parseFloat(`${n}`))), t && (n = Number.parseInt(`${n * e}`, 10) / 100), Math.abs(n - e) < 1e-6 ? 1 : n % e / Number.parseFloat(e);
}, kB = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F"
}, dw = (n) => {
  n = Math.min(Math.round(n), 255);
  const e = Math.floor(n / 16), t = n % 16;
  return `${kB[e] || e}${kB[t] || t}`;
}, PB = function({ r: n, g: e, b: t }) {
  return Number.isNaN(+n) || Number.isNaN(+e) || Number.isNaN(+t) ? "" : `#${dw(n)}${dw(e)}${dw(t)}`;
}, v2 = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, mh = function(n) {
  return n.length === 2 ? (v2[n[0].toUpperCase()] || +n[0]) * 16 + (v2[n[1].toUpperCase()] || +n[1]) : v2[n[1].toUpperCase()] || +n[1];
}, _Oe = function(n, e, t) {
  e = e / 100, t = t / 100;
  let r = e;
  const i = Math.max(t, 0.01);
  t *= 2, e *= t <= 1 ? t : 2 - t, r *= i <= 1 ? i : 2 - i;
  const o = (t + e) / 2, a = t === 0 ? 2 * r / (i + r) : 2 * e / (t + e);
  return {
    h: n,
    s: a * 100,
    v: o * 100
  };
}, EB = (n, e, t) => {
  n = Vp(n, 255), e = Vp(e, 255), t = Vp(t, 255);
  const r = Math.max(n, e, t), i = Math.min(n, e, t);
  let o;
  const a = r, s = r - i, l = r === 0 ? 0 : s / r;
  if (r === i)
    o = 0;
  else {
    switch (r) {
      case n: {
        o = (e - t) / s + (e < t ? 6 : 0);
        break;
      }
      case e: {
        o = (t - n) / s + 2;
        break;
      }
      case t: {
        o = (n - e) / s + 4;
        break;
      }
    }
    o /= 6;
  }
  return { h: o * 360, s: l * 100, v: a * 100 };
}, Yv = function(n, e, t) {
  n = Vp(n, 360) * 6, e = Vp(e, 100), t = Vp(t, 100);
  const r = Math.floor(n), i = n - r, o = t * (1 - e), a = t * (1 - i * e), s = t * (1 - (1 - i) * e), l = r % 6, u = [t, a, o, o, s, t][l], c = [s, t, t, a, o, o][l], h = [o, o, s, t, t, a][l];
  return {
    r: Math.round(u * 255),
    g: Math.round(c * 255),
    b: Math.round(h * 255)
  };
};
let fy = class {
  constructor(e = {}) {
    this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this.enableAlpha = !1, this.format = "hex", this.value = "";
    for (const t in e)
      To(e, t) && (this[t] = e[t]);
    e.value ? this.fromString(e.value) : this.doOnChange();
  }
  set(e, t) {
    if (arguments.length === 1 && typeof e == "object") {
      for (const r in e)
        To(e, r) && this.set(r, e[r]);
      return;
    }
    this[`_${e}`] = t, this.doOnChange();
  }
  get(e) {
    return e === "alpha" ? Math.floor(this[`_${e}`]) : this[`_${e}`];
  }
  toRgb() {
    return Yv(this._hue, this._saturation, this._value);
  }
  fromString(e) {
    if (!e) {
      this._hue = 0, this._saturation = 100, this._value = 100, this.doOnChange();
      return;
    }
    const t = (r, i, o) => {
      this._hue = Math.max(0, Math.min(360, r)), this._saturation = Math.max(0, Math.min(100, i)), this._value = Math.max(0, Math.min(100, o)), this.doOnChange();
    };
    if (e.includes("hsl")) {
      const r = e.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((i) => i !== "").map((i, o) => o > 2 ? Number.parseFloat(i) : Number.parseInt(i, 10));
      if (r.length === 4 ? this._alpha = Number.parseFloat(r[3]) * 100 : r.length === 3 && (this._alpha = 100), r.length >= 3) {
        const { h: i, s: o, v: a } = _Oe(r[0], r[1], r[2]);
        t(i, o, a);
      }
    } else if (e.includes("hsv")) {
      const r = e.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((i) => i !== "").map((i, o) => o > 2 ? Number.parseFloat(i) : Number.parseInt(i, 10));
      r.length === 4 ? this._alpha = Number.parseFloat(r[3]) * 100 : r.length === 3 && (this._alpha = 100), r.length >= 3 && t(r[0], r[1], r[2]);
    } else if (e.includes("rgb")) {
      const r = e.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((i) => i !== "").map((i, o) => o > 2 ? Number.parseFloat(i) : Number.parseInt(i, 10));
      if (r.length === 4 ? this._alpha = Number.parseFloat(r[3]) * 100 : r.length === 3 && (this._alpha = 100), r.length >= 3) {
        const { h: i, s: o, v: a } = EB(r[0], r[1], r[2]);
        t(i, o, a);
      }
    } else if (e.includes("#")) {
      const r = e.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(r))
        return;
      let i, o, a;
      r.length === 3 ? (i = mh(r[0] + r[0]), o = mh(r[1] + r[1]), a = mh(r[2] + r[2])) : (r.length === 6 || r.length === 8) && (i = mh(r.slice(0, 2)), o = mh(r.slice(2, 4)), a = mh(r.slice(4, 6))), r.length === 8 ? this._alpha = mh(r.slice(6)) / 255 * 100 : (r.length === 3 || r.length === 6) && (this._alpha = 100);
      const { h: s, s: l, v: u } = EB(i, o, a);
      t(s, l, u);
    }
  }
  compare(e) {
    return Math.abs(e._hue - this._hue) < 2 && Math.abs(e._saturation - this._saturation) < 1 && Math.abs(e._value - this._value) < 1 && Math.abs(e._alpha - this._alpha) < 1;
  }
  doOnChange() {
    const { _hue: e, _saturation: t, _value: r, _alpha: i, format: o } = this;
    if (this.enableAlpha)
      switch (o) {
        case "hsl": {
          const a = TB(e, t / 100, r / 100);
          this.value = `hsla(${e}, ${Math.round(a[1] * 100)}%, ${Math.round(a[2] * 100)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hsv": {
          this.value = `hsva(${e}, ${Math.round(t)}%, ${Math.round(r)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hex": {
          this.value = `${PB(Yv(e, t, r))}${dw(i * 255 / 100)}`;
          break;
        }
        default: {
          const { r: a, g: s, b: l } = Yv(e, t, r);
          this.value = `rgba(${a}, ${s}, ${l}, ${this.get("alpha") / 100})`;
        }
      }
    else
      switch (o) {
        case "hsl": {
          const a = TB(e, t / 100, r / 100);
          this.value = `hsl(${e}, ${Math.round(a[1] * 100)}%, ${Math.round(a[2] * 100)}%)`;
          break;
        }
        case "hsv": {
          this.value = `hsv(${e}, ${Math.round(t)}%, ${Math.round(r)}%)`;
          break;
        }
        case "rgb": {
          const { r: a, g: s, b: l } = Yv(e, t, r);
          this.value = `rgb(${a}, ${s}, ${l})`;
          break;
        }
        default:
          this.value = PB(Yv(e, t, r));
      }
  }
};
const COe = U({
  props: {
    colors: {
      type: Array,
      required: !0
    },
    color: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = Pe("color-predefine"), { currentColor: t } = Re(CH), r = z(o(n.colors, n.color));
    he(() => t.value, (a) => {
      const s = new fy();
      s.fromString(a), r.value.forEach((l) => {
        l.selected = s.compare(l);
      });
    }), sl(() => {
      r.value = o(n.colors, n.color);
    });
    function i(a) {
      n.color.fromString(n.colors[a]);
    }
    function o(a, s) {
      return a.map((l) => {
        const u = new fy();
        return u.enableAlpha = !0, u.format = "rgba", u.fromString(l), u.selected = u.value === s.value, u;
      });
    }
    return {
      rgbaColors: r,
      handleSelect: i,
      ns: e
    };
  }
}), AOe = ["onClick"];
function TOe(n, e, t, r, i, o) {
  return V(), q("div", {
    class: Q(n.ns.b())
  }, [
    J("div", {
      class: Q(n.ns.e("colors"))
    }, [
      (V(!0), q(yn, null, qi(n.rgbaColors, (a, s) => (V(), q("div", {
        key: n.colors[s],
        class: Q([
          n.ns.e("color-selector"),
          n.ns.is("alpha", a._alpha < 100),
          { selected: a.selected }
        ]),
        onClick: (l) => n.handleSelect(s)
      }, [
        J("div", {
          style: vt({ backgroundColor: a.value })
        }, null, 4)
      ], 10, AOe))), 128))
    ], 2)
  ], 2);
}
var kOe = /* @__PURE__ */ Ve(COe, [["render", TOe], ["__file", "predefine.vue"]]);
const POe = U({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = Pe("color-svpanel"), t = wt(), r = z(0), i = z(0), o = z("hsl(0, 100%, 50%)"), a = B(() => {
      const u = n.color.get("hue"), c = n.color.get("value");
      return { hue: u, value: c };
    });
    function s() {
      const u = n.color.get("saturation"), c = n.color.get("value"), h = t.vnode.el, { clientWidth: f, clientHeight: d } = h;
      i.value = u * f / 100, r.value = (100 - c) * d / 100, o.value = `hsl(${n.color.get("hue")}, 100%, 50%)`;
    }
    function l(u) {
      const h = t.vnode.el.getBoundingClientRect(), { clientX: f, clientY: d } = bL(u);
      let p = f - h.left, g = d - h.top;
      p = Math.max(0, p), p = Math.min(p, h.width), g = Math.max(0, g), g = Math.min(g, h.height), i.value = p, r.value = g, n.color.set({
        saturation: p / h.width * 100,
        value: 100 - g / h.height * 100
      });
    }
    return he(() => a.value, () => {
      s();
    }), ht(() => {
      n0(t.vnode.el, {
        drag: (u) => {
          l(u);
        },
        end: (u) => {
          l(u);
        }
      }), s();
    }), {
      cursorTop: r,
      cursorLeft: i,
      background: o,
      colorValue: a,
      handleDrag: l,
      update: s,
      ns: e
    };
  }
}), EOe = /* @__PURE__ */ J("div", null, null, -1), MOe = [
  EOe
];
function DOe(n, e, t, r, i, o) {
  return V(), q("div", {
    class: Q(n.ns.b()),
    style: vt({
      backgroundColor: n.background
    })
  }, [
    J("div", {
      class: Q(n.ns.e("white"))
    }, null, 2),
    J("div", {
      class: Q(n.ns.e("black"))
    }, null, 2),
    J("div", {
      class: Q(n.ns.e("cursor")),
      style: vt({
        top: n.cursorTop + "px",
        left: n.cursorLeft + "px"
      })
    }, MOe, 6)
  ], 6);
}
var LOe = /* @__PURE__ */ Ve(POe, [["render", DOe], ["__file", "sv-panel.vue"]]);
const IOe = ["onKeydown"], ROe = ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex"], NOe = U({
  name: "ElColorPicker"
}), $Oe = /* @__PURE__ */ U({
  ...NOe,
  props: OOe,
  emits: wOe,
  setup(n, { expose: e, emit: t }) {
    const r = n, { t: i } = Ar(), o = Pe("color"), { formItem: a } = Na(), s = ko(), l = ah(), { inputId: u, isLabeledByFormItem: c } = Ad(r, {
      formItemContext: a
    }), h = z(), f = z(), d = z(), p = z(), g = z(), v = z(), {
      isFocused: m,
      handleFocus: y,
      handleBlur: b
    } = LL(g, {
      beforeBlur(te) {
        var ue;
        return (ue = p.value) == null ? void 0 : ue.isFocusInsideContent(te);
      },
      afterBlur() {
        M(!1), F();
      }
    }), O = (te) => {
      if (l.value)
        return ye();
      y(te);
    };
    let w = !0;
    const x = dr(new fy({
      enableAlpha: r.showAlpha,
      format: r.colorFormat || "",
      value: r.modelValue
    })), S = z(!1), _ = z(!1), C = z(""), A = B(() => !r.modelValue && !_.value ? "transparent" : E(x, r.showAlpha)), k = B(() => !r.modelValue && !_.value ? "" : x.value), P = B(() => c.value ? void 0 : r.label || i("el.colorpicker.defaultLabel")), L = B(() => c.value ? a == null ? void 0 : a.labelId : void 0), D = B(() => [
      o.b("picker"),
      o.is("disabled", l.value),
      o.bm("picker", s.value),
      o.is("focused", m.value)
    ]);
    function E(te, ue) {
      if (!(te instanceof fy))
        throw new TypeError("color should be instance of _color Class");
      const { r: xe, g: dt, b: Ue } = te.toRgb();
      return ue ? `rgba(${xe}, ${dt}, ${Ue}, ${te.get("alpha") / 100})` : `rgb(${xe}, ${dt}, ${Ue})`;
    }
    function M(te) {
      S.value = te;
    }
    const R = kc(M, 100, { leading: !0 });
    function N() {
      l.value || M(!0);
    }
    function $() {
      R(!1), F();
    }
    function F() {
      Ke(() => {
        r.modelValue ? x.fromString(r.modelValue) : (x.value = "", Ke(() => {
          _.value = !1;
        }));
      });
    }
    function W() {
      l.value || R(!S.value);
    }
    function j() {
      x.fromString(C.value);
    }
    function Y() {
      const te = x.value;
      t(Dt, te), t("change", te), r.validateEvent && (a == null || a.validate("change").catch((ue) => Ht(ue))), R(!1), Ke(() => {
        const ue = new fy({
          enableAlpha: r.showAlpha,
          format: r.colorFormat || "",
          value: r.modelValue
        });
        x.compare(ue) || F();
      });
    }
    function X() {
      R(!1), t(Dt, null), t("change", null), r.modelValue !== null && r.validateEvent && (a == null || a.validate("change").catch((te) => Ht(te))), F();
    }
    function ie(te) {
      if (S.value && ($(), m.value)) {
        const ue = new FocusEvent("focus", te);
        b(ue);
      }
    }
    function ae(te) {
      te.preventDefault(), te.stopPropagation(), M(!1), F();
    }
    function ee(te) {
      switch (te.code) {
        case Ft.enter:
        case Ft.space:
          te.preventDefault(), te.stopPropagation(), N(), v.value.focus();
          break;
        case Ft.esc:
          ae(te);
          break;
      }
    }
    function ne() {
      g.value.focus();
    }
    function ye() {
      g.value.blur();
    }
    return ht(() => {
      r.modelValue && (C.value = k.value);
    }), he(() => r.modelValue, (te) => {
      te ? te && te !== x.value && (w = !1, x.fromString(te)) : _.value = !1;
    }), he(() => k.value, (te) => {
      C.value = te, w && t("activeChange", te), w = !0;
    }), he(() => x.value, () => {
      !r.modelValue && !_.value && (_.value = !0);
    }), he(() => S.value, () => {
      Ke(() => {
        var te, ue, xe;
        (te = h.value) == null || te.update(), (ue = f.value) == null || ue.update(), (xe = d.value) == null || xe.update();
      });
    }), Wt(CH, {
      currentColor: k
    }), e({
      color: x,
      show: N,
      hide: $,
      focus: ne,
      blur: ye
    }), (te, ue) => (V(), ve(T(Uf), {
      ref_key: "popper",
      ref: p,
      visible: S.value,
      "show-arrow": !1,
      "fallback-placements": ["bottom", "top", "right", "left"],
      offset: 0,
      "gpu-acceleration": !1,
      "popper-class": [T(o).be("picker", "panel"), T(o).b("dropdown"), te.popperClass],
      "stop-popper-mouse-event": !1,
      effect: "light",
      trigger: "click",
      transition: `${T(o).namespace.value}-zoom-in-top`,
      persistent: "",
      onHide: ue[2] || (ue[2] = (xe) => M(!1))
    }, {
      content: fe(() => [
        At((V(), q("div", {
          onKeydown: Rr(ae, ["esc"])
        }, [
          J("div", {
            class: Q(T(o).be("dropdown", "main-wrapper"))
          }, [
            de(bOe, {
              ref_key: "hue",
              ref: h,
              class: "hue-slider",
              color: T(x),
              vertical: ""
            }, null, 8, ["color"]),
            de(LOe, {
              ref_key: "sv",
              ref: f,
              color: T(x)
            }, null, 8, ["color"])
          ], 2),
          te.showAlpha ? (V(), ve(vOe, {
            key: 0,
            ref_key: "alpha",
            ref: d,
            color: T(x)
          }, null, 8, ["color"])) : pe("v-if", !0),
          te.predefine ? (V(), ve(kOe, {
            key: 1,
            ref: "predefine",
            color: T(x),
            colors: te.predefine
          }, null, 8, ["color", "colors"])) : pe("v-if", !0),
          J("div", {
            class: Q(T(o).be("dropdown", "btns"))
          }, [
            J("span", {
              class: Q(T(o).be("dropdown", "value"))
            }, [
              de(T(Td), {
                ref_key: "inputRef",
                ref: v,
                modelValue: C.value,
                "onUpdate:modelValue": ue[0] || (ue[0] = (xe) => C.value = xe),
                "validate-event": !1,
                size: "small",
                onKeyup: Rr(j, ["enter"]),
                onBlur: j
              }, null, 8, ["modelValue", "onKeyup"])
            ], 2),
            de(T(t0), {
              class: Q(T(o).be("dropdown", "link-btn")),
              text: "",
              size: "small",
              onClick: X
            }, {
              default: fe(() => [
                Ri(ze(T(i)("el.colorpicker.clear")), 1)
              ]),
              _: 1
            }, 8, ["class"]),
            de(T(t0), {
              plain: "",
              size: "small",
              class: Q(T(o).be("dropdown", "btn")),
              onClick: Y
            }, {
              default: fe(() => [
                Ri(ze(T(i)("el.colorpicker.confirm")), 1)
              ]),
              _: 1
            }, 8, ["class"])
          ], 2)
        ], 40, IOe)), [
          [T(S_), ie]
        ])
      ]),
      default: fe(() => [
        J("div", {
          id: T(u),
          ref_key: "triggerRef",
          ref: g,
          class: Q(T(D)),
          role: "button",
          "aria-label": T(P),
          "aria-labelledby": T(L),
          "aria-description": T(i)("el.colorpicker.description", { color: te.modelValue || "" }),
          "aria-disabled": T(l),
          tabindex: T(l) ? -1 : te.tabindex,
          onKeydown: ee,
          onFocus: O,
          onBlur: ue[1] || (ue[1] = (...xe) => T(b) && T(b)(...xe))
        }, [
          T(l) ? (V(), q("div", {
            key: 0,
            class: Q(T(o).be("picker", "mask"))
          }, null, 2)) : pe("v-if", !0),
          J("div", {
            class: Q(T(o).be("picker", "trigger")),
            onClick: W
          }, [
            J("span", {
              class: Q([T(o).be("picker", "color"), T(o).is("alpha", te.showAlpha)])
            }, [
              J("span", {
                class: Q(T(o).be("picker", "color-inner")),
                style: vt({
                  backgroundColor: T(A)
                })
              }, [
                At(de(T(bt), {
                  class: Q([T(o).be("picker", "icon"), T(o).is("icon-arrow-down")])
                }, {
                  default: fe(() => [
                    de(T(pb))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [On, te.modelValue || _.value]
                ]),
                At(de(T(bt), {
                  class: Q([T(o).be("picker", "empty"), T(o).is("icon-close")])
                }, {
                  default: fe(() => [
                    de(T(Pc))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [On, !te.modelValue && !_.value]
                ])
              ], 6)
            ], 2)
          ], 2)
        ], 42, ROe)
      ]),
      _: 1
    }, 8, ["visible", "popper-class", "transition"]));
  }
});
var BOe = /* @__PURE__ */ Ve($Oe, [["__file", "color-picker.vue"]]);
const o6t = zn(BOe), VOe = Ye({
  mask: {
    type: Boolean,
    default: !0
  },
  customMaskEvent: {
    type: Boolean,
    default: !1
  },
  overlayClass: {
    type: Ae([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: Ae([String, Number])
  }
}), zOe = {
  click: (n) => n instanceof MouseEvent
}, FOe = "overlay";
var QOe = U({
  name: "ElOverlay",
  props: VOe,
  emits: zOe,
  setup(n, { slots: e, emit: t }) {
    const r = Pe(FOe), i = (l) => {
      t("click", l);
    }, { onClick: o, onMousedown: a, onMouseup: s } = EL(n.customMaskEvent ? void 0 : i);
    return () => n.mask ? de("div", {
      class: [r.b(), n.overlayClass],
      style: {
        zIndex: n.zIndex
      },
      onClick: o,
      onMousedown: a,
      onMouseup: s
    }, [ke(e, "default")], rw.STYLE | rw.CLASS | rw.PROPS, ["onClick", "onMouseup", "onMousedown"]) : et("div", {
      class: n.overlayClass,
      style: {
        zIndex: n.zIndex,
        position: "fixed",
        top: "0px",
        right: "0px",
        bottom: "0px",
        left: "0px"
      }
    }, [ke(e, "default")]);
  }
});
const QL = QOe, AH = Symbol("dialogInjectionKey"), TH = Ye({
  center: Boolean,
  alignCenter: Boolean,
  closeIcon: {
    type: $r
  },
  draggable: Boolean,
  overflow: Boolean,
  fullscreen: Boolean,
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
}), ZOe = {
  close: () => !0
}, WOe = ["aria-level"], GOe = ["aria-label"], jOe = ["id"], HOe = U({ name: "ElDialogContent" }), qOe = /* @__PURE__ */ U({
  ...HOe,
  props: TH,
  emits: ZOe,
  setup(n) {
    const e = n, { t } = Ar(), { Close: r } = f7, { dialogRef: i, headerRef: o, bodyId: a, ns: s, style: l } = Re(AH), { focusTrapRef: u } = Re(U7), c = B(() => [
      s.b(),
      s.is("fullscreen", e.fullscreen),
      s.is("draggable", e.draggable),
      s.is("align-center", e.alignCenter),
      { [s.m("center")]: e.center }
    ]), h = mve(u, i), f = B(() => e.draggable), d = B(() => e.overflow);
    return m7(i, o, f, d), (p, g) => (V(), q("div", {
      ref: T(h),
      class: Q(T(c)),
      style: vt(T(l)),
      tabindex: "-1"
    }, [
      J("header", {
        ref_key: "headerRef",
        ref: o,
        class: Q([T(s).e("header"), { "show-close": p.showClose }])
      }, [
        ke(p.$slots, "header", {}, () => [
          J("span", {
            role: "heading",
            "aria-level": p.ariaLevel,
            class: Q(T(s).e("title"))
          }, ze(p.title), 11, WOe)
        ]),
        p.showClose ? (V(), q("button", {
          key: 0,
          "aria-label": T(t)("el.dialog.close"),
          class: Q(T(s).e("headerbtn")),
          type: "button",
          onClick: g[0] || (g[0] = (v) => p.$emit("close"))
        }, [
          de(T(bt), {
            class: Q(T(s).e("close"))
          }, {
            default: fe(() => [
              (V(), ve(cn(p.closeIcon || T(r))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, GOe)) : pe("v-if", !0)
      ], 2),
      J("div", {
        id: T(a),
        class: Q(T(s).e("body"))
      }, [
        ke(p.$slots, "default")
      ], 10, jOe),
      p.$slots.footer ? (V(), q("footer", {
        key: 0,
        class: Q(T(s).e("footer"))
      }, [
        ke(p.$slots, "footer")
      ], 2)) : pe("v-if", !0)
    ], 6));
  }
});
var YOe = /* @__PURE__ */ Ve(qOe, [["__file", "dialog-content.vue"]]);
const kH = Ye({
  ...TH,
  appendToBody: Boolean,
  appendTo: {
    type: Ae(String),
    default: "body"
  },
  beforeClose: {
    type: Ae(Function)
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  lockScroll: {
    type: Boolean,
    default: !0
  },
  modal: {
    type: Boolean,
    default: !0
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: !1
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), PH = {
  open: () => !0,
  opened: () => !0,
  close: () => !0,
  closed: () => !0,
  [Dt]: (n) => pi(n),
  openAutoFocus: () => !0,
  closeAutoFocus: () => !0
}, EH = (n, e) => {
  var t;
  const i = wt().emit, { nextZIndex: o } = DL();
  let a = "";
  const s = fs(), l = fs(), u = z(!1), c = z(!1), h = z(!1), f = z((t = n.zIndex) != null ? t : o());
  let d, p;
  const g = O_("namespace", uy), v = B(() => {
    const E = {}, M = `--${g.value}-dialog`;
    return n.fullscreen || (n.top && (E[`${M}-margin-top`] = n.top), n.width && (E[`${M}-width`] = Xo(n.width))), E;
  }), m = B(() => n.alignCenter ? { display: "flex" } : {});
  function y() {
    i("opened");
  }
  function b() {
    i("closed"), i(Dt, !1), n.destroyOnClose && (h.value = !1);
  }
  function O() {
    i("close");
  }
  function w() {
    p == null || p(), d == null || d(), n.openDelay && n.openDelay > 0 ? { stop: d } = hx(() => C(), n.openDelay) : C();
  }
  function x() {
    d == null || d(), p == null || p(), n.closeDelay && n.closeDelay > 0 ? { stop: p } = hx(() => A(), n.closeDelay) : A();
  }
  function S() {
    function E(M) {
      M || (c.value = !0, u.value = !1);
    }
    n.beforeClose ? n.beforeClose(E) : x();
  }
  function _() {
    n.closeOnClickModal && S();
  }
  function C() {
    qt && (u.value = !0);
  }
  function A() {
    u.value = !1;
  }
  function k() {
    i("openAutoFocus");
  }
  function P() {
    i("closeAutoFocus");
  }
  function L(E) {
    var M;
    ((M = E.detail) == null ? void 0 : M.focusReason) === "pointer" && E.preventDefault();
  }
  n.lockScroll && _7(u);
  function D() {
    n.closeOnPressEscape && S();
  }
  return he(() => n.modelValue, (E) => {
    E ? (c.value = !1, w(), h.value = !0, f.value = Fj(n.zIndex) ? o() : f.value++, Ke(() => {
      i("open"), e.value && (e.value.scrollTop = 0);
    })) : u.value && x();
  }), he(() => n.fullscreen, (E) => {
    e.value && (E ? (a = e.value.style.transform, e.value.style.transform = "") : e.value.style.transform = a);
  }), ht(() => {
    n.modelValue && (u.value = !0, h.value = !0, w());
  }), {
    afterEnter: y,
    afterLeave: b,
    beforeLeave: O,
    handleClose: S,
    onModalClick: _,
    close: x,
    doClose: A,
    onOpenAutoFocus: k,
    onCloseAutoFocus: P,
    onCloseRequested: D,
    onFocusoutPrevented: L,
    titleId: s,
    bodyId: l,
    closed: c,
    style: v,
    overlayDialogStyle: m,
    rendered: h,
    visible: u,
    zIndex: f
  };
}, XOe = ["aria-label", "aria-labelledby", "aria-describedby"], UOe = U({
  name: "ElDialog",
  inheritAttrs: !1
}), KOe = /* @__PURE__ */ U({
  ...UOe,
  props: kH,
  emits: PH,
  setup(n, { expose: e }) {
    const t = n, r = Tl();
    Xf({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, B(() => !!r.title));
    const i = Pe("dialog"), o = z(), a = z(), s = z(), {
      visible: l,
      titleId: u,
      bodyId: c,
      style: h,
      overlayDialogStyle: f,
      rendered: d,
      zIndex: p,
      afterEnter: g,
      afterLeave: v,
      beforeLeave: m,
      handleClose: y,
      onModalClick: b,
      onOpenAutoFocus: O,
      onCloseAutoFocus: w,
      onCloseRequested: x,
      onFocusoutPrevented: S
    } = EH(t, o);
    Wt(AH, {
      dialogRef: o,
      headerRef: a,
      bodyId: c,
      ns: i,
      rendered: d,
      style: h
    });
    const _ = EL(b), C = B(() => t.draggable && !t.fullscreen);
    return e({
      visible: l,
      dialogContentRef: s
    }), (A, k) => (V(), ve(a_, {
      to: A.appendTo,
      disabled: A.appendTo !== "body" ? !1 : !A.appendToBody
    }, [
      de(kl, {
        name: "dialog-fade",
        onAfterEnter: T(g),
        onAfterLeave: T(v),
        onBeforeLeave: T(m),
        persisted: ""
      }, {
        default: fe(() => [
          At(de(T(QL), {
            "custom-mask-event": "",
            mask: A.modal,
            "overlay-class": A.modalClass,
            "z-index": T(p)
          }, {
            default: fe(() => [
              J("div", {
                role: "dialog",
                "aria-modal": "true",
                "aria-label": A.title || void 0,
                "aria-labelledby": A.title ? void 0 : T(u),
                "aria-describedby": T(c),
                class: Q(`${T(i).namespace.value}-overlay-dialog`),
                style: vt(T(f)),
                onClick: k[0] || (k[0] = (...P) => T(_).onClick && T(_).onClick(...P)),
                onMousedown: k[1] || (k[1] = (...P) => T(_).onMousedown && T(_).onMousedown(...P)),
                onMouseup: k[2] || (k[2] = (...P) => T(_).onMouseup && T(_).onMouseup(...P))
              }, [
                de(T(x_), {
                  loop: "",
                  trapped: T(l),
                  "focus-start-el": "container",
                  onFocusAfterTrapped: T(O),
                  onFocusAfterReleased: T(w),
                  onFocusoutPrevented: T(S),
                  onReleaseRequested: T(x)
                }, {
                  default: fe(() => [
                    T(d) ? (V(), ve(YOe, xa({
                      key: 0,
                      ref_key: "dialogContentRef",
                      ref: s
                    }, A.$attrs, {
                      center: A.center,
                      "align-center": A.alignCenter,
                      "close-icon": A.closeIcon,
                      draggable: T(C),
                      overflow: A.overflow,
                      fullscreen: A.fullscreen,
                      "show-close": A.showClose,
                      title: A.title,
                      "aria-level": A.headerAriaLevel,
                      onClose: T(y)
                    }), lae({
                      header: fe(() => [
                        A.$slots.title ? ke(A.$slots, "title", { key: 1 }) : ke(A.$slots, "header", {
                          key: 0,
                          close: T(y),
                          titleId: T(u),
                          titleClass: T(i).e("title")
                        })
                      ]),
                      default: fe(() => [
                        ke(A.$slots, "default")
                      ]),
                      _: 2
                    }, [
                      A.$slots.footer ? {
                        name: "footer",
                        fn: fe(() => [
                          ke(A.$slots, "footer")
                        ])
                      } : void 0
                    ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : pe("v-if", !0)
                  ]),
                  _: 3
                }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
              ], 46, XOe)
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index"]), [
            [On, T(l)]
          ])
        ]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["to", "disabled"]));
  }
});
var JOe = /* @__PURE__ */ Ve(KOe, [["__file", "dialog.vue"]]);
const a6t = zn(JOe), ewe = Ye({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: Ae(String),
    default: "solid"
  }
}), twe = U({
  name: "ElDivider"
}), nwe = /* @__PURE__ */ U({
  ...twe,
  props: ewe,
  setup(n) {
    const e = n, t = Pe("divider"), r = B(() => t.cssVar({
      "border-style": e.borderStyle
    }));
    return (i, o) => (V(), q("div", {
      class: Q([T(t).b(), T(t).m(i.direction)]),
      style: vt(T(r)),
      role: "separator"
    }, [
      i.$slots.default && i.direction !== "vertical" ? (V(), q("div", {
        key: 0,
        class: Q([T(t).e("text"), T(t).is(i.contentPosition)])
      }, [
        ke(i.$slots, "default")
      ], 2)) : pe("v-if", !0)
    ], 6));
  }
});
var rwe = /* @__PURE__ */ Ve(nwe, [["__file", "divider.vue"]]);
const s6t = zn(rwe), iwe = Ye({
  ...kH,
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: !0
  },
  modalFade: {
    type: Boolean,
    default: !0
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), owe = PH, awe = ["aria-label", "aria-labelledby", "aria-describedby"], swe = ["id", "aria-level"], lwe = ["aria-label"], uwe = ["id"], cwe = U({
  name: "ElDrawer",
  inheritAttrs: !1
}), hwe = /* @__PURE__ */ U({
  ...cwe,
  props: iwe,
  emits: owe,
  setup(n, { expose: e }) {
    const t = n, r = Tl();
    Xf({
      scope: "el-drawer",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#slots"
    }, B(() => !!r.title));
    const i = z(), o = z(), a = Pe("drawer"), { t: s } = Ar(), {
      afterEnter: l,
      afterLeave: u,
      beforeLeave: c,
      visible: h,
      rendered: f,
      titleId: d,
      bodyId: p,
      onModalClick: g,
      onOpenAutoFocus: v,
      onCloseAutoFocus: m,
      onFocusoutPrevented: y,
      onCloseRequested: b,
      handleClose: O
    } = EH(t, i), w = B(() => t.direction === "rtl" || t.direction === "ltr"), x = B(() => Xo(t.size));
    return e({
      handleClose: O,
      afterEnter: l,
      afterLeave: u
    }), (S, _) => (V(), ve(a_, {
      to: "body",
      disabled: !S.appendToBody
    }, [
      de(kl, {
        name: T(a).b("fade"),
        onAfterEnter: T(l),
        onAfterLeave: T(u),
        onBeforeLeave: T(c),
        persisted: ""
      }, {
        default: fe(() => [
          At(de(T(QL), {
            mask: S.modal,
            "overlay-class": S.modalClass,
            "z-index": S.zIndex,
            onClick: T(g)
          }, {
            default: fe(() => [
              de(T(x_), {
                loop: "",
                trapped: T(h),
                "focus-trap-el": i.value,
                "focus-start-el": o.value,
                onFocusAfterTrapped: T(v),
                onFocusAfterReleased: T(m),
                onFocusoutPrevented: T(y),
                onReleaseRequested: T(b)
              }, {
                default: fe(() => [
                  J("div", xa({
                    ref_key: "drawerRef",
                    ref: i,
                    "aria-modal": "true",
                    "aria-label": S.title || void 0,
                    "aria-labelledby": S.title ? void 0 : T(d),
                    "aria-describedby": T(p)
                  }, S.$attrs, {
                    class: [T(a).b(), S.direction, T(h) && "open"],
                    style: T(w) ? "width: " + T(x) : "height: " + T(x),
                    role: "dialog",
                    onClick: _[1] || (_[1] = kt(() => {
                    }, ["stop"]))
                  }), [
                    J("span", {
                      ref_key: "focusStartRef",
                      ref: o,
                      class: Q(T(a).e("sr-focus")),
                      tabindex: "-1"
                    }, null, 2),
                    S.withHeader ? (V(), q("header", {
                      key: 0,
                      class: Q(T(a).e("header"))
                    }, [
                      S.$slots.title ? ke(S.$slots, "title", { key: 1 }, () => [
                        pe(" DEPRECATED SLOT ")
                      ]) : ke(S.$slots, "header", {
                        key: 0,
                        close: T(O),
                        titleId: T(d),
                        titleClass: T(a).e("title")
                      }, () => [
                        S.$slots.title ? pe("v-if", !0) : (V(), q("span", {
                          key: 0,
                          id: T(d),
                          role: "heading",
                          "aria-level": S.headerAriaLevel,
                          class: Q(T(a).e("title"))
                        }, ze(S.title), 11, swe))
                      ]),
                      S.showClose ? (V(), q("button", {
                        key: 2,
                        "aria-label": T(s)("el.drawer.close"),
                        class: Q(T(a).e("close-btn")),
                        type: "button",
                        onClick: _[0] || (_[0] = (...C) => T(O) && T(O)(...C))
                      }, [
                        de(T(bt), {
                          class: Q(T(a).e("close"))
                        }, {
                          default: fe(() => [
                            de(T(Pc))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, lwe)) : pe("v-if", !0)
                    ], 2)) : pe("v-if", !0),
                    T(f) ? (V(), q("div", {
                      key: 1,
                      id: T(p),
                      class: Q(T(a).e("body"))
                    }, [
                      ke(S.$slots, "default")
                    ], 10, uwe)) : pe("v-if", !0),
                    S.$slots.footer ? (V(), q("div", {
                      key: 2,
                      class: Q(T(a).e("footer"))
                    }, [
                      ke(S.$slots, "footer")
                    ], 2)) : pe("v-if", !0)
                  ], 16, awe)
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
            [On, T(h)]
          ])
        ]),
        _: 3
      }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["disabled"]));
  }
});
var fwe = /* @__PURE__ */ Ve(hwe, [["__file", "drawer.vue"]]);
const l6t = zn(fwe), dwe = /* @__PURE__ */ U({
  inheritAttrs: !1
});
function pwe(n, e, t, r, i, o) {
  return ke(n.$slots, "default");
}
var gwe = /* @__PURE__ */ Ve(dwe, [["render", pwe], ["__file", "collection.vue"]]);
const vwe = /* @__PURE__ */ U({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function mwe(n, e, t, r, i, o) {
  return ke(n.$slots, "default");
}
var ywe = /* @__PURE__ */ Ve(vwe, [["render", mwe], ["__file", "collection-item.vue"]]);
const bwe = "data-el-collection-item", Owe = (n) => {
  const e = `El${n}Collection`, t = `${e}Item`, r = Symbol(e), i = Symbol(t), o = {
    ...gwe,
    name: e,
    setup() {
      const s = z(null), l = /* @__PURE__ */ new Map();
      Wt(r, {
        itemMap: l,
        getItems: () => {
          const c = T(s);
          if (!c)
            return [];
          const h = Array.from(c.querySelectorAll(`[${bwe}]`));
          return [...l.values()].sort((d, p) => h.indexOf(d.ref) - h.indexOf(p.ref));
        },
        collectionRef: s
      });
    }
  }, a = {
    ...ywe,
    name: t,
    setup(s, { attrs: l }) {
      const u = z(null), c = Re(r, void 0);
      Wt(i, {
        collectionItemRef: u
      }), ht(() => {
        const h = T(u);
        h && c.itemMap.set(h, {
          ref: h,
          ...l
        });
      }), xi(() => {
        const h = T(u);
        c.itemMap.delete(h);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: r,
    COLLECTION_ITEM_INJECTION_KEY: i,
    ElCollection: o,
    ElCollectionItem: a
  };
}, m2 = Ye({
  trigger: e0.trigger,
  effect: {
    ...po.effect,
    default: "light"
  },
  type: {
    type: Ae(String)
  },
  placement: {
    type: Ae(String),
    default: "bottom"
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: Ae([Number, String]),
    default: 0
  },
  maxHeight: {
    type: Ae([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: Ae(Object)
  },
  teleported: po.teleported
});
Ye({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: $r
  }
});
Ye({
  onKeydown: { type: Ae(Function) }
});
Owe("Dropdown");
const wwe = Ye({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: Ra,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (n) => n === null || _t(n) || ["min", "max"].includes(n),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (n) => n >= 0 && n === Number.parseInt(`${n}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), xwe = {
  [yi]: (n, e) => e !== n,
  blur: (n) => n instanceof FocusEvent,
  focus: (n) => n instanceof FocusEvent,
  [Df]: (n) => _t(n) || _o(n),
  [Dt]: (n) => _t(n) || _o(n)
}, Swe = ["aria-label", "onKeydown"], _we = ["aria-label", "onKeydown"], Cwe = U({
  name: "ElInputNumber"
}), Awe = /* @__PURE__ */ U({
  ...Cwe,
  props: wwe,
  emits: xwe,
  setup(n, { expose: e, emit: t }) {
    const r = n, { t: i } = Ar(), o = Pe("input-number"), a = z(), s = dr({
      currentValue: r.modelValue,
      userInput: null
    }), { formItem: l } = Na(), u = B(() => _t(r.modelValue) && r.modelValue <= r.min), c = B(() => _t(r.modelValue) && r.modelValue >= r.max), h = B(() => {
      const E = m(r.step);
      return Li(r.precision) ? Math.max(m(r.modelValue), E) : (E > r.precision && Ht("InputNumber", "precision should not be less than the decimal places of step"), r.precision);
    }), f = B(() => r.controls && r.controlsPosition === "right"), d = ko(), p = ah(), g = B(() => {
      if (s.userInput !== null)
        return s.userInput;
      let E = s.currentValue;
      if (_o(E))
        return "";
      if (_t(E)) {
        if (Number.isNaN(E))
          return "";
        Li(r.precision) || (E = E.toFixed(r.precision));
      }
      return E;
    }), v = (E, M) => {
      if (Li(M) && (M = h.value), M === 0)
        return Math.round(E);
      let R = String(E);
      const N = R.indexOf(".");
      if (N === -1 || !R.replace(".", "").split("")[N + M])
        return E;
      const W = R.length;
      return R.charAt(W - 1) === "5" && (R = `${R.slice(0, Math.max(0, W - 1))}6`), Number.parseFloat(Number(R).toFixed(M));
    }, m = (E) => {
      if (_o(E))
        return 0;
      const M = E.toString(), R = M.indexOf(".");
      let N = 0;
      return R !== -1 && (N = M.length - R - 1), N;
    }, y = (E, M = 1) => _t(E) ? v(E + r.step * M) : s.currentValue, b = () => {
      if (r.readonly || p.value || c.value)
        return;
      const E = Number(g.value) || 0, M = y(E);
      x(M), t(Df, s.currentValue), L();
    }, O = () => {
      if (r.readonly || p.value || u.value)
        return;
      const E = Number(g.value) || 0, M = y(E, -1);
      x(M), t(Df, s.currentValue), L();
    }, w = (E, M) => {
      const { max: R, min: N, step: $, precision: F, stepStrictly: W, valueOnClear: j } = r;
      R < N && Su("InputNumber", "min should not be greater than max.");
      let Y = Number(E);
      if (_o(E) || Number.isNaN(Y))
        return null;
      if (E === "") {
        if (j === null)
          return null;
        Y = Ut(j) ? { min: N, max: R }[j] : j;
      }
      return W && (Y = v(Math.round(Y / $) * $, F)), Li(F) || (Y = v(Y, F)), (Y > R || Y < N) && (Y = Y > R ? R : N, M && t(Dt, Y)), Y;
    }, x = (E, M = !0) => {
      var R;
      const N = s.currentValue, $ = w(E);
      if (!M) {
        t(Dt, $);
        return;
      }
      N !== $ && (s.userInput = null, t(Dt, $), t(yi, $, N), r.validateEvent && ((R = l == null ? void 0 : l.validate) == null || R.call(l, "change").catch((F) => Ht(F))), s.currentValue = $);
    }, S = (E) => {
      s.userInput = E;
      const M = E === "" ? null : Number(E);
      t(Df, M), x(M, !1);
    }, _ = (E) => {
      const M = E !== "" ? Number(E) : "";
      (_t(M) && !Number.isNaN(M) || E === "") && x(M), L(), s.userInput = null;
    }, C = () => {
      var E, M;
      (M = (E = a.value) == null ? void 0 : E.focus) == null || M.call(E);
    }, A = () => {
      var E, M;
      (M = (E = a.value) == null ? void 0 : E.blur) == null || M.call(E);
    }, k = (E) => {
      t("focus", E);
    }, P = (E) => {
      var M;
      s.userInput = null, t("blur", E), r.validateEvent && ((M = l == null ? void 0 : l.validate) == null || M.call(l, "blur").catch((R) => Ht(R)));
    }, L = () => {
      s.currentValue !== r.modelValue && (s.currentValue = r.modelValue);
    }, D = (E) => {
      document.activeElement === E.target && E.preventDefault();
    };
    return he(() => r.modelValue, (E, M) => {
      const R = w(E, !0);
      s.userInput === null && R !== M && (s.currentValue = R);
    }, { immediate: !0 }), ht(() => {
      var E;
      const { min: M, max: R, modelValue: N } = r, $ = (E = a.value) == null ? void 0 : E.input;
      if ($.setAttribute("role", "spinbutton"), Number.isFinite(R) ? $.setAttribute("aria-valuemax", String(R)) : $.removeAttribute("aria-valuemax"), Number.isFinite(M) ? $.setAttribute("aria-valuemin", String(M)) : $.removeAttribute("aria-valuemin"), $.setAttribute("aria-valuenow", s.currentValue || s.currentValue === 0 ? String(s.currentValue) : ""), $.setAttribute("aria-disabled", String(p.value)), !_t(N) && N != null) {
        let F = Number(N);
        Number.isNaN(F) && (F = null), t(Dt, F);
      }
    }), yd(() => {
      var E, M;
      const R = (E = a.value) == null ? void 0 : E.input;
      R == null || R.setAttribute("aria-valuenow", `${(M = s.currentValue) != null ? M : ""}`);
    }), e({
      focus: C,
      blur: A
    }), (E, M) => (V(), q("div", {
      class: Q([
        T(o).b(),
        T(o).m(T(d)),
        T(o).is("disabled", T(p)),
        T(o).is("without-controls", !E.controls),
        T(o).is("controls-right", T(f))
      ]),
      onDragstart: M[0] || (M[0] = kt(() => {
      }, ["prevent"]))
    }, [
      E.controls ? At((V(), q("span", {
        key: 0,
        role: "button",
        "aria-label": T(i)("el.inputNumber.decrease"),
        class: Q([T(o).e("decrease"), T(o).is("disabled", T(u))]),
        onKeydown: Rr(O, ["enter"])
      }, [
        de(T(bt), null, {
          default: fe(() => [
            T(f) ? (V(), ve(T(pb), { key: 0 })) : (V(), ve(T(bpe), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, Swe)), [
        [T(yB), O]
      ]) : pe("v-if", !0),
      E.controls ? At((V(), q("span", {
        key: 1,
        role: "button",
        "aria-label": T(i)("el.inputNumber.increase"),
        class: Q([T(o).e("increase"), T(o).is("disabled", T(c))]),
        onKeydown: Rr(b, ["enter"])
      }, [
        de(T(bt), null, {
          default: fe(() => [
            T(f) ? (V(), ve(T(Yj), { key: 0 })) : (V(), ve(T(Jj), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, _we)), [
        [T(yB), b]
      ]) : pe("v-if", !0),
      de(T(Td), {
        id: E.id,
        ref_key: "input",
        ref: a,
        type: "number",
        step: E.step,
        "model-value": T(g),
        placeholder: E.placeholder,
        readonly: E.readonly,
        disabled: T(p),
        size: T(d),
        max: E.max,
        min: E.min,
        name: E.name,
        label: E.label,
        "validate-event": !1,
        onWheel: D,
        onKeydown: [
          Rr(kt(b, ["prevent"]), ["up"]),
          Rr(kt(O, ["prevent"]), ["down"])
        ],
        onBlur: P,
        onFocus: k,
        onInput: S,
        onChange: _
      }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
    ], 34));
  }
});
var Twe = /* @__PURE__ */ Ve(Awe, [["__file", "input-number.vue"]]);
const u6t = zn(Twe), MH = Symbol("elPaginationKey"), kwe = Ye({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: $r
  }
}), Pwe = {
  click: (n) => n instanceof MouseEvent
}, Ewe = ["disabled", "aria-label", "aria-disabled"], Mwe = { key: 0 }, Dwe = U({
  name: "ElPaginationPrev"
}), Lwe = /* @__PURE__ */ U({
  ...Dwe,
  props: kwe,
  emits: Pwe,
  setup(n) {
    const e = n, { t } = Ar(), r = B(() => e.disabled || e.currentPage <= 1);
    return (i, o) => (V(), q("button", {
      type: "button",
      class: "btn-prev",
      disabled: T(r),
      "aria-label": i.prevText || T(t)("el.pagination.prev"),
      "aria-disabled": T(r),
      onClick: o[0] || (o[0] = (a) => i.$emit("click", a))
    }, [
      i.prevText ? (V(), q("span", Mwe, ze(i.prevText), 1)) : (V(), ve(T(bt), { key: 1 }, {
        default: fe(() => [
          (V(), ve(cn(i.prevIcon)))
        ]),
        _: 1
      }))
    ], 8, Ewe));
  }
});
var Iwe = /* @__PURE__ */ Ve(Lwe, [["__file", "prev.vue"]]);
const Rwe = Ye({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: $r
  }
}), Nwe = ["disabled", "aria-label", "aria-disabled"], $we = { key: 0 }, Bwe = U({
  name: "ElPaginationNext"
}), Vwe = /* @__PURE__ */ U({
  ...Bwe,
  props: Rwe,
  emits: ["click"],
  setup(n) {
    const e = n, { t } = Ar(), r = B(() => e.disabled || e.currentPage === e.pageCount || e.pageCount === 0);
    return (i, o) => (V(), q("button", {
      type: "button",
      class: "btn-next",
      disabled: T(r),
      "aria-label": i.nextText || T(t)("el.pagination.next"),
      "aria-disabled": T(r),
      onClick: o[0] || (o[0] = (a) => i.$emit("click", a))
    }, [
      i.nextText ? (V(), q("span", $we, ze(i.nextText), 1)) : (V(), ve(T(bt), { key: 1 }, {
        default: fe(() => [
          (V(), ve(cn(i.nextIcon)))
        ]),
        _: 1
      }))
    ], 8, Nwe));
  }
});
var zwe = /* @__PURE__ */ Ve(Vwe, [["__file", "next.vue"]]);
const DH = Symbol("ElSelectGroup"), __ = Symbol("ElSelect");
function Fwe(n, e) {
  const t = Re(__), r = Re(DH, { disabled: !1 }), i = B(() => t.props.multiple ? c(t.props.modelValue, n.value) : c([t.props.modelValue], n.value)), o = B(() => {
    if (t.props.multiple) {
      const d = t.props.modelValue || [];
      return !i.value && d.length >= t.props.multipleLimit && t.props.multipleLimit > 0;
    } else
      return !1;
  }), a = B(() => n.label || (Nr(n.value) ? "" : n.value)), s = B(() => n.value || n.label || ""), l = B(() => n.disabled || e.groupDisabled || o.value), u = wt(), c = (d = [], p) => {
    if (Nr(n.value)) {
      const g = t.props.valueKey;
      return d && d.some((v) => rx(ga(v, g)) === ga(p, g));
    } else
      return d && d.includes(p);
  }, h = () => {
    !n.disabled && !r.disabled && (t.states.hoveringIndex = t.optionsArray.indexOf(u.proxy));
  }, f = (d) => {
    const p = new RegExp(hve(d), "i");
    e.visible = p.test(a.value) || n.created;
  };
  return he(() => a.value, () => {
    !n.created && !t.props.remote && t.setSelected();
  }), he(() => n.value, (d, p) => {
    const { remote: g, valueKey: v } = t.props;
    if (hr(d, p) || (t.onOptionDestroy(p, u.proxy), t.onOptionCreate(u.proxy)), !n.created && !g) {
      if (v && Nr(d) && Nr(p) && d[v] === p[v])
        return;
      t.setSelected();
    }
  }), he(() => r.disabled, () => {
    e.groupDisabled = r.disabled;
  }, { immediate: !0 }), {
    select: t,
    currentLabel: a,
    currentValue: s,
    itemSelected: i,
    isDisabled: l,
    hoverItem: h,
    updateOption: f
  };
}
const Qwe = U({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(n) {
    const e = Pe("select"), t = fs(), r = B(() => [
      e.be("dropdown", "item"),
      e.is("disabled", T(s)),
      e.is("selected", T(a)),
      e.is("hovering", T(f))
    ]), i = dr({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hover: !1
    }), {
      currentLabel: o,
      itemSelected: a,
      isDisabled: s,
      select: l,
      hoverItem: u,
      updateOption: c
    } = Fwe(n, i), { visible: h, hover: f } = bu(i), d = wt().proxy;
    l.onOptionCreate(d), xi(() => {
      const g = d.value, { selected: v } = l.states, y = (l.props.multiple ? v : [v]).some((b) => b.value === d.value);
      Ke(() => {
        l.states.cachedOptions.get(g) === d && !y && l.states.cachedOptions.delete(g);
      }), l.onOptionDestroy(g, d);
    });
    function p() {
      n.disabled !== !0 && i.groupDisabled !== !0 && l.handleOptionSelect(d);
    }
    return {
      ns: e,
      id: t,
      containerKls: r,
      currentLabel: o,
      itemSelected: a,
      isDisabled: s,
      select: l,
      hoverItem: u,
      updateOption: c,
      visible: h,
      hover: f,
      selectOptionClick: p,
      states: i
    };
  }
}), Zwe = ["id", "aria-disabled", "aria-selected"];
function Wwe(n, e, t, r, i, o) {
  return At((V(), q("li", {
    id: n.id,
    class: Q(n.containerKls),
    role: "option",
    "aria-disabled": n.isDisabled || void 0,
    "aria-selected": n.itemSelected,
    onMouseenter: e[0] || (e[0] = (...a) => n.hoverItem && n.hoverItem(...a)),
    onClick: e[1] || (e[1] = kt((...a) => n.selectOptionClick && n.selectOptionClick(...a), ["stop"]))
  }, [
    ke(n.$slots, "default", {}, () => [
      J("span", null, ze(n.currentLabel), 1)
    ])
  ], 42, Zwe)), [
    [On, n.visible]
  ]);
}
var ZL = /* @__PURE__ */ Ve(Qwe, [["render", Wwe], ["__file", "option.vue"]]);
const Gwe = U({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const n = Re(__), e = Pe("select"), t = B(() => n.props.popperClass), r = B(() => n.props.multiple), i = B(() => n.props.fitInputWidth), o = z("");
    function a() {
      var s;
      o.value = `${(s = n.selectRef) == null ? void 0 : s.offsetWidth}px`;
    }
    return ht(() => {
      a(), Ei(n.selectRef, a);
    }), {
      ns: e,
      minWidth: o,
      popperClass: t,
      isMultiple: r,
      isFitInputWidth: i
    };
  }
});
function jwe(n, e, t, r, i, o) {
  return V(), q("div", {
    class: Q([n.ns.b("dropdown"), n.ns.is("multiple", n.isMultiple), n.popperClass]),
    style: vt({ [n.isFitInputWidth ? "width" : "minWidth"]: n.minWidth })
  }, [
    n.$slots.header ? (V(), q("div", {
      key: 0,
      class: Q(n.ns.be("dropdown", "header"))
    }, [
      ke(n.$slots, "header")
    ], 2)) : pe("v-if", !0),
    ke(n.$slots, "default"),
    n.$slots.footer ? (V(), q("div", {
      key: 1,
      class: Q(n.ns.be("dropdown", "footer"))
    }, [
      ke(n.$slots, "footer")
    ], 2)) : pe("v-if", !0)
  ], 6);
}
var Hwe = /* @__PURE__ */ Ve(Gwe, [["render", jwe], ["__file", "select-dropdown.vue"]]);
function qwe(n) {
  const e = z(!1);
  return {
    handleCompositionStart: () => {
      e.value = !0;
    },
    handleCompositionUpdate: (o) => {
      const a = o.target.value, s = a[a.length - 1] || "";
      e.value = !OL(s);
    },
    handleCompositionEnd: (o) => {
      e.value && (e.value = !1, fn(n) && n(o));
    }
  };
}
const Ywe = 11, Xwe = (n, e) => {
  const { t } = Ar(), r = fs(), i = Pe("select"), o = Pe("input"), a = dr({
    inputValue: "",
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    optionValues: [],
    selected: n.multiple ? [] : {},
    selectionWidth: 0,
    calculatorWidth: 0,
    collapseItemWidth: 0,
    selectedLabel: "",
    hoveringIndex: -1,
    previousQuery: null,
    inputHovering: !1,
    menuVisibleOnFocus: !1,
    isBeforeHide: !1
  });
  Xf({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, B(() => n.suffixTransition === !1));
  const s = z(null), l = z(null), u = z(null), c = z(null), h = z(null), f = z(null), d = z(null), p = z(null), g = z(null), v = z(null), m = z(null), y = z(null), { wrapperRef: b, isFocused: O, handleFocus: w, handleBlur: x } = LL(h, {
    afterFocus() {
      n.automaticDropdown && !S.value && (S.value = !0, a.menuVisibleOnFocus = !0);
    },
    beforeBlur(ce) {
      var Me, dn;
      return ((Me = u.value) == null ? void 0 : Me.isFocusInsideContent(ce)) || ((dn = c.value) == null ? void 0 : dn.isFocusInsideContent(ce));
    },
    afterBlur() {
      S.value = !1, a.menuVisibleOnFocus = !1;
    }
  }), S = z(!1), _ = z(), { form: C, formItem: A } = Na(), { inputId: k } = Ad(n, {
    formItemContext: A
  }), P = B(() => n.disabled || (C == null ? void 0 : C.disabled)), L = B(() => n.multiple ? _n(n.modelValue) && n.modelValue.length > 0 : n.modelValue !== void 0 && n.modelValue !== null && n.modelValue !== ""), D = B(() => n.clearable && !P.value && a.inputHovering && L.value), E = B(() => n.remote && n.filterable && !n.remoteShowSuffix ? "" : n.suffixIcon), M = B(() => i.is("reverse", E.value && S.value && n.suffixTransition)), R = B(() => (A == null ? void 0 : A.validateState) || ""), N = B(() => p7[R.value]), $ = B(() => n.remote ? 300 : 0), F = B(() => n.loading ? n.loadingText || t("el.select.loading") : n.remote && !a.inputValue && a.options.size === 0 ? !1 : n.filterable && a.inputValue && a.options.size > 0 && W.value === 0 ? n.noMatchText || t("el.select.noMatch") : a.options.size === 0 ? n.noDataText || t("el.select.noData") : null), W = B(() => j.value.filter((ce) => ce.visible).length), j = B(() => {
    const ce = Array.from(a.options.values()), Me = [];
    return a.optionValues.forEach((dn) => {
      const or = ce.findIndex((Mu) => Mu.value === dn);
      or > -1 && Me.push(ce[or]);
    }), Me.length >= ce.length ? Me : ce;
  }), Y = B(() => Array.from(a.cachedOptions.values())), X = B(() => {
    const ce = j.value.filter((Me) => !Me.created).some((Me) => Me.currentLabel === a.inputValue);
    return n.filterable && n.allowCreate && a.inputValue !== "" && !ce;
  }), ie = () => {
    n.filterable && fn(n.filterMethod) || n.filterable && n.remote && fn(n.remoteMethod) || j.value.forEach((ce) => {
      ce.updateOption(a.inputValue);
    });
  }, ae = ko(), ee = B(() => ["small"].includes(ae.value) ? "small" : "default"), ne = B({
    get() {
      return S.value && F.value !== !1;
    },
    set(ce) {
      S.value = ce;
    }
  }), ye = B(() => _n(n.modelValue) ? n.modelValue.length === 0 && !a.inputValue : n.filterable ? !a.inputValue : !0), te = B(() => {
    var ce;
    const Me = (ce = n.placeholder) != null ? ce : t("el.select.placeholder");
    return n.multiple || !L.value ? Me : a.selectedLabel;
  });
  he(() => n.modelValue, (ce, Me) => {
    n.multiple && n.filterable && !n.reserveKeyword && (a.inputValue = "", ue("")), dt(), !hr(ce, Me) && n.validateEvent && (A == null || A.validate("change").catch((dn) => Ht(dn)));
  }, {
    flush: "post",
    deep: !0
  }), he(() => S.value, (ce) => {
    ce ? ue(a.inputValue) : (a.inputValue = "", a.previousQuery = null, a.isBeforeHide = !0), e("visible-change", ce);
  }), he(() => a.options.entries(), () => {
    var ce;
    if (!qt)
      return;
    const Me = ((ce = s.value) == null ? void 0 : ce.querySelectorAll("input")) || [];
    (!n.filterable && !n.defaultFirstOption && !Li(n.modelValue) || !Array.from(Me).includes(document.activeElement)) && dt(), n.defaultFirstOption && (n.filterable || n.remote) && W.value && xe();
  }, {
    flush: "post"
  }), he(() => a.hoveringIndex, (ce) => {
    _t(ce) && ce > -1 ? _.value = j.value[ce] || {} : _.value = {}, j.value.forEach((Me) => {
      Me.hover = _.value === Me;
    });
  }), sl(() => {
    a.isBeforeHide || ie();
  });
  const ue = (ce) => {
    a.previousQuery !== ce && (a.previousQuery = ce, n.filterable && fn(n.filterMethod) ? n.filterMethod(ce) : n.filterable && n.remote && fn(n.remoteMethod) && n.remoteMethod(ce), n.defaultFirstOption && (n.filterable || n.remote) && W.value ? Ke(xe) : Ke(Rt));
  }, xe = () => {
    const ce = j.value.filter((or) => or.visible && !or.disabled && !or.states.groupDisabled), Me = ce.find((or) => or.created), dn = ce[0];
    a.hoveringIndex = Ge(j.value, Me || dn);
  }, dt = () => {
    if (n.multiple)
      a.selectedLabel = "";
    else {
      const Me = Ue(n.modelValue);
      a.selectedLabel = Me.currentLabel, a.selected = Me;
      return;
    }
    const ce = [];
    _n(n.modelValue) && n.modelValue.forEach((Me) => {
      ce.push(Ue(Me));
    }), a.selected = ce;
  }, Ue = (ce) => {
    let Me;
    const dn = s2(ce).toLowerCase() === "object", or = s2(ce).toLowerCase() === "null", Mu = s2(ce).toLowerCase() === "undefined";
    for (let gh = a.cachedOptions.size - 1; gh >= 0; gh--) {
      const Ts = Y.value[gh];
      if (dn ? ga(Ts.value, n.valueKey) === ga(ce, n.valueKey) : Ts.value === ce) {
        Me = {
          value: ce,
          currentLabel: Ts.currentLabel,
          isDisabled: Ts.isDisabled
        };
        break;
      }
    }
    if (Me)
      return Me;
    const Fd = dn ? ce.label : !or && !Mu ? ce : "";
    return {
      value: ce,
      currentLabel: Fd
    };
  }, Rt = () => {
    n.multiple ? a.selected.length > 0 ? a.hoveringIndex = Math.min(...a.selected.map((ce) => j.value.findIndex((Me) => jv(Me) === jv(ce)))) : a.hoveringIndex = -1 : a.hoveringIndex = j.value.findIndex((ce) => jv(ce) === jv(a.selected));
  }, zt = () => {
    a.selectionWidth = l.value.getBoundingClientRect().width;
  }, tn = () => {
    a.calculatorWidth = f.value.getBoundingClientRect().width;
  }, jn = () => {
    a.collapseItemWidth = m.value.getBoundingClientRect().width;
  }, An = () => {
    var ce, Me;
    (Me = (ce = u.value) == null ? void 0 : ce.updatePopper) == null || Me.call(ce);
  }, Tn = () => {
    var ce, Me;
    (Me = (ce = c.value) == null ? void 0 : ce.updatePopper) == null || Me.call(ce);
  }, Un = () => {
    a.inputValue.length > 0 && !S.value && (S.value = !0), ue(a.inputValue);
  }, Vi = (ce) => {
    if (a.inputValue = ce.target.value, n.remote)
      Jr();
    else
      return Un();
  }, Jr = kc(() => {
    Un();
  }, $.value), _i = (ce) => {
    hr(n.modelValue, ce) || e(yi, ce);
  }, Oe = (ce) => Hfe(ce, (Me) => !a.disabledOptions.has(Me)), xt = (ce) => {
    if (n.multiple && ce.code !== Ft.delete && ce.target.value.length <= 0) {
      const Me = n.modelValue.slice(), dn = Oe(Me);
      if (dn < 0)
        return;
      Me.splice(dn, 1), e(Dt, Me), _i(Me);
    }
  }, wn = (ce, Me) => {
    const dn = a.selected.indexOf(Me);
    if (dn > -1 && !P.value) {
      const or = n.modelValue.slice();
      or.splice(dn, 1), e(Dt, or), _i(or), e("remove-tag", Me.value);
    }
    ce.stopPropagation(), Vd();
  }, oo = (ce) => {
    ce.stopPropagation();
    const Me = n.multiple ? [] : "";
    if (!Ut(Me))
      for (const dn of a.selected)
        dn.isDisabled && Me.push(dn.value);
    e(Dt, Me), _i(Me), a.hoveringIndex = -1, S.value = !1, e("clear"), Vd();
  }, Eu = (ce) => {
    if (n.multiple) {
      const Me = (n.modelValue || []).slice(), dn = Ge(Me, ce.value);
      dn > -1 ? Me.splice(dn, 1) : (n.multipleLimit <= 0 || Me.length < n.multipleLimit) && Me.push(ce.value), e(Dt, Me), _i(Me), ce.created && ue(""), n.filterable && !n.reserveKeyword && (a.inputValue = "");
    } else
      e(Dt, ce.value), _i(ce.value), S.value = !1;
    Vd(), !S.value && Ke(() => {
      at(ce);
    });
  }, Ge = (ce = [], Me) => {
    if (!Nr(Me))
      return ce.indexOf(Me);
    const dn = n.valueKey;
    let or = -1;
    return ce.some((Mu, Fd) => rx(ga(Mu, dn)) === ga(Me, dn) ? (or = Fd, !0) : !1), or;
  }, at = (ce) => {
    var Me, dn, or, Mu, Fd;
    const n1 = _n(ce) ? ce[0] : ce;
    let gh = null;
    if (n1 != null && n1.value) {
      const Ts = j.value.filter((I$) => I$.value === n1.value);
      Ts.length > 0 && (gh = Ts[0].$el);
    }
    if (u.value && gh) {
      const Ts = (Mu = (or = (dn = (Me = u.value) == null ? void 0 : Me.popperRef) == null ? void 0 : dn.contentRef) == null ? void 0 : or.querySelector) == null ? void 0 : Mu.call(or, `.${i.be("dropdown", "wrap")}`);
      Ts && c7(Ts, gh);
    }
    (Fd = y.value) == null || Fd.handleScroll();
  }, oe = (ce) => {
    a.options.set(ce.value, ce), a.cachedOptions.set(ce.value, ce), ce.disabled && a.disabledOptions.set(ce.value, ce);
  }, ge = (ce, Me) => {
    a.options.get(ce) === Me && a.options.delete(ce);
  }, {
    handleCompositionStart: Se,
    handleCompositionUpdate: yt,
    handleCompositionEnd: Fn
  } = qwe((ce) => Vi(ce)), Tr = B(() => {
    var ce, Me;
    return (Me = (ce = u.value) == null ? void 0 : ce.popperRef) == null ? void 0 : Me.contentRef;
  }), ir = () => {
    Ke(() => at(a.selected));
  }, Vd = () => {
    var ce;
    (ce = h.value) == null || ce.focus();
  }, KC = () => {
    zd();
  }, JC = (ce) => {
    oo(ce);
  }, zd = (ce) => {
    if (S.value = !1, O.value) {
      const Me = new FocusEvent("focus", ce);
      Ke(() => x(Me));
    }
  }, e2 = () => {
    a.inputValue.length > 0 ? a.inputValue = "" : S.value = !1;
  }, D$ = () => {
    P.value || (a.menuVisibleOnFocus ? a.menuVisibleOnFocus = !1 : S.value = !S.value);
  }, joe = () => {
    S.value ? j.value[a.hoveringIndex] && Eu(j.value[a.hoveringIndex]) : D$();
  }, jv = (ce) => Nr(ce.value) ? ga(ce.value, n.valueKey) : ce.value, Hoe = B(() => j.value.filter((ce) => ce.visible).every((ce) => ce.disabled)), qoe = B(() => n.multiple ? n.collapseTags ? a.selected.slice(0, n.maxCollapseTags) : a.selected : []), Yoe = B(() => n.multiple ? n.collapseTags ? a.selected.slice(n.maxCollapseTags) : [] : []), L$ = (ce) => {
    if (!S.value) {
      S.value = !0;
      return;
    }
    if (!(a.options.size === 0 || W.value === 0) && !Hoe.value) {
      ce === "next" ? (a.hoveringIndex++, a.hoveringIndex === a.options.size && (a.hoveringIndex = 0)) : ce === "prev" && (a.hoveringIndex--, a.hoveringIndex < 0 && (a.hoveringIndex = a.options.size - 1));
      const Me = j.value[a.hoveringIndex];
      (Me.disabled === !0 || Me.states.groupDisabled === !0 || !Me.visible) && L$(ce), Ke(() => at(_.value));
    }
  }, Xoe = () => {
    if (!l.value)
      return 0;
    const ce = window.getComputedStyle(l.value);
    return Number.parseFloat(ce.gap || "6px");
  }, Uoe = B(() => {
    const ce = Xoe();
    return { maxWidth: `${m.value && n.maxCollapseTags === 1 ? a.selectionWidth - a.collapseItemWidth - ce : a.selectionWidth}px` };
  }), Koe = B(() => ({ maxWidth: `${a.selectionWidth}px` })), Joe = B(() => ({
    width: `${Math.max(a.calculatorWidth, Ywe)}px`
  }));
  return n.multiple && !_n(n.modelValue) && e(Dt, []), !n.multiple && _n(n.modelValue) && e(Dt, ""), Ei(l, zt), Ei(f, tn), Ei(g, An), Ei(b, An), Ei(v, Tn), Ei(m, jn), ht(() => {
    dt();
  }), {
    inputId: k,
    contentId: r,
    nsSelect: i,
    nsInput: o,
    states: a,
    isFocused: O,
    expanded: S,
    optionsArray: j,
    hoverOption: _,
    selectSize: ae,
    filteredOptionsCount: W,
    resetCalculatorWidth: tn,
    updateTooltip: An,
    updateTagTooltip: Tn,
    debouncedOnInputChange: Jr,
    onInput: Vi,
    deletePrevTag: xt,
    deleteTag: wn,
    deleteSelected: oo,
    handleOptionSelect: Eu,
    scrollToOption: at,
    hasModelValue: L,
    shouldShowPlaceholder: ye,
    currentPlaceholder: te,
    showClose: D,
    iconComponent: E,
    iconReverse: M,
    validateState: R,
    validateIcon: N,
    showNewOption: X,
    updateOptions: ie,
    collapseTagSize: ee,
    setSelected: dt,
    selectDisabled: P,
    emptyText: F,
    handleCompositionStart: Se,
    handleCompositionUpdate: yt,
    handleCompositionEnd: Fn,
    onOptionCreate: oe,
    onOptionDestroy: ge,
    handleMenuEnter: ir,
    handleFocus: w,
    focus: Vd,
    blur: KC,
    handleBlur: x,
    handleClearClick: JC,
    handleClickOutside: zd,
    handleEsc: e2,
    toggleMenu: D$,
    selectOption: joe,
    getValueKey: jv,
    navigateOptions: L$,
    dropdownMenuVisible: ne,
    showTagList: qoe,
    collapseTagList: Yoe,
    tagStyle: Uoe,
    collapseTagStyle: Koe,
    inputStyle: Joe,
    popperRef: Tr,
    inputRef: h,
    tooltipRef: u,
    tagTooltipRef: c,
    calculatorRef: f,
    prefixRef: d,
    suffixRef: p,
    selectRef: s,
    wrapperRef: b,
    selectionRef: l,
    scrollbarRef: y,
    menuRef: g,
    tagMenuRef: v,
    collapseItemRef: m
  };
};
var Uwe = U({
  name: "ElOptions",
  setup(n, { slots: e }) {
    const t = Re(__);
    let r = [];
    return () => {
      var i, o;
      const a = (i = e.default) == null ? void 0 : i.call(e), s = [];
      function l(u) {
        _n(u) && u.forEach((c) => {
          var h, f, d, p;
          const g = (h = (c == null ? void 0 : c.type) || {}) == null ? void 0 : h.name;
          g === "ElOptionGroup" ? l(!Ut(c.children) && !_n(c.children) && fn((f = c.children) == null ? void 0 : f.default) ? (d = c.children) == null ? void 0 : d.default() : c.children) : g === "ElOption" ? s.push((p = c.props) == null ? void 0 : p.value) : _n(c.children) && l(c.children);
        });
      }
      return a.length && l((o = a[0]) == null ? void 0 : o.children), hr(s, r) || (r = s, t && (t.states.optionValues = s)), a;
    };
  }
});
const Kwe = Ye({
  name: String,
  id: String,
  modelValue: {
    type: [Array, String, Number, Boolean, Object],
    default: void 0
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  automaticDropdown: Boolean,
  size: Ra,
  effect: {
    type: Ae(String),
    default: "light"
  },
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  allowCreate: Boolean,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  remote: Boolean,
  loadingText: String,
  noMatchText: String,
  noDataText: String,
  remoteMethod: Function,
  filterMethod: Function,
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  placeholder: {
    type: String
  },
  defaultFirstOption: Boolean,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  valueKey: {
    type: String,
    default: "value"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  teleported: po.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: $r,
    default: gb
  },
  fitInputWidth: Boolean,
  suffixIcon: {
    type: $r,
    default: pb
  },
  tagType: { ...FL.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  remoteShowSuffix: Boolean,
  suffixTransition: {
    type: Boolean,
    default: !0
  },
  placement: {
    type: Ae(String),
    values: y_,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: Ae(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  ariaLabel: {
    type: String,
    default: void 0
  }
}), MB = "ElSelect", Jwe = U({
  name: MB,
  componentName: MB,
  components: {
    ElInput: Td,
    ElSelectMenu: Hwe,
    ElOption: ZL,
    ElOptions: Uwe,
    ElTag: _P,
    ElScrollbar: Ob,
    ElTooltip: Uf,
    ElIcon: bt
  },
  directives: { ClickOutside: S_ },
  props: Kwe,
  emits: [
    Dt,
    yi,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(n, { emit: e }) {
    const t = Xwe(n, e);
    return Wt(__, dr({
      props: n,
      states: t.states,
      optionsArray: t.optionsArray,
      handleOptionSelect: t.handleOptionSelect,
      onOptionCreate: t.onOptionCreate,
      onOptionDestroy: t.onOptionDestroy,
      selectRef: t.selectRef,
      setSelected: t.setSelected
    })), {
      ...t
    };
  }
}), exe = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], txe = ["textContent"];
function nxe(n, e, t, r, i, o) {
  const a = Ct("el-tag"), s = Ct("el-tooltip"), l = Ct("el-icon"), u = Ct("el-option"), c = Ct("el-options"), h = Ct("el-scrollbar"), f = Ct("el-select-menu"), d = eL("click-outside");
  return At((V(), q("div", {
    ref: "selectRef",
    class: Q([n.nsSelect.b(), n.nsSelect.m(n.selectSize)]),
    onMouseenter: e[14] || (e[14] = (p) => n.states.inputHovering = !0),
    onMouseleave: e[15] || (e[15] = (p) => n.states.inputHovering = !1),
    onClick: e[16] || (e[16] = kt((...p) => n.toggleMenu && n.toggleMenu(...p), ["stop"]))
  }, [
    de(s, {
      ref: "tooltipRef",
      visible: n.dropdownMenuVisible,
      placement: n.placement,
      teleported: n.teleported,
      "popper-class": [n.nsSelect.e("popper"), n.popperClass],
      "popper-options": n.popperOptions,
      "fallback-placements": n.fallbackPlacements,
      effect: n.effect,
      pure: "",
      trigger: "click",
      transition: `${n.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: n.persistent,
      onBeforeShow: n.handleMenuEnter,
      onHide: e[13] || (e[13] = (p) => n.states.isBeforeHide = !1)
    }, {
      default: fe(() => {
        var p;
        return [
          J("div", {
            ref: "wrapperRef",
            class: Q([
              n.nsSelect.e("wrapper"),
              n.nsSelect.is("focused", n.isFocused),
              n.nsSelect.is("hovering", n.states.inputHovering),
              n.nsSelect.is("filterable", n.filterable),
              n.nsSelect.is("disabled", n.selectDisabled)
            ])
          }, [
            n.$slots.prefix ? (V(), q("div", {
              key: 0,
              ref: "prefixRef",
              class: Q(n.nsSelect.e("prefix"))
            }, [
              ke(n.$slots, "prefix")
            ], 2)) : pe("v-if", !0),
            J("div", {
              ref: "selectionRef",
              class: Q([
                n.nsSelect.e("selection"),
                n.nsSelect.is("near", n.multiple && !n.$slots.prefix && !!n.states.selected.length)
              ])
            }, [
              n.multiple ? ke(n.$slots, "tag", { key: 0 }, () => [
                (V(!0), q(yn, null, qi(n.showTagList, (g) => (V(), q("div", {
                  key: n.getValueKey(g),
                  class: Q(n.nsSelect.e("selected-item"))
                }, [
                  de(a, {
                    closable: !n.selectDisabled && !g.isDisabled,
                    size: n.collapseTagSize,
                    type: n.tagType,
                    "disable-transitions": "",
                    style: vt(n.tagStyle),
                    onClose: (v) => n.deleteTag(v, g)
                  }, {
                    default: fe(() => [
                      J("span", {
                        class: Q(n.nsSelect.e("tags-text"))
                      }, ze(g.currentLabel), 3)
                    ]),
                    _: 2
                  }, 1032, ["closable", "size", "type", "style", "onClose"])
                ], 2))), 128)),
                n.collapseTags && n.states.selected.length > n.maxCollapseTags ? (V(), ve(s, {
                  key: 0,
                  ref: "tagTooltipRef",
                  disabled: n.dropdownMenuVisible || !n.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  effect: n.effect,
                  placement: "bottom",
                  teleported: n.teleported
                }, {
                  default: fe(() => [
                    J("div", {
                      ref: "collapseItemRef",
                      class: Q(n.nsSelect.e("selected-item"))
                    }, [
                      de(a, {
                        closable: !1,
                        size: n.collapseTagSize,
                        type: n.tagType,
                        "disable-transitions": "",
                        style: vt(n.collapseTagStyle)
                      }, {
                        default: fe(() => [
                          J("span", {
                            class: Q(n.nsSelect.e("tags-text"))
                          }, " + " + ze(n.states.selected.length - n.maxCollapseTags), 3)
                        ]),
                        _: 1
                      }, 8, ["size", "type", "style"])
                    ], 2)
                  ]),
                  content: fe(() => [
                    J("div", {
                      ref: "tagMenuRef",
                      class: Q(n.nsSelect.e("selection"))
                    }, [
                      (V(!0), q(yn, null, qi(n.collapseTagList, (g) => (V(), q("div", {
                        key: n.getValueKey(g),
                        class: Q(n.nsSelect.e("selected-item"))
                      }, [
                        de(a, {
                          class: "in-tooltip",
                          closable: !n.selectDisabled && !g.isDisabled,
                          size: n.collapseTagSize,
                          type: n.tagType,
                          "disable-transitions": "",
                          onClose: (v) => n.deleteTag(v, g)
                        }, {
                          default: fe(() => [
                            J("span", {
                              class: Q(n.nsSelect.e("tags-text"))
                            }, ze(g.currentLabel), 3)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "onClose"])
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["disabled", "effect", "teleported"])) : pe("v-if", !0)
              ]) : pe("v-if", !0),
              n.selectDisabled ? pe("v-if", !0) : (V(), q("div", {
                key: 1,
                class: Q([
                  n.nsSelect.e("selected-item"),
                  n.nsSelect.e("input-wrapper"),
                  n.nsSelect.is("hidden", !n.filterable)
                ])
              }, [
                At(J("input", {
                  id: n.inputId,
                  ref: "inputRef",
                  "onUpdate:modelValue": e[0] || (e[0] = (g) => n.states.inputValue = g),
                  type: "text",
                  class: Q([n.nsSelect.e("input"), n.nsSelect.is(n.selectSize)]),
                  disabled: n.selectDisabled,
                  autocomplete: n.autocomplete,
                  style: vt(n.inputStyle),
                  role: "combobox",
                  readonly: !n.filterable,
                  spellcheck: "false",
                  "aria-activedescendant": ((p = n.hoverOption) == null ? void 0 : p.id) || "",
                  "aria-controls": n.contentId,
                  "aria-expanded": n.dropdownMenuVisible,
                  "aria-label": n.ariaLabel,
                  "aria-autocomplete": "none",
                  "aria-haspopup": "listbox",
                  onFocus: e[1] || (e[1] = (...g) => n.handleFocus && n.handleFocus(...g)),
                  onBlur: e[2] || (e[2] = (...g) => n.handleBlur && n.handleBlur(...g)),
                  onKeydown: [
                    e[3] || (e[3] = Rr(kt((g) => n.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                    e[4] || (e[4] = Rr(kt((g) => n.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                    e[5] || (e[5] = Rr(kt((...g) => n.handleEsc && n.handleEsc(...g), ["stop", "prevent"]), ["esc"])),
                    e[6] || (e[6] = Rr(kt((...g) => n.selectOption && n.selectOption(...g), ["stop", "prevent"]), ["enter"])),
                    e[7] || (e[7] = Rr(kt((...g) => n.deletePrevTag && n.deletePrevTag(...g), ["stop"]), ["delete"]))
                  ],
                  onCompositionstart: e[8] || (e[8] = (...g) => n.handleCompositionStart && n.handleCompositionStart(...g)),
                  onCompositionupdate: e[9] || (e[9] = (...g) => n.handleCompositionUpdate && n.handleCompositionUpdate(...g)),
                  onCompositionend: e[10] || (e[10] = (...g) => n.handleCompositionEnd && n.handleCompositionEnd(...g)),
                  onInput: e[11] || (e[11] = (...g) => n.onInput && n.onInput(...g)),
                  onClick: e[12] || (e[12] = kt((...g) => n.toggleMenu && n.toggleMenu(...g), ["stop"]))
                }, null, 46, exe), [
                  [LG, n.states.inputValue]
                ]),
                n.filterable ? (V(), q("span", {
                  key: 0,
                  ref: "calculatorRef",
                  "aria-hidden": "true",
                  class: Q(n.nsSelect.e("input-calculator")),
                  textContent: ze(n.states.inputValue)
                }, null, 10, txe)) : pe("v-if", !0)
              ], 2)),
              n.shouldShowPlaceholder ? (V(), q("div", {
                key: 2,
                class: Q([
                  n.nsSelect.e("selected-item"),
                  n.nsSelect.e("placeholder"),
                  n.nsSelect.is("transparent", !n.hasModelValue || n.expanded && !n.states.inputValue)
                ])
              }, [
                J("span", null, ze(n.currentPlaceholder), 1)
              ], 2)) : pe("v-if", !0)
            ], 2),
            J("div", {
              ref: "suffixRef",
              class: Q(n.nsSelect.e("suffix"))
            }, [
              n.iconComponent && !n.showClose ? (V(), ve(l, {
                key: 0,
                class: Q([n.nsSelect.e("caret"), n.nsSelect.e("icon"), n.iconReverse])
              }, {
                default: fe(() => [
                  (V(), ve(cn(n.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])) : pe("v-if", !0),
              n.showClose && n.clearIcon ? (V(), ve(l, {
                key: 1,
                class: Q([n.nsSelect.e("caret"), n.nsSelect.e("icon")]),
                onClick: n.handleClearClick
              }, {
                default: fe(() => [
                  (V(), ve(cn(n.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : pe("v-if", !0),
              n.validateState && n.validateIcon ? (V(), ve(l, {
                key: 2,
                class: Q([n.nsInput.e("icon"), n.nsInput.e("validateIcon")])
              }, {
                default: fe(() => [
                  (V(), ve(cn(n.validateIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : pe("v-if", !0)
            ], 2)
          ], 2)
        ];
      }),
      content: fe(() => [
        de(f, { ref: "menuRef" }, {
          default: fe(() => [
            n.$slots.header ? (V(), q("div", {
              key: 0,
              class: Q(n.nsSelect.be("dropdown", "header"))
            }, [
              ke(n.$slots, "header")
            ], 2)) : pe("v-if", !0),
            At(de(h, {
              id: n.contentId,
              ref: "scrollbarRef",
              tag: "ul",
              "wrap-class": n.nsSelect.be("dropdown", "wrap"),
              "view-class": n.nsSelect.be("dropdown", "list"),
              class: Q([n.nsSelect.is("empty", n.filteredOptionsCount === 0)]),
              role: "listbox",
              "aria-label": n.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: fe(() => [
                n.showNewOption ? (V(), ve(u, {
                  key: 0,
                  value: n.states.inputValue,
                  created: !0
                }, null, 8, ["value"])) : pe("v-if", !0),
                de(c, null, {
                  default: fe(() => [
                    ke(n.$slots, "default")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [On, n.states.options.size > 0 && !n.loading]
            ]),
            n.$slots.loading && n.loading ? (V(), q("div", {
              key: 1,
              class: Q(n.nsSelect.be("dropdown", "loading"))
            }, [
              ke(n.$slots, "loading")
            ], 2)) : n.loading || n.filteredOptionsCount === 0 ? (V(), q("div", {
              key: 2,
              class: Q(n.nsSelect.be("dropdown", "empty"))
            }, [
              ke(n.$slots, "empty", {}, () => [
                J("span", null, ze(n.emptyText), 1)
              ])
            ], 2)) : pe("v-if", !0),
            n.$slots.footer ? (V(), q("div", {
              key: 3,
              class: Q(n.nsSelect.be("dropdown", "footer"))
            }, [
              ke(n.$slots, "footer")
            ], 2)) : pe("v-if", !0)
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])
  ], 34)), [
    [d, n.handleClickOutside, n.popperRef]
  ]);
}
var rxe = /* @__PURE__ */ Ve(Jwe, [["render", nxe], ["__file", "select.vue"]]);
const ixe = U({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(n) {
    const e = Pe("select"), t = z(null), r = wt(), i = z([]);
    Wt(DH, dr({
      ...bu(n)
    }));
    const o = B(() => i.value.some((l) => l.visible === !0)), a = (l) => {
      const u = [];
      return _n(l.children) && l.children.forEach((c) => {
        var h, f;
        c.type && c.type.name === "ElOption" && c.component && c.component.proxy ? u.push(c.component.proxy) : (h = c.children) != null && h.length ? u.push(...a(c)) : (f = c.component) != null && f.subTree && u.push(...a(c.component.subTree));
      }), u;
    }, s = () => {
      i.value = a(r.subTree);
    };
    return ht(() => {
      s();
    }), qge(t, s, {
      attributes: !0,
      subtree: !0,
      childList: !0
    }), {
      groupRef: t,
      visible: o,
      ns: e
    };
  }
});
function oxe(n, e, t, r, i, o) {
  return At((V(), q("ul", {
    ref: "groupRef",
    class: Q(n.ns.be("group", "wrap"))
  }, [
    J("li", {
      class: Q(n.ns.be("group", "title"))
    }, ze(n.label), 3),
    J("li", null, [
      J("ul", {
        class: Q(n.ns.b("group"))
      }, [
        ke(n.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [On, n.visible]
  ]);
}
var LH = /* @__PURE__ */ Ve(ixe, [["render", oxe], ["__file", "option-group.vue"]]);
const axe = zn(rxe, {
  Option: ZL,
  OptionGroup: LH
}), sxe = Os(ZL);
Os(LH);
const WL = () => Re(MH, {}), lxe = Ye({
  pageSize: {
    type: Number,
    required: !0
  },
  pageSizes: {
    type: Ae(Array),
    default: () => ih([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String
  },
  disabled: Boolean,
  teleported: Boolean,
  size: {
    type: String,
    values: Cd
  }
}), uxe = U({
  name: "ElPaginationSizes"
}), cxe = /* @__PURE__ */ U({
  ...uxe,
  props: lxe,
  emits: ["page-size-change"],
  setup(n, { emit: e }) {
    const t = n, { t: r } = Ar(), i = Pe("pagination"), o = WL(), a = z(t.pageSize);
    he(() => t.pageSizes, (u, c) => {
      if (!hr(u, c) && Array.isArray(u)) {
        const h = u.includes(t.pageSize) ? t.pageSize : t.pageSizes[0];
        e("page-size-change", h);
      }
    }), he(() => t.pageSize, (u) => {
      a.value = u;
    });
    const s = B(() => t.pageSizes);
    function l(u) {
      var c;
      u !== a.value && (a.value = u, (c = o.handleSizeChange) == null || c.call(o, Number(u)));
    }
    return (u, c) => (V(), q("span", {
      class: Q(T(i).e("sizes"))
    }, [
      de(T(axe), {
        "model-value": a.value,
        disabled: u.disabled,
        "popper-class": u.popperClass,
        size: u.size,
        teleported: u.teleported,
        "validate-event": !1,
        onChange: l
      }, {
        default: fe(() => [
          (V(!0), q(yn, null, qi(T(s), (h) => (V(), ve(T(sxe), {
            key: h,
            value: h,
            label: h + T(r)("el.pagination.pagesize")
          }, null, 8, ["value", "label"]))), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])
    ], 2));
  }
});
var hxe = /* @__PURE__ */ Ve(cxe, [["__file", "sizes.vue"]]);
const fxe = Ye({
  size: {
    type: String,
    values: Cd
  }
}), dxe = ["disabled"], pxe = U({
  name: "ElPaginationJumper"
}), gxe = /* @__PURE__ */ U({
  ...pxe,
  props: fxe,
  setup(n) {
    const { t: e } = Ar(), t = Pe("pagination"), { pageCount: r, disabled: i, currentPage: o, changeEvent: a } = WL(), s = z(), l = B(() => {
      var h;
      return (h = s.value) != null ? h : o == null ? void 0 : o.value;
    });
    function u(h) {
      s.value = h ? +h : "";
    }
    function c(h) {
      h = Math.trunc(+h), a == null || a(h), s.value = void 0;
    }
    return (h, f) => (V(), q("span", {
      class: Q(T(t).e("jump")),
      disabled: T(i)
    }, [
      J("span", {
        class: Q([T(t).e("goto")])
      }, ze(T(e)("el.pagination.goto")), 3),
      de(T(Td), {
        size: h.size,
        class: Q([T(t).e("editor"), T(t).is("in-pagination")]),
        min: 1,
        max: T(r),
        disabled: T(i),
        "model-value": T(l),
        "validate-event": !1,
        label: T(e)("el.pagination.page"),
        type: "number",
        "onUpdate:modelValue": u,
        onChange: c
      }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
      J("span", {
        class: Q([T(t).e("classifier")])
      }, ze(T(e)("el.pagination.pageClassifier")), 3)
    ], 10, dxe));
  }
});
var vxe = /* @__PURE__ */ Ve(gxe, [["__file", "jumper.vue"]]);
const mxe = Ye({
  total: {
    type: Number,
    default: 1e3
  }
}), yxe = ["disabled"], bxe = U({
  name: "ElPaginationTotal"
}), Oxe = /* @__PURE__ */ U({
  ...bxe,
  props: mxe,
  setup(n) {
    const { t: e } = Ar(), t = Pe("pagination"), { disabled: r } = WL();
    return (i, o) => (V(), q("span", {
      class: Q(T(t).e("total")),
      disabled: T(r)
    }, ze(T(e)("el.pagination.total", {
      total: i.total
    })), 11, yxe));
  }
});
var wxe = /* @__PURE__ */ Ve(Oxe, [["__file", "total.vue"]]);
const xxe = Ye({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: !0
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
}), Sxe = ["onKeyup"], _xe = ["aria-current", "aria-label", "tabindex"], Cxe = ["tabindex", "aria-label"], Axe = ["aria-current", "aria-label", "tabindex"], Txe = ["tabindex", "aria-label"], kxe = ["aria-current", "aria-label", "tabindex"], Pxe = U({
  name: "ElPaginationPager"
}), Exe = /* @__PURE__ */ U({
  ...Pxe,
  props: xxe,
  emits: ["change"],
  setup(n, { emit: e }) {
    const t = n, r = Pe("pager"), i = Pe("icon"), { t: o } = Ar(), a = z(!1), s = z(!1), l = z(!1), u = z(!1), c = z(!1), h = z(!1), f = B(() => {
      const O = t.pagerCount, w = (O - 1) / 2, x = Number(t.currentPage), S = Number(t.pageCount);
      let _ = !1, C = !1;
      S > O && (x > O - w && (_ = !0), x < S - w && (C = !0));
      const A = [];
      if (_ && !C) {
        const k = S - (O - 2);
        for (let P = k; P < S; P++)
          A.push(P);
      } else if (!_ && C)
        for (let k = 2; k < O; k++)
          A.push(k);
      else if (_ && C) {
        const k = Math.floor(O / 2) - 1;
        for (let P = x - k; P <= x + k; P++)
          A.push(P);
      } else
        for (let k = 2; k < S; k++)
          A.push(k);
      return A;
    }), d = B(() => [
      "more",
      "btn-quickprev",
      i.b(),
      r.is("disabled", t.disabled)
    ]), p = B(() => [
      "more",
      "btn-quicknext",
      i.b(),
      r.is("disabled", t.disabled)
    ]), g = B(() => t.disabled ? -1 : 0);
    sl(() => {
      const O = (t.pagerCount - 1) / 2;
      a.value = !1, s.value = !1, t.pageCount > t.pagerCount && (t.currentPage > t.pagerCount - O && (a.value = !0), t.currentPage < t.pageCount - O && (s.value = !0));
    });
    function v(O = !1) {
      t.disabled || (O ? l.value = !0 : u.value = !0);
    }
    function m(O = !1) {
      O ? c.value = !0 : h.value = !0;
    }
    function y(O) {
      const w = O.target;
      if (w.tagName.toLowerCase() === "li" && Array.from(w.classList).includes("number")) {
        const x = Number(w.textContent);
        x !== t.currentPage && e("change", x);
      } else
        w.tagName.toLowerCase() === "li" && Array.from(w.classList).includes("more") && b(O);
    }
    function b(O) {
      const w = O.target;
      if (w.tagName.toLowerCase() === "ul" || t.disabled)
        return;
      let x = Number(w.textContent);
      const S = t.pageCount, _ = t.currentPage, C = t.pagerCount - 2;
      w.className.includes("more") && (w.className.includes("quickprev") ? x = _ - C : w.className.includes("quicknext") && (x = _ + C)), Number.isNaN(+x) || (x < 1 && (x = 1), x > S && (x = S)), x !== _ && e("change", x);
    }
    return (O, w) => (V(), q("ul", {
      class: Q(T(r).b()),
      onClick: b,
      onKeyup: Rr(y, ["enter"])
    }, [
      O.pageCount > 0 ? (V(), q("li", {
        key: 0,
        class: Q([[
          T(r).is("active", O.currentPage === 1),
          T(r).is("disabled", O.disabled)
        ], "number"]),
        "aria-current": O.currentPage === 1,
        "aria-label": T(o)("el.pagination.currentPage", { pager: 1 }),
        tabindex: T(g)
      }, " 1 ", 10, _xe)) : pe("v-if", !0),
      a.value ? (V(), q("li", {
        key: 1,
        class: Q(T(d)),
        tabindex: T(g),
        "aria-label": T(o)("el.pagination.prevPages", { pager: O.pagerCount - 2 }),
        onMouseenter: w[0] || (w[0] = (x) => v(!0)),
        onMouseleave: w[1] || (w[1] = (x) => l.value = !1),
        onFocus: w[2] || (w[2] = (x) => m(!0)),
        onBlur: w[3] || (w[3] = (x) => c.value = !1)
      }, [
        (l.value || c.value) && !O.disabled ? (V(), ve(T(rpe), { key: 0 })) : (V(), ve(T(y3), { key: 1 }))
      ], 42, Cxe)) : pe("v-if", !0),
      (V(!0), q(yn, null, qi(T(f), (x) => (V(), q("li", {
        key: x,
        class: Q([[
          T(r).is("active", O.currentPage === x),
          T(r).is("disabled", O.disabled)
        ], "number"]),
        "aria-current": O.currentPage === x,
        "aria-label": T(o)("el.pagination.currentPage", { pager: x }),
        tabindex: T(g)
      }, ze(x), 11, Axe))), 128)),
      s.value ? (V(), q("li", {
        key: 2,
        class: Q(T(p)),
        tabindex: T(g),
        "aria-label": T(o)("el.pagination.nextPages", { pager: O.pagerCount - 2 }),
        onMouseenter: w[4] || (w[4] = (x) => v()),
        onMouseleave: w[5] || (w[5] = (x) => u.value = !1),
        onFocus: w[6] || (w[6] = (x) => m()),
        onBlur: w[7] || (w[7] = (x) => h.value = !1)
      }, [
        (u.value || h.value) && !O.disabled ? (V(), ve(T(ope), { key: 0 })) : (V(), ve(T(y3), { key: 1 }))
      ], 42, Txe)) : pe("v-if", !0),
      O.pageCount > 1 ? (V(), q("li", {
        key: 3,
        class: Q([[
          T(r).is("active", O.currentPage === O.pageCount),
          T(r).is("disabled", O.disabled)
        ], "number"]),
        "aria-current": O.currentPage === O.pageCount,
        "aria-label": T(o)("el.pagination.currentPage", { pager: O.pageCount }),
        tabindex: T(g)
      }, ze(O.pageCount), 11, kxe)) : pe("v-if", !0)
    ], 42, Sxe));
  }
});
var Mxe = /* @__PURE__ */ Ve(Exe, [["__file", "pager.vue"]]);
const zi = (n) => typeof n != "number", Dxe = Ye({
  pageSize: Number,
  defaultPageSize: Number,
  total: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (n) => _t(n) && Math.trunc(n) === n && n > 4 && n < 22 && n % 2 === 1,
    default: 7
  },
  currentPage: Number,
  defaultCurrentPage: Number,
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: Ae(Array),
    default: () => ih([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: $r,
    default: () => vL
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: $r,
    default: () => Sd
  },
  teleported: {
    type: Boolean,
    default: !0
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
}), Lxe = {
  "update:current-page": (n) => _t(n),
  "update:page-size": (n) => _t(n),
  "size-change": (n) => _t(n),
  change: (n, e) => _t(n) && _t(e),
  "current-change": (n) => _t(n),
  "prev-click": (n) => _t(n),
  "next-click": (n) => _t(n)
}, DB = "ElPagination";
var Ixe = U({
  name: DB,
  props: Dxe,
  emits: Lxe,
  setup(n, { emit: e, slots: t }) {
    const { t: r } = Ar(), i = Pe("pagination"), o = wt().vnode.props || {}, a = "onUpdate:currentPage" in o || "onUpdate:current-page" in o || "onCurrentChange" in o, s = "onUpdate:pageSize" in o || "onUpdate:page-size" in o || "onSizeChange" in o, l = B(() => {
      if (zi(n.total) && zi(n.pageCount) || !zi(n.currentPage) && !a)
        return !1;
      if (n.layout.includes("sizes")) {
        if (zi(n.pageCount)) {
          if (!zi(n.total) && !zi(n.pageSize) && !s)
            return !1;
        } else if (!s)
          return !1;
      }
      return !0;
    }), u = z(zi(n.defaultPageSize) ? 10 : n.defaultPageSize), c = z(zi(n.defaultCurrentPage) ? 1 : n.defaultCurrentPage), h = B({
      get() {
        return zi(n.pageSize) ? u.value : n.pageSize;
      },
      set(b) {
        zi(n.pageSize) && (u.value = b), s && (e("update:page-size", b), e("size-change", b));
      }
    }), f = B(() => {
      let b = 0;
      return zi(n.pageCount) ? zi(n.total) || (b = Math.max(1, Math.ceil(n.total / h.value))) : b = n.pageCount, b;
    }), d = B({
      get() {
        return zi(n.currentPage) ? c.value : n.currentPage;
      },
      set(b) {
        let O = b;
        b < 1 ? O = 1 : b > f.value && (O = f.value), zi(n.currentPage) && (c.value = O), a && (e("update:current-page", O), e("current-change", O));
      }
    });
    he(f, (b) => {
      d.value > b && (d.value = b);
    }), he([d, h], (b) => {
      e("change", ...b);
    }, { flush: "post" });
    function p(b) {
      d.value = b;
    }
    function g(b) {
      h.value = b;
      const O = f.value;
      d.value > O && (d.value = O);
    }
    function v() {
      n.disabled || (d.value -= 1, e("prev-click", d.value));
    }
    function m() {
      n.disabled || (d.value += 1, e("next-click", d.value));
    }
    function y(b, O) {
      b && (b.props || (b.props = {}), b.props.class = [b.props.class, O].join(" "));
    }
    return Wt(MH, {
      pageCount: f,
      disabled: B(() => n.disabled),
      currentPage: d,
      changeEvent: p,
      handleSizeChange: g
    }), () => {
      var b, O;
      if (!l.value)
        return Ht(DB, r("el.pagination.deprecationWarning")), null;
      if (!n.layout || n.hideOnSinglePage && f.value <= 1)
        return null;
      const w = [], x = [], S = et("div", { class: i.e("rightwrapper") }, x), _ = {
        prev: et(Iwe, {
          disabled: n.disabled,
          currentPage: d.value,
          prevText: n.prevText,
          prevIcon: n.prevIcon,
          onClick: v
        }),
        jumper: et(vxe, {
          size: n.small ? "small" : "default"
        }),
        pager: et(Mxe, {
          currentPage: d.value,
          pageCount: f.value,
          pagerCount: n.pagerCount,
          onChange: p,
          disabled: n.disabled
        }),
        next: et(zwe, {
          disabled: n.disabled,
          currentPage: d.value,
          pageCount: f.value,
          nextText: n.nextText,
          nextIcon: n.nextIcon,
          onClick: m
        }),
        sizes: et(hxe, {
          pageSize: h.value,
          pageSizes: n.pageSizes,
          popperClass: n.popperClass,
          disabled: n.disabled,
          teleported: n.teleported,
          size: n.small ? "small" : "default"
        }),
        slot: (O = (b = t == null ? void 0 : t.default) == null ? void 0 : b.call(t)) != null ? O : null,
        total: et(wxe, { total: zi(n.total) ? 0 : n.total })
      }, C = n.layout.split(",").map((k) => k.trim());
      let A = !1;
      return C.forEach((k) => {
        if (k === "->") {
          A = !0;
          return;
        }
        A ? x.push(_[k]) : w.push(_[k]);
      }), y(w[0], i.is("first")), y(w[w.length - 1], i.is("last")), A && x.length > 0 && (y(x[0], i.is("first")), y(x[x.length - 1], i.is("last")), w.push(S)), et("div", {
        class: [
          i.b(),
          i.is("background", n.background),
          {
            [i.m("small")]: n.small
          }
        ]
      }, w);
    };
  }
});
const c6t = zn(Ixe), Rxe = Ye({
  trigger: e0.trigger,
  placement: m2.placement,
  disabled: e0.disabled,
  visible: po.visible,
  transition: po.transition,
  popperOptions: m2.popperOptions,
  tabindex: m2.tabindex,
  content: po.content,
  popperStyle: po.popperStyle,
  popperClass: po.popperClass,
  enterable: {
    ...po.enterable,
    default: !0
  },
  effect: {
    ...po.effect,
    default: "light"
  },
  teleported: po.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), Nxe = {
  "update:visible": (n) => pi(n),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, $xe = "onUpdate:visible", Bxe = U({
  name: "ElPopover"
}), Vxe = /* @__PURE__ */ U({
  ...Bxe,
  props: Rxe,
  emits: Nxe,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = B(() => r[$xe]), o = Pe("popover"), a = z(), s = B(() => {
      var v;
      return (v = T(a)) == null ? void 0 : v.popperRef;
    }), l = B(() => [
      {
        width: Xo(r.width)
      },
      r.popperStyle
    ]), u = B(() => [o.b(), r.popperClass, { [o.m("plain")]: !!r.content }]), c = B(() => r.transition === `${o.namespace.value}-fade-in-linear`), h = () => {
      var v;
      (v = a.value) == null || v.hide();
    }, f = () => {
      t("before-enter");
    }, d = () => {
      t("before-leave");
    }, p = () => {
      t("after-enter");
    }, g = () => {
      t("update:visible", !1), t("after-leave");
    };
    return e({
      popperRef: s,
      hide: h
    }), (v, m) => (V(), ve(T(Uf), xa({
      ref_key: "tooltipRef",
      ref: a
    }, v.$attrs, {
      trigger: v.trigger,
      placement: v.placement,
      disabled: v.disabled,
      visible: v.visible,
      transition: v.transition,
      "popper-options": v.popperOptions,
      tabindex: v.tabindex,
      content: v.content,
      offset: v.offset,
      "show-after": v.showAfter,
      "hide-after": v.hideAfter,
      "auto-close": v.autoClose,
      "show-arrow": v.showArrow,
      "aria-label": v.title,
      effect: v.effect,
      enterable: v.enterable,
      "popper-class": T(u),
      "popper-style": T(l),
      teleported: v.teleported,
      persistent: v.persistent,
      "gpu-acceleration": T(c),
      "onUpdate:visible": T(i),
      onBeforeShow: f,
      onBeforeHide: d,
      onShow: p,
      onHide: g
    }), {
      content: fe(() => [
        v.title ? (V(), q("div", {
          key: 0,
          class: Q(T(o).e("title")),
          role: "title"
        }, ze(v.title), 3)) : pe("v-if", !0),
        ke(v.$slots, "default", {}, () => [
          Ri(ze(v.content), 1)
        ])
      ]),
      default: fe(() => [
        v.$slots.reference ? ke(v.$slots, "reference", { key: 0 }) : pe("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var zxe = /* @__PURE__ */ Ve(Vxe, [["__file", "popover.vue"]]);
const LB = (n, e) => {
  const t = e.arg || e.value, r = t == null ? void 0 : t.popperRef;
  r && (r.triggerRef = n);
};
var Fxe = {
  mounted(n, e) {
    LB(n, e);
  },
  updated(n, e) {
    LB(n, e);
  }
};
const Qxe = "popover", Zxe = vve(Fxe, Qxe), h6t = zn(zxe, {
  directive: Zxe
}), Wxe = Ye({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (n) => n >= 0 && n <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: Ae(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: Ae([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: Ae(Function),
    default: (n) => `${n}%`
  }
}), Gxe = ["aria-valuenow"], jxe = { viewBox: "0 0 100 100" }, Hxe = ["d", "stroke", "stroke-linecap", "stroke-width"], qxe = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], Yxe = { key: 0 }, Xxe = U({
  name: "ElProgress"
}), Uxe = /* @__PURE__ */ U({
  ...Xxe,
  props: Wxe,
  setup(n) {
    const e = n, t = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, r = Pe("progress"), i = B(() => ({
      width: `${e.percentage}%`,
      animationDuration: `${e.duration}s`,
      backgroundColor: y(e.percentage)
    })), o = B(() => (e.strokeWidth / e.width * 100).toFixed(1)), a = B(() => ["circle", "dashboard"].includes(e.type) ? Number.parseInt(`${50 - Number.parseFloat(o.value) / 2}`, 10) : 0), s = B(() => {
      const b = a.value, O = e.type === "dashboard";
      return `
          M 50 50
          m 0 ${O ? "" : "-"}${b}
          a ${b} ${b} 0 1 1 0 ${O ? "-" : ""}${b * 2}
          a ${b} ${b} 0 1 1 0 ${O ? "" : "-"}${b * 2}
          `;
    }), l = B(() => 2 * Math.PI * a.value), u = B(() => e.type === "dashboard" ? 0.75 : 1), c = B(() => `${-1 * l.value * (1 - u.value) / 2}px`), h = B(() => ({
      strokeDasharray: `${l.value * u.value}px, ${l.value}px`,
      strokeDashoffset: c.value
    })), f = B(() => ({
      strokeDasharray: `${l.value * u.value * (e.percentage / 100)}px, ${l.value}px`,
      strokeDashoffset: c.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), d = B(() => {
      let b;
      return e.color ? b = y(e.percentage) : b = t[e.status] || t.default, b;
    }), p = B(() => e.status === "warning" ? yL : e.type === "line" ? e.status === "success" ? Xj : gb : e.status === "success" ? mL : Pc), g = B(() => e.type === "line" ? 12 + e.strokeWidth * 0.4 : e.width * 0.111111 + 2), v = B(() => e.format(e.percentage));
    function m(b) {
      const O = 100 / b.length;
      return b.map((x, S) => Ut(x) ? {
        color: x,
        percentage: (S + 1) * O
      } : x).sort((x, S) => x.percentage - S.percentage);
    }
    const y = (b) => {
      var O;
      const { color: w } = e;
      if (fn(w))
        return w(b);
      if (Ut(w))
        return w;
      {
        const x = m(w);
        for (const S of x)
          if (S.percentage > b)
            return S.color;
        return (O = x[x.length - 1]) == null ? void 0 : O.color;
      }
    };
    return (b, O) => (V(), q("div", {
      class: Q([
        T(r).b(),
        T(r).m(b.type),
        T(r).is(b.status),
        {
          [T(r).m("without-text")]: !b.showText,
          [T(r).m("text-inside")]: b.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": b.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      b.type === "line" ? (V(), q("div", {
        key: 0,
        class: Q(T(r).b("bar"))
      }, [
        J("div", {
          class: Q(T(r).be("bar", "outer")),
          style: vt({ height: `${b.strokeWidth}px` })
        }, [
          J("div", {
            class: Q([
              T(r).be("bar", "inner"),
              { [T(r).bem("bar", "inner", "indeterminate")]: b.indeterminate },
              { [T(r).bem("bar", "inner", "striped")]: b.striped },
              { [T(r).bem("bar", "inner", "striped-flow")]: b.stripedFlow }
            ]),
            style: vt(T(i))
          }, [
            (b.showText || b.$slots.default) && b.textInside ? (V(), q("div", {
              key: 0,
              class: Q(T(r).be("bar", "innerText"))
            }, [
              ke(b.$slots, "default", { percentage: b.percentage }, () => [
                J("span", null, ze(T(v)), 1)
              ])
            ], 2)) : pe("v-if", !0)
          ], 6)
        ], 6)
      ], 2)) : (V(), q("div", {
        key: 1,
        class: Q(T(r).b("circle")),
        style: vt({ height: `${b.width}px`, width: `${b.width}px` })
      }, [
        (V(), q("svg", jxe, [
          J("path", {
            class: Q(T(r).be("circle", "track")),
            d: T(s),
            stroke: `var(${T(r).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": b.strokeLinecap,
            "stroke-width": T(o),
            fill: "none",
            style: vt(T(h))
          }, null, 14, Hxe),
          J("path", {
            class: Q(T(r).be("circle", "path")),
            d: T(s),
            stroke: T(d),
            fill: "none",
            opacity: b.percentage ? 1 : 0,
            "stroke-linecap": b.strokeLinecap,
            "stroke-width": T(o),
            style: vt(T(f))
          }, null, 14, qxe)
        ]))
      ], 6)),
      (b.showText || b.$slots.default) && !b.textInside ? (V(), q("div", {
        key: 2,
        class: Q(T(r).e("text")),
        style: vt({ fontSize: `${T(g)}px` })
      }, [
        ke(b.$slots, "default", { percentage: b.percentage }, () => [
          b.status ? (V(), ve(T(bt), { key: 1 }, {
            default: fe(() => [
              (V(), ve(cn(T(p))))
            ]),
            _: 1
          })) : (V(), q("span", Yxe, ze(T(v)), 1))
        ])
      ], 6)) : pe("v-if", !0)
    ], 10, Gxe));
  }
});
var Kxe = /* @__PURE__ */ Ve(Uxe, [["__file", "progress.vue"]]);
const f6t = zn(Kxe), Jxe = Ye({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  size: {
    type: String,
    validator: v7
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  inactiveActionIcon: {
    type: $r
  },
  activeActionIcon: {
    type: $r
  },
  activeIcon: {
    type: $r
  },
  inactiveIcon: {
    type: $r
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  beforeChange: {
    type: Ae(Function)
  },
  id: String,
  tabindex: {
    type: [String, Number]
  },
  value: {
    type: [Boolean, String, Number],
    default: !1
  },
  label: {
    type: String,
    default: void 0
  }
}), eSe = {
  [Dt]: (n) => pi(n) || Ut(n) || _t(n),
  [yi]: (n) => pi(n) || Ut(n) || _t(n),
  [Df]: (n) => pi(n) || Ut(n) || _t(n)
}, tSe = ["onClick"], nSe = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], rSe = ["aria-hidden"], iSe = ["aria-hidden"], oSe = ["aria-hidden"], pw = "ElSwitch", aSe = U({
  name: pw
}), sSe = /* @__PURE__ */ U({
  ...aSe,
  props: Jxe,
  emits: eSe,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = wt(), { formItem: o } = Na(), a = ko(), s = Pe("switch");
    ((_) => {
      _.forEach((C) => {
        Xf({
          from: C[0],
          replacement: C[1],
          scope: pw,
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/switch.html#attributes",
          type: "Attribute"
        }, B(() => {
          var A;
          return !!((A = i.vnode.props) != null && A[C[2]]);
        }));
      });
    })([
      ['"value"', '"model-value" or "v-model"', "value"],
      ['"active-color"', "CSS var `--el-switch-on-color`", "activeColor"],
      ['"inactive-color"', "CSS var `--el-switch-off-color`", "inactiveColor"],
      ['"border-color"', "CSS var `--el-switch-border-color`", "borderColor"]
    ]);
    const { inputId: u } = Ad(r, {
      formItemContext: o
    }), c = ah(B(() => r.loading)), h = z(r.modelValue !== !1), f = z(), d = z(), p = B(() => [
      s.b(),
      s.m(a.value),
      s.is("disabled", c.value),
      s.is("checked", b.value)
    ]), g = B(() => [
      s.e("label"),
      s.em("label", "left"),
      s.is("active", !b.value)
    ]), v = B(() => [
      s.e("label"),
      s.em("label", "right"),
      s.is("active", b.value)
    ]), m = B(() => ({
      width: Xo(r.width)
    }));
    he(() => r.modelValue, () => {
      h.value = !0;
    }), he(() => r.value, () => {
      h.value = !1;
    });
    const y = B(() => h.value ? r.modelValue : r.value), b = B(() => y.value === r.activeValue);
    [r.activeValue, r.inactiveValue].includes(y.value) || (t(Dt, r.inactiveValue), t(yi, r.inactiveValue), t(Df, r.inactiveValue)), he(b, (_) => {
      var C;
      f.value.checked = _, r.validateEvent && ((C = o == null ? void 0 : o.validate) == null || C.call(o, "change").catch((A) => Ht(A)));
    });
    const O = () => {
      const _ = b.value ? r.inactiveValue : r.activeValue;
      t(Dt, _), t(yi, _), t(Df, _), Ke(() => {
        f.value.checked = b.value;
      });
    }, w = () => {
      if (c.value)
        return;
      const { beforeChange: _ } = r;
      if (!_) {
        O();
        return;
      }
      const C = _();
      [
        rP(C),
        pi(C)
      ].includes(!0) || Su(pw, "beforeChange must return type `Promise<boolean>` or `boolean`"), rP(C) ? C.then((k) => {
        k && O();
      }).catch((k) => {
        Ht(pw, `some error occurred: ${k}`);
      }) : C && O();
    }, x = B(() => s.cssVarBlock({
      ...r.activeColor ? { "on-color": r.activeColor } : null,
      ...r.inactiveColor ? { "off-color": r.inactiveColor } : null,
      ...r.borderColor ? { "border-color": r.borderColor } : null
    })), S = () => {
      var _, C;
      (C = (_ = f.value) == null ? void 0 : _.focus) == null || C.call(_);
    };
    return ht(() => {
      f.value.checked = b.value;
    }), e({
      focus: S,
      checked: b
    }), (_, C) => (V(), q("div", {
      class: Q(T(p)),
      style: vt(T(x)),
      onClick: kt(w, ["prevent"])
    }, [
      J("input", {
        id: T(u),
        ref_key: "input",
        ref: f,
        class: Q(T(s).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": T(b),
        "aria-disabled": T(c),
        "aria-label": _.label,
        name: _.name,
        "true-value": _.activeValue,
        "false-value": _.inactiveValue,
        disabled: T(c),
        tabindex: _.tabindex,
        onChange: O,
        onKeydown: Rr(w, ["enter"])
      }, null, 42, nSe),
      !_.inlinePrompt && (_.inactiveIcon || _.inactiveText) ? (V(), q("span", {
        key: 0,
        class: Q(T(g))
      }, [
        _.inactiveIcon ? (V(), ve(T(bt), { key: 0 }, {
          default: fe(() => [
            (V(), ve(cn(_.inactiveIcon)))
          ]),
          _: 1
        })) : pe("v-if", !0),
        !_.inactiveIcon && _.inactiveText ? (V(), q("span", {
          key: 1,
          "aria-hidden": T(b)
        }, ze(_.inactiveText), 9, rSe)) : pe("v-if", !0)
      ], 2)) : pe("v-if", !0),
      J("span", {
        ref_key: "core",
        ref: d,
        class: Q(T(s).e("core")),
        style: vt(T(m))
      }, [
        _.inlinePrompt ? (V(), q("div", {
          key: 0,
          class: Q(T(s).e("inner"))
        }, [
          _.activeIcon || _.inactiveIcon ? (V(), ve(T(bt), {
            key: 0,
            class: Q(T(s).is("icon"))
          }, {
            default: fe(() => [
              (V(), ve(cn(T(b) ? _.activeIcon : _.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : _.activeText || _.inactiveText ? (V(), q("span", {
            key: 1,
            class: Q(T(s).is("text")),
            "aria-hidden": !T(b)
          }, ze(T(b) ? _.activeText : _.inactiveText), 11, iSe)) : pe("v-if", !0)
        ], 2)) : pe("v-if", !0),
        J("div", {
          class: Q(T(s).e("action"))
        }, [
          _.loading ? (V(), ve(T(bt), {
            key: 0,
            class: Q(T(s).is("loading"))
          }, {
            default: fe(() => [
              de(T(_d))
            ]),
            _: 1
          }, 8, ["class"])) : T(b) ? ke(_.$slots, "active-action", { key: 1 }, () => [
            _.activeActionIcon ? (V(), ve(T(bt), { key: 0 }, {
              default: fe(() => [
                (V(), ve(cn(_.activeActionIcon)))
              ]),
              _: 1
            })) : pe("v-if", !0)
          ]) : T(b) ? pe("v-if", !0) : ke(_.$slots, "inactive-action", { key: 2 }, () => [
            _.inactiveActionIcon ? (V(), ve(T(bt), { key: 0 }, {
              default: fe(() => [
                (V(), ve(cn(_.inactiveActionIcon)))
              ]),
              _: 1
            })) : pe("v-if", !0)
          ])
        ], 2)
      ], 6),
      !_.inlinePrompt && (_.activeIcon || _.activeText) ? (V(), q("span", {
        key: 1,
        class: Q(T(v))
      }, [
        _.activeIcon ? (V(), ve(T(bt), { key: 0 }, {
          default: fe(() => [
            (V(), ve(cn(_.activeIcon)))
          ]),
          _: 1
        })) : pe("v-if", !0),
        !_.activeIcon && _.activeText ? (V(), q("span", {
          key: 1,
          "aria-hidden": !T(b)
        }, ze(_.activeText), 9, oSe)) : pe("v-if", !0)
      ], 2)) : pe("v-if", !0)
    ], 14, tSe));
  }
});
var lSe = /* @__PURE__ */ Ve(sSe, [["__file", "switch.vue"]]);
const d6t = zn(lSe), y2 = function(n) {
  var e;
  return (e = n.target) == null ? void 0 : e.closest("td");
}, uSe = function(n, e, t, r, i) {
  if (!e && !r && (!i || Array.isArray(i) && !i.length))
    return n;
  typeof t == "string" ? t = t === "descending" ? -1 : 1 : t = t && t < 0 ? -1 : 1;
  const o = r ? null : function(s, l) {
    return i ? (Array.isArray(i) || (i = [i]), i.map((u) => typeof u == "string" ? ga(s, u) : u(s, l, n))) : (e !== "$key" && Nr(s) && "$value" in s && (s = s.$value), [Nr(s) ? ga(s, e) : s]);
  }, a = function(s, l) {
    if (r)
      return r(s.value, l.value);
    for (let u = 0, c = s.key.length; u < c; u++) {
      if (s.key[u] < l.key[u])
        return -1;
      if (s.key[u] > l.key[u])
        return 1;
    }
    return 0;
  };
  return n.map((s, l) => ({
    value: s,
    index: l,
    key: o ? o(s, l) : null
  })).sort((s, l) => {
    let u = a(s, l);
    return u || (u = s.index - l.index), u * +t;
  }).map((s) => s.value);
}, IH = function(n, e) {
  let t = null;
  return n.columns.forEach((r) => {
    r.id === e && (t = r);
  }), t;
}, cSe = function(n, e) {
  let t = null;
  for (let r = 0; r < n.columns.length; r++) {
    const i = n.columns[r];
    if (i.columnKey === e) {
      t = i;
      break;
    }
  }
  return t || Su("ElTable", `No column matching with column-key: ${e}`), t;
}, IB = function(n, e, t) {
  const r = (e.className || "").match(new RegExp(`${t}-table_[^\\s]+`, "gm"));
  return r ? IH(n, r[0]) : null;
}, li = (n, e) => {
  if (!n)
    throw new Error("Row is required when get row identity");
  if (typeof e == "string") {
    if (!e.includes("."))
      return `${n[e]}`;
    const t = e.split(".");
    let r = n;
    for (const i of t)
      r = r[i];
    return `${r}`;
  } else if (typeof e == "function")
    return e.call(null, n);
}, pf = function(n, e) {
  const t = {};
  return (n || []).forEach((r, i) => {
    t[li(r, e)] = { row: r, index: i };
  }), t;
};
function hSe(n, e) {
  const t = {};
  let r;
  for (r in n)
    t[r] = n[r];
  for (r in e)
    if (To(e, r)) {
      const i = e[r];
      typeof i < "u" && (t[r] = i);
    }
  return t;
}
function GL(n) {
  return n === "" || n !== void 0 && (n = Number.parseInt(n, 10), Number.isNaN(n) && (n = "")), n;
}
function RH(n) {
  return n === "" || n !== void 0 && (n = GL(n), Number.isNaN(n) && (n = 80)), n;
}
function fSe(n) {
  return typeof n == "number" ? n : typeof n == "string" ? /^\d+(?:px)?$/.test(n) ? Number.parseInt(n, 10) : n : null;
}
function dSe(...n) {
  return n.length === 0 ? (e) => e : n.length === 1 ? n[0] : n.reduce((e, t) => (...r) => e(t(...r)));
}
function dy(n, e, t) {
  let r = !1;
  const i = n.indexOf(e), o = i !== -1, a = (s) => {
    s === "add" ? n.push(e) : n.splice(i, 1), r = !0, _n(e.children) && e.children.forEach((l) => {
      dy(n, l, t ?? !o);
    });
  };
  return pi(t) ? t && !o ? a("add") : !t && o && a("remove") : a(o ? "remove" : "add"), r;
}
function pSe(n, e, t = "children", r = "hasChildren") {
  const i = (a) => !(Array.isArray(a) && a.length);
  function o(a, s, l) {
    e(a, s, l), s.forEach((u) => {
      if (u[r]) {
        e(u, null, l + 1);
        return;
      }
      const c = u[t];
      i(c) || o(u, c, l + 1);
    });
  }
  n.forEach((a) => {
    if (a[r]) {
      e(a, null, 0);
      return;
    }
    const s = a[t];
    i(s) || o(a, s, 0);
  });
}
let ia = null;
function gSe(n, e, t, r) {
  if ((ia == null ? void 0 : ia.trigger) === t)
    return;
  ia == null || ia();
  const i = r == null ? void 0 : r.refs.tableWrapper, o = i == null ? void 0 : i.dataset.prefix, a = {
    strategy: "fixed",
    ...n.popperOptions
  }, s = de(Uf, {
    content: e,
    virtualTriggering: !0,
    virtualRef: t,
    appendTo: i,
    placement: "top",
    transition: "none",
    offset: 0,
    hideAfter: 0,
    ...n,
    popperOptions: a,
    onHide: () => {
      ia == null || ia();
    }
  });
  s.appContext = { ...r.appContext, ...r };
  const l = document.createElement("div");
  Tc(s, l), s.component.exposed.onOpen();
  const u = i == null ? void 0 : i.querySelector(`.${o}-scrollbar__wrap`);
  ia = () => {
    Tc(null, l), u == null || u.removeEventListener("scroll", ia), ia = null;
  }, ia.trigger = t, u == null || u.addEventListener("scroll", ia);
}
function NH(n) {
  return n.children ? Yfe(n.children, NH) : [n];
}
function RB(n, e) {
  return n + e.colSpan;
}
const $H = (n, e, t, r) => {
  let i = 0, o = n;
  const a = t.states.columns.value;
  if (r) {
    const l = NH(r[n]);
    i = a.slice(0, a.indexOf(l[0])).reduce(RB, 0), o = i + l.reduce(RB, 0) - 1;
  } else
    i = n;
  let s;
  switch (e) {
    case "left":
      o < t.states.fixedLeafColumnsLength.value && (s = "left");
      break;
    case "right":
      i >= a.length - t.states.rightFixedLeafColumnsLength.value && (s = "right");
      break;
    default:
      o < t.states.fixedLeafColumnsLength.value ? s = "left" : i >= a.length - t.states.rightFixedLeafColumnsLength.value && (s = "right");
  }
  return s ? {
    direction: s,
    start: i,
    after: o
  } : {};
}, jL = (n, e, t, r, i, o = 0) => {
  const a = [], { direction: s, start: l, after: u } = $H(e, t, r, i);
  if (s) {
    const c = s === "left";
    a.push(`${n}-fixed-column--${s}`), c && u + o === r.states.fixedLeafColumnsLength.value - 1 ? a.push("is-last-column") : !c && l - o === r.states.columns.value.length - r.states.rightFixedLeafColumnsLength.value && a.push("is-first-column");
  }
  return a;
};
function NB(n, e) {
  return n + (e.realWidth === null || Number.isNaN(e.realWidth) ? Number(e.width) : e.realWidth);
}
const HL = (n, e, t, r) => {
  const {
    direction: i,
    start: o = 0,
    after: a = 0
  } = $H(n, e, t, r);
  if (!i)
    return;
  const s = {}, l = i === "left", u = t.states.columns.value;
  return l ? s.left = u.slice(0, o).reduce(NB, 0) : s.right = u.slice(a + 1).reverse().reduce(NB, 0), s;
}, bg = (n, e) => {
  n && (Number.isNaN(n[e]) || (n[e] = `${n[e]}px`));
};
function vSe(n) {
  const e = wt(), t = z(!1), r = z([]);
  return {
    updateExpandRows: () => {
      const l = n.data.value || [], u = n.rowKey.value;
      if (t.value)
        r.value = l.slice();
      else if (u) {
        const c = pf(r.value, u);
        r.value = l.reduce((h, f) => {
          const d = li(f, u);
          return c[d] && h.push(f), h;
        }, []);
      } else
        r.value = [];
    },
    toggleRowExpansion: (l, u) => {
      dy(r.value, l, u) && e.emit("expand-change", l, r.value.slice());
    },
    setExpandRowKeys: (l) => {
      e.store.assertRowKey();
      const u = n.data.value || [], c = n.rowKey.value, h = pf(u, c);
      r.value = l.reduce((f, d) => {
        const p = h[d];
        return p && f.push(p.row), f;
      }, []);
    },
    isRowExpanded: (l) => {
      const u = n.rowKey.value;
      return u ? !!pf(r.value, u)[li(l, u)] : r.value.includes(l);
    },
    states: {
      expandRows: r,
      defaultExpandAll: t
    }
  };
}
function mSe(n) {
  const e = wt(), t = z(null), r = z(null), i = (u) => {
    e.store.assertRowKey(), t.value = u, a(u);
  }, o = () => {
    t.value = null;
  }, a = (u) => {
    const { data: c, rowKey: h } = n;
    let f = null;
    h.value && (f = (T(c) || []).find((d) => li(d, h.value) === u)), r.value = f, e.emit("current-change", r.value, null);
  };
  return {
    setCurrentRowKey: i,
    restoreCurrentRowKey: o,
    setCurrentRowByKey: a,
    updateCurrentRow: (u) => {
      const c = r.value;
      if (u && u !== c) {
        r.value = u, e.emit("current-change", r.value, c);
        return;
      }
      !u && c && (r.value = null, e.emit("current-change", null, c));
    },
    updateCurrentRowData: () => {
      const u = n.rowKey.value, c = n.data.value || [], h = r.value;
      if (!c.includes(h) && h) {
        if (u) {
          const f = li(h, u);
          a(f);
        } else
          r.value = null;
        r.value === null && e.emit("current-change", null, h);
      } else
        t.value && (a(t.value), o());
    },
    states: {
      _currentRowKey: t,
      currentRow: r
    }
  };
}
function ySe(n) {
  const e = z([]), t = z({}), r = z(16), i = z(!1), o = z({}), a = z("hasChildren"), s = z("children"), l = wt(), u = B(() => {
    if (!n.rowKey.value)
      return {};
    const m = n.data.value || [];
    return h(m);
  }), c = B(() => {
    const m = n.rowKey.value, y = Object.keys(o.value), b = {};
    return y.length && y.forEach((O) => {
      if (o.value[O].length) {
        const w = { children: [] };
        o.value[O].forEach((x) => {
          const S = li(x, m);
          w.children.push(S), x[a.value] && !b[S] && (b[S] = { children: [] });
        }), b[O] = w;
      }
    }), b;
  }), h = (m) => {
    const y = n.rowKey.value, b = {};
    return pSe(m, (O, w, x) => {
      const S = li(O, y);
      Array.isArray(w) ? b[S] = {
        children: w.map((_) => li(_, y)),
        level: x
      } : i.value && (b[S] = {
        children: [],
        lazy: !0,
        level: x
      });
    }, s.value, a.value), b;
  }, f = (m = !1, y = ((b) => (b = l.store) == null ? void 0 : b.states.defaultExpandAll.value)()) => {
    var b;
    const O = u.value, w = c.value, x = Object.keys(O), S = {};
    if (x.length) {
      const _ = T(t), C = [], A = (P, L) => {
        if (m)
          return e.value ? y || e.value.includes(L) : !!(y || P != null && P.expanded);
        {
          const D = y || e.value && e.value.includes(L);
          return !!(P != null && P.expanded || D);
        }
      };
      x.forEach((P) => {
        const L = _[P], D = { ...O[P] };
        if (D.expanded = A(L, P), D.lazy) {
          const { loaded: E = !1, loading: M = !1 } = L || {};
          D.loaded = !!E, D.loading = !!M, C.push(P);
        }
        S[P] = D;
      });
      const k = Object.keys(w);
      i.value && k.length && C.length && k.forEach((P) => {
        const L = _[P], D = w[P].children;
        if (C.includes(P)) {
          if (S[P].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          S[P].children = D;
        } else {
          const { loaded: E = !1, loading: M = !1 } = L || {};
          S[P] = {
            lazy: !0,
            loaded: !!E,
            loading: !!M,
            expanded: A(L, P),
            children: D,
            level: ""
          };
        }
      });
    }
    t.value = S, (b = l.store) == null || b.updateTableScrollY();
  };
  he(() => e.value, () => {
    f(!0);
  }), he(() => u.value, () => {
    f();
  }), he(() => c.value, () => {
    f();
  });
  const d = (m) => {
    e.value = m, f();
  }, p = (m, y) => {
    l.store.assertRowKey();
    const b = n.rowKey.value, O = li(m, b), w = O && t.value[O];
    if (O && w && "expanded" in w) {
      const x = w.expanded;
      y = typeof y > "u" ? !w.expanded : y, t.value[O].expanded = y, x !== y && l.emit("expand-change", m, y), l.store.updateTableScrollY();
    }
  }, g = (m) => {
    l.store.assertRowKey();
    const y = n.rowKey.value, b = li(m, y), O = t.value[b];
    i.value && O && "loaded" in O && !O.loaded ? v(m, b, O) : p(m, void 0);
  }, v = (m, y, b) => {
    const { load: O } = l.props;
    O && !t.value[y].loaded && (t.value[y].loading = !0, O(m, b, (w) => {
      if (!Array.isArray(w))
        throw new TypeError("[ElTable] data must be an array");
      t.value[y].loading = !1, t.value[y].loaded = !0, t.value[y].expanded = !0, w.length && (o.value[y] = w), l.emit("expand-change", m, !0);
    }));
  };
  return {
    loadData: v,
    loadOrToggle: g,
    toggleTreeExpansion: p,
    updateTreeExpandKeys: d,
    updateTreeData: f,
    normalize: h,
    states: {
      expandRowKeys: e,
      treeData: t,
      indent: r,
      lazy: i,
      lazyTreeNodeMap: o,
      lazyColumnIdentifier: a,
      childrenColumnName: s
    }
  };
}
const bSe = (n, e) => {
  const t = e.sortingColumn;
  return !t || typeof t.sortable == "string" ? n : uSe(n, e.sortProp, e.sortOrder, t.sortMethod, t.sortBy);
}, gw = (n) => {
  const e = [];
  return n.forEach((t) => {
    t.children && t.children.length > 0 ? e.push.apply(e, gw(t.children)) : e.push(t);
  }), e;
};
function OSe() {
  var n;
  const e = wt(), { size: t } = bu((n = e.proxy) == null ? void 0 : n.$props), r = z(null), i = z([]), o = z([]), a = z(!1), s = z([]), l = z([]), u = z([]), c = z([]), h = z([]), f = z([]), d = z([]), p = z([]), g = [], v = z(0), m = z(0), y = z(0), b = z(!1), O = z([]), w = z(!1), x = z(!1), S = z(null), _ = z({}), C = z(null), A = z(null), k = z(null), P = z(null), L = z(null);
  he(i, () => e.state && R(!1), {
    deep: !0
  });
  const D = () => {
    if (!r.value)
      throw new Error("[ElTable] prop row-key is required");
  }, E = (Ge) => {
    var at;
    (at = Ge.children) == null || at.forEach((oe) => {
      oe.fixed = Ge.fixed, E(oe);
    });
  }, M = () => {
    s.value.forEach((Se) => {
      E(Se);
    }), c.value = s.value.filter((Se) => Se.fixed === !0 || Se.fixed === "left"), h.value = s.value.filter((Se) => Se.fixed === "right"), c.value.length > 0 && s.value[0] && s.value[0].type === "selection" && !s.value[0].fixed && (s.value[0].fixed = !0, c.value.unshift(s.value[0]));
    const Ge = s.value.filter((Se) => !Se.fixed);
    l.value = [].concat(c.value).concat(Ge).concat(h.value);
    const at = gw(Ge), oe = gw(c.value), ge = gw(h.value);
    v.value = at.length, m.value = oe.length, y.value = ge.length, u.value = [].concat(oe).concat(at).concat(ge), a.value = c.value.length > 0 || h.value.length > 0;
  }, R = (Ge, at = !1) => {
    Ge && M(), at ? e.state.doLayout() : e.state.debouncedUpdateLayout();
  }, N = (Ge) => O.value.includes(Ge), $ = () => {
    b.value = !1, O.value.length && (O.value = [], e.emit("selection-change", []));
  }, F = () => {
    let Ge;
    if (r.value) {
      Ge = [];
      const at = pf(O.value, r.value), oe = pf(i.value, r.value);
      for (const ge in at)
        To(at, ge) && !oe[ge] && Ge.push(at[ge].row);
    } else
      Ge = O.value.filter((at) => !i.value.includes(at));
    if (Ge.length) {
      const at = O.value.filter((oe) => !Ge.includes(oe));
      O.value = at, e.emit("selection-change", at.slice());
    }
  }, W = () => (O.value || []).slice(), j = (Ge, at = void 0, oe = !0) => {
    if (dy(O.value, Ge, at)) {
      const Se = (O.value || []).slice();
      oe && e.emit("select", Se, Ge), e.emit("selection-change", Se);
    }
  }, Y = () => {
    var Ge, at;
    const oe = x.value ? !b.value : !(b.value || O.value.length);
    b.value = oe;
    let ge = !1, Se = 0;
    const yt = (at = (Ge = e == null ? void 0 : e.store) == null ? void 0 : Ge.states) == null ? void 0 : at.rowKey.value;
    i.value.forEach((Fn, Tr) => {
      const ir = Tr + Se;
      S.value ? S.value.call(null, Fn, ir) && dy(O.value, Fn, oe) && (ge = !0) : dy(O.value, Fn, oe) && (ge = !0), Se += ae(li(Fn, yt));
    }), ge && e.emit("selection-change", O.value ? O.value.slice() : []), e.emit("select-all", O.value);
  }, X = () => {
    const Ge = pf(O.value, r.value);
    i.value.forEach((at) => {
      const oe = li(at, r.value), ge = Ge[oe];
      ge && (O.value[ge.index] = at);
    });
  }, ie = () => {
    var Ge, at, oe;
    if (((Ge = i.value) == null ? void 0 : Ge.length) === 0) {
      b.value = !1;
      return;
    }
    let ge;
    r.value && (ge = pf(O.value, r.value));
    const Se = function(ir) {
      return ge ? !!ge[li(ir, r.value)] : O.value.includes(ir);
    };
    let yt = !0, Fn = 0, Tr = 0;
    for (let ir = 0, Vd = (i.value || []).length; ir < Vd; ir++) {
      const KC = (oe = (at = e == null ? void 0 : e.store) == null ? void 0 : at.states) == null ? void 0 : oe.rowKey.value, JC = ir + Tr, zd = i.value[ir], e2 = S.value && S.value.call(null, zd, JC);
      if (Se(zd))
        Fn++;
      else if (!S.value || e2) {
        yt = !1;
        break;
      }
      Tr += ae(li(zd, KC));
    }
    Fn === 0 && (yt = !1), b.value = yt;
  }, ae = (Ge) => {
    var at;
    if (!e || !e.store)
      return 0;
    const { treeData: oe } = e.store.states;
    let ge = 0;
    const Se = (at = oe.value[Ge]) == null ? void 0 : at.children;
    return Se && (ge += Se.length, Se.forEach((yt) => {
      ge += ae(yt);
    })), ge;
  }, ee = (Ge, at) => {
    Array.isArray(Ge) || (Ge = [Ge]);
    const oe = {};
    return Ge.forEach((ge) => {
      _.value[ge.id] = at, oe[ge.columnKey || ge.id] = at;
    }), oe;
  }, ne = (Ge, at, oe) => {
    A.value && A.value !== Ge && (A.value.order = null), A.value = Ge, k.value = at, P.value = oe;
  }, ye = () => {
    let Ge = T(o);
    Object.keys(_.value).forEach((at) => {
      const oe = _.value[at];
      if (!oe || oe.length === 0)
        return;
      const ge = IH({
        columns: u.value
      }, at);
      ge && ge.filterMethod && (Ge = Ge.filter((Se) => oe.some((yt) => ge.filterMethod.call(null, yt, Se, ge))));
    }), C.value = Ge;
  }, te = () => {
    i.value = bSe(C.value, {
      sortingColumn: A.value,
      sortProp: k.value,
      sortOrder: P.value
    });
  }, ue = (Ge = void 0) => {
    Ge && Ge.filter || ye(), te();
  }, xe = (Ge) => {
    const { tableHeaderRef: at } = e.refs;
    if (!at)
      return;
    const oe = Object.assign({}, at.filterPanels), ge = Object.keys(oe);
    if (ge.length)
      if (typeof Ge == "string" && (Ge = [Ge]), Array.isArray(Ge)) {
        const Se = Ge.map((yt) => cSe({
          columns: u.value
        }, yt));
        ge.forEach((yt) => {
          const Fn = Se.find((Tr) => Tr.id === yt);
          Fn && (Fn.filteredValue = []);
        }), e.store.commit("filterChange", {
          column: Se,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        ge.forEach((Se) => {
          const yt = u.value.find((Fn) => Fn.id === Se);
          yt && (yt.filteredValue = []);
        }), _.value = {}, e.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, dt = () => {
    A.value && (ne(null, null, null), e.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: Ue,
    toggleRowExpansion: Rt,
    updateExpandRows: zt,
    states: tn,
    isRowExpanded: jn
  } = vSe({
    data: i,
    rowKey: r
  }), {
    updateTreeExpandKeys: An,
    toggleTreeExpansion: Tn,
    updateTreeData: Un,
    loadOrToggle: Vi,
    states: Jr
  } = ySe({
    data: i,
    rowKey: r
  }), {
    updateCurrentRowData: _i,
    updateCurrentRow: Oe,
    setCurrentRowKey: xt,
    states: wn
  } = mSe({
    data: i,
    rowKey: r
  });
  return {
    assertRowKey: D,
    updateColumns: M,
    scheduleLayout: R,
    isSelected: N,
    clearSelection: $,
    cleanSelection: F,
    getSelectionRows: W,
    toggleRowSelection: j,
    _toggleAllSelection: Y,
    toggleAllSelection: null,
    updateSelectionByRowKey: X,
    updateAllSelected: ie,
    updateFilters: ee,
    updateCurrentRow: Oe,
    updateSort: ne,
    execFilter: ye,
    execSort: te,
    execQuery: ue,
    clearFilter: xe,
    clearSort: dt,
    toggleRowExpansion: Rt,
    setExpandRowKeysAdapter: (Ge) => {
      Ue(Ge), An(Ge);
    },
    setCurrentRowKey: xt,
    toggleRowExpansionAdapter: (Ge, at) => {
      u.value.some(({ type: ge }) => ge === "expand") ? Rt(Ge, at) : Tn(Ge, at);
    },
    isRowExpanded: jn,
    updateExpandRows: zt,
    updateCurrentRowData: _i,
    loadOrToggle: Vi,
    updateTreeData: Un,
    states: {
      tableSize: t,
      rowKey: r,
      data: i,
      _data: o,
      isComplex: a,
      _columns: s,
      originColumns: l,
      columns: u,
      fixedColumns: c,
      rightFixedColumns: h,
      leafColumns: f,
      fixedLeafColumns: d,
      rightFixedLeafColumns: p,
      updateOrderFns: g,
      leafColumnsLength: v,
      fixedLeafColumnsLength: m,
      rightFixedLeafColumnsLength: y,
      isAllSelected: b,
      selection: O,
      reserveSelection: w,
      selectOnIndeterminate: x,
      selectable: S,
      filters: _,
      filteredData: C,
      sortingColumn: A,
      sortProp: k,
      sortOrder: P,
      hoverRow: L,
      ...tn,
      ...Jr,
      ...wn
    }
  };
}
function CP(n, e) {
  return n.map((t) => {
    var r;
    return t.id === e.id ? e : ((r = t.children) != null && r.length && (t.children = CP(t.children, e)), t);
  });
}
function AP(n) {
  n.forEach((e) => {
    var t, r;
    e.no = (t = e.getColumnIndex) == null ? void 0 : t.call(e), (r = e.children) != null && r.length && AP(e.children);
  }), n.sort((e, t) => e.no - t.no);
}
function wSe() {
  const n = wt(), e = OSe();
  return {
    ns: Pe("table"),
    ...e,
    mutations: {
      setData(a, s) {
        const l = T(a._data) !== s;
        a.data.value = s, a._data.value = s, n.store.execQuery(), n.store.updateCurrentRowData(), n.store.updateExpandRows(), n.store.updateTreeData(n.store.states.defaultExpandAll.value), T(a.reserveSelection) ? (n.store.assertRowKey(), n.store.updateSelectionByRowKey()) : l ? n.store.clearSelection() : n.store.cleanSelection(), n.store.updateAllSelected(), n.$ready && n.store.scheduleLayout();
      },
      insertColumn(a, s, l, u) {
        const c = T(a._columns);
        let h = [];
        l ? (l && !l.children && (l.children = []), l.children.push(s), h = CP(c, l)) : (c.push(s), h = c), AP(h), a._columns.value = h, a.updateOrderFns.push(u), s.type === "selection" && (a.selectable.value = s.selectable, a.reserveSelection.value = s.reserveSelection), n.$ready && (n.store.updateColumns(), n.store.scheduleLayout());
      },
      updateColumnOrder(a, s) {
        var l;
        ((l = s.getColumnIndex) == null ? void 0 : l.call(s)) !== s.no && (AP(a._columns.value), n.$ready && n.store.updateColumns());
      },
      removeColumn(a, s, l, u) {
        const c = T(a._columns) || [];
        if (l)
          l.children.splice(l.children.findIndex((f) => f.id === s.id), 1), Ke(() => {
            var f;
            ((f = l.children) == null ? void 0 : f.length) === 0 && delete l.children;
          }), a._columns.value = CP(c, l);
        else {
          const f = c.indexOf(s);
          f > -1 && (c.splice(f, 1), a._columns.value = c);
        }
        const h = a.updateOrderFns.indexOf(u);
        h > -1 && a.updateOrderFns.splice(h, 1), n.$ready && (n.store.updateColumns(), n.store.scheduleLayout());
      },
      sort(a, s) {
        const { prop: l, order: u, init: c } = s;
        if (l) {
          const h = T(a.columns).find((f) => f.property === l);
          h && (h.order = u, n.store.updateSort(h, l, u), n.store.commit("changeSortCondition", { init: c }));
        }
      },
      changeSortCondition(a, s) {
        const { sortingColumn: l, sortProp: u, sortOrder: c } = a, h = T(l), f = T(u), d = T(c);
        d === null && (a.sortingColumn.value = null, a.sortProp.value = null);
        const p = { filter: !0 };
        n.store.execQuery(p), (!s || !(s.silent || s.init)) && n.emit("sort-change", {
          column: h,
          prop: f,
          order: d
        }), n.store.updateTableScrollY();
      },
      filterChange(a, s) {
        const { column: l, values: u, silent: c } = s, h = n.store.updateFilters(l, u);
        n.store.execQuery(), c || n.emit("filter-change", h), n.store.updateTableScrollY();
      },
      toggleAllSelection() {
        n.store.toggleAllSelection();
      },
      rowSelectedChanged(a, s) {
        n.store.toggleRowSelection(s), n.store.updateAllSelected();
      },
      setHoverRow(a, s) {
        a.hoverRow.value = s;
      },
      setCurrentRow(a, s) {
        n.store.updateCurrentRow(s);
      }
    },
    commit: function(a, ...s) {
      const l = n.store.mutations;
      if (l[a])
        l[a].apply(n, [n.store.states].concat(s));
      else
        throw new Error(`Action not found: ${a}`);
    },
    updateTableScrollY: function() {
      Ke(() => n.layout.updateScrollY.apply(n.layout));
    }
  };
}
const py = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  "treeProps.hasChildren": {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  "treeProps.children": {
    key: "childrenColumnName",
    default: "children"
  }
};
function xSe(n, e) {
  if (!n)
    throw new Error("Table is required.");
  const t = wSe();
  return t.toggleAllSelection = kc(t._toggleAllSelection, 10), Object.keys(py).forEach((r) => {
    BH(VH(e, r), r, t);
  }), SSe(t, e), t;
}
function SSe(n, e) {
  Object.keys(py).forEach((t) => {
    he(() => VH(e, t), (r) => {
      BH(r, t, n);
    });
  });
}
function BH(n, e, t) {
  let r = n, i = py[e];
  typeof py[e] == "object" && (i = i.key, r = r || py[e].default), t.states[i].value = r;
}
function VH(n, e) {
  if (e.includes(".")) {
    const t = e.split(".");
    let r = n;
    return t.forEach((i) => {
      r = r[i];
    }), r;
  } else
    return n[e];
}
class _Se {
  constructor(e) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = z(null), this.scrollX = z(!1), this.scrollY = z(!1), this.bodyWidth = z(null), this.fixedWidth = z(null), this.rightFixedWidth = z(null), this.gutterWidth = 0;
    for (const t in e)
      To(e, t) && (So(this[t]) ? this[t].value = e[t] : this[t] = e[t]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    if (this.height.value === null)
      return !1;
    const t = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (t != null && t.wrapRef)) {
      let r = !0;
      const i = this.scrollY.value;
      return r = t.wrapRef.scrollHeight > t.wrapRef.clientHeight, this.scrollY.value = r, i !== r;
    }
    return !1;
  }
  setHeight(e, t = "height") {
    if (!qt)
      return;
    const r = this.table.vnode.el;
    if (e = fSe(e), this.height.value = Number(e), !r && (e || e === 0))
      return Ke(() => this.setHeight(e, t));
    typeof e == "number" ? (r.style[t] = `${e}px`, this.updateElsHeight()) : typeof e == "string" && (r.style[t] = e, this.updateElsHeight());
  }
  setMaxHeight(e) {
    this.setHeight(e, "max-height");
  }
  getFlattenColumns() {
    const e = [];
    return this.table.store.states.columns.value.forEach((r) => {
      r.isColumnGroup ? e.push.apply(e, r.columns) : e.push(r);
    }), e;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(e) {
    if (!e)
      return !0;
    let t = e;
    for (; t.tagName !== "DIV"; ) {
      if (getComputedStyle(t).display === "none")
        return !0;
      t = t.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    if (!qt)
      return;
    const e = this.fit, t = this.table.vnode.el.clientWidth;
    let r = 0;
    const i = this.getFlattenColumns(), o = i.filter((l) => typeof l.width != "number");
    if (i.forEach((l) => {
      typeof l.width == "number" && l.realWidth && (l.realWidth = null);
    }), o.length > 0 && e) {
      if (i.forEach((l) => {
        r += Number(l.width || l.minWidth || 80);
      }), r <= t) {
        this.scrollX.value = !1;
        const l = t - r;
        if (o.length === 1)
          o[0].realWidth = Number(o[0].minWidth || 80) + l;
        else {
          const u = o.reduce((f, d) => f + Number(d.minWidth || 80), 0), c = l / u;
          let h = 0;
          o.forEach((f, d) => {
            if (d === 0)
              return;
            const p = Math.floor(Number(f.minWidth || 80) * c);
            h += p, f.realWidth = Number(f.minWidth || 80) + p;
          }), o[0].realWidth = Number(o[0].minWidth || 80) + l - h;
        }
      } else
        this.scrollX.value = !0, o.forEach((l) => {
          l.realWidth = Number(l.minWidth);
        });
      this.bodyWidth.value = Math.max(r, t), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      i.forEach((l) => {
        !l.width && !l.minWidth ? l.realWidth = 80 : l.realWidth = Number(l.width || l.minWidth), r += l.realWidth;
      }), this.scrollX.value = r > t, this.bodyWidth.value = r;
    const a = this.store.states.fixedColumns.value;
    if (a.length > 0) {
      let l = 0;
      a.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.fixedWidth.value = l;
    }
    const s = this.store.states.rightFixedColumns.value;
    if (s.length > 0) {
      let l = 0;
      s.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.rightFixedWidth.value = l;
    }
    this.notifyObservers("columns");
  }
  addObserver(e) {
    this.observers.push(e);
  }
  removeObserver(e) {
    const t = this.observers.indexOf(e);
    t !== -1 && this.observers.splice(t, 1);
  }
  notifyObservers(e) {
    this.observers.forEach((r) => {
      var i, o;
      switch (e) {
        case "columns":
          (i = r.state) == null || i.onColumnsChange(this);
          break;
        case "scrollable":
          (o = r.state) == null || o.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${e}.`);
      }
    });
  }
}
const { CheckboxGroup: CSe } = yl, ASe = U({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: yl,
    ElCheckboxGroup: CSe,
    ElScrollbar: Ob,
    ElTooltip: Uf,
    ElIcon: bt,
    ArrowDown: pb,
    ArrowUp: Yj
  },
  directives: { ClickOutside: S_ },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(n) {
    const e = wt(), { t } = Ar(), r = Pe("table-filter"), i = e == null ? void 0 : e.parent;
    i.filterPanels.value[n.column.id] || (i.filterPanels.value[n.column.id] = e);
    const o = z(!1), a = z(null), s = B(() => n.column && n.column.filters), l = B(() => n.column.filterClassName ? `${r.b()} ${n.column.filterClassName}` : r.b()), u = B({
      get: () => {
        var w;
        return (((w = n.column) == null ? void 0 : w.filteredValue) || [])[0];
      },
      set: (w) => {
        c.value && (typeof w < "u" && w !== null ? c.value.splice(0, 1, w) : c.value.splice(0, 1));
      }
    }), c = B({
      get() {
        return n.column ? n.column.filteredValue || [] : [];
      },
      set(w) {
        n.column && n.upDataColumn("filteredValue", w);
      }
    }), h = B(() => n.column ? n.column.filterMultiple : !0), f = (w) => w.value === u.value, d = () => {
      o.value = !1;
    }, p = (w) => {
      w.stopPropagation(), o.value = !o.value;
    }, g = () => {
      o.value = !1;
    }, v = () => {
      b(c.value), d();
    }, m = () => {
      c.value = [], b(c.value), d();
    }, y = (w) => {
      u.value = w, b(typeof w < "u" && w !== null ? c.value : []), d();
    }, b = (w) => {
      n.store.commit("filterChange", {
        column: n.column,
        values: w
      }), n.store.updateAllSelected();
    };
    he(o, (w) => {
      n.column && n.upDataColumn("filterOpened", w);
    }, {
      immediate: !0
    });
    const O = B(() => {
      var w, x;
      return (x = (w = a.value) == null ? void 0 : w.popperRef) == null ? void 0 : x.contentRef;
    });
    return {
      tooltipVisible: o,
      multiple: h,
      filterClassName: l,
      filteredValue: c,
      filterValue: u,
      filters: s,
      handleConfirm: v,
      handleReset: m,
      handleSelect: y,
      isActive: f,
      t,
      ns: r,
      showFilterPanel: p,
      hideFilterPanel: g,
      popperPaneRef: O,
      tooltip: a
    };
  }
}), TSe = { key: 0 }, kSe = ["disabled"], PSe = ["label", "onClick"];
function ESe(n, e, t, r, i, o) {
  const a = Ct("el-checkbox"), s = Ct("el-checkbox-group"), l = Ct("el-scrollbar"), u = Ct("arrow-up"), c = Ct("arrow-down"), h = Ct("el-icon"), f = Ct("el-tooltip"), d = eL("click-outside");
  return V(), ve(f, {
    ref: "tooltip",
    visible: n.tooltipVisible,
    offset: 0,
    placement: n.placement,
    "show-arrow": !1,
    "stop-popper-mouse-event": !1,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": n.filterClassName,
    persistent: ""
  }, {
    content: fe(() => [
      n.multiple ? (V(), q("div", TSe, [
        J("div", {
          class: Q(n.ns.e("content"))
        }, [
          de(l, {
            "wrap-class": n.ns.e("wrap")
          }, {
            default: fe(() => [
              de(s, {
                modelValue: n.filteredValue,
                "onUpdate:modelValue": e[0] || (e[0] = (p) => n.filteredValue = p),
                class: Q(n.ns.e("checkbox-group"))
              }, {
                default: fe(() => [
                  (V(!0), q(yn, null, qi(n.filters, (p) => (V(), ve(a, {
                    key: p.value,
                    label: p.value
                  }, {
                    default: fe(() => [
                      Ri(ze(p.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["label"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        J("div", {
          class: Q(n.ns.e("bottom"))
        }, [
          J("button", {
            class: Q({ [n.ns.is("disabled")]: n.filteredValue.length === 0 }),
            disabled: n.filteredValue.length === 0,
            type: "button",
            onClick: e[1] || (e[1] = (...p) => n.handleConfirm && n.handleConfirm(...p))
          }, ze(n.t("el.table.confirmFilter")), 11, kSe),
          J("button", {
            type: "button",
            onClick: e[2] || (e[2] = (...p) => n.handleReset && n.handleReset(...p))
          }, ze(n.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (V(), q("ul", {
        key: 1,
        class: Q(n.ns.e("list"))
      }, [
        J("li", {
          class: Q([
            n.ns.e("list-item"),
            {
              [n.ns.is("active")]: n.filterValue === void 0 || n.filterValue === null
            }
          ]),
          onClick: e[3] || (e[3] = (p) => n.handleSelect(null))
        }, ze(n.t("el.table.clearFilter")), 3),
        (V(!0), q(yn, null, qi(n.filters, (p) => (V(), q("li", {
          key: p.value,
          class: Q([n.ns.e("list-item"), n.ns.is("active", n.isActive(p))]),
          label: p.value,
          onClick: (g) => n.handleSelect(p.value)
        }, ze(p.text), 11, PSe))), 128))
      ], 2))
    ]),
    default: fe(() => [
      At((V(), q("span", {
        class: Q([
          `${n.ns.namespace.value}-table__column-filter-trigger`,
          `${n.ns.namespace.value}-none-outline`
        ]),
        onClick: e[4] || (e[4] = (...p) => n.showFilterPanel && n.showFilterPanel(...p))
      }, [
        de(h, null, {
          default: fe(() => [
            n.column.filterOpened ? (V(), ve(u, { key: 0 })) : (V(), ve(c, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [d, n.hideFilterPanel, n.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var MSe = /* @__PURE__ */ Ve(ASe, [["render", ESe], ["__file", "filter-panel.vue"]]);
function zH(n) {
  const e = wt();
  JD(() => {
    t.value.addObserver(e);
  }), ht(() => {
    r(t.value), i(t.value);
  }), yd(() => {
    r(t.value), i(t.value);
  }), ub(() => {
    t.value.removeObserver(e);
  });
  const t = B(() => {
    const o = n.layout;
    if (!o)
      throw new Error("Can not find table layout.");
    return o;
  }), r = (o) => {
    var a;
    const s = ((a = n.vnode.el) == null ? void 0 : a.querySelectorAll("colgroup > col")) || [];
    if (!s.length)
      return;
    const l = o.getFlattenColumns(), u = {};
    l.forEach((c) => {
      u[c.id] = c;
    });
    for (let c = 0, h = s.length; c < h; c++) {
      const f = s[c], d = f.getAttribute("name"), p = u[d];
      p && f.setAttribute("width", p.realWidth || p.width);
    }
  }, i = (o) => {
    var a, s;
    const l = ((a = n.vnode.el) == null ? void 0 : a.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let c = 0, h = l.length; c < h; c++)
      l[c].setAttribute("width", o.scrollY.value ? o.gutterWidth : "0");
    const u = ((s = n.vnode.el) == null ? void 0 : s.querySelectorAll("th.gutter")) || [];
    for (let c = 0, h = u.length; c < h; c++) {
      const f = u[c];
      f.style.width = o.scrollY.value ? `${o.gutterWidth}px` : "0", f.style.display = o.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: t.value,
    onColumnsChange: r,
    onScrollableChange: i
  };
}
const Pl = Symbol("ElTable");
function DSe(n, e) {
  const t = wt(), r = Re(Pl), i = (g) => {
    g.stopPropagation();
  }, o = (g, v) => {
    !v.filters && v.sortable ? p(g, v, !1) : v.filterable && !v.sortable && i(g), r == null || r.emit("header-click", v, g);
  }, a = (g, v) => {
    r == null || r.emit("header-contextmenu", v, g);
  }, s = z(null), l = z(!1), u = z({}), c = (g, v) => {
    if (qt && !(v.children && v.children.length > 0) && s.value && n.border) {
      l.value = !0;
      const m = r;
      e("set-drag-visible", !0);
      const b = (m == null ? void 0 : m.vnode.el).getBoundingClientRect().left, O = t.vnode.el.querySelector(`th.${v.id}`), w = O.getBoundingClientRect(), x = w.left - b + 30;
      fg(O, "noclick"), u.value = {
        startMouseLeft: g.clientX,
        startLeft: w.right - b,
        startColumnLeft: w.left - b,
        tableLeft: b
      };
      const S = m == null ? void 0 : m.refs.resizeProxy;
      S.style.left = `${u.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const _ = (A) => {
        const k = A.clientX - u.value.startMouseLeft, P = u.value.startLeft + k;
        S.style.left = `${Math.max(x, P)}px`;
      }, C = () => {
        if (l.value) {
          const { startColumnLeft: A, startLeft: k } = u.value, L = Number.parseInt(S.style.left, 10) - A;
          v.width = v.realWidth = L, m == null || m.emit("header-dragend", v.width, k - A, v, g), requestAnimationFrame(() => {
            n.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", l.value = !1, s.value = null, u.value = {}, e("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", _), document.removeEventListener("mouseup", C), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          Ul(O, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", _), document.addEventListener("mouseup", C);
    }
  }, h = (g, v) => {
    if (v.children && v.children.length > 0)
      return;
    const m = g.target;
    if (!hs(m))
      return;
    const y = m == null ? void 0 : m.closest("th");
    if (!(!v || !v.resizable) && !l.value && n.border) {
      const b = y.getBoundingClientRect(), O = document.body.style;
      b.width > 12 && b.right - g.pageX < 8 ? (O.cursor = "col-resize", Bp(y, "is-sortable") && (y.style.cursor = "col-resize"), s.value = v) : l.value || (O.cursor = "", Bp(y, "is-sortable") && (y.style.cursor = "pointer"), s.value = null);
    }
  }, f = () => {
    qt && (document.body.style.cursor = "");
  }, d = ({ order: g, sortOrders: v }) => {
    if (g === "")
      return v[0];
    const m = v.indexOf(g || null);
    return v[m > v.length - 2 ? 0 : m + 1];
  }, p = (g, v, m) => {
    var y;
    g.stopPropagation();
    const b = v.order === m ? null : m || d(v), O = (y = g.target) == null ? void 0 : y.closest("th");
    if (O && Bp(O, "noclick")) {
      Ul(O, "noclick");
      return;
    }
    if (!v.sortable)
      return;
    const w = n.store.states;
    let x = w.sortProp.value, S;
    const _ = w.sortingColumn.value;
    (_ !== v || _ === v && _.order === null) && (_ && (_.order = null), w.sortingColumn.value = v, x = v.property), b ? S = v.order = b : S = v.order = null, w.sortProp.value = x, w.sortOrder.value = S, r == null || r.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: o,
    handleHeaderContextMenu: a,
    handleMouseDown: c,
    handleMouseMove: h,
    handleMouseOut: f,
    handleSortClick: p,
    handleFilterClick: i
  };
}
function LSe(n) {
  const e = Re(Pl), t = Pe("table");
  return {
    getHeaderRowStyle: (s) => {
      const l = e == null ? void 0 : e.props.headerRowStyle;
      return typeof l == "function" ? l.call(null, { rowIndex: s }) : l;
    },
    getHeaderRowClass: (s) => {
      const l = [], u = e == null ? void 0 : e.props.headerRowClassName;
      return typeof u == "string" ? l.push(u) : typeof u == "function" && l.push(u.call(null, { rowIndex: s })), l.join(" ");
    },
    getHeaderCellStyle: (s, l, u, c) => {
      var h;
      let f = (h = e == null ? void 0 : e.props.headerCellStyle) != null ? h : {};
      typeof f == "function" && (f = f.call(null, {
        rowIndex: s,
        columnIndex: l,
        row: u,
        column: c
      }));
      const d = HL(l, c.fixed, n.store, u);
      return bg(d, "left"), bg(d, "right"), Object.assign({}, f, d);
    },
    getHeaderCellClass: (s, l, u, c) => {
      const h = jL(t.b(), l, c.fixed, n.store, u), f = [
        c.id,
        c.order,
        c.headerAlign,
        c.className,
        c.labelClassName,
        ...h
      ];
      c.children || f.push("is-leaf"), c.sortable && f.push("is-sortable");
      const d = e == null ? void 0 : e.props.headerCellClassName;
      return typeof d == "string" ? f.push(d) : typeof d == "function" && f.push(d.call(null, {
        rowIndex: s,
        columnIndex: l,
        row: u,
        column: c
      })), f.push(t.e("cell")), f.filter((p) => !!p).join(" ");
    }
  };
}
const FH = (n) => {
  const e = [];
  return n.forEach((t) => {
    t.children ? (e.push(t), e.push.apply(e, FH(t.children))) : e.push(t);
  }), e;
}, ISe = (n) => {
  let e = 1;
  const t = (o, a) => {
    if (a && (o.level = a.level + 1, e < o.level && (e = o.level)), o.children) {
      let s = 0;
      o.children.forEach((l) => {
        t(l, o), s += l.colSpan;
      }), o.colSpan = s;
    } else
      o.colSpan = 1;
  };
  n.forEach((o) => {
    o.level = 1, t(o, void 0);
  });
  const r = [];
  for (let o = 0; o < e; o++)
    r.push([]);
  return FH(n).forEach((o) => {
    o.children ? (o.rowSpan = 1, o.children.forEach((a) => a.isSubColumn = !0)) : o.rowSpan = e - o.level + 1, r[o.level - 1].push(o);
  }), r;
};
function RSe(n) {
  const e = Re(Pl), t = B(() => ISe(n.store.states.originColumns.value));
  return {
    isGroup: B(() => {
      const o = t.value.length > 1;
      return o && e && (e.state.isGroup.value = !0), o;
    }),
    toggleAllSelection: (o) => {
      o.stopPropagation(), e == null || e.store.commit("toggleAllSelection");
    },
    columnRows: t
  };
}
var NSe = U({
  name: "ElTableHeader",
  components: {
    ElCheckbox: yl
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(n, { emit: e }) {
    const t = wt(), r = Re(Pl), i = Pe("table"), o = z({}), { onColumnsChange: a, onScrollableChange: s } = zH(r);
    ht(async () => {
      await Ke(), await Ke();
      const { prop: x, order: S } = n.defaultSort;
      r == null || r.store.commit("sort", { prop: x, order: S, init: !0 });
    });
    const {
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: h,
      handleMouseOut: f,
      handleSortClick: d,
      handleFilterClick: p
    } = DSe(n, e), {
      getHeaderRowStyle: g,
      getHeaderRowClass: v,
      getHeaderCellStyle: m,
      getHeaderCellClass: y
    } = LSe(n), { isGroup: b, toggleAllSelection: O, columnRows: w } = RSe(n);
    return t.state = {
      onColumnsChange: a,
      onScrollableChange: s
    }, t.filterPanels = o, {
      ns: i,
      filterPanels: o,
      onColumnsChange: a,
      onScrollableChange: s,
      columnRows: w,
      getHeaderRowClass: v,
      getHeaderRowStyle: g,
      getHeaderCellClass: y,
      getHeaderCellStyle: m,
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: h,
      handleMouseOut: f,
      handleSortClick: d,
      handleFilterClick: p,
      isGroup: b,
      toggleAllSelection: O
    };
  },
  render() {
    const {
      ns: n,
      isGroup: e,
      columnRows: t,
      getHeaderCellStyle: r,
      getHeaderCellClass: i,
      getHeaderRowClass: o,
      getHeaderRowStyle: a,
      handleHeaderClick: s,
      handleHeaderContextMenu: l,
      handleMouseDown: u,
      handleMouseMove: c,
      handleSortClick: h,
      handleMouseOut: f,
      store: d,
      $parent: p
    } = this;
    let g = 1;
    return et("thead", {
      class: { [n.is("group")]: e }
    }, t.map((v, m) => et("tr", {
      class: o(m),
      key: m,
      style: a(m)
    }, v.map((y, b) => (y.rowSpan > g && (g = y.rowSpan), et("th", {
      class: i(m, b, v, y),
      colspan: y.colSpan,
      key: `${y.id}-thead`,
      rowspan: y.rowSpan,
      style: r(m, b, v, y),
      onClick: (O) => s(O, y),
      onContextmenu: (O) => l(O, y),
      onMousedown: (O) => u(O, y),
      onMousemove: (O) => c(O, y),
      onMouseout: f
    }, [
      et("div", {
        class: [
          "cell",
          y.filteredValue && y.filteredValue.length > 0 ? "highlight" : ""
        ]
      }, [
        y.renderHeader ? y.renderHeader({
          column: y,
          $index: b,
          store: d,
          _self: p
        }) : y.label,
        y.sortable && et("span", {
          onClick: (O) => h(O, y),
          class: "caret-wrapper"
        }, [
          et("i", {
            onClick: (O) => h(O, y, "ascending"),
            class: "sort-caret ascending"
          }),
          et("i", {
            onClick: (O) => h(O, y, "descending"),
            class: "sort-caret descending"
          })
        ]),
        y.filterable && et(MSe, {
          store: d,
          placement: y.filterPlacement || "bottom-start",
          column: y,
          upDataColumn: (O, w) => {
            y[O] = w;
          }
        })
      ])
    ]))))));
  }
});
function $Se(n) {
  const e = Re(Pl), t = z(""), r = z(et("div")), i = (p, g, v) => {
    var m;
    const y = e, b = y2(p);
    let O;
    const w = (m = y == null ? void 0 : y.vnode.el) == null ? void 0 : m.dataset.prefix;
    b && (O = IB({
      columns: n.store.states.columns.value
    }, b, w), O && (y == null || y.emit(`cell-${v}`, g, O, b, p))), y == null || y.emit(`row-${v}`, g, O, p);
  }, o = (p, g) => {
    i(p, g, "dblclick");
  }, a = (p, g) => {
    n.store.commit("setCurrentRow", g), i(p, g, "click");
  }, s = (p, g) => {
    i(p, g, "contextmenu");
  }, l = kc((p) => {
    n.store.commit("setHoverRow", p);
  }, 30), u = kc(() => {
    n.store.commit("setHoverRow", null);
  }, 30), c = (p) => {
    const g = window.getComputedStyle(p, null), v = Number.parseInt(g.paddingLeft, 10) || 0, m = Number.parseInt(g.paddingRight, 10) || 0, y = Number.parseInt(g.paddingTop, 10) || 0, b = Number.parseInt(g.paddingBottom, 10) || 0;
    return {
      left: v,
      right: m,
      top: y,
      bottom: b
    };
  }, h = (p, g, v) => {
    let m = g.target.parentNode;
    for (; p > 1 && (m = m == null ? void 0 : m.nextSibling, !(!m || m.nodeName !== "TR")); )
      v(m, "hover-row hover-fixed-row"), p--;
  };
  return {
    handleDoubleClick: o,
    handleClick: a,
    handleContextMenu: s,
    handleMouseEnter: l,
    handleMouseLeave: u,
    handleCellMouseEnter: (p, g, v) => {
      var m;
      const y = e, b = y2(p), O = (m = y == null ? void 0 : y.vnode.el) == null ? void 0 : m.dataset.prefix;
      if (b) {
        const R = IB({
          columns: n.store.states.columns.value
        }, b, O);
        b.rowSpan > 1 && h(b.rowSpan, p, fg);
        const N = y.hoverState = { cell: b, column: R, row: g };
        y == null || y.emit("cell-mouse-enter", N.row, N.column, N.cell, p);
      }
      if (!v)
        return;
      const w = p.target.querySelector(".cell");
      if (!(Bp(w, `${O}-tooltip`) && w.childNodes.length))
        return;
      const x = document.createRange();
      x.setStart(w, 0), x.setEnd(w, w.childNodes.length);
      let S = x.getBoundingClientRect().width, _ = x.getBoundingClientRect().height;
      S - Math.floor(S) < 1e-3 && (S = Math.floor(S)), _ - Math.floor(_) < 1e-3 && (_ = Math.floor(_));
      const { top: k, left: P, right: L, bottom: D } = c(w), E = P + L, M = k + D;
      (S + E > w.offsetWidth || _ + M > w.offsetHeight || w.scrollWidth > w.offsetWidth) && gSe(v, b.innerText || b.textContent, b, y);
    },
    handleCellMouseLeave: (p) => {
      const g = y2(p);
      if (!g)
        return;
      g.rowSpan > 1 && h(g.rowSpan, p, Ul);
      const v = e == null ? void 0 : e.hoverState;
      e == null || e.emit("cell-mouse-leave", v == null ? void 0 : v.row, v == null ? void 0 : v.column, v == null ? void 0 : v.cell, p);
    },
    tooltipContent: t,
    tooltipTrigger: r
  };
}
function BSe(n) {
  const e = Re(Pl), t = Pe("table");
  return {
    getRowStyle: (u, c) => {
      const h = e == null ? void 0 : e.props.rowStyle;
      return typeof h == "function" ? h.call(null, {
        row: u,
        rowIndex: c
      }) : h || null;
    },
    getRowClass: (u, c) => {
      const h = [t.e("row")];
      e != null && e.props.highlightCurrentRow && u === n.store.states.currentRow.value && h.push("current-row"), n.stripe && c % 2 === 1 && h.push(t.em("row", "striped"));
      const f = e == null ? void 0 : e.props.rowClassName;
      return typeof f == "string" ? h.push(f) : typeof f == "function" && h.push(f.call(null, {
        row: u,
        rowIndex: c
      })), h;
    },
    getCellStyle: (u, c, h, f) => {
      const d = e == null ? void 0 : e.props.cellStyle;
      let p = d ?? {};
      typeof d == "function" && (p = d.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: h,
        column: f
      }));
      const g = HL(c, n == null ? void 0 : n.fixed, n.store);
      return bg(g, "left"), bg(g, "right"), Object.assign({}, p, g);
    },
    getCellClass: (u, c, h, f, d) => {
      const p = jL(t.b(), c, n == null ? void 0 : n.fixed, n.store, void 0, d), g = [f.id, f.align, f.className, ...p], v = e == null ? void 0 : e.props.cellClassName;
      return typeof v == "string" ? g.push(v) : typeof v == "function" && g.push(v.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: h,
        column: f
      })), g.push(t.e("cell")), g.filter((m) => !!m).join(" ");
    },
    getSpan: (u, c, h, f) => {
      let d = 1, p = 1;
      const g = e == null ? void 0 : e.props.spanMethod;
      if (typeof g == "function") {
        const v = g({
          row: u,
          column: c,
          rowIndex: h,
          columnIndex: f
        });
        Array.isArray(v) ? (d = v[0], p = v[1]) : typeof v == "object" && (d = v.rowspan, p = v.colspan);
      }
      return { rowspan: d, colspan: p };
    },
    getColspanRealWidth: (u, c, h) => {
      if (c < 1)
        return u[h].realWidth;
      const f = u.map(({ realWidth: d, width: p }) => d || p).slice(h, h + c);
      return Number(f.reduce((d, p) => Number(d) + Number(p), -1));
    }
  };
}
function VSe(n) {
  const e = Re(Pl), t = Pe("table"), {
    handleDoubleClick: r,
    handleClick: i,
    handleContextMenu: o,
    handleMouseEnter: a,
    handleMouseLeave: s,
    handleCellMouseEnter: l,
    handleCellMouseLeave: u,
    tooltipContent: c,
    tooltipTrigger: h
  } = $Se(n), {
    getRowStyle: f,
    getRowClass: d,
    getCellStyle: p,
    getCellClass: g,
    getSpan: v,
    getColspanRealWidth: m
  } = BSe(n), y = B(() => n.store.states.columns.value.findIndex(({ type: S }) => S === "default")), b = (S, _) => {
    const C = e.props.rowKey;
    return C ? li(S, C) : _;
  }, O = (S, _, C, A = !1) => {
    const { tooltipEffect: k, tooltipOptions: P, store: L } = n, { indent: D, columns: E } = L.states, M = d(S, _);
    let R = !0;
    return C && (M.push(t.em("row", `level-${C.level}`)), R = C.display), et("tr", {
      style: [R ? null : {
        display: "none"
      }, f(S, _)],
      class: M,
      key: b(S, _),
      onDblclick: ($) => r($, S),
      onClick: ($) => i($, S),
      onContextmenu: ($) => o($, S),
      onMouseenter: () => a(_),
      onMouseleave: s
    }, E.value.map(($, F) => {
      const { rowspan: W, colspan: j } = v(S, $, _, F);
      if (!W || !j)
        return null;
      const Y = Object.assign({}, $);
      Y.realWidth = m(E.value, j, F);
      const X = {
        store: n.store,
        _self: n.context || e,
        column: Y,
        row: S,
        $index: _,
        cellIndex: F,
        expanded: A
      };
      F === y.value && C && (X.treeNode = {
        indent: C.level * D.value,
        level: C.level
      }, typeof C.expanded == "boolean" && (X.treeNode.expanded = C.expanded, "loading" in C && (X.treeNode.loading = C.loading), "noLazyChildren" in C && (X.treeNode.noLazyChildren = C.noLazyChildren)));
      const ie = `${_},${F}`, ae = Y.columnKey || Y.rawColumnKey || "", ee = w(F, $, X), ne = $.showOverflowTooltip && er({
        effect: k
      }, P, $.showOverflowTooltip);
      return et("td", {
        style: p(_, F, S, $),
        class: g(_, F, S, $, j - 1),
        key: `${ae}${ie}`,
        rowspan: W,
        colspan: j,
        onMouseenter: (ye) => l(ye, S, ne),
        onMouseleave: u
      }, [ee]);
    }));
  }, w = (S, _, C) => _.renderCell(C);
  return {
    wrappedRowRender: (S, _) => {
      const C = n.store, { isRowExpanded: A, assertRowKey: k } = C, { treeData: P, lazyTreeNodeMap: L, childrenColumnName: D, rowKey: E } = C.states, M = C.states.columns.value;
      if (M.some(({ type: N }) => N === "expand")) {
        const N = A(S), $ = O(S, _, void 0, N), F = e.renderExpanded;
        return N ? F ? [
          [
            $,
            et("tr", {
              key: `expanded-row__${$.key}`
            }, [
              et("td", {
                colspan: M.length,
                class: `${t.e("cell")} ${t.e("expanded-cell")}`
              }, [F({ row: S, $index: _, store: C, expanded: N })])
            ])
          ]
        ] : (console.error("[Element Error]renderExpanded is required."), $) : [[$]];
      } else if (Object.keys(P.value).length) {
        k();
        const N = li(S, E.value);
        let $ = P.value[N], F = null;
        $ && (F = {
          expanded: $.expanded,
          level: $.level,
          display: !0
        }, typeof $.lazy == "boolean" && (typeof $.loaded == "boolean" && $.loaded && (F.noLazyChildren = !($.children && $.children.length)), F.loading = $.loading));
        const W = [O(S, _, F)];
        if ($) {
          let j = 0;
          const Y = (ie, ae) => {
            ie && ie.length && ae && ie.forEach((ee) => {
              const ne = {
                display: ae.display && ae.expanded,
                level: ae.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, ye = li(ee, E.value);
              if (ye == null)
                throw new Error("For nested data item, row-key is required.");
              if ($ = { ...P.value[ye] }, $ && (ne.expanded = $.expanded, $.level = $.level || ne.level, $.display = !!($.expanded && ne.display), typeof $.lazy == "boolean" && (typeof $.loaded == "boolean" && $.loaded && (ne.noLazyChildren = !($.children && $.children.length)), ne.loading = $.loading)), j++, W.push(O(ee, _ + j, ne)), $) {
                const te = L.value[ye] || ee[D.value];
                Y(te, $);
              }
            });
          };
          $.display = !0;
          const X = L.value[N] || S[D.value];
          Y(X, $);
        }
        return W;
      } else
        return O(S, _, void 0);
    },
    tooltipContent: c,
    tooltipTrigger: h
  };
}
const zSe = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var FSe = U({
  name: "ElTableBody",
  props: zSe,
  setup(n) {
    const e = wt(), t = Re(Pl), r = Pe("table"), { wrappedRowRender: i, tooltipContent: o, tooltipTrigger: a } = VSe(n), { onColumnsChange: s, onScrollableChange: l } = zH(t), u = [];
    return he(n.store.states.hoverRow, (c, h) => {
      var f;
      const d = e == null ? void 0 : e.vnode.el, p = Array.from((d == null ? void 0 : d.children) || []).filter((m) => m == null ? void 0 : m.classList.contains(`${r.e("row")}`));
      let g = c;
      const v = (f = p[g]) == null ? void 0 : f.childNodes;
      v != null && v.length ? Array.from(v).reduce((y, b, O) => {
        var w, x;
        const S = ((w = v[O - 1]) == null ? void 0 : w.colSpan) > 1, _ = ((x = v[O + 1]) == null ? void 0 : x.colSpan) > 1;
        return b.nodeName !== "TD" && !S && !_ && y.push(O), y;
      }, []).forEach((y) => {
        for (var b; g > 0; ) {
          const O = (b = p[g - 1]) == null ? void 0 : b.childNodes;
          if (O[y] && O[y].nodeName === "TD") {
            fg(O[y], "hover-cell"), u.push(O[y]);
            break;
          }
          g--;
        }
      }) : (u.forEach((m) => Ul(m, "hover-cell")), u.length = 0), !(!n.store.states.isComplex.value || !qt) && yve(() => {
        const m = p[h], y = p[c];
        m && !m.classList.contains("hover-fixed-row") && Ul(m, "hover-row"), y && fg(y, "hover-row");
      });
    }), ub(() => {
      var c;
      (c = ia) == null || c();
    }), {
      ns: r,
      onColumnsChange: s,
      onScrollableChange: l,
      wrappedRowRender: i,
      tooltipContent: o,
      tooltipTrigger: a
    };
  },
  render() {
    const { wrappedRowRender: n, store: e } = this, t = e.states.data.value || [];
    return et("tbody", { tabIndex: -1 }, [
      t.reduce((r, i) => r.concat(n(i, r.length)), [])
    ]);
  }
});
function QSe() {
  const n = Re(Pl), e = n == null ? void 0 : n.store, t = B(() => e.states.fixedLeafColumnsLength.value), r = B(() => e.states.rightFixedColumns.value.length), i = B(() => e.states.columns.value.length), o = B(() => e.states.fixedColumns.value.length), a = B(() => e.states.rightFixedColumns.value.length);
  return {
    leftFixedLeafCount: t,
    rightFixedLeafCount: r,
    columnsCount: i,
    leftFixedCount: o,
    rightFixedCount: a,
    columns: e.states.columns
  };
}
function ZSe(n) {
  const { columns: e } = QSe(), t = Pe("table");
  return {
    getCellClasses: (o, a) => {
      const s = o[a], l = [
        t.e("cell"),
        s.id,
        s.align,
        s.labelClassName,
        ...jL(t.b(), a, s.fixed, n.store)
      ];
      return s.className && l.push(s.className), s.children || l.push(t.is("leaf")), l;
    },
    getCellStyles: (o, a) => {
      const s = HL(a, o.fixed, n.store);
      return bg(s, "left"), bg(s, "right"), s;
    },
    columns: e
  };
}
var WSe = U({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(n) {
    const { getCellClasses: e, getCellStyles: t, columns: r } = ZSe(n);
    return {
      ns: Pe("table"),
      getCellClasses: e,
      getCellStyles: t,
      columns: r
    };
  },
  render() {
    const { columns: n, getCellStyles: e, getCellClasses: t, summaryMethod: r, sumText: i } = this, o = this.store.states.data.value;
    let a = [];
    return r ? a = r({
      columns: n,
      data: o
    }) : n.forEach((s, l) => {
      if (l === 0) {
        a[l] = i;
        return;
      }
      const u = o.map((d) => Number(d[s.property])), c = [];
      let h = !0;
      u.forEach((d) => {
        if (!Number.isNaN(+d)) {
          h = !1;
          const p = `${d}`.split(".")[1];
          c.push(p ? p.length : 0);
        }
      });
      const f = Math.max.apply(null, c);
      h ? a[l] = "" : a[l] = u.reduce((d, p) => {
        const g = Number(p);
        return Number.isNaN(+g) ? d : Number.parseFloat((d + p).toFixed(Math.min(f, 20)));
      }, 0);
    }), et(et("tfoot", [
      et("tr", {}, [
        ...n.map((s, l) => et("td", {
          key: l,
          colspan: s.colSpan,
          rowspan: s.rowSpan,
          class: t(n, l),
          style: e(s, l)
        }, [
          et("div", {
            class: ["cell", s.labelClassName]
          }, [a[l]])
        ]))
      ])
    ]));
  }
});
function GSe(n) {
  return {
    setCurrentRow: (c) => {
      n.commit("setCurrentRow", c);
    },
    getSelectionRows: () => n.getSelectionRows(),
    toggleRowSelection: (c, h) => {
      n.toggleRowSelection(c, h, !1), n.updateAllSelected();
    },
    clearSelection: () => {
      n.clearSelection();
    },
    clearFilter: (c) => {
      n.clearFilter(c);
    },
    toggleAllSelection: () => {
      n.commit("toggleAllSelection");
    },
    toggleRowExpansion: (c, h) => {
      n.toggleRowExpansionAdapter(c, h);
    },
    clearSort: () => {
      n.clearSort();
    },
    sort: (c, h) => {
      n.commit("sort", { prop: c, order: h });
    }
  };
}
function jSe(n, e, t, r) {
  const i = z(!1), o = z(null), a = z(!1), s = ($) => {
    a.value = $;
  }, l = z({
    width: null,
    height: null,
    headerHeight: null
  }), u = z(!1), c = {
    display: "inline-block",
    verticalAlign: "middle"
  }, h = z(), f = z(0), d = z(0), p = z(0), g = z(0), v = z(0);
  sl(() => {
    e.setHeight(n.height);
  }), sl(() => {
    e.setMaxHeight(n.maxHeight);
  }), he(() => [n.currentRowKey, t.states.rowKey], ([$, F]) => {
    !T(F) || !T($) || t.setCurrentRowKey(`${$}`);
  }, {
    immediate: !0
  }), he(() => n.data, ($) => {
    r.store.commit("setData", $);
  }, {
    immediate: !0,
    deep: !0
  }), sl(() => {
    n.expandRowKeys && t.setExpandRowKeysAdapter(n.expandRowKeys);
  });
  const m = () => {
    r.store.commit("setHoverRow", null), r.hoverState && (r.hoverState = null);
  }, y = ($, F) => {
    const { pixelX: W, pixelY: j } = F;
    Math.abs(W) >= Math.abs(j) && (r.refs.bodyWrapper.scrollLeft += F.pixelX / 5);
  }, b = B(() => n.height || n.maxHeight || t.states.fixedColumns.value.length > 0 || t.states.rightFixedColumns.value.length > 0), O = B(() => ({
    width: e.bodyWidth.value ? `${e.bodyWidth.value}px` : ""
  })), w = () => {
    b.value && e.updateElsHeight(), e.updateColumnsWidth(), requestAnimationFrame(C);
  };
  ht(async () => {
    await Ke(), t.updateColumns(), A(), requestAnimationFrame(w);
    const $ = r.vnode.el, F = r.refs.headerWrapper;
    n.flexible && $ && $.parentElement && ($.parentElement.style.minWidth = "0"), l.value = {
      width: h.value = $.offsetWidth,
      height: $.offsetHeight,
      headerHeight: n.showHeader && F ? F.offsetHeight : null
    }, t.states.columns.value.forEach((W) => {
      W.filteredValue && W.filteredValue.length && r.store.commit("filterChange", {
        column: W,
        values: W.filteredValue,
        silent: !0
      });
    }), r.$ready = !0;
  });
  const x = ($, F) => {
    if (!$)
      return;
    const W = Array.from($.classList).filter((j) => !j.startsWith("is-scrolling-"));
    W.push(e.scrollX.value ? F : "is-scrolling-none"), $.className = W.join(" ");
  }, S = ($) => {
    const { tableWrapper: F } = r.refs;
    x(F, $);
  }, _ = ($) => {
    const { tableWrapper: F } = r.refs;
    return !!(F && F.classList.contains($));
  }, C = function() {
    if (!r.refs.scrollBarRef)
      return;
    if (!e.scrollX.value) {
      const ae = "is-scrolling-none";
      _(ae) || S(ae);
      return;
    }
    const $ = r.refs.scrollBarRef.wrapRef;
    if (!$)
      return;
    const { scrollLeft: F, offsetWidth: W, scrollWidth: j } = $, { headerWrapper: Y, footerWrapper: X } = r.refs;
    Y && (Y.scrollLeft = F), X && (X.scrollLeft = F);
    const ie = j - W - 1;
    F >= ie ? S("is-scrolling-right") : S(F === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, A = () => {
    r.refs.scrollBarRef && (r.refs.scrollBarRef.wrapRef && Yi(r.refs.scrollBarRef.wrapRef, "scroll", C, {
      passive: !0
    }), n.fit ? Ei(r.vnode.el, k) : Yi(window, "resize", k), Ei(r.refs.bodyWrapper, () => {
      var $, F;
      k(), (F = ($ = r.refs) == null ? void 0 : $.scrollBarRef) == null || F.update();
    }));
  }, k = () => {
    var $, F, W, j;
    const Y = r.vnode.el;
    if (!r.$ready || !Y)
      return;
    let X = !1;
    const {
      width: ie,
      height: ae,
      headerHeight: ee
    } = l.value, ne = h.value = Y.offsetWidth;
    ie !== ne && (X = !0);
    const ye = Y.offsetHeight;
    (n.height || b.value) && ae !== ye && (X = !0);
    const te = n.tableLayout === "fixed" ? r.refs.headerWrapper : ($ = r.refs.tableHeaderRef) == null ? void 0 : $.$el;
    n.showHeader && (te == null ? void 0 : te.offsetHeight) !== ee && (X = !0), f.value = ((F = r.refs.tableWrapper) == null ? void 0 : F.scrollHeight) || 0, p.value = (te == null ? void 0 : te.scrollHeight) || 0, g.value = ((W = r.refs.footerWrapper) == null ? void 0 : W.offsetHeight) || 0, v.value = ((j = r.refs.appendWrapper) == null ? void 0 : j.offsetHeight) || 0, d.value = f.value - p.value - g.value - v.value, X && (l.value = {
      width: ne,
      height: ye,
      headerHeight: n.showHeader && (te == null ? void 0 : te.offsetHeight) || 0
    }, w());
  }, P = ko(), L = B(() => {
    const { bodyWidth: $, scrollY: F, gutterWidth: W } = e;
    return $.value ? `${$.value - (F.value ? W : 0)}px` : "";
  }), D = B(() => n.maxHeight ? "fixed" : n.tableLayout), E = B(() => {
    if (n.data && n.data.length)
      return null;
    let $ = "100%";
    n.height && d.value && ($ = `${d.value}px`);
    const F = h.value;
    return {
      width: F ? `${F}px` : "",
      height: $
    };
  }), M = B(() => n.height ? {
    height: Number.isNaN(Number(n.height)) ? n.height : `${n.height}px`
  } : n.maxHeight ? {
    maxHeight: Number.isNaN(Number(n.maxHeight)) ? n.maxHeight : `${n.maxHeight}px`
  } : {}), R = B(() => n.height ? {
    height: "100%"
  } : n.maxHeight ? Number.isNaN(Number(n.maxHeight)) ? {
    maxHeight: `calc(${n.maxHeight} - ${p.value + g.value}px)`
  } : {
    maxHeight: `${n.maxHeight - p.value - g.value}px`
  } : {});
  return {
    isHidden: i,
    renderExpanded: o,
    setDragVisible: s,
    isGroup: u,
    handleMouseLeave: m,
    handleHeaderFooterMousewheel: y,
    tableSize: P,
    emptyBlockStyle: E,
    handleFixedMousewheel: ($, F) => {
      const W = r.refs.bodyWrapper;
      if (Math.abs(F.spinY) > 0) {
        const j = W.scrollTop;
        F.pixelY < 0 && j !== 0 && $.preventDefault(), F.pixelY > 0 && W.scrollHeight - W.clientHeight > j && $.preventDefault(), W.scrollTop += Math.ceil(F.pixelY / 5);
      } else
        W.scrollLeft += Math.ceil(F.pixelX / 5);
    },
    resizeProxyVisible: a,
    bodyWidth: L,
    resizeState: l,
    doLayout: w,
    tableBodyStyles: O,
    tableLayout: D,
    scrollbarViewStyle: c,
    tableInnerStyle: M,
    scrollbarStyle: R
  };
}
function HSe(n) {
  const e = z(), t = () => {
    const i = n.vnode.el.querySelector(".hidden-columns"), o = { childList: !0, subtree: !0 }, a = n.store.states.updateOrderFns;
    e.value = new MutationObserver(() => {
      a.forEach((s) => s());
    }), e.value.observe(i, o);
  };
  ht(() => {
    t();
  }), ub(() => {
    var r;
    (r = e.value) == null || r.disconnect();
  });
}
var qSe = {
  data: {
    type: Array,
    default: () => []
  },
  size: Ra,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  },
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object]
};
function QH(n) {
  const e = n.tableLayout === "auto";
  let t = n.columns || [];
  e && t.every((i) => i.width === void 0) && (t = []);
  const r = (i) => {
    const o = {
      key: `${n.tableLayout}_${i.id}`,
      style: {},
      name: void 0
    };
    return e ? o.style = {
      width: `${i.width}px`
    } : o.name = i.id, o;
  };
  return et("colgroup", {}, t.map((i) => et("col", r(i))));
}
QH.props = ["columns", "tableLayout"];
const YSe = () => {
  const n = z(), e = (o, a) => {
    const s = n.value;
    s && s.scrollTo(o, a);
  }, t = (o, a) => {
    const s = n.value;
    s && _t(a) && ["Top", "Left"].includes(o) && s[`setScroll${o}`](a);
  };
  return {
    scrollBarRef: n,
    scrollTo: e,
    setScrollTop: (o) => t("Top", o),
    setScrollLeft: (o) => t("Left", o)
  };
};
let XSe = 1;
const USe = U({
  name: "ElTable",
  directives: {
    Mousewheel: Nbe
  },
  components: {
    TableHeader: NSe,
    TableBody: FSe,
    TableFooter: WSe,
    ElScrollbar: Ob,
    hColgroup: QH
  },
  props: qSe,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(n) {
    const { t: e } = Ar(), t = Pe("table"), r = wt();
    Wt(Pl, r);
    const i = xSe(r, n);
    r.store = i;
    const o = new _Se({
      store: r.store,
      table: r,
      fit: n.fit,
      showHeader: n.showHeader
    });
    r.layout = o;
    const a = B(() => (i.states.data.value || []).length === 0), {
      setCurrentRow: s,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: h,
      toggleAllSelection: f,
      toggleRowExpansion: d,
      clearSort: p,
      sort: g
    } = GSe(i), {
      isHidden: v,
      renderExpanded: m,
      setDragVisible: y,
      isGroup: b,
      handleMouseLeave: O,
      handleHeaderFooterMousewheel: w,
      tableSize: x,
      emptyBlockStyle: S,
      handleFixedMousewheel: _,
      resizeProxyVisible: C,
      bodyWidth: A,
      resizeState: k,
      doLayout: P,
      tableBodyStyles: L,
      tableLayout: D,
      scrollbarViewStyle: E,
      tableInnerStyle: M,
      scrollbarStyle: R
    } = jSe(n, o, i, r), { scrollBarRef: N, scrollTo: $, setScrollLeft: F, setScrollTop: W } = YSe(), j = kc(P, 50), Y = `${t.namespace.value}-table_${XSe++}`;
    r.tableId = Y, r.state = {
      isGroup: b,
      resizeState: k,
      doLayout: P,
      debouncedUpdateLayout: j
    };
    const X = B(() => n.sumText || e("el.table.sumText")), ie = B(() => n.emptyText || e("el.table.emptyText"));
    return HSe(r), {
      ns: t,
      layout: o,
      store: i,
      handleHeaderFooterMousewheel: w,
      handleMouseLeave: O,
      tableId: Y,
      tableSize: x,
      isHidden: v,
      isEmpty: a,
      renderExpanded: m,
      resizeProxyVisible: C,
      resizeState: k,
      isGroup: b,
      bodyWidth: A,
      tableBodyStyles: L,
      emptyBlockStyle: S,
      debouncedUpdateLayout: j,
      handleFixedMousewheel: _,
      setCurrentRow: s,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: h,
      toggleAllSelection: f,
      toggleRowExpansion: d,
      clearSort: p,
      doLayout: P,
      sort: g,
      t: e,
      setDragVisible: y,
      context: r,
      computedSumText: X,
      computedEmptyText: ie,
      tableLayout: D,
      scrollbarViewStyle: E,
      tableInnerStyle: M,
      scrollbarStyle: R,
      scrollBarRef: N,
      scrollTo: $,
      setScrollLeft: F,
      setScrollTop: W
    };
  }
}), KSe = ["data-prefix"], JSe = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function e_e(n, e, t, r, i, o) {
  const a = Ct("hColgroup"), s = Ct("table-header"), l = Ct("table-body"), u = Ct("table-footer"), c = Ct("el-scrollbar"), h = eL("mousewheel");
  return V(), q("div", {
    ref: "tableWrapper",
    class: Q([
      {
        [n.ns.m("fit")]: n.fit,
        [n.ns.m("striped")]: n.stripe,
        [n.ns.m("border")]: n.border || n.isGroup,
        [n.ns.m("hidden")]: n.isHidden,
        [n.ns.m("group")]: n.isGroup,
        [n.ns.m("fluid-height")]: n.maxHeight,
        [n.ns.m("scrollable-x")]: n.layout.scrollX.value,
        [n.ns.m("scrollable-y")]: n.layout.scrollY.value,
        [n.ns.m("enable-row-hover")]: !n.store.states.isComplex.value,
        [n.ns.m("enable-row-transition")]: (n.store.states.data.value || []).length !== 0 && (n.store.states.data.value || []).length < 100,
        "has-footer": n.showSummary
      },
      n.ns.m(n.tableSize),
      n.className,
      n.ns.b(),
      n.ns.m(`layout-${n.tableLayout}`)
    ]),
    style: vt(n.style),
    "data-prefix": n.ns.namespace.value,
    onMouseleave: e[0] || (e[0] = (...f) => n.handleMouseLeave && n.handleMouseLeave(...f))
  }, [
    J("div", {
      class: Q(n.ns.e("inner-wrapper")),
      style: vt(n.tableInnerStyle)
    }, [
      J("div", JSe, [
        ke(n.$slots, "default")
      ], 512),
      n.showHeader && n.tableLayout === "fixed" ? At((V(), q("div", {
        key: 0,
        ref: "headerWrapper",
        class: Q(n.ns.e("header-wrapper"))
      }, [
        J("table", {
          ref: "tableHeader",
          class: Q(n.ns.e("header")),
          style: vt(n.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          de(a, {
            columns: n.store.states.columns.value,
            "table-layout": n.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          de(s, {
            ref: "tableHeaderRef",
            border: n.border,
            "default-sort": n.defaultSort,
            store: n.store,
            onSetDragVisible: n.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [h, n.handleHeaderFooterMousewheel]
      ]) : pe("v-if", !0),
      J("div", {
        ref: "bodyWrapper",
        class: Q(n.ns.e("body-wrapper"))
      }, [
        de(c, {
          ref: "scrollBarRef",
          "view-style": n.scrollbarViewStyle,
          "wrap-style": n.scrollbarStyle,
          always: n.scrollbarAlwaysOn
        }, {
          default: fe(() => [
            J("table", {
              ref: "tableBody",
              class: Q(n.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: vt({
                width: n.bodyWidth,
                tableLayout: n.tableLayout
              })
            }, [
              de(a, {
                columns: n.store.states.columns.value,
                "table-layout": n.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              n.showHeader && n.tableLayout === "auto" ? (V(), ve(s, {
                key: 0,
                ref: "tableHeaderRef",
                class: Q(n.ns.e("body-header")),
                border: n.border,
                "default-sort": n.defaultSort,
                store: n.store,
                onSetDragVisible: n.setDragVisible
              }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : pe("v-if", !0),
              de(l, {
                context: n.context,
                highlight: n.highlightCurrentRow,
                "row-class-name": n.rowClassName,
                "tooltip-effect": n.tooltipEffect,
                "tooltip-options": n.tooltipOptions,
                "row-style": n.rowStyle,
                store: n.store,
                stripe: n.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
              n.showSummary && n.tableLayout === "auto" ? (V(), ve(u, {
                key: 1,
                class: Q(n.ns.e("body-footer")),
                border: n.border,
                "default-sort": n.defaultSort,
                store: n.store,
                "sum-text": n.computedSumText,
                "summary-method": n.summaryMethod
              }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : pe("v-if", !0)
            ], 6),
            n.isEmpty ? (V(), q("div", {
              key: 0,
              ref: "emptyBlock",
              style: vt(n.emptyBlockStyle),
              class: Q(n.ns.e("empty-block"))
            }, [
              J("span", {
                class: Q(n.ns.e("empty-text"))
              }, [
                ke(n.$slots, "empty", {}, () => [
                  Ri(ze(n.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : pe("v-if", !0),
            n.$slots.append ? (V(), q("div", {
              key: 1,
              ref: "appendWrapper",
              class: Q(n.ns.e("append-wrapper"))
            }, [
              ke(n.$slots, "append")
            ], 2)) : pe("v-if", !0)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      n.showSummary && n.tableLayout === "fixed" ? At((V(), q("div", {
        key: 1,
        ref: "footerWrapper",
        class: Q(n.ns.e("footer-wrapper"))
      }, [
        J("table", {
          class: Q(n.ns.e("footer")),
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: vt(n.tableBodyStyles)
        }, [
          de(a, {
            columns: n.store.states.columns.value,
            "table-layout": n.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          de(u, {
            border: n.border,
            "default-sort": n.defaultSort,
            store: n.store,
            "sum-text": n.computedSumText,
            "summary-method": n.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
        ], 6)
      ], 2)), [
        [On, !n.isEmpty],
        [h, n.handleHeaderFooterMousewheel]
      ]) : pe("v-if", !0),
      n.border || n.isGroup ? (V(), q("div", {
        key: 2,
        class: Q(n.ns.e("border-left-patch"))
      }, null, 2)) : pe("v-if", !0)
    ], 6),
    At(J("div", {
      ref: "resizeProxy",
      class: Q(n.ns.e("column-resize-proxy"))
    }, null, 2), [
      [On, n.resizeProxyVisible]
    ])
  ], 46, KSe);
}
var t_e = /* @__PURE__ */ Ve(USe, [["render", e_e], ["__file", "table.vue"]]);
const n_e = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, r_e = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, i_e = (n) => n_e[n] || "", o_e = {
  selection: {
    renderHeader({ store: n, column: e }) {
      function t() {
        return n.states.data.value && n.states.data.value.length === 0;
      }
      return et(yl, {
        disabled: t(),
        size: n.states.tableSize.value,
        indeterminate: n.states.selection.value.length > 0 && !n.states.isAllSelected.value,
        "onUpdate:modelValue": n.toggleAllSelection,
        modelValue: n.states.isAllSelected.value,
        ariaLabel: e.label
      });
    },
    renderCell({
      row: n,
      column: e,
      store: t,
      $index: r
    }) {
      return et(yl, {
        disabled: e.selectable ? !e.selectable.call(null, n, r) : !1,
        size: t.states.tableSize.value,
        onChange: () => {
          t.commit("rowSelectedChanged", n);
        },
        onClick: (i) => i.stopPropagation(),
        modelValue: t.isSelected(n),
        ariaLabel: e.label
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({ column: n }) {
      return n.label || "#";
    },
    renderCell({
      column: n,
      $index: e
    }) {
      let t = e + 1;
      const r = n.index;
      return typeof r == "number" ? t = e + r : typeof r == "function" && (t = r(e)), et("div", {}, [t]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({ column: n }) {
      return n.label || "";
    },
    renderCell({
      row: n,
      store: e,
      expanded: t
    }) {
      const { ns: r } = e, i = [r.e("expand-icon")];
      return t && i.push(r.em("expand-icon", "expanded")), et("div", {
        class: i,
        onClick: function(a) {
          a.stopPropagation(), e.toggleRowExpansion(n);
        }
      }, {
        default: () => [
          et(bt, null, {
            default: () => [et(Sd)]
          })
        ]
      });
    },
    sortable: !1,
    resizable: !1
  }
};
function a_e({
  row: n,
  column: e,
  $index: t
}) {
  var r;
  const i = e.property, o = i && nw(n, i).value;
  return e && e.formatter ? e.formatter(n, e, o, t) : ((r = o == null ? void 0 : o.toString) == null ? void 0 : r.call(o)) || "";
}
function s_e({
  row: n,
  treeNode: e,
  store: t
}, r = !1) {
  const { ns: i } = t;
  if (!e)
    return r ? [
      et("span", {
        class: i.e("placeholder")
      })
    ] : null;
  const o = [], a = function(s) {
    s.stopPropagation(), !e.loading && t.loadOrToggle(n);
  };
  if (e.indent && o.push(et("span", {
    class: i.e("indent"),
    style: { "padding-left": `${e.indent}px` }
  })), typeof e.expanded == "boolean" && !e.noLazyChildren) {
    const s = [
      i.e("expand-icon"),
      e.expanded ? i.em("expand-icon", "expanded") : ""
    ];
    let l = Sd;
    e.loading && (l = _d), o.push(et("div", {
      class: s,
      onClick: a
    }, {
      default: () => [
        et(bt, { class: { [i.is("loading")]: e.loading } }, {
          default: () => [et(l)]
        })
      ]
    }));
  } else
    o.push(et("span", {
      class: i.e("placeholder")
    }));
  return o;
}
function $B(n, e) {
  return n.reduce((t, r) => (t[r] = r, t), e);
}
function l_e(n, e) {
  const t = wt();
  return {
    registerComplexWatchers: () => {
      const o = ["fixed"], a = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, s = $B(o, a);
      Object.keys(s).forEach((l) => {
        const u = a[l];
        To(e, u) && he(() => e[u], (c) => {
          let h = c;
          u === "width" && l === "realWidth" && (h = GL(c)), u === "minWidth" && l === "realMinWidth" && (h = RH(c)), t.columnConfig.value[u] = h, t.columnConfig.value[l] = h;
          const f = u === "fixed";
          n.value.store.scheduleLayout(f);
        });
      });
    },
    registerNormalWatchers: () => {
      const o = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "filterClassName",
        "showOverflowTooltip"
      ], a = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, s = $B(o, a);
      Object.keys(s).forEach((l) => {
        const u = a[l];
        To(e, u) && he(() => e[u], (c) => {
          t.columnConfig.value[l] = c;
        });
      });
    }
  };
}
function u_e(n, e, t) {
  const r = wt(), i = z(""), o = z(!1), a = z(), s = z(), l = Pe("table");
  sl(() => {
    a.value = n.align ? `is-${n.align}` : null, a.value;
  }), sl(() => {
    s.value = n.headerAlign ? `is-${n.headerAlign}` : a.value, s.value;
  });
  const u = B(() => {
    let O = r.vnode.vParent || r.parent;
    for (; O && !O.tableId && !O.columnId; )
      O = O.vnode.vParent || O.parent;
    return O;
  }), c = B(() => {
    const { store: O } = r.parent;
    if (!O)
      return !1;
    const { treeData: w } = O.states, x = w.value;
    return x && Object.keys(x).length > 0;
  }), h = z(GL(n.width)), f = z(RH(n.minWidth)), d = (O) => (h.value && (O.width = h.value), f.value && (O.minWidth = f.value), !h.value && f.value && (O.width = void 0), O.minWidth || (O.minWidth = 80), O.realWidth = Number(O.width === void 0 ? O.minWidth : O.width), O), p = (O) => {
    const w = O.type, x = o_e[w] || {};
    Object.keys(x).forEach((_) => {
      const C = x[_];
      _ !== "className" && C !== void 0 && (O[_] = C);
    });
    const S = i_e(w);
    if (S) {
      const _ = `${T(l.namespace)}-${S}`;
      O.className = O.className ? `${O.className} ${_}` : _;
    }
    return O;
  }, g = (O) => {
    Array.isArray(O) ? O.forEach((x) => w(x)) : w(O);
    function w(x) {
      var S;
      ((S = x == null ? void 0 : x.type) == null ? void 0 : S.name) === "ElTableColumn" && (x.vParent = r);
    }
  };
  return {
    columnId: i,
    realAlign: a,
    isSubColumn: o,
    realHeaderAlign: s,
    columnOrTableParent: u,
    setColumnWidth: d,
    setColumnForcedProps: p,
    setColumnRenders: (O) => {
      n.renderHeader ? Ht("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : O.type !== "selection" && (O.renderHeader = (x) => (r.columnConfig.value.label, ke(e, "header", x, () => [O.label])));
      let w = O.renderCell;
      return O.type === "expand" ? (O.renderCell = (x) => et("div", {
        class: "cell"
      }, [w(x)]), t.value.renderExpanded = (x) => e.default ? e.default(x) : e.default) : (w = w || a_e, O.renderCell = (x) => {
        let S = null;
        if (e.default) {
          const L = e.default(x);
          S = L.some((D) => D.type !== MG) ? L : w(x);
        } else
          S = w(x);
        const { columns: _ } = t.value.store.states, C = _.value.findIndex((L) => L.type === "default"), A = c.value && x.cellIndex === C, k = s_e(x, A), P = {
          class: "cell",
          style: {}
        };
        return O.showOverflowTooltip && (P.class = `${P.class} ${T(l.namespace)}-tooltip`, P.style = {
          width: `${(x.column.realWidth || Number(x.column.width)) - 1}px`
        }), g(S), et("div", P, [k, S]);
      }), O;
    },
    getPropsData: (...O) => O.reduce((w, x) => (Array.isArray(x) && x.forEach((S) => {
      w[S] = n[S];
    }), w), {}),
    getColumnElIndex: (O, w) => Array.prototype.indexOf.call(O, w),
    updateColumnOrder: () => {
      t.value.store.commit("updateColumnOrder", r.columnConfig.value);
    }
  };
}
var c_e = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  filterClassName: String,
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (n) => n.every((e) => ["ascending", "descending", null].includes(e))
  }
};
let h_e = 1;
var ZH = U({
  name: "ElTableColumn",
  components: {
    ElCheckbox: yl
  },
  props: c_e,
  setup(n, { slots: e }) {
    const t = wt(), r = z({}), i = B(() => {
      let b = t.parent;
      for (; b && !b.tableId; )
        b = b.parent;
      return b;
    }), { registerNormalWatchers: o, registerComplexWatchers: a } = l_e(i, n), {
      columnId: s,
      isSubColumn: l,
      realHeaderAlign: u,
      columnOrTableParent: c,
      setColumnWidth: h,
      setColumnForcedProps: f,
      setColumnRenders: d,
      getPropsData: p,
      getColumnElIndex: g,
      realAlign: v,
      updateColumnOrder: m
    } = u_e(n, e, i), y = c.value;
    s.value = `${y.tableId || y.columnId}_column_${h_e++}`, JD(() => {
      l.value = i.value !== y;
      const b = n.type || "default", O = n.sortable === "" ? !0 : n.sortable, w = Li(n.showOverflowTooltip) ? y.props.showOverflowTooltip : n.showOverflowTooltip, x = {
        ...r_e[b],
        id: s.value,
        type: b,
        property: n.prop || n.property,
        align: v,
        headerAlign: u,
        showOverflowTooltip: w,
        filterable: n.filters || n.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        filterClassName: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: O,
        index: n.index,
        rawColumnKey: t.vnode.key
      };
      let k = p([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement",
        "filterClassName"
      ]);
      k = hSe(x, k), k = dSe(d, h, f)(k), r.value = k, o(), a();
    }), ht(() => {
      var b;
      const O = c.value, w = l.value ? O.vnode.el.children : (b = O.refs.hiddenColumns) == null ? void 0 : b.children, x = () => g(w || [], t.vnode.el);
      r.value.getColumnIndex = x, x() > -1 && i.value.store.commit("insertColumn", r.value, l.value ? O.columnConfig.value : null, m);
    }), xi(() => {
      i.value.store.commit("removeColumn", r.value, l.value ? y.columnConfig.value : null, m);
    }), t.columnId = s.value, t.columnConfig = r;
  },
  render() {
    var n, e, t;
    try {
      const r = (e = (n = this.$slots).default) == null ? void 0 : e.call(n, {
        row: {},
        column: {},
        $index: -1
      }), i = [];
      if (Array.isArray(r))
        for (const a of r)
          ((t = a.type) == null ? void 0 : t.name) === "ElTableColumn" || a.shapeFlag & 2 ? i.push(a) : a.type === yn && Array.isArray(a.children) && a.children.forEach((s) => {
            (s == null ? void 0 : s.patchFlag) !== 1024 && !Ut(s == null ? void 0 : s.children) && i.push(s);
          });
      return et("div", i);
    } catch {
      return et("div", []);
    }
  }
});
const p6t = zn(t_e, {
  TableColumn: ZH
}), g6t = Os(ZH), C_ = Symbol("tabsRootContextKey"), f_e = Ye({
  tabs: {
    type: Ae(Array),
    default: () => ih([])
  }
}), WH = "ElTabBar", d_e = U({
  name: WH
}), p_e = /* @__PURE__ */ U({
  ...d_e,
  props: f_e,
  setup(n, { expose: e }) {
    const t = n, r = wt(), i = Re(C_);
    i || Su(WH, "<el-tabs><el-tab-bar /></el-tabs>");
    const o = Pe("tabs"), a = z(), s = z(), l = () => {
      let c = 0, h = 0;
      const f = ["top", "bottom"].includes(i.props.tabPosition) ? "width" : "height", d = f === "width" ? "x" : "y", p = d === "x" ? "left" : "top";
      return t.tabs.every((g) => {
        var v, m;
        const y = (m = (v = r.parent) == null ? void 0 : v.refs) == null ? void 0 : m[`tab-${g.uid}`];
        if (!y)
          return !1;
        if (!g.active)
          return !0;
        c = y[`offset${js(p)}`], h = y[`client${js(f)}`];
        const b = window.getComputedStyle(y);
        return f === "width" && (t.tabs.length > 1 && (h -= Number.parseFloat(b.paddingLeft) + Number.parseFloat(b.paddingRight)), c += Number.parseFloat(b.paddingLeft)), !1;
      }), {
        [f]: `${h}px`,
        transform: `translate${js(d)}(${c}px)`
      };
    }, u = () => s.value = l();
    return he(() => t.tabs, async () => {
      await Ke(), u();
    }, { immediate: !0 }), Ei(a, () => u()), e({
      ref: a,
      update: u
    }), (c, h) => (V(), q("div", {
      ref_key: "barRef",
      ref: a,
      class: Q([T(o).e("active-bar"), T(o).is(T(i).props.tabPosition)]),
      style: vt(s.value)
    }, null, 6));
  }
});
var g_e = /* @__PURE__ */ Ve(p_e, [["__file", "tab-bar.vue"]]);
const v_e = Ye({
  panes: {
    type: Ae(Array),
    default: () => ih([])
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean
}), m_e = {
  tabClick: (n, e, t) => t instanceof Event,
  tabRemove: (n, e) => e instanceof Event
}, BB = "ElTabNav", y_e = U({
  name: BB,
  props: v_e,
  emits: m_e,
  setup(n, {
    expose: e,
    emit: t
  }) {
    const r = wt(), i = Re(C_);
    i || Su(BB, "<el-tabs><tab-nav /></el-tabs>");
    const o = Pe("tabs"), a = Fge(), s = eve(), l = z(), u = z(), c = z(), h = z(), f = z(!1), d = z(0), p = z(!1), g = z(!0), v = B(() => ["top", "bottom"].includes(i.props.tabPosition) ? "width" : "height"), m = B(() => ({
      transform: `translate${v.value === "width" ? "X" : "Y"}(-${d.value}px)`
    })), y = () => {
      if (!l.value)
        return;
      const C = l.value[`offset${js(v.value)}`], A = d.value;
      if (!A)
        return;
      const k = A > C ? A - C : 0;
      d.value = k;
    }, b = () => {
      if (!l.value || !u.value)
        return;
      const C = u.value[`offset${js(v.value)}`], A = l.value[`offset${js(v.value)}`], k = d.value;
      if (C - k <= A)
        return;
      const P = C - k > A * 2 ? k + A : C - A;
      d.value = P;
    }, O = async () => {
      const C = u.value;
      if (!f.value || !c.value || !l.value || !C)
        return;
      await Ke();
      const A = c.value.querySelector(".is-active");
      if (!A)
        return;
      const k = l.value, P = ["top", "bottom"].includes(i.props.tabPosition), L = A.getBoundingClientRect(), D = k.getBoundingClientRect(), E = P ? C.offsetWidth - D.width : C.offsetHeight - D.height, M = d.value;
      let R = M;
      P ? (L.left < D.left && (R = M - (D.left - L.left)), L.right > D.right && (R = M + L.right - D.right)) : (L.top < D.top && (R = M - (D.top - L.top)), L.bottom > D.bottom && (R = M + (L.bottom - D.bottom))), R = Math.max(R, 0), d.value = Math.min(R, E);
    }, w = () => {
      var C;
      if (!u.value || !l.value)
        return;
      n.stretch && ((C = h.value) == null || C.update());
      const A = u.value[`offset${js(v.value)}`], k = l.value[`offset${js(v.value)}`], P = d.value;
      k < A ? (f.value = f.value || {}, f.value.prev = P, f.value.next = P + k < A, A - P < k && (d.value = A - k)) : (f.value = !1, P > 0 && (d.value = 0));
    }, x = (C) => {
      const A = C.code, {
        up: k,
        down: P,
        left: L,
        right: D
      } = Ft;
      if (![k, P, L, D].includes(A))
        return;
      const E = Array.from(C.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)")), M = E.indexOf(C.target);
      let R;
      A === L || A === k ? M === 0 ? R = E.length - 1 : R = M - 1 : M < E.length - 1 ? R = M + 1 : R = 0, E[R].focus({
        preventScroll: !0
      }), E[R].click(), S();
    }, S = () => {
      g.value && (p.value = !0);
    }, _ = () => p.value = !1;
    return he(a, (C) => {
      C === "hidden" ? g.value = !1 : C === "visible" && setTimeout(() => g.value = !0, 50);
    }), he(s, (C) => {
      C ? setTimeout(() => g.value = !0, 50) : g.value = !1;
    }), Ei(c, w), ht(() => setTimeout(() => O(), 0)), yd(() => w()), e({
      scrollToActiveTab: O,
      removeFocus: _
    }), he(() => n.panes, () => r.update(), {
      flush: "post",
      deep: !0
    }), () => {
      const C = f.value ? [de("span", {
        class: [o.e("nav-prev"), o.is("disabled", !f.value.prev)],
        onClick: y
      }, [de(bt, null, {
        default: () => [de(vL, null, null)]
      })]), de("span", {
        class: [o.e("nav-next"), o.is("disabled", !f.value.next)],
        onClick: b
      }, [de(bt, null, {
        default: () => [de(Sd, null, null)]
      })])] : null, A = n.panes.map((k, P) => {
        var L, D, E, M;
        const R = k.uid, N = k.props.disabled, $ = (D = (L = k.props.name) != null ? L : k.index) != null ? D : `${P}`, F = !N && (k.isClosable || n.editable);
        k.index = `${P}`;
        const W = F ? de(bt, {
          class: "is-icon-close",
          onClick: (X) => t("tabRemove", k, X)
        }, {
          default: () => [de(Pc, null, null)]
        }) : null, j = ((M = (E = k.slots).label) == null ? void 0 : M.call(E)) || k.props.label, Y = !N && k.active ? 0 : -1;
        return de("div", {
          ref: `tab-${R}`,
          class: [o.e("item"), o.is(i.props.tabPosition), o.is("active", k.active), o.is("disabled", N), o.is("closable", F), o.is("focus", p.value)],
          id: `tab-${$}`,
          key: `tab-${R}`,
          "aria-controls": `pane-${$}`,
          role: "tab",
          "aria-selected": k.active,
          tabindex: Y,
          onFocus: () => S(),
          onBlur: () => _(),
          onClick: (X) => {
            _(), t("tabClick", k, $, X);
          },
          onKeydown: (X) => {
            F && (X.code === Ft.delete || X.code === Ft.backspace) && t("tabRemove", k, X);
          }
        }, [j, W]);
      });
      return de("div", {
        ref: c,
        class: [o.e("nav-wrap"), o.is("scrollable", !!f.value), o.is(i.props.tabPosition)]
      }, [C, de("div", {
        class: o.e("nav-scroll"),
        ref: l
      }, [de("div", {
        class: [o.e("nav"), o.is(i.props.tabPosition), o.is("stretch", n.stretch && ["top", "bottom"].includes(i.props.tabPosition))],
        ref: u,
        style: m.value,
        role: "tablist",
        onKeydown: x
      }, [n.type ? null : de(g_e, {
        ref: h,
        tabs: [...n.panes]
      }, null), A])])]);
    };
  }
}), b_e = Ye({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  activeName: {
    type: [String, Number]
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: Ae(Function),
    default: () => !0
  },
  stretch: Boolean
}), b2 = (n) => Ut(n) || _t(n), O_e = {
  [Dt]: (n) => b2(n),
  tabClick: (n, e) => e instanceof Event,
  tabChange: (n) => b2(n),
  edit: (n, e) => ["remove", "add"].includes(e),
  tabRemove: (n) => b2(n),
  tabAdd: () => !0
}, w_e = U({
  name: "ElTabs",
  props: b_e,
  emits: O_e,
  setup(n, {
    emit: e,
    slots: t,
    expose: r
  }) {
    var i, o;
    const a = Pe("tabs"), {
      children: s,
      addChild: l,
      removeChild: u
    } = rye(wt(), "ElTabPane"), c = z(), h = z((o = (i = n.modelValue) != null ? i : n.activeName) != null ? o : "0"), f = async (v, m = !1) => {
      var y, b, O;
      if (!(h.value === v || Li(v)))
        try {
          await ((y = n.beforeLeave) == null ? void 0 : y.call(n, v, h.value)) !== !1 && (h.value = v, m && (e(Dt, v), e("tabChange", v)), (O = (b = c.value) == null ? void 0 : b.removeFocus) == null || O.call(b));
        } catch {
        }
    }, d = (v, m, y) => {
      v.props.disabled || (f(m, !0), e("tabClick", v, y));
    }, p = (v, m) => {
      v.props.disabled || Li(v.props.name) || (m.stopPropagation(), e("edit", v.props.name, "remove"), e("tabRemove", v.props.name));
    }, g = () => {
      e("edit", void 0, "add"), e("tabAdd");
    };
    return Xf({
      from: '"activeName"',
      replacement: '"model-value" or "v-model"',
      scope: "ElTabs",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
      type: "Attribute"
    }, B(() => !!n.activeName)), Xf({
      from: '"addIcon"',
      replacement: '"add-icon"',
      scope: "ElTabs",
      version: "2.6.0",
      ref: "https://element-plus.org/en-US/component/tabs.html#slots",
      type: "Slot"
    }, B(() => !!t.addIcon)), he(() => n.activeName, (v) => f(v)), he(() => n.modelValue, (v) => f(v)), he(h, async () => {
      var v;
      await Ke(), (v = c.value) == null || v.scrollToActiveTab();
    }), Wt(C_, {
      props: n,
      currentName: h,
      registerPane: l,
      unregisterPane: u
    }), r({
      currentName: h
    }), () => {
      const v = t["add-icon"] || t.addIcon, m = v && t.addIcon, y = n.editable || n.addable ? de("span", {
        class: a.e("new-tab"),
        tabindex: "0",
        onClick: g,
        onKeydown: (w) => {
          w.code === Ft.enter && g();
        }
      }, [v ? ke(t, m ? "addIcon" : "add-icon") : de(bt, {
        class: a.is("icon-plus")
      }, {
        default: () => [de(Jj, null, null)]
      })]) : null, b = de("div", {
        class: [a.e("header"), a.is(n.tabPosition)]
      }, [y, de(y_e, {
        ref: c,
        currentName: h.value,
        editable: n.editable,
        type: n.type,
        panes: s.value,
        stretch: n.stretch,
        onTabClick: d,
        onTabRemove: p
      }, null)]), O = de("div", {
        class: a.e("content")
      }, [ke(t, "default")]);
      return de("div", {
        class: [a.b(), a.m(n.tabPosition), {
          [a.m("card")]: n.type === "card",
          [a.m("border-card")]: n.type === "border-card"
        }]
      }, [...n.tabPosition !== "bottom" ? [b, O] : [O, b]]);
    };
  }
}), x_e = Ye({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
}), S_e = ["id", "aria-hidden", "aria-labelledby"], GH = "ElTabPane", __e = U({
  name: GH
}), C_e = /* @__PURE__ */ U({
  ...__e,
  props: x_e,
  setup(n) {
    const e = n, t = wt(), r = Tl(), i = Re(C_);
    i || Su(GH, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const o = Pe("tab-pane"), a = z(), s = B(() => e.closable || i.props.closable), l = T3(() => {
      var d;
      return i.currentName.value === ((d = e.name) != null ? d : a.value);
    }), u = z(l.value), c = B(() => {
      var d;
      return (d = e.name) != null ? d : a.value;
    }), h = T3(() => !e.lazy || u.value || l.value);
    he(l, (d) => {
      d && (u.value = !0);
    });
    const f = dr({
      uid: t.uid,
      slots: r,
      props: e,
      paneName: c,
      active: l,
      index: a,
      isClosable: s
    });
    return ht(() => {
      i.registerPane(f);
    }), ub(() => {
      i.unregisterPane(f.uid);
    }), (d, p) => T(h) ? At((V(), q("div", {
      key: 0,
      id: `pane-${T(c)}`,
      class: Q(T(o).b()),
      role: "tabpanel",
      "aria-hidden": !T(l),
      "aria-labelledby": `tab-${T(c)}`
    }, [
      ke(d.$slots, "default")
    ], 10, S_e)), [
      [On, T(l)]
    ]) : pe("v-if", !0);
  }
});
var jH = /* @__PURE__ */ Ve(C_e, [["__file", "tab-pane.vue"]]);
const v6t = zn(w_e, {
  TabPane: jH
}), m6t = Os(jH), HH = "left-check-change", qH = "right-check-change", Op = Ye({
  data: {
    type: Ae(Array),
    default: () => []
  },
  titles: {
    type: Ae(Array),
    default: () => []
  },
  buttonTexts: {
    type: Ae(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: Ae(Function)
  },
  leftDefaultChecked: {
    type: Ae(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: Ae(Array),
    default: () => []
  },
  renderContent: {
    type: Ae(Function)
  },
  modelValue: {
    type: Ae(Array),
    default: () => []
  },
  format: {
    type: Ae(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: Ae(Object),
    default: () => ih({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), TP = (n, e) => [n, e].every(_n) || _n(n) && _o(e), A_e = {
  [yi]: (n, e, t) => [n, t].every(_n) && ["left", "right"].includes(e),
  [Dt]: (n) => _n(n),
  [HH]: TP,
  [qH]: TP
}, kP = "checked-change", T_e = Ye({
  data: Op.data,
  optionRender: {
    type: Ae(Function)
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: Op.format,
  filterMethod: Op.filterMethod,
  defaultChecked: Op.leftDefaultChecked,
  props: Op.props
}), k_e = {
  [kP]: TP
}, xb = (n) => {
  const e = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return B(() => ({
    ...e,
    ...n.props
  }));
}, P_e = (n, e, t) => {
  const r = xb(n), i = B(() => n.data.filter((c) => fn(n.filterMethod) ? n.filterMethod(e.query, c) : String(c[r.value.label] || c[r.value.key]).toLowerCase().includes(e.query.toLowerCase()))), o = B(() => i.value.filter((c) => !c[r.value.disabled])), a = B(() => {
    const c = e.checked.length, h = n.data.length, { noChecked: f, hasChecked: d } = n.format;
    return f && d ? c > 0 ? d.replace(/\${checked}/g, c.toString()).replace(/\${total}/g, h.toString()) : f.replace(/\${total}/g, h.toString()) : `${c}/${h}`;
  }), s = B(() => {
    const c = e.checked.length;
    return c > 0 && c < o.value.length;
  }), l = () => {
    const c = o.value.map((h) => h[r.value.key]);
    e.allChecked = c.length > 0 && c.every((h) => e.checked.includes(h));
  }, u = (c) => {
    e.checked = c ? o.value.map((h) => h[r.value.key]) : [];
  };
  return he(() => e.checked, (c, h) => {
    if (l(), e.checkChangeByUser) {
      const f = c.concat(h).filter((d) => !c.includes(d) || !h.includes(d));
      t(kP, c, f);
    } else
      t(kP, c), e.checkChangeByUser = !0;
  }), he(o, () => {
    l();
  }), he(() => n.data, () => {
    const c = [], h = i.value.map((f) => f[r.value.key]);
    e.checked.forEach((f) => {
      h.includes(f) && c.push(f);
    }), e.checkChangeByUser = !1, e.checked = c;
  }), he(() => n.defaultChecked, (c, h) => {
    if (h && c.length === h.length && c.every((p) => h.includes(p)))
      return;
    const f = [], d = o.value.map((p) => p[r.value.key]);
    c.forEach((p) => {
      d.includes(p) && f.push(p);
    }), e.checkChangeByUser = !1, e.checked = f;
  }, {
    immediate: !0
  }), {
    filteredData: i,
    checkableData: o,
    checkedSummary: a,
    isIndeterminate: s,
    updateAllChecked: l,
    handleAllCheckedChange: u
  };
}, E_e = (n, e) => ({
  onSourceCheckedChange: (i, o) => {
    n.leftChecked = i, o && e(HH, i, o);
  },
  onTargetCheckedChange: (i, o) => {
    n.rightChecked = i, o && e(qH, i, o);
  }
}), M_e = (n) => {
  const e = xb(n), t = B(() => n.data.reduce((o, a) => (o[a[e.value.key]] = a) && o, {})), r = B(() => n.data.filter((o) => !n.modelValue.includes(o[e.value.key]))), i = B(() => n.targetOrder === "original" ? n.data.filter((o) => n.modelValue.includes(o[e.value.key])) : n.modelValue.reduce((o, a) => {
    const s = t.value[a];
    return s && o.push(s), o;
  }, []));
  return {
    sourceData: r,
    targetData: i
  };
}, D_e = (n, e, t) => {
  const r = xb(n), i = (s, l, u) => {
    t(Dt, s), t(yi, s, l, u);
  };
  return {
    addToLeft: () => {
      const s = n.modelValue.slice();
      e.rightChecked.forEach((l) => {
        const u = s.indexOf(l);
        u > -1 && s.splice(u, 1);
      }), i(s, "left", e.rightChecked);
    },
    addToRight: () => {
      let s = n.modelValue.slice();
      const l = n.data.filter((u) => {
        const c = u[r.value.key];
        return e.leftChecked.includes(c) && !n.modelValue.includes(c);
      }).map((u) => u[r.value.key]);
      s = n.targetOrder === "unshift" ? l.concat(s) : s.concat(l), n.targetOrder === "original" && (s = n.data.filter((u) => s.includes(u[r.value.key])).map((u) => u[r.value.key])), i(s, "right", e.leftChecked);
    }
  };
}, L_e = U({
  name: "ElTransferPanel"
}), I_e = /* @__PURE__ */ U({
  ...L_e,
  props: T_e,
  emits: k_e,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = Tl(), o = ({ option: b }) => b, { t: a } = Ar(), s = Pe("transfer"), l = dr({
      checked: [],
      allChecked: !1,
      query: "",
      checkChangeByUser: !0
    }), u = xb(r), {
      filteredData: c,
      checkedSummary: h,
      isIndeterminate: f,
      handleAllCheckedChange: d
    } = P_e(r, l, t), p = B(() => !Gs(l.query) && Gs(c.value)), g = B(() => !Gs(i.default()[0].children)), { checked: v, allChecked: m, query: y } = bu(l);
    return e({
      query: y
    }), (b, O) => (V(), q("div", {
      class: Q(T(s).b("panel"))
    }, [
      J("p", {
        class: Q(T(s).be("panel", "header"))
      }, [
        de(T(yl), {
          modelValue: T(m),
          "onUpdate:modelValue": O[0] || (O[0] = (w) => So(m) ? m.value = w : null),
          indeterminate: T(f),
          "validate-event": !1,
          onChange: T(d)
        }, {
          default: fe(() => [
            Ri(ze(b.title) + " ", 1),
            J("span", null, ze(T(h)), 1)
          ]),
          _: 1
        }, 8, ["modelValue", "indeterminate", "onChange"])
      ], 2),
      J("div", {
        class: Q([T(s).be("panel", "body"), T(s).is("with-footer", T(g))])
      }, [
        b.filterable ? (V(), ve(T(Td), {
          key: 0,
          modelValue: T(y),
          "onUpdate:modelValue": O[1] || (O[1] = (w) => So(y) ? y.value = w : null),
          class: Q(T(s).be("panel", "filter")),
          size: "default",
          placeholder: b.placeholder,
          "prefix-icon": T(Ppe),
          clearable: "",
          "validate-event": !1
        }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : pe("v-if", !0),
        At(de(T(t1e), {
          modelValue: T(v),
          "onUpdate:modelValue": O[2] || (O[2] = (w) => So(v) ? v.value = w : null),
          "validate-event": !1,
          class: Q([T(s).is("filterable", b.filterable), T(s).be("panel", "list")])
        }, {
          default: fe(() => [
            (V(!0), q(yn, null, qi(T(c), (w) => (V(), ve(T(yl), {
              key: w[T(u).key],
              class: Q(T(s).be("panel", "item")),
              label: w[T(u).key],
              disabled: w[T(u).disabled],
              "validate-event": !1
            }, {
              default: fe(() => {
                var x;
                return [
                  de(o, {
                    option: (x = b.optionRender) == null ? void 0 : x.call(b, w)
                  }, null, 8, ["option"])
                ];
              }),
              _: 2
            }, 1032, ["class", "label", "disabled"]))), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "class"]), [
          [On, !T(p) && !T(Gs)(b.data)]
        ]),
        At(J("p", {
          class: Q(T(s).be("panel", "empty"))
        }, ze(T(p) ? T(a)("el.transfer.noMatch") : T(a)("el.transfer.noData")), 3), [
          [On, T(p) || T(Gs)(b.data)]
        ])
      ], 2),
      T(g) ? (V(), q("p", {
        key: 0,
        class: Q(T(s).be("panel", "footer"))
      }, [
        ke(b.$slots, "default")
      ], 2)) : pe("v-if", !0)
    ], 2));
  }
});
var VB = /* @__PURE__ */ Ve(I_e, [["__file", "transfer-panel.vue"]]);
const R_e = { key: 0 }, N_e = { key: 0 }, $_e = U({
  name: "ElTransfer"
}), B_e = /* @__PURE__ */ U({
  ...$_e,
  props: Op,
  emits: A_e,
  setup(n, { expose: e, emit: t }) {
    const r = n, i = Tl(), { t: o } = Ar(), a = Pe("transfer"), { formItem: s } = Na(), l = dr({
      leftChecked: [],
      rightChecked: []
    }), u = xb(r), { sourceData: c, targetData: h } = M_e(r), { onSourceCheckedChange: f, onTargetCheckedChange: d } = E_e(l, t), { addToLeft: p, addToRight: g } = D_e(r, l, t), v = z(), m = z(), y = (_) => {
      switch (_) {
        case "left":
          v.value.query = "";
          break;
        case "right":
          m.value.query = "";
          break;
      }
    }, b = B(() => r.buttonTexts.length === 2), O = B(() => r.titles[0] || o("el.transfer.titles.0")), w = B(() => r.titles[1] || o("el.transfer.titles.1")), x = B(() => r.filterPlaceholder || o("el.transfer.filterPlaceholder"));
    he(() => r.modelValue, () => {
      var _;
      r.validateEvent && ((_ = s == null ? void 0 : s.validate) == null || _.call(s, "change").catch((C) => Ht(C)));
    });
    const S = B(() => (_) => r.renderContent ? r.renderContent(et, _) : i.default ? i.default({ option: _ }) : et("span", _[u.value.label] || _[u.value.key]));
    return e({
      clearQuery: y,
      leftPanel: v,
      rightPanel: m
    }), (_, C) => (V(), q("div", {
      class: Q(T(a).b())
    }, [
      de(VB, {
        ref_key: "leftPanel",
        ref: v,
        data: T(c),
        "option-render": T(S),
        placeholder: T(x),
        title: T(O),
        filterable: _.filterable,
        format: _.format,
        "filter-method": _.filterMethod,
        "default-checked": _.leftDefaultChecked,
        props: r.props,
        onCheckedChange: T(f)
      }, {
        default: fe(() => [
          ke(_.$slots, "left-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
      J("div", {
        class: Q(T(a).e("buttons"))
      }, [
        de(T(t0), {
          type: "primary",
          class: Q([T(a).e("button"), T(a).is("with-texts", T(b))]),
          disabled: T(Gs)(l.rightChecked),
          onClick: T(p)
        }, {
          default: fe(() => [
            de(T(bt), null, {
              default: fe(() => [
                de(T(vL))
              ]),
              _: 1
            }),
            T(Li)(_.buttonTexts[0]) ? pe("v-if", !0) : (V(), q("span", R_e, ze(_.buttonTexts[0]), 1))
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"]),
        de(T(t0), {
          type: "primary",
          class: Q([T(a).e("button"), T(a).is("with-texts", T(b))]),
          disabled: T(Gs)(l.leftChecked),
          onClick: T(g)
        }, {
          default: fe(() => [
            T(Li)(_.buttonTexts[1]) ? pe("v-if", !0) : (V(), q("span", N_e, ze(_.buttonTexts[1]), 1)),
            de(T(bt), null, {
              default: fe(() => [
                de(T(Sd))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"])
      ], 2),
      de(VB, {
        ref_key: "rightPanel",
        ref: m,
        data: T(h),
        "option-render": T(S),
        placeholder: T(x),
        filterable: _.filterable,
        format: _.format,
        "filter-method": _.filterMethod,
        title: T(w),
        "default-checked": _.rightDefaultChecked,
        props: r.props,
        onCheckedChange: T(d)
      }, {
        default: fe(() => [
          ke(_.$slots, "right-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
    ], 2));
  }
});
var V_e = /* @__PURE__ */ Ve(B_e, [["__file", "transfer.vue"]]);
const y6t = zn(V_e), zp = "$treeNodeId", zB = function(n, e) {
  !e || e[zp] || Object.defineProperty(e, zp, {
    value: n.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, qL = function(n, e) {
  return n ? e[n] : e[zp];
}, PP = (n, e, t) => {
  const r = n.value.currentNode;
  t();
  const i = n.value.currentNode;
  r !== i && e("current-change", i ? i.data : null, i);
}, EP = (n) => {
  let e = !0, t = !0, r = !0;
  for (let i = 0, o = n.length; i < o; i++) {
    const a = n[i];
    (a.checked !== !0 || a.indeterminate) && (e = !1, a.disabled || (r = !1)), (a.checked !== !1 || a.indeterminate) && (t = !1);
  }
  return { all: e, none: t, allWithoutDisable: r, half: !e && !t };
}, vw = function(n) {
  if (n.childNodes.length === 0 || n.loading)
    return;
  const { all: e, none: t, half: r } = EP(n.childNodes);
  e ? (n.checked = !0, n.indeterminate = !1) : r ? (n.checked = !1, n.indeterminate = !0) : t && (n.checked = !1, n.indeterminate = !1);
  const i = n.parent;
  !i || i.level === 0 || n.store.checkStrictly || vw(i);
}, v1 = function(n, e) {
  const t = n.store.props, r = n.data || {}, i = t[e];
  if (typeof i == "function")
    return i(r, n);
  if (typeof i == "string")
    return r[i];
  if (typeof i > "u") {
    const o = r[e];
    return o === void 0 ? "" : o;
  }
};
let z_e = 0, MP = class mw {
  constructor(e) {
    this.id = z_e++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const t in e)
      To(e, t) && (this[t] = e[t]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const e = this.store;
    if (!e)
      throw new Error("[Node]store is required!");
    e.registerNode(this);
    const t = e.props;
    if (t && typeof t.isLeaf < "u") {
      const o = v1(this, "isLeaf");
      typeof o == "boolean" && (this.isLeafByUser = o);
    }
    if (e.lazy !== !0 && this.data ? (this.setData(this.data), e.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(), Array.isArray(this.data) || zB(this, this.data), !this.data)
      return;
    const r = e.defaultExpandedKeys, i = e.key;
    i && r && r.includes(this.key) && this.expand(null, e.autoExpandParent), i && e.currentNodeKey !== void 0 && this.key === e.currentNodeKey && (e.currentNode = this, e.currentNode.isCurrent = !0), e.lazy && e._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(e) {
    Array.isArray(e) || zB(this, e), this.data = e, this.childNodes = [];
    let t;
    this.level === 0 && Array.isArray(this.data) ? t = this.data : t = v1(this, "children") || [];
    for (let r = 0, i = t.length; r < i; r++)
      this.insertChild({ data: t[r] });
  }
  get label() {
    return v1(this, "label");
  }
  get key() {
    const e = this.store.key;
    return this.data ? this.data[e] : null;
  }
  get disabled() {
    return v1(this, "disabled");
  }
  get nextSibling() {
    const e = this.parent;
    if (e) {
      const t = e.childNodes.indexOf(this);
      if (t > -1)
        return e.childNodes[t + 1];
    }
    return null;
  }
  get previousSibling() {
    const e = this.parent;
    if (e) {
      const t = e.childNodes.indexOf(this);
      if (t > -1)
        return t > 0 ? e.childNodes[t - 1] : null;
    }
    return null;
  }
  contains(e, t = !0) {
    return (this.childNodes || []).some((r) => r === e || t && r.contains(e));
  }
  remove() {
    const e = this.parent;
    e && e.removeChild(this);
  }
  insertChild(e, t, r) {
    if (!e)
      throw new Error("InsertChild error: child is required.");
    if (!(e instanceof mw)) {
      if (!r) {
        const i = this.getChildren(!0);
        i.includes(e.data) || (typeof t > "u" || t < 0 ? i.push(e.data) : i.splice(t, 0, e.data));
      }
      Object.assign(e, {
        parent: this,
        store: this.store
      }), e = dr(new mw(e)), e instanceof mw && e.initialize();
    }
    e.level = this.level + 1, typeof t > "u" || t < 0 ? this.childNodes.push(e) : this.childNodes.splice(t, 0, e), this.updateLeafState();
  }
  insertBefore(e, t) {
    let r;
    t && (r = this.childNodes.indexOf(t)), this.insertChild(e, r);
  }
  insertAfter(e, t) {
    let r;
    t && (r = this.childNodes.indexOf(t), r !== -1 && (r += 1)), this.insertChild(e, r);
  }
  removeChild(e) {
    const t = this.getChildren() || [], r = t.indexOf(e.data);
    r > -1 && t.splice(r, 1);
    const i = this.childNodes.indexOf(e);
    i > -1 && (this.store && this.store.deregisterNode(e), e.parent = null, this.childNodes.splice(i, 1)), this.updateLeafState();
  }
  removeChildByData(e) {
    let t = null;
    for (let r = 0; r < this.childNodes.length; r++)
      if (this.childNodes[r].data === e) {
        t = this.childNodes[r];
        break;
      }
    t && this.removeChild(t);
  }
  expand(e, t) {
    const r = () => {
      if (t) {
        let i = this.parent;
        for (; i.level > 0; )
          i.expanded = !0, i = i.parent;
      }
      this.expanded = !0, e && e(), this.childNodes.forEach((i) => {
        i.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((i) => {
      Array.isArray(i) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || vw(this), r());
    }) : r();
  }
  doCreateChildren(e, t = {}) {
    e.forEach((r) => {
      this.insertChild(Object.assign({ data: r }, t), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((e) => {
      e.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const e = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !e || e.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(e, t, r, i) {
    if (this.indeterminate = e === "half", this.checked = e === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: a, allWithoutDisable: s } = EP(this.childNodes);
      !this.isLeaf && !a && s && (this.checked = !1, e = !1);
      const l = () => {
        if (t) {
          const u = this.childNodes;
          for (let f = 0, d = u.length; f < d; f++) {
            const p = u[f];
            i = i || e !== !1;
            const g = p.disabled ? p.checked : i;
            p.setChecked(g, t, !0, i);
          }
          const { half: c, all: h } = EP(u);
          h || (this.checked = h, this.indeterminate = c);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          l(), vw(this);
        }, {
          checked: e !== !1
        });
        return;
      } else
        l();
    }
    const o = this.parent;
    !o || o.level === 0 || r || vw(o);
  }
  getChildren(e = !1) {
    if (this.level === 0)
      return this.data;
    const t = this.data;
    if (!t)
      return null;
    const r = this.store.props;
    let i = "children";
    return r && (i = r.children || "children"), t[i] === void 0 && (t[i] = null), e && !t[i] && (t[i] = []), t[i];
  }
  updateChildren() {
    const e = this.getChildren() || [], t = this.childNodes.map((o) => o.data), r = {}, i = [];
    e.forEach((o, a) => {
      const s = o[zp];
      !!s && t.findIndex((u) => u[zp] === s) >= 0 ? r[s] = { index: a, data: o } : i.push({ index: a, data: o });
    }), this.store.lazy || t.forEach((o) => {
      r[o[zp]] || this.removeChildByData(o);
    }), i.forEach(({ index: o, data: a }) => {
      this.insertChild({ data: a }, o);
    }), this.updateLeafState();
  }
  loadData(e, t = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(t).length)) {
      this.loading = !0;
      const r = (i) => {
        this.childNodes = [], this.doCreateChildren(i, t), this.loaded = !0, this.loading = !1, this.updateLeafState(), e && e.call(this, i);
      };
      this.store.load(this, r);
    } else
      e && e.call(this);
  }
};
class F_e {
  constructor(e) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const t in e)
      To(e, t) && (this[t] = e[t]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new MP({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const e = this.load;
      e(this.root, (t) => {
        this.root.doCreateChildren(t), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(e) {
    const t = this.filterNodeMethod, r = this.lazy, i = function(o) {
      const a = o.root ? o.root.childNodes : o.childNodes;
      if (a.forEach((s) => {
        s.visible = t.call(s, e, s.data, s), i(s);
      }), !o.visible && a.length) {
        let s = !0;
        s = !a.some((l) => l.visible), o.root ? o.root.visible = s === !1 : o.visible = s === !1;
      }
      e && o.visible && !o.isLeaf && (!r || o.loaded) && o.expand();
    };
    i(this);
  }
  setData(e) {
    e !== this.root.data ? (this.root.setData(e), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(e) {
    if (e instanceof MP)
      return e;
    const t = Nr(e) ? qL(this.key, e) : e;
    return this.nodesMap[t] || null;
  }
  insertBefore(e, t) {
    const r = this.getNode(t);
    r.parent.insertBefore({ data: e }, r);
  }
  insertAfter(e, t) {
    const r = this.getNode(t);
    r.parent.insertAfter({ data: e }, r);
  }
  remove(e) {
    const t = this.getNode(e);
    t && t.parent && (t === this.currentNode && (this.currentNode = null), t.parent.removeChild(t));
  }
  append(e, t) {
    const r = t ? this.getNode(t) : this.root;
    r && r.insertChild({ data: e });
  }
  _initDefaultCheckedNodes() {
    const e = this.defaultCheckedKeys || [], t = this.nodesMap;
    e.forEach((r) => {
      const i = t[r];
      i && i.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(e) {
    (this.defaultCheckedKeys || []).includes(e.key) && e.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(e) {
    e !== this.defaultCheckedKeys && (this.defaultCheckedKeys = e, this._initDefaultCheckedNodes());
  }
  registerNode(e) {
    const t = this.key;
    !e || !e.data || (t ? e.key !== void 0 && (this.nodesMap[e.key] = e) : this.nodesMap[e.id] = e);
  }
  deregisterNode(e) {
    !this.key || !e || !e.data || (e.childNodes.forEach((r) => {
      this.deregisterNode(r);
    }), delete this.nodesMap[e.key]);
  }
  getCheckedNodes(e = !1, t = !1) {
    const r = [], i = function(o) {
      (o.root ? o.root.childNodes : o.childNodes).forEach((s) => {
        (s.checked || t && s.indeterminate) && (!e || e && s.isLeaf) && r.push(s.data), i(s);
      });
    };
    return i(this), r;
  }
  getCheckedKeys(e = !1) {
    return this.getCheckedNodes(e).map((t) => (t || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const e = [], t = function(r) {
      (r.root ? r.root.childNodes : r.childNodes).forEach((o) => {
        o.indeterminate && e.push(o.data), t(o);
      });
    };
    return t(this), e;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((e) => (e || {})[this.key]);
  }
  _getAllNodes() {
    const e = [], t = this.nodesMap;
    for (const r in t)
      To(t, r) && e.push(t[r]);
    return e;
  }
  updateChildren(e, t) {
    const r = this.nodesMap[e];
    if (!r)
      return;
    const i = r.childNodes;
    for (let o = i.length - 1; o >= 0; o--) {
      const a = i[o];
      this.remove(a.data);
    }
    for (let o = 0, a = t.length; o < a; o++) {
      const s = t[o];
      this.append(s, r.data);
    }
  }
  _setCheckedKeys(e, t = !1, r) {
    const i = this._getAllNodes().sort((l, u) => l.level - u.level), o = /* @__PURE__ */ Object.create(null), a = Object.keys(r);
    i.forEach((l) => l.setChecked(!1, !1));
    const s = (l) => {
      l.childNodes.forEach((u) => {
        var c;
        o[u.data[e]] = !0, (c = u.childNodes) != null && c.length && s(u);
      });
    };
    for (let l = 0, u = i.length; l < u; l++) {
      const c = i[l], h = c.data[e].toString();
      if (!a.includes(h)) {
        c.checked && !o[h] && c.setChecked(!1, !1);
        continue;
      }
      if (c.childNodes.length && s(c), c.isLeaf || this.checkStrictly) {
        c.setChecked(!0, !1);
        continue;
      }
      if (c.setChecked(!0, !0), t) {
        c.setChecked(!1, !1);
        const d = function(p) {
          p.childNodes.forEach((v) => {
            v.isLeaf || v.setChecked(!1, !1), d(v);
          });
        };
        d(c);
      }
    }
  }
  setCheckedNodes(e, t = !1) {
    const r = this.key, i = {};
    e.forEach((o) => {
      i[(o || {})[r]] = !0;
    }), this._setCheckedKeys(r, t, i);
  }
  setCheckedKeys(e, t = !1) {
    this.defaultCheckedKeys = e;
    const r = this.key, i = {};
    e.forEach((o) => {
      i[o] = !0;
    }), this._setCheckedKeys(r, t, i);
  }
  setDefaultExpandedKeys(e) {
    e = e || [], this.defaultExpandedKeys = e, e.forEach((t) => {
      const r = this.getNode(t);
      r && r.expand(null, this.autoExpandParent);
    });
  }
  setChecked(e, t, r) {
    const i = this.getNode(e);
    i && i.setChecked(!!t, r);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(e) {
    const t = this.currentNode;
    t && (t.isCurrent = !1), this.currentNode = e, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(e, t = !0) {
    const r = e[this.key], i = this.nodesMap[r];
    this.setCurrentNode(i), t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
  }
  setCurrentNodeKey(e, t = !0) {
    if (e == null) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const r = this.getNode(e);
    r && (this.setCurrentNode(r), t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
  }
}
const Q_e = U({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(n) {
    const e = Pe("tree"), t = Re("NodeInstance"), r = Re("RootTree");
    return () => {
      const i = n.node, { data: o, store: a } = i;
      return n.renderContent ? n.renderContent(et, { _self: t, node: i, data: o, store: a }) : ke(r.ctx.slots, "default", { node: i, data: o }, () => [
        et("span", { class: e.be("node", "label") }, [i.label])
      ]);
    };
  }
});
var Z_e = /* @__PURE__ */ Ve(Q_e, [["__file", "tree-node-content.vue"]]);
function YH(n) {
  const e = Re("TreeNodeMap", null), t = {
    treeNodeExpand: (r) => {
      n.node !== r && n.node.collapse();
    },
    children: []
  };
  return e && e.children.push(t), Wt("TreeNodeMap", t), {
    broadcastExpanded: (r) => {
      if (n.accordion)
        for (const i of t.children)
          i.treeNodeExpand(r);
    }
  };
}
const XH = Symbol("dragEvents");
function W_e({ props: n, ctx: e, el$: t, dropIndicator$: r, store: i }) {
  const o = Pe("tree"), a = z({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return Wt(XH, {
    treeNodeDragStart: ({ event: c, treeNode: h }) => {
      if (typeof n.allowDrag == "function" && !n.allowDrag(h.node))
        return c.preventDefault(), !1;
      c.dataTransfer.effectAllowed = "move";
      try {
        c.dataTransfer.setData("text/plain", "");
      } catch {
      }
      a.value.draggingNode = h, e.emit("node-drag-start", h.node, c);
    },
    treeNodeDragOver: ({ event: c, treeNode: h }) => {
      const f = h, d = a.value.dropNode;
      d && d.node.id !== f.node.id && Ul(d.$el, o.is("drop-inner"));
      const p = a.value.draggingNode;
      if (!p || !f)
        return;
      let g = !0, v = !0, m = !0, y = !0;
      typeof n.allowDrop == "function" && (g = n.allowDrop(p.node, f.node, "prev"), y = v = n.allowDrop(p.node, f.node, "inner"), m = n.allowDrop(p.node, f.node, "next")), c.dataTransfer.dropEffect = v || g || m ? "move" : "none", (g || v || m) && (d == null ? void 0 : d.node.id) !== f.node.id && (d && e.emit("node-drag-leave", p.node, d.node, c), e.emit("node-drag-enter", p.node, f.node, c)), g || v || m ? a.value.dropNode = f : a.value.dropNode = null, f.node.nextSibling === p.node && (m = !1), f.node.previousSibling === p.node && (g = !1), f.node.contains(p.node, !1) && (v = !1), (p.node === f.node || p.node.contains(f.node)) && (g = !1, v = !1, m = !1);
      const b = f.$el.querySelector(`.${o.be("node", "content")}`).getBoundingClientRect(), O = t.value.getBoundingClientRect();
      let w;
      const x = g ? v ? 0.25 : m ? 0.45 : 1 : -1, S = m ? v ? 0.75 : g ? 0.55 : 0 : 1;
      let _ = -9999;
      const C = c.clientY - b.top;
      C < b.height * x ? w = "before" : C > b.height * S ? w = "after" : v ? w = "inner" : w = "none";
      const A = f.$el.querySelector(`.${o.be("node", "expand-icon")}`).getBoundingClientRect(), k = r.value;
      w === "before" ? _ = A.top - O.top : w === "after" && (_ = A.bottom - O.top), k.style.top = `${_}px`, k.style.left = `${A.right - O.left}px`, w === "inner" ? fg(f.$el, o.is("drop-inner")) : Ul(f.$el, o.is("drop-inner")), a.value.showDropIndicator = w === "before" || w === "after", a.value.allowDrop = a.value.showDropIndicator || y, a.value.dropType = w, e.emit("node-drag-over", p.node, f.node, c);
    },
    treeNodeDragEnd: (c) => {
      const { draggingNode: h, dropType: f, dropNode: d } = a.value;
      if (c.preventDefault(), c.dataTransfer.dropEffect = "move", h && d) {
        const p = { data: h.node.data };
        f !== "none" && h.node.remove(), f === "before" ? d.node.parent.insertBefore(p, d.node) : f === "after" ? d.node.parent.insertAfter(p, d.node) : f === "inner" && d.node.insertChild(p), f !== "none" && i.value.registerNode(p), Ul(d.$el, o.is("drop-inner")), e.emit("node-drag-end", h.node, d.node, f, c), f !== "none" && e.emit("node-drop", h.node, d.node, f, c);
      }
      h && !d && e.emit("node-drag-end", h.node, null, f, c), a.value.showDropIndicator = !1, a.value.draggingNode = null, a.value.dropNode = null, a.value.allowDrop = !0;
    }
  }), {
    dragState: a
  };
}
const G_e = U({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: SH,
    ElCheckbox: yl,
    NodeContent: Z_e,
    ElIcon: bt,
    Loading: _d
  },
  props: {
    node: {
      type: MP,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(n, e) {
    const t = Pe("tree"), { broadcastExpanded: r } = YH(n), i = Re("RootTree"), o = z(!1), a = z(!1), s = z(null), l = z(null), u = z(null), c = Re(XH), h = wt();
    Wt("NodeInstance", h), i || Ht("Tree", "Can not find node's tree."), n.node.expanded && (o.value = !0, a.value = !0);
    const f = i.props.props.children || "children";
    he(() => {
      const C = n.node.data[f];
      return C && [...C];
    }, () => {
      n.node.updateChildren();
    }), he(() => n.node.indeterminate, (C) => {
      g(n.node.checked, C);
    }), he(() => n.node.checked, (C) => {
      g(C, n.node.indeterminate);
    }), he(() => n.node.expanded, (C) => {
      Ke(() => o.value = C), C && (a.value = !0);
    });
    const d = (C) => qL(i.props.nodeKey, C.data), p = (C) => {
      const A = n.props.class;
      if (!A)
        return {};
      let k;
      if (fn(A)) {
        const { data: P } = C;
        k = A(P, C);
      } else
        k = A;
      return Ut(k) ? { [k]: !0 } : k;
    }, g = (C, A) => {
      (s.value !== C || l.value !== A) && i.ctx.emit("check-change", n.node.data, C, A), s.value = C, l.value = A;
    }, v = (C) => {
      PP(i.store, i.ctx.emit, () => i.store.value.setCurrentNode(n.node)), i.currentNode.value = n.node, i.props.expandOnClickNode && y(), i.props.checkOnClickNode && !n.node.disabled && b(null, {
        target: { checked: !n.node.checked }
      }), i.ctx.emit("node-click", n.node.data, n.node, h, C);
    }, m = (C) => {
      i.instance.vnode.props.onNodeContextmenu && (C.stopPropagation(), C.preventDefault()), i.ctx.emit("node-contextmenu", C, n.node.data, n.node, h);
    }, y = () => {
      n.node.isLeaf || (o.value ? (i.ctx.emit("node-collapse", n.node.data, n.node, h), n.node.collapse()) : (n.node.expand(), e.emit("node-expand", n.node.data, n.node, h)));
    }, b = (C, A) => {
      n.node.setChecked(A.target.checked, !i.props.checkStrictly), Ke(() => {
        const k = i.store.value;
        i.ctx.emit("check", n.node.data, {
          checkedNodes: k.getCheckedNodes(),
          checkedKeys: k.getCheckedKeys(),
          halfCheckedNodes: k.getHalfCheckedNodes(),
          halfCheckedKeys: k.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: t,
      node$: u,
      tree: i,
      expanded: o,
      childNodeRendered: a,
      oldChecked: s,
      oldIndeterminate: l,
      getNodeKey: d,
      getNodeClass: p,
      handleSelectChange: g,
      handleClick: v,
      handleContextMenu: m,
      handleExpandIconClick: y,
      handleCheckChange: b,
      handleChildNodeExpand: (C, A, k) => {
        r(A), i.ctx.emit("node-expand", C, A, k);
      },
      handleDragStart: (C) => {
        i.props.draggable && c.treeNodeDragStart({ event: C, treeNode: n });
      },
      handleDragOver: (C) => {
        C.preventDefault(), i.props.draggable && c.treeNodeDragOver({
          event: C,
          treeNode: { $el: u.value, node: n.node }
        });
      },
      handleDrop: (C) => {
        C.preventDefault();
      },
      handleDragEnd: (C) => {
        i.props.draggable && c.treeNodeDragEnd(C);
      },
      CaretRight: Yde
    };
  }
}), j_e = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], H_e = ["aria-expanded"];
function q_e(n, e, t, r, i, o) {
  const a = Ct("el-icon"), s = Ct("el-checkbox"), l = Ct("loading"), u = Ct("node-content"), c = Ct("el-tree-node"), h = Ct("el-collapse-transition");
  return At((V(), q("div", {
    ref: "node$",
    class: Q([
      n.ns.b("node"),
      n.ns.is("expanded", n.expanded),
      n.ns.is("current", n.node.isCurrent),
      n.ns.is("hidden", !n.node.visible),
      n.ns.is("focusable", !n.node.disabled),
      n.ns.is("checked", !n.node.disabled && n.node.checked),
      n.getNodeClass(n.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": n.expanded,
    "aria-disabled": n.node.disabled,
    "aria-checked": n.node.checked,
    draggable: n.tree.props.draggable,
    "data-key": n.getNodeKey(n.node),
    onClick: e[1] || (e[1] = kt((...f) => n.handleClick && n.handleClick(...f), ["stop"])),
    onContextmenu: e[2] || (e[2] = (...f) => n.handleContextMenu && n.handleContextMenu(...f)),
    onDragstart: e[3] || (e[3] = kt((...f) => n.handleDragStart && n.handleDragStart(...f), ["stop"])),
    onDragover: e[4] || (e[4] = kt((...f) => n.handleDragOver && n.handleDragOver(...f), ["stop"])),
    onDragend: e[5] || (e[5] = kt((...f) => n.handleDragEnd && n.handleDragEnd(...f), ["stop"])),
    onDrop: e[6] || (e[6] = kt((...f) => n.handleDrop && n.handleDrop(...f), ["stop"]))
  }, [
    J("div", {
      class: Q(n.ns.be("node", "content")),
      style: vt({ paddingLeft: (n.node.level - 1) * n.tree.props.indent + "px" })
    }, [
      n.tree.props.icon || n.CaretRight ? (V(), ve(a, {
        key: 0,
        class: Q([
          n.ns.be("node", "expand-icon"),
          n.ns.is("leaf", n.node.isLeaf),
          {
            expanded: !n.node.isLeaf && n.expanded
          }
        ]),
        onClick: kt(n.handleExpandIconClick, ["stop"])
      }, {
        default: fe(() => [
          (V(), ve(cn(n.tree.props.icon || n.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : pe("v-if", !0),
      n.showCheckbox ? (V(), ve(s, {
        key: 1,
        "model-value": n.node.checked,
        indeterminate: n.node.indeterminate,
        disabled: !!n.node.disabled,
        onClick: e[0] || (e[0] = kt(() => {
        }, ["stop"])),
        onChange: n.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : pe("v-if", !0),
      n.node.loading ? (V(), ve(a, {
        key: 2,
        class: Q([n.ns.be("node", "loading-icon"), n.ns.is("loading")])
      }, {
        default: fe(() => [
          de(l)
        ]),
        _: 1
      }, 8, ["class"])) : pe("v-if", !0),
      de(u, {
        node: n.node,
        "render-content": n.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    de(h, null, {
      default: fe(() => [
        !n.renderAfterExpand || n.childNodeRendered ? At((V(), q("div", {
          key: 0,
          class: Q(n.ns.be("node", "children")),
          role: "group",
          "aria-expanded": n.expanded
        }, [
          (V(!0), q(yn, null, qi(n.node.childNodes, (f) => (V(), ve(c, {
            key: n.getNodeKey(f),
            "render-content": n.renderContent,
            "render-after-expand": n.renderAfterExpand,
            "show-checkbox": n.showCheckbox,
            node: f,
            accordion: n.accordion,
            props: n.props,
            onNodeExpand: n.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, H_e)), [
          [On, n.expanded]
        ]) : pe("v-if", !0)
      ]),
      _: 1
    })
  ], 42, j_e)), [
    [On, n.node.visible]
  ]);
}
var Y_e = /* @__PURE__ */ Ve(G_e, [["render", q_e], ["__file", "tree-node.vue"]]);
function X_e({ el$: n }, e) {
  const t = Pe("tree"), r = di([]), i = di([]);
  ht(() => {
    a();
  }), yd(() => {
    r.value = Array.from(n.value.querySelectorAll("[role=treeitem]")), i.value = Array.from(n.value.querySelectorAll("input[type=checkbox]"));
  }), he(i, (s) => {
    s.forEach((l) => {
      l.setAttribute("tabindex", "-1");
    });
  }), Yi(n, "keydown", (s) => {
    const l = s.target;
    if (!l.className.includes(t.b("node")))
      return;
    const u = s.code;
    r.value = Array.from(n.value.querySelectorAll(`.${t.is("focusable")}[role=treeitem]`));
    const c = r.value.indexOf(l);
    let h;
    if ([Ft.up, Ft.down].includes(u)) {
      if (s.preventDefault(), u === Ft.up) {
        h = c === -1 ? 0 : c !== 0 ? c - 1 : r.value.length - 1;
        const d = h;
        for (; !e.value.getNode(r.value[h].dataset.key).canFocus; ) {
          if (h--, h === d) {
            h = -1;
            break;
          }
          h < 0 && (h = r.value.length - 1);
        }
      } else {
        h = c === -1 ? 0 : c < r.value.length - 1 ? c + 1 : 0;
        const d = h;
        for (; !e.value.getNode(r.value[h].dataset.key).canFocus; ) {
          if (h++, h === d) {
            h = -1;
            break;
          }
          h >= r.value.length && (h = 0);
        }
      }
      h !== -1 && r.value[h].focus();
    }
    [Ft.left, Ft.right].includes(u) && (s.preventDefault(), l.click());
    const f = l.querySelector('[type="checkbox"]');
    [Ft.enter, Ft.space].includes(u) && f && (s.preventDefault(), f.click());
  });
  const a = () => {
    var s;
    r.value = Array.from(n.value.querySelectorAll(`.${t.is("focusable")}[role=treeitem]`)), i.value = Array.from(n.value.querySelectorAll("input[type=checkbox]"));
    const l = n.value.querySelectorAll(`.${t.is("checked")}[role=treeitem]`);
    if (l.length) {
      l[0].setAttribute("tabindex", "0");
      return;
    }
    (s = r.value[0]) == null || s.setAttribute("tabindex", "0");
  };
}
const U_e = U({
  name: "ElTree",
  components: { ElTreeNode: Y_e },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: $r
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(n, e) {
    const { t } = Ar(), r = Pe("tree"), i = z(new F_e({
      key: n.nodeKey,
      data: n.data,
      lazy: n.lazy,
      props: n.props,
      load: n.load,
      currentNodeKey: n.currentNodeKey,
      checkStrictly: n.checkStrictly,
      checkDescendants: n.checkDescendants,
      defaultCheckedKeys: n.defaultCheckedKeys,
      defaultExpandedKeys: n.defaultExpandedKeys,
      autoExpandParent: n.autoExpandParent,
      defaultExpandAll: n.defaultExpandAll,
      filterNodeMethod: n.filterNodeMethod
    }));
    i.value.initialize();
    const o = z(i.value.root), a = z(null), s = z(null), l = z(null), { broadcastExpanded: u } = YH(n), { dragState: c } = W_e({
      props: n,
      ctx: e,
      el$: s,
      dropIndicator$: l,
      store: i
    });
    X_e({ el$: s }, i);
    const h = B(() => {
      const { childNodes: R } = o.value;
      return !R || R.length === 0 || R.every(({ visible: N }) => !N);
    });
    he(() => n.currentNodeKey, (R) => {
      i.value.setCurrentNodeKey(R);
    }), he(() => n.defaultCheckedKeys, (R) => {
      i.value.setDefaultCheckedKey(R);
    }), he(() => n.defaultExpandedKeys, (R) => {
      i.value.setDefaultExpandedKeys(R);
    }), he(() => n.data, (R) => {
      i.value.setData(R);
    }, { deep: !0 }), he(() => n.checkStrictly, (R) => {
      i.value.checkStrictly = R;
    });
    const f = (R) => {
      if (!n.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      i.value.filter(R);
    }, d = (R) => qL(n.nodeKey, R.data), p = (R) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const N = i.value.getNode(R);
      if (!N)
        return [];
      const $ = [N.data];
      let F = N.parent;
      for (; F && F !== o.value; )
        $.push(F.data), F = F.parent;
      return $.reverse();
    }, g = (R, N) => i.value.getCheckedNodes(R, N), v = (R) => i.value.getCheckedKeys(R), m = () => {
      const R = i.value.getCurrentNode();
      return R ? R.data : null;
    }, y = () => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const R = m();
      return R ? R[n.nodeKey] : null;
    }, b = (R, N) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      i.value.setCheckedNodes(R, N);
    }, O = (R, N) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      i.value.setCheckedKeys(R, N);
    }, w = (R, N, $) => {
      i.value.setChecked(R, N, $);
    }, x = () => i.value.getHalfCheckedNodes(), S = () => i.value.getHalfCheckedKeys(), _ = (R, N = !0) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      PP(i, e.emit, () => i.value.setUserCurrentNode(R, N));
    }, C = (R, N = !0) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      PP(i, e.emit, () => i.value.setCurrentNodeKey(R, N));
    }, A = (R) => i.value.getNode(R), k = (R) => {
      i.value.remove(R);
    }, P = (R, N) => {
      i.value.append(R, N);
    }, L = (R, N) => {
      i.value.insertBefore(R, N);
    }, D = (R, N) => {
      i.value.insertAfter(R, N);
    }, E = (R, N, $) => {
      u(N), e.emit("node-expand", R, N, $);
    }, M = (R, N) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      i.value.updateChildren(R, N);
    };
    return Wt("RootTree", {
      ctx: e,
      props: n,
      store: i,
      root: o,
      currentNode: a,
      instance: wt()
    }), Wt(Ec, void 0), {
      ns: r,
      store: i,
      root: o,
      currentNode: a,
      dragState: c,
      el$: s,
      dropIndicator$: l,
      isEmpty: h,
      filter: f,
      getNodeKey: d,
      getNodePath: p,
      getCheckedNodes: g,
      getCheckedKeys: v,
      getCurrentNode: m,
      getCurrentKey: y,
      setCheckedNodes: b,
      setCheckedKeys: O,
      setChecked: w,
      getHalfCheckedNodes: x,
      getHalfCheckedKeys: S,
      setCurrentNode: _,
      setCurrentKey: C,
      t,
      getNode: A,
      remove: k,
      append: P,
      insertBefore: L,
      insertAfter: D,
      handleNodeExpand: E,
      updateKeyChildren: M
    };
  }
});
function K_e(n, e, t, r, i, o) {
  const a = Ct("el-tree-node");
  return V(), q("div", {
    ref: "el$",
    class: Q([
      n.ns.b(),
      n.ns.is("dragging", !!n.dragState.draggingNode),
      n.ns.is("drop-not-allow", !n.dragState.allowDrop),
      n.ns.is("drop-inner", n.dragState.dropType === "inner"),
      { [n.ns.m("highlight-current")]: n.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (V(!0), q(yn, null, qi(n.root.childNodes, (s) => (V(), ve(a, {
      key: n.getNodeKey(s),
      node: s,
      props: n.props,
      accordion: n.accordion,
      "render-after-expand": n.renderAfterExpand,
      "show-checkbox": n.showCheckbox,
      "render-content": n.renderContent,
      onNodeExpand: n.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    n.isEmpty ? (V(), q("div", {
      key: 0,
      class: Q(n.ns.e("empty-block"))
    }, [
      ke(n.$slots, "empty", {}, () => {
        var s;
        return [
          J("span", {
            class: Q(n.ns.e("empty-text"))
          }, ze((s = n.emptyText) != null ? s : n.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : pe("v-if", !0),
    At(J("div", {
      ref: "dropIndicator$",
      class: Q(n.ns.e("drop-indicator"))
    }, null, 2), [
      [On, n.dragState.showDropIndicator]
    ])
  ], 2);
}
var yw = /* @__PURE__ */ Ve(U_e, [["render", K_e], ["__file", "tree.vue"]]);
yw.install = (n) => {
  n.component(yw.name, yw);
};
const J_e = yw, b6t = J_e, UH = ["success", "info", "warning", "error"], uo = ih({
  customClass: "",
  center: !1,
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: qt ? document.body : void 0
}), eCe = Ye({
  customClass: {
    type: String,
    default: uo.customClass
  },
  center: {
    type: Boolean,
    default: uo.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: uo.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: uo.duration
  },
  icon: {
    type: $r,
    default: uo.icon
  },
  id: {
    type: String,
    default: uo.id
  },
  message: {
    type: Ae([
      String,
      Object,
      Function
    ]),
    default: uo.message
  },
  onClose: {
    type: Ae(Function),
    required: !1
  },
  showClose: {
    type: Boolean,
    default: uo.showClose
  },
  type: {
    type: String,
    values: UH,
    default: uo.type
  },
  offset: {
    type: Number,
    default: uo.offset
  },
  zIndex: {
    type: Number,
    default: uo.zIndex
  },
  grouping: {
    type: Boolean,
    default: uo.grouping
  },
  repeatNum: {
    type: Number,
    default: uo.repeatNum
  }
}), tCe = {
  destroy: () => !0
}, ts = uae([]), nCe = (n) => {
  const e = ts.findIndex((i) => i.id === n), t = ts[e];
  let r;
  return e > 0 && (r = ts[e - 1]), { current: t, prev: r };
}, rCe = (n) => {
  const { prev: e } = nCe(n);
  return e ? e.vm.exposed.bottom.value : 0;
}, iCe = (n, e) => ts.findIndex((r) => r.id === n) > 0 ? 20 : e, oCe = ["id"], aCe = ["innerHTML"], sCe = U({
  name: "ElMessage"
}), lCe = /* @__PURE__ */ U({
  ...sCe,
  props: eCe,
  emits: tCe,
  setup(n, { expose: e }) {
    const t = n, { Close: r } = d7, { ns: i, zIndex: o } = IL("message"), { currentZIndex: a, nextZIndex: s } = o, l = z(), u = z(!1), c = z(0);
    let h;
    const f = B(() => t.type ? t.type === "error" ? "danger" : t.type : "info"), d = B(() => {
      const S = t.type;
      return { [i.bm("icon", S)]: S && dg[S] };
    }), p = B(() => t.icon || dg[t.type] || ""), g = B(() => rCe(t.id)), v = B(() => iCe(t.id, t.offset) + g.value), m = B(() => c.value + v.value), y = B(() => ({
      top: `${v.value}px`,
      zIndex: a.value
    }));
    function b() {
      t.duration !== 0 && ({ stop: h } = hx(() => {
        w();
      }, t.duration));
    }
    function O() {
      h == null || h();
    }
    function w() {
      u.value = !1;
    }
    function x({ code: S }) {
      S === Ft.esc && w();
    }
    return ht(() => {
      b(), s(), u.value = !0;
    }), he(() => t.repeatNum, () => {
      O(), b();
    }), Yi(document, "keydown", x), Ei(l, () => {
      c.value = l.value.getBoundingClientRect().height;
    }), e({
      visible: u,
      bottom: m,
      close: w
    }), (S, _) => (V(), ve(kl, {
      name: T(i).b("fade"),
      onBeforeLeave: S.onClose,
      onAfterLeave: _[0] || (_[0] = (C) => S.$emit("destroy")),
      persisted: ""
    }, {
      default: fe(() => [
        At(J("div", {
          id: S.id,
          ref_key: "messageRef",
          ref: l,
          class: Q([
            T(i).b(),
            { [T(i).m(S.type)]: S.type },
            T(i).is("center", S.center),
            T(i).is("closable", S.showClose),
            S.customClass
          ]),
          style: vt(T(y)),
          role: "alert",
          onMouseenter: O,
          onMouseleave: b
        }, [
          S.repeatNum > 1 ? (V(), ve(T(ebe), {
            key: 0,
            value: S.repeatNum,
            type: T(f),
            class: Q(T(i).e("badge"))
          }, null, 8, ["value", "type", "class"])) : pe("v-if", !0),
          T(p) ? (V(), ve(T(bt), {
            key: 1,
            class: Q([T(i).e("icon"), T(d)])
          }, {
            default: fe(() => [
              (V(), ve(cn(T(p))))
            ]),
            _: 1
          }, 8, ["class"])) : pe("v-if", !0),
          ke(S.$slots, "default", {}, () => [
            S.dangerouslyUseHTMLString ? (V(), q(yn, { key: 1 }, [
              pe(" Caution here, message could've been compromised, never use user's input as message "),
              J("p", {
                class: Q(T(i).e("content")),
                innerHTML: S.message
              }, null, 10, aCe)
            ], 2112)) : (V(), q("p", {
              key: 0,
              class: Q(T(i).e("content"))
            }, ze(S.message), 3))
          ]),
          S.showClose ? (V(), ve(T(bt), {
            key: 2,
            class: Q(T(i).e("closeBtn")),
            onClick: kt(w, ["stop"])
          }, {
            default: fe(() => [
              de(T(r))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : pe("v-if", !0)
        ], 46, oCe), [
          [On, u.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var uCe = /* @__PURE__ */ Ve(lCe, [["__file", "message.vue"]]);
let cCe = 1;
const KH = (n) => {
  const e = !n || Ut(n) || gl(n) || fn(n) ? { message: n } : n, t = {
    ...uo,
    ...e
  };
  if (!t.appendTo)
    t.appendTo = document.body;
  else if (Ut(t.appendTo)) {
    let r = document.querySelector(t.appendTo);
    hs(r) || (Ht("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), r = document.body), t.appendTo = r;
  }
  return t;
}, hCe = (n) => {
  const e = ts.indexOf(n);
  if (e === -1)
    return;
  ts.splice(e, 1);
  const { handler: t } = n;
  t.close();
}, fCe = ({ appendTo: n, ...e }, t) => {
  const r = `message_${cCe++}`, i = e.onClose, o = document.createElement("div"), a = {
    ...e,
    id: r,
    onClose: () => {
      i == null || i(), hCe(c);
    },
    onDestroy: () => {
      Tc(null, o);
    }
  }, s = de(uCe, a, fn(a.message) || gl(a.message) ? {
    default: fn(a.message) ? a.message : () => a.message
  } : null);
  s.appContext = t || Og._context, Tc(s, o), n.appendChild(o.firstElementChild);
  const l = s.component, c = {
    id: r,
    vnode: s,
    vm: l,
    handler: {
      close: () => {
        l.exposed.visible.value = !1;
      }
    },
    props: s.component.props
  };
  return c;
}, Og = (n = {}, e) => {
  if (!qt)
    return { close: () => {
    } };
  if (_t(lP.max) && ts.length >= lP.max)
    return { close: () => {
    } };
  const t = KH(n);
  if (t.grouping && ts.length) {
    const i = ts.find(({ vnode: o }) => {
      var a;
      return ((a = o.props) == null ? void 0 : a.message) === t.message;
    });
    if (i)
      return i.props.repeatNum += 1, i.props.type = t.type, i.handler;
  }
  const r = fCe(t, e);
  return ts.push(r), r.handler;
};
UH.forEach((n) => {
  Og[n] = (e = {}, t) => {
    const r = KH(e);
    return Og({ ...r, type: n }, t);
  };
});
function dCe(n) {
  for (const e of ts)
    (!n || n === e.props.type) && e.handler.close();
}
Og.closeAll = dCe;
Og._context = null;
const O6t = g7(Og, "$message"), pCe = U({
  name: "ElMessageBox",
  directives: {
    TrapFocus: Pbe
  },
  components: {
    ElButton: t0,
    ElFocusTrap: x_,
    ElInput: Td,
    ElOverlay: QL,
    ElIcon: bt,
    ...d7
  },
  inheritAttrs: !1,
  props: {
    buttonSize: {
      type: String,
      validator: v7
    },
    modal: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    closeOnHashChange: {
      type: Boolean,
      default: !0
    },
    center: Boolean,
    draggable: Boolean,
    overflow: Boolean,
    roundButton: {
      default: !1,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(n, { emit: e }) {
    const {
      locale: t,
      zIndex: r,
      ns: i,
      size: o
    } = IL("message-box", B(() => n.buttonSize)), { t: a } = t, { nextZIndex: s } = r, l = z(!1), u = dr({
      autofocus: !0,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: !1,
      distinguishCancelAndClose: !1,
      icon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: !0,
      modalClass: "",
      showCancelButton: !1,
      showConfirmButton: !0,
      type: "",
      title: void 0,
      showInput: !1,
      action: "",
      confirmButtonLoading: !1,
      cancelButtonLoading: !1,
      confirmButtonDisabled: !1,
      editorErrorMessage: "",
      validateError: !1,
      zIndex: s()
    }), c = B(() => {
      const M = u.type;
      return { [i.bm("icon", M)]: M && dg[M] };
    }), h = fs(), f = fs(), d = B(() => u.icon || dg[u.type] || ""), p = B(() => !!u.message), g = z(), v = z(), m = z(), y = z(), b = z(), O = B(() => u.confirmButtonClass);
    he(() => u.inputValue, async (M) => {
      await Ke(), n.boxType === "prompt" && M !== null && P();
    }, { immediate: !0 }), he(() => l.value, (M) => {
      var R, N;
      M && (n.boxType !== "prompt" && (u.autofocus ? m.value = (N = (R = b.value) == null ? void 0 : R.$el) != null ? N : g.value : m.value = g.value), u.zIndex = s()), n.boxType === "prompt" && (M ? Ke().then(() => {
        var $;
        y.value && y.value.$el && (u.autofocus ? m.value = ($ = L()) != null ? $ : g.value : m.value = g.value);
      }) : (u.editorErrorMessage = "", u.validateError = !1));
    });
    const w = B(() => n.draggable), x = B(() => n.overflow);
    m7(g, v, w, x), ht(async () => {
      await Ke(), n.closeOnHashChange && window.addEventListener("hashchange", S);
    }), xi(() => {
      n.closeOnHashChange && window.removeEventListener("hashchange", S);
    });
    function S() {
      l.value && (l.value = !1, Ke(() => {
        u.action && e("action", u.action);
      }));
    }
    const _ = () => {
      n.closeOnClickModal && k(u.distinguishCancelAndClose ? "close" : "cancel");
    }, C = EL(_), A = (M) => {
      if (u.inputType !== "textarea")
        return M.preventDefault(), k("confirm");
    }, k = (M) => {
      var R;
      n.boxType === "prompt" && M === "confirm" && !P() || (u.action = M, u.beforeClose ? (R = u.beforeClose) == null || R.call(u, M, u, S) : S());
    }, P = () => {
      if (n.boxType === "prompt") {
        const M = u.inputPattern;
        if (M && !M.test(u.inputValue || ""))
          return u.editorErrorMessage = u.inputErrorMessage || a("el.messagebox.error"), u.validateError = !0, !1;
        const R = u.inputValidator;
        if (typeof R == "function") {
          const N = R(u.inputValue);
          if (N === !1)
            return u.editorErrorMessage = u.inputErrorMessage || a("el.messagebox.error"), u.validateError = !0, !1;
          if (typeof N == "string")
            return u.editorErrorMessage = N, u.validateError = !0, !1;
        }
      }
      return u.editorErrorMessage = "", u.validateError = !1, !0;
    }, L = () => {
      const M = y.value.$refs;
      return M.input || M.textarea;
    }, D = () => {
      k("close");
    }, E = () => {
      n.closeOnPressEscape && D();
    };
    return n.lockScroll && _7(l), {
      ...bu(u),
      ns: i,
      overlayEvent: C,
      visible: l,
      hasMessage: p,
      typeClass: c,
      contentId: h,
      inputId: f,
      btnSize: o,
      iconComponent: d,
      confirmButtonClasses: O,
      rootRef: g,
      focusStartRef: m,
      headerRef: v,
      inputRef: y,
      confirmRef: b,
      doClose: S,
      handleClose: D,
      onCloseRequested: E,
      handleWrapperClick: _,
      handleInputEnter: A,
      handleAction: k,
      t: a
    };
  }
}), gCe = ["aria-label", "aria-describedby"], vCe = ["aria-label"], mCe = ["id"];
function yCe(n, e, t, r, i, o) {
  const a = Ct("el-icon"), s = Ct("close"), l = Ct("el-input"), u = Ct("el-button"), c = Ct("el-focus-trap"), h = Ct("el-overlay");
  return V(), ve(kl, {
    name: "fade-in-linear",
    onAfterLeave: e[11] || (e[11] = (f) => n.$emit("vanish")),
    persisted: ""
  }, {
    default: fe(() => [
      At(de(h, {
        "z-index": n.zIndex,
        "overlay-class": [n.ns.is("message-box"), n.modalClass],
        mask: n.modal
      }, {
        default: fe(() => [
          J("div", {
            role: "dialog",
            "aria-label": n.title,
            "aria-modal": "true",
            "aria-describedby": n.showInput ? void 0 : n.contentId,
            class: Q(`${n.ns.namespace.value}-overlay-message-box`),
            onClick: e[8] || (e[8] = (...f) => n.overlayEvent.onClick && n.overlayEvent.onClick(...f)),
            onMousedown: e[9] || (e[9] = (...f) => n.overlayEvent.onMousedown && n.overlayEvent.onMousedown(...f)),
            onMouseup: e[10] || (e[10] = (...f) => n.overlayEvent.onMouseup && n.overlayEvent.onMouseup(...f))
          }, [
            de(c, {
              loop: "",
              trapped: n.visible,
              "focus-trap-el": n.rootRef,
              "focus-start-el": n.focusStartRef,
              onReleaseRequested: n.onCloseRequested
            }, {
              default: fe(() => [
                J("div", {
                  ref: "rootRef",
                  class: Q([
                    n.ns.b(),
                    n.customClass,
                    n.ns.is("draggable", n.draggable),
                    { [n.ns.m("center")]: n.center }
                  ]),
                  style: vt(n.customStyle),
                  tabindex: "-1",
                  onClick: e[7] || (e[7] = kt(() => {
                  }, ["stop"]))
                }, [
                  n.title !== null && n.title !== void 0 ? (V(), q("div", {
                    key: 0,
                    ref: "headerRef",
                    class: Q([n.ns.e("header"), { "show-close": n.showClose }])
                  }, [
                    J("div", {
                      class: Q(n.ns.e("title"))
                    }, [
                      n.iconComponent && n.center ? (V(), ve(a, {
                        key: 0,
                        class: Q([n.ns.e("status"), n.typeClass])
                      }, {
                        default: fe(() => [
                          (V(), ve(cn(n.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : pe("v-if", !0),
                      J("span", null, ze(n.title), 1)
                    ], 2),
                    n.showClose ? (V(), q("button", {
                      key: 0,
                      type: "button",
                      class: Q(n.ns.e("headerbtn")),
                      "aria-label": n.t("el.messagebox.close"),
                      onClick: e[0] || (e[0] = (f) => n.handleAction(n.distinguishCancelAndClose ? "close" : "cancel")),
                      onKeydown: e[1] || (e[1] = Rr(kt((f) => n.handleAction(n.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                    }, [
                      de(a, {
                        class: Q(n.ns.e("close"))
                      }, {
                        default: fe(() => [
                          de(s)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 42, vCe)) : pe("v-if", !0)
                  ], 2)) : pe("v-if", !0),
                  J("div", {
                    id: n.contentId,
                    class: Q(n.ns.e("content"))
                  }, [
                    J("div", {
                      class: Q(n.ns.e("container"))
                    }, [
                      n.iconComponent && !n.center && n.hasMessage ? (V(), ve(a, {
                        key: 0,
                        class: Q([n.ns.e("status"), n.typeClass])
                      }, {
                        default: fe(() => [
                          (V(), ve(cn(n.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : pe("v-if", !0),
                      n.hasMessage ? (V(), q("div", {
                        key: 1,
                        class: Q(n.ns.e("message"))
                      }, [
                        ke(n.$slots, "default", {}, () => [
                          n.dangerouslyUseHTMLString ? (V(), ve(cn(n.showInput ? "label" : "p"), {
                            key: 1,
                            for: n.showInput ? n.inputId : void 0,
                            innerHTML: n.message
                          }, null, 8, ["for", "innerHTML"])) : (V(), ve(cn(n.showInput ? "label" : "p"), {
                            key: 0,
                            for: n.showInput ? n.inputId : void 0
                          }, {
                            default: fe(() => [
                              Ri(ze(n.dangerouslyUseHTMLString ? "" : n.message), 1)
                            ]),
                            _: 1
                          }, 8, ["for"]))
                        ])
                      ], 2)) : pe("v-if", !0)
                    ], 2),
                    At(J("div", {
                      class: Q(n.ns.e("input"))
                    }, [
                      de(l, {
                        id: n.inputId,
                        ref: "inputRef",
                        modelValue: n.inputValue,
                        "onUpdate:modelValue": e[2] || (e[2] = (f) => n.inputValue = f),
                        type: n.inputType,
                        placeholder: n.inputPlaceholder,
                        "aria-invalid": n.validateError,
                        class: Q({ invalid: n.validateError }),
                        onKeydown: Rr(n.handleInputEnter, ["enter"])
                      }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                      J("div", {
                        class: Q(n.ns.e("errormsg")),
                        style: vt({
                          visibility: n.editorErrorMessage ? "visible" : "hidden"
                        })
                      }, ze(n.editorErrorMessage), 7)
                    ], 2), [
                      [On, n.showInput]
                    ])
                  ], 10, mCe),
                  J("div", {
                    class: Q(n.ns.e("btns"))
                  }, [
                    n.showCancelButton ? (V(), ve(u, {
                      key: 0,
                      loading: n.cancelButtonLoading,
                      class: Q([n.cancelButtonClass]),
                      round: n.roundButton,
                      size: n.btnSize,
                      onClick: e[3] || (e[3] = (f) => n.handleAction("cancel")),
                      onKeydown: e[4] || (e[4] = Rr(kt((f) => n.handleAction("cancel"), ["prevent"]), ["enter"]))
                    }, {
                      default: fe(() => [
                        Ri(ze(n.cancelButtonText || n.t("el.messagebox.cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "size"])) : pe("v-if", !0),
                    At(de(u, {
                      ref: "confirmRef",
                      type: "primary",
                      loading: n.confirmButtonLoading,
                      class: Q([n.confirmButtonClasses]),
                      round: n.roundButton,
                      disabled: n.confirmButtonDisabled,
                      size: n.btnSize,
                      onClick: e[5] || (e[5] = (f) => n.handleAction("confirm")),
                      onKeydown: e[6] || (e[6] = Rr(kt((f) => n.handleAction("confirm"), ["prevent"]), ["enter"]))
                    }, {
                      default: fe(() => [
                        Ri(ze(n.confirmButtonText || n.t("el.messagebox.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "disabled", "size"]), [
                      [On, n.showConfirmButton]
                    ])
                  ], 2)
                ], 6)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, gCe)
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [On, n.visible]
      ])
    ]),
    _: 3
  });
}
var bCe = /* @__PURE__ */ Ve(pCe, [["render", yCe], ["__file", "index.vue"]]);
const r0 = /* @__PURE__ */ new Map(), OCe = (n) => {
  let e = document.body;
  return n.appendTo && (Ut(n.appendTo) && (e = document.querySelector(n.appendTo)), hs(n.appendTo) && (e = n.appendTo), hs(e) || (Ht("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body."), e = document.body)), e;
}, wCe = (n, e, t = null) => {
  const r = de(bCe, n, fn(n.message) || gl(n.message) ? {
    default: fn(n.message) ? n.message : () => n.message
  } : null);
  return r.appContext = t, Tc(r, e), OCe(n).appendChild(e.firstElementChild), r.component;
}, xCe = () => document.createElement("div"), SCe = (n, e) => {
  const t = xCe();
  n.onVanish = () => {
    Tc(null, t), r0.delete(i);
  }, n.onAction = (o) => {
    const a = r0.get(i);
    let s;
    n.showInput ? s = { value: i.inputValue, action: o } : s = o, n.callback ? n.callback(s, r.proxy) : o === "cancel" || o === "close" ? n.distinguishCancelAndClose && o !== "cancel" ? a.reject("close") : a.reject("cancel") : a.resolve(s);
  };
  const r = wCe(n, t, e), i = r.proxy;
  for (const o in n)
    To(n, o) && !To(i.$props, o) && (i[o] = n[o]);
  return i.visible = !0, i;
};
function pv(n, e = null) {
  if (!qt)
    return Promise.reject();
  let t;
  return Ut(n) || gl(n) ? n = {
    message: n
  } : t = n.callback, new Promise((r, i) => {
    const o = SCe(n, e ?? pv._context);
    r0.set(o, {
      options: n,
      callback: t,
      resolve: r,
      reject: i
    });
  });
}
const _Ce = ["alert", "confirm", "prompt"], CCe = {
  alert: { closeOnPressEscape: !1, closeOnClickModal: !1 },
  confirm: { showCancelButton: !0 },
  prompt: { showCancelButton: !0, showInput: !0 }
};
_Ce.forEach((n) => {
  pv[n] = ACe(n);
});
function ACe(n) {
  return (e, t, r, i) => {
    let o = "";
    return Nr(t) ? (r = t, o = "") : Li(t) ? o = "" : o = t, pv(Object.assign({
      title: o,
      message: e,
      type: "",
      ...CCe[n]
    }, r, {
      boxType: n
    }), i);
  };
}
pv.close = () => {
  r0.forEach((n, e) => {
    e.doClose();
  }), r0.clear();
};
pv._context = null;
const Wu = pv;
Wu.install = (n) => {
  Wu._context = n._context, n.config.globalProperties.$msgbox = Wu, n.config.globalProperties.$messageBox = Wu, n.config.globalProperties.$alert = Wu.alert, n.config.globalProperties.$confirm = Wu.confirm, n.config.globalProperties.$prompt = Wu.prompt;
};
const w6t = Wu, JH = [
  "success",
  "info",
  "warning",
  "error"
], TCe = Ye({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: $r
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: Ae([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Ae(Function),
    default: () => {
    }
  },
  onClose: {
    type: Ae(Function),
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...JH, ""],
    default: ""
  },
  zIndex: Number
}), kCe = {
  destroy: () => !0
}, PCe = ["id"], ECe = ["textContent"], MCe = { key: 0 }, DCe = ["innerHTML"], LCe = U({
  name: "ElNotification"
}), ICe = /* @__PURE__ */ U({
  ...LCe,
  props: TCe,
  emits: kCe,
  setup(n, { expose: e }) {
    const t = n, { ns: r, zIndex: i } = IL("notification"), { nextZIndex: o, currentZIndex: a } = i, { Close: s } = f7, l = z(!1);
    let u;
    const c = B(() => {
      const b = t.type;
      return b && dg[t.type] ? r.m(b) : "";
    }), h = B(() => t.type && dg[t.type] || t.icon), f = B(() => t.position.endsWith("right") ? "right" : "left"), d = B(() => t.position.startsWith("top") ? "top" : "bottom"), p = B(() => {
      var b;
      return {
        [d.value]: `${t.offset}px`,
        zIndex: (b = t.zIndex) != null ? b : a.value
      };
    });
    function g() {
      t.duration > 0 && ({ stop: u } = hx(() => {
        l.value && m();
      }, t.duration));
    }
    function v() {
      u == null || u();
    }
    function m() {
      l.value = !1;
    }
    function y({ code: b }) {
      b === Ft.delete || b === Ft.backspace ? v() : b === Ft.esc ? l.value && m() : g();
    }
    return ht(() => {
      g(), o(), l.value = !0;
    }), Yi(document, "keydown", y), e({
      visible: l,
      close: m
    }), (b, O) => (V(), ve(kl, {
      name: T(r).b("fade"),
      onBeforeLeave: b.onClose,
      onAfterLeave: O[1] || (O[1] = (w) => b.$emit("destroy")),
      persisted: ""
    }, {
      default: fe(() => [
        At(J("div", {
          id: b.id,
          class: Q([T(r).b(), b.customClass, T(f)]),
          style: vt(T(p)),
          role: "alert",
          onMouseenter: v,
          onMouseleave: g,
          onClick: O[0] || (O[0] = (...w) => b.onClick && b.onClick(...w))
        }, [
          T(h) ? (V(), ve(T(bt), {
            key: 0,
            class: Q([T(r).e("icon"), T(c)])
          }, {
            default: fe(() => [
              (V(), ve(cn(T(h))))
            ]),
            _: 1
          }, 8, ["class"])) : pe("v-if", !0),
          J("div", {
            class: Q(T(r).e("group"))
          }, [
            J("h2", {
              class: Q(T(r).e("title")),
              textContent: ze(b.title)
            }, null, 10, ECe),
            At(J("div", {
              class: Q(T(r).e("content")),
              style: vt(b.title ? void 0 : { margin: 0 })
            }, [
              ke(b.$slots, "default", {}, () => [
                b.dangerouslyUseHTMLString ? (V(), q(yn, { key: 1 }, [
                  pe(" Caution here, message could've been compromised, never use user's input as message "),
                  J("p", { innerHTML: b.message }, null, 8, DCe)
                ], 2112)) : (V(), q("p", MCe, ze(b.message), 1))
              ])
            ], 6), [
              [On, b.message]
            ]),
            b.showClose ? (V(), ve(T(bt), {
              key: 0,
              class: Q(T(r).e("closeBtn")),
              onClick: kt(m, ["stop"])
            }, {
              default: fe(() => [
                de(T(s))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : pe("v-if", !0)
          ], 2)
        ], 46, PCe), [
          [On, l.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var RCe = /* @__PURE__ */ Ve(ICe, [["__file", "notification.vue"]]);
const px = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, DP = 16;
let NCe = 1;
const wg = function(n = {}, e = null) {
  if (!qt)
    return { close: () => {
    } };
  (typeof n == "string" || gl(n)) && (n = { message: n });
  const t = n.position || "top-right";
  let r = n.offset || 0;
  px[t].forEach(({ vm: c }) => {
    var h;
    r += (((h = c.el) == null ? void 0 : h.offsetHeight) || 0) + DP;
  }), r += DP;
  const i = `notification_${NCe++}`, o = n.onClose, a = {
    ...n,
    offset: r,
    id: i,
    onClose: () => {
      $Ce(i, t, o);
    }
  };
  let s = document.body;
  hs(n.appendTo) ? s = n.appendTo : Ut(n.appendTo) && (s = document.querySelector(n.appendTo)), hs(s) || (Ht("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), s = document.body);
  const l = document.createElement("div"), u = de(RCe, a, gl(a.message) ? {
    default: () => a.message
  } : null);
  return u.appContext = e ?? wg._context, u.props.onDestroy = () => {
    Tc(null, l);
  }, Tc(u, l), px[t].push({ vm: u }), s.appendChild(l.firstElementChild), {
    close: () => {
      u.component.exposed.visible.value = !1;
    }
  };
};
JH.forEach((n) => {
  wg[n] = (e = {}) => ((typeof e == "string" || gl(e)) && (e = {
    message: e
  }), wg({
    ...e,
    type: n
  }));
});
function $Ce(n, e, t) {
  const r = px[e], i = r.findIndex(({ vm: u }) => {
    var c;
    return ((c = u.component) == null ? void 0 : c.props.id) === n;
  });
  if (i === -1)
    return;
  const { vm: o } = r[i];
  if (!o)
    return;
  t == null || t(o);
  const a = o.el.offsetHeight, s = e.split("-")[0];
  r.splice(i, 1);
  const l = r.length;
  if (!(l < 1))
    for (let u = i; u < l; u++) {
      const { el: c, component: h } = r[u].vm, f = Number.parseInt(c.style[s], 10) - a - DP;
      h.props.offset = f;
    }
}
function BCe() {
  for (const n of Object.values(px))
    n.forEach(({ vm: e }) => {
      e.component.exposed.visible.value = !1;
    });
}
wg.closeAll = BCe;
wg._context = null;
const x6t = g7(wg, "$notify");
function VCe(n, e) {
  let t, r, i;
  const o = z(!0), a = () => {
    o.value = !0, i();
  };
  he(n, a, { flush: "sync" });
  const s = typeof e == "function" ? e : e.get, l = typeof e == "function" ? void 0 : e.set, u = cae((c, h) => (r = c, i = h, {
    get() {
      return o.value && (t = s(), o.value = !1), r(), t;
    },
    set(f) {
      l == null || l(f);
    }
  }));
  return Object.isExtensible(u) && (u.trigger = a), u;
}
function YL(n) {
  return kG() ? (KD(n), !0) : !1;
}
function zCe(n, e) {
  if (typeof Symbol < "u") {
    const t = { ...n };
    return Object.defineProperty(t, Symbol.iterator, {
      enumerable: !1,
      value() {
        let r = 0;
        return {
          next: () => ({
            value: e[r++],
            done: r > e.length
          })
        };
      }
    }), t;
  } else
    return Object.assign([...e], n);
}
function go(n) {
  return typeof n == "function" ? n() : T(n);
}
const XL = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const FCe = Object.prototype.toString, QCe = (n) => FCe.call(n) === "[object Object]", Kf = () => {
};
function UL(n, e) {
  function t(...r) {
    return new Promise((i, o) => {
      Promise.resolve(n(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(o);
    });
  }
  return t;
}
const ZCe = (n) => n();
function eq(n, e = {}) {
  let t, r, i = Kf;
  const o = (s) => {
    clearTimeout(s), i(), i = Kf;
  };
  return (s) => {
    const l = go(n), u = go(e.maxWait);
    return t && o(t), l <= 0 || u !== void 0 && u <= 0 ? (r && (o(r), r = null), Promise.resolve(s())) : new Promise((c, h) => {
      i = e.rejectOnCancel ? h : c, u && !r && (r = setTimeout(() => {
        t && o(t), r = null, c(s());
      }, u)), t = setTimeout(() => {
        r && o(r), r = null, c(s());
      }, l);
    });
  };
}
function WCe(...n) {
  let e = 0, t, r = !0, i = Kf, o, a, s, l, u;
  !So(n[0]) && typeof n[0] == "object" ? { delay: a, trailing: s = !0, leading: l = !0, rejectOnCancel: u = !1 } = n[0] : [a, s = !0, l = !0, u = !1] = n;
  const c = () => {
    t && (clearTimeout(t), t = void 0, i(), i = Kf);
  };
  return (f) => {
    const d = go(a), p = Date.now() - e, g = () => o = f();
    return c(), d <= 0 ? (e = Date.now(), g()) : (p > d && (l || !r) ? (e = Date.now(), g()) : s && (o = new Promise((v, m) => {
      i = u ? m : v, t = setTimeout(() => {
        e = Date.now(), r = !0, v(g()), c();
      }, Math.max(0, d - p));
    })), !l && !t && (t = setTimeout(() => r = !0, d)), r = !1, o);
  };
}
function GCe(n) {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}
const jCe = /-(\w)/g, HCe = GCe((n) => n.replace(jCe, (e, t) => t ? t.toUpperCase() : ""));
function qCe(n) {
  let e;
  function t() {
    return e || (e = n()), e;
  }
  return t.reset = async () => {
    const r = e;
    e = void 0, r && await r;
  }, t;
}
function YCe(n) {
  return n || wt();
}
function tq(n, e = 200, t = {}) {
  return UL(
    eq(e, t),
    n
  );
}
function S6t(n, e = 200, t = {}) {
  const r = z(n.value), i = tq(() => {
    r.value = n.value;
  }, e, t);
  return he(n, () => i()), r;
}
function XCe(n, e = 200, t = !1, r = !0, i = !1) {
  return UL(
    WCe(e, t, r, i),
    n
  );
}
function UCe(n, e, t = {}) {
  const {
    eventFilter: r = ZCe,
    ...i
  } = t;
  return he(
    n,
    UL(
      r,
      e
    ),
    i
  );
}
function KL(n, e = !0, t) {
  YCe() ? ht(n, t) : e ? n() : Ke(n);
}
function KCe(n, e, t = {}) {
  const {
    immediate: r = !0
  } = t, i = z(!1);
  let o = null;
  function a() {
    o && (clearTimeout(o), o = null);
  }
  function s() {
    i.value = !1, a();
  }
  function l(...u) {
    a(), i.value = !0, o = setTimeout(() => {
      i.value = !1, o = null, n(...u);
    }, go(e));
  }
  return r && (i.value = !0, XL && l()), YL(s), {
    isPending: o_(i),
    start: l,
    stop: s
  };
}
function _6t(n, e, t = {}) {
  const {
    debounce: r = 0,
    maxWait: i = void 0,
    ...o
  } = t;
  return UCe(
    n,
    e,
    {
      ...o,
      eventFilter: eq(r, { maxWait: i })
    }
  );
}
function C6t(n = {}) {
  const {
    inheritAttrs: e = !0
  } = n, t = di(), r = /* @__PURE__ */ U({
    setup(o, { slots: a }) {
      return () => {
        t.value = a.default;
      };
    }
  }), i = /* @__PURE__ */ U({
    inheritAttrs: e,
    setup(o, { attrs: a, slots: s }) {
      return () => {
        var l;
        if (!t.value && process.env.NODE_ENV !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const u = (l = t.value) == null ? void 0 : l.call(t, { ...JCe(a), $slots: s });
        return e && (u == null ? void 0 : u.length) === 1 ? u[0] : u;
      };
    }
  });
  return zCe(
    { define: r, reuse: i },
    [r, i]
  );
}
function JCe(n) {
  const e = {};
  for (const t in n)
    e[HCe(t)] = n[t];
  return e;
}
function ns(n) {
  var e;
  const t = go(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const gv = XL ? window : void 0, nq = XL ? window.navigator : void 0;
function ri(...n) {
  let e, t, r, i;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([t, r, i] = n, e = gv) : [e, t, r, i] = n, !e)
    return Kf;
  Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]);
  const o = [], a = () => {
    o.forEach((c) => c()), o.length = 0;
  }, s = (c, h, f, d) => (c.addEventListener(h, f, d), () => c.removeEventListener(h, f, d)), l = he(
    () => [ns(e), go(i)],
    ([c, h]) => {
      if (a(), !c)
        return;
      const f = QCe(h) ? { ...h } : h;
      o.push(
        ...t.flatMap((d) => r.map((p) => s(c, d, p, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    l(), a();
  };
  return YL(u), u;
}
function e2e() {
  const n = z(!1), e = wt();
  return e && ht(() => {
    n.value = !0;
  }, e), n;
}
function JL(n) {
  const e = e2e();
  return B(() => (e.value, !!n()));
}
function FB(n, e = {}) {
  const {
    controls: t = !1,
    navigator: r = nq
  } = e, i = JL(() => r && "permissions" in r);
  let o;
  const a = typeof n == "string" ? { name: n } : n, s = z(), l = () => {
    o && (s.value = o.state);
  }, u = qCe(async () => {
    if (i.value) {
      if (!o)
        try {
          o = await r.permissions.query(a), ri(o, "change", l), l();
        } catch {
          s.value = "prompt";
        }
      return o;
    }
  });
  return u(), t ? {
    state: s,
    isSupported: i,
    query: u
  } : s;
}
function A6t(n = {}) {
  const {
    navigator: e = nq,
    read: t = !1,
    source: r,
    copiedDuring: i = 1500,
    legacy: o = !1
  } = n, a = JL(() => e && "clipboard" in e), s = FB("clipboard-read"), l = FB("clipboard-write"), u = B(() => a.value || o), c = z(""), h = z(!1), f = KCe(() => h.value = !1, i);
  function d() {
    a.value && s.value !== "denied" ? e.clipboard.readText().then((m) => {
      c.value = m;
    }) : c.value = v();
  }
  u.value && t && ri(["copy", "cut"], d);
  async function p(m = go(r)) {
    u.value && m != null && (a.value && l.value !== "denied" ? await e.clipboard.writeText(m) : g(m), c.value = m, h.value = !0, f.start());
  }
  function g(m) {
    const y = document.createElement("textarea");
    y.value = m ?? "", y.style.position = "absolute", y.style.opacity = "0", document.body.appendChild(y), y.select(), document.execCommand("copy"), y.remove();
  }
  function v() {
    var m, y, b;
    return (b = (y = (m = document == null ? void 0 : document.getSelection) == null ? void 0 : m.call(document)) == null ? void 0 : y.toString()) != null ? b : "";
  }
  return {
    isSupported: u,
    text: c,
    copied: h,
    copy: p
  };
}
function t2e(n) {
  const e = wt(), t = VCe(
    () => null,
    () => n ? ns(n) : e.proxy.$el
  );
  return yd(t.trigger), ht(t.trigger), t;
}
function n2e(n, e, t = {}) {
  const { window: r = gv, ...i } = t;
  let o;
  const a = JL(() => r && "ResizeObserver" in r), s = () => {
    o && (o.disconnect(), o = void 0);
  }, l = B(() => Array.isArray(n) ? n.map((h) => ns(h)) : [ns(n)]), u = he(
    l,
    (h) => {
      if (s(), a.value && r) {
        o = new ResizeObserver(e);
        for (const f of h)
          f && o.observe(f, i);
      }
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    s(), u();
  };
  return YL(c), {
    isSupported: a,
    stop: c
  };
}
function T6t(n, e = { width: 0, height: 0 }, t = {}) {
  const { window: r = gv, box: i = "content-box" } = t, o = B(() => {
    var h, f;
    return (f = (h = ns(n)) == null ? void 0 : h.namespaceURI) == null ? void 0 : f.includes("svg");
  }), a = z(e.width), s = z(e.height), { stop: l } = n2e(
    n,
    ([h]) => {
      const f = i === "border-box" ? h.borderBoxSize : i === "content-box" ? h.contentBoxSize : h.devicePixelContentBoxSize;
      if (r && o.value) {
        const d = ns(n);
        if (d) {
          const p = r.getComputedStyle(d);
          a.value = Number.parseFloat(p.width), s.value = Number.parseFloat(p.height);
        }
      } else if (f) {
        const d = Array.isArray(f) ? f : [f];
        a.value = d.reduce((p, { inlineSize: g }) => p + g, 0), s.value = d.reduce((p, { blockSize: g }) => p + g, 0);
      } else
        a.value = h.contentRect.width, s.value = h.contentRect.height;
    },
    t
  );
  KL(() => {
    const h = ns(n);
    h && (a.value = "offsetWidth" in h ? h.offsetWidth : e.width, s.value = "offsetHeight" in h ? h.offsetHeight : e.height);
  });
  const u = he(
    () => ns(n),
    (h) => {
      a.value = h ? e.width : 0, s.value = h ? e.height : 0;
    }
  );
  function c() {
    l(), u();
  }
  return {
    width: a,
    height: s,
    stop: c
  };
}
const QB = 1;
function k6t(n, e = {}) {
  const {
    throttle: t = 0,
    idle: r = 200,
    onStop: i = Kf,
    onScroll: o = Kf,
    offset: a = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: s = {
      capture: !1,
      passive: !0
    },
    behavior: l = "auto",
    window: u = gv,
    onError: c = (S) => {
      console.error(S);
    }
  } = e, h = z(0), f = z(0), d = B({
    get() {
      return h.value;
    },
    set(S) {
      g(S, void 0);
    }
  }), p = B({
    get() {
      return f.value;
    },
    set(S) {
      g(void 0, S);
    }
  });
  function g(S, _) {
    var C, A, k;
    if (!u)
      return;
    const P = go(n);
    P && ((k = P instanceof Document ? u.document.body : P) == null || k.scrollTo({
      top: (C = go(_)) != null ? C : p.value,
      left: (A = go(S)) != null ? A : d.value,
      behavior: go(l)
    }));
  }
  const v = z(!1), m = dr({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), y = dr({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), b = (S) => {
    v.value && (v.value = !1, y.left = !1, y.right = !1, y.top = !1, y.bottom = !1, i(S));
  }, O = tq(b, t + r), w = (S) => {
    var _;
    if (!u)
      return;
    const C = ((_ = S == null ? void 0 : S.document) == null ? void 0 : _.documentElement) || (S == null ? void 0 : S.documentElement) || ns(S), { display: A, flexDirection: k } = getComputedStyle(C), P = C.scrollLeft;
    y.left = P < h.value, y.right = P > h.value;
    const L = Math.abs(P) <= (a.left || 0), D = Math.abs(P) + C.clientWidth >= C.scrollWidth - (a.right || 0) - QB;
    A === "flex" && k === "row-reverse" ? (m.left = D, m.right = L) : (m.left = L, m.right = D), h.value = P;
    let E = C.scrollTop;
    S === u.document && !E && (E = u.document.body.scrollTop), y.top = E < f.value, y.bottom = E > f.value;
    const M = Math.abs(E) <= (a.top || 0), R = Math.abs(E) + C.clientHeight >= C.scrollHeight - (a.bottom || 0) - QB;
    A === "flex" && k === "column-reverse" ? (m.top = R, m.bottom = M) : (m.top = M, m.bottom = R), f.value = E;
  }, x = (S) => {
    var _;
    if (!u)
      return;
    const C = (_ = S.target.documentElement) != null ? _ : S.target;
    w(C), v.value = !0, O(S), o(S);
  };
  return ri(
    n,
    "scroll",
    t ? XCe(x, t, !0, !1) : x,
    s
  ), KL(() => {
    try {
      const S = go(n);
      if (!S)
        return;
      w(S);
    } catch (S) {
      c(S);
    }
  }), ri(
    n,
    "scrollend",
    b,
    s
  ), {
    x: d,
    y: p,
    isScrolling: v,
    arrivedState: m,
    directions: y,
    measure() {
      const S = go(n);
      u && S && w(S);
    }
  };
}
const r2e = {
  page: (n) => [n.pageX, n.pageY],
  client: (n) => [n.clientX, n.clientY],
  screen: (n) => [n.screenX, n.screenY],
  movement: (n) => n instanceof Touch ? null : [n.movementX, n.movementY]
};
function P6t(n = {}) {
  const {
    type: e = "page",
    touch: t = !0,
    resetOnTouchEnds: r = !1,
    initialValue: i = { x: 0, y: 0 },
    window: o = gv,
    target: a = o,
    scroll: s = !0,
    eventFilter: l
  } = n;
  let u = null;
  const c = z(i.x), h = z(i.y), f = z(null), d = typeof e == "function" ? e : r2e[e], p = (w) => {
    const x = d(w);
    u = w, x && ([c.value, h.value] = x, f.value = "mouse");
  }, g = (w) => {
    if (w.touches.length > 0) {
      const x = d(w.touches[0]);
      x && ([c.value, h.value] = x, f.value = "touch");
    }
  }, v = () => {
    if (!u || !o)
      return;
    const w = d(u);
    u instanceof MouseEvent && w && (c.value = w[0] + o.scrollX, h.value = w[1] + o.scrollY);
  }, m = () => {
    c.value = i.x, h.value = i.y;
  }, y = l ? (w) => l(() => p(w), {}) : (w) => p(w), b = l ? (w) => l(() => g(w), {}) : (w) => g(w), O = l ? () => l(() => v(), {}) : () => v();
  if (a) {
    const w = { passive: !0 };
    ri(a, ["mousemove", "dragover"], y, w), t && e !== "movement" && (ri(a, ["touchstart", "touchmove"], b, w), r && ri(a, "touchend", m, w)), s && e === "page" && ri(o, "scroll", O, { passive: !0 });
  }
  return {
    x: c,
    y: h,
    sourceType: f
  };
}
function E6t(n = {}) {
  const {
    touch: e = !0,
    drag: t = !0,
    capture: r = !1,
    initialValue: i = !1,
    window: o = gv
  } = n, a = z(i), s = z(null);
  if (!o)
    return {
      pressed: a,
      sourceType: s
    };
  const l = (h) => () => {
    a.value = !0, s.value = h;
  }, u = () => {
    a.value = !1, s.value = null;
  }, c = B(() => ns(n.target) || o);
  return ri(c, "mousedown", l("mouse"), { passive: !0, capture: r }), ri(o, "mouseleave", u, { passive: !0, capture: r }), ri(o, "mouseup", u, { passive: !0, capture: r }), t && (ri(c, "dragstart", l("mouse"), { passive: !0, capture: r }), ri(o, "drop", u, { passive: !0, capture: r }), ri(o, "dragend", u, { passive: !0, capture: r })), e && (ri(c, "touchstart", l("touch"), { passive: !0, capture: r }), ri(o, "touchend", u, { passive: !0, capture: r }), ri(o, "touchcancel", u, { passive: !0, capture: r })), {
    pressed: a,
    sourceType: s
  };
}
function M6t(n = t2e()) {
  const e = di(), t = () => {
    const r = ns(n);
    r && (e.value = r.parentElement);
  };
  return KL(t), he(() => go(n), t), e;
}
var rq = { exports: {} };
/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function(n, e) {
  (function(r, i) {
    n.exports = i();
  })(Cbe, function() {
    return (
      /******/
      function() {
        var t = {
          /***/
          686: (
            /***/
            function(o, a, s) {
              s.d(a, {
                default: function() {
                  return (
                    /* binding */
                    W
                  );
                }
              });
              var l = s(279), u = /* @__PURE__ */ s.n(l), c = s(370), h = /* @__PURE__ */ s.n(c), f = s(817), d = /* @__PURE__ */ s.n(f);
              function p(j) {
                try {
                  return document.execCommand(j);
                } catch {
                  return !1;
                }
              }
              var g = function(Y) {
                var X = d()(Y);
                return p("cut"), X;
              }, v = g;
              function m(j) {
                var Y = document.documentElement.getAttribute("dir") === "rtl", X = document.createElement("textarea");
                X.style.fontSize = "12pt", X.style.border = "0", X.style.padding = "0", X.style.margin = "0", X.style.position = "absolute", X.style[Y ? "right" : "left"] = "-9999px";
                var ie = window.pageYOffset || document.documentElement.scrollTop;
                return X.style.top = "".concat(ie, "px"), X.setAttribute("readonly", ""), X.value = j, X;
              }
              var y = function(Y, X) {
                var ie = m(Y);
                X.container.appendChild(ie);
                var ae = d()(ie);
                return p("copy"), ie.remove(), ae;
              }, b = function(Y) {
                var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                  container: document.body
                }, ie = "";
                return typeof Y == "string" ? ie = y(Y, X) : Y instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(Y == null ? void 0 : Y.type) ? ie = y(Y.value, X) : (ie = d()(Y), p("copy")), ie;
              }, O = b;
              function w(j) {
                "@babel/helpers - typeof";
                return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? w = function(X) {
                  return typeof X;
                } : w = function(X) {
                  return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X;
                }, w(j);
              }
              var x = function() {
                var Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, X = Y.action, ie = X === void 0 ? "copy" : X, ae = Y.container, ee = Y.target, ne = Y.text;
                if (ie !== "copy" && ie !== "cut")
                  throw new Error('Invalid "action" value, use either "copy" or "cut"');
                if (ee !== void 0)
                  if (ee && w(ee) === "object" && ee.nodeType === 1) {
                    if (ie === "copy" && ee.hasAttribute("disabled"))
                      throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                    if (ie === "cut" && (ee.hasAttribute("readonly") || ee.hasAttribute("disabled")))
                      throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                  } else
                    throw new Error('Invalid "target" value, use a valid Element');
                if (ne)
                  return O(ne, {
                    container: ae
                  });
                if (ee)
                  return ie === "cut" ? v(ee) : O(ee, {
                    container: ae
                  });
              }, S = x;
              function _(j) {
                "@babel/helpers - typeof";
                return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _ = function(X) {
                  return typeof X;
                } : _ = function(X) {
                  return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X;
                }, _(j);
              }
              function C(j, Y) {
                if (!(j instanceof Y))
                  throw new TypeError("Cannot call a class as a function");
              }
              function A(j, Y) {
                for (var X = 0; X < Y.length; X++) {
                  var ie = Y[X];
                  ie.enumerable = ie.enumerable || !1, ie.configurable = !0, "value" in ie && (ie.writable = !0), Object.defineProperty(j, ie.key, ie);
                }
              }
              function k(j, Y, X) {
                return Y && A(j.prototype, Y), X && A(j, X), j;
              }
              function P(j, Y) {
                if (typeof Y != "function" && Y !== null)
                  throw new TypeError("Super expression must either be null or a function");
                j.prototype = Object.create(Y && Y.prototype, { constructor: { value: j, writable: !0, configurable: !0 } }), Y && L(j, Y);
              }
              function L(j, Y) {
                return L = Object.setPrototypeOf || function(ie, ae) {
                  return ie.__proto__ = ae, ie;
                }, L(j, Y);
              }
              function D(j) {
                var Y = R();
                return function() {
                  var ie = N(j), ae;
                  if (Y) {
                    var ee = N(this).constructor;
                    ae = Reflect.construct(ie, arguments, ee);
                  } else
                    ae = ie.apply(this, arguments);
                  return E(this, ae);
                };
              }
              function E(j, Y) {
                return Y && (_(Y) === "object" || typeof Y == "function") ? Y : M(j);
              }
              function M(j) {
                if (j === void 0)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return j;
              }
              function R() {
                if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                  return !1;
                if (typeof Proxy == "function")
                  return !0;
                try {
                  return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                  })), !0;
                } catch {
                  return !1;
                }
              }
              function N(j) {
                return N = Object.setPrototypeOf ? Object.getPrototypeOf : function(X) {
                  return X.__proto__ || Object.getPrototypeOf(X);
                }, N(j);
              }
              function $(j, Y) {
                var X = "data-clipboard-".concat(j);
                if (Y.hasAttribute(X))
                  return Y.getAttribute(X);
              }
              var F = /* @__PURE__ */ function(j) {
                P(X, j);
                var Y = D(X);
                function X(ie, ae) {
                  var ee;
                  return C(this, X), ee = Y.call(this), ee.resolveOptions(ae), ee.listenClick(ie), ee;
                }
                return k(X, [{
                  key: "resolveOptions",
                  value: function() {
                    var ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    this.action = typeof ae.action == "function" ? ae.action : this.defaultAction, this.target = typeof ae.target == "function" ? ae.target : this.defaultTarget, this.text = typeof ae.text == "function" ? ae.text : this.defaultText, this.container = _(ae.container) === "object" ? ae.container : document.body;
                  }
                  /**
                   * Adds a click event listener to the passed trigger.
                   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                   */
                }, {
                  key: "listenClick",
                  value: function(ae) {
                    var ee = this;
                    this.listener = h()(ae, "click", function(ne) {
                      return ee.onClick(ne);
                    });
                  }
                  /**
                   * Defines a new `ClipboardAction` on each click event.
                   * @param {Event} e
                   */
                }, {
                  key: "onClick",
                  value: function(ae) {
                    var ee = ae.delegateTarget || ae.currentTarget, ne = this.action(ee) || "copy", ye = S({
                      action: ne,
                      container: this.container,
                      target: this.target(ee),
                      text: this.text(ee)
                    });
                    this.emit(ye ? "success" : "error", {
                      action: ne,
                      text: ye,
                      trigger: ee,
                      clearSelection: function() {
                        ee && ee.focus(), window.getSelection().removeAllRanges();
                      }
                    });
                  }
                  /**
                   * Default `action` lookup function.
                   * @param {Element} trigger
                   */
                }, {
                  key: "defaultAction",
                  value: function(ae) {
                    return $("action", ae);
                  }
                  /**
                   * Default `target` lookup function.
                   * @param {Element} trigger
                   */
                }, {
                  key: "defaultTarget",
                  value: function(ae) {
                    var ee = $("target", ae);
                    if (ee)
                      return document.querySelector(ee);
                  }
                  /**
                   * Allow fire programmatically a copy action
                   * @param {String|HTMLElement} target
                   * @param {Object} options
                   * @returns Text copied.
                   */
                }, {
                  key: "defaultText",
                  /**
                   * Default `text` lookup function.
                   * @param {Element} trigger
                   */
                  value: function(ae) {
                    return $("text", ae);
                  }
                  /**
                   * Destroy lifecycle.
                   */
                }, {
                  key: "destroy",
                  value: function() {
                    this.listener.destroy();
                  }
                }], [{
                  key: "copy",
                  value: function(ae) {
                    var ee = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                      container: document.body
                    };
                    return O(ae, ee);
                  }
                  /**
                   * Allow fire programmatically a cut action
                   * @param {String|HTMLElement} target
                   * @returns Text cutted.
                   */
                }, {
                  key: "cut",
                  value: function(ae) {
                    return v(ae);
                  }
                  /**
                   * Returns the support of the given action, or all actions if no action is
                   * given.
                   * @param {String} [action]
                   */
                }, {
                  key: "isSupported",
                  value: function() {
                    var ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"], ee = typeof ae == "string" ? [ae] : ae, ne = !!document.queryCommandSupported;
                    return ee.forEach(function(ye) {
                      ne = ne && !!document.queryCommandSupported(ye);
                    }), ne;
                  }
                }]), X;
              }(u()), W = F;
            }
          ),
          /***/
          828: (
            /***/
            function(o) {
              var a = 9;
              if (typeof Element < "u" && !Element.prototype.matches) {
                var s = Element.prototype;
                s.matches = s.matchesSelector || s.mozMatchesSelector || s.msMatchesSelector || s.oMatchesSelector || s.webkitMatchesSelector;
              }
              function l(u, c) {
                for (; u && u.nodeType !== a; ) {
                  if (typeof u.matches == "function" && u.matches(c))
                    return u;
                  u = u.parentNode;
                }
              }
              o.exports = l;
            }
          ),
          /***/
          438: (
            /***/
            function(o, a, s) {
              var l = s(828);
              function u(f, d, p, g, v) {
                var m = h.apply(this, arguments);
                return f.addEventListener(p, m, v), {
                  destroy: function() {
                    f.removeEventListener(p, m, v);
                  }
                };
              }
              function c(f, d, p, g, v) {
                return typeof f.addEventListener == "function" ? u.apply(null, arguments) : typeof p == "function" ? u.bind(null, document).apply(null, arguments) : (typeof f == "string" && (f = document.querySelectorAll(f)), Array.prototype.map.call(f, function(m) {
                  return u(m, d, p, g, v);
                }));
              }
              function h(f, d, p, g) {
                return function(v) {
                  v.delegateTarget = l(v.target, d), v.delegateTarget && g.call(f, v);
                };
              }
              o.exports = c;
            }
          ),
          /***/
          879: (
            /***/
            function(o, a) {
              a.node = function(s) {
                return s !== void 0 && s instanceof HTMLElement && s.nodeType === 1;
              }, a.nodeList = function(s) {
                var l = Object.prototype.toString.call(s);
                return s !== void 0 && (l === "[object NodeList]" || l === "[object HTMLCollection]") && "length" in s && (s.length === 0 || a.node(s[0]));
              }, a.string = function(s) {
                return typeof s == "string" || s instanceof String;
              }, a.fn = function(s) {
                var l = Object.prototype.toString.call(s);
                return l === "[object Function]";
              };
            }
          ),
          /***/
          370: (
            /***/
            function(o, a, s) {
              var l = s(879), u = s(438);
              function c(p, g, v) {
                if (!p && !g && !v)
                  throw new Error("Missing required arguments");
                if (!l.string(g))
                  throw new TypeError("Second argument must be a String");
                if (!l.fn(v))
                  throw new TypeError("Third argument must be a Function");
                if (l.node(p))
                  return h(p, g, v);
                if (l.nodeList(p))
                  return f(p, g, v);
                if (l.string(p))
                  return d(p, g, v);
                throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
              }
              function h(p, g, v) {
                return p.addEventListener(g, v), {
                  destroy: function() {
                    p.removeEventListener(g, v);
                  }
                };
              }
              function f(p, g, v) {
                return Array.prototype.forEach.call(p, function(m) {
                  m.addEventListener(g, v);
                }), {
                  destroy: function() {
                    Array.prototype.forEach.call(p, function(m) {
                      m.removeEventListener(g, v);
                    });
                  }
                };
              }
              function d(p, g, v) {
                return u(document.body, p, g, v);
              }
              o.exports = c;
            }
          ),
          /***/
          817: (
            /***/
            function(o) {
              function a(s) {
                var l;
                if (s.nodeName === "SELECT")
                  s.focus(), l = s.value;
                else if (s.nodeName === "INPUT" || s.nodeName === "TEXTAREA") {
                  var u = s.hasAttribute("readonly");
                  u || s.setAttribute("readonly", ""), s.select(), s.setSelectionRange(0, s.value.length), u || s.removeAttribute("readonly"), l = s.value;
                } else {
                  s.hasAttribute("contenteditable") && s.focus();
                  var c = window.getSelection(), h = document.createRange();
                  h.selectNodeContents(s), c.removeAllRanges(), c.addRange(h), l = c.toString();
                }
                return l;
              }
              o.exports = a;
            }
          ),
          /***/
          279: (
            /***/
            function(o) {
              function a() {
              }
              a.prototype = {
                on: function(s, l, u) {
                  var c = this.e || (this.e = {});
                  return (c[s] || (c[s] = [])).push({
                    fn: l,
                    ctx: u
                  }), this;
                },
                once: function(s, l, u) {
                  var c = this;
                  function h() {
                    c.off(s, h), l.apply(u, arguments);
                  }
                  return h._ = l, this.on(s, h, u);
                },
                emit: function(s) {
                  var l = [].slice.call(arguments, 1), u = ((this.e || (this.e = {}))[s] || []).slice(), c = 0, h = u.length;
                  for (c; c < h; c++)
                    u[c].fn.apply(u[c].ctx, l);
                  return this;
                },
                off: function(s, l) {
                  var u = this.e || (this.e = {}), c = u[s], h = [];
                  if (c && l)
                    for (var f = 0, d = c.length; f < d; f++)
                      c[f].fn !== l && c[f].fn._ !== l && h.push(c[f]);
                  return h.length ? u[s] = h : delete u[s], this;
                }
              }, o.exports = a, o.exports.TinyEmitter = a;
            }
          )
          /******/
        }, r = {};
        function i(o) {
          if (r[o])
            return r[o].exports;
          var a = r[o] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return t[o](a, a.exports, i), a.exports;
        }
        return function() {
          i.n = function(o) {
            var a = o && o.__esModule ? (
              /******/
              function() {
                return o.default;
              }
            ) : (
              /******/
              function() {
                return o;
              }
            );
            return i.d(a, { a }), a;
          };
        }(), function() {
          i.d = function(o, a) {
            for (var s in a)
              i.o(a, s) && !i.o(o, s) && Object.defineProperty(o, s, { enumerable: !0, get: a[s] });
          };
        }(), function() {
          i.o = function(o, a) {
            return Object.prototype.hasOwnProperty.call(o, a);
          };
        }(), i(686);
      }().default
    );
  });
})(rq);
var i2e = rq.exports;
const D6t = /* @__PURE__ */ wb(i2e);
typeof window == "object" && window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach);
typeof window < "u" && function(n) {
  n.forEach((e) => {
    Object.prototype.hasOwnProperty.call(e, "append") || Object.defineProperty(e, "append", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value(...t) {
        const r = document.createDocumentFragment();
        t.forEach((i) => {
          const o = i instanceof Node;
          r.appendChild(o ? i : document.createTextNode(String(i)));
        }), this.appendChild(r);
      }
    });
  });
}([Element.prototype, Document.prototype, DocumentFragment.prototype]);
class au {
  get disposed() {
    return this._disposed === !0;
  }
  dispose() {
    this._disposed = !0;
  }
}
(function(n) {
  function e() {
    return (t, r, i) => {
      const o = i.value, a = t.__proto__;
      i.value = function(...s) {
        this.disposed || (o.call(this, ...s), a.dispose.call(this));
      };
    };
  }
  n.dispose = e;
})(au || (au = {}));
class ZB {
  constructor() {
    this.isDisposed = !1, this.items = /* @__PURE__ */ new Set();
  }
  /**
   * Test whether the set has been disposed.
   */
  get disposed() {
    return this.isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    this.isDisposed || (this.isDisposed = !0, this.items.forEach((e) => {
      e.dispose();
    }), this.items.clear());
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */
  contains(e) {
    return this.items.has(e);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */
  add(e) {
    this.items.add(e);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */
  remove(e) {
    this.items.delete(e);
  }
  /**
   * Remove all items from the set.
   */
  clear() {
    this.items.clear();
  }
}
(function(n) {
  function e(t) {
    const r = new n();
    return t.forEach((i) => {
      r.add(i);
    }), r;
  }
  n.from = e;
})(ZB || (ZB = {}));
function iq(n, e, t) {
  if (t)
    switch (t.length) {
      case 0:
        return n.call(e);
      case 1:
        return n.call(e, t[0]);
      case 2:
        return n.call(e, t[0], t[1]);
      case 3:
        return n.call(e, t[0], t[1], t[2]);
      case 4:
        return n.call(e, t[0], t[1], t[2], t[3]);
      case 5:
        return n.call(e, t[0], t[1], t[2], t[3], t[4]);
      case 6:
        return n.call(e, t[0], t[1], t[2], t[3], t[4], t[5]);
      default:
        return n.apply(e, t);
    }
  return n.call(e);
}
function rt(n, e, ...t) {
  return iq(n, e, t);
}
function o2e(n) {
  return typeof n == "object" && n.then && typeof n.then == "function";
}
function LP(n) {
  return n != null && (n instanceof Promise || o2e(n));
}
function eI(...n) {
  const e = [];
  if (n.forEach((r) => {
    Array.isArray(r) ? e.push(...r) : e.push(r);
  }), e.some((r) => LP(r))) {
    const r = e.map((i) => LP(i) ? i : Promise.resolve(i !== !1));
    return Promise.all(r).then((i) => i.reduce((o, a) => a !== !1 && o, !0));
  }
  return e.every((r) => r !== !1);
}
function a2e(...n) {
  const e = eI(n);
  return typeof e == "boolean" ? Promise.resolve(e) : e;
}
function O2(n, e) {
  const t = [];
  for (let r = 0; r < n.length; r += 2) {
    const i = n[r], o = n[r + 1], a = Array.isArray(e) ? e : [e], s = iq(i, o, a);
    t.push(s);
  }
  return eI(t);
}
class s2e {
  constructor() {
    this.listeners = {};
  }
  on(e, t, r) {
    return t == null ? this : (this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t, r), this);
  }
  once(e, t, r) {
    const i = (...o) => (this.off(e, i), O2([t, r], o));
    return this.on(e, i, this);
  }
  off(e, t, r) {
    if (!(e || t || r))
      return this.listeners = {}, this;
    const i = this.listeners;
    return (e ? [e] : Object.keys(i)).forEach((a) => {
      const s = i[a];
      if (s) {
        if (!(t || r)) {
          delete i[a];
          return;
        }
        for (let l = s.length - 2; l >= 0; l -= 2)
          t && s[l] !== t || r && s[l + 1] !== r || s.splice(l, 2);
      }
    }), this;
  }
  trigger(e, ...t) {
    let r = !0;
    if (e !== "*") {
      const o = this.listeners[e];
      o != null && (r = O2([...o], t));
    }
    const i = this.listeners["*"];
    return i != null ? eI([
      r,
      O2([...i], [e, ...t])
    ]) : r;
  }
  emit(e, ...t) {
    return this.trigger(e, ...t);
  }
}
function l2e(n, ...e) {
  e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((r) => {
      r !== "constructor" && Object.defineProperty(n.prototype, r, Object.getOwnPropertyDescriptor(t.prototype, r));
    });
  });
}
const u2e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, e) {
  n.__proto__ = e;
} || function(n, e) {
  for (const t in e)
    Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]);
};
function c2e(n, e) {
  u2e(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
class h2e {
}
const f2e = /^\s*class\s+/.test(`${h2e}`) || /^\s*class\s*\{/.test(`${class {
}}`);
function tI(n, e) {
  let t;
  return f2e ? t = class extends e {
  } : (t = function() {
    return e.apply(this, arguments);
  }, c2e(t, e)), Object.defineProperty(t, "name", { value: n }), t;
}
function WB(n) {
  return n === "__proto__";
}
function nI(n, e, t = "/") {
  let r;
  const i = Array.isArray(e) ? e : e.split(t);
  if (i.length)
    for (r = n; i.length; ) {
      const o = i.shift();
      if (Object(r) === r && o && o in r)
        r = r[o];
      else
        return;
    }
  return r;
}
function vv(n, e, t, r = "/") {
  const i = Array.isArray(e) ? e : e.split(r), o = i.pop();
  if (o && !WB(o)) {
    let a = n;
    i.forEach((s) => {
      WB(s) || (a[s] == null && (a[s] = {}), a = a[s]);
    }), a[o] = t;
  }
  return n;
}
function GB(n, e, t = "/") {
  const r = Array.isArray(e) ? e.slice() : e.split(t), i = r.pop();
  if (i)
    if (r.length > 0) {
      const o = nI(n, r);
      o && delete o[i];
    } else
      delete n[i];
  return n;
}
var d2e = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class Yn extends s2e {
  dispose() {
    this.off();
  }
}
d2e([
  au.dispose()
], Yn.prototype, "dispose", null);
(function(n) {
  n.dispose = au.dispose;
})(Yn || (Yn = {}));
l2e(Yn, au);
const oq = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, aq = oq((n) => n.replace(/\B([A-Z])/g, "-$1").toLowerCase()), rI = oq((n) => Bde(d_(n)).replace(/ /g, ""));
function w2(n) {
  let e = 2166136261, t = !1, r = n;
  for (let i = 0, o = r.length; i < o; i += 1) {
    let a = r.charCodeAt(i);
    a > 127 && !t && (r = unescape(encodeURIComponent(r)), a = r.charCodeAt(i), t = !0), e ^= a, e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
  }
  return e >>> 0;
}
function gx() {
  let n = "";
  const e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  for (let t = 0, r = e.length; t < r; t += 1) {
    const i = e[t], o = Math.random() * 16 | 0, a = i === "x" ? o : i === "y" ? o & 3 | 8 : i;
    n += a.toString(16);
  }
  return n;
}
function p2e(n, e, t) {
  const r = Math.min(2, Math.floor(n.length * 0.34));
  let i = Math.floor(n.length * 0.4) + 1, o, a = !1;
  const s = n.toLowerCase();
  for (const l of e) {
    const u = t(l);
    if (u !== void 0 && Math.abs(u.length - s.length) <= r) {
      const c = u.toLowerCase();
      if (c === s) {
        if (u === n)
          continue;
        return l;
      }
      if (a || u.length < 3)
        continue;
      const h = g2e(s, c, i - 1);
      if (h === void 0)
        continue;
      h < 3 ? (a = !0, o = l) : (i = h, o = l);
    }
  }
  return o;
}
function g2e(n, e, t) {
  let r = new Array(e.length + 1), i = new Array(e.length + 1);
  const o = t + 1;
  for (let s = 0; s <= e.length; s += 1)
    r[s] = s;
  for (let s = 1; s <= n.length; s += 1) {
    const l = n.charCodeAt(s - 1), u = s > t ? s - t : 1, c = e.length > t + s ? t + s : e.length;
    i[0] = s;
    let h = s;
    for (let d = 1; d < u; d += 1)
      i[d] = o;
    for (let d = u; d <= c; d += 1) {
      const p = l === e.charCodeAt(d - 1) ? r[d - 1] : Math.min(
        /* delete */
        r[d] + 1,
        /* insert */
        i[d - 1] + 1,
        /* substitute */
        r[d - 1] + 2
      );
      i[d] = p, h = Math.min(h, p);
    }
    for (let d = c + 1; d <= e.length; d += 1)
      i[d] = o;
    if (h > t)
      return;
    const f = r;
    r = i, i = f;
  }
  const a = r[e.length];
  return a > t ? void 0 : a;
}
function su(n) {
  return typeof n == "string" && n.slice(-1) === "%";
}
function ss(n, e) {
  if (n == null)
    return 0;
  let t;
  if (typeof n == "string") {
    if (t = parseFloat(n), su(n) && (t /= 100, Number.isFinite(t)))
      return t * e;
  } else
    t = n;
  return Number.isFinite(t) ? t > 0 && t < 1 ? t * e : t : 0;
}
function Jf(n) {
  if (typeof n == "object") {
    let t = 0, r = 0, i = 0, o = 0;
    return n.vertical != null && Number.isFinite(n.vertical) && (r = o = n.vertical), n.horizontal != null && Number.isFinite(n.horizontal) && (i = t = n.horizontal), n.left != null && Number.isFinite(n.left) && (t = n.left), n.top != null && Number.isFinite(n.top) && (r = n.top), n.right != null && Number.isFinite(n.right) && (i = n.right), n.bottom != null && Number.isFinite(n.bottom) && (o = n.bottom), { top: r, right: i, bottom: o, left: t };
  }
  let e = 0;
  return n != null && Number.isFinite(n) && (e = n), { top: e, right: e, bottom: e, left: e };
}
let iI = !1, sq = !1, lq = !1, uq = !1, cq = !1, hq = !1, fq = !1, dq = !1, pq = !1, gq = !1, vq = !1, mq = !1, yq = !1, bq = !1, Oq = !1, wq = !1;
if (typeof navigator == "object") {
  const n = navigator.userAgent;
  iI = n.indexOf("Macintosh") >= 0, sq = !!n.match(/(iPad|iPhone|iPod)/g), lq = n.indexOf("Windows") >= 0, uq = n.indexOf("MSIE") >= 0, cq = !!n.match(/Trident\/7\./), hq = !!n.match(/Edge\//), fq = n.indexOf("Mozilla/") >= 0 && n.indexOf("MSIE") < 0 && n.indexOf("Edge/") < 0, pq = n.indexOf("Chrome/") >= 0 && n.indexOf("Edge/") < 0, gq = n.indexOf("Opera/") >= 0 || n.indexOf("OPR/") >= 0, vq = n.indexOf("Firefox/") >= 0, mq = n.indexOf("AppleWebKit/") >= 0 && n.indexOf("Chrome/") < 0 && n.indexOf("Edge/") < 0, typeof document == "object" && (wq = !document.createElementNS || `${document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")}` != "[object SVGForeignObjectElement]" || n.indexOf("Opera/") >= 0);
}
typeof window == "object" && (dq = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null, bq = window.PointerEvent != null && !iI);
if (typeof document == "object") {
  yq = "ontouchstart" in document.documentElement;
  try {
    const n = Object.defineProperty({}, "passive", {
      get() {
        Oq = !0;
      }
    }), e = document.createElement("div");
    e.addEventListener && e.addEventListener("click", () => {
    }, n);
  } catch {
  }
}
var Mc;
(function(n) {
  n.IS_MAC = iI, n.IS_IOS = sq, n.IS_WINDOWS = lq, n.IS_IE = uq, n.IS_IE11 = cq, n.IS_EDGE = hq, n.IS_NETSCAPE = fq, n.IS_CHROME_APP = dq, n.IS_CHROME = pq, n.IS_OPERA = gq, n.IS_FIREFOX = vq, n.IS_SAFARI = mq, n.SUPPORT_TOUCH = yq, n.SUPPORT_POINTER = bq, n.SUPPORT_PASSIVE = Oq, n.NO_FOREIGNOBJECT = wq, n.SUPPORT_FOREIGNOBJECT = !n.NO_FOREIGNOBJECT;
})(Mc || (Mc = {}));
(function(n) {
  function e() {
    const o = window.module;
    return o != null && o.hot != null && o.hot.status != null ? o.hot.status() : "unkonwn";
  }
  n.getHMRStatus = e;
  function t() {
    return e() === "apply";
  }
  n.isApplyingHMR = t;
  const r = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  function i(o) {
    const a = document.createElement(r[o] || "div"), s = `on${o}`;
    let l = s in a;
    return l || (a.setAttribute(s, "return;"), l = typeof a[s] == "function"), l;
  }
  n.isEventSupported = i;
})(Mc || (Mc = {}));
const oI = /[\t\r\n\f]/g, aI = /\S+/g, xg = (n) => ` ${n} `;
function Sg(n) {
  return n && n.getAttribute && n.getAttribute("class") || "";
}
function mv(n, e) {
  if (n == null || e == null)
    return !1;
  const t = xg(Sg(n)), r = xg(e);
  return n.nodeType === 1 ? t.replace(oI, " ").includes(r) : !1;
}
function lt(n, e) {
  if (!(n == null || e == null)) {
    if (typeof e == "function")
      return lt(n, e(Sg(n)));
    if (typeof e == "string" && n.nodeType === 1) {
      const t = e.match(aI) || [], r = xg(Sg(n)).replace(oI, " ");
      let i = t.reduce((o, a) => o.indexOf(xg(a)) < 0 ? `${o}${a} ` : o, r);
      i = i.trim(), r !== i && n.setAttribute("class", i);
    }
  }
}
function br(n, e) {
  if (n != null) {
    if (typeof e == "function")
      return br(n, e(Sg(n)));
    if ((!e || typeof e == "string") && n.nodeType === 1) {
      const t = (e || "").match(aI) || [], r = xg(Sg(n)).replace(oI, " ");
      let i = t.reduce((o, a) => {
        const s = xg(a);
        return o.indexOf(s) > -1 ? o.replace(s, " ") : o;
      }, r);
      i = e ? i.trim() : "", r !== i && n.setAttribute("class", i);
    }
  }
}
function gy(n, e, t) {
  if (!(n == null || e == null)) {
    if (t != null && typeof e == "string") {
      t ? lt(n, e) : br(n, e);
      return;
    }
    if (typeof e == "function")
      return gy(n, e(Sg(n), t), t);
    typeof e == "string" && (e.match(aI) || []).forEach((i) => {
      mv(n, i) ? br(n, i) : lt(n, i);
    });
  }
}
let jB = 0;
function v2e() {
  return jB += 1, `v${jB}`;
}
function sI(n) {
  return (n.id == null || n.id === "") && (n.id = v2e()), n.id;
}
function Dc(n) {
  return n == null ? !1 : typeof n.getScreenCTM == "function" && n instanceof SVGElement;
}
const Hr = {
  svg: "http://www.w3.org/2000/svg",
  xmlns: "http://www.w3.org/2000/xmlns/",
  xml: "http://www.w3.org/XML/1998/namespace",
  xlink: "http://www.w3.org/1999/xlink",
  xhtml: "http://www.w3.org/1999/xhtml"
}, HB = "1.1";
function qB(n, e = document) {
  return e.createElement(n);
}
function lI(n, e = Hr.xhtml, t = document) {
  return t.createElementNS(e, n);
}
function xs(n, e = document) {
  return lI(n, Hr.svg, e);
}
function vx(n) {
  if (n) {
    const t = `<svg xmlns="${Hr.svg}" xmlns:xlink="${Hr.xlink}" version="${HB}">${n}</svg>`, { documentElement: r } = m2e(t, { async: !1 });
    return r;
  }
  const e = document.createElementNS(Hr.svg, "svg");
  return e.setAttributeNS(Hr.xmlns, "xmlns:xlink", Hr.xlink), e.setAttribute("version", HB), e;
}
function m2e(n, e = {}) {
  let t;
  try {
    const r = new DOMParser();
    if (e.async != null) {
      const i = r;
      i.async = e.async;
    }
    t = r.parseFromString(n, e.mimeType || "text/xml");
  } catch {
    t = void 0;
  }
  if (!t || t.getElementsByTagName("parsererror").length)
    throw new Error(`Invalid XML: ${n}`);
  return t;
}
function y2e(n, e = !0) {
  const t = n.nodeName;
  return e ? t.toLowerCase() : t.toUpperCase();
}
function uI(n) {
  let e = 0, t = n.previousSibling;
  for (; t; )
    t.nodeType === 1 && (e += 1), t = t.previousSibling;
  return e;
}
function b2e(n, e) {
  return n.querySelectorAll(e);
}
function O2e(n, e) {
  return n.querySelector(e);
}
function xq(n, e, t) {
  const r = n.ownerSVGElement;
  let i = n.parentNode;
  for (; i && i !== t && i !== r; ) {
    if (mv(i, e))
      return i;
    i = i.parentNode;
  }
  return null;
}
function Sq(n, e) {
  const t = e && e.parentNode;
  return n === t || !!(t && t.nodeType === 1 && n.compareDocumentPosition(t) & 16);
}
function cl(n) {
  n && (Array.isArray(n) ? n : [n]).forEach((t) => {
    t.parentNode && t.parentNode.removeChild(t);
  });
}
function Sb(n) {
  for (; n.firstChild; )
    n.removeChild(n.firstChild);
}
function sh(n, e) {
  (Array.isArray(e) ? e : [e]).forEach((r) => {
    r != null && n.appendChild(r);
  });
}
function _q(n, e) {
  const t = n.firstChild;
  return t ? cI(t, e) : sh(n, e);
}
function cI(n, e) {
  const t = n.parentNode;
  t && (Array.isArray(e) ? e : [e]).forEach((i) => {
    i != null && t.insertBefore(i, n);
  });
}
function vy(n, e) {
  e != null && e.appendChild(n);
}
function YB(n) {
  try {
    return n instanceof HTMLElement;
  } catch {
    return typeof n == "object" && n.nodeType === 1 && typeof n.style == "object" && typeof n.ownerDocument == "object";
  }
}
function w2e(n, e) {
  const t = [];
  let r = n.firstChild;
  for (; r; r = r.nextSibling)
    r.nodeType === 1 && (!e || mv(r, e)) && t.push(r);
  return t;
}
const Cq = [
  "viewBox",
  "attributeName",
  "attributeType",
  "repeatCount",
  "textLength",
  "lengthAdjust",
  "gradientUnits"
];
function x2e(n, e) {
  return n.getAttribute(e);
}
function hI(n, e) {
  const t = Tq(e);
  t.ns ? n.hasAttributeNS(t.ns, t.local) && n.removeAttributeNS(t.ns, t.local) : n.hasAttribute(e) && n.removeAttribute(e);
}
function fI(n, e, t) {
  if (t == null)
    return hI(n, e);
  const r = Tq(e);
  r.ns && typeof t == "string" ? n.setAttributeNS(r.ns, e, t) : e === "id" ? n.id = `${t}` : n.setAttribute(e, `${t}`);
}
function Aq(n, e) {
  Object.keys(e).forEach((t) => {
    fI(n, t, e[t]);
  });
}
function Xt(n, e, t) {
  if (e == null) {
    const r = n.attributes, i = {};
    for (let o = 0; o < r.length; o += 1)
      i[r[o].name] = r[o].value;
    return i;
  }
  if (typeof e == "string" && t === void 0)
    return n.getAttribute(e);
  typeof e == "object" ? Aq(n, e) : fI(n, e, t);
}
function Tq(n) {
  if (n.indexOf(":") !== -1) {
    const e = n.split(":");
    return {
      ns: Hr[e[0]],
      local: e[1]
    };
  }
  return {
    ns: null,
    local: n
  };
}
function i0(n) {
  const e = {};
  return Object.keys(n).forEach((t) => {
    const r = Cq.includes(t) ? t : aq(t);
    e[r] = n[t];
  }), e;
}
function m1(n) {
  const e = {};
  return n.split(";").forEach((r) => {
    const i = r.trim();
    if (i) {
      const o = i.split("=");
      o.length && (e[o[0].trim()] = o[1] ? o[1].trim() : "");
    }
  }), e;
}
function IP(n, e) {
  return Object.keys(e).forEach((t) => {
    if (t === "class")
      n[t] = n[t] ? `${n[t]} ${e[t]}` : e[t];
    else if (t === "style") {
      const r = typeof n[t] == "object", i = typeof e[t] == "object";
      let o, a;
      r && i ? (o = n[t], a = e[t]) : r ? (o = n[t], a = m1(e[t])) : i ? (o = m1(n[t]), a = e[t]) : (o = m1(n[t]), a = m1(e[t])), n[t] = IP(o, a);
    } else
      n[t] = e[t];
  }), n;
}
function S2e(n, e, t = {}) {
  const r = t.offset || 0, i = [], o = [];
  let a, s, l = null;
  for (let u = 0; u < n.length; u += 1) {
    a = o[u] = n[u];
    for (let c = 0, h = e.length; c < h; c += 1) {
      const f = e[c], d = f.start + r, p = f.end + r;
      u >= d && u < p && (typeof a == "string" ? a = o[u] = {
        t: n[u],
        attrs: f.attrs
      } : a.attrs = IP(IP({}, a.attrs), f.attrs), t.includeAnnotationIndices && (a.annotations == null && (a.annotations = []), a.annotations.push(c)));
    }
    s = o[u - 1], s ? tr(a) && tr(s) ? (l = l, JSON.stringify(a.attrs) === JSON.stringify(s.attrs) ? l.t += a.t : (i.push(l), l = a)) : tr(a) || tr(s) ? (l = l, i.push(l), l = a) : l = (l || "") + a : l = a;
  }
  return l != null && i.push(l), i;
}
function _2e(n) {
  return n.replace(/ /g, " ");
}
var XB;
(function(n) {
  function e(u) {
    const c = "data:";
    return u.substr(0, c.length) === c;
  }
  n.isDataUrl = e;
  function t(u, c) {
    if (!u || e(u)) {
      setTimeout(() => c(null, u));
      return;
    }
    const h = () => {
      c(new Error(`Failed to load image: ${u}`));
    }, f = window.FileReader ? (
      // chrome, IE10+
      (p) => {
        if (p.status === 200) {
          const g = new FileReader();
          g.onload = (v) => {
            const m = v.target.result;
            c(null, m);
          }, g.onerror = h, g.readAsDataURL(p.response);
        } else
          h();
      }
    ) : (p) => {
      const g = (v) => {
        const y = [];
        for (let b = 0; b < v.length; b += 32768)
          y.push(String.fromCharCode.apply(null, v.subarray(b, b + 32768)));
        return y.join("");
      };
      if (p.status === 200) {
        let v = u.split(".").pop() || "png";
        v === "svg" && (v = "svg+xml");
        const m = `data:image/${v};base64,`, y = new Uint8Array(p.response), b = m + btoa(g(y));
        c(null, b);
      } else
        h();
    }, d = new XMLHttpRequest();
    d.responseType = window.FileReader ? "blob" : "arraybuffer", d.open("GET", u, !0), d.addEventListener("error", h), d.addEventListener("load", () => f(d)), d.send();
  }
  n.imageToDataUri = t;
  function r(u) {
    let c = u.replace(/\s/g, "");
    c = decodeURIComponent(c);
    const h = c.indexOf(","), f = c.slice(0, h), d = f.split(":")[1].split(";")[0], p = c.slice(h + 1);
    let g;
    f.indexOf("base64") >= 0 ? g = atob(p) : g = unescape(encodeURIComponent(p));
    const v = new Uint8Array(g.length);
    for (let m = 0; m < g.length; m += 1)
      v[m] = g.charCodeAt(m);
    return new Blob([v], { type: d });
  }
  n.dataUriToBlob = r;
  function i(u, c) {
    const h = window.navigator.msSaveBlob;
    if (h)
      h(u, c);
    else {
      const f = window.URL.createObjectURL(u), d = document.createElement("a");
      d.href = f, d.download = c, document.body.appendChild(d), d.click(), document.body.removeChild(d), window.URL.revokeObjectURL(f);
    }
  }
  n.downloadBlob = i;
  function o(u, c) {
    const h = r(u);
    i(h, c);
  }
  n.downloadDataUri = o;
  function a(u) {
    const c = u.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    return c && c[2] ? c[2].replace(/\s+/, " ").split(" ") : null;
  }
  function s(u) {
    const c = parseFloat(u);
    return Number.isNaN(c) ? null : c;
  }
  function l(u, c = {}) {
    let h = null;
    const f = (b) => (h == null && (h = a(u)), h != null ? s(h[b]) : null), d = (b) => {
      const O = u.match(b);
      return O && O[2] ? s(O[2]) : null;
    };
    let p = c.width;
    if (p == null && (p = d(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i)), p == null && (p = f(2)), p == null)
      throw new Error("Can not parse width from svg string");
    let g = c.height;
    if (g == null && (g = d(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i)), g == null && (g = f(3)), g == null)
      throw new Error("Can not parse height from svg string");
    return `data:image/svg+xml,${encodeURIComponent(u).replace(/'/g, "%27").replace(/"/g, "%22")}`;
  }
  n.svgToDataUrl = l;
})(XB || (XB = {}));
let tf;
const C2e = {
  px(n) {
    return n;
  },
  mm(n) {
    return tf * n;
  },
  cm(n) {
    return tf * n * 10;
  },
  in(n) {
    return tf * n * 25.4;
  },
  pt(n) {
    return tf * (25.4 * n / 72);
  },
  pc(n) {
    return tf * (25.4 * n / 6);
  }
};
var UB;
(function(n) {
  function e(r, i, o) {
    const a = document.createElement("div"), s = a.style;
    s.display = "inline-block", s.position = "absolute", s.left = "-15000px", s.top = "-15000px", s.width = r + (o || "px"), s.height = i + (o || "px"), document.body.appendChild(a);
    const l = a.getBoundingClientRect(), u = {
      width: l.width || 0,
      height: l.height || 0
    };
    return document.body.removeChild(a), u;
  }
  n.measure = e;
  function t(r, i) {
    tf == null && (tf = e("1", "1", "mm").width);
    const o = i ? C2e[i] : null;
    return o ? o(r) : r;
  }
  n.toPx = t;
})(UB || (UB = {}));
const A2e = /-(.)/g;
function T2e(n) {
  return n.replace(A2e, (e, t) => t.toUpperCase());
}
const x2 = {}, KB = ["webkit", "ms", "moz", "o"], kq = typeof document < "u" ? document.createElement("div").style : {};
function k2e(n) {
  for (let e = 0; e < KB.length; e += 1) {
    const t = KB[e] + n;
    if (t in kq)
      return t;
  }
  return null;
}
function P2e(n) {
  const e = T2e(n);
  if (x2[e] == null) {
    const t = e.charAt(0).toUpperCase() + e.slice(1);
    x2[e] = e in kq ? e : k2e(t);
  }
  return x2[e];
}
function JB(n, e) {
  const t = n.ownerDocument && n.ownerDocument.defaultView && n.ownerDocument.defaultView.opener ? n.ownerDocument.defaultView.getComputedStyle(n, null) : window.getComputedStyle(n, null);
  return t && e ? t.getPropertyValue(e) || t[e] : t;
}
const E2e = {
  animationIterationCount: !0,
  columnCount: !0,
  flexGrow: !0,
  flexShrink: !0,
  fontWeight: !0,
  gridArea: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnStart: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowStart: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  widows: !0,
  zIndex: !0
};
function M2e(n) {
  return /^--/.test(n);
}
function D2e(n, e, t) {
  const r = window.getComputedStyle(n, null);
  return t ? r.getPropertyValue(e) || void 0 : r[e] || n.style[e];
}
function L2e(n, e) {
  return !E2e[n] && typeof e == "number" ? `${e}px` : e;
}
function Mr(n, e, t) {
  if (typeof e == "string") {
    const r = M2e(e);
    if (r || (e = P2e(e)), t === void 0)
      return D2e(n, e, r);
    r || (t = L2e(e, t));
    const i = n.style;
    r ? i.setProperty(e, t) : i[e] = t;
    return;
  }
  for (const r in e)
    Mr(n, r, e[r]);
}
const mx = /* @__PURE__ */ new WeakMap();
function e5(n, e) {
  const t = d_(e), r = mx.get(n);
  if (r)
    return r[t];
}
function I2e(n, e, t) {
  const r = d_(e), i = mx.get(n);
  i ? i[r] = t : mx.set(n, {
    [r]: t
  });
}
function ed(n, e, t) {
  if (!e) {
    const r = {};
    return Object.keys(mx).forEach((i) => {
      r[i] = e5(n, i);
    }), r;
  }
  if (typeof e == "string") {
    if (t === void 0)
      return e5(n, e);
    I2e(n, e, t);
    return;
  }
  for (const r in e)
    ed(n, r, e[r]);
}
class pt {
  get [Symbol.toStringTag]() {
    return pt.toStringTag;
  }
  get type() {
    return this.node.nodeName;
  }
  get id() {
    return this.node.id;
  }
  set id(e) {
    this.node.id = e;
  }
  constructor(e, t, r) {
    if (!e)
      throw new TypeError("Invalid element to create vector");
    let i;
    if (pt.isVector(e))
      i = e.node;
    else if (typeof e == "string")
      if (e.toLowerCase() === "svg")
        i = vx();
      else if (e[0] === "<") {
        const o = vx(e);
        i = document.importNode(o.firstChild, !0);
      } else
        i = document.createElementNS(Hr.svg, e);
    else
      i = e;
    this.node = i, t && this.setAttributes(t), r && this.append(r);
  }
  transform(e, t) {
    return e == null ? _g(this.node) : (_g(this.node, e, t), this);
  }
  translate(e, t = 0, r = {}) {
    return e == null ? n5(this.node) : (n5(this.node, e, t, r), this);
  }
  rotate(e, t, r, i = {}) {
    return e == null ? $P(this.node) : ($P(this.node, e, t, r, i), this);
  }
  scale(e, t) {
    return e == null ? BP(this.node) : (BP(this.node, e, t), this);
  }
  /**
   * Returns an SVGMatrix that specifies the transformation necessary
   * to convert this coordinate system into `target` coordinate system.
   */
  getTransformToElement(e) {
    const t = pt.toNode(e);
    return yy(this.node, t);
  }
  removeAttribute(e) {
    return hI(this.node, e), this;
  }
  getAttribute(e) {
    return x2e(this.node, e);
  }
  setAttribute(e, t) {
    return fI(this.node, e, t), this;
  }
  setAttributes(e) {
    return Aq(this.node, e), this;
  }
  attr(e, t) {
    return e == null ? Xt(this.node) : typeof e == "string" && t === void 0 ? Xt(this.node, e) : (typeof e == "object" ? Xt(this.node, e) : Xt(this.node, e, t), this);
  }
  svg() {
    return this.node instanceof SVGSVGElement ? this : pt.create(this.node.ownerSVGElement);
  }
  defs() {
    const e = this.svg() || this, t = e.node.getElementsByTagName("defs")[0];
    return t ? pt.create(t) : pt.create("defs").appendTo(e);
  }
  text(e, t = {}) {
    return Eq(this.node, e, t), this;
  }
  tagName() {
    return y2e(this.node);
  }
  clone() {
    return pt.create(this.node.cloneNode(!0));
  }
  remove() {
    return cl(this.node), this;
  }
  empty() {
    return Sb(this.node), this;
  }
  append(e) {
    return sh(this.node, pt.toNodes(e)), this;
  }
  appendTo(e) {
    return vy(this.node, pt.isVector(e) ? e.node : e), this;
  }
  prepend(e) {
    return _q(this.node, pt.toNodes(e)), this;
  }
  before(e) {
    return cI(this.node, pt.toNodes(e)), this;
  }
  replace(e) {
    return this.node.parentNode && this.node.parentNode.replaceChild(pt.toNode(e), this.node), pt.create(e);
  }
  first() {
    return this.node.firstChild ? pt.create(this.node.firstChild) : null;
  }
  last() {
    return this.node.lastChild ? pt.create(this.node.lastChild) : null;
  }
  get(e) {
    const t = this.node.childNodes[e];
    return t ? pt.create(t) : null;
  }
  indexOf(e) {
    return Array.prototype.slice.call(this.node.childNodes).indexOf(pt.toNode(e));
  }
  find(e) {
    const t = [], r = b2e(this.node, e);
    if (r)
      for (let i = 0, o = r.length; i < o; i += 1)
        t.push(pt.create(r[i]));
    return t;
  }
  findOne(e) {
    const t = O2e(this.node, e);
    return t ? pt.create(t) : null;
  }
  findParentByClass(e, t) {
    const r = xq(this.node, e, t);
    return r ? pt.create(r) : null;
  }
  matches(e) {
    const t = this.node;
    this.node.matches;
    const r = t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector || null;
    return r && r.call(t, e);
  }
  contains(e) {
    return Sq(this.node, pt.isVector(e) ? e.node : e);
  }
  wrap(e) {
    const t = pt.create(e), r = this.node.parentNode;
    return r != null && r.insertBefore(t.node, this.node), t.append(this);
  }
  parent(e) {
    let t = this;
    if (t.node.parentNode == null)
      return null;
    if (t = pt.create(t.node.parentNode), e == null)
      return t;
    do
      if (typeof e == "string" ? t.matches(e) : t instanceof e)
        return t;
    while (t = pt.create(t.node.parentNode));
    return t;
  }
  children() {
    const e = this.node.childNodes, t = [];
    for (let r = 0; r < e.length; r += 1)
      e[r].nodeType === 1 && t.push(pt.create(e[r]));
    return t;
  }
  eachChild(e, t) {
    const r = this.children();
    for (let i = 0, o = r.length; i < o; i += 1)
      e.call(r[i], r[i], i, r), t && r[i].eachChild(e, t);
    return this;
  }
  index() {
    return uI(this.node);
  }
  hasClass(e) {
    return mv(this.node, e);
  }
  addClass(e) {
    return lt(this.node, e), this;
  }
  removeClass(e) {
    return br(this.node, e), this;
  }
  toggleClass(e, t) {
    return gy(this.node, e, t), this;
  }
  toLocalPoint(e, t) {
    return eAe(this.node, e, t);
  }
  /**
   * Samples the underlying SVG element (it currently works only on
   * paths - where it is most useful anyway). Returns an array of objects
   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
   * objects represent a point on the path. This basically creates a discrete
   * representation of the path (which is possible a curve). The sampling
   * interval defines the accuracy of the sampling. In other words, we travel
   * from the beginning of the path to the end by interval distance (on the
   * path, not between the resulting points) and collect the discrete points
   * on the path. This is very useful in many situations. For example, SVG
   * does not provide a built-in mechanism to find intersections between two
   * paths. Using sampling, we can just generate bunch of points for each of
   * the path and find the closest ones from each set.
   */
  sample(e = 1) {
    return this.node instanceof SVGPathElement ? B2e(this.node, e) : [];
  }
  toPath() {
    return pt.create(G2e(this.node));
  }
  toPathData() {
    return Iq(this.node);
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(a) {
    if (a == null)
      return !1;
    if (a instanceof n)
      return !0;
    const s = a[Symbol.toStringTag], l = a;
    return (s == null || s === n.toStringTag) && l.node instanceof SVGElement && typeof l.sample == "function" && typeof l.toPath == "function";
  }
  n.isVector = e;
  function t(a, s, l) {
    return new n(a, s, l);
  }
  n.create = t;
  function r(a) {
    if (a[0] === "<") {
      const s = vx(a), l = [];
      for (let u = 0, c = s.childNodes.length; u < c; u += 1) {
        const h = s.childNodes[u];
        l.push(t(document.importNode(h, !0)));
      }
      return l;
    }
    return [t(a)];
  }
  n.createVectors = r;
  function i(a) {
    return e(a) ? a.node : a;
  }
  n.toNode = i;
  function o(a) {
    return Array.isArray(a) ? a.map((s) => i(s)) : [i(a)];
  }
  n.toNodes = o;
})(pt || (pt = {}));
function R2e(n, e) {
  const t = pt.create(e), r = pt.create("textPath"), i = n.d;
  if (i && n["xlink:href"] === void 0) {
    const o = pt.create("path").attr("d", i).appendTo(t.defs());
    r.attr("xlink:href", `#${o.id}`);
  }
  return typeof n == "object" && r.attr(n), r.node;
}
function N2e(n, e, t) {
  const r = t.eol, i = t.baseSize, o = t.lineHeight;
  let a = 0, s;
  const l = {}, u = e.length - 1;
  for (let c = 0; c <= u; c += 1) {
    let h = e[c], f = null;
    if (typeof h == "object") {
      const d = h.attrs, p = pt.create("tspan", d);
      s = p.node;
      let g = h.t;
      r && c === u && (g += r), s.textContent = g;
      const v = d.class;
      v && p.addClass(v), t.includeAnnotationIndices && p.attr("annotations", h.annotations.join(",")), f = parseFloat(d["font-size"]), f === void 0 && (f = i), f && f > a && (a = f);
    } else
      r && c === u && (h += r), s = document.createTextNode(h || " "), i && i > a && (a = i);
    n.appendChild(s);
  }
  return a && (l.maxFontSize = a), o ? l.lineHeight = o : a && (l.lineHeight = a * 1.2), l;
}
const Pq = /em$/;
function y1(n, e) {
  const t = parseFloat(n);
  return Pq.test(n) ? t * e : t;
}
function $2e(n, e, t, r) {
  if (!Array.isArray(e))
    return 0;
  const i = e.length;
  if (!i)
    return 0;
  let o = e[0];
  const a = y1(o.maxFontSize, t) || t;
  let s = 0;
  const l = y1(r, t);
  for (let h = 1; h < i; h += 1) {
    o = e[h];
    const f = y1(o.lineHeight, t) || l;
    s += f;
  }
  const u = y1(o.maxFontSize, t) || t;
  let c;
  switch (n) {
    case "middle":
      c = a / 2 - 0.15 * u - s / 2;
      break;
    case "bottom":
      c = -(0.25 * u) - s;
      break;
    case "top":
    default:
      c = 0.8 * a;
      break;
  }
  return c;
}
function Eq(n, e, t = {}) {
  e = _2e(e);
  const r = t.eol;
  let i = t.textPath;
  const o = t.textVerticalAnchor, a = o === "middle" || o === "bottom" || o === "top";
  let s = t.x;
  s === void 0 && (s = n.getAttribute("x") || 0);
  const l = t.includeAnnotationIndices;
  let u = t.annotations;
  u && !Array.isArray(u) && (u = [u]);
  const c = t.lineHeight, h = c === "auto", f = h ? "1.5em" : c || "1em";
  let d = !0;
  const p = n.childNodes;
  if (p.length === 1) {
    const C = p[0];
    C && C.tagName.toUpperCase() === "TITLE" && (d = !1);
  }
  d && Sb(n), Xt(n, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    "xml:space": "preserve",
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: e || t.displayEmpty ? null : "none"
  });
  const g = Xt(n, "font-size");
  let v = parseFloat(g);
  v || (v = 16, (a || u) && !g && Xt(n, "font-size", `${v}`));
  let m;
  i ? (typeof i == "string" && (i = { d: i }), m = R2e(i, n)) : m = document.createDocumentFragment();
  let y, b = 0, O;
  const w = e.split(`
`), x = [], S = w.length - 1;
  for (let C = 0; C <= S; C += 1) {
    y = f;
    let A = "v-line";
    const k = xs("tspan");
    let P, L = w[C];
    if (L)
      if (u) {
        const D = S2e(L, u, {
          offset: -b,
          includeAnnotationIndices: l
        });
        P = N2e(k, D, {
          eol: C !== S && r,
          baseSize: v,
          lineHeight: h ? null : f,
          includeAnnotationIndices: l
        });
        const E = P.lineHeight;
        E && h && C !== 0 && (y = E), C === 0 && (O = P.maxFontSize * 0.8);
      } else
        r && C !== S && (L += r), k.textContent = L;
    else {
      k.textContent = "-", A += " v-empty-line";
      const D = k.style;
      D.fillOpacity = 0, D.strokeOpacity = 0, u && (P = {});
    }
    P && x.push(P), C > 0 && k.setAttribute("dy", y), (C > 0 || i) && k.setAttribute("x", s), k.className.baseVal = A, m.appendChild(k), b += L.length + 1;
  }
  if (a)
    if (u)
      y = $2e(o, x, v, f);
    else if (o === "top")
      y = "0.8em";
    else {
      let C;
      switch (S > 0 ? (C = parseFloat(f) || 1, C *= S, Pq.test(f) || (C /= v)) : C = 0, o) {
        case "middle":
          y = `${0.3 - C / 2}em`;
          break;
        case "bottom":
          y = `${-C - 0.3}em`;
          break;
      }
    }
  else
    o === 0 ? y = "0em" : o ? y = o : (y = 0, n.getAttribute("y") == null && n.setAttribute("y", `${O || "0.8em"}`));
  m.firstChild.setAttribute("dy", y), n.appendChild(m);
}
function my(n, e = {}) {
  const t = document.createElement("canvas").getContext("2d");
  if (!n)
    return { width: 0 };
  const r = [], i = e["font-size"] ? `${parseFloat(e["font-size"])}px` : "14px";
  return r.push(e["font-style"] || "normal"), r.push(e["font-variant"] || "normal"), r.push(e["font-weight"] || 400), r.push(i), r.push(e["font-family"] || "sans-serif"), t.font = r.join(" "), t.measureText(n);
}
function t5(n, e, t, r = {}) {
  if (e >= t)
    return [n, ""];
  const i = n.length, o = {};
  let a = Math.round(e / t * i - 1);
  for (a < 0 && (a = 0); a >= 0 && a < i; ) {
    const s = n.slice(0, a), l = o[s] || my(s, r).width, u = n.slice(0, a + 1), c = o[u] || my(u, r).width;
    if (o[s] = l, o[u] = c, l > e)
      a -= 1;
    else if (c <= e)
      a += 1;
    else
      break;
  }
  return [n.slice(0, a), n.slice(a)];
}
function Mq(n, e, t = {}, r = {}) {
  const i = e.width, o = e.height, a = r.eol || `
`, s = t.fontSize || 14, l = t.lineHeight ? parseFloat(t.lineHeight) : Math.ceil(s * 1.4), u = Math.floor(o / l);
  if (n.indexOf(a) > -1) {
    const v = gx(), m = [];
    return n.split(a).map((y) => {
      const b = Mq(y, Object.assign(Object.assign({}, e), { height: Number.MAX_SAFE_INTEGER }), t, Object.assign(Object.assign({}, r), { eol: v }));
      b && m.push(...b.split(v));
    }), m.slice(0, u).join(a);
  }
  const { width: c } = my(n, t);
  if (c < i)
    return n;
  const h = [];
  let f = n, d = c, p = r.ellipsis, g = 0;
  p && (typeof p != "string" && (p = "…"), g = my(p, t).width);
  for (let v = 0; v < u; v += 1)
    if (d > i)
      if (v === u - 1) {
        const [y] = t5(f, i - g, d, t);
        h.push(p ? `${y}${p}` : y);
      } else {
        const [y, b] = t5(f, i, d, t);
        h.push(y), f = b, d = my(f, t).width;
      }
    else {
      h.push(f);
      break;
    }
  return h.join(a);
}
const RP = 0.551784;
function oi(n, e, t = NaN) {
  const r = n.getAttribute(e);
  if (r == null)
    return t;
  const i = parseFloat(r);
  return Number.isNaN(i) ? t : i;
}
function B2e(n, e = 1) {
  const t = n.getTotalLength(), r = [];
  let i = 0, o;
  for (; i < t; )
    o = n.getPointAtLength(i), r.push({ distance: i, x: o.x, y: o.y }), i += e;
  return r;
}
function V2e(n) {
  return [
    "M",
    oi(n, "x1"),
    oi(n, "y1"),
    "L",
    oi(n, "x2"),
    oi(n, "y2")
  ].join(" ");
}
function z2e(n) {
  const e = yx(n);
  return e.length === 0 ? null : `${Dq(e)} Z`;
}
function F2e(n) {
  const e = yx(n);
  return e.length === 0 ? null : Dq(e);
}
function Dq(n) {
  return `M ${n.map((t) => `${t.x} ${t.y}`).join(" L")}`;
}
function yx(n) {
  const e = [], t = n.points;
  if (t)
    for (let r = 0, i = t.numberOfItems; r < i; r += 1)
      e.push(t.getItem(r));
  return e;
}
function Q2e(n) {
  const e = oi(n, "cx", 0), t = oi(n, "cy", 0), r = oi(n, "r"), i = r * RP;
  return [
    "M",
    e,
    t - r,
    "C",
    e + i,
    t - r,
    e + r,
    t - i,
    e + r,
    t,
    "C",
    e + r,
    t + i,
    e + i,
    t + r,
    e,
    t + r,
    "C",
    e - i,
    t + r,
    e - r,
    t + i,
    e - r,
    t,
    "C",
    e - r,
    t - i,
    e - i,
    t - r,
    e,
    t - r,
    "Z"
  ].join(" ");
}
function Z2e(n) {
  const e = oi(n, "cx", 0), t = oi(n, "cy", 0), r = oi(n, "rx"), i = oi(n, "ry") || r, o = r * RP, a = i * RP;
  return [
    "M",
    e,
    t - i,
    "C",
    e + o,
    t - i,
    e + r,
    t - a,
    e + r,
    t,
    "C",
    e + r,
    t + a,
    e + o,
    t + i,
    e,
    t + i,
    "C",
    e - o,
    t + i,
    e - r,
    t + a,
    e - r,
    t,
    "C",
    e - r,
    t - a,
    e - o,
    t - i,
    e,
    t - i,
    "Z"
  ].join(" ");
}
function W2e(n) {
  return Lq({
    x: oi(n, "x", 0),
    y: oi(n, "y", 0),
    width: oi(n, "width", 0),
    height: oi(n, "height", 0),
    rx: oi(n, "rx", 0),
    ry: oi(n, "ry", 0)
  });
}
function Lq(n) {
  let e;
  const t = n.x, r = n.y, i = n.width, o = n.height, a = Math.min(n.rx || n["top-rx"] || 0, i / 2), s = Math.min(n.rx || n["bottom-rx"] || 0, i / 2), l = Math.min(n.ry || n["top-ry"] || 0, o / 2), u = Math.min(n.ry || n["bottom-ry"] || 0, o / 2);
  return a || s || l || u ? e = [
    "M",
    t,
    r + l,
    "v",
    o - l - u,
    "a",
    s,
    u,
    0,
    0,
    0,
    s,
    u,
    "h",
    i - 2 * s,
    "a",
    s,
    u,
    0,
    0,
    0,
    s,
    -u,
    "v",
    -(o - u - l),
    "a",
    a,
    l,
    0,
    0,
    0,
    -a,
    -l,
    "h",
    -(i - 2 * a),
    "a",
    a,
    l,
    0,
    0,
    0,
    -a,
    l,
    "Z"
  ] : e = ["M", t, r, "H", t + i, "V", r + o, "H", t, "V", r, "Z"], e.join(" ");
}
function G2e(n) {
  const e = xs("path");
  Xt(e, Xt(n));
  const t = Iq(n);
  return t && e.setAttribute("d", t), e;
}
function Iq(n) {
  const e = n.tagName.toLowerCase();
  switch (e) {
    case "path":
      return n.getAttribute("d");
    case "line":
      return V2e(n);
    case "polygon":
      return z2e(n);
    case "polyline":
      return F2e(n);
    case "ellipse":
      return Z2e(n);
    case "circle":
      return Q2e(n);
    case "rect":
      return W2e(n);
  }
  throw new Error(`"${e}" cannot be converted to svg path element.`);
}
const j2e = /(\w+)\(([^,)]+),?([^)]+)?\)/gi, Rq = /[ ,]+/, H2e = /^(\w+)\((.*)\)/;
function q2e(n, e) {
  const r = xs("svg").createSVGPoint();
  return r.x = n, r.y = e, r;
}
function Xr(n) {
  const t = xs("svg").createSVGMatrix();
  if (n != null) {
    const r = n, i = t;
    for (const o in r)
      i[o] = r[o];
  }
  return t;
}
function Nm(n) {
  const e = xs("svg");
  return n != null ? (n instanceof DOMMatrix || (n = Xr(n)), e.createSVGTransformFromMatrix(n)) : e.createSVGTransform();
}
function o0(n) {
  let e = Xr();
  const t = n != null && n.match(j2e);
  if (!t)
    return e;
  for (let r = 0, i = t.length; r < i; r += 1) {
    const a = t[r].match(H2e);
    if (a) {
      let s, l, u, c, h, f = Xr();
      const d = a[2].split(Rq);
      switch (a[1].toLowerCase()) {
        case "scale":
          s = parseFloat(d[0]), l = d[1] === void 0 ? s : parseFloat(d[1]), f = f.scaleNonUniform(s, l);
          break;
        case "translate":
          u = parseFloat(d[0]), c = parseFloat(d[1]), f = f.translate(u, c);
          break;
        case "rotate":
          h = parseFloat(d[0]), u = parseFloat(d[1]) || 0, c = parseFloat(d[2]) || 0, u !== 0 || c !== 0 ? f = f.translate(u, c).rotate(h).translate(-u, -c) : f = f.rotate(h);
          break;
        case "skewx":
          h = parseFloat(d[0]), f = f.skewX(h);
          break;
        case "skewy":
          h = parseFloat(d[0]), f = f.skewY(h);
          break;
        case "matrix":
          f.a = parseFloat(d[0]), f.b = parseFloat(d[1]), f.c = parseFloat(d[2]), f.d = parseFloat(d[3]), f.e = parseFloat(d[4]), f.f = parseFloat(d[5]);
          break;
        default:
          continue;
      }
      e = e.multiply(f);
    }
  }
  return e;
}
function yv(n) {
  const e = n || {}, t = e.a != null ? e.a : 1, r = e.b != null ? e.b : 0, i = e.c != null ? e.c : 0, o = e.d != null ? e.d : 1, a = e.e != null ? e.e : 0, s = e.f != null ? e.f : 0;
  return `matrix(${t},${r},${i},${o},${a},${s})`;
}
function A_(n) {
  let e, t, r;
  if (n) {
    const o = Rq;
    if (n.trim().indexOf("matrix") >= 0) {
      const a = o0(n), s = Y2e(a);
      e = [s.translateX, s.translateY], t = [s.rotation], r = [s.scaleX, s.scaleY];
      const l = [];
      (e[0] !== 0 || e[1] !== 0) && l.push(`translate(${e.join(",")})`), (r[0] !== 1 || r[1] !== 1) && l.push(`scale(${r.join(",")})`), t[0] !== 0 && l.push(`rotate(${t[0]})`), n = l.join(" ");
    } else {
      const a = n.match(/translate\((.*?)\)/);
      a && (e = a[1].split(o));
      const s = n.match(/rotate\((.*?)\)/);
      s && (t = s[1].split(o));
      const l = n.match(/scale\((.*?)\)/);
      l && (r = l[1].split(o));
    }
  }
  const i = r && r[0] ? parseFloat(r[0]) : 1;
  return {
    raw: n || "",
    translation: {
      tx: e && e[0] ? parseInt(e[0], 10) : 0,
      ty: e && e[1] ? parseInt(e[1], 10) : 0
    },
    rotation: {
      angle: t && t[0] ? parseInt(t[0], 10) : 0,
      cx: t && t[1] ? parseInt(t[1], 10) : void 0,
      cy: t && t[2] ? parseInt(t[2], 10) : void 0
    },
    scale: {
      sx: i,
      sy: r && r[1] ? parseFloat(r[1]) : i
    }
  };
}
function NP(n, e) {
  const t = e.x * n.a + e.y * n.c + 0, r = e.x * n.b + e.y * n.d + 0;
  return { x: t, y: r };
}
function Y2e(n) {
  const e = NP(n, { x: 0, y: 1 }), t = NP(n, { x: 1, y: 0 }), r = 180 / Math.PI * Math.atan2(e.y, e.x) - 90, i = 180 / Math.PI * Math.atan2(t.y, t.x);
  return {
    skewX: r,
    skewY: i,
    translateX: n.e,
    translateY: n.f,
    scaleX: Math.sqrt(n.a * n.a + n.b * n.b),
    scaleY: Math.sqrt(n.c * n.c + n.d * n.d),
    rotation: r
  };
}
function X2e(n) {
  let e, t, r, i;
  return n ? (e = n.a == null ? 1 : n.a, i = n.d == null ? 1 : n.d, t = n.b, r = n.c) : e = i = 1, {
    sx: t ? Math.sqrt(e * e + t * t) : e,
    sy: r ? Math.sqrt(r * r + i * i) : i
  };
}
function U2e(n) {
  let e = { x: 0, y: 1 };
  n && (e = NP(n, e));
  const t = 180 * Math.atan2(e.y, e.x) / Math.PI % 360 - 90;
  return {
    angle: t % 360 + (t < 0 ? 360 : 0)
  };
}
function K2e(n) {
  return {
    tx: n && n.e || 0,
    ty: n && n.f || 0
  };
}
function _g(n, e, t = {}) {
  if (e == null)
    return o0(Xt(n, "transform"));
  if (t.absolute) {
    n.setAttribute("transform", yv(e));
    return;
  }
  const r = n.transform, i = Nm(e);
  r.baseVal.appendItem(i);
}
function n5(n, e, t = 0, r = {}) {
  let i = Xt(n, "transform");
  const o = A_(i);
  if (e == null)
    return o.translation;
  i = o.raw, i = i.replace(/translate\([^)]*\)/g, "").trim();
  const a = r.absolute ? e : o.translation.tx + e, s = r.absolute ? t : o.translation.ty + t, l = `translate(${a},${s})`;
  n.setAttribute("transform", `${l} ${i}`.trim());
}
function $P(n, e, t, r, i = {}) {
  let o = Xt(n, "transform");
  const a = A_(o);
  if (e == null)
    return a.rotation;
  o = a.raw, o = o.replace(/rotate\([^)]*\)/g, "").trim(), e %= 360;
  const s = i.absolute ? e : a.rotation.angle + e, l = t != null && r != null ? `,${t},${r}` : "", u = `rotate(${s}${l})`;
  n.setAttribute("transform", `${o} ${u}`.trim());
}
function BP(n, e, t) {
  let r = Xt(n, "transform");
  const i = A_(r);
  if (e == null)
    return i.scale;
  t = t ?? e, r = i.raw, r = r.replace(/scale\([^)]*\)/g, "").trim();
  const o = `scale(${e},${t})`;
  n.setAttribute("transform", `${r} ${o}`.trim());
}
function yy(n, e) {
  if (Dc(e) && Dc(n)) {
    const t = e.getScreenCTM(), r = n.getScreenCTM();
    if (t && r)
      return t.inverse().multiply(r);
  }
  return Xr();
}
function J2e(n, e) {
  let t = Xr();
  if (Dc(e) && Dc(n)) {
    let r = n;
    const i = [];
    for (; r && r !== e; ) {
      const o = r.getAttribute("transform") || null, a = o0(o);
      i.push(a), r = r.parentNode;
    }
    i.reverse().forEach((o) => {
      t = t.multiply(o);
    });
  }
  return t;
}
function eAe(n, e, t) {
  const r = n instanceof SVGSVGElement ? n : n.ownerSVGElement, i = r.createSVGPoint();
  i.x = e, i.y = t;
  try {
    const o = r.getScreenCTM(), a = i.matrixTransform(o.inverse()), s = yy(n, r).inverse();
    return a.matrixTransform(s);
  } catch {
    return i;
  }
}
var fa;
(function(n) {
  const e = {};
  function t(o) {
    return e[o] || {};
  }
  n.get = t;
  function r(o, a) {
    e[o] = a;
  }
  n.register = r;
  function i(o) {
    delete e[o];
  }
  n.unregister = i;
})(fa || (fa = {}));
var gf;
(function(n) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(o) {
    return e.has(o) || e.set(o, { events: /* @__PURE__ */ Object.create(null) }), e.get(o);
  }
  n.ensure = t;
  function r(o) {
    return e.get(o);
  }
  n.get = r;
  function i(o) {
    return e.delete(o);
  }
  n.remove = i;
})(gf || (gf = {}));
var St;
(function(n) {
  n.returnTrue = () => !0, n.returnFalse = () => !1;
  function e(i) {
    i.stopPropagation();
  }
  n.stopPropagationCallback = e;
  function t(i, o, a) {
    i.addEventListener != null && i.addEventListener(o, a);
  }
  n.addEventListener = t;
  function r(i, o, a) {
    i.removeEventListener != null && i.removeEventListener(o, a);
  }
  n.removeEventListener = r;
})(St || (St = {}));
(function(n) {
  const e = /[^\x20\t\r\n\f]+/g, t = /^([^.]*)(?:\.(.+)|)/;
  function r(s) {
    return (s || "").match(e) || [""];
  }
  n.splitType = r;
  function i(s) {
    const l = t.exec(s) || [];
    return {
      originType: l[1] ? l[1].trim() : l[1],
      namespaces: l[2] ? l[2].split(".").map((u) => u.trim()).sort() : []
    };
  }
  n.normalizeType = i;
  function o(s) {
    return s.nodeType === 1 || s.nodeType === 9 || !+s.nodeType;
  }
  n.isValidTarget = o;
  function a(s, l) {
    if (l) {
      const u = s;
      return u.querySelector != null && u.querySelector(l) != null;
    }
    return !0;
  }
  n.isValidSelector = a;
})(St || (St = {}));
(function(n) {
  let e = 0;
  const t = /* @__PURE__ */ new WeakMap();
  function r(s) {
    return t.has(s) || (t.set(s, e), e += 1), t.get(s);
  }
  n.ensureHandlerId = r;
  function i(s) {
    return t.get(s);
  }
  n.getHandlerId = i;
  function o(s) {
    return t.delete(s);
  }
  n.removeHandlerId = o;
  function a(s, l) {
    return t.set(s, l);
  }
  n.setHandlerId = a;
})(St || (St = {}));
(function(n) {
  function e(t, r) {
    const i = [], o = gf.get(t), a = o && o.events && o.events[r.type], s = a && a.handlers || [], l = a ? a.delegateCount : 0;
    if (l > 0 && // Support: Firefox <=42 - 66+
    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    // Support: IE 11+
    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    !(r.type === "click" && typeof r.button == "number" && r.button >= 1)) {
      for (let u = r.target; u !== t; u = u.parentNode || t)
        if (u.nodeType === 1 && !(r.type === "click" && u.disabled === !0)) {
          const c = [], h = {};
          for (let f = 0; f < l; f += 1) {
            const d = s[f], p = d.selector;
            if (p != null && h[p] == null) {
              const g = t, v = [];
              g.querySelectorAll(p).forEach((m) => {
                v.push(m);
              }), h[p] = v.includes(u);
            }
            h[p] && c.push(d);
          }
          c.length && i.push({ elem: u, handlers: c });
        }
    }
    return l < s.length && i.push({ elem: t, handlers: s.slice(l) }), i;
  }
  n.getHandlerQueue = e;
})(St || (St = {}));
(function(n) {
  function e(t) {
    return t != null && t === t.window;
  }
  n.isWindow = e;
})(St || (St = {}));
(function(n) {
  function e(t, r) {
    const i = t.nodeType === 9 ? t.documentElement : t, o = r && r.parentNode;
    return t === o || !!(o && o.nodeType === 1 && // Support: IE 9 - 11+
    // IE doesn't have `contains` on SVG.
    (i.contains ? i.contains(o) : t.compareDocumentPosition && t.compareDocumentPosition(o) & 16));
  }
  n.contains = e;
})(St || (St = {}));
class hl {
  constructor(e, t) {
    this.isDefaultPrevented = St.returnFalse, this.isPropagationStopped = St.returnFalse, this.isImmediatePropagationStopped = St.returnFalse, this.isSimulated = !1, this.preventDefault = () => {
      const r = this.originalEvent;
      this.isDefaultPrevented = St.returnTrue, r && !this.isSimulated && r.preventDefault();
    }, this.stopPropagation = () => {
      const r = this.originalEvent;
      this.isPropagationStopped = St.returnTrue, r && !this.isSimulated && r.stopPropagation();
    }, this.stopImmediatePropagation = () => {
      const r = this.originalEvent;
      this.isImmediatePropagationStopped = St.returnTrue, r && !this.isSimulated && r.stopImmediatePropagation(), this.stopPropagation();
    }, typeof e == "string" ? this.type = e : e.type && (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? St.returnTrue : St.returnFalse, this.target = e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget, this.timeStamp = e.timeStamp), t && Object.assign(this, t), this.timeStamp || (this.timeStamp = Date.now());
  }
}
(function(n) {
  function e(t) {
    return t instanceof n ? t : new n(t);
  }
  n.create = e;
})(hl || (hl = {}));
(function(n) {
  function e(t, r) {
    Object.defineProperty(n.prototype, t, {
      enumerable: !0,
      configurable: !0,
      get: typeof r == "function" ? (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return r(this.originalEvent);
        }
      ) : (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return this.originalEvent[t];
        }
      ),
      set(i) {
        Object.defineProperty(this, t, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: i
        });
      }
    });
  }
  n.addProperty = e;
})(hl || (hl = {}));
(function(n) {
  const e = {
    bubbles: !0,
    cancelable: !0,
    eventPhase: !0,
    detail: !0,
    view: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pageX: !0,
    pageY: !0,
    screenX: !0,
    screenY: !0,
    toElement: !0,
    pointerId: !0,
    pointerType: !0,
    char: !0,
    code: !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    touches: !0,
    changedTouches: !0,
    targetTouches: !0,
    which: !0,
    altKey: !0,
    ctrlKey: !0,
    metaKey: !0,
    shiftKey: !0
  };
  Object.keys(e).forEach((t) => n.addProperty(t, e[t]));
})(hl || (hl = {}));
(function(n) {
  fa.register("load", {
    noBubble: !0
  });
})();
(function(n) {
  fa.register("beforeunload", {
    postDispatch(e, t) {
      t.result !== void 0 && t.originalEvent && (t.originalEvent.returnValue = t.result);
    }
  });
})();
(function(n) {
  fa.register("mouseenter", {
    delegateType: "mouseover",
    bindType: "mouseover",
    handle(e, t) {
      let r;
      const i = t.relatedTarget, o = t.handleObj;
      return (!i || i !== e && !St.contains(e, i)) && (t.type = o.originType, r = o.handler.call(e, t), t.type = "mouseover"), r;
    }
  }), fa.register("mouseleave", {
    delegateType: "mouseout",
    bindType: "mouseout",
    handle(e, t) {
      let r;
      const i = t.relatedTarget, o = t.handleObj;
      return (!i || i !== e && !St.contains(e, i)) && (t.type = o.originType, r = o.handler.call(e, t), t.type = "mouseout"), r;
    }
  });
})();
var tAe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
}, a0;
(function(n) {
  let e;
  function t(a, s, l, u, c) {
    if (!St.isValidTarget(a))
      return;
    let h;
    if (typeof l != "function") {
      const { handler: g, selector: v } = l, m = tAe(l, ["handler", "selector"]);
      l = g, c = v, h = m;
    }
    const f = gf.ensure(a);
    let d = f.handler;
    d == null && (d = f.handler = function(g, ...v) {
      return e !== g.type ? i(a, g, ...v) : void 0;
    });
    const p = St.ensureHandlerId(l);
    St.splitType(s).forEach((g) => {
      const { originType: v, namespaces: m } = St.normalizeType(g);
      if (!v)
        return;
      let y = v, b = fa.get(y);
      y = (c ? b.delegateType : b.bindType) || y, b = fa.get(y);
      const O = Object.assign({
        type: y,
        originType: v,
        data: u,
        selector: c,
        guid: p,
        handler: l,
        namespace: m.join(".")
      }, h), w = f.events;
      let x = w[y];
      x || (x = w[y] = { handlers: [], delegateCount: 0 }, (!b.setup || b.setup(a, u, m, d) === !1) && St.addEventListener(a, y, d)), b.add && (St.removeHandlerId(O.handler), b.add(a, O), St.setHandlerId(O.handler, p)), c ? (x.handlers.splice(x.delegateCount, 0, O), x.delegateCount += 1) : x.handlers.push(O);
    });
  }
  n.on = t;
  function r(a, s, l, u, c) {
    const h = gf.get(a);
    if (!h)
      return;
    const f = h.events;
    f && (St.splitType(s).forEach((d) => {
      const { originType: p, namespaces: g } = St.normalizeType(d);
      if (!p) {
        Object.keys(f).forEach((w) => {
          r(a, w + d, l, u, !0);
        });
        return;
      }
      let v = p;
      const m = fa.get(v);
      v = (u ? m.delegateType : m.bindType) || v;
      const y = f[v];
      if (!y)
        return;
      const b = g.length > 0 ? new RegExp(`(^|\\.)${g.join("\\.(?:.*\\.|)")}(\\.|$)`) : null, O = y.handlers.length;
      for (let w = y.handlers.length - 1; w >= 0; w -= 1) {
        const x = y.handlers[w];
        (c || p === x.originType) && (!l || St.getHandlerId(l) === x.guid) && (b == null || x.namespace && b.test(x.namespace)) && (u == null || u === x.selector || u === "**" && x.selector) && (y.handlers.splice(w, 1), x.selector && (y.delegateCount -= 1), m.remove && m.remove(a, x));
      }
      O && y.handlers.length === 0 && ((!m.teardown || m.teardown(a, g, h.handler) === !1) && St.removeEventListener(a, v, h.handler), delete f[v]);
    }), Object.keys(f).length === 0 && gf.remove(a));
  }
  n.off = r;
  function i(a, s, ...l) {
    const u = hl.create(s);
    u.delegateTarget = a;
    const c = fa.get(u.type);
    if (c.preDispatch && c.preDispatch(a, u) === !1)
      return;
    const h = St.getHandlerQueue(a, u);
    for (let f = 0, d = h.length; f < d && !u.isPropagationStopped(); f += 1) {
      const p = h[f];
      u.currentTarget = p.elem;
      for (let g = 0, v = p.handlers.length; g < v && !u.isImmediatePropagationStopped(); g += 1) {
        const m = p.handlers[g];
        if (u.rnamespace == null || m.namespace && u.rnamespace.test(m.namespace)) {
          u.handleObj = m, u.data = m.data;
          const y = fa.get(m.originType).handle, b = y ? y(p.elem, u, ...l) : m.handler.call(p.elem, u, ...l);
          b !== void 0 && (u.result = b, b === !1 && (u.preventDefault(), u.stopPropagation()));
        }
      }
    }
    return c.postDispatch && c.postDispatch(a, u), u.result;
  }
  n.dispatch = i;
  function o(a, s, l, u) {
    let c = a, h = typeof a == "string" ? a : a.type, f = typeof a == "string" || c.namespace == null ? [] : c.namespace.split(".");
    const d = l;
    if (d.nodeType === 3 || d.nodeType === 8)
      return;
    h.indexOf(".") > -1 && (f = h.split("."), h = f.shift(), f.sort());
    const p = h.indexOf(":") < 0 && `on${h}`;
    c = a instanceof hl ? a : new hl(h, typeof a == "object" ? a : null), c.namespace = f.join("."), c.rnamespace = c.namespace ? new RegExp(`(^|\\.)${f.join("\\.(?:.*\\.|)")}(\\.|$)`) : null, c.result = void 0, c.target || (c.target = d);
    const g = [c];
    Array.isArray(s) ? g.push(...s) : g.push(s);
    const v = fa.get(h);
    if (!u && v.trigger && v.trigger(d, c, s) === !1)
      return;
    let m;
    const y = [d];
    if (!u && !v.noBubble && !St.isWindow(d)) {
      m = v.delegateType || h;
      let O = d, w = d.parentNode;
      for (; w != null; )
        y.push(w), O = w, w = w.parentNode;
      const x = d.ownerDocument || document;
      if (O === x) {
        const S = O.defaultView || O.parentWindow || window;
        y.push(S);
      }
    }
    let b = d;
    for (let O = 0, w = y.length; O < w && !c.isPropagationStopped(); O += 1) {
      const x = y[O];
      b = x, c.type = O > 1 ? m : v.bindType || h;
      const S = gf.get(x);
      S && S.events[c.type] && S.handler && S.handler.call(x, ...g);
      const _ = p && x[p] || null;
      _ && St.isValidTarget(x) && (c.result = _.call(x, ...g), c.result === !1 && c.preventDefault());
    }
    if (c.type = h, !u && !c.isDefaultPrevented()) {
      const O = v.preventDefault;
      if ((O == null || O(y.pop(), c, s) === !1) && St.isValidTarget(d) && p && typeof d[h] == "function" && !St.isWindow(d)) {
        const w = d[p];
        w && (d[p] = null), e = h, c.isPropagationStopped() && b.addEventListener(h, St.stopPropagationCallback), d[h](), c.isPropagationStopped() && b.removeEventListener(h, St.stopPropagationCallback), e = void 0, w && (d[p] = w);
      }
    }
    return c.result;
  }
  n.trigger = o;
})(a0 || (a0 = {}));
var ii;
(function(n) {
  function e(o, a, s, l, u) {
    return by.on(o, a, s, l, u), o;
  }
  n.on = e;
  function t(o, a, s, l, u) {
    return by.on(o, a, s, l, u, !0), o;
  }
  n.once = t;
  function r(o, a, s, l) {
    return by.off(o, a, s, l), o;
  }
  n.off = r;
  function i(o, a, s, l) {
    return a0.trigger(a, s, o, l), o;
  }
  n.trigger = i;
})(ii || (ii = {}));
var by;
(function(n) {
  function e(r, i, o, a, s, l) {
    if (typeof i == "object") {
      typeof o != "string" && (a = a || o, o = void 0), Object.keys(i).forEach((u) => e(r, u, o, a, i[u], l));
      return;
    }
    if (a == null && s == null ? (s = o, a = o = void 0) : s == null && (typeof o == "string" ? (s = a, a = void 0) : (s = a, a = o, o = void 0)), s === !1)
      s = St.returnFalse;
    else if (!s)
      return;
    if (l) {
      const u = s;
      s = function(c, ...h) {
        return n.off(r, c), u.call(this, c, ...h);
      }, St.setHandlerId(s, St.ensureHandlerId(u));
    }
    a0.on(r, i, s, a, o);
  }
  n.on = e;
  function t(r, i, o, a) {
    const s = i;
    if (s && s.preventDefault != null && s.handleObj != null) {
      const l = s.handleObj;
      t(s.delegateTarget, l.namespace ? `${l.originType}.${l.namespace}` : l.originType, l.selector, l.handler);
      return;
    }
    if (typeof i == "object") {
      const l = i;
      Object.keys(l).forEach((u) => t(r, u, o, l[u]));
      return;
    }
    (o === !1 || typeof o == "function") && (a = o, o = void 0), a === !1 && (a = St.returnFalse), a0.off(r, i, a, o);
  }
  n.off = t;
})(by || (by = {}));
class Nq {
  constructor(e, t, r) {
    this.animationFrameId = 0, this.deltaX = 0, this.deltaY = 0, this.eventName = Mc.isEventSupported("wheel") ? "wheel" : "mousewheel", this.target = e, this.onWheelCallback = t, this.onWheelGuard = r, this.onWheel = this.onWheel.bind(this), this.didWheel = this.didWheel.bind(this);
  }
  enable() {
    this.target.addEventListener(this.eventName, this.onWheel, {
      passive: !1
    });
  }
  disable() {
    this.target.removeEventListener(this.eventName, this.onWheel);
  }
  onWheel(e) {
    if (this.onWheelGuard != null && !this.onWheelGuard(e))
      return;
    this.deltaX += e.deltaX, this.deltaY += e.deltaY, e.preventDefault();
    let t;
    (this.deltaX !== 0 || this.deltaY !== 0) && (e.stopPropagation(), t = !0), t === !0 && this.animationFrameId === 0 && (this.animationFrameId = requestAnimationFrame(() => {
      this.didWheel(e);
    }));
  }
  didWheel(e) {
    this.animationFrameId = 0, this.onWheelCallback(e, this.deltaX, this.deltaY), this.deltaX = 0, this.deltaY = 0;
  }
}
function VP(n) {
  const e = n.getBoundingClientRect(), t = n.ownerDocument.defaultView;
  return {
    top: e.top + t.pageYOffset,
    left: e.left + t.pageXOffset
  };
}
function nAe(n) {
  return n.getBoundingClientRect().width;
}
function rAe(n) {
  return n.getBoundingClientRect().height;
}
function $q(n, e = 60) {
  let t = null;
  return (...r) => {
    t && clearTimeout(t), t = window.setTimeout(() => {
      n.apply(this, r);
    }, e);
  };
}
function iAe(n) {
  let e = null, t = [];
  const r = () => {
    if (getComputedStyle(n).position === "static") {
      const u = n.style;
      u.position = "relative";
    }
    const l = document.createElement("object");
    return l.onload = () => {
      l.contentDocument.defaultView.addEventListener("resize", i), i();
    }, l.style.display = "block", l.style.position = "absolute", l.style.top = "0", l.style.left = "0", l.style.height = "100%", l.style.width = "100%", l.style.overflow = "hidden", l.style.pointerEvents = "none", l.style.zIndex = "-1", l.style.opacity = "0", l.setAttribute("tabindex", "-1"), l.type = "text/html", n.appendChild(l), l.data = "about:blank", l;
  }, i = $q(() => {
    t.forEach((l) => l(n));
  }), o = (l) => {
    e || (e = r()), t.indexOf(l) === -1 && t.push(l);
  }, a = () => {
    e && e.parentNode && (e.contentDocument && e.contentDocument.defaultView.removeEventListener("resize", i), e.parentNode.removeChild(e), e = null, t = []);
  };
  return {
    element: n,
    bind: o,
    destroy: a,
    unbind: (l) => {
      const u = t.indexOf(l);
      u !== -1 && t.splice(u, 1), t.length === 0 && e && a();
    }
  };
}
function oAe(n) {
  let e = null, t = [];
  const r = $q(() => {
    t.forEach((l) => {
      l(n);
    });
  }), i = () => {
    const l = new ResizeObserver(r);
    return l.observe(n), r(), l;
  }, o = (l) => {
    e || (e = i()), t.indexOf(l) === -1 && t.push(l);
  }, a = () => {
    e && (e.disconnect(), t = [], e = null);
  };
  return {
    element: n,
    bind: o,
    destroy: a,
    unbind: (l) => {
      const u = t.indexOf(l);
      u !== -1 && t.splice(u, 1), t.length === 0 && e && a();
    }
  };
}
const aAe = typeof ResizeObserver < "u" ? oAe : iAe;
var bx;
(function(n) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(i) {
    let o = e.get(i);
    return o || (o = aAe(i), e.set(i, o), o);
  }
  function r(i) {
    i.destroy(), e.delete(i.element);
  }
  n.bind = (i, o) => {
    const a = t(i);
    return a.bind(o), () => a.unbind(o);
  }, n.clear = (i) => {
    const o = t(i);
    r(o);
  };
})(bx || (bx = {}));
class s0 {
  constructor(e = {}) {
    this.comparator = e.comparator || s0.defaultComparator, this.index = {}, this.data = e.data || [], this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */
  isEmpty() {
    return this.data.length === 0;
  }
  /**
   * Inserts a value with priority to the queue. Optionally pass a unique
   * id of this item. Passing unique IDs for each item you insert allows
   * you to use the `updatePriority()` operation.
   * @param priority
   * @param value
   * @param id
   */
  insert(e, t, r) {
    const i = { priority: e, value: t }, o = this.data.length;
    return r && (i.id = r, this.index[r] = o), this.data.push(i), this.bubbleUp(o), this;
  }
  /**
   * Returns the value of an item with the highest priority.
   */
  peek() {
    return this.data[0] ? this.data[0].value : null;
  }
  /**
   * Returns the highest priority in the queue.
   */
  peekPriority() {
    return this.data[0] ? this.data[0].priority : null;
  }
  updatePriority(e, t) {
    const r = this.index[e];
    if (typeof r > "u")
      throw new Error(`Node with id '${e}' was not found in the heap.`);
    const i = this.data, o = i[r].priority, a = this.comparator(t, o);
    a < 0 ? (i[r].priority = t, this.bubbleUp(r)) : a > 0 && (i[r].priority = t, this.bubbleDown(r));
  }
  /**
   * Removes the item with the highest priority from the queue
   *
   * @returns The value of the removed item.
   */
  remove() {
    const e = this.data, t = e[0], r = e.pop();
    return t.id && delete this.index[t.id], e.length > 0 && (e[0] = r, r.id && (this.index[r.id] = 0), this.bubbleDown(0)), t ? t.value : null;
  }
  heapify() {
    for (let e = 0; e < this.data.length; e += 1)
      this.bubbleUp(e);
  }
  bubbleUp(e) {
    const t = this.data;
    let r, i, o = e;
    for (; o > 0 && (i = o - 1 >>> 1, this.comparator(t[o].priority, t[i].priority) < 0); ) {
      r = t[i], t[i] = t[o];
      let a = t[o].id;
      a != null && (this.index[a] = i), t[o] = r, a = t[o].id, a != null && (this.index[a] = o), o = i;
    }
  }
  bubbleDown(e) {
    const t = this.data, r = t.length - 1;
    let i = e;
    for (; ; ) {
      const o = (i << 1) + 1, a = o + 1;
      let s = i;
      if (o <= r && this.comparator(t[o].priority, t[s].priority) < 0 && (s = o), a <= r && this.comparator(t[a].priority, t[s].priority) < 0 && (s = a), s !== i) {
        const l = t[s];
        t[s] = t[i];
        let u = t[i].id;
        u != null && (this.index[u] = s), t[i] = l, u = t[i].id, u != null && (this.index[u] = i), i = s;
      } else
        break;
    }
  }
}
(function(n) {
  n.defaultComparator = (e, t) => e - t;
})(s0 || (s0 = {}));
var zP;
(function(n) {
  function e(t, r, i = (o, a) => 1) {
    const o = {}, a = {}, s = {}, l = new s0();
    for (o[r] = 0, Object.keys(t).forEach((u) => {
      u !== r && (o[u] = 1 / 0), l.insert(o[u], u, u);
    }); !l.isEmpty(); ) {
      const u = l.remove();
      s[u] = !0;
      const c = t[u] || [];
      for (let h = 0; h < c.length; h += 1) {
        const f = c[h];
        if (!s[f]) {
          const d = o[u] + i(u, f);
          d < o[f] && (o[f] = d, a[f] = u, l.updatePriority(f, d));
        }
      }
    }
    return a;
  }
  n.run = e;
})(zP || (zP = {}));
class ql {
  constructor(e, t, r, i) {
    if (e == null)
      return this.set(255, 255, 255, 1);
    if (typeof e == "number")
      return this.set(e, t, r, i);
    if (typeof e == "string")
      return ql.fromString(e) || this;
    if (Array.isArray(e))
      return this.set(e);
    this.set(e.r, e.g, e.b, e.a == null ? 1 : e.a);
  }
  blend(e, t, r) {
    this.set(e.r + (t.r - e.r) * r, e.g + (t.g - e.g) * r, e.b + (t.b - e.b) * r, e.a + (t.a - e.a) * r);
  }
  lighten(e) {
    const t = ql.lighten(this.toArray(), e);
    this.r = t[0], this.g = t[1], this.b = t[2], this.a = t[3];
  }
  darken(e) {
    this.lighten(-e);
  }
  set(e, t, r, i) {
    const o = Array.isArray(e) ? e[0] : e, a = Array.isArray(e) ? e[1] : t, s = Array.isArray(e) ? e[2] : r, l = Array.isArray(e) ? e[3] : i;
    return this.r = Math.round(wo(o, 0, 255)), this.g = Math.round(wo(a, 0, 255)), this.b = Math.round(wo(s, 0, 255)), this.a = l == null ? 1 : wo(l, 0, 1), this;
  }
  toHex() {
    return `#${["r", "g", "b"].map((t) => {
      const r = this[t].toString(16);
      return r.length < 2 ? `0${r}` : r;
    }).join("")}`;
  }
  toRGBA() {
    return this.toArray();
  }
  toHSLA() {
    return ql.rgba2hsla(this.r, this.g, this.b, this.a);
  }
  toCSS(e) {
    const t = `${this.r},${this.g},${this.b},`;
    return e ? `rgb(${t})` : `rgba(${t},${this.a})`;
  }
  toGrey() {
    return ql.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toString() {
    return this.toCSS();
  }
}
(function(n) {
  function e(b) {
    return new n(b);
  }
  n.fromArray = e;
  function t(b) {
    return new n([...p(b), 1]);
  }
  n.fromHex = t;
  function r(b) {
    const O = b.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
    if (O) {
      const w = O[1].split(/\s*,\s*/).map((x) => parseInt(x, 10));
      return new n(w);
    }
    return null;
  }
  n.fromRGBA = r;
  function i(b, O, w) {
    w < 0 && ++w, w > 1 && --w;
    const x = 6 * w;
    return x < 1 ? b + (O - b) * x : 2 * w < 1 ? O : 3 * w < 2 ? b + (O - b) * (2 / 3 - w) * 6 : b;
  }
  function o(b) {
    const O = b.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
    if (O) {
      const w = O[2].split(/\s*,\s*/), x = (parseFloat(w[0]) % 360 + 360) % 360 / 360, S = parseFloat(w[1]) / 100, _ = parseFloat(w[2]) / 100, C = w[3] == null ? 1 : parseInt(w[3], 10);
      return new n(u(x, S, _, C));
    }
    return null;
  }
  n.fromHSLA = o;
  function a(b) {
    if (b.startsWith("#"))
      return t(b);
    if (b.startsWith("rgb"))
      return r(b);
    const O = n.named[b];
    return O ? t(O) : o(b);
  }
  n.fromString = a;
  function s(b, O) {
    return n.fromArray([b, b, b, O]);
  }
  n.makeGrey = s;
  function l(b, O, w, x) {
    const S = Array.isArray(b) ? b[0] : b, _ = Array.isArray(b) ? b[1] : O, C = Array.isArray(b) ? b[2] : w, A = Array.isArray(b) ? b[3] : x, k = Math.max(S, _, C), P = Math.min(S, _, C), L = (k + P) / 2;
    let D = 0, E = 0;
    if (P !== k) {
      const M = k - P;
      switch (E = L > 0.5 ? M / (2 - k - P) : M / (k + P), k) {
        case S:
          D = (_ - C) / M + (_ < C ? 6 : 0);
          break;
        case _:
          D = (C - S) / M + 2;
          break;
        case C:
          D = (S - _) / M + 4;
          break;
      }
      D /= 6;
    }
    return [D, E, L, A ?? 1];
  }
  n.rgba2hsla = l;
  function u(b, O, w, x) {
    const S = Array.isArray(b) ? b[0] : b, _ = Array.isArray(b) ? b[1] : O, C = Array.isArray(b) ? b[2] : w, A = Array.isArray(b) ? b[3] : x, k = C <= 0.5 ? C * (_ + 1) : C + _ - C * _, P = 2 * C - k;
    return [
      i(P, k, S + 1 / 3) * 256,
      i(P, k, S) * 256,
      i(P, k, S - 1 / 3) * 256,
      A ?? 1
    ];
  }
  n.hsla2rgba = u;
  function c(b) {
    return new n(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), b ? void 0 : parseFloat(Math.random().toFixed(2)));
  }
  n.random = c;
  function h() {
    const b = "0123456789ABCDEF";
    let O = "#";
    for (let w = 0; w < 6; w += 1)
      O += b[Math.floor(Math.random() * 16)];
    return O;
  }
  n.randomHex = h;
  function f(b) {
    return c(b).toString();
  }
  n.randomRGBA = f;
  function d(b, O) {
    if (typeof b == "string") {
      const C = b[0] === "#", [A, k, P] = p(b);
      return O ? A * 0.299 + k * 0.587 + P * 0.114 > 186 ? "#000000" : "#ffffff" : `${C ? "#" : ""}${g(255 - A, 255 - k, 255 - P)}`;
    }
    const w = b[0], x = b[1], S = b[2], _ = b[3];
    return O ? w * 0.299 + x * 0.587 + S * 0.114 > 186 ? [0, 0, 0, _] : [255, 255, 255, _] : [255 - w, 255 - x, 255 - S, _];
  }
  n.invert = d;
  function p(b) {
    const O = b.indexOf("#") === 0 ? b : `#${b}`;
    let w = +`0x${O.substr(1)}`;
    if (!(O.length === 4 || O.length === 7) || Number.isNaN(w))
      throw new Error("Invalid hex color.");
    const x = O.length === 4 ? 4 : 8, S = (1 << x) - 1, _ = ["b", "g", "r"].map(() => {
      const C = w & S;
      return w >>= x, x === 4 ? 17 * C : C;
    });
    return [_[2], _[1], _[0]];
  }
  function g(b, O, w) {
    const x = (S) => S.length < 2 ? `0${S}` : S;
    return `${x(b.toString(16))}${x(O.toString(16))}${x(w.toString(16))}`;
  }
  function v(b, O) {
    return y(b, O);
  }
  n.lighten = v;
  function m(b, O) {
    return y(b, -O);
  }
  n.darken = m;
  function y(b, O) {
    if (typeof b == "string") {
      const S = b[0] === "#", _ = parseInt(S ? b.substr(1) : b, 16), C = wo((_ >> 16) + O, 0, 255), A = wo((_ >> 8 & 255) + O, 0, 255), k = wo((_ & 255) + O, 0, 255);
      return `${S ? "#" : ""}${(k | A << 8 | C << 16).toString(16)}`;
    }
    const w = g(b[0], b[1], b[2]), x = p(y(w, O));
    return [x[0], x[1], x[2], b[3]];
  }
})(ql || (ql = {}));
(function(n) {
  n.named = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    burntsienna: "#ea7e5d",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
})(ql || (ql = {}));
class FP {
  constructor() {
    this.clear();
  }
  clear() {
    this.map = /* @__PURE__ */ new WeakMap(), this.arr = [];
  }
  has(e) {
    return this.map.has(e);
  }
  get(e) {
    return this.map.get(e);
  }
  set(e, t) {
    this.map.set(e, t), this.arr.push(e);
  }
  delete(e) {
    const t = this.arr.indexOf(e);
    t >= 0 && this.arr.splice(t, 1);
    const r = this.map.get(e);
    return this.map.delete(e), r;
  }
  each(e) {
    this.arr.forEach((t) => {
      const r = this.map.get(t);
      e(r, t);
    });
  }
  dispose() {
    this.clear();
  }
}
var Lc;
(function(n) {
  function e(i) {
    const o = [], a = [];
    return Array.isArray(i) ? o.push(...i) : i.split("|").forEach((s) => {
      s.indexOf("&") === -1 ? o.push(s) : a.push(...s.split("&"));
    }), { or: o, and: a };
  }
  n.parse = e;
  function t(i, o) {
    if (i != null && o != null) {
      const a = e(i), s = e(o), l = a.or.sort(), u = s.or.sort(), c = a.and.sort(), h = s.and.sort(), f = (d, p) => d.length === p.length && (d.length === 0 || d.every((g, v) => g === p[v]));
      return f(l, u) && f(c, h);
    }
    return i == null && o == null;
  }
  n.equals = t;
  function r(i, o, a) {
    if (o == null || Array.isArray(o) && o.length === 0)
      return a ? i.altKey !== !0 && i.ctrlKey !== !0 && i.metaKey !== !0 && i.shiftKey !== !0 : !0;
    const { or: s, and: l } = e(o), u = (c) => {
      const h = `${c.toLowerCase()}Key`;
      return i[h] === !0;
    };
    return s.some((c) => u(c)) && l.every((c) => u(c));
  }
  n.isMatch = r;
})(Lc || (Lc = {}));
var td;
(function(n) {
  n.linear = (e) => e, n.quad = (e) => e * e, n.cubic = (e) => e * e * e, n.inout = (e) => {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const t = e * e, r = t * e;
    return 4 * (e < 0.5 ? r : 3 * (e - t) + r - 0.75);
  }, n.exponential = (e) => Math.pow(2, 10 * (e - 1)), n.bounce = (e) => {
    for (let t = 0, r = 1; ; t += r, r /= 2)
      if (e >= (7 - 4 * t) / 11) {
        const i = (11 - 6 * t - 11 * e) / 4;
        return -i * i + r * r;
      }
  };
})(td || (td = {}));
(function(n) {
  n.decorators = {
    reverse(e) {
      return (t) => 1 - e(1 - t);
    },
    reflect(e) {
      return (t) => 0.5 * (t < 0.5 ? e(2 * t) : 2 - e(2 - 2 * t));
    },
    clamp(e, t = 0, r = 1) {
      return (i) => {
        const o = e(i);
        return o < t ? t : o > r ? r : o;
      };
    },
    back(e = 1.70158) {
      return (t) => t * t * ((e + 1) * t - e);
    },
    elastic(e = 1.5) {
      return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * e / 3 * t);
    }
  };
})(td || (td = {}));
(function(n) {
  function e(E) {
    return -1 * Math.cos(E * (Math.PI / 2)) + 1;
  }
  n.easeInSine = e;
  function t(E) {
    return Math.sin(E * (Math.PI / 2));
  }
  n.easeOutSine = t;
  function r(E) {
    return -0.5 * (Math.cos(Math.PI * E) - 1);
  }
  n.easeInOutSine = r;
  function i(E) {
    return E * E;
  }
  n.easeInQuad = i;
  function o(E) {
    return E * (2 - E);
  }
  n.easeOutQuad = o;
  function a(E) {
    return E < 0.5 ? 2 * E * E : -1 + (4 - 2 * E) * E;
  }
  n.easeInOutQuad = a;
  function s(E) {
    return E * E * E;
  }
  n.easeInCubic = s;
  function l(E) {
    const M = E - 1;
    return M * M * M + 1;
  }
  n.easeOutCubic = l;
  function u(E) {
    return E < 0.5 ? 4 * E * E * E : (E - 1) * (2 * E - 2) * (2 * E - 2) + 1;
  }
  n.easeInOutCubic = u;
  function c(E) {
    return E * E * E * E;
  }
  n.easeInQuart = c;
  function h(E) {
    const M = E - 1;
    return 1 - M * M * M * M;
  }
  n.easeOutQuart = h;
  function f(E) {
    const M = E - 1;
    return E < 0.5 ? 8 * E * E * E * E : 1 - 8 * M * M * M * M;
  }
  n.easeInOutQuart = f;
  function d(E) {
    return E * E * E * E * E;
  }
  n.easeInQuint = d;
  function p(E) {
    const M = E - 1;
    return 1 + M * M * M * M * M;
  }
  n.easeOutQuint = p;
  function g(E) {
    const M = E - 1;
    return E < 0.5 ? 16 * E * E * E * E * E : 1 + 16 * M * M * M * M * M;
  }
  n.easeInOutQuint = g;
  function v(E) {
    return E === 0 ? 0 : Math.pow(2, 10 * (E - 1));
  }
  n.easeInExpo = v;
  function m(E) {
    return E === 1 ? 1 : -Math.pow(2, -10 * E) + 1;
  }
  n.easeOutExpo = m;
  function y(E) {
    if (E === 0 || E === 1)
      return E;
    const M = E * 2, R = M - 1;
    return M < 1 ? 0.5 * Math.pow(2, 10 * R) : 0.5 * (-Math.pow(2, -10 * R) + 2);
  }
  n.easeInOutExpo = y;
  function b(E) {
    const M = E / 1;
    return -1 * (Math.sqrt(1 - M * E) - 1);
  }
  n.easeInCirc = b;
  function O(E) {
    const M = E - 1;
    return Math.sqrt(1 - M * M);
  }
  n.easeOutCirc = O;
  function w(E) {
    const M = E * 2, R = M - 2;
    return M < 1 ? -0.5 * (Math.sqrt(1 - M * M) - 1) : 0.5 * (Math.sqrt(1 - R * R) + 1);
  }
  n.easeInOutCirc = w;
  function x(E, M = 1.70158) {
    return E * E * ((M + 1) * E - M);
  }
  n.easeInBack = x;
  function S(E, M = 1.70158) {
    const R = E / 1 - 1;
    return R * R * ((M + 1) * R + M) + 1;
  }
  n.easeOutBack = S;
  function _(E, M = 1.70158) {
    const R = E * 2, N = R - 2, $ = M * 1.525;
    return R < 1 ? 0.5 * R * R * (($ + 1) * R - $) : 0.5 * (N * N * (($ + 1) * N + $) + 2);
  }
  n.easeInOutBack = _;
  function C(E, M = 0.7) {
    if (E === 0 || E === 1)
      return E;
    const N = E / 1 - 1, $ = 1 - M, F = $ / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * N) * // eslint-disable-line
    Math.sin((N - F) * (2 * Math.PI) / $));
  }
  n.easeInElastic = C;
  function A(E, M = 0.7) {
    const R = 1 - M, N = E * 2;
    if (E === 0 || E === 1)
      return E;
    const $ = R / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * N) * // eslint-disable-line
    Math.sin((N - $) * (2 * Math.PI) / R) + 1;
  }
  n.easeOutElastic = A;
  function k(E, M = 0.65) {
    const R = 1 - M;
    if (E === 0 || E === 1)
      return E;
    const N = E * 2, $ = N - 1, F = R / (2 * Math.PI) * Math.asin(1);
    return N < 1 ? -0.5 * (Math.pow(2, 10 * $) * // eslint-disable-line
    Math.sin(($ - F) * (2 * Math.PI) / R)) : Math.pow(2, -10 * $) * // eslint-disable-line
    Math.sin(($ - F) * (2 * Math.PI) / R) * 0.5 + 1;
  }
  n.easeInOutElastic = k;
  function P(E) {
    const M = E / 1;
    if (M < 1 / 2.75)
      return 7.5625 * M * M;
    if (M < 2 / 2.75) {
      const R = M - 0.5454545454545454;
      return 7.5625 * R * R + 0.75;
    }
    if (M < 2.5 / 2.75) {
      const R = M - 0.8181818181818182;
      return 7.5625 * R * R + 0.9375;
    }
    {
      const R = M - 0.9545454545454546;
      return 7.5625 * R * R + 0.984375;
    }
  }
  n.easeOutBounce = P;
  function L(E) {
    return 1 - P(1 - E);
  }
  n.easeInBounce = L;
  function D(E) {
    return E < 0.5 ? L(E * 2) * 0.5 : P(E * 2 - 1) * 0.5 + 0.5;
  }
  n.easeInOutBounce = D;
})(td || (td = {}));
var vf;
(function(n) {
  n.number = (e, t) => {
    const r = t - e;
    return (i) => e + r * i;
  }, n.object = (e, t) => {
    const r = Object.keys(e);
    return (i) => {
      const o = {};
      for (let a = r.length - 1; a !== -1; a -= 1) {
        const s = r[a];
        o[s] = e[s] + (t[s] - e[s]) * i;
      }
      return o;
    };
  }, n.unit = (e, t) => {
    const r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/, i = r.exec(e), o = r.exec(t), a = o ? o[1] : "", s = i ? +i[1] : 0, l = o ? +o[1] : 0, u = a.indexOf("."), c = u > 0 ? a[1].length - u - 1 : 0, h = l - s, f = i ? i[2] : "";
    return (d) => (s + h * d).toFixed(c) + f;
  }, n.color = (e, t) => {
    const r = parseInt(e.slice(1), 16), i = parseInt(t.slice(1), 16), o = r & 255, a = (i & 255) - o, s = r & 65280, l = (i & 65280) - s, u = r & 16711680, c = (i & 16711680) - u;
    return (h) => {
      const f = o + a * h & 255, d = s + l * h & 65280, p = u + c * h & 16711680;
      return `#${(1 << 24 | f | d | p).toString(16).slice(1)}`;
    };
  };
})(vf || (vf = {}));
const Oy = [];
function T_(n, e) {
  const t = Oy.find((r) => r.name === n);
  if (!(t && (t.loadTimes += 1, t.loadTimes > 1)) && !Mc.isApplyingHMR()) {
    const r = document.createElement("style");
    r.setAttribute("type", "text/css"), r.textContent = e;
    const i = document.querySelector("head");
    i && i.insertBefore(r, i.firstChild), Oy.push({
      name: n,
      loadTimes: 1,
      styleElement: r
    });
  }
}
function k_(n) {
  const e = Oy.findIndex((t) => t.name === n);
  if (e > -1) {
    const t = Oy[e];
    if (t.loadTimes -= 1, t.loadTimes > 0)
      return;
    let r = t.styleElement;
    r && r.parentNode && r.parentNode.removeChild(r), r = null, Oy.splice(e, 1);
  }
}
var Jt;
(function(n) {
  function e(r) {
    return 180 * r / Math.PI % 360;
  }
  n.toDeg = e, n.toRad = function(r, i = !1) {
    return (i ? r : r % 360) * Math.PI / 180;
  };
  function t(r) {
    return r % 360 + (r < 0 ? 360 : 0);
  }
  n.normalize = t;
})(Jt || (Jt = {}));
var rn;
(function(n) {
  function e(s, l = 0) {
    return Number.isInteger(s) ? s : +s.toFixed(l);
  }
  n.round = e;
  function t(s, l) {
    let u, c;
    if (l == null ? (c = s ?? 1, u = 0) : (c = l, u = s ?? 0), c < u) {
      const h = u;
      u = c, c = h;
    }
    return Math.floor(Math.random() * (c - u + 1) + u);
  }
  n.random = t;
  function r(s, l, u) {
    return Number.isNaN(s) ? NaN : Number.isNaN(l) || Number.isNaN(u) ? 0 : l < u ? s < l ? l : s > u ? u : s : s < u ? u : s > l ? l : s;
  }
  n.clamp = r;
  function i(s, l) {
    return l * Math.round(s / l);
  }
  n.snapToGrid = i;
  function o(s, l) {
    return l != null && s != null && l.x >= s.x && l.x <= s.x + s.width && l.y >= s.y && l.y <= s.y + s.height;
  }
  n.containsPoint = o;
  function a(s, l) {
    const u = s.x - l.x, c = s.y - l.y;
    return u * u + c * c;
  }
  n.squaredLength = a;
})(rn || (rn = {}));
class lh {
  valueOf() {
    return this.toJSON();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
let G = class un extends lh {
  constructor(e, t) {
    super(), this.x = e ?? 0, this.y = t ?? 0;
  }
  /**
   * Rounds the point to the given precision.
   */
  round(e = 0) {
    return this.x = rn.round(this.x, e), this.y = rn.round(this.y, e), this;
  }
  add(e, t) {
    const r = un.create(e, t);
    return this.x += r.x, this.y += r.y, this;
  }
  update(e, t) {
    const r = un.create(e, t);
    return this.x = r.x, this.y = r.y, this;
  }
  translate(e, t) {
    const r = un.create(e, t);
    return this.x += r.x, this.y += r.y, this;
  }
  /**
   * Rotate the point by `degree` around `center`.
   */
  rotate(e, t) {
    const r = un.rotate(this, e, t);
    return this.x = r.x, this.y = r.y, this;
  }
  /**
   * Scale point by `sx` and `sy` around the given `origin`. If origin is
   * not specified, the point is scaled around `0, 0`.
   */
  scale(e, t, r = new un()) {
    const i = un.create(r);
    return this.x = i.x + e * (this.x - i.x), this.y = i.y + t * (this.y - i.y), this;
  }
  /**
   * Chooses the point closest to this point from among `points`. If `points`
   * is an empty array, `null` is returned.
   */
  closest(e) {
    if (e.length === 1)
      return un.create(e[0]);
    let t = null, r = 1 / 0;
    return e.forEach((i) => {
      const o = this.squaredDistance(i);
      o < r && (t = i, r = o);
    }), t ? un.create(t) : null;
  }
  /**
   * Returns the distance between the point and another point `p`.
   */
  distance(e) {
    return Math.sqrt(this.squaredDistance(e));
  }
  /**
   * Returns the squared distance between the point and another point `p`.
   *
   * Useful for distance comparisons in which real distance is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredDistance(e) {
    const t = un.create(e), r = this.x - t.x, i = this.y - t.y;
    return r * r + i * i;
  }
  manhattanDistance(e) {
    const t = un.create(e);
    return Math.abs(t.x - this.x) + Math.abs(t.y - this.y);
  }
  /**
   * Returns the magnitude of the point vector.
   *
   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
   */
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p` and
   * the x-axis.
   */
  theta(e = new un()) {
    const t = un.create(e), r = -(t.y - this.y), i = t.x - this.x;
    let o = Math.atan2(r, i);
    return o < 0 && (o = 2 * Math.PI + o), 180 * o / Math.PI;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p1` and
   * the vector from this point to `p2`.
   *
   * The ordering of points `p1` and `p2` is important.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from `p1` to `p2`) is clockwise, and a value between `180` and
   * `360` when the angle is counterclockwise.
   *
   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
   */
  angleBetween(e, t) {
    if (this.equals(e) || this.equals(t))
      return NaN;
    let r = this.theta(t) - this.theta(e);
    return r < 0 && (r += 360), r;
  }
  /**
   * Returns the angle(in degrees) between the line from `(0,0)` and this point
   * and the line from `(0,0)` to `p`.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from this point to `p`) is clockwise, and a value between `180`
   * and `360` when the angle is counterclockwise. Returns `NaN` if called from
   * point `(0,0)` or if `p` is `(0,0)`.
   */
  vectorAngle(e) {
    return new un(0, 0).angleBetween(this, e);
  }
  /**
   * Converts rectangular to polar coordinates.
   */
  toPolar(e) {
    return this.update(un.toPolar(this, e)), this;
  }
  /**
   * Returns the change in angle(in degrees) that is the result of moving the
   * point from its previous position to its current position.
   *
   * More specifically, this function computes the angle between the line from
   * the ref point to the previous position of this point(i.e. current position
   * `-dx`, `-dy`) and the line from the `ref` point to the current position of
   * this point.
   *
   * The function returns a positive value between `0` and `180` when the angle
   * (in the direction from previous position of this point to its current
   * position) is clockwise, and a negative value between `0` and `-180` when
   * the angle is counterclockwise.
   *
   * The function returns `0` if the previous and current positions of this
   * point are the same (i.e. both `dx` and `dy` are `0`).
   */
  changeInAngle(e, t, r = new un()) {
    return this.clone().translate(-e, -t).theta(r) - this.theta(r);
  }
  /**
   * If the point lies outside the rectangle `rect`, adjust the point so that
   * it becomes the nearest point on the boundary of `rect`.
   */
  adhereToRect(e) {
    return rn.containsPoint(e, this) || (this.x = Math.min(Math.max(this.x, e.x), e.x + e.width), this.y = Math.min(Math.max(this.y, e.y), e.y + e.height)), this;
  }
  /**
   * Returns the bearing(cardinal direction) between me and the given point.
   *
   * @see https://en.wikipedia.org/wiki/Cardinal_direction
   */
  bearing(e) {
    const t = un.create(e), r = Jt.toRad(this.y), i = Jt.toRad(t.y), o = this.x, a = t.x, s = Jt.toRad(a - o), l = Math.sin(s) * Math.cos(i), u = Math.cos(r) * Math.sin(i) - Math.sin(r) * Math.cos(i) * Math.cos(s), c = Jt.toDeg(Math.atan2(l, u)), h = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
    let f = c - 22.5;
    return f < 0 && (f += 360), f = parseInt(f / 45, 10), h[f];
  }
  /**
   * Returns the cross product of the vector from me to `p1` and the vector
   * from me to `p2`.
   *
   * The left-hand rule is used because the coordinate system is left-handed.
   */
  cross(e, t) {
    if (e != null && t != null) {
      const r = un.create(e), i = un.create(t);
      return (i.x - this.x) * (r.y - this.y) - (i.y - this.y) * (r.x - this.x);
    }
    return NaN;
  }
  /**
   * Returns the dot product of this point with given other point.
   */
  dot(e) {
    const t = un.create(e);
    return this.x * t.x + this.y * t.y;
  }
  diff(e, t) {
    if (typeof e == "number")
      return new un(this.x - e, this.y - t);
    const r = un.create(e);
    return new un(this.x - r.x, this.y - r.y);
  }
  /**
   * Returns an interpolation between me and point `p` for a parametert in
   * the closed interval `[0, 1]`.
   */
  lerp(e, t) {
    const r = un.create(e);
    return new un((1 - t) * this.x + t * r.x, (1 - t) * this.y + t * r.y);
  }
  /**
   * Normalize the point vector, scale the line segment between `(0, 0)`
   * and the point in order for it to have the given length. If length is
   * not specified, it is considered to be `1`; in that case, a unit vector
   * is computed.
   */
  normalize(e = 1) {
    const t = e / this.magnitude();
    return this.scale(t, t);
  }
  /**
   * Moves this point along the line starting from `ref` to this point by a
   * certain `distance`.
   */
  move(e, t) {
    const r = un.create(e), i = Jt.toRad(r.theta(this));
    return this.translate(Math.cos(i) * t, -Math.sin(i) * t);
  }
  /**
   * Returns a point that is the reflection of me with the center of inversion
   * in `ref` point.
   */
  reflection(e) {
    return un.create(e).move(this, this.distance(e));
  }
  snapToGrid(e, t) {
    return this.x = rn.snapToGrid(this.x, e), this.y = rn.snapToGrid(this.y, t ?? e), this;
  }
  equals(e) {
    const t = un.create(e);
    return t != null && t.x === this.x && t.y === this.y;
  }
  clone() {
    return un.clone(this);
  }
  /**
   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
   */
  toJSON() {
    return un.toJSON(this);
  }
  serialize() {
    return `${this.x} ${this.y}`;
  }
};
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isPoint = e;
})(G || (G = {}));
(function(n) {
  function e(r) {
    return r != null && typeof r == "object" && typeof r.x == "number" && typeof r.y == "number";
  }
  n.isPointLike = e;
  function t(r) {
    return r != null && Array.isArray(r) && r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number";
  }
  n.isPointData = t;
})(G || (G = {}));
(function(n) {
  function e(h, f) {
    return h == null || typeof h == "number" ? new n(h, f) : t(h);
  }
  n.create = e;
  function t(h) {
    return n.isPoint(h) ? new n(h.x, h.y) : Array.isArray(h) ? new n(h[0], h[1]) : new n(h.x, h.y);
  }
  n.clone = t;
  function r(h) {
    return n.isPoint(h) ? { x: h.x, y: h.y } : Array.isArray(h) ? { x: h[0], y: h[1] } : { x: h.x, y: h.y };
  }
  n.toJSON = r;
  function i(h, f, d = new n()) {
    let p = Math.abs(h * Math.cos(f)), g = Math.abs(h * Math.sin(f));
    const v = t(d), m = Jt.normalize(Jt.toDeg(f));
    return m < 90 ? g = -g : m < 180 ? (p = -p, g = -g) : m < 270 && (p = -p), new n(v.x + p, v.y + g);
  }
  n.fromPolar = i;
  function o(h, f = new n()) {
    const d = t(h), p = t(f), g = d.x - p.x, v = d.y - p.y;
    return new n(
      Math.sqrt(g * g + v * v),
      // r
      Jt.toRad(p.theta(d))
    );
  }
  n.toPolar = o;
  function a(h, f) {
    return h === f ? !0 : h != null && f != null ? h.x === f.x && h.y === f.y : !1;
  }
  n.equals = a;
  function s(h, f) {
    if (h == null && f != null || h != null && f == null || h != null && f != null && h.length !== f.length)
      return !1;
    if (h != null && f != null) {
      for (let d = 0, p = h.length; d < p; d += 1)
        if (!a(h[d], f[d]))
          return !1;
    }
    return !0;
  }
  n.equalPoints = s;
  function l(h, f, d, p) {
    return new n(rn.random(h, f), rn.random(d, p));
  }
  n.random = l;
  function u(h, f, d) {
    const p = Jt.toRad(Jt.normalize(-f)), g = Math.sin(p), v = Math.cos(p);
    return c(h, v, g, d);
  }
  n.rotate = u;
  function c(h, f, d, p = new n()) {
    const g = t(h), v = t(p), m = g.x - v.x, y = g.y - v.y, b = m * f - y * d, O = y * f + m * d;
    return new n(b + v.x, O + v.y);
  }
  n.rotateEx = c;
})(G || (G = {}));
class Te extends lh {
  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.width;
  }
  get bottom() {
    return this.y + this.height;
  }
  get origin() {
    return new G(this.x, this.y);
  }
  get topLeft() {
    return new G(this.x, this.y);
  }
  get topCenter() {
    return new G(this.x + this.width / 2, this.y);
  }
  get topRight() {
    return new G(this.x + this.width, this.y);
  }
  get center() {
    return new G(this.x + this.width / 2, this.y + this.height / 2);
  }
  get bottomLeft() {
    return new G(this.x, this.y + this.height);
  }
  get bottomCenter() {
    return new G(this.x + this.width / 2, this.y + this.height);
  }
  get bottomRight() {
    return new G(this.x + this.width, this.y + this.height);
  }
  get corner() {
    return new G(this.x + this.width, this.y + this.height);
  }
  get rightMiddle() {
    return new G(this.x + this.width, this.y + this.height / 2);
  }
  get leftMiddle() {
    return new G(this.x, this.y + this.height / 2);
  }
  get topLine() {
    return new Xe(this.topLeft, this.topRight);
  }
  get rightLine() {
    return new Xe(this.topRight, this.bottomRight);
  }
  get bottomLine() {
    return new Xe(this.bottomLeft, this.bottomRight);
  }
  get leftLine() {
    return new Xe(this.topLeft, this.bottomLeft);
  }
  constructor(e, t, r, i) {
    super(), this.x = e ?? 0, this.y = t ?? 0, this.width = r ?? 0, this.height = i ?? 0;
  }
  getOrigin() {
    return this.origin;
  }
  getTopLeft() {
    return this.topLeft;
  }
  getTopCenter() {
    return this.topCenter;
  }
  getTopRight() {
    return this.topRight;
  }
  getCenter() {
    return this.center;
  }
  getCenterX() {
    return this.x + this.width / 2;
  }
  getCenterY() {
    return this.y + this.height / 2;
  }
  getBottomLeft() {
    return this.bottomLeft;
  }
  getBottomCenter() {
    return this.bottomCenter;
  }
  getBottomRight() {
    return this.bottomRight;
  }
  getCorner() {
    return this.corner;
  }
  getRightMiddle() {
    return this.rightMiddle;
  }
  getLeftMiddle() {
    return this.leftMiddle;
  }
  getTopLine() {
    return this.topLine;
  }
  getRightLine() {
    return this.rightLine;
  }
  getBottomLine() {
    return this.bottomLine;
  }
  getLeftLine() {
    return this.leftLine;
  }
  /**
   * Returns a rectangle that is the bounding box of the rectangle.
   *
   * If `angle` is specified, the bounding box calculation will take into
   * account the rotation of the rectangle by angle degrees around its center.
   */
  bbox(e) {
    if (!e)
      return this.clone();
    const t = Jt.toRad(e), r = Math.abs(Math.sin(t)), i = Math.abs(Math.cos(t)), o = this.width * i + this.height * r, a = this.width * r + this.height * i;
    return new Te(this.x + (this.width - o) / 2, this.y + (this.height - a) / 2, o, a);
  }
  round(e = 0) {
    return this.x = rn.round(this.x, e), this.y = rn.round(this.y, e), this.width = rn.round(this.width, e), this.height = rn.round(this.height, e), this;
  }
  add(e, t, r, i) {
    const o = Te.create(e, t, r, i), a = Math.min(this.x, o.x), s = Math.min(this.y, o.y), l = Math.max(this.x + this.width, o.x + o.width), u = Math.max(this.y + this.height, o.y + o.height);
    return this.x = a, this.y = s, this.width = l - a, this.height = u - s, this;
  }
  update(e, t, r, i) {
    const o = Te.create(e, t, r, i);
    return this.x = o.x, this.y = o.y, this.width = o.width, this.height = o.height, this;
  }
  inflate(e, t) {
    const r = e, i = t ?? e;
    return this.x -= r, this.y -= i, this.width += 2 * r, this.height += 2 * i, this;
  }
  snapToGrid(e, t) {
    const r = this.origin.snapToGrid(e, t), i = this.corner.snapToGrid(e, t);
    return this.x = r.x, this.y = r.y, this.width = i.x - r.x, this.height = i.y - r.y, this;
  }
  translate(e, t) {
    const r = G.create(e, t);
    return this.x += r.x, this.y += r.y, this;
  }
  scale(e, t, r = new G()) {
    const i = this.origin.scale(e, t, r);
    return this.x = i.x, this.y = i.y, this.width *= e, this.height *= t, this;
  }
  rotate(e, t = this.getCenter()) {
    if (e !== 0) {
      const r = Jt.toRad(e), i = Math.cos(r), o = Math.sin(r);
      let a = this.getOrigin(), s = this.getTopRight(), l = this.getBottomRight(), u = this.getBottomLeft();
      a = G.rotateEx(a, i, o, t), s = G.rotateEx(s, i, o, t), l = G.rotateEx(l, i, o, t), u = G.rotateEx(u, i, o, t);
      const c = new Te(a.x, a.y, 0, 0);
      c.add(s.x, s.y, 0, 0), c.add(l.x, l.y, 0, 0), c.add(u.x, u.y, 0, 0), this.update(c);
    }
    return this;
  }
  rotate90() {
    const e = (this.width - this.height) / 2;
    this.x += e, this.y -= e;
    const t = this.width;
    return this.width = this.height, this.height = t, this;
  }
  /**
   * Translates the rectangle by `rect.x` and `rect.y` and expand it by
   * `rect.width` and `rect.height`.
   */
  moveAndExpand(e) {
    const t = Te.clone(e);
    return this.x += t.x || 0, this.y += t.y || 0, this.width += t.width || 0, this.height += t.height || 0, this;
  }
  /**
   * Returns an object where `sx` and `sy` give the maximum scaling that can be
   * applied to the rectangle so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxScaleToFit(e, t = this.center) {
    const r = Te.clone(e), i = t.x, o = t.y;
    let a = 1 / 0, s = 1 / 0, l = 1 / 0, u = 1 / 0, c = 1 / 0, h = 1 / 0, f = 1 / 0, d = 1 / 0;
    const p = r.topLeft;
    p.x < i && (a = (this.x - i) / (p.x - i)), p.y < o && (c = (this.y - o) / (p.y - o));
    const g = r.bottomRight;
    g.x > i && (s = (this.x + this.width - i) / (g.x - i)), g.y > o && (h = (this.y + this.height - o) / (g.y - o));
    const v = r.topRight;
    v.x > i && (l = (this.x + this.width - i) / (v.x - i)), v.y < o && (f = (this.y - o) / (v.y - o));
    const m = r.bottomLeft;
    return m.x < i && (u = (this.x - i) / (m.x - i)), m.y > o && (d = (this.y + this.height - o) / (m.y - o)), {
      sx: Math.min(a, s, l, u),
      sy: Math.min(c, h, f, d)
    };
  }
  /**
   * Returns a number that specifies the maximum scaling that can be applied to
   * the rectangle along both axes so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxUniformScaleToFit(e, t = this.center) {
    const r = this.getMaxScaleToFit(e, t);
    return Math.min(r.sx, r.sy);
  }
  containsPoint(e, t) {
    return rn.containsPoint(this, G.create(e, t));
  }
  containsRect(e, t, r, i) {
    const o = Te.create(e, t, r, i), a = this.x, s = this.y, l = this.width, u = this.height, c = o.x, h = o.y, f = o.width, d = o.height;
    return l === 0 || u === 0 || f === 0 || d === 0 ? !1 : c >= a && h >= s && c + f <= a + l && h + d <= s + u;
  }
  /**
   * Returns an array of the intersection points of the rectangle and the line.
   * Return `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [
      this.topLine,
      this.rightLine,
      this.bottomLine,
      this.leftLine
    ], r = [], i = [];
    return t.forEach((o) => {
      const a = e.intersectsWithLine(o);
      a !== null && i.indexOf(a.toString()) < 0 && (r.push(a), i.push(a.toString()));
    }), r.length > 0 ? r : null;
  }
  /**
   * Returns the point on the boundary of the rectangle that is the intersection
   * of the rectangle with a line starting in the center the rectangle ending in
   * the point `p`.
   *
   * If `angle` is specified, the intersection will take into account the
   * rotation of the rectangle by `angle` degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t) {
    const r = G.clone(e), i = this.center;
    let o = null;
    t != null && t !== 0 && r.rotate(t, i);
    const a = [this.topLine, this.rightLine, this.bottomLine, this.leftLine], s = new Xe(i, r);
    for (let l = a.length - 1; l >= 0; l -= 1) {
      const u = a[l].intersectsWithLine(s);
      if (u !== null) {
        o = u;
        break;
      }
    }
    return o && t != null && t !== 0 && o.rotate(-t, i), o;
  }
  intersectsWithRect(e, t, r, i) {
    const o = Te.create(e, t, r, i);
    if (!this.isIntersectWithRect(o))
      return null;
    const a = this.origin, s = this.corner, l = o.origin, u = o.corner, c = Math.max(a.x, l.x), h = Math.max(a.y, l.y);
    return new Te(c, h, Math.min(s.x, u.x) - c, Math.min(s.y, u.y) - h);
  }
  isIntersectWithRect(e, t, r, i) {
    const o = Te.create(e, t, r, i), a = this.origin, s = this.corner, l = o.origin, u = o.corner;
    return !(u.x <= a.x || u.y <= a.y || l.x >= s.x || l.y >= s.y);
  }
  /**
   * Normalize the rectangle, i.e. make it so that it has non-negative
   * width and height. If width is less than `0`, the function swaps left and
   * right corners and if height is less than `0`, the top and bottom corners
   * are swapped.
   */
  normalize() {
    let e = this.x, t = this.y, r = this.width, i = this.height;
    return this.width < 0 && (e = this.x + this.width, r = -this.width), this.height < 0 && (t = this.y + this.height, i = -this.height), this.x = e, this.y = t, this.width = r, this.height = i, this;
  }
  /**
   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
   */
  union(e) {
    const t = Te.clone(e), r = this.origin, i = this.corner, o = t.origin, a = t.corner, s = Math.min(r.x, o.x), l = Math.min(r.y, o.y), u = Math.max(i.x, a.x), c = Math.max(i.y, a.y);
    return new Te(s, l, u - s, c - l);
  }
  /**
   * Returns a string ("top", "left", "right" or "bottom") denoting the side of
   * the rectangle which is nearest to the point `p`.
   */
  getNearestSideToPoint(e) {
    const t = G.clone(e), r = t.x - this.x, i = this.x + this.width - t.x, o = t.y - this.y, a = this.y + this.height - t.y;
    let s = r, l = "left";
    return i < s && (s = i, l = "right"), o < s && (s = o, l = "top"), a < s && (l = "bottom"), l;
  }
  /**
   * Returns a point on the boundary of the rectangle nearest to the point `p`.
   */
  getNearestPointToPoint(e) {
    const t = G.clone(e);
    if (this.containsPoint(t)) {
      const r = this.getNearestSideToPoint(t);
      if (r === "left")
        return new G(this.x, t.y);
      if (r === "top")
        return new G(t.x, this.y);
      if (r === "right")
        return new G(this.x + this.width, t.y);
      if (r === "bottom")
        return new G(t.x, this.y + this.height);
    }
    return t.adhereToRect(this);
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.width === this.width && e.height === this.height;
  }
  clone() {
    return new Te(this.x, this.y, this.width, this.height);
  }
  toJSON() {
    return { x: this.x, y: this.y, width: this.width, height: this.height };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.width} ${this.height}`;
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isRectangle = e;
})(Te || (Te = {}));
(function(n) {
  function e(t) {
    return t != null && typeof t == "object" && typeof t.x == "number" && typeof t.y == "number" && typeof t.width == "number" && typeof t.height == "number";
  }
  n.isRectangleLike = e;
})(Te || (Te = {}));
(function(n) {
  function e(a, s, l, u) {
    return a == null || typeof a == "number" ? new n(a, s, l, u) : t(a);
  }
  n.create = e;
  function t(a) {
    return n.isRectangle(a) ? a.clone() : Array.isArray(a) ? new n(a[0], a[1], a[2], a[3]) : new n(a.x, a.y, a.width, a.height);
  }
  n.clone = t;
  function r(a) {
    return new n(a.x - a.a, a.y - a.b, 2 * a.a, 2 * a.b);
  }
  n.fromEllipse = r;
  function i(a) {
    return new n(0, 0, a.width, a.height);
  }
  n.fromSize = i;
  function o(a, s) {
    return new n(a.x, a.y, s.width, s.height);
  }
  n.fromPositionAndSize = o;
})(Te || (Te = {}));
let Xe = class Wa extends lh {
  get center() {
    return new G((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }
  constructor(e, t, r, i) {
    super(), typeof e == "number" && typeof t == "number" ? (this.start = new G(e, t), this.end = new G(r, i)) : (this.start = G.create(e), this.end = G.create(t));
  }
  getCenter() {
    return this.center;
  }
  /**
   * Rounds the line to the given `precision`.
   */
  round(e = 0) {
    return this.start.round(e), this.end.round(e), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.end.translate(e)), this;
  }
  /**
   * Rotate the line by `angle` around `origin`.
   */
  rotate(e, t) {
    return this.start.rotate(e, t), this.end.rotate(e, t), this;
  }
  /**
   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
   * specified, the line is scaled around `0,0`.
   */
  scale(e, t, r) {
    return this.start.scale(e, t, r), this.end.scale(e, t, r), this;
  }
  /**
   * Returns the length of the line.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Useful for distance comparisons in which real length is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredLength() {
    const e = this.start.x - this.end.x, t = this.start.y - this.end.y;
    return e * e + t * t;
  }
  /**
   * Scale the line so that it has the requested length. The start point of
   * the line is preserved.
   */
  setLength(e) {
    const t = this.length();
    if (!t)
      return this;
    const r = e / t;
    return this.scale(r, r, this.start);
  }
  parallel(e) {
    const t = this.clone();
    if (!t.isDifferentiable())
      return t;
    const { start: r, end: i } = t, o = r.clone().rotate(270, i), a = i.clone().rotate(90, r);
    return r.move(a, e), i.move(o, e), t;
  }
  /**
   * Returns the vector of the line with length equal to length of the line.
   */
  vector() {
    return new G(this.end.x - this.start.x, this.end.y - this.start.y);
  }
  /**
   * Returns the angle of incline of the line.
   *
   * The function returns `NaN` if the start and end endpoints of the line
   * both lie at the same coordinates(it is impossible to determine the angle
   * of incline of a line that appears to be a point). The
   * `line.isDifferentiable()` function may be used in advance to determine
   * whether the angle of incline can be computed for a given line.
   */
  angle() {
    const e = new G(this.start.x + 1, this.start.y);
    return this.start.angleBetween(this.end, e);
  }
  /**
   * Returns a rectangle that is the bounding box of the line.
   */
  bbox() {
    const e = Math.min(this.start.x, this.end.x), t = Math.min(this.start.y, this.end.y), r = Math.max(this.start.x, this.end.x), i = Math.max(this.start.y, this.end.y);
    return new Te(e, t, r - e, i - t);
  }
  /**
   * Returns the bearing (cardinal direction) of the line.
   *
   * The return value is one of the following strings:
   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
   *
   * The function returns 'N' if the two endpoints of the line are coincident.
   */
  bearing() {
    return this.start.bearing(this.end);
  }
  /**
   * Returns the point on the line that lies closest to point `p`.
   */
  closestPoint(e) {
    return this.pointAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the length of the line up to the point that lies closest to point `p`.
   */
  closestPointLength(e) {
    return this.closestPointNormalizedLength(e) * this.length();
  }
  /**
   * Returns a line that is tangent to the line at the point that lies closest
   * to point `p`.
   */
  closestPointTangent(e) {
    return this.tangentAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the normalized length (distance from the start of the line / total
   * line length) of the line up to the point that lies closest to point.
   */
  closestPointNormalizedLength(e) {
    const t = this.vector().dot(new Wa(this.start, e).vector()), r = Math.min(1, Math.max(0, t / this.squaredLength()));
    return Number.isNaN(r) ? 0 : r;
  }
  /**
   * Returns a point on the line that lies `rate` (normalized length) away from
   * the beginning of the line.
   */
  pointAt(e) {
    const t = this.start, r = this.end;
    return e <= 0 ? t.clone() : e >= 1 ? r.clone() : t.lerp(r, e);
  }
  /**
   * Returns a point on the line that lies length away from the beginning of
   * the line.
   */
  pointAtLength(e) {
    const t = this.start, r = this.end;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const o = this.length();
    if (e >= o)
      return i ? r.clone() : t.clone();
    const a = (i ? e : o - e) / o;
    return this.pointAt(a);
  }
  /**
   * Divides the line into two lines at the point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  divideAt(e) {
    const t = this.pointAt(e);
    return [
      new Wa(this.start, t),
      new Wa(t, this.end)
    ];
  }
  /**
   * Divides the line into two lines at the point that lies length away from
   * the beginning of the line.
   */
  divideAtLength(e) {
    const t = this.pointAtLength(e);
    return [
      new Wa(this.start, t),
      new Wa(t, this.end)
    ];
  }
  /**
   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
   */
  containsPoint(e) {
    const t = this.start, r = this.end;
    if (t.cross(e, r) !== 0)
      return !1;
    const i = this.length();
    return !(new Wa(t, e).length() > i || new Wa(e, r).length() > i);
  }
  intersect(e, t) {
    const r = e.intersectsWithLine(this, t);
    return r ? Array.isArray(r) ? r : [r] : null;
  }
  /**
   * Returns the intersection point of the line with another line. Returns
   * `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = new G(this.end.x - this.start.x, this.end.y - this.start.y), r = new G(e.end.x - e.start.x, e.end.y - e.start.y), i = t.x * r.y - t.y * r.x, o = new G(e.start.x - this.start.x, e.start.y - this.start.y), a = o.x * r.y - o.y * r.x, s = o.x * t.y - o.y * t.x;
    if (i === 0 || a * i < 0 || s * i < 0)
      return null;
    if (i > 0) {
      if (a > i || s > i)
        return null;
    } else if (a < i || s < i)
      return null;
    return new G(this.start.x + a * t.x / i, this.start.y + a * t.y / i);
  }
  /**
   * Returns `true` if a tangent line can be found for the line.
   *
   * Tangents cannot be found if both of the line endpoints are coincident
   * (the line appears to be a point).
   */
  isDifferentiable() {
    return !this.start.equals(this.end);
  }
  /**
   * Returns the perpendicular distance between the line and point. The
   * distance is positive if the point lies to the right of the line, negative
   * if the point lies to the left of the line, and `0` if the point lies on
   * the line.
   */
  pointOffset(e) {
    const t = G.clone(e), r = this.start, i = this.end;
    return ((i.x - r.x) * (t.y - r.y) - (i.y - r.y) * (t.x - r.x)) / this.length();
  }
  pointSquaredDistance(e, t) {
    const r = G.create(e, t);
    return this.closestPoint(r).squaredDistance(r);
  }
  pointDistance(e, t) {
    const r = G.create(e, t);
    return this.closestPoint(r).distance(r);
  }
  /**
   * Returns a line tangent to the line at point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  tangentAt(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, r = this.end, i = this.pointAt(e), o = new Wa(t, r);
    return o.translate(i.x - t.x, i.y - t.y), o;
  }
  /**
   * Returns a line tangent to the line at point that lies `length` away from
   * the beginning of the line.
   */
  tangentAtLength(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, r = this.end, i = this.pointAtLength(e), o = new Wa(t, r);
    return o.translate(i.x - t.x, i.y - t.y), o;
  }
  relativeCcw(e, t) {
    const r = G.create(e, t);
    let i = r.x - this.start.x, o = r.y - this.start.y;
    const a = this.end.x - this.start.x, s = this.end.y - this.start.y;
    let l = i * s - o * a;
    return l === 0 && (l = i * a + o * s, l > 0 && (i -= a, o -= s, l = i * a + o * s, l < 0 && (l = 0))), l < 0 ? -1 : l > 0 ? 1 : 0;
  }
  /**
   * Return `true` if the line equals the other line.
   */
  equals(e) {
    return e != null && this.start.x === e.start.x && this.start.y === e.start.y && this.end.x === e.end.x && this.end.y === e.end.y;
  }
  /**
   * Returns another line which is a clone of the line.
   */
  clone() {
    return new Wa(this.start, this.end);
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  serialize() {
    return [this.start.serialize(), this.end.serialize()].join(" ");
  }
};
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isLine = e;
})(Xe || (Xe = {}));
let Ic = class QP extends lh {
  get center() {
    return new G(this.x, this.y);
  }
  constructor(e, t, r, i) {
    super(), this.x = e ?? 0, this.y = t ?? 0, this.a = r ?? 0, this.b = i ?? 0;
  }
  /**
   * Returns a rectangle that is the bounding box of the ellipse.
   */
  bbox() {
    return Te.fromEllipse(this);
  }
  /**
   * Returns a point that is the center of the ellipse.
   */
  getCenter() {
    return this.center;
  }
  inflate(e, t) {
    const r = e, i = t ?? e;
    return this.a += 2 * r, this.b += 2 * i, this;
  }
  normalizedDistance(e, t) {
    const r = G.create(e, t), i = r.x - this.x, o = r.y - this.y, a = this.a, s = this.b;
    return i * i / (a * a) + o * o / (s * s);
  }
  containsPoint(e, t) {
    return this.normalizedDistance(e, t) <= 1;
  }
  /**
   * Returns an array of the intersection points of the ellipse and the line.
   * Returns `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [], r = this.a, i = this.b, o = e.start, a = e.end, s = e.vector(), l = o.diff(new G(this.x, this.y)), u = new G(s.x / (r * r), s.y / (i * i)), c = new G(l.x / (r * r), l.y / (i * i)), h = s.dot(u), f = s.dot(c), d = l.dot(c) - 1, p = f * f - h * d;
    if (p < 0)
      return null;
    if (p > 0) {
      const g = Math.sqrt(p), v = (-f - g) / h, m = (-f + g) / h;
      if ((v < 0 || v > 1) && (m < 0 || m > 1))
        return null;
      v >= 0 && v <= 1 && t.push(o.lerp(a, v)), m >= 0 && m <= 1 && t.push(o.lerp(a, m));
    } else {
      const g = -f / h;
      if (g >= 0 && g <= 1)
        t.push(o.lerp(a, g));
      else
        return null;
    }
    return t;
  }
  /**
   * Returns the point on the boundary of the ellipse that is the
   * intersection of the ellipse with a line starting in the center
   * of the ellipse ending in the point `p`.
   *
   * If angle is specified, the intersection will take into account
   * the rotation of the ellipse by angle degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t = 0) {
    const r = G.clone(e);
    t && r.rotate(t, this.getCenter());
    const i = r.x - this.x, o = r.y - this.y;
    let a;
    if (i === 0)
      return a = this.bbox().getNearestPointToPoint(r), t ? a.rotate(-t, this.getCenter()) : a;
    const s = o / i, l = s * s, u = this.a * this.a, c = this.b * this.b;
    let h = Math.sqrt(1 / (1 / u + l / c));
    h = i < 0 ? -h : h;
    const f = s * h;
    return a = new G(this.x + h, this.y + f), t ? a.rotate(-t, this.getCenter()) : a;
  }
  /**
   * Returns the angle between the x-axis and the tangent from a point. It is
   * valid for points lying on the ellipse boundary only.
   */
  tangentTheta(e) {
    const t = G.clone(e), r = t.x, i = t.y, o = this.a, a = this.b, s = this.bbox().center, l = s.x, u = s.y, c = 30, h = r > s.x + o / 2, f = r < s.x - o / 2;
    let d, p;
    return h || f ? (p = r > s.x ? i - c : i + c, d = o * o / (r - l) - o * o * (i - u) * (p - u) / (a * a * (r - l)) + l) : (d = i > s.y ? r + c : r - c, p = a * a / (i - u) - a * a * (r - l) * (d - l) / (o * o * (i - u)) + u), new G(d, p).theta(t);
  }
  scale(e, t) {
    return this.a *= e, this.b *= t, this;
  }
  rotate(e, t) {
    const r = Te.fromEllipse(this);
    r.rotate(e, t);
    const i = QP.fromRect(r);
    return this.a = i.a, this.b = i.b, this.x = i.x, this.y = i.y, this;
  }
  translate(e, t) {
    const r = G.create(e, t);
    return this.x += r.x, this.y += r.y, this;
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.a === this.a && e.b === this.b;
  }
  clone() {
    return new QP(this.x, this.y, this.a, this.b);
  }
  toJSON() {
    return { x: this.x, y: this.y, a: this.a, b: this.b };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.a} ${this.b}`;
  }
};
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isEllipse = e;
})(Ic || (Ic = {}));
(function(n) {
  function e(i, o, a, s) {
    return i == null || typeof i == "number" ? new n(i, o, a, s) : t(i);
  }
  n.create = e;
  function t(i) {
    return n.isEllipse(i) ? i.clone() : Array.isArray(i) ? new n(i[0], i[1], i[2], i[3]) : new n(i.x, i.y, i.a, i.b);
  }
  n.parse = t;
  function r(i) {
    const o = i.center;
    return new n(o.x, o.y, i.width / 2, i.height / 2);
  }
  n.fromRect = r;
})(Ic || (Ic = {}));
const sAe = new RegExp("^[\\s\\dLMCZz,.]*$");
function lAe(n) {
  return typeof n != "string" ? !1 : sAe.test(n);
}
function S2(n, e) {
  return (n % e + e) % e;
}
function uAe(n, e, t, r, i) {
  const o = [], a = n[n.length - 1], s = e != null && e > 0, l = e || 0;
  if (r && s) {
    n = n.slice();
    const h = n[0], f = new G(a.x + (h.x - a.x) / 2, a.y + (h.y - a.y) / 2);
    n.splice(0, 0, f);
  }
  let u = n[0], c = 1;
  for (t ? o.push("M", u.x, u.y) : o.push("L", u.x, u.y); c < (r ? n.length : n.length - 1); ) {
    let h = n[S2(c, n.length)], f = u.x - h.x, d = u.y - h.y;
    if (s && (f !== 0 || d !== 0) && (i == null || i.indexOf(c - 1) < 0)) {
      let p = Math.sqrt(f * f + d * d);
      const g = f * Math.min(l, p / 2) / p, v = d * Math.min(l, p / 2) / p, m = h.x + g, y = h.y + v;
      o.push("L", m, y);
      let b = n[S2(c + 1, n.length)];
      for (; c < n.length - 2 && Math.round(b.x - h.x) === 0 && Math.round(b.y - h.y) === 0; )
        b = n[S2(c + 2, n.length)], c += 1;
      f = b.x - h.x, d = b.y - h.y, p = Math.max(1, Math.sqrt(f * f + d * d));
      const O = f * Math.min(l, p / 2) / p, w = d * Math.min(l, p / 2) / p, x = h.x + O, S = h.y + w;
      o.push("Q", h.x, h.y, x, S), h = new G(x, S);
    } else
      o.push("L", h.x, h.y);
    u = h, c += 1;
  }
  return r ? o.push("Z") : o.push("L", a.x, a.y), o.map((h) => typeof h == "string" ? h : +h.toFixed(3)).join(" ");
}
function Bq(n, e = {}) {
  const t = [];
  return n && n.length && n.forEach((r) => {
    Array.isArray(r) ? t.push({ x: r[0], y: r[1] }) : t.push({ x: r.x, y: r.y });
  }), uAe(t, e.round, e.initialMove == null || e.initialMove, e.close, e.exclude);
}
function Ox(n, e, t, r, i = 0, o = 0, a = 0, s, l) {
  if (t === 0 || r === 0)
    return [];
  s -= n, l -= e, t = Math.abs(t), r = Math.abs(r);
  const u = -s / 2, c = -l / 2, h = Math.cos(i * Math.PI / 180), f = Math.sin(i * Math.PI / 180), d = h * u + f * c, p = -1 * f * u + h * c, g = d * d, v = p * p, m = t * t, y = r * r, b = g / m + v / y;
  let O;
  if (b > 1)
    t = Math.sqrt(b) * t, r = Math.sqrt(b) * r, O = 0;
  else {
    let ee = 1;
    o === a && (ee = -1), O = ee * Math.sqrt((m * y - m * v - y * g) / (m * v + y * g));
  }
  const w = O * t * p / r, x = -1 * O * r * d / t, S = h * w - f * x + s / 2, _ = f * w + h * x + l / 2;
  let C = Math.atan2((p - x) / r, (d - w) / t) - Math.atan2(0, 1), A = C >= 0 ? C : 2 * Math.PI + C;
  C = Math.atan2((-p - x) / r, (-d - w) / t) - Math.atan2((p - x) / r, (d - w) / t);
  let k = C >= 0 ? C : 2 * Math.PI + C;
  a === 0 && k > 0 ? k -= 2 * Math.PI : a !== 0 && k < 0 && (k += 2 * Math.PI);
  const P = k * 2 / Math.PI, L = Math.ceil(P < 0 ? -1 * P : P), D = k / L, E = 8 / 3 * Math.sin(D / 4) * Math.sin(D / 4) / Math.sin(D / 2), M = h * t, R = h * r, N = f * t, $ = f * r;
  let F = Math.cos(A), W = Math.sin(A), j = -E * (M * W + $ * F), Y = -E * (N * W - R * F), X = 0, ie = 0;
  const ae = [];
  for (let ee = 0; ee < L; ee += 1) {
    A += D, F = Math.cos(A), W = Math.sin(A), X = M * F - $ * W + S, ie = N * F + R * W + _;
    const ne = -E * (M * W + $ * F), ye = -E * (N * W - R * F), te = ee * 6;
    ae[te] = Number(j + n), ae[te + 1] = Number(Y + e), ae[te + 2] = Number(X - ne + n), ae[te + 3] = Number(ie - ye + e), ae[te + 4] = Number(X + n), ae[te + 5] = Number(ie + e), j = X + ne, Y = ie + ye;
  }
  return ae.map((ee) => +ee.toFixed(2));
}
function cAe(n, e, t, r, i = 0, o = 0, a = 0, s, l) {
  const u = [], c = Ox(n, e, t, r, i, o, a, s, l);
  if (c != null)
    for (let h = 0, f = c.length; h < f; h += 6)
      u.push("C", c[h], c[h + 1], c[h + 2], c[h + 3], c[h + 4], c[h + 5]);
  return u.join(" ");
}
let Ii = class $m extends lh {
  get start() {
    return this.points[0] || null;
  }
  get end() {
    return this.points[this.points.length - 1] || null;
  }
  constructor(e) {
    if (super(), e != null) {
      if (typeof e == "string")
        return $m.parse(e);
      this.points = e.map((t) => G.create(t));
    } else
      this.points = [];
  }
  scale(e, t, r = new G()) {
    return this.points.forEach((i) => i.scale(e, t, r)), this;
  }
  rotate(e, t) {
    return this.points.forEach((r) => r.rotate(e, t)), this;
  }
  translate(e, t) {
    const r = G.create(e, t);
    return this.points.forEach((i) => i.translate(r.x, r.y)), this;
  }
  round(e = 0) {
    return this.points.forEach((t) => t.round(e)), this;
  }
  bbox() {
    if (this.points.length === 0)
      return new Te();
    let e = 1 / 0, t = -1 / 0, r = 1 / 0, i = -1 / 0;
    const o = this.points;
    for (let a = 0, s = o.length; a < s; a += 1) {
      const l = o[a], u = l.x, c = l.y;
      u < e && (e = u), u > t && (t = u), c < r && (r = c), c > i && (i = c);
    }
    return new Te(e, r, t - e, i - r);
  }
  closestPoint(e) {
    const t = this.closestPointLength(e);
    return this.pointAtLength(t);
  }
  closestPointLength(e) {
    const t = this.points, r = t.length;
    if (r === 0 || r === 1)
      return 0;
    let i = 0, o = 0, a = 1 / 0;
    for (let s = 0, l = r - 1; s < l; s += 1) {
      const u = new Xe(t[s], t[s + 1]), c = u.length(), h = u.closestPointNormalizedLength(e), d = u.pointAt(h).squaredDistance(e);
      d < a && (a = d, o = i + h * c), i += c;
    }
    return o;
  }
  closestPointNormalizedLength(e) {
    const t = this.length();
    return t === 0 ? 0 : this.closestPointLength(e) / t;
  }
  closestPointTangent(e) {
    const t = this.closestPointLength(e);
    return this.tangentAtLength(t);
  }
  containsPoint(e) {
    if (this.points.length === 0)
      return !1;
    const t = G.clone(e), r = t.x, i = t.y, o = this.points, a = o.length;
    let s = a - 1, l = 0;
    for (let u = 0; u < a; u += 1) {
      const c = o[s], h = o[u];
      if (t.equals(c))
        return !0;
      const f = new Xe(c, h);
      if (f.containsPoint(e))
        return !0;
      if (i <= c.y && i > h.y || i > c.y && i <= h.y) {
        const d = c.x - r > h.x - r ? c.x - r : h.x - r;
        if (d >= 0) {
          const p = new G(r + d, i), g = new Xe(e, p);
          f.intersectsWithLine(g) && (l += 1);
        }
      }
      s = u;
    }
    return l % 2 === 1;
  }
  intersectsWithLine(e) {
    const t = [];
    for (let r = 0, i = this.points.length - 1; r < i; r += 1) {
      const o = this.points[r], a = this.points[r + 1], s = e.intersectsWithLine(new Xe(o, a));
      s && t.push(s);
    }
    return t.length > 0 ? t : null;
  }
  isDifferentiable() {
    for (let e = 0, t = this.points.length - 1; e < t; e += 1) {
      const r = this.points[e], i = this.points[e + 1];
      if (new Xe(r, i).isDifferentiable())
        return !0;
    }
    return !1;
  }
  length() {
    let e = 0;
    for (let t = 0, r = this.points.length - 1; t < r; t += 1) {
      const i = this.points[t], o = this.points[t + 1];
      e += i.distance(o);
    }
    return e;
  }
  pointAt(e) {
    const t = this.points, r = t.length;
    if (r === 0)
      return null;
    if (r === 1 || e <= 0)
      return t[0].clone();
    if (e >= 1)
      return t[r - 1].clone();
    const o = this.length() * e;
    return this.pointAtLength(o);
  }
  pointAtLength(e) {
    const t = this.points, r = t.length;
    if (r === 0)
      return null;
    if (r === 1)
      return t[0].clone();
    let i = !0;
    e < 0 && (i = !1, e = -e);
    let o = 0;
    for (let s = 0, l = r - 1; s < l; s += 1) {
      const u = i ? s : l - 1 - s, c = t[u], h = t[u + 1], f = new Xe(c, h), d = c.distance(h);
      if (e <= o + d)
        return f.pointAtLength((i ? 1 : -1) * (e - o));
      o += d;
    }
    return (i ? t[r - 1] : t[0]).clone();
  }
  tangentAt(e) {
    const r = this.points.length;
    if (r === 0 || r === 1)
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const o = this.length() * e;
    return this.tangentAtLength(o);
  }
  tangentAtLength(e) {
    const t = this.points, r = t.length;
    if (r === 0 || r === 1)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    let o, a = 0;
    for (let s = 0, l = r - 1; s < l; s += 1) {
      const u = i ? s : l - 1 - s, c = t[u], h = t[u + 1], f = new Xe(c, h), d = c.distance(h);
      if (f.isDifferentiable()) {
        if (e <= a + d)
          return f.tangentAtLength((i ? 1 : -1) * (e - a));
        o = f;
      }
      a += d;
    }
    if (o) {
      const s = i ? 1 : 0;
      return o.tangentAt(s);
    }
    return null;
  }
  simplify(e = {}) {
    const t = this.points;
    if (t.length < 3)
      return this;
    const r = e.threshold || 0;
    let i = 0;
    for (; t[i + 2]; ) {
      const o = i, a = i + 1, s = i + 2, l = t[o], u = t[a], c = t[s];
      new Xe(l, c).closestPoint(u).distance(u) <= r ? t.splice(a, 1) : i += 1;
    }
    return this;
  }
  toHull() {
    const e = this.points, t = e.length;
    if (t === 0)
      return new $m();
    let r = e[0];
    for (let f = 1; f < t; f += 1)
      (e[f].y < r.y || e[f].y === r.y && e[f].x > r.x) && (r = e[f]);
    const i = [];
    for (let f = 0; f < t; f += 1) {
      let d = r.theta(e[f]);
      d === 0 && (d = 360), i.push([e[f], f, d]);
    }
    if (i.sort((f, d) => {
      let p = f[2] - d[2];
      return p === 0 && (p = d[1] - f[1]), p;
    }), i.length > 2) {
      const f = i[i.length - 1];
      i.unshift(f);
    }
    const o = {}, a = [], s = (f) => `${f[0].toString()}@${f[1]}`;
    for (; i.length !== 0; ) {
      const f = i.pop(), d = f[0];
      if (o[s(f)])
        continue;
      let p = !1;
      for (; !p; )
        if (a.length < 2)
          a.push(f), p = !0;
        else {
          const g = a.pop(), v = g[0], m = a.pop(), y = m[0], b = y.cross(v, d);
          if (b < 0)
            a.push(m), a.push(g), a.push(f), p = !0;
          else if (b === 0) {
            const w = v.angleBetween(y, d);
            Math.abs(w - 180) < 1e-10 || v.equals(d) || y.equals(v) ? (o[s(g)] = v, a.push(m)) : Math.abs((w + 1) % 360 - 1) < 1e-10 && (a.push(m), i.push(g));
          } else
            o[s(g)] = v, a.push(m);
        }
    }
    a.length > 2 && a.pop();
    let l, u = -1;
    for (let f = 0, d = a.length; f < d; f += 1) {
      const p = a[f][1];
      (l === void 0 || p < l) && (l = p, u = f);
    }
    let c = [];
    if (u > 0) {
      const f = a.slice(u), d = a.slice(0, u);
      c = f.concat(d);
    } else
      c = a;
    const h = [];
    for (let f = 0, d = c.length; f < d; f += 1)
      h.push(c[f][0]);
    return new $m(h);
  }
  equals(e) {
    return e == null || e.points.length !== this.points.length ? !1 : e.points.every((t, r) => t.equals(this.points[r]));
  }
  clone() {
    return new $m(this.points.map((e) => e.clone()));
  }
  toJSON() {
    return this.points.map((e) => e.toJSON());
  }
  serialize() {
    return this.points.map((e) => `${e.serialize()}`).join(" ");
  }
};
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isPolyline = e;
})(Ii || (Ii = {}));
(function(n) {
  function e(t) {
    const r = t.trim();
    if (r === "")
      return new n();
    const i = [], o = r.split(/\s*,\s*|\s+/);
    for (let a = 0, s = o.length; a < s; a += 2)
      i.push({ x: +o[a], y: +o[a + 1] });
    return new n(i);
  }
  n.parse = e;
})(Ii || (Ii = {}));
class Jn extends lh {
  constructor(e, t, r, i) {
    super(), this.PRECISION = 3, this.start = G.create(e), this.controlPoint1 = G.create(t), this.controlPoint2 = G.create(r), this.end = G.create(i);
  }
  bbox() {
    const e = this.start, t = this.controlPoint1, r = this.controlPoint2, i = this.end, o = e.x, a = e.y, s = t.x, l = t.y, u = r.x, c = r.y, h = i.x, f = i.y, d = [], p = [[], []];
    let g, v, m, y, b, O, w, x;
    for (let M = 0; M < 2; M += 1) {
      if (M === 0 ? (v = 6 * o - 12 * s + 6 * u, g = -3 * o + 9 * s - 9 * u + 3 * h, m = 3 * s - 3 * o) : (v = 6 * a - 12 * l + 6 * c, g = -3 * a + 9 * l - 9 * c + 3 * f, m = 3 * l - 3 * a), Math.abs(g) < 1e-12) {
        if (Math.abs(v) < 1e-12)
          continue;
        y = -m / v, y > 0 && y < 1 && d.push(y);
        continue;
      }
      w = v * v - 4 * m * g, x = Math.sqrt(w), !(w < 0) && (b = (-v + x) / (2 * g), b > 0 && b < 1 && d.push(b), O = (-v - x) / (2 * g), O > 0 && O < 1 && d.push(O));
    }
    let S, _, C, A = d.length;
    const k = A;
    for (; A; )
      A -= 1, y = d[A], C = 1 - y, S = C * C * C * o + 3 * C * C * y * s + 3 * C * y * y * u + y * y * y * h, p[0][A] = S, _ = C * C * C * a + 3 * C * C * y * l + 3 * C * y * y * c + y * y * y * f, p[1][A] = _;
    d[k] = 0, d[k + 1] = 1, p[0][k] = o, p[1][k] = a, p[0][k + 1] = h, p[1][k + 1] = f, d.length = k + 2, p[0].length = k + 2, p[1].length = k + 2;
    const P = Math.min.apply(null, p[0]), L = Math.min.apply(null, p[1]), D = Math.max.apply(null, p[0]), E = Math.max.apply(null, p[1]);
    return new Te(P, L, D - P, E - L);
  }
  closestPoint(e, t = {}) {
    return this.pointAtT(this.closestPointT(e, t));
  }
  closestPointLength(e, t = {}) {
    const r = this.getOptions(t);
    return this.lengthAtT(this.closestPointT(e, r), r);
  }
  closestPointNormalizedLength(e, t = {}) {
    const r = this.getOptions(t), i = this.closestPointLength(e, r);
    if (!i)
      return 0;
    const o = this.length(r);
    return o === 0 ? 0 : i / o;
  }
  closestPointT(e, t = {}) {
    const r = this.getPrecision(t), i = this.getDivisions(t), o = Math.pow(10, -r);
    let a = null, s = 0, l = 0, u = 0, c = 0, h = 0, f = null;
    const d = i.length;
    let p = d > 0 ? 1 / d : 0;
    for (i.forEach((g, v) => {
      const m = g.start.distance(e), y = g.end.distance(e), b = m + y;
      (f == null || b < f) && (a = g, s = v * p, l = (v + 1) * p, u = m, c = y, f = b, h = g.endpointDistance());
    }); ; ) {
      const g = u ? Math.abs(u - c) / u : 0, v = c != null ? Math.abs(u - c) / c : 0, m = g < o || v < o, y = u ? u < h * o : !0, b = c ? c < h * o : !0;
      if (m || (y || b))
        return u <= c ? s : l;
      const w = a.divide(0.5);
      p /= 2;
      const x = w[0].start.distance(e), S = w[0].end.distance(e), _ = x + S, C = w[1].start.distance(e), A = w[1].end.distance(e), k = C + A;
      _ <= k ? (a = w[0], l -= p, u = x, c = S) : (a = w[1], s += p, u = C, c = A);
    }
  }
  closestPointTangent(e, t = {}) {
    return this.tangentAtT(this.closestPointT(e, t));
  }
  containsPoint(e, t = {}) {
    return this.toPolyline(t).containsPoint(e);
  }
  divideAt(e, t = {}) {
    if (e <= 0)
      return this.divideAtT(0);
    if (e >= 1)
      return this.divideAtT(1);
    const r = this.tAt(e, t);
    return this.divideAtT(r);
  }
  divideAtLength(e, t = {}) {
    const r = this.tAtLength(e, t);
    return this.divideAtT(r);
  }
  divide(e) {
    return this.divideAtT(e);
  }
  divideAtT(e) {
    const t = this.start, r = this.controlPoint1, i = this.controlPoint2, o = this.end;
    if (e <= 0)
      return [
        new Jn(t, t, t, t),
        new Jn(t, r, i, o)
      ];
    if (e >= 1)
      return [
        new Jn(t, r, i, o),
        new Jn(o, o, o, o)
      ];
    const a = this.getSkeletonPoints(e), s = a.startControlPoint1, l = a.startControlPoint2, u = a.divider, c = a.dividerControlPoint1, h = a.dividerControlPoint2;
    return [
      new Jn(t, s, l, u),
      new Jn(u, c, h, o)
    ];
  }
  endpointDistance() {
    return this.start.distance(this.end);
  }
  getSkeletonPoints(e) {
    const t = this.start, r = this.controlPoint1, i = this.controlPoint2, o = this.end;
    if (e <= 0)
      return {
        startControlPoint1: t.clone(),
        startControlPoint2: t.clone(),
        divider: t.clone(),
        dividerControlPoint1: r.clone(),
        dividerControlPoint2: i.clone()
      };
    if (e >= 1)
      return {
        startControlPoint1: r.clone(),
        startControlPoint2: i.clone(),
        divider: o.clone(),
        dividerControlPoint1: o.clone(),
        dividerControlPoint2: o.clone()
      };
    const a = new Xe(t, r).pointAt(e), s = new Xe(r, i).pointAt(e), l = new Xe(i, o).pointAt(e), u = new Xe(a, s).pointAt(e), c = new Xe(s, l).pointAt(e), h = new Xe(u, c).pointAt(e);
    return {
      startControlPoint1: a,
      startControlPoint2: u,
      divider: h,
      dividerControlPoint1: c,
      dividerControlPoint2: l
    };
  }
  getSubdivisions(e = {}) {
    const t = this.getPrecision(e);
    let r = [
      new Jn(this.start, this.controlPoint1, this.controlPoint2, this.end)
    ];
    if (t === 0)
      return r;
    let i = this.endpointDistance();
    const o = Math.pow(10, -t);
    let a = 0;
    for (; ; ) {
      a += 1;
      const s = [];
      r.forEach((c) => {
        const h = c.divide(0.5);
        s.push(h[0], h[1]);
      });
      const l = s.reduce((c, h) => c + h.endpointDistance(), 0), u = l !== 0 ? (l - i) / l : 0;
      if (a > 1 && u < o)
        return s;
      r = s, i = l;
    }
  }
  length(e = {}) {
    return this.getDivisions(e).reduce((r, i) => r + i.endpointDistance(), 0);
  }
  lengthAtT(e, t = {}) {
    if (e <= 0)
      return 0;
    const r = t.precision === void 0 ? this.PRECISION : t.precision;
    return this.divide(e)[0].length({ precision: r });
  }
  pointAt(e, t = {}) {
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const r = this.tAt(e, t);
    return this.pointAtT(r);
  }
  pointAtLength(e, t = {}) {
    const r = this.tAtLength(e, t);
    return this.pointAtT(r);
  }
  pointAtT(e) {
    return e <= 0 ? this.start.clone() : e >= 1 ? this.end.clone() : this.getSkeletonPoints(e).divider;
  }
  isDifferentiable() {
    const e = this.start, t = this.controlPoint1, r = this.controlPoint2, i = this.end;
    return !(e.equals(t) && t.equals(r) && r.equals(i));
  }
  tangentAt(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    e < 0 ? e = 0 : e > 1 && (e = 1);
    const r = this.tAt(e, t);
    return this.tangentAtT(r);
  }
  tangentAtLength(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    const r = this.tAtLength(e, t);
    return this.tangentAtT(r);
  }
  tangentAtT(e) {
    if (!this.isDifferentiable())
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const t = this.getSkeletonPoints(e), r = t.startControlPoint2, i = t.dividerControlPoint1, o = t.divider, a = new Xe(r, i);
    return a.translate(o.x - r.x, o.y - r.y), a;
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getDivisions(e = {}) {
    if (e.subdivisions != null)
      return e.subdivisions;
    const t = this.getPrecision(e);
    return this.getSubdivisions({ precision: t });
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), r = this.getDivisions(e);
    return { precision: t, subdivisions: r };
  }
  tAt(e, t = {}) {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const r = this.getOptions(t), o = this.length(r) * e;
    return this.tAtLength(o, r);
  }
  tAtLength(e, t = {}) {
    let r = !0;
    e < 0 && (r = !1, e = -e);
    const i = this.getPrecision(t), o = this.getDivisions(t), a = { precision: i, subdivisions: o };
    let s = null, l, u, c = 0, h = 0, f = 0;
    const d = o.length;
    let p = d > 0 ? 1 / d : 0;
    for (let m = 0; m < d; m += 1) {
      const y = r ? m : d - 1 - m, b = o[m], O = b.endpointDistance();
      if (e <= f + O) {
        s = b, l = y * p, u = (y + 1) * p, c = r ? e - f : O + f - e, h = r ? O + f - e : e - f;
        break;
      }
      f += O;
    }
    if (s == null)
      return r ? 1 : 0;
    const g = this.length(a), v = Math.pow(10, -i);
    for (; ; ) {
      let m;
      if (m = g !== 0 ? c / g : 0, m < v)
        return l;
      if (m = g !== 0 ? h / g : 0, m < v)
        return u;
      let y, b;
      const O = s.divide(0.5);
      p /= 2;
      const w = O[0].endpointDistance(), x = O[1].endpointDistance();
      c <= w ? (s = O[0], u -= p, y = c, b = w - y) : (s = O[1], l += p, y = c - w, b = x - y), c = y, h = b;
    }
  }
  toPoints(e = {}) {
    const t = this.getDivisions(e), r = [t[0].start.clone()];
    return t.forEach((i) => r.push(i.end.clone())), r;
  }
  toPolyline(e = {}) {
    return new Ii(this.toPoints(e));
  }
  scale(e, t, r) {
    return this.start.scale(e, t, r), this.controlPoint1.scale(e, t, r), this.controlPoint2.scale(e, t, r), this.end.scale(e, t, r), this;
  }
  rotate(e, t) {
    return this.start.rotate(e, t), this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return e != null && this.start.equals(e.start) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2) && this.end.equals(e.end);
  }
  clone() {
    return new Jn(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return [
      this.start.serialize(),
      this.controlPoint1.serialize(),
      this.controlPoint2.serialize(),
      this.end.serialize()
    ].join(" ");
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isCurve = e;
})(Jn || (Jn = {}));
(function(n) {
  function e(i) {
    const o = i.length, a = [], s = [];
    let l = 2;
    a[0] = i[0] / l;
    for (let u = 1; u < o; u += 1)
      s[u] = 1 / l, l = (u < o - 1 ? 4 : 3.5) - s[u], a[u] = (i[u] - a[u - 1]) / l;
    for (let u = 1; u < o; u += 1)
      a[o - u - 1] -= s[o - u] * a[o - u];
    return a;
  }
  function t(i) {
    const o = i.map((f) => G.clone(f)), a = [], s = [], l = o.length - 1;
    if (l === 1)
      return a[0] = new G((2 * o[0].x + o[1].x) / 3, (2 * o[0].y + o[1].y) / 3), s[0] = new G(2 * a[0].x - o[0].x, 2 * a[0].y - o[0].y), [a, s];
    const u = [];
    for (let f = 1; f < l - 1; f += 1)
      u[f] = 4 * o[f].x + 2 * o[f + 1].x;
    u[0] = o[0].x + 2 * o[1].x, u[l - 1] = (8 * o[l - 1].x + o[l].x) / 2;
    const c = e(u);
    for (let f = 1; f < l - 1; f += 1)
      u[f] = 4 * o[f].y + 2 * o[f + 1].y;
    u[0] = o[0].y + 2 * o[1].y, u[l - 1] = (8 * o[l - 1].y + o[l].y) / 2;
    const h = e(u);
    for (let f = 0; f < l; f += 1)
      a.push(new G(c[f], h[f])), f < l - 1 ? s.push(new G(2 * o[f + 1].x - c[f + 1], 2 * o[f + 1].y - h[f + 1])) : s.push(new G((o[l].x + c[l - 1]) / 2, (o[l].y + h[l - 1]) / 2));
    return [a, s];
  }
  function r(i) {
    if (i == null || Array.isArray(i) && i.length < 2)
      throw new Error("At least 2 points are required");
    const o = t(i), a = [];
    for (let s = 0, l = o[0].length; s < l; s += 1) {
      const u = new G(o[0][s].x, o[0][s].y), c = new G(o[1][s].x, o[1][s].y);
      a.push(new n(i[s], u, c, i[s + 1]));
    }
    return a;
  }
  n.throughPoints = r;
})(Jn || (Jn = {}));
class P_ extends lh {
  constructor() {
    super(...arguments), this.isVisible = !0, this.isSegment = !0, this.isSubpathStart = !1;
  }
  get end() {
    return this.endPoint;
  }
  get start() {
    if (this.previousSegment == null)
      throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");
    return this.previousSegment.end;
  }
  closestPointT(e, t) {
    if (this.closestPointNormalizedLength)
      return this.closestPointNormalizedLength(e);
    throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.");
  }
  // eslint-disable-next-line
  lengthAtT(e, t) {
    if (e <= 0)
      return 0;
    const r = this.length();
    return e >= 1 ? r : r * e;
  }
  divideAtT(e) {
    if (this.divideAt)
      return this.divideAt(e);
    throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.");
  }
  pointAtT(e) {
    if (this.pointAt)
      return this.pointAt(e);
    throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.");
  }
  tangentAtT(e) {
    if (this.tangentAt)
      return this.tangentAt(e);
    throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.");
  }
}
class Mi extends P_ {
  constructor(e, t) {
    super(), Xe.isLine(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = G.create(e, t).round(2);
  }
  get type() {
    return "L";
  }
  get line() {
    return new Xe(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [new Mi(t[0]), new Mi(t[1])];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [new Mi(t[0]), new Mi(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return this.previousSegment == null ? !1 : !this.start.equals(this.end);
  }
  clone() {
    return new Mi(this.end);
  }
  scale(e, t, r) {
    return this.end.scale(e, t, r), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return `${this.type} ${e.x} ${e.y}`;
  }
}
(function(n) {
  function e(...t) {
    const r = t.length, i = t[0];
    if (Xe.isLine(i))
      return new n(i);
    if (G.isPointLike(i))
      return r === 1 ? new n(i) : t.map((a) => new n(a));
    if (r === 2)
      return new n(+t[0], +t[1]);
    const o = [];
    for (let a = 0; a < r; a += 2) {
      const s = +t[a], l = +t[a + 1];
      o.push(new n(s, l));
    }
    return o;
  }
  n.create = e;
})(Mi || (Mi = {}));
class Cg extends P_ {
  get end() {
    if (!this.subpathStartSegment)
      throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");
    return this.subpathStartSegment.end;
  }
  get type() {
    return "Z";
  }
  get line() {
    return new Xe(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [
      // do not actually cut into the segment, first divided part can stay as Z
      t[1].isDifferentiable() ? new Mi(t[0]) : this.clone(),
      new Mi(t[1])
    ];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [
      t[1].isDifferentiable() ? new Mi(t[0]) : this.clone(),
      new Mi(t[1])
    ];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return !this.previousSegment || !this.subpathStartSegment ? !1 : !this.start.equals(this.end);
  }
  scale() {
    return this;
  }
  rotate() {
    return this;
  }
  translate() {
    return this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  clone() {
    return new Cg();
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return this.type;
  }
}
(function(n) {
  function e() {
    return new n();
  }
  n.create = e;
})(Cg || (Cg = {}));
class Ag extends P_ {
  constructor(e, t) {
    super(), this.isVisible = !1, this.isSubpathStart = !0, Xe.isLine(e) || Jn.isCurve(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = G.create(e, t).round(2);
  }
  get start() {
    throw new Error("Illegal access. Moveto segments should not need a start property.");
  }
  get type() {
    return "M";
  }
  bbox() {
    return null;
  }
  closestPoint() {
    return this.end.clone();
  }
  closestPointLength() {
    return 0;
  }
  closestPointNormalizedLength() {
    return 0;
  }
  closestPointT() {
    return 1;
  }
  closestPointTangent() {
    return null;
  }
  length() {
    return 0;
  }
  lengthAtT() {
    return 0;
  }
  divideAt() {
    return [this.clone(), this.clone()];
  }
  divideAtLength() {
    return [this.clone(), this.clone()];
  }
  getSubdivisions() {
    return [];
  }
  pointAt() {
    return this.end.clone();
  }
  pointAtLength() {
    return this.end.clone();
  }
  pointAtT() {
    return this.end.clone();
  }
  tangentAt() {
    return null;
  }
  tangentAtLength() {
    return null;
  }
  tangentAtT() {
    return null;
  }
  isDifferentiable() {
    return !1;
  }
  scale(e, t, r) {
    return this.end.scale(e, t, r), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  clone() {
    return new Ag(this.end);
  }
  equals(e) {
    return this.type === e.type && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return `${this.type} ${e.x} ${e.y}`;
  }
}
(function(n) {
  function e(...t) {
    const r = t.length, i = t[0];
    if (Xe.isLine(i))
      return new n(i);
    if (Jn.isCurve(i))
      return new n(i);
    if (G.isPointLike(i)) {
      if (r === 1)
        return new n(i);
      const a = [];
      for (let s = 0; s < r; s += 1)
        s === 0 ? a.push(new n(t[s])) : a.push(new Mi(t[s]));
      return a;
    }
    if (r === 2)
      return new n(+t[0], +t[1]);
    const o = [];
    for (let a = 0; a < r; a += 2) {
      const s = +t[a], l = +t[a + 1];
      a === 0 ? o.push(new n(s, l)) : o.push(new Mi(s, l));
    }
    return o;
  }
  n.create = e;
})(Ag || (Ag = {}));
class ha extends P_ {
  constructor(e, t, r, i, o, a) {
    super(), Jn.isCurve(e) ? (this.controlPoint1 = e.controlPoint1.clone().round(2), this.controlPoint2 = e.controlPoint2.clone().round(2), this.endPoint = e.end.clone().round(2)) : typeof e == "number" ? (this.controlPoint1 = new G(e, t).round(2), this.controlPoint2 = new G(r, i).round(2), this.endPoint = new G(o, a).round(2)) : (this.controlPoint1 = G.create(e).round(2), this.controlPoint2 = G.create(t).round(2), this.endPoint = G.create(r).round(2));
  }
  get type() {
    return "C";
  }
  get curve() {
    return new Jn(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  bbox() {
    return this.curve.bbox();
  }
  closestPoint(e) {
    return this.curve.closestPoint(e);
  }
  closestPointLength(e) {
    return this.curve.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.curve.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.curve.closestPointTangent(e);
  }
  length() {
    return this.curve.length();
  }
  divideAt(e, t = {}) {
    const r = this.curve.divideAt(e, t);
    return [new ha(r[0]), new ha(r[1])];
  }
  divideAtLength(e, t = {}) {
    const r = this.curve.divideAtLength(e, t);
    return [new ha(r[0]), new ha(r[1])];
  }
  divideAtT(e) {
    const t = this.curve.divideAtT(e);
    return [new ha(t[0]), new ha(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.curve.pointAt(e);
  }
  pointAtLength(e) {
    return this.curve.pointAtLength(e);
  }
  tangentAt(e) {
    return this.curve.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.curve.tangentAtLength(e);
  }
  isDifferentiable() {
    if (!this.previousSegment)
      return !1;
    const e = this.start, t = this.controlPoint1, r = this.controlPoint2, i = this.end;
    return !(e.equals(t) && t.equals(r) && r.equals(i));
  }
  scale(e, t, r) {
    return this.controlPoint1.scale(e, t, r), this.controlPoint2.scale(e, t, r), this.end.scale(e, t, r), this;
  }
  rotate(e, t) {
    return this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return this.start.equals(e.start) && this.end.equals(e.end) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2);
  }
  clone() {
    return new ha(this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.controlPoint1, t = this.controlPoint2, r = this.end;
    return [this.type, e.x, e.y, t.x, t.y, r.x, r.y].join(" ");
  }
}
(function(n) {
  function e(...t) {
    const r = t.length, i = t[0];
    if (Jn.isCurve(i))
      return new n(i);
    if (G.isPointLike(i)) {
      if (r === 3)
        return new n(t[0], t[1], t[2]);
      const a = [];
      for (let s = 0; s < r; s += 3)
        a.push(new n(t[s], t[s + 1], t[s + 2]));
      return a;
    }
    if (r === 6)
      return new n(t[0], t[1], t[2], t[3], t[4], t[5]);
    const o = [];
    for (let a = 0; a < r; a += 6)
      o.push(new n(t[a], t[a + 1], t[a + 2], t[a + 3], t[a + 4], t[a + 5]));
    return o;
  }
  n.create = e;
})(ha || (ha = {}));
function b1(n, e, t) {
  return {
    x: n * Math.cos(t) - e * Math.sin(t),
    y: n * Math.sin(t) + e * Math.cos(t)
  };
}
function r5(n, e, t, r, i, o) {
  const a = 0.3333333333333333, s = 2 / 3;
  return [
    a * n + s * t,
    a * e + s * r,
    a * i + s * t,
    a * o + s * r,
    i,
    o
  ];
}
function Vq(n, e, t, r, i, o, a, s, l, u) {
  const c = Math.PI * 120 / 180, h = Math.PI / 180 * (+i || 0);
  let f = [], d, p, g, v, m;
  if (u)
    p = u[0], g = u[1], v = u[2], m = u[3];
  else {
    d = b1(n, e, -h), n = d.x, e = d.y, d = b1(s, l, -h), s = d.x, l = d.y;
    const D = (n - s) / 2, E = (e - l) / 2;
    let M = D * D / (t * t) + E * E / (r * r);
    M > 1 && (M = Math.sqrt(M), t = M * t, r = M * r);
    const R = t * t, N = r * r, $ = (o === a ? -1 : 1) * Math.sqrt(Math.abs((R * N - R * E * E - N * D * D) / (R * E * E + N * D * D)));
    v = $ * t * E / r + (n + s) / 2, m = $ * -r * D / t + (e + l) / 2, p = Math.asin((e - m) / r), g = Math.asin((l - m) / r), p = n < v ? Math.PI - p : p, g = s < v ? Math.PI - g : g, p < 0 && (p = Math.PI * 2 + p), g < 0 && (g = Math.PI * 2 + g), a && p > g && (p -= Math.PI * 2), !a && g > p && (g -= Math.PI * 2);
  }
  let y = g - p;
  if (Math.abs(y) > c) {
    const D = g, E = s, M = l;
    g = p + c * (a && g > p ? 1 : -1), s = v + t * Math.cos(g), l = m + r * Math.sin(g), f = Vq(s, l, t, r, i, 0, a, E, M, [
      g,
      D,
      v,
      m
    ]);
  }
  y = g - p;
  const b = Math.cos(p), O = Math.sin(p), w = Math.cos(g), x = Math.sin(g), S = Math.tan(y / 4), _ = 4 / 3 * (t * S), C = 4 / 3 * (r * S), A = [n, e], k = [n + _ * O, e - C * b], P = [s + _ * x, l - C * w], L = [s, l];
  if (k[0] = 2 * A[0] - k[0], k[1] = 2 * A[1] - k[1], u)
    return [k, P, L].concat(f);
  {
    f = [k, P, L].concat(f).join().split(",");
    const D = [], E = f.length;
    for (let M = 0; M < E; M += 1)
      D[M] = M % 2 ? b1(+f[M - 1], +f[M], h).y : b1(+f[M], +f[M + 1], h).x;
    return D;
  }
}
function hAe(n) {
  if (!n)
    return null;
  const e = `	
\v\f\r   ᠎             　\u2028\u2029`, t = new RegExp(
    `([a-z])[${e},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${e}]*,?[${e}]*)+)`,
    // eslint-disable-line
    "ig"
  ), r = new RegExp(
    // eslint-disable-next-line
    `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${e}]*,?[${e}]*`,
    "ig"
  ), i = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  }, o = [];
  return n.replace(t, (a, s, l) => {
    const u = [];
    let c = s.toLowerCase();
    l.replace(r, (f, d) => (d && u.push(+d), f)), c === "m" && u.length > 2 && (o.push([s, ...u.splice(0, 2)]), c = "l", s = s === "m" ? "l" : "L");
    const h = i[c];
    for (; u.length >= h && (o.push([s, ...u.splice(0, h)]), !!h); )
      ;
    return a;
  }), o;
}
function fAe(n) {
  const e = hAe(n);
  if (!e || !e.length)
    return [["M", 0, 0]];
  let t = 0, r = 0, i = 0, o = 0;
  const a = [];
  for (let s = 0, l = e.length; s < l; s += 1) {
    const u = [];
    a.push(u);
    const c = e[s], h = c[0];
    if (h !== h.toUpperCase())
      switch (u[0] = h.toUpperCase(), u[0]) {
        case "A":
          u[1] = c[1], u[2] = c[2], u[3] = c[3], u[4] = c[4], u[5] = c[5], u[6] = +c[6] + t, u[7] = +c[7] + r;
          break;
        case "V":
          u[1] = +c[1] + r;
          break;
        case "H":
          u[1] = +c[1] + t;
          break;
        case "M":
          i = +c[1] + t, o = +c[2] + r;
          for (let f = 1, d = c.length; f < d; f += 1)
            u[f] = +c[f] + (f % 2 ? t : r);
          break;
        default:
          for (let f = 1, d = c.length; f < d; f += 1)
            u[f] = +c[f] + (f % 2 ? t : r);
          break;
      }
    else
      for (let f = 0, d = c.length; f < d; f += 1)
        u[f] = c[f];
    switch (u[0]) {
      case "Z":
        t = +i, r = +o;
        break;
      case "H":
        t = u[1];
        break;
      case "V":
        r = u[1];
        break;
      case "M":
        i = u[u.length - 2], o = u[u.length - 1], t = u[u.length - 2], r = u[u.length - 1];
        break;
      default:
        t = u[u.length - 2], r = u[u.length - 1];
        break;
    }
  }
  return a;
}
function dAe(n) {
  const e = fAe(n), t = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
  function r(l, u, c) {
    let h, f;
    if (!l)
      return ["C", u.x, u.y, u.x, u.y, u.x, u.y];
    switch (l[0] in { T: 1, Q: 1 } || (u.qx = null, u.qy = null), l[0]) {
      case "M":
        u.X = l[1], u.Y = l[2];
        break;
      case "A":
        return parseFloat(l[1]) === 0 || parseFloat(l[2]) === 0 ? ["L", l[6], l[7]] : ["C"].concat(Vq.apply(0, [u.x, u.y].concat(l.slice(1))));
      case "S":
        return c === "C" || c === "S" ? (h = u.x * 2 - u.bx, f = u.y * 2 - u.by) : (h = u.x, f = u.y), ["C", h, f].concat(l.slice(1));
      case "T":
        return c === "Q" || c === "T" ? (u.qx = u.x * 2 - u.qx, u.qy = u.y * 2 - u.qy) : (u.qx = u.x, u.qy = u.y), ["C"].concat(r5(u.x, u.y, u.qx, u.qy, l[1], l[2]));
      case "Q":
        return u.qx = l[1], u.qy = l[2], ["C"].concat(r5(u.x, u.y, l[1], l[2], l[3], l[4]));
      case "H":
        return ["L"].concat(l[1], u.y);
      case "V":
        return ["L"].concat(u.x, l[1]);
    }
    return l;
  }
  function i(l, u) {
    if (l[u].length > 7) {
      l[u].shift();
      const c = l[u];
      for (; c.length; )
        o[u] = "A", u += 1, l.splice(u, 0, ["C"].concat(c.splice(0, 6)));
      l.splice(u, 1), s = e.length;
    }
  }
  const o = [];
  let a = "", s = e.length;
  for (let l = 0; l < s; l += 1) {
    let u = "";
    e[l] && (u = e[l][0]), u !== "C" && (o[l] = u, l > 0 && (a = o[l - 1])), e[l] = r(e[l], t, a), o[l] !== "A" && u === "C" && (o[l] = "C"), i(e, l);
    const c = e[l], h = c.length;
    t.x = c[h - 2], t.y = c[h - 1], t.bx = parseFloat(c[h - 4]) || t.x, t.by = parseFloat(c[h - 3]) || t.y;
  }
  return (!e[0][0] || e[0][0] !== "M") && e.unshift(["M", 0, 0]), e;
}
function pAe(n) {
  return dAe(n).map((e) => e.map((t) => typeof t == "string" ? t : rn.round(t, 2))).join(",").split(",").join(" ");
}
let Bt = class Wr extends lh {
  constructor(e) {
    if (super(), this.PRECISION = 3, this.segments = [], Array.isArray(e))
      if (Xe.isLine(e[0]) || Jn.isCurve(e[0])) {
        let t = null;
        e.forEach((i, o) => {
          o === 0 && this.appendSegment(Wr.createSegment("M", i.start)), t != null && !t.end.equals(i.start) && this.appendSegment(Wr.createSegment("M", i.start)), Xe.isLine(i) ? this.appendSegment(Wr.createSegment("L", i.end)) : Jn.isCurve(i) && this.appendSegment(Wr.createSegment("C", i.controlPoint1, i.controlPoint2, i.end)), t = i;
        });
      } else
        e.forEach((r) => {
          r.isSegment && this.appendSegment(r);
        });
    else
      e != null && (Xe.isLine(e) ? (this.appendSegment(Wr.createSegment("M", e.start)), this.appendSegment(Wr.createSegment("L", e.end))) : Jn.isCurve(e) ? (this.appendSegment(Wr.createSegment("M", e.start)), this.appendSegment(Wr.createSegment("C", e.controlPoint1, e.controlPoint2, e.end))) : Ii.isPolyline(e) ? e.points && e.points.length && e.points.forEach((t, r) => {
        const i = r === 0 ? Wr.createSegment("M", t) : Wr.createSegment("L", t);
        this.appendSegment(i);
      }) : e.isSegment && this.appendSegment(e));
  }
  get start() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let r = 0; r < t; r += 1) {
      const i = e[r];
      if (i.isVisible)
        return i.start;
    }
    return e[t - 1].end;
  }
  get end() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let r = t - 1; r >= 0; r -= 1) {
      const i = e[r];
      if (i.isVisible)
        return i.end;
    }
    return e[t - 1].end;
  }
  moveTo(...e) {
    return this.appendSegment(Ag.create.call(null, ...e));
  }
  lineTo(...e) {
    return this.appendSegment(Mi.create.call(null, ...e));
  }
  curveTo(...e) {
    return this.appendSegment(ha.create.call(null, ...e));
  }
  arcTo(e, t, r, i, o, a, s) {
    const l = this.end || new G(), u = typeof a == "number" ? Ox(l.x, l.y, e, t, r, i, o, a, s) : Ox(l.x, l.y, e, t, r, i, o, a.x, a.y);
    if (u != null)
      for (let c = 0, h = u.length; c < h; c += 6)
        this.curveTo(u[c], u[c + 1], u[c + 2], u[c + 3], u[c + 4], u[c + 5]);
    return this;
  }
  quadTo(e, t, r, i) {
    const o = this.end || new G(), a = ["M", o.x, o.y];
    if (typeof e == "number")
      a.push("Q", e, t, r, i);
    else {
      const l = t;
      a.push("Q", e.x, e.y, l.x, l.y);
    }
    const s = Wr.parse(a.join(" "));
    return this.appendSegment(s.segments.slice(1)), this;
  }
  close() {
    return this.appendSegment(Cg.create());
  }
  drawPoints(e, t = {}) {
    const r = Bq(e, t), i = Wr.parse(r);
    i && i.segments && this.appendSegment(i.segments);
  }
  bbox() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    let r;
    for (let o = 0; o < t; o += 1) {
      const a = e[o];
      if (a.isVisible) {
        const s = a.bbox();
        s != null && (r = r ? r.union(s) : s);
      }
    }
    if (r != null)
      return r;
    const i = e[t - 1];
    return new Te(i.end.x, i.end.y, 0, 0);
  }
  appendSegment(e) {
    const t = this.segments.length;
    let r = t !== 0 ? this.segments[t - 1] : null, i;
    const o = null;
    if (Array.isArray(e))
      for (let a = 0, s = e.length; a < s; a += 1) {
        const l = e[a];
        i = this.prepareSegment(l, r, o), this.segments.push(i), r = i;
      }
    else
      e != null && e.isSegment && (i = this.prepareSegment(e, r, o), this.segments.push(i));
    return this;
  }
  insertSegment(e, t) {
    const r = this.segments.length;
    if (e < 0 && (e = r + e + 1), e > r || e < 0)
      throw new Error("Index out of range.");
    let i, o = null, a = null;
    if (r !== 0 && (e >= 1 ? (o = this.segments[e - 1], a = o.nextSegment) : (o = null, a = this.segments[0])), !Array.isArray(t))
      i = this.prepareSegment(t, o, a), this.segments.splice(e, 0, i);
    else
      for (let s = 0, l = t.length; s < l; s += 1) {
        const u = t[s];
        i = this.prepareSegment(u, o, a), this.segments.splice(e + s, 0, i), o = i;
      }
    return this;
  }
  removeSegment(e) {
    const t = this.fixIndex(e), r = this.segments.splice(t, 1)[0], i = r.previousSegment, o = r.nextSegment;
    return i && (i.nextSegment = o), o && (o.previousSegment = i), r.isSubpathStart && o && this.updateSubpathStartSegment(o), r;
  }
  replaceSegment(e, t) {
    const r = this.fixIndex(e);
    let i;
    const o = this.segments[r];
    let a = o.previousSegment;
    const s = o.nextSegment;
    let l = o.isSubpathStart;
    if (!Array.isArray(t))
      i = this.prepareSegment(t, a, s), this.segments.splice(r, 1, i), l && i.isSubpathStart && (l = !1);
    else {
      this.segments.splice(e, 1);
      for (let u = 0, c = t.length; u < c; u += 1) {
        const h = t[u];
        i = this.prepareSegment(h, a, s), this.segments.splice(e + u, 0, i), a = i, l && i.isSubpathStart && (l = !1);
      }
    }
    l && s && this.updateSubpathStartSegment(s);
  }
  getSegment(e) {
    const t = this.fixIndex(e);
    return this.segments[t];
  }
  fixIndex(e) {
    const t = this.segments.length;
    if (t === 0)
      throw new Error("Path has no segments.");
    let r = e;
    for (; r < 0; )
      r = t + r;
    if (r >= t || r < 0)
      throw new Error("Index out of range.");
    return r;
  }
  segmentAt(e, t = {}) {
    const r = this.segmentIndexAt(e, t);
    return r ? this.getSegment(r) : null;
  }
  segmentAtLength(e, t = {}) {
    const r = this.segmentIndexAtLength(e, t);
    return r ? this.getSegment(r) : null;
  }
  segmentIndexAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const r = rn.clamp(e, 0, 1), i = this.getOptions(t), a = this.length(i) * r;
    return this.segmentIndexAtLength(a, i);
  }
  segmentIndexAtLength(e, t = {}) {
    const r = this.segments.length;
    if (r === 0)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const o = this.getPrecision(t), a = this.getSubdivisions(t);
    let s = 0, l = null;
    for (let u = 0; u < r; u += 1) {
      const c = i ? u : r - 1 - u, h = this.segments[c], f = a[c], d = h.length({ precision: o, subdivisions: f });
      if (h.isVisible) {
        if (e <= s + d)
          return c;
        l = c;
      }
      s += d;
    }
    return l;
  }
  getSegmentSubdivisions(e = {}) {
    const t = this.getPrecision(e), r = [];
    for (let i = 0, o = this.segments.length; i < o; i += 1) {
      const s = this.segments[i].getSubdivisions({ precision: t });
      r.push(s);
    }
    return r;
  }
  updateSubpathStartSegment(e) {
    let t = e.previousSegment, r = e;
    for (; r && !r.isSubpathStart; )
      t != null ? r.subpathStartSegment = t.subpathStartSegment : r.subpathStartSegment = null, t = r, r = r.nextSegment;
  }
  prepareSegment(e, t, r) {
    e.previousSegment = t, e.nextSegment = r, t != null && (t.nextSegment = e), r != null && (r.previousSegment = e);
    let i = e;
    return e.isSubpathStart && (e.subpathStartSegment = e, i = r), i != null && this.updateSubpathStartSegment(i), e;
  }
  closestPoint(e, t = {}) {
    const r = this.closestPointT(e, t);
    return r ? this.pointAtT(r) : null;
  }
  closestPointLength(e, t = {}) {
    const r = this.getOptions(t), i = this.closestPointT(e, r);
    return i ? this.lengthAtT(i, r) : 0;
  }
  closestPointNormalizedLength(e, t = {}) {
    const r = this.getOptions(t), i = this.closestPointLength(e, r);
    if (i === 0)
      return 0;
    const o = this.length(r);
    return o === 0 ? 0 : i / o;
  }
  closestPointT(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const r = this.getPrecision(t), i = this.getSubdivisions(t);
    let o, a = 1 / 0;
    for (let s = 0, l = this.segments.length; s < l; s += 1) {
      const u = this.segments[s], c = i[s];
      if (u.isVisible) {
        const h = u.closestPointT(e, {
          precision: r,
          subdivisions: c
        }), f = u.pointAtT(h), d = rn.squaredLength(f, e);
        d < a && (o = { segmentIndex: s, value: h }, a = d);
      }
    }
    return o || { segmentIndex: this.segments.length - 1, value: 1 };
  }
  closestPointTangent(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const r = this.getPrecision(t), i = this.getSubdivisions(t);
    let o, a = 1 / 0;
    for (let s = 0, l = this.segments.length; s < l; s += 1) {
      const u = this.segments[s], c = i[s];
      if (u.isDifferentiable()) {
        const h = u.closestPointT(e, {
          precision: r,
          subdivisions: c
        }), f = u.pointAtT(h), d = rn.squaredLength(f, e);
        d < a && (o = u.tangentAtT(h), a = d);
      }
    }
    return o || null;
  }
  containsPoint(e, t = {}) {
    const r = this.toPolylines(t);
    if (!r)
      return !1;
    let i = 0;
    for (let o = 0, a = r.length; o < a; o += 1)
      r[o].containsPoint(e) && (i += 1);
    return i % 2 === 1;
  }
  pointAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const r = this.getOptions(t), o = this.length(r) * e;
    return this.pointAtLength(o, r);
  }
  pointAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e === 0)
      return this.start.clone();
    let r = !0;
    e < 0 && (r = !1, e = -e);
    const i = this.getPrecision(t), o = this.getSubdivisions(t);
    let a, s = 0;
    for (let u = 0, c = this.segments.length; u < c; u += 1) {
      const h = r ? u : c - 1 - u, f = this.segments[h], d = o[h], p = f.length({
        precision: i,
        subdivisions: d
      });
      if (f.isVisible) {
        if (e <= s + p)
          return f.pointAtLength((r ? 1 : -1) * (e - s), {
            precision: i,
            subdivisions: d
          });
        a = f;
      }
      s += p;
    }
    return a ? r ? a.end : a.start : this.segments[this.segments.length - 1].end.clone();
  }
  pointAtT(e) {
    const t = this.segments, r = t.length;
    if (r === 0)
      return null;
    const i = e.segmentIndex;
    if (i < 0)
      return t[0].pointAtT(0);
    if (i >= r)
      return t[r - 1].pointAtT(1);
    const o = rn.clamp(e.value, 0, 1);
    return t[i].pointAtT(o);
  }
  divideAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const r = rn.clamp(e, 0, 1), i = this.getOptions(t), a = this.length(i) * r;
    return this.divideAtLength(a, i);
  }
  divideAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let r = !0;
    e < 0 && (r = !1, e = -e);
    const i = this.getPrecision(t), o = this.getSubdivisions(t);
    let a = 0, s, l, u, c, h;
    for (let w = 0, x = this.segments.length; w < x; w += 1) {
      const S = r ? w : x - 1 - w, _ = this.getSegment(S), C = o[S], A = { precision: i, subdivisions: C }, k = _.length(A);
      if (_.isDifferentiable() && (u = _, c = S, e <= a + k)) {
        l = S, s = _.divideAtLength((r ? 1 : -1) * (e - a), A);
        break;
      }
      a += k;
    }
    if (!u)
      return null;
    s || (l = c, h = r ? 1 : 0, s = u.divideAtT(h));
    const f = this.clone(), d = l;
    f.replaceSegment(d, s);
    const p = d;
    let g = d + 1, v = d + 2;
    s[0].isDifferentiable() || (f.removeSegment(p), g -= 1, v -= 1);
    const m = f.getSegment(g).start;
    f.insertSegment(g, Wr.createSegment("M", m)), v += 1, s[1].isDifferentiable() || (f.removeSegment(v - 1), v -= 1);
    const y = v - p - 1;
    for (let w = v, x = f.segments.length; w < x; w += 1) {
      const S = this.getSegment(w - y), _ = f.getSegment(w);
      if (_.type === "Z" && !S.subpathStartSegment.end.equals(_.subpathStartSegment.end)) {
        const C = Wr.createSegment("L", S.end);
        f.replaceSegment(w, C);
      }
    }
    const b = new Wr(f.segments.slice(0, g)), O = new Wr(f.segments.slice(g));
    return [b, O];
  }
  intersectsWithLine(e, t = {}) {
    const r = this.toPolylines(t);
    if (r == null)
      return null;
    let i = null;
    for (let o = 0, a = r.length; o < a; o += 1) {
      const s = r[o], l = e.intersect(s);
      l && (i == null && (i = []), Array.isArray(l) ? i.push(...l) : i.push(l));
    }
    return i;
  }
  isDifferentiable() {
    for (let e = 0, t = this.segments.length; e < t; e += 1)
      if (this.segments[e].isDifferentiable())
        return !0;
    return !1;
  }
  isValid() {
    const e = this.segments;
    return e.length === 0 || e[0].type === "M";
  }
  length(e = {}) {
    if (this.segments.length === 0)
      return 0;
    const t = this.getSubdivisions(e);
    let r = 0;
    for (let i = 0, o = this.segments.length; i < o; i += 1) {
      const a = this.segments[i], s = t[i];
      r += a.length({ subdivisions: s });
    }
    return r;
  }
  lengthAtT(e, t = {}) {
    const r = this.segments.length;
    if (r === 0)
      return 0;
    let i = e.segmentIndex;
    if (i < 0)
      return 0;
    let o = rn.clamp(e.value, 0, 1);
    i >= r && (i = r - 1, o = 1);
    const a = this.getPrecision(t), s = this.getSubdivisions(t);
    let l = 0;
    for (let h = 0; h < i; h += 1) {
      const f = this.segments[h], d = s[h];
      l += f.length({ precision: a, subdivisions: d });
    }
    const u = this.segments[i], c = s[i];
    return l += u.lengthAtT(o, { precision: a, subdivisions: c }), l;
  }
  tangentAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const r = rn.clamp(e, 0, 1), i = this.getOptions(t), a = this.length(i) * r;
    return this.tangentAtLength(a, i);
  }
  tangentAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let r = !0;
    e < 0 && (r = !1, e = -e);
    const i = this.getPrecision(t), o = this.getSubdivisions(t);
    let a, s = 0;
    for (let l = 0, u = this.segments.length; l < u; l += 1) {
      const c = r ? l : u - 1 - l, h = this.segments[c], f = o[c], d = h.length({ precision: i, subdivisions: f });
      if (h.isDifferentiable()) {
        if (e <= s + d)
          return h.tangentAtLength((r ? 1 : -1) * (e - s), {
            precision: i,
            subdivisions: f
          });
        a = h;
      }
      s += d;
    }
    if (a) {
      const l = r ? 1 : 0;
      return a.tangentAtT(l);
    }
    return null;
  }
  tangentAtT(e) {
    const t = this.segments.length;
    if (t === 0)
      return null;
    const r = e.segmentIndex;
    if (r < 0)
      return this.segments[0].tangentAtT(0);
    if (r >= t)
      return this.segments[t - 1].tangentAtT(1);
    const i = rn.clamp(e.value, 0, 1);
    return this.segments[r].tangentAtT(i);
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getSubdivisions(e = {}) {
    if (e.segmentSubdivisions == null) {
      const t = this.getPrecision(e);
      return this.getSegmentSubdivisions({ precision: t });
    }
    return e.segmentSubdivisions;
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), r = this.getSubdivisions(e);
    return { precision: t, segmentSubdivisions: r };
  }
  toPoints(e = {}) {
    const t = this.segments, r = t.length;
    if (r === 0)
      return null;
    const i = this.getSubdivisions(e), o = [];
    let a = [];
    for (let s = 0; s < r; s += 1) {
      const l = t[s];
      if (l.isVisible) {
        const u = i[s];
        u.length > 0 ? u.forEach((c) => a.push(c.start)) : a.push(l.start);
      } else
        a.length > 0 && (a.push(t[s - 1].end), o.push(a), a = []);
    }
    return a.length > 0 && (a.push(this.end), o.push(a)), o;
  }
  toPolylines(e = {}) {
    const t = this.toPoints(e);
    return t ? t.map((r) => new Ii(r)) : null;
  }
  scale(e, t, r) {
    return this.segments.forEach((i) => i.scale(e, t, r)), this;
  }
  rotate(e, t) {
    return this.segments.forEach((r) => r.rotate(e, t)), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.segments.forEach((r) => r.translate(e, t)) : this.segments.forEach((r) => r.translate(e)), this;
  }
  clone() {
    const e = new Wr();
    return this.segments.forEach((t) => e.appendSegment(t.clone())), e;
  }
  equals(e) {
    if (e == null)
      return !1;
    const t = this.segments, r = e.segments, i = t.length;
    if (r.length !== i)
      return !1;
    for (let o = 0; o < i; o += 1) {
      const a = t[o], s = r[o];
      if (a.type !== s.type || !a.equals(s))
        return !1;
    }
    return !0;
  }
  toJSON() {
    return this.segments.map((e) => e.toJSON());
  }
  serialize() {
    if (!this.isValid())
      throw new Error("Invalid path segments.");
    return this.segments.map((e) => e.serialize()).join(" ");
  }
  toString() {
    return this.serialize();
  }
};
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isPath = e;
})(Bt || (Bt = {}));
(function(n) {
  function e(r) {
    if (!r)
      return new n();
    const i = new n(), o = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g, a = n.normalize(r).match(o);
    if (a != null)
      for (let s = 0, l = a.length; s < l; s += 1) {
        const u = a[s], c = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g, h = u.match(c);
        if (h != null) {
          const f = h[0], d = h.slice(1).map((g) => +g), p = t.call(null, f, ...d);
          i.appendSegment(p);
        }
      }
    return i;
  }
  n.parse = e;
  function t(r, ...i) {
    if (r === "M")
      return Ag.create.call(null, ...i);
    if (r === "L")
      return Mi.create.call(null, ...i);
    if (r === "C")
      return ha.create.call(null, ...i);
    if (r === "z" || r === "Z")
      return Cg.create();
    throw new Error(`Invalid path segment type "${r}"`);
  }
  n.createSegment = t;
})(Bt || (Bt = {}));
(function(n) {
  n.normalize = pAe, n.isValid = lAe, n.drawArc = cAe, n.drawPoints = Bq, n.arcToCurves = Ox;
})(Bt || (Bt = {}));
class pr {
  constructor(e) {
    this.options = Object.assign({}, e), this.data = this.options.data || {}, this.register = this.register.bind(this), this.unregister = this.unregister.bind(this);
  }
  get names() {
    return Object.keys(this.data);
  }
  register(e, t, r = !1) {
    if (typeof e == "object") {
      Object.entries(e).forEach(([a, s]) => {
        this.register(a, s, t);
      });
      return;
    }
    this.exist(e) && !r && !Mc.isApplyingHMR() && this.onDuplicated(e);
    const i = this.options.process, o = i ? rt(i, this, e, t) : t;
    return this.data[e] = o, o;
  }
  unregister(e) {
    const t = e ? this.data[e] : null;
    return delete this.data[e], t;
  }
  get(e) {
    return e ? this.data[e] : null;
  }
  exist(e) {
    return e ? this.data[e] != null : !1;
  }
  onDuplicated(e) {
    try {
      throw this.options.onConflict && rt(this.options.onConflict, this, e), new Error(`${ax(this.options.type)} with name '${e}' already registered.`);
    } catch (t) {
      throw t;
    }
  }
  onNotFound(e, t) {
    throw new Error(this.getSpellingSuggestion(e, t));
  }
  getSpellingSuggestion(e, t) {
    const r = this.getSpellingSuggestionForName(e), i = t ? `${t} ${fde(this.options.type)}` : this.options.type;
    return (
      // eslint-disable-next-line
      `${ax(i)} with name '${e}' does not exist.${r ? ` Did you mean '${r}'?` : ""}`
    );
  }
  getSpellingSuggestionForName(e) {
    return p2e(e, Object.keys(this.data), (t) => t);
  }
}
(function(n) {
  function e(t) {
    return new n(t);
  }
  n.create = e;
})(pr || (pr = {}));
const gAe = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(n, e) {
    const t = e.thickness * e.sx, r = e.thickness * e.sy;
    Xt(n, {
      width: t,
      height: r,
      rx: t,
      ry: r,
      fill: e.color
    });
  }
}, vAe = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(n, e) {
    const t = e.sx <= 1 ? e.thickness * e.sx : e.thickness;
    Xt(n, {
      width: t,
      height: t,
      rx: t,
      ry: t,
      fill: e.color
    });
  }
}, mAe = {
  color: "rgba(224,224,224,1)",
  thickness: 1,
  markup: "path",
  update(n, e) {
    let t;
    const r = e.width, i = e.height, o = e.thickness;
    r - o >= 0 && i - o >= 0 ? t = ["M", r, 0, "H0 M0 0 V0", i].join(" ") : t = "M 0 0 0 0", Xt(n, {
      d: t,
      stroke: e.color,
      "stroke-width": e.thickness
    });
  }
}, yAe = [
  {
    color: "rgba(224,224,224,1)",
    thickness: 1,
    markup: "path",
    update(n, e) {
      let t;
      const r = e.width, i = e.height, o = e.thickness;
      r - o >= 0 && i - o >= 0 ? t = ["M", r, 0, "H0 M0 0 V0", i].join(" ") : t = "M 0 0 0 0", Xt(n, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  },
  {
    color: "rgba(224,224,224,0.2)",
    thickness: 3,
    factor: 4,
    markup: "path",
    update(n, e) {
      let t;
      const r = e.factor || 1, i = e.width * r, o = e.height * r, a = e.thickness;
      i - a >= 0 && o - a >= 0 ? t = ["M", i, 0, "H0 M0 0 V0", o].join(" ") : t = "M 0 0 0 0", e.width = i, e.height = o, Xt(n, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  }
], bAe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dot: gAe,
  doubleMesh: yAe,
  fixedDot: vAe,
  mesh: mAe
}, Symbol.toStringTag, { value: "Module" }));
let sc = class {
  constructor() {
    this.patterns = {}, this.root = pt.create(vx(), {
      width: "100%",
      height: "100%"
    }, [xs("defs")]).node;
  }
  add(e, t) {
    const r = this.root.childNodes[0];
    r && r.appendChild(t), this.patterns[e] = t, pt.create("rect", {
      width: "100%",
      height: "100%",
      fill: `url(#${e})`
    }).appendTo(this.root);
  }
  get(e) {
    return this.patterns[e];
  }
  has(e) {
    return this.patterns[e] != null;
  }
};
(function(n) {
  n.presets = bAe, n.registry = pr.create({
    type: "grid"
  }), n.registry.register(n.presets, !0);
})(sc || (sc = {}));
const zq = function(n) {
  const e = document.createElement("canvas"), t = n.width, r = n.height;
  e.width = t * 2, e.height = r;
  const i = e.getContext("2d");
  return i.drawImage(n, 0, 0, t, r), i.translate(2 * t, 0), i.scale(-1, 1), i.drawImage(n, 0, 0, t, r), e;
}, Fq = function(n) {
  const e = document.createElement("canvas"), t = n.width, r = n.height;
  e.width = t, e.height = r * 2;
  const i = e.getContext("2d");
  return i.drawImage(n, 0, 0, t, r), i.translate(0, 2 * r), i.scale(1, -1), i.drawImage(n, 0, 0, t, r), e;
}, Qq = function(n) {
  const e = document.createElement("canvas"), t = n.width, r = n.height;
  e.width = 2 * t, e.height = 2 * r;
  const i = e.getContext("2d");
  return i.drawImage(n, 0, 0, t, r), i.setTransform(-1, 0, 0, -1, e.width, e.height), i.drawImage(n, 0, 0, t, r), i.setTransform(-1, 0, 0, 1, e.width, 0), i.drawImage(n, 0, 0, t, r), i.setTransform(1, 0, 0, -1, 0, e.height), i.drawImage(n, 0, 0, t, r), e;
}, OAe = function(n, e) {
  const t = n.width, r = n.height, i = document.createElement("canvas");
  i.width = t * 3, i.height = r * 3;
  const o = i.getContext("2d"), a = e.angle != null ? -e.angle : -20, s = Jt.toRad(a), l = i.width / 4, u = i.height / 4;
  for (let c = 0; c < 4; c += 1)
    for (let h = 0; h < 4; h += 1)
      (c + h) % 2 > 0 && (o.setTransform(1, 0, 0, 1, (2 * c - 1) * l, (2 * h - 1) * u), o.rotate(s), o.drawImage(n, -t / 2, -r / 2, t, r));
  return i;
}, wAe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  flipX: zq,
  flipXY: Qq,
  flipY: Fq,
  watermark: OAe
}, Symbol.toStringTag, { value: "Module" }));
var l0;
(function(n) {
  n.presets = Object.assign({}, wAe), n.presets["flip-x"] = zq, n.presets["flip-y"] = Fq, n.presets["flip-xy"] = Qq, n.registry = pr.create({
    type: "background pattern"
  }), n.registry.register(n.presets, !0);
})(l0 || (l0 = {}));
function dI(n, e) {
  return n ?? e;
}
function qr(n, e) {
  return n != null && Number.isFinite(n) ? n : e;
}
function xAe(n = {}) {
  const e = dI(n.color, "blue"), t = qr(n.width, 1), r = qr(n.margin, 2), i = qr(n.opacity, 1), o = r, a = r + t;
  return `
    <filter>
      <feFlood flood-color="${e}" flood-opacity="${i}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${a}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${o}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}
function SAe(n = {}) {
  const e = dI(n.color, "red"), t = qr(n.blur, 0), r = qr(n.width, 1), i = qr(n.opacity, 1);
  return `
      <filter>
        <feFlood flood-color="${e}" flood-opacity="${i}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${r}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${t}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}
function _Ae(n = {}) {
  const e = qr(n.x, 2);
  return `
    <filter>
      <feGaussianBlur stdDeviation="${n.y != null && Number.isFinite(n.y) ? [e, n.y] : e}"/>
    </filter>
  `.trim();
}
function CAe(n = {}) {
  const e = qr(n.dx, 0), t = qr(n.dy, 0), r = dI(n.color, "black"), i = qr(n.blur, 4), o = qr(n.opacity, 1);
  return "SVGFEDropShadowElement" in window ? `<filter>
         <feDropShadow stdDeviation="${i}" dx="${e}" dy="${t}" flood-color="${r}" flood-opacity="${o}" />
       </filter>`.trim() : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${i}" />
         <feOffset dx="${e}" dy="${t}" result="offsetblur" />
         <feFlood flood-color="${r}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${o}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}
function AAe(n = {}) {
  const e = qr(n.amount, 1), t = 0.2126 + 0.7874 * (1 - e), r = 0.7152 - 0.7152 * (1 - e), i = 0.0722 - 0.0722 * (1 - e), o = 0.2126 - 0.2126 * (1 - e), a = 0.7152 + 0.2848 * (1 - e), s = 0.0722 - 0.0722 * (1 - e), l = 0.2126 - 0.2126 * (1 - e), u = 0.0722 + 0.9278 * (1 - e);
  return `
    <filter>
      <feColorMatrix type="matrix" values="${t} ${r} ${i} 0 0 ${o} ${a} ${s} 0 0 ${l} ${r} ${u} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}
function TAe(n = {}) {
  const e = qr(n.amount, 1), t = 0.393 + 0.607 * (1 - e), r = 0.769 - 0.769 * (1 - e), i = 0.189 - 0.189 * (1 - e), o = 0.349 - 0.349 * (1 - e), a = 0.686 + 0.314 * (1 - e), s = 0.168 - 0.168 * (1 - e), l = 0.272 - 0.272 * (1 - e), u = 0.534 - 0.534 * (1 - e), c = 0.131 + 0.869 * (1 - e);
  return `
      <filter>
        <feColorMatrix type="matrix" values="${t} ${r} ${i} 0 0 ${o} ${a} ${s} 0 0 ${l} ${u} ${c} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}
function kAe(n = {}) {
  return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - qr(n.amount, 1)}"/>
      </filter>
    `.trim();
}
function PAe(n = {}) {
  return `
      <filter>
        <feColorMatrix type="hueRotate" values="${qr(n.angle, 0)}"/>
      </filter>
    `.trim();
}
function EAe(n = {}) {
  const e = qr(n.amount, 1), t = 1 - e;
  return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${e} ${t}"/>
          <feFuncG type="table" tableValues="${e} ${t}"/>
          <feFuncB type="table" tableValues="${e} ${t}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}
function MAe(n = {}) {
  const e = qr(n.amount, 1);
  return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${e}"/>
        <feFuncG type="linear" slope="${e}"/>
        <feFuncB type="linear" slope="${e}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}
function DAe(n = {}) {
  const e = qr(n.amount, 1), t = 0.5 - e / 2;
  return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${e}" intercept="${t}"/>
        <feFuncG type="linear" slope="${e}" intercept="${t}"/>
        <feFuncB type="linear" slope="${e}" intercept="${t}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}
const LAe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  blur: _Ae,
  brightness: MAe,
  contrast: DAe,
  dropShadow: CAe,
  grayScale: AAe,
  highlight: SAe,
  hueRotate: PAe,
  invert: EAe,
  outline: xAe,
  saturate: kAe,
  sepia: TAe
}, Symbol.toStringTag, { value: "Module" }));
var Tg;
(function(n) {
  n.presets = LAe, n.registry = pr.create({
    type: "filter"
  }), n.registry.register(n.presets, !0);
})(Tg || (Tg = {}));
const IAe = {
  xlinkHref: "xlink:href",
  xlinkShow: "xlink:show",
  xlinkRole: "xlink:role",
  xlinkType: "xlink:type",
  xlinkArcrole: "xlink:arcrole",
  xlinkTitle: "xlink:title",
  xlinkActuate: "xlink:actuate",
  xmlSpace: "xml:space",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  preserveAspectRatio: "preserveAspectRatio",
  requiredExtension: "requiredExtension",
  requiredFeatures: "requiredFeatures",
  systemLanguage: "systemLanguage",
  externalResourcesRequired: "externalResourceRequired"
}, RAe = {
  // We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
}, Zq = {
  position: E_("x", "width", "origin")
}, Wq = {
  position: E_("y", "height", "origin")
}, NAe = {
  position: E_("x", "width", "corner")
}, $Ae = {
  position: E_("y", "height", "corner")
}, Gq = {
  set: Rc("width", "width")
}, jq = {
  set: Rc("height", "height")
}, BAe = {
  set: Rc("rx", "width")
}, VAe = {
  set: Rc("ry", "height")
}, Hq = {
  set: ((n) => {
    const e = Rc(n, "width"), t = Rc(n, "height");
    return function(r, i) {
      const o = i.refBBox, a = o.height > o.width ? e : t;
      return rt(a, this, r, i);
    };
  })("r")
}, zAe = {
  set(n, { refBBox: e }) {
    let t = parseFloat(n);
    const r = su(n);
    r && (t /= 100);
    const i = Math.sqrt(e.height * e.height + e.width * e.width);
    let o;
    return Number.isFinite(t) && (r || t >= 0 && t <= 1 ? o = t * i : o = Math.max(t + i, 0)), { r: o };
  }
}, FAe = {
  set: Rc("cx", "width")
}, QAe = {
  set: Rc("cy", "height")
}, qq = {
  set: Uq({ resetOffset: !0 })
}, ZAe = {
  set: Uq({ resetOffset: !1 })
}, Yq = {
  set: Kq({ resetOffset: !0 })
}, WAe = {
  set: Kq({ resetOffset: !1 })
}, GAe = Hq, jAe = qq, HAe = Yq, qAe = Zq, YAe = Wq, XAe = Gq, UAe = jq;
function E_(n, e, t) {
  return (r, { refBBox: i }) => {
    if (r == null)
      return null;
    let o = parseFloat(r);
    const a = su(r);
    a && (o /= 100);
    let s;
    if (Number.isFinite(o)) {
      const u = i[t];
      a || o > 0 && o < 1 ? s = u[n] + i[e] * o : s = u[n] + o;
    }
    const l = new G();
    return l[n] = s || 0, l;
  };
}
function Rc(n, e) {
  return function(t, { refBBox: r }) {
    let i = parseFloat(t);
    const o = su(t);
    o && (i /= 100);
    const a = {};
    if (Number.isFinite(i)) {
      const s = o || i >= 0 && i <= 1 ? i * r[e] : Math.max(i + r[e], 0);
      a[n] = s;
    }
    return a;
  };
}
function Xq(n, e) {
  const t = "x6-shape", r = e && e.resetOffset;
  return function(i, { elem: o, refBBox: a }) {
    let s = ed(o, t);
    if (!s || s.value !== i) {
      const g = n(i);
      s = {
        value: i,
        shape: g,
        shapeBBox: g.bbox()
      }, ed(o, t, s);
    }
    const l = s.shape.clone(), u = s.shapeBBox.clone(), c = u.getOrigin(), h = a.getOrigin();
    u.x = h.x, u.y = h.y;
    const f = a.getMaxScaleToFit(u, h), d = u.width === 0 || a.width === 0 ? 1 : f.sx, p = u.height === 0 || a.height === 0 ? 1 : f.sy;
    return l.scale(d, p, c), r && l.translate(-c.x, -c.y), l;
  };
}
function Uq(n) {
  function e(r) {
    return Bt.parse(r);
  }
  const t = Xq(e, n);
  return (r, i) => ({
    d: t(r, i).serialize()
  });
}
function Kq(n) {
  const e = Xq((t) => new Ii(t), n);
  return (t, r) => ({
    points: e(t, r).serialize()
  });
}
const KAe = {
  qualify: bs,
  set(n, { view: e }) {
    return `url(#${e.graph.defineGradient(n)})`;
  }
}, JAe = {
  qualify: bs,
  set(n, { view: e }) {
    const t = e.cell, r = Object.assign({}, n);
    if (t.isEdge() && r.type === "linearGradient") {
      const i = e, o = i.sourcePoint, a = i.targetPoint;
      r.id = `gradient-${r.type}-${t.id}`, r.attrs = Object.assign(Object.assign({}, r.attrs), { x1: o.x, y1: o.y, x2: a.x, y2: a.y, gradientUnits: "userSpaceOnUse" }), e.graph.defs.remove(r.id);
    }
    return `url(#${e.graph.defineGradient(r)})`;
  }
}, Jq = {
  qualify(n, { attrs: e }) {
    return e.textWrap == null || !bs(e.textWrap);
  },
  set(n, { view: e, elem: t, attrs: r }) {
    const i = "x6-text", o = ed(t, i), a = (c) => {
      try {
        return JSON.parse(c);
      } catch {
        return c;
      }
    }, s = {
      x: r.x,
      eol: r.eol,
      annotations: a(r.annotations),
      textPath: a(r["text-path"] || r.textPath),
      textVerticalAnchor: r["text-vertical-anchor"] || r.textVerticalAnchor,
      displayEmpty: (r["display-empty"] || r.displayEmpty) === "true",
      lineHeight: r["line-height"] || r.lineHeight
    }, l = r["font-size"] || r.fontSize, u = JSON.stringify([n, s]);
    if (l && t.setAttribute("font-size", l), o == null || o !== u) {
      const c = s.textPath;
      if (c != null && typeof c == "object") {
        const h = c.selector;
        if (typeof h == "string") {
          const f = e.find(h)[0];
          f instanceof SVGPathElement && (sI(f), s.textPath = Object.assign({ "xlink:href": `#${f.id}` }, c));
        }
      }
      Eq(t, `${n}`, s), ed(t, i, u);
    }
  }
}, eTe = {
  qualify: bs,
  set(n, { view: e, elem: t, attrs: r, refBBox: i }) {
    const o = n, a = o.width || 0;
    su(a) ? i.width *= parseFloat(a) / 100 : a <= 0 ? i.width += a : i.width = a;
    const s = o.height || 0;
    su(s) ? i.height *= parseFloat(s) / 100 : s <= 0 ? i.height += s : i.height = s;
    let l, u = o.text;
    u == null && (u = r.text || (t == null ? void 0 : t.textContent)), u != null ? l = Mq(`${u}`, i, {
      "font-weight": r["font-weight"] || r.fontWeight,
      "font-size": r["font-size"] || r.fontSize,
      "font-family": r["font-family"] || r.fontFamily,
      lineHeight: r.lineHeight
    }, {
      // svgDocument: view.graph.view.svg,
      ellipsis: o.ellipsis
      // hyphen: info.hyphen as string,
      // breakWord: info.breakWord as boolean,
    }) : l = "", rt(Jq.set, this, l, {
      view: e,
      elem: t,
      attrs: r,
      refBBox: i,
      cell: e.cell
    });
  }
}, bv = (n, { attrs: e }) => e.text !== void 0, tTe = {
  qualify: bv
}, nTe = {
  qualify: bv
}, rTe = {
  qualify: bv
}, iTe = {
  qualify: bv
}, oTe = {
  qualify: bv
}, aTe = {
  qualify: bv
}, sTe = {
  qualify(n, { elem: e }) {
    return e instanceof SVGElement;
  },
  set(n, { elem: e }) {
    const t = "x6-title", r = `${n}`, i = ed(e, t);
    if (i == null || i !== r) {
      ed(e, t, r);
      const o = e.firstChild;
      if (o && o.tagName.toUpperCase() === "TITLE") {
        const a = o;
        a.textContent = r;
      } else {
        const a = document.createElementNS(e.namespaceURI, "title");
        a.textContent = r, e.insertBefore(a, o);
      }
    }
  }
}, lTe = {
  offset: e9("x", "width", "right")
}, uTe = {
  offset: e9("y", "height", "bottom")
}, cTe = {
  offset(n, { refBBox: e }) {
    return n ? { x: -e.x, y: -e.y } : { x: 0, y: 0 };
  }
};
function e9(n, e, t) {
  return (r, { refBBox: i }) => {
    const o = new G();
    let a;
    return r === "middle" ? a = i[e] / 2 : r === t ? a = i[e] : typeof r == "number" && Number.isFinite(r) ? a = r > -1 && r < 1 ? -i[e] * r : -r : su(r) ? a = i[e] * parseFloat(r) / 100 : a = 0, o[n] = -(i[n] + a), o;
  };
}
const hTe = {
  qualify: bs,
  set(n, { elem: e }) {
    Mr(e, n);
  }
}, fTe = {
  set(n, { elem: e }) {
    e.innerHTML = `${n}`;
  }
}, dTe = {
  qualify: bs,
  set(n, { view: e }) {
    return `url(#${e.graph.defineFilter(n)})`;
  }
}, pTe = {
  set(n) {
    return n != null && typeof n == "object" && n.id ? n.id : n;
  }
};
function uh(n, e, t) {
  let r, i;
  typeof e == "object" ? (r = e.x, i = e.y) : (r = e, i = t);
  const o = Bt.parse(n), a = o.bbox();
  if (a) {
    let s = -a.height / 2 - a.y, l = -a.width / 2 - a.x;
    typeof r == "number" && (l -= r), typeof i == "number" && (s -= i), o.translate(l, s);
  }
  return o.serialize();
}
var t9 = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const gTe = (n) => {
  var { size: e, width: t, height: r, offset: i, open: o } = n, a = t9(n, ["size", "width", "height", "offset", "open"]);
  return n9({ size: e, width: t, height: r, offset: i }, o === !0, !0, void 0, a);
}, vTe = (n) => {
  var { size: e, width: t, height: r, offset: i, factor: o } = n, a = t9(n, ["size", "width", "height", "offset", "factor"]);
  return n9({ size: e, width: t, height: r, offset: i }, !1, !1, o, a);
};
function n9(n, e, t, r = 3 / 4, i = {}) {
  const o = n.size || 10, a = n.width || o, s = n.height || o, l = new Bt(), u = {};
  if (e)
    l.moveTo(a, 0).lineTo(0, s / 2).lineTo(a, s), u.fill = "none";
  else {
    if (l.moveTo(0, s / 2), l.lineTo(a, 0), !t) {
      const c = wo(r, 0, 1);
      l.lineTo(a * c, s / 2);
    }
    l.lineTo(a, s), l.close();
  }
  return Object.assign(Object.assign(Object.assign({}, u), i), { tagName: "path", d: uh(l.serialize(), {
    x: n.offset != null ? n.offset : -a / 2
  }) });
}
var mTe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const yTe = (n) => {
  var { size: e, width: t, height: r, offset: i } = n, o = mTe(n, ["size", "width", "height", "offset"]);
  const a = e || 10, s = t || a, l = r || a, u = new Bt();
  return u.moveTo(0, l / 2).lineTo(s / 2, 0).lineTo(s, l / 2).lineTo(s / 2, l).close(), Object.assign(Object.assign({}, o), { tagName: "path", d: uh(u.serialize(), i ?? -s / 2) });
};
var bTe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const OTe = (n) => {
  var { d: e, offsetX: t, offsetY: r } = n, i = bTe(n, ["d", "offsetX", "offsetY"]);
  return Object.assign(Object.assign({}, i), { tagName: "path", d: uh(e, t, r) });
};
var wTe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const xTe = (n) => {
  var { size: e, width: t, height: r, offset: i } = n, o = wTe(n, ["size", "width", "height", "offset"]);
  const a = e || 10, s = t || a, l = r || a, u = new Bt();
  return u.moveTo(0, 0).lineTo(s, l).moveTo(0, l).lineTo(s, 0), Object.assign(Object.assign({}, o), { tagName: "path", fill: "none", d: uh(u.serialize(), i || -s / 2) });
};
var STe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const _Te = (n) => {
  var { width: e, height: t, offset: r, open: i, flip: o } = n, a = STe(n, ["width", "height", "offset", "open", "flip"]);
  let s = t || 6;
  const l = e || 10, u = i === !0, c = o === !0, h = Object.assign(Object.assign({}, a), { tagName: "path" });
  c && (s = -s);
  const f = new Bt();
  return f.moveTo(0, s).lineTo(l, 0), u ? h.fill = "none" : (f.lineTo(l, s), f.close()), h.d = uh(f.serialize(), {
    x: r || -l / 2,
    y: s / 2
  }), h;
};
var r9 = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const i9 = (n) => {
  var { r: e } = n, t = r9(n, ["r"]);
  const r = e || 5;
  return Object.assign(Object.assign({ cx: r }, t), { tagName: "circle", r });
}, CTe = (n) => {
  var { r: e } = n, t = r9(n, ["r"]);
  const r = e || 5, i = new Bt();
  return i.moveTo(r, 0).lineTo(r, r * 2), i.moveTo(0, r).lineTo(r * 2, r), {
    children: [
      Object.assign(Object.assign({}, i9({ r })), { fill: "none" }),
      Object.assign(Object.assign({}, t), { tagName: "path", d: uh(i.serialize(), -r) })
    ]
  };
};
var ATe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const TTe = (n) => {
  var { rx: e, ry: t } = n, r = ATe(n, ["rx", "ry"]);
  const i = e || 5, o = t || 5;
  return Object.assign(Object.assign({ cx: i }, r), { tagName: "ellipse", rx: i, ry: o });
}, kTe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  async: _Te,
  block: gTe,
  circle: i9,
  circlePlus: CTe,
  classic: vTe,
  cross: xTe,
  diamond: yTe,
  ellipse: TTe,
  path: OTe
}, Symbol.toStringTag, { value: "Module" }));
var Nc;
(function(n) {
  n.presets = kTe, n.registry = pr.create({
    type: "marker"
  }), n.registry.register(n.presets, !0);
})(Nc || (Nc = {}));
(function(n) {
  n.normalize = uh;
})(Nc || (Nc = {}));
var PTe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function pI(n) {
  return typeof n == "string" || bs(n);
}
const ETe = {
  qualify: pI,
  set(n, { view: e, attrs: t }) {
    return gI("marker-start", n, e, t);
  }
}, MTe = {
  qualify: pI,
  set(n, { view: e, attrs: t }) {
    return gI("marker-end", n, e, t, {
      transform: "rotate(180)"
    });
  }
}, DTe = {
  qualify: pI,
  set(n, { view: e, attrs: t }) {
    return gI("marker-mid", n, e, t);
  }
};
function gI(n, e, t, r, i = {}) {
  const o = typeof e == "string" ? { name: e } : e, { name: a, args: s } = o, l = PTe(o, ["name", "args"]);
  let u = l;
  if (a && typeof a == "string") {
    const h = Nc.registry.get(a);
    if (h)
      u = h(Object.assign(Object.assign({}, l), s));
    else
      return Nc.registry.onNotFound(a);
  }
  const c = Object.assign(Object.assign(Object.assign({}, LTe(r, n)), i), u);
  return {
    [n]: `url(#${t.graph.defineMarker(c)})`
  };
}
function LTe(n, e) {
  const t = {}, r = n.stroke;
  typeof r == "string" && (t.stroke = r, t.fill = r);
  let i = n.strokeOpacity;
  if (i == null && (i = n["stroke-opacity"]), i == null && (i = n.opacity), i != null && (t["stroke-opacity"] = i, t["fill-opacity"] = i), e !== "marker-mid") {
    const o = parseFloat(n.strokeWidth || n["stroke-width"]);
    if (Number.isFinite(o) && o > 1) {
      const a = Math.ceil(o / 2);
      t.refX = e === "marker-start" ? a : -a;
    }
  }
  return t;
}
const _b = (n, { view: e }) => e.cell.isEdge(), ITe = {
  qualify: _b,
  set(n, e) {
    var t, r, i, o;
    const a = e.view, s = n.reverse || !1, l = n.stubs || 0;
    let u;
    if (Number.isFinite(l) && l !== 0)
      if (s) {
        let c, h;
        const f = a.getConnectionLength() || 0;
        l < 0 ? (c = (f + l) / 2, h = -l) : (c = l, h = f - l * 2);
        const d = a.getConnection();
        u = (o = (i = (r = (t = d == null ? void 0 : d.divideAtLength(c)) === null || t === void 0 ? void 0 : t[1]) === null || r === void 0 ? void 0 : r.divideAtLength(h)) === null || i === void 0 ? void 0 : i[0]) === null || o === void 0 ? void 0 : o.serialize();
      } else {
        let c;
        l < 0 ? c = ((a.getConnectionLength() || 0) + l) / 2 : c = l;
        const h = a.getConnection();
        if (h) {
          const f = h.divideAtLength(c), d = h.divideAtLength(-c);
          f && d && (u = `${f[0].serialize()} ${d[1].serialize()}`);
        }
      }
    return { d: u || a.getConnectionPathData() };
  }
}, o9 = {
  qualify: _b,
  set: M_("getTangentAtLength", { rotate: !0 })
}, RTe = {
  qualify: _b,
  set: M_("getTangentAtLength", { rotate: !1 })
}, a9 = {
  qualify: _b,
  set: M_("getTangentAtRatio", { rotate: !0 })
}, NTe = {
  qualify: _b,
  set: M_("getTangentAtRatio", { rotate: !1 })
}, $Te = o9, BTe = a9;
function M_(n, e) {
  const t = { x: 1, y: 0 };
  return (r, i) => {
    let o, a;
    const s = i.view, l = s[n](Number(r));
    return l ? (a = e.rotate ? l.vector().vectorAngle(t) : 0, o = l.start) : (o = s.path.start, a = 0), a === 0 ? { transform: `translate(${o.x},${o.y}')` } : {
      transform: `translate(${o.x},${o.y}') rotate(${a})`
    };
  };
}
const VTe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotations: iTe,
  atConnectionLength: $Te,
  atConnectionLengthIgnoreGradient: RTe,
  atConnectionLengthKeepGradient: o9,
  atConnectionRatio: BTe,
  atConnectionRatioIgnoreGradient: NTe,
  atConnectionRatioKeepGradient: a9,
  connection: ITe,
  displayEmpty: aTe,
  eol: oTe,
  fill: KAe,
  filter: dTe,
  html: fTe,
  lineHeight: tTe,
  port: pTe,
  ref: RAe,
  refCx: FAe,
  refCy: QAe,
  refD: jAe,
  refDKeepOffset: ZAe,
  refDResetOffset: qq,
  refDx: NAe,
  refDy: $Ae,
  refHeight: jq,
  refHeight2: UAe,
  refPoints: HAe,
  refPointsKeepOffset: WAe,
  refPointsResetOffset: Yq,
  refR: GAe,
  refRCircumscribed: zAe,
  refRInscribed: Hq,
  refRx: BAe,
  refRy: VAe,
  refWidth: Gq,
  refWidth2: XAe,
  refX: Zq,
  refX2: qAe,
  refY: Wq,
  refY2: YAe,
  resetOffset: cTe,
  sourceMarker: ETe,
  stroke: JAe,
  style: hTe,
  targetMarker: MTe,
  text: Jq,
  textPath: rTe,
  textVerticalAnchor: nTe,
  textWrap: eTe,
  title: sTe,
  vertexMarker: DTe,
  xAlign: lTe,
  yAlign: uTe
}, Symbol.toStringTag, { value: "Module" }));
var bl;
(function(n) {
  function e(t, r, i) {
    return !!(t != null && (typeof t == "string" || typeof t.qualify != "function" || rt(t.qualify, this, r, i)));
  }
  n.isValidDefinition = e;
})(bl || (bl = {}));
(function(n) {
  n.presets = Object.assign(Object.assign({}, IAe), VTe), n.registry = pr.create({
    type: "attribute definition"
  }), n.registry.register(n.presets, !0);
})(bl || (bl = {}));
const Da = {
  prefixCls: "x6",
  autoInsertCSS: !0,
  useCSSSelector: !0,
  prefix(n) {
    return `${Da.prefixCls}-${n}`;
  }
}, i5 = Da.prefix("highlighted"), zTe = {
  highlight(n, e, t) {
    const r = t && t.className || i5;
    lt(e, r);
  },
  unhighlight(n, e, t) {
    const r = t && t.className || i5;
    br(e, r);
  }
}, o5 = Da.prefix("highlight-opacity"), FTe = {
  highlight(n, e) {
    lt(e, o5);
  },
  unhighlight(n, e) {
    br(e, o5);
  }
};
var gn;
(function(n) {
  n.normalizeMarker = uh;
  function e(f, d) {
    const p = q2e(f.x, f.y).matrixTransform(d);
    return new G(p.x, p.y);
  }
  n.transformPoint = e;
  function t(f, d) {
    return new Xe(e(f.start, d), e(f.end, d));
  }
  n.transformLine = t;
  function r(f, d) {
    let p = f instanceof Ii ? f.points : f;
    return Array.isArray(p) || (p = []), new Ii(p.map((g) => e(g, d)));
  }
  n.transformPolyline = r;
  function i(f, d) {
    const g = xs("svg").createSVGPoint();
    g.x = f.x, g.y = f.y;
    const v = g.matrixTransform(d);
    g.x = f.x + f.width, g.y = f.y;
    const m = g.matrixTransform(d);
    g.x = f.x + f.width, g.y = f.y + f.height;
    const y = g.matrixTransform(d);
    g.x = f.x, g.y = f.y + f.height;
    const b = g.matrixTransform(d), O = Math.min(v.x, m.x, y.x, b.x), w = Math.max(v.x, m.x, y.x, b.x), x = Math.min(v.y, m.y, y.y, b.y), S = Math.max(v.y, m.y, y.y, b.y);
    return new Te(O, x, w - O, S - x);
  }
  n.transformRectangle = i;
  function o(f, d, p) {
    let g;
    const v = f.ownerSVGElement;
    if (!v)
      return new Te(0, 0, 0, 0);
    try {
      g = f.getBBox();
    } catch {
      g = {
        x: f.clientLeft,
        y: f.clientTop,
        width: f.clientWidth,
        height: f.clientHeight
      };
    }
    if (d)
      return Te.create(g);
    const m = yy(f, p || v);
    return i(g, m);
  }
  n.bbox = o;
  function a(f, d = {}) {
    let p;
    if (!f.ownerSVGElement || !Dc(f)) {
      if (YB(f)) {
        const { left: y, top: b, width: O, height: w } = s(f);
        return new Te(y, b, O, w);
      }
      return new Te(0, 0, 0, 0);
    }
    let v = d.target;
    if (!d.recursive) {
      try {
        p = f.getBBox();
      } catch {
        p = {
          x: f.clientLeft,
          y: f.clientTop,
          width: f.clientWidth,
          height: f.clientHeight
        };
      }
      if (!v)
        return Te.create(p);
      const y = yy(f, v);
      return i(p, y);
    }
    {
      const y = f.childNodes, b = y.length;
      if (b === 0)
        return a(f, {
          target: v
        });
      v || (v = f);
      for (let O = 0; O < b; O += 1) {
        const w = y[O];
        let x;
        w.childNodes.length === 0 ? x = a(w, {
          target: v
        }) : x = a(w, {
          target: v,
          recursive: !0
        }), p ? p = p.union(x) : p = x;
      }
      return p;
    }
  }
  n.getBBox = a;
  function s(f) {
    let d = 0, p = 0, g = 0, v = 0;
    if (f) {
      let m = f;
      for (; m; )
        d += m.offsetLeft, p += m.offsetTop, m = m.offsetParent, m && (d += parseInt(JB(m, "borderLeft"), 10), p += parseInt(JB(m, "borderTop"), 10));
      g = f.offsetWidth, v = f.offsetHeight;
    }
    return {
      left: d,
      top: p,
      width: g,
      height: v
    };
  }
  n.getBoundingOffsetRect = s;
  function l(f) {
    const d = (p) => {
      const g = f.getAttribute(p), v = g ? parseFloat(g) : 0;
      return Number.isNaN(v) ? 0 : v;
    };
    switch (f instanceof SVGElement && f.nodeName.toLowerCase()) {
      case "rect":
        return new Te(d("x"), d("y"), d("width"), d("height"));
      case "circle":
        return new Ic(d("cx"), d("cy"), d("r"), d("r"));
      case "ellipse":
        return new Ic(d("cx"), d("cy"), d("rx"), d("ry"));
      case "polyline": {
        const p = yx(f);
        return new Ii(p);
      }
      case "polygon": {
        const p = yx(f);
        return p.length > 1 && p.push(p[0]), new Ii(p);
      }
      case "path": {
        let p = f.getAttribute("d");
        return Bt.isValid(p) || (p = Bt.normalize(p)), Bt.parse(p);
      }
      case "line":
        return new Xe(d("x1"), d("y1"), d("x2"), d("y2"));
    }
    return a(f);
  }
  n.toGeometryShape = l;
  function u(f, d, p, g) {
    const v = G.create(d), m = G.create(p);
    g || (g = f instanceof SVGSVGElement ? f : f.ownerSVGElement);
    const y = BP(f);
    f.setAttribute("transform", "");
    const b = a(f, {
      target: g
    }).scale(y.sx, y.sy), O = Nm();
    O.setTranslate(-b.x - b.width / 2, -b.y - b.height / 2);
    const w = Nm(), x = v.angleBetween(m, v.clone().translate(1, 0));
    x && w.setRotate(x, 0, 0);
    const S = Nm(), _ = v.clone().move(m, b.width / 2);
    S.setTranslate(2 * v.x - _.x, 2 * v.y - _.y);
    const C = yy(f, g), A = Nm();
    A.setMatrix(S.matrix.multiply(w.matrix.multiply(O.matrix.multiply(C.scale(y.sx, y.sy))))), f.setAttribute("transform", yv(A.matrix));
  }
  n.translateAndAutoOrient = u;
  function c(f) {
    if (f == null)
      return null;
    let d = f;
    do {
      let p = d.tagName;
      if (typeof p != "string")
        return null;
      if (p = p.toUpperCase(), mv(d, "x6-port"))
        d = d.nextElementSibling;
      else if (p === "G")
        d = d.firstElementChild;
      else if (p === "TITLE")
        d = d.nextElementSibling;
      else
        break;
    } while (d);
    return d;
  }
  n.findShapeNode = c;
  function h(f) {
    const d = c(f);
    if (!Dc(d)) {
      if (YB(f)) {
        const { left: v, top: m, width: y, height: b } = s(f);
        return new Te(v, m, y, b);
      }
      return new Te(0, 0, 0, 0);
    }
    return l(d).bbox() || Te.create();
  }
  n.getBBoxV2 = h;
})(gn || (gn = {}));
const QTe = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    "stroke-width": 3,
    stroke: "#FEB663"
  }
}, ZTe = {
  highlight(n, e, t) {
    const r = Xu.getHighlighterId(e, t);
    if (Xu.hasCache(r))
      return;
    t = $j({}, t, QTe);
    const i = pt.create(e);
    let o, a;
    try {
      o = i.toPathData();
    } catch {
      a = gn.bbox(i.node, !0), o = Lq(Object.assign(Object.assign({}, t), a));
    }
    const s = xs("path");
    if (Xt(s, Object.assign({ d: o, "pointer-events": "none", "vector-effect": "non-scaling-stroke", fill: "none" }, t.attrs ? i0(t.attrs) : null)), n.isEdgeElement(e))
      Xt(s, "d", n.getConnectionPathData());
    else {
      let c = i.getTransformToElement(n.container);
      const h = t.padding;
      if (h) {
        a == null && (a = gn.bbox(i.node, !0));
        const f = a.x + a.width / 2, d = a.y + a.height / 2;
        a = gn.transformRectangle(a, c);
        const p = Math.max(a.width, 1), g = Math.max(a.height, 1), v = (p + h) / p, m = (g + h) / g, y = Xr({
          a: v,
          b: 0,
          c: 0,
          d: m,
          e: f - v * f,
          f: d - m * d
        });
        c = c.multiply(y);
      }
      _g(s, c);
    }
    lt(s, Da.prefix("highlight-stroke"));
    const l = n.cell, u = () => Xu.removeHighlighter(r);
    l.on("removed", u), l.model && l.model.on("reseted", u), n.container.appendChild(s), Xu.setCache(r, s);
  },
  unhighlight(n, e, t) {
    Xu.removeHighlighter(Xu.getHighlighterId(e, t));
  }
};
var Xu;
(function(n) {
  function e(a, s) {
    return sI(a), a.id + JSON.stringify(s);
  }
  n.getHighlighterId = e;
  const t = {};
  function r(a, s) {
    t[a] = s;
  }
  n.setCache = r;
  function i(a) {
    return t[a] != null;
  }
  n.hasCache = i;
  function o(a) {
    const s = t[a];
    s && (cl(s), delete t[a]);
  }
  n.removeHighlighter = o;
})(Xu || (Xu = {}));
const WTe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  className: zTe,
  opacity: FTe,
  stroke: ZTe
}, Symbol.toStringTag, { value: "Module" }));
var Kl;
(function(n) {
  function e(t, r) {
    if (typeof r.highlight != "function")
      throw new Error(`Highlighter '${t}' is missing required \`highlight()\` method`);
    if (typeof r.unhighlight != "function")
      throw new Error(`Highlighter '${t}' is missing required \`unhighlight()\` method`);
  }
  n.check = e;
})(Kl || (Kl = {}));
(function(n) {
  n.presets = WTe, n.registry = pr.create({
    type: "highlighter"
  }), n.registry.register(n.presets, !0);
})(Kl || (Kl = {}));
function ZP(n, e = {}) {
  return new G(ss(e.x, n.width), ss(e.y, n.height));
}
function vI(n, e, t) {
  return Object.assign({ angle: e, position: n.toJSON() }, t);
}
const GTe = (n, e) => n.map(({ x: t, y: r, angle: i }) => vI(ZP(e, { x: t, y: r }), i || 0)), jTe = (n, e, t) => {
  const r = t.start || 0, i = t.step || 20;
  return s9(n, e, r, (o, a) => (o + 0.5 - a / 2) * i);
}, HTe = (n, e, t) => {
  const r = t.start || 0, i = t.step || 360 / n.length;
  return s9(n, e, r, (o) => o * i);
};
function s9(n, e, t, r) {
  const i = e.getCenter(), o = e.getTopCenter(), a = e.width / e.height, s = Ic.fromRect(e), l = n.length;
  return n.map((u, c) => {
    const h = t + r(c, l), f = o.clone().rotate(-h, i).scale(a, 1, i), d = u.compensateRotate ? -s.tangentTheta(f) : 0;
    return (u.dx || u.dy) && f.translate(u.dx || 0, u.dy || 0), u.dr && f.move(i, u.dr), vI(f.round(), d, u);
  });
}
var qTe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const YTe = (n, e, t) => {
  const r = ZP(e, t.start || e.getOrigin()), i = ZP(e, t.end || e.getCorner());
  return Cb(n, r, i, t);
}, XTe = (n, e, t) => Cb(n, e.getTopLeft(), e.getBottomLeft(), t), UTe = (n, e, t) => Cb(n, e.getTopRight(), e.getBottomRight(), t), KTe = (n, e, t) => Cb(n, e.getTopLeft(), e.getTopRight(), t), JTe = (n, e, t) => Cb(n, e.getBottomLeft(), e.getBottomRight(), t);
function Cb(n, e, t, r) {
  const i = new Xe(e, t), o = n.length;
  return n.map((a, s) => {
    var { strict: l } = a, u = qTe(a, ["strict"]);
    const c = l || r.strict ? (s + 1) / (o + 1) : (s + 0.5) / o, h = i.pointAt(c);
    return (u.dx || u.dy) && h.translate(u.dx || 0, u.dy || 0), vI(h.round(), 0, u);
  });
}
const eke = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  absolute: GTe,
  bottom: JTe,
  ellipse: jTe,
  ellipseSpread: HTe,
  left: XTe,
  line: YTe,
  right: UTe,
  top: KTe
}, Symbol.toStringTag, { value: "Module" }));
var Rf;
(function(n) {
  n.presets = eke, n.registry = pr.create({
    type: "port layout"
  }), n.registry.register(n.presets, !0);
})(Rf || (Rf = {}));
const tke = {
  position: { x: 0, y: 0 },
  angle: 0,
  attrs: {
    ".": {
      y: "0",
      "text-anchor": "start"
    }
  }
};
function ch(n, e) {
  const { x: t, y: r, angle: i, attrs: o } = e || {};
  return $j({}, { angle: i, attrs: o, position: { x: t, y: r } }, n, tke);
}
const nke = (n, e, t) => ch({ position: e.getTopLeft() }, t), rke = (n, e, t) => ch({
  position: { x: -15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "end" } }
}, t), ike = (n, e, t) => ch({
  position: { x: 15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "start" } }
}, t), oke = (n, e, t) => ch({
  position: { x: 0, y: -15 },
  attrs: { ".": { "text-anchor": "middle" } }
}, t), ake = (n, e, t) => ch({
  position: { x: 0, y: 15 },
  attrs: { ".": { y: ".6em", "text-anchor": "middle" } }
}, t), ske = (n, e, t) => l9(n, e, !1, t), lke = (n, e, t) => l9(n, e, !0, t), uke = (n, e, t) => u9(n, e, !1, t), cke = (n, e, t) => u9(n, e, !0, t);
function l9(n, e, t, r) {
  const i = r.offset != null ? r.offset : 15, o = e.getCenter().theta(n), a = c9(e);
  let s, l, u, c, h = 0;
  return o < a[1] || o > a[2] ? (s = ".3em", l = i, u = 0, c = "start") : o < a[0] ? (s = "0", l = 0, u = -i, t ? (h = -90, c = "start") : c = "middle") : o < a[3] ? (s = ".3em", l = -i, u = 0, c = "end") : (s = ".6em", l = 0, u = i, t ? (h = 90, c = "start") : c = "middle"), ch({
    position: {
      x: Math.round(l),
      y: Math.round(u)
    },
    angle: h,
    attrs: {
      ".": {
        y: s,
        "text-anchor": c
      }
    }
  }, r);
}
function u9(n, e, t, r) {
  const i = r.offset != null ? r.offset : 15, o = e.getCenter().theta(n), a = c9(e);
  let s, l, u, c, h = 0;
  return o < a[1] || o > a[2] ? (s = ".3em", l = -i, u = 0, c = "end") : o < a[0] ? (s = ".6em", l = 0, u = i, t ? (h = 90, c = "start") : c = "middle") : o < a[3] ? (s = ".3em", l = i, u = 0, c = "start") : (s = "0em", l = 0, u = -i, t ? (h = -90, c = "start") : c = "middle"), ch({
    position: {
      x: Math.round(l),
      y: Math.round(u)
    },
    angle: h,
    attrs: {
      ".": {
        y: s,
        "text-anchor": c
      }
    }
  }, r);
}
function c9(n) {
  const e = n.getCenter(), t = e.theta(n.getTopLeft()), r = e.theta(n.getBottomLeft()), i = e.theta(n.getBottomRight()), o = e.theta(n.getTopRight());
  return [t, o, i, r];
}
const hke = (n, e, t) => h9(n.diff(e.getCenter()), !1, t), fke = (n, e, t) => h9(n.diff(e.getCenter()), !0, t);
function h9(n, e, t) {
  const r = t.offset != null ? t.offset : 20, i = new G(0, 0), o = -n.theta(i), a = n.clone().move(i, r).diff(n).round();
  let s = ".3em", l, u = o;
  return (o + 90) % 180 === 0 ? (l = e ? "end" : "middle", !e && o === -270 && (s = "0em")) : o > -270 && o < -90 ? (l = "start", u = o - 180) : l = "end", ch({
    position: a.round().toJSON(),
    angle: e ? u : 0,
    attrs: {
      ".": {
        y: s,
        "text-anchor": l
      }
    }
  }, t);
}
const dke = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: ake,
  inside: uke,
  insideOriented: cke,
  left: rke,
  manual: nke,
  outside: ske,
  outsideOriented: lke,
  radial: hke,
  radialOriented: fke,
  right: ike,
  top: oke
}, Symbol.toStringTag, { value: "Module" }));
var kg;
(function(n) {
  n.presets = dke, n.registry = pr.create({
    type: "port label layout"
  }), n.registry.register(n.presets, !0);
})(kg || (kg = {}));
var pke = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
let Dn = class Bm extends Yn {
  get priority() {
    return 2;
  }
  /** If need remove `this.container` DOM */
  get disposeContainer() {
    return !0;
  }
  constructor() {
    super(), this.cid = WP.uniqueId(), Bm.views[this.cid] = this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t) {
    return 0;
  }
  empty(e = this.container) {
    return Sb(e), this;
  }
  unmount(e = this.container) {
    return cl(e), this;
  }
  remove(e = this.container) {
    return e === this.container ? (this.removeEventListeners(document), this.onRemove(), delete Bm.views[this.cid], this.disposeContainer && this.unmount(e)) : this.unmount(e), this;
  }
  onRemove() {
  }
  setClass(e, t = this.container) {
    t.classList.value = Array.isArray(e) ? e.join(" ") : e;
  }
  addClass(e, t = this.container) {
    return lt(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  removeClass(e, t = this.container) {
    return br(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  setStyle(e, t = this.container) {
    return Mr(t, e), this;
  }
  setAttrs(e, t = this.container) {
    return e != null && t != null && Xt(t, e), this;
  }
  /**
   * Returns the value of the specified attribute of `node`.
   *
   * If the node does not set a value for attribute, start recursing up
   * the DOM tree from node to lookup for attribute at the ancestors of
   * node. If the recursion reaches CellView's root node and attribute
   * is not found even there, return `null`.
   */
  findAttr(e, t = this.container) {
    let r = t;
    for (; r && r.nodeType === 1; ) {
      const i = r.getAttribute(e);
      if (i != null)
        return i;
      if (r === this.container)
        return null;
      r = r.parentNode;
    }
    return null;
  }
  find(e, t = this.container, r = this.selectors) {
    return Bm.find(e, t, r).elems;
  }
  findOne(e, t = this.container, r = this.selectors) {
    const i = this.find(e, t, r);
    return i.length > 0 ? i[0] : null;
  }
  findByAttr(e, t = this.container) {
    let r = t;
    for (; r && r.getAttribute; ) {
      const i = r.getAttribute(e);
      if ((i != null || r === this.container) && i !== "false")
        return r;
      r = r.parentNode;
    }
    return null;
  }
  getSelector(e, t) {
    let r;
    if (e === this.container)
      return typeof t == "string" && (r = `> ${t}`), r;
    if (e) {
      const i = uI(e) + 1;
      r = `${e.tagName.toLowerCase()}:nth-child(${i})`, t && (r += ` > ${t}`), r = this.getSelector(e.parentNode, r);
    }
    return r;
  }
  prefixClassName(e) {
    return Da.prefix(e);
  }
  delegateEvents(e, t) {
    if (e == null)
      return this;
    t || this.undelegateEvents();
    const r = /^(\S+)\s*(.*)$/;
    return Object.keys(e).forEach((i) => {
      const o = i.match(r);
      if (o == null)
        return;
      const a = this.getEventHandler(e[i]);
      typeof a == "function" && this.delegateEvent(o[1], o[2], a);
    }), this;
  }
  undelegateEvents() {
    return ii.off(this.container, this.getEventNamespace()), this;
  }
  delegateDocumentEvents(e, t) {
    return this.addEventListeners(document, e, t), this;
  }
  undelegateDocumentEvents() {
    return this.removeEventListeners(document), this;
  }
  delegateEvent(e, t, r) {
    return ii.on(this.container, e + this.getEventNamespace(), t, r), this;
  }
  undelegateEvent(e, t, r) {
    const i = e + this.getEventNamespace();
    return t == null ? ii.off(this.container, i) : typeof t == "string" ? ii.off(this.container, i, t, r) : ii.off(this.container, i, t), this;
  }
  addEventListeners(e, t, r) {
    if (t == null)
      return this;
    const i = this.getEventNamespace();
    return Object.keys(t).forEach((o) => {
      const a = this.getEventHandler(t[o]);
      typeof a == "function" && ii.on(e, o + i, r, a);
    }), this;
  }
  removeEventListeners(e) {
    return e != null && ii.off(e, this.getEventNamespace()), this;
  }
  getEventNamespace() {
    return `.${Da.prefixCls}-event-${this.cid}`;
  }
  // eslint-disable-next-line
  getEventHandler(e) {
    let t;
    if (typeof e == "string") {
      const r = this[e];
      typeof r == "function" && (t = (...i) => r.call(this, ...i));
    } else
      t = (...r) => e.call(this, ...r);
    return t;
  }
  getEventTarget(e, t = {}) {
    const { target: r, type: i, clientX: o = 0, clientY: a = 0 } = e;
    return t.fromPoint || i === "touchmove" || i === "touchend" ? document.elementFromPoint(o, a) : r;
  }
  stopPropagation(e) {
    return this.setEventData(e, { propagationStopped: !0 }), this;
  }
  isPropagationStopped(e) {
    return this.getEventData(e).propagationStopped === !0;
  }
  getEventData(e) {
    return this.eventData(e);
  }
  setEventData(e, t) {
    return this.eventData(e, t);
  }
  eventData(e, t) {
    if (e == null)
      throw new TypeError("Event object required");
    let r = e.data;
    const i = `__${this.cid}__`;
    return t == null ? r == null ? {} : r[i] || {} : (r == null && (r = e.data = {}), r[i] == null ? r[i] = Object.assign({}, t) : r[i] = Object.assign(Object.assign({}, r[i]), t), r[i]);
  }
  normalizeEvent(e) {
    return Bm.normalizeEvent(e);
  }
  dispose() {
    this.remove();
  }
};
pke([
  Dn.dispose()
], Dn.prototype, "dispose", null);
(function(n) {
  function e(i, o) {
    return o ? xs(i || "g") : lI(i || "div");
  }
  n.createElement = e;
  function t(i, o, a) {
    if (!i || i === ".")
      return { elems: [o] };
    if (a) {
      const s = a[i];
      if (s)
        return { elems: Array.isArray(s) ? s : [s] };
    }
    {
      const s = i.includes(">") ? `:scope ${i}` : i;
      return {
        isCSSSelector: !0,
        // $(rootElem).find(selector).toArray() as Element[]
        elems: Array.prototype.slice.call(o.querySelectorAll(s))
      };
    }
  }
  n.find = t;
  function r(i) {
    let o = i;
    const a = i.originalEvent, s = a && a.changedTouches && a.changedTouches[0];
    if (s) {
      for (const l in i)
        s[l] === void 0 && (s[l] = i[l]);
      o = s;
    }
    return o;
  }
  n.normalizeEvent = r;
})(Dn || (Dn = {}));
(function(n) {
  n.views = {};
  function e(t) {
    return n.views[t] || null;
  }
  n.getView = e;
})(Dn || (Dn = {}));
var WP;
(function(n) {
  let e = 0;
  function t() {
    const r = `v${e}`;
    return e += 1, r;
  }
  n.uniqueId = t;
})(WP || (WP = {}));
class gke {
  constructor(e) {
    this.view = e, this.clean();
  }
  clean() {
    this.elemCache && this.elemCache.dispose(), this.elemCache = new FP(), this.pathCache = {};
  }
  get(e) {
    return this.elemCache.has(e) || this.elemCache.set(e, {}), this.elemCache.get(e);
  }
  getData(e) {
    const t = this.get(e);
    return t.data || (t.data = {}), t.data;
  }
  getMatrix(e) {
    const t = this.get(e);
    if (t.matrix == null) {
      const r = this.view.container;
      t.matrix = J2e(e, r);
    }
    return Xr(t.matrix);
  }
  getShape(e) {
    const t = this.get(e);
    return t.shape == null && (t.shape = gn.toGeometryShape(e)), t.shape.clone();
  }
  getBoundingRect(e) {
    const t = this.get(e);
    return t.boundingRect == null && (t.boundingRect = gn.getBBoxV2(e)), t.boundingRect.clone();
  }
}
var Mn;
(function(n) {
  function e(u) {
    return u != null && !t(u);
  }
  n.isJSONMarkup = e;
  function t(u) {
    return u != null && typeof u == "string";
  }
  n.isStringMarkup = t;
  function r(u) {
    return u == null || t(u) ? u : Sn(u);
  }
  n.clone = r;
  function i(u) {
    return `${u}`.trim().replace(/[\r|\n]/g, " ").replace(/>\s+</g, "><");
  }
  n.sanitize = i;
  function o(u, c = { ns: Hr.svg }) {
    const h = document.createDocumentFragment(), f = {}, d = {}, p = [
      {
        markup: Array.isArray(u) ? u : [u],
        parent: h,
        ns: c.ns
      }
    ];
    for (; p.length > 0; ) {
      const g = p.pop();
      let v = g.ns || Hr.svg;
      const m = g.markup, y = g.parent;
      m.forEach((b) => {
        const O = b.tagName;
        if (!O)
          throw new TypeError("Invalid tagName");
        b.ns && (v = b.ns);
        const w = v ? lI(O, v) : qB(O), x = b.attrs;
        x && Xt(w, i0(x));
        const S = b.style;
        S && Mr(w, S);
        const _ = b.className;
        _ != null && w.setAttribute("class", Array.isArray(_) ? _.join(" ") : _), b.textContent && (w.textContent = b.textContent);
        const C = b.selector;
        if (C != null) {
          if (d[C])
            throw new TypeError("Selector must be unique");
          d[C] = w;
        }
        if (b.groupSelector) {
          let k = b.groupSelector;
          Array.isArray(k) || (k = [k]), k.forEach((P) => {
            f[P] || (f[P] = []), f[P].push(w);
          });
        }
        y.appendChild(w);
        const A = b.children;
        Array.isArray(A) && p.push({ ns: v, markup: A, parent: w });
      });
    }
    return Object.keys(f).forEach((g) => {
      if (d[g])
        throw new Error("Ambiguous group selector");
      d[g] = f[g];
    }), { fragment: h, selectors: d, groups: f };
  }
  n.parseJSONMarkup = o;
  function a(u) {
    return u instanceof SVGElement ? xs("g") : qB("div");
  }
  function s(u) {
    if (t(u)) {
      const d = pt.createVectors(u), p = d.length;
      if (p === 1)
        return {
          elem: d[0].node
        };
      if (p > 1) {
        const g = a(d[0].node);
        return d.forEach((v) => {
          g.appendChild(v.node);
        }), { elem: g };
      }
      return {};
    }
    const c = o(u), h = c.fragment;
    let f = null;
    return h.childNodes.length > 1 ? (f = a(h.firstChild), f.appendChild(h)) : f = h.firstChild, { elem: f, selectors: c.selectors };
  }
  n.renderMarkup = s;
  function l(u) {
    const c = pt.createVectors(u), h = document.createDocumentFragment();
    for (let f = 0, d = c.length; f < d; f += 1) {
      const p = c[f].node;
      h.appendChild(p);
    }
    return { fragment: h, selectors: {} };
  }
  n.parseLabelStringMarkup = l;
})(Mn || (Mn = {}));
(function(n) {
  function e(t, r, i) {
    if (t != null) {
      let o;
      const a = t.tagName.toLowerCase();
      if (t === r)
        return typeof i == "string" ? o = `> ${a} > ${i}` : o = `> ${a}`, o;
      const s = t.parentNode;
      if (s && s.childNodes.length > 1) {
        const l = uI(t) + 1;
        o = `${a}:nth-child(${l})`;
      } else
        o = a;
      return i && (o += ` > ${i}`), e(t.parentNode, r, o);
    }
    return i;
  }
  n.getSelector = e;
})(Mn || (Mn = {}));
(function(n) {
  function e() {
    return "g";
  }
  n.getPortContainerMarkup = e;
  function t() {
    return {
      tagName: "circle",
      selector: "circle",
      attrs: {
        r: 10,
        fill: "#FFFFFF",
        stroke: "#000000"
      }
    };
  }
  n.getPortMarkup = t;
  function r() {
    return {
      tagName: "text",
      selector: "text",
      attrs: {
        fill: "#000000"
      }
    };
  }
  n.getPortLabelMarkup = r;
})(Mn || (Mn = {}));
(function(n) {
  function e() {
    return [
      {
        tagName: "path",
        selector: "wrap",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          cursor: "pointer",
          stroke: "transparent",
          strokeLinecap: "round"
        }
      },
      {
        tagName: "path",
        selector: "line",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          pointerEvents: "none"
        }
      }
    ];
  }
  n.getEdgeMarkup = e;
})(Mn || (Mn = {}));
(function(n) {
  function e(t = !1) {
    return {
      tagName: "foreignObject",
      selector: "fo",
      children: [
        {
          ns: Hr.xhtml,
          tagName: "body",
          selector: "foBody",
          attrs: {
            xmlns: Hr.xhtml
          },
          style: {
            width: "100%",
            height: "100%",
            background: "transparent"
          },
          children: t ? [] : [
            {
              tagName: "div",
              selector: "foContent",
              style: {
                width: "100%",
                height: "100%"
              }
            }
          ]
        }
      ]
    };
  }
  n.getForeignObjectMarkup = e;
})(Mn || (Mn = {}));
class f9 {
  constructor(e) {
    this.view = e;
  }
  get cell() {
    return this.view.cell;
  }
  getDefinition(e) {
    return this.cell.getAttrDefinition(e);
  }
  processAttrs(e, t) {
    let r, i, o, a;
    const s = [];
    return Object.keys(t).forEach((l) => {
      const u = t[l], c = this.getDefinition(l), h = rt(bl.isValidDefinition, this.view, c, u, {
        elem: e,
        attrs: t,
        cell: this.cell,
        view: this.view
      });
      if (c && h)
        typeof c == "string" ? (r == null && (r = {}), r[c] = u) : u !== null && s.push({ name: l, definition: c });
      else {
        r == null && (r = {});
        const f = Cq.includes(l) ? l : aq(l);
        r[f] = u;
      }
    }), s.forEach(({ name: l, definition: u }) => {
      const c = t[l];
      typeof u.set == "function" && (i == null && (i = {}), i[l] = c), typeof u.offset == "function" && (o == null && (o = {}), o[l] = c), typeof u.position == "function" && (a == null && (a = {}), a[l] = c);
    }), {
      raw: t,
      normal: r,
      set: i,
      offset: o,
      position: a
    };
  }
  mergeProcessedAttrs(e, t) {
    e.set = Object.assign(Object.assign({}, e.set), t.set), e.position = Object.assign(Object.assign({}, e.position), t.position), e.offset = Object.assign(Object.assign({}, e.offset), t.offset);
    const r = e.normal && e.normal.transform;
    r != null && t.normal && (t.normal.transform = r), e.normal = t.normal;
  }
  findAttrs(e, t, r, i) {
    const o = [], a = new FP();
    return Object.keys(e).forEach((s) => {
      const l = e[s];
      if (!bs(l))
        return;
      const { isCSSSelector: u, elems: c } = Dn.find(s, t, i);
      r[s] = c;
      for (let h = 0, f = c.length; h < f; h += 1) {
        const d = c[h], p = i && i[s] === d, g = a.get(d);
        if (g) {
          g.array || (o.push(d), g.array = !0, g.attrs = [g.attrs], g.priority = [g.priority]);
          const v = g.attrs, m = g.priority;
          if (p)
            v.unshift(l), m.unshift(-1);
          else {
            const y = Nde(m, u ? -1 : f);
            v.splice(y, 0, l), m.splice(y, 0, f);
          }
        } else
          a.set(d, {
            elem: d,
            attrs: l,
            priority: p ? -1 : f,
            array: !1
          });
      }
    }), o.forEach((s) => {
      const l = a.get(s), u = l.attrs;
      l.attrs = u.reduceRight((c, h) => er(c, h), {});
    }), a;
  }
  updateRelativeAttrs(e, t, r) {
    const i = t.raw || {};
    let o = t.normal || {};
    const a = t.set, s = t.position, l = t.offset, u = () => ({
      elem: e,
      cell: this.cell,
      view: this.view,
      attrs: i,
      refBBox: r.clone()
    });
    if (a != null && Object.keys(a).forEach((v) => {
      const m = a[v], y = this.getDefinition(v);
      if (y != null) {
        const b = rt(y.set, this.view, m, u());
        typeof b == "object" ? o = Object.assign(Object.assign({}, o), b) : b != null && (o[v] = b);
      }
    }), e instanceof HTMLElement) {
      this.view.setAttrs(o, e);
      return;
    }
    const c = o.transform, h = c ? `${c}` : null, f = o0(h), d = new G(f.e, f.f);
    c && (delete o.transform, f.e = 0, f.f = 0);
    let p = !1;
    s != null && Object.keys(s).forEach((v) => {
      const m = s[v], y = this.getDefinition(v);
      if (y != null) {
        const b = rt(y.position, this.view, m, u());
        b != null && (p = !0, d.translate(G.create(b)));
      }
    }), this.view.setAttrs(o, e);
    let g = !1;
    if (l != null) {
      const v = this.view.getBoundingRectOfElement(e);
      if (v.width > 0 && v.height > 0) {
        const m = gn.transformRectangle(v, f);
        Object.keys(l).forEach((y) => {
          const b = l[y], O = this.getDefinition(y);
          if (O != null) {
            const w = rt(O.offset, this.view, b, {
              elem: e,
              cell: this.cell,
              view: this.view,
              attrs: i,
              refBBox: m
            });
            w != null && (g = !0, d.translate(G.create(w)));
          }
        });
      }
    }
    (c != null || p || g) && (d.round(1), f.e = d.x, f.f = d.y, e.setAttribute("transform", yv(f)));
  }
  update(e, t, r) {
    const i = {}, o = this.findAttrs(r.attrs || t, e, i, r.selectors), a = r.attrs ? this.findAttrs(t, e, i, r.selectors) : o, s = [];
    o.each((c) => {
      const h = c.elem, f = c.attrs, d = this.processAttrs(h, f);
      if (d.set == null && d.position == null && d.offset == null)
        this.view.setAttrs(d.normal, h);
      else {
        const p = a.get(h), g = p ? p.attrs : null, v = g && f.ref == null ? g.ref : f.ref;
        let m;
        if (v) {
          if (m = (i[v] || this.view.find(v, e, r.selectors))[0], !m)
            throw new Error(`"${v}" reference does not exist.`);
        } else
          m = null;
        const y = {
          node: h,
          refNode: m,
          attributes: g,
          processedAttributes: d
        }, b = s.findIndex((O) => O.refNode === h);
        b > -1 ? s.splice(b, 0, y) : s.push(y);
      }
    });
    const l = new FP();
    let u;
    s.forEach((c) => {
      const h = c.node, f = c.refNode;
      let d;
      const p = f != null && r.rotatableNode != null && Sq(r.rotatableNode, f);
      if (f && (d = l.get(f)), !d) {
        const m = p ? r.rotatableNode : e;
        d = f ? gn.getBBox(f, { target: m }) : r.rootBBox, f && l.set(f, d);
      }
      let g;
      r.attrs && c.attributes ? (g = this.processAttrs(h, c.attributes), this.mergeProcessedAttrs(g, c.processedAttributes)) : g = c.processedAttributes;
      let v = d;
      p && r.rotatableNode != null && !r.rotatableNode.contains(h) && (u || (u = o0(Xt(r.rotatableNode, "transform"))), v = gn.transformRectangle(d, u)), this.updateRelativeAttrs(h, g, v);
    });
  }
}
class d9 {
  get cell() {
    return this.view.cell;
  }
  constructor(e, t, r = []) {
    this.view = e;
    const i = {}, o = {};
    let a = 0;
    Object.keys(t).forEach((l) => {
      let u = t[l];
      Array.isArray(u) || (u = [u]), u.forEach((c) => {
        let h = i[c];
        h || (a += 1, h = i[c] = 1 << a), o[l] |= h;
      });
    });
    let s = r;
    if (Array.isArray(s) || (s = [s]), s.forEach((l) => {
      i[l] || (a += 1, i[l] = 1 << a);
    }), a > 25)
      throw new Error("Maximum number of flags exceeded.");
    this.flags = i, this.attrs = o, this.bootstrap = r;
  }
  getFlag(e) {
    const t = this.flags;
    return t == null ? 0 : Array.isArray(e) ? e.reduce((r, i) => r | t[i], 0) : t[e] | 0;
  }
  hasAction(e, t) {
    return e & this.getFlag(t);
  }
  removeAction(e, t) {
    return e ^ e & this.getFlag(t);
  }
  getBootstrapFlag() {
    return this.getFlag(this.bootstrap);
  }
  getChangedFlag() {
    let e = 0;
    return this.attrs && Object.keys(this.attrs).forEach((t) => {
      this.cell.hasChanged(t) && (e |= this.attrs[t]);
    }), e;
  }
}
var vke = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
}, mke = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class fr extends Dn {
  static getDefaults() {
    return this.defaults;
  }
  static config(e) {
    this.defaults = this.getOptions(e);
  }
  static getOptions(e) {
    const t = (u, c) => c != null ? qj([
      ...Array.isArray(u) ? u : [u],
      ...Array.isArray(c) ? c : [c]
    ]) : Array.isArray(u) ? [...u] : [u], r = Sn(this.getDefaults()), { bootstrap: i, actions: o, events: a, documentEvents: s } = e, l = mke(e, ["bootstrap", "actions", "events", "documentEvents"]);
    return i && (r.bootstrap = t(r.bootstrap, i)), o && Object.entries(o).forEach(([u, c]) => {
      const h = r.actions[u];
      c && h ? r.actions[u] = t(h, c) : c && (r.actions[u] = t(c));
    }), a && (r.events = Object.assign(Object.assign({}, r.events), a)), e.documentEvents && (r.documentEvents = Object.assign(Object.assign({}, r.documentEvents), s)), er(r, l);
  }
  get [Symbol.toStringTag]() {
    return fr.toStringTag;
  }
  constructor(e, t = {}) {
    super(), this.cell = e, this.options = this.ensureOptions(t), this.graph = this.options.graph, this.attr = new f9(this), this.flag = new d9(this, this.options.actions, this.options.bootstrap), this.cache = new gke(this), this.setContainer(this.ensureContainer()), this.setup(), this.init();
  }
  init() {
  }
  onRemove() {
    this.removeTools();
  }
  get priority() {
    return this.options.priority;
  }
  get rootSelector() {
    return this.options.rootSelector;
  }
  getConstructor() {
    return this.constructor;
  }
  ensureOptions(e) {
    return this.getConstructor().getOptions(e);
  }
  getContainerTagName() {
    return this.options.isSvgElement ? "g" : "div";
  }
  getContainerStyle() {
  }
  getContainerAttrs() {
    return {
      "data-cell-id": this.cell.id,
      "data-shape": this.cell.shape
    };
  }
  getContainerClassName() {
    return this.prefixClassName("cell");
  }
  ensureContainer() {
    return Dn.createElement(this.getContainerTagName(), this.options.isSvgElement);
  }
  setContainer(e) {
    if (this.container !== e) {
      this.undelegateEvents(), this.container = e, this.options.events != null && this.delegateEvents(this.options.events);
      const t = this.getContainerAttrs();
      t != null && this.setAttrs(t, e);
      const r = this.getContainerStyle();
      r != null && this.setStyle(r, e);
      const i = this.getContainerClassName();
      i != null && this.addClass(i, e);
    }
    return this;
  }
  isNodeView() {
    return !1;
  }
  isEdgeView() {
    return !1;
  }
  render() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t = {}) {
    return 0;
  }
  getBootstrapFlag() {
    return this.flag.getBootstrapFlag();
  }
  getFlag(e) {
    return this.flag.getFlag(e);
  }
  hasAction(e, t) {
    return this.flag.hasAction(e, t);
  }
  removeAction(e, t) {
    return this.flag.removeAction(e, t);
  }
  handleAction(e, t, r, i) {
    if (this.hasAction(e, t)) {
      r();
      const o = [t];
      return i && (typeof i == "string" ? o.push(i) : o.push(...i)), this.removeAction(e, o);
    }
    return e;
  }
  setup() {
    this.cell.on("changed", this.onCellChanged, this);
  }
  onCellChanged({ options: e }) {
    this.onAttrsChange(e);
  }
  onAttrsChange(e) {
    let t = this.flag.getChangedFlag();
    e.updated || !t || (e.dirty && this.hasAction(t, "update") && (t |= this.getFlag("render")), e.toolId && (e.async = !1), this.graph != null && this.graph.renderer.requestViewUpdate(this, t, e));
  }
  parseJSONMarkup(e, t) {
    const r = Mn.parseJSONMarkup(e), i = r.selectors, o = this.rootSelector;
    if (t && o) {
      if (i[o])
        throw new Error("Invalid root selector");
      i[o] = t;
    }
    return r;
  }
  can(e) {
    let t = this.graph.options.interacting;
    if (typeof t == "function" && (t = rt(t, this.graph, this)), typeof t == "object") {
      let r = t[e];
      return typeof r == "function" && (r = rt(r, this.graph, this)), r !== !1;
    }
    return typeof t == "boolean" ? t : !1;
  }
  cleanCache() {
    return this.cache.clean(), this;
  }
  getCache(e) {
    return this.cache.get(e);
  }
  getDataOfElement(e) {
    return this.cache.getData(e);
  }
  getMatrixOfElement(e) {
    return this.cache.getMatrix(e);
  }
  getShapeOfElement(e) {
    return this.cache.getShape(e);
  }
  getBoundingRectOfElement(e) {
    return this.cache.getBoundingRect(e);
  }
  getBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), r = this.getMatrixOfElement(e), i = this.getRootRotatedMatrix(), o = this.getRootTranslatedMatrix();
    return gn.transformRectangle(t, o.multiply(i).multiply(r));
  }
  getUnrotatedBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), r = this.getMatrixOfElement(e), i = this.getRootTranslatedMatrix();
    return gn.transformRectangle(t, i.multiply(r));
  }
  getBBox(e = {}) {
    let t;
    if (e.useCellGeometry) {
      const r = this.cell, i = r.isNode() ? r.getAngle() : 0;
      t = r.getBBox().bbox(i);
    } else
      t = this.getBBoxOfElement(this.container);
    return this.graph.coord.localToGraphRect(t);
  }
  getRootTranslatedMatrix() {
    const e = this.cell, t = e.isNode() ? e.getPosition() : { x: 0, y: 0 };
    return Xr().translate(t.x, t.y);
  }
  getRootRotatedMatrix() {
    let e = Xr();
    const t = this.cell, r = t.isNode() ? t.getAngle() : 0;
    if (r) {
      const i = t.getBBox(), o = i.width / 2, a = i.height / 2;
      e = e.translate(o, a).rotate(r).translate(-o, -a);
    }
    return e;
  }
  findMagnet(e = this.container) {
    return this.findByAttr("magnet", e);
  }
  updateAttrs(e, t, r = {}) {
    r.rootBBox == null && (r.rootBBox = new Te()), r.selectors == null && (r.selectors = this.selectors), this.attr.update(e, t, r);
  }
  isEdgeElement(e) {
    return this.cell.isEdge() && (e == null || e === this.container);
  }
  // #region highlight
  prepareHighlight(e, t = {}) {
    const r = e || this.container;
    return t.partial = r === this.container, r;
  }
  highlight(e, t = {}) {
    const r = this.prepareHighlight(e, t);
    return this.notify("cell:highlight", {
      magnet: r,
      options: t,
      view: this,
      cell: this.cell
    }), this.isEdgeView() ? this.notify("edge:highlight", {
      magnet: r,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }) : this.isNodeView() && this.notify("node:highlight", {
      magnet: r,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }), this;
  }
  unhighlight(e, t = {}) {
    const r = this.prepareHighlight(e, t);
    return this.notify("cell:unhighlight", {
      magnet: r,
      options: t,
      view: this,
      cell: this.cell
    }), this.isNodeView() ? this.notify("node:unhighlight", {
      magnet: r,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }) : this.isEdgeView() && this.notify("edge:unhighlight", {
      magnet: r,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }), this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  notifyUnhighlight(e, t) {
  }
  // #endregion
  getEdgeTerminal(e, t, r, i, o) {
    const a = this.cell, s = this.findAttr("port", e), l = e.getAttribute("data-selector"), u = { cell: a.id };
    return l != null && (u.magnet = l), s != null ? (u.port = s, a.isNode() && !a.hasPort(s) && l == null && (u.selector = this.getSelector(e))) : l == null && this.container !== e && (u.selector = this.getSelector(e)), u;
  }
  getMagnetFromEdgeTerminal(e) {
    const t = this.cell, r = this.container, i = e.port;
    let o = e.magnet, a;
    return i != null && t.isNode() && t.hasPort(i) ? a = this.findPortElem(i, o) || r : (o || (o = e.selector), !o && i != null && (o = `[port="${i}"]`), a = this.findOne(o, r, this.selectors)), a;
  }
  hasTools(e) {
    const t = this.tools;
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  addTools(e) {
    if (this.removeTools(), e) {
      if (!this.can("toolsAddable"))
        return this;
      const t = xr.isToolsView(e) ? e : new xr(e);
      this.tools = t, t.config({ view: this }), t.mount();
    }
    return this;
  }
  updateTools(e = {}) {
    return this.tools && this.tools.update(e), this;
  }
  removeTools() {
    return this.tools && (this.tools.remove(), this.tools = null), this;
  }
  hideTools() {
    return this.tools && this.tools.hide(), this;
  }
  showTools() {
    return this.tools && this.tools.show(), this;
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  notify(e, t) {
    return this.trigger(e, t), this.graph.trigger(e, t), this;
  }
  getEventArgs(e, t, r) {
    const i = this, o = i.cell;
    return t == null || r == null ? { e, view: i, cell: o } : { e, x: t, y: r, view: i, cell: o };
  }
  onClick(e, t, r) {
    this.notify("cell:click", this.getEventArgs(e, t, r));
  }
  onDblClick(e, t, r) {
    this.notify("cell:dblclick", this.getEventArgs(e, t, r));
  }
  onContextMenu(e, t, r) {
    this.notify("cell:contextmenu", this.getEventArgs(e, t, r));
  }
  onMouseDown(e, t, r) {
    this.cell.model && (this.cachedModelForMouseEvent = this.cell.model, this.cachedModelForMouseEvent.startBatch("mouse")), this.notify("cell:mousedown", this.getEventArgs(e, t, r));
  }
  onMouseUp(e, t, r) {
    this.notify("cell:mouseup", this.getEventArgs(e, t, r)), this.cachedModelForMouseEvent && (this.cachedModelForMouseEvent.stopBatch("mouse", { cell: this.cell }), this.cachedModelForMouseEvent = null);
  }
  onMouseMove(e, t, r) {
    this.notify("cell:mousemove", this.getEventArgs(e, t, r));
  }
  onMouseOver(e) {
    this.notify("cell:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    this.notify("cell:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    this.notify("cell:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    this.notify("cell:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, r, i) {
    this.notify("cell:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, r)));
  }
  onCustomEvent(e, t, r, i) {
    this.notify("cell:customevent", Object.assign({ name: t }, this.getEventArgs(e, r, i))), this.notify(t, Object.assign({}, this.getEventArgs(e, r, i)));
  }
  onMagnetMouseDown(e, t, r, i) {
  }
  onMagnetDblClick(e, t, r, i) {
  }
  onMagnetContextMenu(e, t, r, i) {
  }
  onLabelMouseDown(e, t, r) {
  }
  checkMouseleave(e) {
    const t = this.getEventTarget(e, { fromPoint: !0 }), r = this.graph.findViewByElem(t);
    r !== this && (this.onMouseLeave(e), r && r.onMouseEnter(e));
  }
  dispose() {
    this.cell.off("changed", this.onCellChanged, this);
  }
}
fr.defaults = {
  isSvgElement: !0,
  rootSelector: "root",
  priority: 0,
  bootstrap: [],
  actions: {}
};
vke([
  fr.dispose()
], fr.prototype, "dispose", null);
(function(n) {
  n.Flag = d9, n.Attr = f9;
})(fr || (fr = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function";
  }
  n.isCellView = e;
})(fr || (fr = {}));
(function(n) {
  function e(r) {
    return function(i) {
      i.config({ priority: r });
    };
  }
  n.priority = e;
  function t(r) {
    return function(i) {
      i.config({ bootstrap: r });
    };
  }
  n.bootstrap = t;
})(fr || (fr = {}));
(function(n) {
  n.registry = pr.create({
    type: "view"
  });
})(fr || (fr = {}));
class xr extends Dn {
  get name() {
    return this.options.name;
  }
  get graph() {
    return this.cellView.graph;
  }
  get cell() {
    return this.cellView.cell;
  }
  get [Symbol.toStringTag]() {
    return xr.toStringTag;
  }
  constructor(e = {}) {
    super(), this.svgContainer = this.createContainer(!0, e), this.htmlContainer = this.createContainer(!1, e), this.config(e);
  }
  createContainer(e, t) {
    const r = e ? Dn.createElement("g", !0) : Dn.createElement("div", !1);
    return lt(r, this.prefixClassName("cell-tools")), t.className && lt(r, t.className), r;
  }
  config(e) {
    if (this.options = Object.assign(Object.assign({}, this.options), e), !fr.isCellView(e.view) || e.view === this.cellView)
      return this;
    this.cellView = e.view, this.cell.isEdge() ? (lt(this.svgContainer, this.prefixClassName("edge-tools")), lt(this.htmlContainer, this.prefixClassName("edge-tools"))) : this.cell.isNode() && (lt(this.svgContainer, this.prefixClassName("node-tools")), lt(this.htmlContainer, this.prefixClassName("node-tools"))), this.svgContainer.setAttribute("data-cell-id", this.cell.id), this.htmlContainer.setAttribute("data-cell-id", this.cell.id), this.name && (this.svgContainer.setAttribute("data-tools-name", this.name), this.htmlContainer.setAttribute("data-tools-name", this.name));
    const t = this.options.items;
    if (!Array.isArray(t))
      return this;
    this.tools = [];
    const r = [];
    t.forEach((i) => {
      xr.ToolItem.isToolItem(i) ? i.name === "vertices" ? r.unshift(i) : r.push(i) : (typeof i == "object" ? i.name : i) === "vertices" ? r.unshift(i) : r.push(i);
    });
    for (let i = 0; i < r.length; i += 1) {
      const o = r[i];
      let a;
      if (xr.ToolItem.isToolItem(o))
        a = o;
      else {
        const s = typeof o == "object" ? o.name : o, l = typeof o == "object" ? o.args || {} : {};
        if (s) {
          if (this.cell.isNode()) {
            const u = Eg.registry.get(s);
            if (u)
              a = new u(l);
            else
              return Eg.registry.onNotFound(s);
          } else if (this.cell.isEdge()) {
            const u = Mg.registry.get(s);
            if (u)
              a = new u(l);
            else
              return Mg.registry.onNotFound(s);
          }
        }
      }
      a && (a.config(this.cellView, this), a.render(), (a.options.isSVGElement !== !1 ? this.svgContainer : this.htmlContainer).appendChild(a.container), this.tools.push(a));
    }
    return this;
  }
  update(e = {}) {
    const t = this.tools;
    return t && t.forEach((r) => {
      e.toolId !== r.cid && r.isVisible() && r.update();
    }), this;
  }
  focus(e) {
    const t = this.tools;
    return t && t.forEach((r) => {
      e === r ? r.show() : r.hide();
    }), this;
  }
  blur(e) {
    const t = this.tools;
    return t && t.forEach((r) => {
      r !== e && !r.isVisible() && (r.show(), r.update());
    }), this;
  }
  hide() {
    return this.focus(null);
  }
  show() {
    return this.blur(null);
  }
  remove() {
    const e = this.tools;
    return e && (e.forEach((t) => t.remove()), this.tools = null), cl(this.svgContainer), cl(this.htmlContainer), super.remove();
  }
  mount() {
    const e = this.tools, t = this.cellView;
    if (t && e) {
      const r = e.some((o) => o.options.isSVGElement !== !1), i = e.some((o) => o.options.isSVGElement === !1);
      r && (this.options.local ? t.container : t.graph.view.decorator).appendChild(this.svgContainer), i && this.graph.container.appendChild(this.htmlContainer);
    }
    return this;
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && i.graph != null && i.cell != null && typeof i.config == "function" && typeof i.update == "function" && typeof i.focus == "function" && typeof i.blur == "function" && typeof i.show == "function" && typeof i.hide == "function";
  }
  n.isToolsView = e;
})(xr || (xr = {}));
(function(n) {
  class e extends Dn {
    static getDefaults() {
      return this.defaults;
    }
    static config(r) {
      this.defaults = this.getOptions(r);
    }
    static getOptions(r) {
      return er(Sn(this.getDefaults()), r);
    }
    get graph() {
      return this.cellView.graph;
    }
    get cell() {
      return this.cellView.cell;
    }
    get name() {
      return this.options.name;
    }
    get [Symbol.toStringTag]() {
      return e.toStringTag;
    }
    constructor(r = {}) {
      super(), this.visible = !0, this.options = this.getOptions(r), this.container = Dn.createElement(this.options.tagName || "g", this.options.isSVGElement !== !1), lt(this.container, this.prefixClassName("cell-tool")), typeof this.options.className == "string" && lt(this.container, this.options.className), this.init();
    }
    init() {
    }
    getOptions(r) {
      return this.constructor.getOptions(r);
    }
    delegateEvents() {
      return this.options.events && super.delegateEvents(this.options.events), this;
    }
    config(r, i) {
      return this.cellView = r, this.parent = i, this.stamp(this.container), this.cell.isEdge() ? lt(this.container, this.prefixClassName("edge-tool")) : this.cell.isNode() && lt(this.container, this.prefixClassName("node-tool")), this.name && this.container.setAttribute("data-tool-name", this.name), this.delegateEvents(), this;
    }
    render() {
      this.empty();
      const r = this.options.markup;
      if (r) {
        const i = Mn.parseJSONMarkup(r);
        this.container.appendChild(i.fragment), this.childNodes = i.selectors;
      }
      return this.onRender(), this;
    }
    onRender() {
    }
    update() {
      return this;
    }
    stamp(r) {
      r && r.setAttribute("data-cell-id", this.cellView.cell.id);
    }
    show() {
      return this.container.style.display = "", this.visible = !0, this;
    }
    hide() {
      return this.container.style.display = "none", this.visible = !1, this;
    }
    isVisible() {
      return this.visible;
    }
    focus() {
      const r = this.options.focusOpacity;
      return r != null && Number.isFinite(r) && (this.container.style.opacity = `${r}`), this.parent.focus(this), this;
    }
    blur() {
      return this.container.style.opacity = "", this.parent.blur(this), this;
    }
    guard(r) {
      return this.graph == null || this.cellView == null ? !0 : this.graph.view.guard(r, this.cellView);
    }
  }
  e.defaults = {
    isSVGElement: !0,
    tagName: "g"
  }, n.ToolItem = e, function(t) {
    let r = 0;
    function i(a) {
      return a ? rI(a) : (r += 1, `CustomTool${r}`);
    }
    function o(a) {
      const s = tI(i(a.name), this);
      return s.config(a), s;
    }
    t.define = o;
  }(e = n.ToolItem || (n.ToolItem = {})), function(t) {
    t.toStringTag = `X6.${t.name}`;
    function r(i) {
      if (i == null)
        return !1;
      if (i instanceof t)
        return !0;
      const o = i[Symbol.toStringTag], a = i;
      return (o == null || o === t.toStringTag) && a.graph != null && a.cell != null && typeof a.config == "function" && typeof a.update == "function" && typeof a.focus == "function" && typeof a.blur == "function" && typeof a.show == "function" && typeof a.hide == "function" && typeof a.isVisible == "function";
    }
    t.isToolItem = r;
  }(e = n.ToolItem || (n.ToolItem = {}));
})(xr || (xr = {}));
const yke = (n) => n;
function a5(n, e) {
  return e === 0 ? "0%" : `${Math.round(n / e * 100)}%`;
}
function p9(n) {
  return (t, r, i, o) => r.isEdgeElement(i) ? Oke(n, t, r, i, o) : bke(n, t, r, i, o);
}
function bke(n, e, t, r, i) {
  const o = t.cell, a = o.getAngle(), s = t.getUnrotatedBBoxOfElement(r), l = o.getBBox().getCenter(), u = G.create(i).rotate(a, l);
  let c = u.x - s.x, h = u.y - s.y;
  return n && (c = a5(c, s.width), h = a5(h, s.height)), e.anchor = {
    name: "topLeft",
    args: {
      dx: c,
      dy: h,
      rotate: !0
    }
  }, e;
}
function Oke(n, e, t, r, i) {
  const o = t.getConnection();
  if (!o)
    return e;
  const a = o.closestPointLength(i);
  if (n) {
    const s = o.length();
    e.anchor = {
      name: "ratio",
      args: {
        ratio: a / s
      }
    };
  } else
    e.anchor = {
      name: "length",
      args: {
        length: a
      }
    };
  return e;
}
const wke = p9(!0), xke = p9(!1), Ske = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  noop: yke,
  pinAbsolute: xke,
  pinRelative: wke
}, Symbol.toStringTag, { value: "Module" }));
var GP;
(function(n) {
  n.presets = Ske, n.registry = pr.create({
    type: "connection strategy"
  }), n.registry.register(n.presets, !0);
})(GP || (GP = {}));
function g9(n, e, t, r) {
  return rt(GP.presets.pinRelative, this.graph, {}, e, t, n, this.cell, r, {}).anchor;
}
function v9(n, e) {
  return e ? n.cell.getBBox() : n.cell.isEdge() ? n.getConnection().bbox() : n.getUnrotatedBBoxOfElement(n.container);
}
class $c extends xr.ToolItem {
  onRender() {
    lt(this.container, this.prefixClassName("cell-tool-button")), this.update();
  }
  update() {
    return this.updatePosition(), this;
  }
  updatePosition() {
    const t = this.cellView.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
    _g(this.container, t, { absolute: !0 });
  }
  getNodeMatrix() {
    const e = this.cellView, t = this.options;
    let { x: r = 0, y: i = 0 } = t;
    const { offset: o, useCellGeometry: a, rotate: s } = t;
    let l = v9(e, a);
    const u = e.cell.getAngle();
    s || (l = l.bbox(u));
    let c = 0, h = 0;
    typeof o == "number" ? (c = o, h = o) : typeof o == "object" && (c = o.x, h = o.y), r = ss(r, l.width), i = ss(i, l.height);
    let f = Xr().translate(l.x + l.width / 2, l.y + l.height / 2);
    return s && (f = f.rotate(u)), f = f.translate(r + c - l.width / 2, i + h - l.height / 2), f;
  }
  getEdgeMatrix() {
    const e = this.cellView, t = this.options, { offset: r = 0, distance: i = 0, rotate: o } = t;
    let a, s, l;
    const u = ss(i, 1);
    u >= 0 && u <= 1 ? a = e.getTangentAtRatio(u) : a = e.getTangentAtLength(u), a ? (s = a.start, l = a.vector().vectorAngle(new G(1, 0)) || 0) : (s = e.getConnection().start, l = 0);
    let c = Xr().translate(s.x, s.y).rotate(l);
    return typeof r == "object" ? c = c.translate(r.x || 0, r.y || 0) : c = c.translate(0, r), o || (c = c.rotate(-l)), c;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.options.onClick;
    typeof t == "function" && rt(t, this.cellView, {
      e,
      view: this.cellView,
      cell: this.cellView.cell,
      btn: this
    });
  }
}
(function(n) {
  n.config({
    name: "button",
    useCellGeometry: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    }
  });
})($c || ($c = {}));
(function(n) {
  n.Remove = n.define({
    name: "button-remove",
    markup: [
      {
        tagName: "circle",
        selector: "button",
        attrs: {
          r: 7,
          fill: "#FF1D00",
          cursor: "pointer"
        }
      },
      {
        tagName: "path",
        selector: "icon",
        attrs: {
          d: "M -3 -3 3 3 M -3 3 3 -3",
          fill: "none",
          stroke: "#FFFFFF",
          "stroke-width": 2,
          "pointer-events": "none"
        }
      }
    ],
    distance: 60,
    offset: 0,
    useCellGeometry: !0,
    onClick({ view: e, btn: t }) {
      t.parent.remove(), e.cell.remove({ ui: !0, toolId: t.cid });
    }
  });
})($c || ($c = {}));
var _ke = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class xx extends xr.ToolItem {
  onRender() {
    if (lt(this.container, this.prefixClassName("cell-tool-boundary")), this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, r = _ke(e, ["class"]);
      Xt(this.container, i0(r)), t && lt(this.container, t);
    }
    this.update();
  }
  update() {
    const e = this.cellView, t = this.options, { useCellGeometry: r, rotate: i } = t, o = Jf(t.padding);
    let a = v9(e, r).moveAndExpand({
      x: -o.left,
      y: -o.top,
      width: o.left + o.right,
      height: o.top + o.bottom
    });
    const s = e.cell;
    if (s.isNode()) {
      const l = s.getAngle();
      if (l)
        if (i) {
          const u = s.getBBox().getCenter();
          $P(this.container, l, u.x, u.y, {
            absolute: !0
          });
        } else
          a = a.bbox(l);
    }
    return Xt(this.container, a.toJSON()), this;
  }
}
(function(n) {
  n.config({
    name: "boundary",
    tagName: "rect",
    padding: 10,
    useCellGeometry: !0,
    attrs: {
      fill: "none",
      stroke: "#333",
      "stroke-width": 0.5,
      "stroke-dasharray": "5, 5",
      "pointer-events": "none"
    }
  });
})(xx || (xx = {}));
class u0 extends xr.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  onRender() {
    return this.addClass(this.prefixClassName("edge-tool-vertices")), this.options.addable && this.updatePath(), this.resetHandles(), this.renderHandles(), this;
  }
  update() {
    return this.vertices.length === this.handles.length ? this.updateHandles() : (this.resetHandles(), this.renderHandles()), this.options.addable && this.updatePath(), this;
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  renderHandles() {
    const e = this.vertices;
    for (let t = 0, r = e.length; t < r; t += 1) {
      const i = e[t], o = this.options.createHandle, a = this.options.processHandle, s = o({
        index: t,
        graph: this.graph,
        guard: (l) => this.guard(l),
        attrs: this.options.attrs || {}
      });
      a && a(s), s.updatePosition(i.x, i.y), this.stamp(s.container), this.container.appendChild(s.container), this.handles.push(s), this.startHandleListening(s);
    }
  }
  updateHandles() {
    const e = this.vertices;
    for (let t = 0, r = e.length; t < r; t += 1) {
      const i = e[t], o = this.handles[t];
      o && o.updatePosition(i.x, i.y);
    }
  }
  updatePath() {
    const e = this.childNodes.connection;
    e && e.setAttribute("d", this.cellView.getConnectionPathData());
  }
  startHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.on("remove", this.onHandleRemove, this);
  }
  stopHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.off("remove", this.onHandleRemove, this);
  }
  getNeighborPoints(e) {
    const t = this.cellView, r = this.vertices, i = e > 0 ? r[e - 1] : t.sourceAnchor, o = e < r.length - 1 ? r[e + 1] : t.targetAnchor;
    return {
      prev: G.create(i),
      next: G.create(o)
    };
  }
  getMouseEventArgs(e) {
    const t = this.normalizeEvent(e), { x: r, y: i } = this.graph.snapToGrid(t.clientX, t.clientY);
    return { e: t, x: r, y: i };
  }
  onHandleChange({ e }) {
    this.focus();
    const t = this.cellView;
    if (t.cell.startBatch("move-vertex", { ui: !0, toolId: this.cid }), !this.options.stopPropagation) {
      const { e: r, x: i, y: o } = this.getMouseEventArgs(e);
      this.eventData(r, { start: { x: i, y: o } }), t.notifyMouseDown(r, i, o);
    }
  }
  onHandleChanging({ handle: e, e: t }) {
    const r = this.cellView, i = e.options.index, { e: o, x: a, y: s } = this.getMouseEventArgs(t), l = { x: a, y: s };
    this.snapVertex(l, i), r.cell.setVertexAt(i, l, { ui: !0, toolId: this.cid }), e.updatePosition(l.x, l.y), this.options.stopPropagation || r.notifyMouseMove(o, a, s);
  }
  stopBatch(e) {
    this.cell.stopBatch("move-vertex", { ui: !0, toolId: this.cid }), e && this.cell.stopBatch("add-vertex", { ui: !0, toolId: this.cid });
  }
  onHandleChanged({ e }) {
    const t = this.options, r = this.cellView;
    if (t.addable && this.updatePath(), !t.removeRedundancies) {
      this.stopBatch(this.eventData(e).vertexAdded);
      return;
    }
    r.removeRedundantLinearVertices({
      ui: !0,
      toolId: this.cid
    }) && this.render(), this.blur(), this.stopBatch(this.eventData(e).vertexAdded);
    const { e: o, x: a, y: s } = this.getMouseEventArgs(e);
    if (!this.options.stopPropagation) {
      r.notifyMouseUp(o, a, s);
      const { start: l } = this.eventData(o);
      if (l) {
        const { x: u, y: c } = l;
        u === a && c === s && r.onClick(o, a, s);
      }
    }
    r.checkMouseleave(o), t.onChanged && t.onChanged({ edge: r.cell, edgeView: r });
  }
  snapVertex(e, t) {
    const r = this.options.snapRadius || 0;
    if (r > 0) {
      const i = this.getNeighborPoints(t), o = i.prev, a = i.next;
      Math.abs(e.x - o.x) < r ? e.x = o.x : Math.abs(e.x - a.x) < r && (e.x = a.x), Math.abs(e.y - o.y) < r ? e.y = i.prev.y : Math.abs(e.y - a.y) < r && (e.y = a.y);
    }
  }
  onHandleRemove({ handle: e, e: t }) {
    if (this.options.removable) {
      const r = e.options.index, i = this.cellView;
      i.cell.removeVertexAt(r, { ui: !0 }), this.options.addable && this.updatePath(), i.checkMouseleave(this.normalizeEvent(t));
    }
  }
  allowAddVertex(e) {
    const t = this.guard(e), r = this.options.addable && this.cellView.can("vertexAddable"), i = this.options.modifiers ? Lc.isMatch(e, this.options.modifiers) : !0;
    return !t && r && i;
  }
  onPathMouseDown(e) {
    const t = this.cellView;
    if (!this.allowAddVertex(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const r = this.normalizeEvent(e), i = this.graph.snapToGrid(r.clientX, r.clientY).toJSON();
    t.cell.startBatch("add-vertex", { ui: !0, toolId: this.cid });
    const o = t.getVertexIndex(i.x, i.y);
    this.snapVertex(i, o), t.cell.insertVertex(i, o, {
      ui: !0,
      toolId: this.cid
    }), this.render();
    const a = this.handles[o];
    this.eventData(r, { vertexAdded: !0 }), a.onMouseDown(r);
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(n) {
  class e extends Dn {
    get graph() {
      return this.options.graph;
    }
    constructor(r) {
      super(), this.options = r, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown",
        dblclick: "onDoubleClick"
      });
    }
    render() {
      this.container = Dn.createElement("circle", !0);
      const r = this.options.attrs;
      if (typeof r == "function") {
        const i = n.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, i.attrs), r(this)));
      } else
        this.setAttrs(r);
      this.addClass(this.prefixClassName("edge-tool-vertex"));
    }
    updatePosition(r, i) {
      this.setAttrs({ cx: r, cy: i });
    }
    onMouseDown(r) {
      this.options.guard(r) || (r.stopPropagation(), r.preventDefault(), this.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, r.data), this.emit("change", { e: r, handle: this }));
    }
    onMouseMove(r) {
      this.emit("changing", { e: r, handle: this });
    }
    onMouseUp(r) {
      this.emit("changed", { e: r, handle: this }), this.undelegateDocumentEvents(), this.graph.view.delegateEvents();
    }
    onDoubleClick(r) {
      this.emit("remove", { e: r, handle: this });
    }
  }
  n.Handle = e;
})(u0 || (u0 = {}));
(function(n) {
  const e = Da.prefix("edge-tool-vertex-path");
  n.config({
    name: "vertices",
    snapRadius: 20,
    addable: !0,
    removable: !0,
    removeRedundancies: !0,
    stopPropagation: !0,
    attrs: {
      r: 6,
      fill: "#333",
      stroke: "#fff",
      cursor: "move",
      "stroke-width": 2
    },
    createHandle: (t) => new n.Handle(t),
    markup: [
      {
        tagName: "path",
        selector: "connection",
        className: e,
        attrs: {
          fill: "none",
          stroke: "transparent",
          "stroke-width": 10,
          cursor: "pointer"
        }
      }
    ],
    events: {
      [`mousedown .${e}`]: "onPathMouseDown",
      [`touchstart .${e}`]: "onPathMouseDown"
    }
  });
})(u0 || (u0 = {}));
class c0 extends xr.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  update() {
    return this.render(), this;
  }
  onRender() {
    lt(this.container, this.prefixClassName("edge-tool-segments")), this.resetHandles();
    const e = this.cellView, t = [...this.vertices];
    t.unshift(e.sourcePoint), t.push(e.targetPoint);
    for (let r = 0, i = t.length; r < i - 1; r += 1) {
      const o = t[r], a = t[r + 1], s = this.renderHandle(o, a, r);
      this.stamp(s.container), this.handles.push(s);
    }
    return this;
  }
  renderHandle(e, t, r) {
    const i = this.options.createHandle({
      index: r,
      graph: this.graph,
      guard: (o) => this.guard(o),
      attrs: this.options.attrs || {}
    });
    return this.options.processHandle && this.options.processHandle(i), this.updateHandle(i, e, t), this.container.appendChild(i.container), this.startHandleListening(i), i;
  }
  startHandleListening(e) {
    e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this);
  }
  stopHandleListening(e) {
    e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this);
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  shiftHandleIndexes(e) {
    const t = this.handles;
    for (let r = 0, i = t.length; r < i; r += 1)
      t[r].options.index += e;
  }
  resetAnchor(e, t) {
    const r = this.cellView.cell, i = {
      ui: !0,
      toolId: this.cid
    };
    t ? r.prop([e, "anchor"], t, i) : r.removeProp([e, "anchor"], i);
  }
  snapHandle(e, t, r) {
    const i = e.options.axis, o = e.options.index, l = this.cellView.cell.getVertices(), u = l[o - 2] || r.sourceAnchor, c = l[o + 1] || r.targetAnchor, h = this.options.snapRadius;
    return Math.abs(t[i] - u[i]) < h ? t[i] = u[i] : Math.abs(t[i] - c[i]) < h && (t[i] = c[i]), t;
  }
  onHandleChanging({ handle: e, e: t }) {
    const r = this.graph, i = this.options, o = this.cellView, a = i.anchor, s = e.options.axis, l = e.options.index - 1, u = this.getEventData(t), c = this.normalizeEvent(t), h = r.snapToGrid(c.clientX, c.clientY), f = this.snapHandle(e, h.clone(), u), d = Sn(this.vertices);
    let p = d[l], g = d[l + 1];
    const v = o.sourceView, m = o.sourceBBox;
    let y = !1, b = !1;
    if (p ? l === 0 ? m.containsPoint(p) ? (d.shift(), this.shiftHandleIndexes(-1), y = !0) : (p[s] = f[s], b = !0) : p[s] = f[s] : (p = o.sourceAnchor.toJSON(), p[s] = f[s], m.containsPoint(p) ? y = !0 : (d.unshift(p), this.shiftHandleIndexes(1), b = !0)), typeof a == "function" && v) {
      if (y) {
        const _ = u.sourceAnchor.clone();
        _[s] = f[s];
        const C = rt(a, o, _, v, o.sourceMagnet || v.container, "source", o, this);
        this.resetAnchor("source", C);
      }
      b && this.resetAnchor("source", u.sourceAnchorDef);
    }
    const O = o.targetView, w = o.targetBBox;
    let x = !1, S = !1;
    if (g ? l === d.length - 2 ? w.containsPoint(g) ? (d.pop(), x = !0) : (g[s] = f[s], S = !0) : g[s] = f[s] : (g = o.targetAnchor.toJSON(), g[s] = f[s], w.containsPoint(g) ? x = !0 : (d.push(g), S = !0)), typeof a == "function" && O) {
      if (x) {
        const _ = u.targetAnchor.clone();
        _[s] = f[s];
        const C = rt(a, o, _, O, o.targetMagnet || O.container, "target", o, this);
        this.resetAnchor("target", C);
      }
      S && this.resetAnchor("target", u.targetAnchorDef);
    }
    G.equalPoints(d, this.vertices) || this.cellView.cell.setVertices(d, { ui: !0, toolId: this.cid }), this.updateHandle(e, p, g, 0), i.stopPropagation || o.notifyMouseMove(c, h.x, h.y);
  }
  onHandleChange({ handle: e, e: t }) {
    const r = this.options, i = this.handles, o = this.cellView, a = e.options.index;
    if (Array.isArray(i)) {
      for (let s = 0, l = i.length; s < l; s += 1)
        s !== a && i[s].hide();
      if (this.focus(), this.setEventData(t, {
        sourceAnchor: o.sourceAnchor.clone(),
        targetAnchor: o.targetAnchor.clone(),
        sourceAnchorDef: Sn(this.cell.prop(["source", "anchor"])),
        targetAnchorDef: Sn(this.cell.prop(["target", "anchor"]))
      }), this.cell.startBatch("move-segment", { ui: !0, toolId: this.cid }), !r.stopPropagation) {
        const s = this.normalizeEvent(t), l = this.graph.snapToGrid(s.clientX, s.clientY);
        o.notifyMouseDown(s, l.x, l.y);
      }
    }
  }
  onHandleChanged({ e }) {
    const t = this.options, r = this.cellView;
    t.removeRedundancies && r.removeRedundantLinearVertices({ ui: !0, toolId: this.cid });
    const i = this.normalizeEvent(e), o = this.graph.snapToGrid(i.clientX, i.clientY);
    this.render(), this.blur(), this.cell.stopBatch("move-segment", { ui: !0, toolId: this.cid }), t.stopPropagation || r.notifyMouseUp(i, o.x, o.y), r.checkMouseleave(i), t.onChanged && t.onChanged({ edge: r.cell, edgeView: r });
  }
  updateHandle(e, t, r, i = 0) {
    const o = this.options.precision || 0, a = Math.abs(t.x - r.x) < o, s = Math.abs(t.y - r.y) < o;
    if (a || s) {
      const l = new Xe(t, r);
      if (l.length() < this.options.threshold)
        e.hide();
      else {
        const c = l.getCenter(), h = a ? "x" : "y";
        c[h] += i || 0;
        const f = l.vector().vectorAngle(new G(1, 0));
        e.updatePosition(c.x, c.y, f, this.cellView), e.show(), e.options.axis = h;
      }
    } else
      e.hide();
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(n) {
  class e extends Dn {
    constructor(r) {
      super(), this.options = r, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      });
    }
    render() {
      this.container = Dn.createElement("rect", !0);
      const r = this.options.attrs;
      if (typeof r == "function") {
        const i = n.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, i.attrs), r(this)));
      } else
        this.setAttrs(r);
      this.addClass(this.prefixClassName("edge-tool-segment"));
    }
    updatePosition(r, i, o, a) {
      const s = a.getClosestPoint(new G(r, i)) || new G(r, i);
      let l = Xr().translate(s.x, s.y);
      if (s.equals({ x: r, y: i }))
        l = l.rotate(o);
      else {
        let c = new Xe(r, i, s.x, s.y).vector().vectorAngle(new G(1, 0));
        c !== 0 && (c += 90), l = l.rotate(c);
      }
      this.setAttrs({
        transform: yv(l),
        cursor: o % 180 === 0 ? "row-resize" : "col-resize"
      });
    }
    onMouseDown(r) {
      this.options.guard(r) || (this.trigger("change", { e: r, handle: this }), r.stopPropagation(), r.preventDefault(), this.options.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, r.data));
    }
    onMouseMove(r) {
      this.emit("changing", { e: r, handle: this });
    }
    onMouseUp(r) {
      this.emit("changed", { e: r, handle: this }), this.undelegateDocumentEvents(), this.options.graph.view.delegateEvents();
    }
    show() {
      this.container.style.display = "";
    }
    hide() {
      this.container.style.display = "none";
    }
  }
  n.Handle = e;
})(c0 || (c0 = {}));
(function(n) {
  n.config({
    name: "segments",
    precision: 0.5,
    threshold: 40,
    snapRadius: 10,
    stopPropagation: !0,
    removeRedundancies: !0,
    attrs: {
      width: 20,
      height: 8,
      x: -10,
      y: -4,
      rx: 4,
      ry: 4,
      fill: "#333",
      stroke: "#fff",
      "stroke-width": 2
    },
    createHandle: (e) => new n.Handle(e),
    anchor: g9
  });
})(c0 || (c0 = {}));
class Sx extends xr.ToolItem {
  get type() {
    return this.options.type;
  }
  onRender() {
    lt(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`)), this.toggleArea(!1), this.update();
  }
  update() {
    const e = this.type;
    return this.cellView.getTerminalView(e) ? (this.updateAnchor(), this.updateArea(), this.container.style.display = "") : this.container.style.display = "none", this;
  }
  updateAnchor() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.anchor;
    if (!t)
      return;
    const r = this.type, i = this.cellView, o = this.options, a = i.getTerminalAnchor(r), s = i.cell.prop([r, "anchor"]);
    t.setAttribute("transform", `translate(${a.x}, ${a.y})`);
    const l = s ? o.customAnchorAttrs : o.defaultAnchorAttrs;
    l && Object.keys(l).forEach((u) => {
      t.setAttribute(u, l[u]);
    });
  }
  updateArea() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.area;
    if (!t)
      return;
    const r = this.type, i = this.cellView, o = i.getTerminalView(r);
    if (o) {
      const a = o.cell, s = i.getTerminalMagnet(r);
      let l = this.options.areaPadding || 0;
      Number.isFinite(l) || (l = 0);
      let u, c, h;
      o.isEdgeElement(s) ? (u = o.getBBox(), c = 0, h = u.getCenter()) : (u = o.getUnrotatedBBoxOfElement(s), c = a.getAngle(), h = u.getCenter(), c && h.rotate(-c, a.getBBox().getCenter())), u.inflate(l), Xt(t, {
        x: -u.width / 2,
        y: -u.height / 2,
        width: u.width,
        height: u.height,
        transform: `translate(${h.x}, ${h.y}) rotate(${c})`
      });
    }
  }
  toggleArea(e) {
    if (this.childNodes) {
      const t = this.childNodes.area;
      t && (t.style.display = e ? "" : "none");
    }
  }
  onMouseDown(e) {
    this.guard(e) || (e.stopPropagation(), e.preventDefault(), this.graph.view.undelegateEvents(), this.options.documentEvents && this.delegateDocumentEvents(this.options.documentEvents), this.focus(), this.toggleArea(this.options.restrictArea), this.cell.startBatch("move-anchor", {
      ui: !0,
      toolId: this.cid
    }));
  }
  resetAnchor(e) {
    const t = this.type, r = this.cell;
    e ? r.prop([t, "anchor"], e, {
      rewrite: !0,
      ui: !0,
      toolId: this.cid
    }) : r.removeProp([t, "anchor"], {
      ui: !0,
      toolId: this.cid
    });
  }
  onMouseMove(e) {
    const t = this.type, r = this.cellView, i = r.getTerminalView(t);
    if (i == null)
      return;
    const o = this.normalizeEvent(e), a = i.cell, s = r.getTerminalMagnet(t);
    let l = this.graph.coord.clientToLocalPoint(o.clientX, o.clientY);
    const u = this.options.snap;
    if (typeof u == "function") {
      const f = rt(u, r, l, i, s, t, r, this);
      l = G.create(f);
    }
    if (this.options.restrictArea)
      if (i.isEdgeElement(s)) {
        const f = i.getClosestPoint(l);
        f && (l = f);
      } else {
        const f = i.getUnrotatedBBoxOfElement(s), d = a.getAngle(), p = a.getBBox().getCenter(), g = l.clone().rotate(d, p);
        f.containsPoint(g) || (l = f.getNearestPointToPoint(g).rotate(-d, p));
      }
    let c;
    const h = this.options.anchor;
    typeof h == "function" && (c = rt(h, r, l, i, s, t, r, this)), this.resetAnchor(c), this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMouseUp(e) {
    this.graph.view.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleArea(!1);
    const t = this.cellView;
    this.options.removeRedundancies && t.removeRedundantLinearVertices({ ui: !0, toolId: this.cid }), this.cell.stopBatch("move-anchor", { ui: !0, toolId: this.cid });
  }
  onDblClick() {
    const e = this.options.resetAnchor;
    e && this.resetAnchor(e === !0 ? void 0 : e), this.update();
  }
}
(function(n) {
  n.config({
    tagName: "g",
    markup: [
      {
        tagName: "circle",
        selector: "anchor",
        attrs: {
          cursor: "pointer"
        }
      },
      {
        tagName: "rect",
        selector: "area",
        attrs: {
          "pointer-events": "none",
          fill: "none",
          stroke: "#33334F",
          "stroke-dasharray": "2,4",
          rx: 5,
          ry: 5
        }
      }
    ],
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown",
      dblclick: "onDblClick"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    },
    customAnchorAttrs: {
      "stroke-width": 4,
      stroke: "#33334F",
      fill: "#FFFFFF",
      r: 5
    },
    defaultAnchorAttrs: {
      "stroke-width": 2,
      stroke: "#FFFFFF",
      fill: "#33334F",
      r: 6
    },
    areaPadding: 6,
    snapRadius: 10,
    resetAnchor: !0,
    restrictArea: !0,
    removeRedundancies: !0,
    anchor: g9,
    snap(e, t, r, i, o, a) {
      const s = a.options.snapRadius || 0, l = i === "source", u = l ? 0 : -1, c = this.cell.getVertexAt(u) || this.getTerminalAnchor(l ? "target" : "source");
      return c && (Math.abs(c.x - e.x) < s && (e.x = c.x), Math.abs(c.y - e.y) < s && (e.y = c.y)), e;
    }
  });
})(Sx || (Sx = {}));
const Cke = Sx.define({
  name: "source-anchor",
  type: "source"
}), Ake = Sx.define({
  name: "target-anchor",
  type: "target"
});
var Tke = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class _x extends xr.ToolItem {
  get type() {
    return this.options.type;
  }
  get ratio() {
    return this.options.ratio;
  }
  init() {
    if (this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, r = Tke(e, ["class"]);
      this.setAttrs(r, this.container), t && lt(this.container, t);
    }
  }
  onRender() {
    lt(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`)), this.update();
  }
  update() {
    const e = this.ratio, t = this.cellView, r = t.getTangentAtRatio(e), i = r ? r.start : t.getPointAtRatio(e), o = r && r.vector().vectorAngle(new G(1, 0)) || 0;
    if (!i)
      return this;
    const a = Xr().translate(i.x, i.y).rotate(o);
    return _g(this.container, a, { absolute: !0 }), this;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.cellView;
    if (t.can("arrowheadMovable")) {
      t.cell.startBatch("move-arrowhead", {
        ui: !0,
        toolId: this.cid
      });
      const r = this.graph.snapToGrid(e.clientX, e.clientY), i = t.prepareArrowheadDragging(this.type, {
        x: r.x,
        y: r.y,
        options: Object.assign(Object.assign({}, this.options), { toolId: this.cid })
      });
      this.cellView.setEventData(e, i), this.delegateDocumentEvents(this.options.documentEvents, e.data), t.graph.view.undelegateEvents(), this.container.style.pointerEvents = "none";
    }
    this.focus();
  }
  onMouseMove(e) {
    const t = this.normalizeEvent(e), r = this.graph.snapToGrid(t.clientX, t.clientY);
    this.cellView.onMouseMove(t, r.x, r.y), this.update();
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), r = this.cellView, i = this.graph.snapToGrid(t.clientX, t.clientY);
    r.onMouseUp(t, i.x, i.y), this.graph.view.delegateEvents(), this.blur(), this.container.style.pointerEvents = "", r.cell.stopBatch("move-arrowhead", {
      ui: !0,
      toolId: this.cid
    });
  }
}
(function(n) {
  n.config({
    tagName: "path",
    isSVGElement: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    }
  });
})(_x || (_x = {}));
const kke = _x.define({
  name: "source-arrowhead",
  type: "source",
  ratio: 0,
  attrs: {
    d: "M 10 -8 -10 0 10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
}), Pke = _x.define({
  name: "target-arrowhead",
  type: "target",
  ratio: 1,
  attrs: {
    d: "M -10 -8 10 0 -10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});
class Pg extends xr.ToolItem {
  constructor() {
    super(...arguments), this.labelIndex = -1, this.distance = 0.5, this.dblClick = this.onCellDblClick.bind(this);
  }
  onRender() {
    const e = this.cellView;
    e && e.on("cell:dblclick", this.dblClick);
  }
  createElement() {
    const e = [
      this.prefixClassName(`${this.cell.isEdge() ? "edge" : "node"}-tool-editor`),
      this.prefixClassName("cell-tool-editor")
    ];
    this.editor = xr.createElement("div", !1), this.addClass(e, this.editor), this.editor.contentEditable = "true", this.container.appendChild(this.editor);
  }
  removeElement() {
    this.undelegateDocumentEvents(), this.editor && (this.container.removeChild(this.editor), this.editor = null);
  }
  updateEditor() {
    const { cell: e, editor: t } = this;
    if (!t)
      return;
    const { style: r } = t;
    e.isNode() ? this.updateNodeEditorTransform() : e.isEdge() && this.updateEdgeEditorTransform();
    const { attrs: i } = this.options;
    r.fontSize = `${i.fontSize}px`, r.fontFamily = i.fontFamily, r.color = i.color, r.backgroundColor = i.backgroundColor;
    const o = this.getCellText() || "";
    return t.innerText = o, this.setCellText(""), this;
  }
  updateNodeEditorTransform() {
    const { graph: e, cell: t, editor: r } = this;
    if (!r)
      return;
    let i = G.create(), o = 20, a = "", { x: s, y: l } = this.options;
    const { width: u, height: c } = this.options;
    if (typeof s < "u" && typeof l < "u") {
      const d = t.getBBox();
      s = ss(s, d.width), l = ss(l, d.height), i = d.topLeft.translate(s, l), o = d.width - s * 2;
    } else {
      const d = t.getBBox();
      i = d.center, o = d.width - 4, a = "translate(-50%, -50%)";
    }
    const h = e.scale(), { style: f } = r;
    i = e.localToGraph(i), f.left = `${i.x}px`, f.top = `${i.y}px`, f.transform = `scale(${h.sx}, ${h.sy}) ${a}`, f.minWidth = `${o}px`, typeof u == "number" && (f.width = `${u}px`), typeof c == "number" && (f.height = `${c}px`);
  }
  updateEdgeEditorTransform() {
    if (!this.event)
      return;
    const { graph: e, editor: t } = this;
    if (!t)
      return;
    let r = G.create(), i = 20;
    const { style: o } = t, a = this.event.target, s = a.parentElement;
    if (s && mv(s, this.prefixClassName("edge-label"))) {
      const c = s.getAttribute("data-index") || "0";
      this.labelIndex = parseInt(c, 10);
      const h = s.getAttribute("transform"), { translation: f } = A_(h);
      r = new G(f.tx, f.ty), i = gn.getBBox(a).width;
    } else {
      if (!this.options.labelAddable)
        return this;
      r = e.clientToLocal(G.create(this.event.clientX, this.event.clientY));
      const h = this.cellView.path.closestPointLength(r);
      this.distance = h, this.labelIndex = -1;
    }
    r = e.localToGraph(r);
    const u = e.scale();
    o.left = `${r.x}px`, o.top = `${r.y}px`, o.minWidth = `${i}px`, o.transform = `scale(${u.sx}, ${u.sy}) translate(-50%, -50%)`;
  }
  onDocumentMouseUp(e) {
    if (this.editor && e.target !== this.editor) {
      const t = this.editor.innerText.replace(/\n$/, "") || "";
      this.setCellText(t !== "" ? t : null), this.removeElement();
    }
  }
  onCellDblClick({ e }) {
    this.editor || (e.stopPropagation(), this.removeElement(), this.event = e, this.createElement(), this.updateEditor(), this.autoFocus(), this.delegateDocumentEvents(this.options.documentEvents));
  }
  onMouseDown(e) {
    e.stopPropagation();
  }
  autoFocus() {
    setTimeout(() => {
      this.editor && (this.editor.focus(), this.selectText());
    });
  }
  selectText() {
    if (window.getSelection && this.editor) {
      const e = document.createRange(), t = window.getSelection();
      e.selectNodeContents(this.editor), t.removeAllRanges(), t.addRange(e);
    }
  }
  getCellText() {
    const { getText: e } = this.options;
    if (typeof e == "function")
      return rt(e, this.cellView, {
        cell: this.cell,
        index: this.labelIndex
      });
    if (typeof e == "string") {
      if (this.cell.isNode())
        return this.cell.attr(e);
      if (this.cell.isEdge() && this.labelIndex !== -1)
        return this.cell.prop(`labels/${this.labelIndex}/attrs/${e}`);
    }
  }
  setCellText(e) {
    const t = this.options.setText;
    if (typeof t == "function") {
      rt(t, this.cellView, {
        cell: this.cell,
        value: e,
        index: this.labelIndex,
        distance: this.distance
      });
      return;
    }
    if (typeof t == "string") {
      if (this.cell.isNode()) {
        e !== null && this.cell.attr(t, e);
        return;
      }
      if (this.cell.isEdge()) {
        const r = this.cell;
        if (this.labelIndex === -1) {
          if (e) {
            const i = {
              position: {
                distance: this.distance
              },
              attrs: {}
            };
            vv(i, `attrs/${t}`, e), r.appendLabel(i);
          }
        } else
          e !== null ? r.prop(`labels/${this.labelIndex}/attrs/${t}`, e) : typeof this.labelIndex == "number" && r.removeLabelAt(this.labelIndex);
      }
    }
  }
  onRemove() {
    const e = this.cellView;
    e && e.off("cell:dblclick", this.dblClick), this.removeElement();
  }
}
(function(n) {
  n.config({
    tagName: "div",
    isSVGElement: !1,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mouseup: "onDocumentMouseUp",
      touchend: "onDocumentMouseUp",
      touchcancel: "onDocumentMouseUp"
    }
  });
})(Pg || (Pg = {}));
(function(n) {
  n.NodeEditor = n.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    getText: "text/text",
    setText: "text/text"
  }), n.EdgeEditor = n.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    labelAddable: !0,
    getText: "label/text",
    setText: "label/text"
  });
})(Pg || (Pg = {}));
var m9 = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
}, Eg;
(function(n) {
  n.presets = {
    boundary: xx,
    button: $c,
    "button-remove": $c.Remove,
    "node-editor": Pg.NodeEditor
  }, n.registry = pr.create({
    type: "node tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let r = xr.ToolItem;
      const { inherit: i } = t, o = m9(t, ["inherit"]);
      if (i) {
        const a = this.get(i);
        a == null ? this.onNotFound(i, "inherited") : r = a;
      }
      return o.name == null && (o.name = e), r.define.call(r, o);
    }
  }), n.registry.register(n.presets, !0);
})(Eg || (Eg = {}));
var Mg;
(function(n) {
  n.presets = {
    boundary: xx,
    vertices: u0,
    segments: c0,
    button: $c,
    "button-remove": $c.Remove,
    "source-anchor": Cke,
    "target-anchor": Ake,
    "source-arrowhead": kke,
    "target-arrowhead": Pke,
    "edge-editor": Pg.EdgeEditor
  }, n.registry = pr.create({
    type: "edge tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let r = xr.ToolItem;
      const { inherit: i } = t, o = m9(t, ["inherit"]);
      if (i) {
        const a = this.get(i);
        a == null ? this.onNotFound(i, "inherited") : r = a;
      }
      return o.name == null && (o.name = e), r.define.call(r, o);
    }
  }), n.registry.register(n.presets, !0);
})(Mg || (Mg = {}));
const Eke = _u("center"), Mke = _u("topCenter"), Dke = _u("bottomCenter"), Lke = _u("leftMiddle"), Ike = _u("rightMiddle"), Rke = _u("topLeft"), Nke = _u("topRight"), $ke = _u("bottomLeft"), Bke = _u("bottomRight");
function _u(n) {
  return function(e, t, r, i = {}) {
    const o = i.rotate ? e.getUnrotatedBBoxOfElement(t) : e.getBBoxOfElement(t), a = o[n];
    a.x += ss(i.dx, o.width), a.y += ss(i.dy, o.height);
    const s = e.cell;
    return i.rotate ? a.rotate(-s.getAngle(), s.getBBox().getCenter()) : a;
  };
}
function D_(n) {
  return function(e, t, r, i) {
    if (r instanceof Element) {
      const o = this.graph.findViewByElem(r);
      let a;
      if (o)
        if (o.isEdgeElement(r)) {
          const s = i.fixedAt != null ? i.fixedAt : "50%";
          a = y9(o, s);
        } else
          a = o.getBBoxOfElement(r).getCenter();
      else
        a = new G();
      return n.call(this, e, t, a, i);
    }
    return n.apply(this, arguments);
  };
}
function y9(n, e) {
  const t = su(e), r = typeof e == "string" ? parseFloat(e) : e;
  return t ? n.getPointAtRatio(r / 100) : n.getPointAtLength(r);
}
const Vke = function(n, e, t, r) {
  const i = Jt.normalize(n.cell.getAngle()), o = n.getBBoxOfElement(e), a = o.getCenter(), s = o.getTopLeft(), l = o.getBottomRight();
  let u = r.padding;
  if (Number.isFinite(u) || (u = 0), s.y + u <= t.y && t.y <= l.y - u) {
    const c = t.y - a.y;
    a.x += i === 0 || i === 180 ? 0 : c * 1 / Math.tan(Jt.toRad(i)), a.y += c;
  } else if (s.x + u <= t.x && t.x <= l.x - u) {
    const c = t.x - a.x;
    a.y += i === 90 || i === 270 ? 0 : c * Math.tan(Jt.toRad(i)), a.x += c;
  }
  return a;
}, zke = D_(Vke), Fke = function(n, e, t, r, i) {
  const o = n.cell.getConnectionPoint(this.cell, i);
  return (r.dx || r.dy) && o.translate(r.dx || 0, r.dy || 0), o;
}, Qke = function(n, e, t, r) {
  let i, o = 0, a;
  const s = n.cell;
  r.rotate ? (i = n.getUnrotatedBBoxOfElement(e), a = s.getBBox().getCenter(), o = s.getAngle()) : i = n.getBBoxOfElement(e);
  const l = r.padding;
  l != null && Number.isFinite(l) && i.inflate(l), r.rotate && t.rotate(o, a);
  const u = i.getNearestSideToPoint(t);
  let c;
  switch (u) {
    case "left":
      c = i.getLeftMiddle();
      break;
    case "right":
      c = i.getRightMiddle();
      break;
    case "top":
      c = i.getTopCenter();
      break;
    case "bottom":
      c = i.getBottomCenter();
      break;
  }
  const h = r.direction;
  return h === "H" ? (u === "top" || u === "bottom") && (t.x <= i.x + i.width ? c = i.getLeftMiddle() : c = i.getRightMiddle()) : h === "V" && (t.y <= i.y + i.height ? c = i.getTopCenter() : c = i.getBottomCenter()), r.rotate ? c.rotate(-o, a) : c;
}, Zke = D_(Qke), Wke = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: Dke,
  bottomLeft: $ke,
  bottomRight: Bke,
  center: Eke,
  left: Lke,
  midSide: Zke,
  nodeCenter: Fke,
  orth: zke,
  right: Ike,
  top: Mke,
  topLeft: Rke,
  topRight: Nke
}, Symbol.toStringTag, { value: "Module" }));
var Dg;
(function(n) {
  n.presets = Wke, n.registry = pr.create({
    type: "node endpoint"
  }), n.registry.register(n.presets, !0);
})(Dg || (Dg = {}));
const Gke = function(n, e, t, r) {
  let i = r.ratio != null ? r.ratio : 0.5;
  return i > 1 && (i /= 100), n.getPointAtRatio(i);
}, jke = function(n, e, t, r) {
  const i = r.length != null ? r.length : 20;
  return n.getPointAtLength(i);
}, b9 = function(n, e, t, r) {
  const i = n.getClosestPoint(t);
  return i ?? new G();
}, Hke = D_(b9), qke = function(n, e, t, r) {
  const o = n.getConnection(), a = n.getConnectionSubdivisions(), s = new Xe(t.clone().translate(0, 1e6), t.clone().translate(0, -1e6)), l = new Xe(t.clone().translate(1e6, 0), t.clone().translate(-1e6, 0)), u = s.intersect(o, {
    segmentSubdivisions: a
  }), c = l.intersect(o, {
    segmentSubdivisions: a
  }), h = [];
  return u && h.push(...u), c && h.push(...c), h.length > 0 ? t.closest(h) : r.fallbackAt != null ? y9(n, r.fallbackAt) : rt(b9, this, n, e, t, r);
}, Yke = D_(qke), Xke = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closest: Hke,
  length: jke,
  orth: Yke,
  ratio: Gke
}, Symbol.toStringTag, { value: "Module" }));
var Lg;
(function(n) {
  n.presets = Xke, n.registry = pr.create({
    type: "edge endpoint"
  }), n.registry.register(n.presets, !0);
})(Lg || (Lg = {}));
function L_(n, e, t) {
  let r;
  if (typeof t == "object") {
    if (Number.isFinite(t.y)) {
      const o = new Xe(e, n), { start: a, end: s } = o.parallel(t.y);
      e = a, n = s;
    }
    r = t.x;
  } else
    r = t;
  if (r == null || !Number.isFinite(r))
    return n;
  const i = n.distance(e);
  return r === 0 && i > 0 ? n : n.move(e, -Math.min(r, i - 1));
}
function Cx(n) {
  const e = n.getAttribute("stroke-width");
  return e === null ? 0 : parseFloat(e) || 0;
}
function Uke(n) {
  if (n == null)
    return null;
  let e = n;
  do {
    let t = e.tagName;
    if (typeof t != "string")
      return null;
    if (t = t.toUpperCase(), t === "G")
      e = e.firstElementChild;
    else if (t === "TITLE")
      e = e.nextElementSibling;
    else
      break;
  } while (e);
  return e;
}
const O9 = function(n, e, t, r) {
  const i = e.getBBoxOfElement(t);
  r.stroked && i.inflate(Cx(t) / 2);
  const o = n.intersect(i), a = o && o.length ? n.start.closest(o) : n.end;
  return L_(a, n.start, r.offset);
}, Kke = function(n, e, t, r, i) {
  const o = e.cell, a = o.isNode() ? o.getAngle() : 0;
  if (a === 0)
    return rt(O9, this, n, e, t, r, i);
  const s = e.getUnrotatedBBoxOfElement(t);
  r.stroked && s.inflate(Cx(t) / 2);
  const l = s.getCenter(), u = n.clone().rotate(a, l), c = u.setLength(1e6).intersect(s), h = c && c.length ? u.start.closest(c).rotate(-a, l) : n.end;
  return L_(h, n.start, r.offset);
}, Jke = function(n, e, t, r) {
  let i, o;
  const a = n.end, s = r.selector;
  if (typeof s == "string" ? i = e.findOne(s) : Array.isArray(s) ? i = nI(t, s) : i = Uke(t), !Dc(i)) {
    if (i === t || !Dc(t))
      return a;
    i = t;
  }
  const l = e.getShapeOfElement(i), u = e.getMatrixOfElement(i), c = e.getRootTranslatedMatrix(), h = e.getRootRotatedMatrix(), f = c.multiply(h).multiply(u), d = f.inverse(), p = gn.transformLine(n, d), g = p.start.clone(), v = e.getDataOfElement(i);
  if (r.insideout === !1) {
    v.shapeBBox == null && (v.shapeBBox = l.bbox());
    const O = v.shapeBBox;
    if (O != null && O.containsPoint(g))
      return a;
  }
  r.extrapolate === !0 && p.setLength(1e6);
  let m;
  if (Bt.isPath(l)) {
    const O = r.precision || 2;
    v.segmentSubdivisions == null && (v.segmentSubdivisions = l.getSegmentSubdivisions({
      precision: O
    })), m = {
      precision: O,
      segmentSubdivisions: v.segmentSubdivisions
    }, o = p.intersect(l, m);
  } else
    o = p.intersect(l);
  o ? Array.isArray(o) && (o = g.closest(o)) : r.sticky === !0 && (Te.isRectangle(l) ? o = l.getNearestPointToPoint(g) : Ic.isEllipse(l) ? o = l.intersectsWithLineFromCenterToPoint(g) : o = l.closestPoint(g, m));
  const y = o ? gn.transformPoint(o, f) : a;
  let b = r.offset || 0;
  return r.stroked !== !1 && (typeof b == "object" ? (b = Object.assign({}, b), b.x == null && (b.x = 0), b.x += Cx(i) / 2) : b += Cx(i) / 2), L_(y, n.start, b);
};
function ePe(n, e, t = 0) {
  const { start: r, end: i } = n;
  let o, a, s, l;
  switch (e) {
    case "left":
      l = "x", o = i, a = r, s = -1;
      break;
    case "right":
      l = "x", o = r, a = i, s = 1;
      break;
    case "top":
      l = "y", o = i, a = r, s = -1;
      break;
    case "bottom":
      l = "y", o = r, a = i, s = 1;
      break;
    default:
      return;
  }
  r[l] < i[l] ? o[l] = a[l] : a[l] = o[l], Number.isFinite(t) && (o[l] += s * t, a[l] += s * t);
}
const tPe = function(n, e, t, r) {
  const { alignOffset: i, align: o } = r;
  return o && ePe(n, o, i), L_(n.end, n.start, r.offset);
}, nPe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  anchor: tPe,
  bbox: O9,
  boundary: Jke,
  rect: Kke
}, Symbol.toStringTag, { value: "Module" }));
var Ig;
(function(n) {
  n.presets = nPe, n.registry = pr.create({
    type: "connection point"
  }), n.registry.register(n.presets, !0);
})(Ig || (Ig = {}));
const rPe = function(n) {
  return [...n];
}, iPe = function(n, e, t) {
  const r = e.side || "bottom", i = Jf(e.padding || 40), o = t.sourceBBox, a = t.targetBBox, s = o.getCenter(), l = a.getCenter();
  let u, c, h;
  switch (r) {
    case "top":
      h = -1, u = "y", c = "height";
      break;
    case "left":
      h = -1, u = "x", c = "width";
      break;
    case "right":
      h = 1, u = "x", c = "width";
      break;
    case "bottom":
    default:
      h = 1, u = "y", c = "height";
      break;
  }
  return s[u] += h * (o[c] / 2 + i[r]), l[u] += h * (a[c] / 2 + i[r]), h * (s[u] - l[u]) > 0 ? l[u] = s[u] : s[u] = l[u], [s.toJSON(), ...n, l.toJSON()];
};
function O1(n) {
  return new Te(n.x, n.y, 0, 0);
}
function Ax(n = {}) {
  const e = Jf(n.padding || 20);
  return {
    x: -e.left,
    y: -e.top,
    width: e.left + e.right,
    height: e.top + e.bottom
  };
}
function w9(n, e = {}) {
  return n.sourceBBox.clone().moveAndExpand(Ax(e));
}
function x9(n, e = {}) {
  return n.targetBBox.clone().moveAndExpand(Ax(e));
}
function oPe(n, e = {}) {
  return n.sourceAnchor ? n.sourceAnchor : w9(n, e).getCenter();
}
function aPe(n, e = {}) {
  return n.targetAnchor ? n.targetAnchor : x9(n, e).getCenter();
}
const S9 = function(n, e, t) {
  let r = w9(t, e), i = x9(t, e);
  const o = oPe(t, e), a = aPe(t, e);
  r = r.union(O1(o)), i = i.union(O1(a));
  const s = n.map((c) => G.create(c));
  s.unshift(o), s.push(a);
  let l = null;
  const u = [];
  for (let c = 0, h = s.length - 1; c < h; c += 1) {
    let f = null;
    const d = s[c], p = s[c + 1], g = aa.getBearing(d, p) != null;
    if (c === 0)
      c + 1 === h ? r.intersectsWithRect(i.clone().inflate(1)) ? f = aa.insideNode(d, p, r, i) : g || (f = aa.nodeToNode(d, p, r, i)) : r.containsPoint(p) ? f = aa.insideNode(d, p, r, O1(p).moveAndExpand(Ax(e))) : g || (f = aa.nodeToVertex(d, p, r));
    else if (c + 1 === h) {
      const v = g && aa.getBearing(p, d) === l;
      i.containsPoint(d) || v ? f = aa.insideNode(d, p, O1(d).moveAndExpand(Ax(e)), i, l) : g || (f = aa.vertexToNode(d, p, i, l));
    } else
      g || (f = aa.vertexToVertex(d, p, l));
    f ? (u.push(...f.points), l = f.direction) : l = aa.getBearing(d, p), c + 1 < h && u.push(p);
  }
  return u;
};
var aa;
(function(n) {
  const e = {
    N: "S",
    S: "N",
    E: "W",
    W: "E"
  }, t = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  function r(h, f, d) {
    let p = new G(h.x, f.y);
    return d.containsPoint(p) && (p = new G(f.x, h.y)), p;
  }
  function i(h, f) {
    return h[f === "W" || f === "E" ? "width" : "height"];
  }
  n.getBBoxSize = i;
  function o(h, f) {
    return h.x === f.x ? h.y > f.y ? "N" : "S" : h.y === f.y ? h.x > f.x ? "W" : "E" : null;
  }
  n.getBearing = o;
  function a(h, f, d) {
    const p = new G(h.x, f.y), g = new G(f.x, h.y), v = o(h, p), m = o(h, g), y = d ? e[d] : null, b = v === d || v !== y && (m === y || m !== d) ? p : g;
    return { points: [b], direction: o(b, f) };
  }
  n.vertexToVertex = a;
  function s(h, f, d) {
    const p = r(h, f, d);
    return { points: [p], direction: o(p, f) };
  }
  n.nodeToVertex = s;
  function l(h, f, d, p) {
    const g = [new G(h.x, f.y), new G(f.x, h.y)], v = g.filter((b) => !d.containsPoint(b)), m = v.filter((b) => o(b, h) !== p);
    let y;
    if (m.length > 0)
      return y = m.filter((b) => o(h, b) === p).pop(), y = y || m[0], {
        points: [y],
        direction: o(y, f)
      };
    {
      y = Qfe(g, v)[0];
      const b = G.create(f).move(y, -i(d, p) / 2);
      return {
        points: [r(b, h, d), b],
        direction: o(b, f)
      };
    }
  }
  n.vertexToNode = l;
  function u(h, f, d, p) {
    let g = s(f, h, p);
    const v = g.points[0];
    if (d.containsPoint(v)) {
      g = s(h, f, d);
      const m = g.points[0];
      if (p.containsPoint(m)) {
        const y = G.create(h).move(m, -i(d, o(h, m)) / 2), b = G.create(f).move(v, -i(p, o(f, v)) / 2), O = new Xe(y, b).getCenter(), w = s(h, O, d), x = a(O, f, w.direction);
        g.points = [w.points[0], x.points[0]], g.direction = x.direction;
      }
    }
    return g;
  }
  n.nodeToNode = u;
  function c(h, f, d, p, g) {
    const v = d.union(p).inflate(1), m = v.getCenter(), y = m.distance(f) > m.distance(h), b = y ? f : h, O = y ? h : f;
    let w, x, S;
    g ? (w = G.fromPolar(v.width + v.height, t[g], b), w = v.getNearestPointToPoint(w).move(w, -1)) : w = v.getNearestPointToPoint(b).move(b, 1), x = r(w, O, v);
    let _;
    w.round().equals(x.round()) ? (x = G.fromPolar(v.width + v.height, Jt.toRad(w.theta(b)) + Math.PI / 2, O), x = v.getNearestPointToPoint(x).move(O, 1).round(), S = r(w, x, v), _ = y ? [x, S, w] : [w, S, x]) : _ = y ? [x, w] : [w, x];
    const C = o(y ? w : x, f);
    return {
      points: _,
      direction: C
    };
  }
  n.insideNode = c;
})(aa || (aa = {}));
const sPe = {
  step: 10,
  maxLoopCount: 2e3,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: !0,
  excludeTerminals: [],
  excludeNodes: [],
  excludeShapes: [],
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    top: { x: 0, y: -1 },
    right: { x: 1, y: 0 },
    bottom: { x: 0, y: 1 },
    left: { x: -1, y: 0 }
  },
  cost() {
    return rc(this.step, this);
  },
  directions() {
    const n = rc(this.step, this), e = rc(this.cost, this);
    return [
      { cost: e, offsetX: n, offsetY: 0 },
      { cost: e, offsetX: -n, offsetY: 0 },
      { cost: e, offsetX: 0, offsetY: n },
      { cost: e, offsetX: 0, offsetY: -n }
    ];
  },
  penalties() {
    const n = rc(this.step, this);
    return {
      0: 0,
      45: n / 2,
      90: n / 2
    };
  },
  paddingBox() {
    const n = rc(this.step, this);
    return {
      x: -n,
      y: -n,
      width: 2 * n,
      height: 2 * n
    };
  },
  fallbackRouter: S9,
  draggingRouter: null,
  snapToGrid: !0
};
function rc(n, e) {
  return typeof n == "function" ? n.call(e) : n;
}
function lPe(n) {
  const e = Object.keys(n).reduce((t, r) => {
    const i = t;
    return r === "fallbackRouter" || r === "draggingRouter" || r === "fallbackRoute" ? i[r] = n[r] : i[r] = rc(n[r], n), t;
  }, {});
  if (e.padding) {
    const t = Jf(e.padding);
    e.paddingBox = {
      x: -t.left,
      y: -t.top,
      width: t.left + t.right,
      height: t.top + t.bottom
    };
  }
  return e.directions.forEach((t) => {
    const r = new G(0, 0), i = new G(t.offsetX, t.offsetY);
    t.angle = Jt.normalize(r.theta(i));
  }), e;
}
const s5 = 1, l5 = 2;
class uPe {
  constructor() {
    this.items = [], this.hash = {}, this.values = {};
  }
  add(e, t) {
    this.hash[e] ? this.items.splice(this.items.indexOf(e), 1) : this.hash[e] = s5, this.values[e] = t;
    const r = $de(this.items, e, (i) => this.values[i]);
    this.items.splice(r, 0, e);
  }
  pop() {
    const e = this.items.shift();
    return e && (this.hash[e] = l5), e;
  }
  isOpen(e) {
    return this.hash[e] === s5;
  }
  isClose(e) {
    return this.hash[e] === l5;
  }
  isEmpty() {
    return this.items.length === 0;
  }
}
class cPe {
  constructor(e) {
    this.options = e, this.mapGridSize = 100, this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */
  build(e, t) {
    const r = this.options, i = r.excludeTerminals.reduce((u, c) => {
      const h = t[c];
      if (h) {
        const f = e.getCell(h.cell);
        f && u.push(f);
      }
      return u;
    }, []);
    let o = [];
    const a = e.getCell(t.getSourceCellId());
    a && (o = m3(o, a.getAncestors().map((u) => u.id)));
    const s = e.getCell(t.getTargetCellId());
    s && (o = m3(o, s.getAncestors().map((u) => u.id)));
    const l = this.mapGridSize;
    return e.getNodes().reduce((u, c) => {
      const h = i.some((v) => v.id === c.id), f = c.shape ? r.excludeShapes.includes(c.shape) : !1, d = r.excludeNodes.some((v) => typeof v == "string" ? c.id === v : v === c), p = o.includes(c.id), g = f || h || d || p;
      if (c.isVisible() && !g) {
        const v = c.getBBox().moveAndExpand(r.paddingBox), m = v.getOrigin().snapToGrid(l), y = v.getCorner().snapToGrid(l);
        for (let b = m.x; b <= y.x; b += l)
          for (let O = m.y; O <= y.y; O += l) {
            const w = new G(b, O).toString();
            u[w] == null && (u[w] = []), u[w].push(v);
          }
      }
      return u;
    }, this.map), this;
  }
  isAccessible(e) {
    const t = e.clone().snapToGrid(this.mapGridSize).toString(), r = this.map[t];
    return r ? r.every((i) => !i.containsPoint(e)) : !0;
  }
}
function _9(n, e) {
  const t = n.sourceBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function C9(n, e) {
  const t = n.targetBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function A9(n, e) {
  return n.sourceAnchor ? n.sourceAnchor : _9(n, e).getCenter();
}
function hPe(n, e) {
  return n.targetAnchor ? n.targetAnchor : C9(n, e).getCenter();
}
function _2(n, e, t, r, i) {
  const o = 360 / t, a = n.theta(fPe(n, e, r, i)), s = Jt.normalize(a + o / 2);
  return o * Math.floor(s / o);
}
function fPe(n, e, t, r) {
  const i = r.step, o = e.x - n.x, a = e.y - n.y, s = o / t.x, l = a / t.y, u = s * i, c = l * i;
  return new G(n.x + u, n.y + c);
}
function u5(n, e) {
  const t = Math.abs(n - e);
  return t > 180 ? 360 - t : t;
}
function dPe(n, e) {
  const t = e.step;
  return e.directions.forEach((r) => {
    r.gridOffsetX = r.offsetX / t * n.x, r.gridOffsetY = r.offsetY / t * n.y;
  }), e.directions;
}
function pPe(n, e, t) {
  return {
    source: e.clone(),
    x: c5(t.x - e.x, n),
    y: c5(t.y - e.y, n)
  };
}
function c5(n, e) {
  if (!n)
    return e;
  const t = Math.abs(n), r = Math.round(t / e);
  if (!r)
    return t;
  const i = r * e, a = (t - i) / r;
  return e + a;
}
function gPe(n, e) {
  const t = e.source, r = rn.snapToGrid(n.x - t.x, e.x) + t.x, i = rn.snapToGrid(n.y - t.y, e.y) + t.y;
  return new G(r, i);
}
function Vm(n, e) {
  return n.round(e);
}
function bw(n, e, t) {
  return Vm(gPe(n.clone(), e), t);
}
function wy(n) {
  return n.toString();
}
function C2(n) {
  return new G(n.x === 0 ? 0 : Math.abs(n.x) / n.x, n.y === 0 ? 0 : Math.abs(n.y) / n.y);
}
function h5(n, e) {
  let t = 1 / 0;
  for (let r = 0, i = e.length; r < i; r += 1) {
    const o = n.manhattanDistance(e[r]);
    o < t && (t = o);
  }
  return t;
}
function f5(n, e, t, r, i) {
  const o = i.precision, a = i.directionMap, s = n.diff(e.getCenter()), l = Object.keys(a).reduce((u, c) => {
    if (t.includes(c)) {
      const h = a[c], f = new G(n.x + h.x * (Math.abs(s.x) + e.width), n.y + h.y * (Math.abs(s.y) + e.height)), p = new Xe(n, f).intersect(e) || [];
      let g, v = null;
      for (let m = 0; m < p.length; m += 1) {
        const y = p[m], b = n.squaredDistance(y);
        (g == null || b > g) && (g = b, v = y);
      }
      if (v) {
        let m = bw(v, r, o);
        e.containsPoint(m) && (m = bw(m.translate(h.x * r.x, h.y * r.y), r, o)), u.push(m);
      }
    }
    return u;
  }, []);
  return e.containsPoint(n) || l.push(bw(n, r, o)), l;
}
function vPe(n, e, t, r, i) {
  const o = [];
  let a = C2(i.diff(t)), s = wy(t), l = n[s], u;
  for (; l; ) {
    u = e[s];
    const f = C2(u.diff(l));
    f.equals(a) || (o.unshift(u), a = f), s = wy(l), l = n[s];
  }
  const c = e[s];
  return C2(c.diff(r)).equals(a) || o.unshift(c), o;
}
function mPe(n, e, t, r, i) {
  const o = i.precision;
  let a, s;
  Te.isRectangle(e) ? a = Vm(A9(n, i).clone(), o) : a = Vm(e.clone(), o), Te.isRectangle(t) ? s = Vm(hPe(n, i).clone(), o) : s = Vm(t.clone(), o);
  const l = pPe(i.step, a, s), u = a, c = s;
  let h, f;
  if (Te.isRectangle(e) ? h = f5(u, e, i.startDirections, l, i) : h = [u], Te.isRectangle(t) ? f = f5(s, t, i.endDirections, l, i) : f = [c], h = h.filter((d) => r.isAccessible(d)), f = f.filter((d) => r.isAccessible(d)), h.length > 0 && f.length > 0) {
    const d = new uPe(), p = {}, g = {}, v = {};
    for (let A = 0, k = h.length; A < k; A += 1) {
      const P = h[A], L = wy(P);
      d.add(L, h5(P, f)), p[L] = P, v[L] = 0;
    }
    const m = i.previousDirectionAngle, y = m === void 0;
    let b, O;
    const w = dPe(l, i), x = w.length, S = f.reduce((A, k) => {
      const P = wy(k);
      return A.push(P), A;
    }, []), _ = G.equalPoints(h, f);
    let C = i.maxLoopCount;
    for (; !d.isEmpty() && C > 0; ) {
      const A = d.pop(), k = p[A], P = g[A], L = v[A], D = k.equals(u), E = P == null;
      let M;
      if (E ? y ? D ? M = null : M = _2(u, k, x, l, i) : M = m : M = _2(P, k, x, l, i), !(E && _) && S.indexOf(A) >= 0)
        return i.previousDirectionAngle = M, vPe(g, p, k, u, c);
      for (let N = 0; N < x; N += 1) {
        b = w[N];
        const $ = b.angle;
        if (O = u5(M, $), !(y && D) && O > i.maxDirectionChange)
          continue;
        const F = bw(k.clone().translate(b.gridOffsetX || 0, b.gridOffsetY || 0), l, o), W = wy(F);
        if (d.isClose(W) || !r.isAccessible(F))
          continue;
        if (S.indexOf(W) >= 0 && !F.equals(c)) {
          const ae = _2(F, c, x, l, i);
          if (u5($, ae) > i.maxDirectionChange)
            continue;
        }
        const j = b.cost, Y = D ? 0 : i.penalties[O], X = L + j + Y;
        (!d.isOpen(W) || X < v[W]) && (p[W] = F, g[W] = k, v[W] = X, d.add(W, X + h5(F, f)));
      }
      C -= 1;
    }
  }
  return i.fallbackRoute ? rt(i.fallbackRoute, this, u, c, i) : null;
}
function yPe(n, e = 10) {
  if (n.length <= 1)
    return n;
  for (let t = 0, r = n.length; t < r - 1; t += 1) {
    const i = n[t], o = n[t + 1];
    if (i.x === o.x) {
      const a = e * Math.round(i.x / e);
      i.x !== a && (i.x = a, o.x = a);
    } else if (i.y === o.y) {
      const a = e * Math.round(i.y / e);
      i.y !== a && (i.y = a, o.y = a);
    }
  }
  return n;
}
const bPe = function(n, e, t) {
  const r = lPe(e), i = _9(t, r), o = C9(t, r), a = A9(t, r), s = new cPe(r).build(t.graph.model, t.cell), l = n.map((d) => G.create(d)), u = [];
  let c = a, h, f;
  for (let d = 0, p = l.length; d <= p; d += 1) {
    let g = null;
    if (h = f || i, f = l[d], f == null) {
      f = o;
      const m = t.cell;
      if ((m.getSourceCellId() == null || m.getTargetCellId() == null) && typeof r.draggingRouter == "function") {
        const b = h === i ? a : h, O = f.getOrigin();
        g = rt(r.draggingRouter, t, b, O, r);
      }
    }
    if (g == null && (g = mPe(t, h, f, s, r)), g === null)
      return console.warn("Unable to execute manhattan algorithm, use orth instead"), rt(r.fallbackRouter, this, n, r, t);
    const v = g[0];
    v && v.equals(c) && g.shift(), c = g[g.length - 1] || c, u.push(...g);
  }
  return r.snapToGrid ? yPe(u, t.graph.grid.getGridSize()) : u;
}, T9 = function(n, e, t) {
  return rt(bPe, this, n, Object.assign(Object.assign({}, sPe), e), t);
}, OPe = {
  maxDirectionChange: 45,
  // an array of directions to find next points on the route
  // different from start/end directions
  directions() {
    const n = rc(this.step, this), e = rc(this.cost, this), t = Math.ceil(Math.sqrt(n * n << 1));
    return [
      { cost: e, offsetX: n, offsetY: 0 },
      { cost: t, offsetX: n, offsetY: n },
      { cost: e, offsetX: 0, offsetY: n },
      { cost: t, offsetX: -n, offsetY: n },
      { cost: e, offsetX: -n, offsetY: 0 },
      { cost: t, offsetX: -n, offsetY: -n },
      { cost: e, offsetX: 0, offsetY: -n },
      { cost: t, offsetX: n, offsetY: -n }
    ];
  },
  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute(n, e, t) {
    const r = n.theta(e), i = [];
    let o = { x: e.x, y: n.y }, a = { x: n.x, y: e.y };
    if (r % 180 > 90) {
      const b = o;
      o = a, a = b;
    }
    const s = r % 90 < 45 ? o : a, l = new Xe(n, s), u = 90 * Math.ceil(r / 90), c = G.fromPolar(l.squaredLength(), Jt.toRad(u + 135), s), h = new Xe(e, c), f = l.intersectsWithLine(h), d = f || e, p = f ? d : n, g = 360 / t.directions.length, v = p.theta(e), m = Jt.normalize(v + g / 2), y = g * Math.floor(m / g);
    return t.previousDirectionAngle = y, d && i.push(d.round()), i.push(e), i;
  }
}, wPe = function(n, e, t) {
  return rt(T9, this, n, Object.assign(Object.assign({}, OPe), e), t);
}, xPe = function(n, e, t) {
  const r = e.offset || 32, i = e.min == null ? 16 : e.min;
  let o = 0, a = e.direction;
  const s = t.sourceBBox, l = t.targetBBox, u = s.getCenter(), c = l.getCenter();
  if (typeof r == "number" && (o = r), a == null) {
    let m = l.left - s.right, y = l.top - s.bottom;
    m >= 0 && y >= 0 ? a = m >= y ? "L" : "T" : m <= 0 && y >= 0 ? (m = s.left - l.right, m >= 0 ? a = m >= y ? "R" : "T" : a = "T") : m >= 0 && y <= 0 ? (y = s.top - l.bottom, y >= 0 ? a = m >= y ? "L" : "B" : a = "L") : (m = s.left - l.right, y = s.top - l.bottom, m >= 0 && y >= 0 ? a = m >= y ? "R" : "B" : m <= 0 && y >= 0 ? a = "B" : m >= 0 && y <= 0 ? a = "R" : a = Math.abs(m) > Math.abs(y) ? "R" : "B");
  }
  a === "H" ? a = c.x - u.x >= 0 ? "L" : "R" : a === "V" && (a = c.y - u.y >= 0 ? "T" : "B"), r === "center" && (a === "L" ? o = (l.left - s.right) / 2 : a === "R" ? o = (s.left - l.right) / 2 : a === "T" ? o = (l.top - s.bottom) / 2 : a === "B" && (o = (s.top - l.bottom) / 2));
  let h, f, d;
  const p = a === "L" || a === "R";
  if (p) {
    if (c.y === u.y)
      return [...n];
    d = a === "L" ? 1 : -1, h = "x", f = "width";
  } else {
    if (c.x === u.x)
      return [...n];
    d = a === "T" ? 1 : -1, h = "y", f = "height";
  }
  const g = u.clone(), v = c.clone();
  if (g[h] += d * (s[f] / 2 + o), v[h] -= d * (l[f] / 2 + o), p) {
    const m = g.x, y = v.x, b = s.width / 2 + i, O = l.width / 2 + i;
    c.x > u.x ? y <= m && (g.x = Math.max(y, u.x + b), v.x = Math.min(m, c.x - O)) : y >= m && (g.x = Math.min(y, u.x - b), v.x = Math.max(m, c.x + O));
  } else {
    const m = g.y, y = v.y, b = s.height / 2 + i, O = l.height / 2 + i;
    c.y > u.y ? y <= m && (g.y = Math.max(y, u.y + b), v.y = Math.min(m, c.y - O)) : y >= m && (g.y = Math.min(y, u.y - b), v.y = Math.max(m, c.y + O));
  }
  return [g.toJSON(), ...n, v.toJSON()];
};
function Gd(n, e) {
  if (e != null && e !== !1) {
    const t = typeof e == "boolean" ? 0 : e;
    if (t > 0) {
      const r = G.create(n[1]).move(n[2], t), i = G.create(n[1]).move(n[0], t);
      return [r.toJSON(), ...n, i.toJSON()];
    }
    {
      const r = n[1];
      return [Object.assign({}, r), ...n, Object.assign({}, r)];
    }
  }
  return n;
}
const SPe = function(n, e, t) {
  const r = e.width || 50, o = (e.height || 80) / 2, a = e.angle || "auto", s = t.sourceAnchor, l = t.targetAnchor, u = t.sourceBBox, c = t.targetBBox;
  if (s.equals(l)) {
    const h = (m) => {
      const y = Jt.toRad(m), b = Math.sin(y), O = Math.cos(y), w = new G(s.x + O * r, s.y + b * r), x = new G(w.x - O * o, w.y - b * o), S = x.clone().rotate(-90, w), _ = x.clone().rotate(90, w);
      return [S.toJSON(), w.toJSON(), _.toJSON()];
    }, f = (m) => {
      const y = s.clone().move(m, -1), b = new Xe(y, m);
      return !u.containsPoint(m) && !u.intersectsWithLine(b);
    }, d = [0, 90, 180, 270, 45, 135, 225, 315];
    if (typeof a == "number")
      return Gd(h(a), e.merge);
    const p = u.getCenter();
    if (p.equals(s))
      return Gd(h(0), e.merge);
    const g = p.angleBetween(s, p.clone().translate(1, 0));
    let v = h(g);
    if (f(v[1]))
      return Gd(v, e.merge);
    for (let m = 1, y = d.length; m < y; m += 1)
      if (v = h(g + d[m]), f(v[1]))
        return Gd(v, e.merge);
    return Gd(v, e.merge);
  }
  {
    const h = new Xe(s, l);
    let f = h.parallel(-r), d = f.getCenter(), p = f.start.clone().move(f.end, o), g = f.end.clone().move(f.start, o);
    const v = h.parallel(-1), m = new Xe(v.start, d), y = new Xe(v.end, d);
    if ((u.containsPoint(d) || c.containsPoint(d) || u.intersectsWithLine(m) || u.intersectsWithLine(y) || c.intersectsWithLine(m) || c.intersectsWithLine(y)) && (f = h.parallel(r), d = f.getCenter(), p = f.start.clone().move(f.end, o), g = f.end.clone().move(f.start, o)), e.merge) {
      const b = new Xe(s, l), O = new Xe(d, b.center).setLength(Number.MAX_SAFE_INTEGER), w = u.intersectsWithLine(O), x = c.intersectsWithLine(O), S = w ? Array.isArray(w) ? w : [w] : [];
      x && (Array.isArray(x) ? S.push(...x) : S.push(x));
      const _ = b.center.closest(S);
      _ ? (t.sourceAnchor = _.clone(), t.targetAnchor = _.clone()) : (t.sourceAnchor = b.center.clone(), t.targetAnchor = b.center.clone());
    }
    return Gd([p.toJSON(), d.toJSON(), g.toJSON()], e.merge);
  }
}, _Pe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  er: xPe,
  loop: SPe,
  manhattan: T9,
  metro: wPe,
  normal: rPe,
  oneSide: iPe,
  orth: S9
}, Symbol.toStringTag, { value: "Module" }));
var lc;
(function(n) {
  n.presets = _Pe, n.registry = pr.create({
    type: "router"
  }), n.registry.register(n.presets, !0);
})(lc || (lc = {}));
const CPe = function(n, e, t, r = {}) {
  const i = [n, ...t, e], o = new Ii(i), a = new Bt(o);
  return r.raw ? a : a.serialize();
}, APe = function(n, e, t, r = {}) {
  const i = t.length === 3 ? 0 : 1, o = G.create(t[0 + i]), a = G.create(t[2 + i]), s = G.create(t[1 + i]);
  if (!G.equals(n, e)) {
    const u = new G((n.x + e.x) / 2, (n.y + e.y) / 2), c = u.angleBetween(G.create(n).rotate(90, u), s);
    c > 1 && (o.rotate(180 - c, u), a.rotate(180 - c, u), s.rotate(180 - c, u));
  }
  const l = `
     M ${n.x} ${n.y}
     Q ${o.x} ${o.y} ${s.x} ${s.y}
     Q ${a.x} ${a.y} ${e.x} ${e.y}
  `;
  return r.raw ? Bt.parse(l) : l;
}, TPe = function(n, e, t, r = {}) {
  const i = new Bt();
  i.appendSegment(Bt.createSegment("M", n));
  const o = 1 / 3, a = 2 / 3, s = r.radius || 10;
  let l, u;
  for (let c = 0, h = t.length; c < h; c += 1) {
    const f = G.create(t[c]), d = t[c - 1] || n, p = t[c + 1] || e;
    l = u || f.distance(d) / 2, u = f.distance(p) / 2;
    const g = -Math.min(s, l), v = -Math.min(s, u), m = f.clone().move(d, g).round(), y = f.clone().move(p, v).round(), b = new G(o * m.x + a * f.x, a * f.y + o * m.y), O = new G(o * y.x + a * f.x, a * f.y + o * y.y);
    i.appendSegment(Bt.createSegment("L", m)), i.appendSegment(Bt.createSegment("C", b, O, y));
  }
  return i.appendSegment(Bt.createSegment("L", e)), r.raw ? i : i.serialize();
}, kPe = function(n, e, t, r = {}) {
  let i, o = r.direction;
  if (t && t.length !== 0) {
    const a = [n, ...t, e], s = Jn.throughPoints(a);
    i = new Bt(s);
  } else if (i = new Bt(), i.appendSegment(Bt.createSegment("M", n)), o || (o = Math.abs(n.x - e.x) >= Math.abs(n.y - e.y) ? "H" : "V"), o === "H") {
    const a = (n.x + e.x) / 2;
    i.appendSegment(Bt.createSegment("C", a, n.y, a, e.y, e.x, e.y));
  } else {
    const a = (n.y + e.y) / 2;
    i.appendSegment(Bt.createSegment("C", n.x, a, e.x, a, e.x, e.y));
  }
  return r.raw ? i : i.serialize();
}, d5 = 1, w1 = 1 / 3, x1 = 2 / 3;
function PPe(n) {
  let e = n.graph._jumpOverUpdateList;
  if (e == null && (e = n.graph._jumpOverUpdateList = [], n.graph.on("cell:mouseup", () => {
    const t = n.graph._jumpOverUpdateList;
    setTimeout(() => {
      for (let r = 0; r < t.length; r += 1)
        t[r].update();
    });
  }), n.graph.on("model:reseted", () => {
    e = n.graph._jumpOverUpdateList = [];
  })), e.indexOf(n) < 0) {
    e.push(n);
    const t = () => e.splice(e.indexOf(n), 1);
    n.cell.once("change:connector", t), n.cell.once("removed", t);
  }
}
function A2(n, e, t = []) {
  const r = [n, ...t, e], i = [];
  return r.forEach((o, a) => {
    const s = r[a + 1];
    s != null && i.push(new Xe(o, s));
  }), i;
}
function EPe(n, e) {
  const t = [];
  return e.forEach((r) => {
    const i = n.intersectsWithLine(r);
    i && t.push(i);
  }), t;
}
function p5(n, e) {
  return new Xe(n, e).squaredLength();
}
function MPe(n, e, t) {
  return e.reduce((r, i, o) => {
    if (Tx.includes(i))
      return r;
    const a = r.pop() || n, s = G.create(i).move(a.start, -t);
    let l = G.create(i).move(a.start, +t);
    const u = e[o + 1];
    if (u != null) {
      const f = l.distance(u);
      f <= t && (l = u.move(a.start, f), Tx.push(u));
    } else if (s.distance(a.end) < t * 2 + d5)
      return r.push(a), r;
    if (l.distance(a.start) < t * 2 + d5)
      return r.push(a), r;
    const h = new Xe(s, l);
    return h0.push(h), r.push(new Xe(a.start, s), h, new Xe(l, a.end)), r;
  }, []);
}
function g5(n, e, t, r) {
  const i = new Bt();
  let o;
  return o = Bt.createSegment("M", n[0].start), i.appendSegment(o), n.forEach((a, s) => {
    if (h0.includes(a)) {
      let l, u, c, h;
      if (t === "arc") {
        l = -90, u = a.start.diff(a.end), (u.x < 0 || u.x === 0 && u.y < 0) && (l += 180);
        const d = a.getCenter(), p = new Xe(d, a.end).rotate(l, d);
        let g;
        g = new Xe(a.start, d), c = g.pointAt(2 / 3).rotate(l, a.start), h = p.pointAt(1 / 3).rotate(-l, p.end), o = Bt.createSegment("C", c, h, p.end), i.appendSegment(o), g = new Xe(d, a.end), c = p.pointAt(1 / 3).rotate(l, p.end), h = g.pointAt(1 / 3).rotate(-l, a.end), o = Bt.createSegment("C", c, h, a.end), i.appendSegment(o);
      } else if (t === "gap")
        o = Bt.createSegment("M", a.end), i.appendSegment(o);
      else if (t === "cubic") {
        l = a.start.theta(a.end);
        const f = e * 0.6;
        let d = e * 1.35;
        u = a.start.diff(a.end), (u.x < 0 || u.x === 0 && u.y < 0) && (d *= -1), c = new G(a.start.x + f, a.start.y + d).rotate(l, a.start), h = new G(a.end.x - f, a.end.y + d).rotate(l, a.end), o = Bt.createSegment("C", c, h, a.end), i.appendSegment(o);
      }
    } else {
      const l = n[s + 1];
      r === 0 || !l || h0.includes(l) ? (o = Bt.createSegment("L", a.end), i.appendSegment(o)) : DPe(r, i, a.end, a.start, l.end);
    }
  }), i;
}
function DPe(n, e, t, r, i) {
  const o = t.distance(r) / 2, a = t.distance(i) / 2, s = -Math.min(n, o), l = -Math.min(n, a), u = t.clone().move(r, s).round(), c = t.clone().move(i, l).round(), h = new G(w1 * u.x + x1 * t.x, x1 * t.y + w1 * u.y), f = new G(w1 * c.x + x1 * t.x, x1 * t.y + w1 * c.y);
  let d;
  d = Bt.createSegment("L", u), e.appendSegment(d), d = Bt.createSegment("C", h, f, c), e.appendSegment(d);
}
let h0, Tx;
const LPe = function(n, e, t, r = {}) {
  h0 = [], Tx = [], PPe(this);
  const i = r.size || 5, o = r.type || "arc", a = r.radius || 0, s = r.ignoreConnectors || ["smooth"], l = this.graph, c = l.model.getEdges();
  if (c.length === 1)
    return g5(A2(n, e, t), i, o, a);
  const h = this.cell, f = c.indexOf(h), d = l.options.connecting.connector || {}, p = c.filter((O, w) => {
    const x = O.getConnector() || d;
    return s.includes(x.name) ? !1 : w > f ? x.name !== "jumpover" : !0;
  }), g = p.map((O) => l.findViewByCell(O)), v = A2(n, e, t), m = g.map((O) => O == null ? [] : O === this ? v : A2(O.sourcePoint, O.targetPoint, O.routePoints)), y = [];
  v.forEach((O) => {
    const w = p.reduce((x, S, _) => {
      if (S !== h) {
        const C = EPe(O, m[_]);
        x.push(...C);
      }
      return x;
    }, []).sort((x, S) => p5(O.start, x) - p5(O.start, S));
    w.length > 0 ? y.push(...MPe(O, w, i)) : y.push(O);
  });
  const b = g5(y, i, o, a);
  return h0 = [], Tx = [], r.raw ? b : b.serialize();
}, IPe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  jumpover: LPe,
  loop: APe,
  normal: CPe,
  rounded: TPe,
  smooth: kPe
}, Symbol.toStringTag, { value: "Module" }));
var Nf;
(function(n) {
  n.presets = IPe, n.registry = pr.create({
    type: "connector"
  }), n.registry.register(n.presets, !0);
})(Nf || (Nf = {}));
var RPe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class k9 extends Yn {
  constructor(e = {}) {
    super(), this.pending = !1, this.changing = !1, this.data = {}, this.mutate(Sn(e)), this.changed = {};
  }
  mutate(e, t = {}) {
    const r = t.unset === !0, i = t.silent === !0, o = [], a = this.changing;
    this.changing = !0, a || (this.previous = Sn(this.data), this.changed = {});
    const s = this.data, l = this.previous, u = this.changed;
    if (Object.keys(e).forEach((c) => {
      const h = c, f = e[h];
      hr(s[h], f) || o.push(h), hr(l[h], f) ? delete u[h] : u[h] = f, r ? delete s[h] : s[h] = f;
    }), !i && o.length > 0 && (this.pending = !0, this.pendingOptions = t, o.forEach((c) => {
      this.emit("change:*", {
        key: c,
        options: t,
        store: this,
        current: s[c],
        previous: l[c]
      });
    })), a)
      return this;
    if (!i)
      for (; this.pending; )
        this.pending = !1, this.emit("changed", {
          current: s,
          previous: l,
          store: this,
          options: this.pendingOptions
        });
    return this.pending = !1, this.changing = !1, this.pendingOptions = null, this;
  }
  get(e, t) {
    if (e == null)
      return this.data;
    const r = this.data[e];
    return r ?? t;
  }
  getPrevious(e) {
    if (this.previous) {
      const t = this.previous[e];
      return t ?? void 0;
    }
  }
  set(e, t, r) {
    return e != null && (typeof e == "object" ? this.mutate(e, t) : this.mutate({ [e]: t }, r)), this;
  }
  remove(e, t) {
    const i = {};
    let o;
    if (typeof e == "string")
      i[e] = void 0, o = t;
    else if (Array.isArray(e))
      e.forEach((a) => i[a] = void 0), o = t;
    else {
      for (const a in this.data)
        i[a] = void 0;
      o = e;
    }
    return this.mutate(i, Object.assign(Object.assign({}, o), { unset: !0 })), this;
  }
  getByPath(e) {
    return nI(this.data, e, "/");
  }
  setByPath(e, t, r = {}) {
    const i = "/", o = Array.isArray(e) ? [...e] : e.split(i), a = Array.isArray(e) ? e.join(i) : e, s = o[0], l = o.length;
    if (r.propertyPath = a, r.propertyValue = t, r.propertyPathArray = o, l === 1)
      this.set(s, t, r);
    else {
      const u = {};
      let c = u, h = s;
      for (let p = 1; p < l; p += 1) {
        const g = o[p], v = Number.isFinite(Number(g));
        c = c[h] = v ? [] : {}, h = g;
      }
      vv(u, o, t, i);
      const f = Sn(this.data);
      r.rewrite && GB(f, e, i);
      const d = er(f, u);
      this.set(s, d[s], r);
    }
    return this;
  }
  removeByPath(e, t) {
    const r = Array.isArray(e) ? e : e.split("/"), i = r[0];
    if (r.length === 1)
      this.remove(i, t);
    else {
      const o = r.slice(1), a = Sn(this.get(i));
      a && GB(a, o), this.set(i, a, t);
    }
    return this;
  }
  hasChanged(e) {
    return e == null ? Object.keys(this.changed).length > 0 : e in this.changed;
  }
  /**
   * Returns an object containing all the data that have changed,
   * or `null` if there are no changes. Useful for determining what
   * parts of a view need to be updated.
   */
  getChanges(e) {
    if (e == null)
      return this.hasChanged() ? Sn(this.changed) : null;
    const t = this.changing ? this.previous : this.data, r = {};
    let i;
    for (const o in e) {
      const a = e[o];
      hr(t[o], a) || (r[o] = a, i = !0);
    }
    return i ? Sn(r) : null;
  }
  /**
   * Returns a copy of the store's `data` object.
   */
  toJSON() {
    return Sn(this.data);
  }
  clone() {
    const e = this.constructor;
    return new e(this.data);
  }
  dispose() {
    this.off(), this.data = {}, this.previous = {}, this.changed = {}, this.pending = !1, this.changing = !1, this.pendingOptions = null, this.trigger("disposed", { store: this });
  }
}
RPe([
  Yn.dispose()
], k9.prototype, "dispose", null);
let jP = class P9 {
  constructor(e) {
    this.cell = e, this.ids = {}, this.cache = {};
  }
  get() {
    return Object.keys(this.ids);
  }
  start(e, t, r = {}, i = "/") {
    const o = this.cell.getPropByPath(e), a = Rfe(r, P9.defaultOptions), s = this.getTiming(a.timing), l = this.getInterp(a.interp, o, t);
    let u = 0;
    const c = Array.isArray(e) ? e.join(i) : e, h = Array.isArray(e) ? e : e.split(i), f = () => {
      const d = (/* @__PURE__ */ new Date()).getTime();
      u === 0 && (u = d);
      let g = (d - u) / a.duration;
      g < 1 ? this.ids[c] = requestAnimationFrame(f) : g = 1;
      const v = l(s(g));
      this.cell.setPropByPath(h, v), r.progress && r.progress(Object.assign({ progress: g, currentValue: v }, this.getArgs(c))), g === 1 && (this.cell.notify("transition:complete", this.getArgs(c)), r.complete && r.complete(this.getArgs(c)), this.cell.notify("transition:finish", this.getArgs(c)), r.finish && r.finish(this.getArgs(c)), this.clean(c));
    };
    return setTimeout(() => {
      this.stop(e, void 0, i), this.cache[c] = { startValue: o, targetValue: t, options: a }, this.ids[c] = requestAnimationFrame(f), this.cell.notify("transition:start", this.getArgs(c)), r.start && r.start(this.getArgs(c));
    }, r.delay), this.stop.bind(this, e, i, r);
  }
  stop(e, t = {}, r = "/") {
    const i = Array.isArray(e) ? e : e.split(r);
    return Object.keys(this.ids).filter((o) => hr(i, o.split(r).slice(0, i.length))).forEach((o) => {
      cancelAnimationFrame(this.ids[o]);
      const a = this.cache[o], s = this.getArgs(o), l = Object.assign(Object.assign({}, a.options), t), u = l.jumpedToEnd;
      u && a.targetValue != null && (this.cell.setPropByPath(o, a.targetValue), this.cell.notify("transition:end", Object.assign({}, s)), this.cell.notify("transition:complete", Object.assign({}, s)), l.complete && l.complete(Object.assign({}, s)));
      const c = Object.assign({ jumpedToEnd: u }, s);
      this.cell.notify("transition:stop", Object.assign({}, c)), l.stop && l.stop(Object.assign({}, c)), this.cell.notify("transition:finish", Object.assign({}, s)), l.finish && l.finish(Object.assign({}, s)), this.clean(o);
    }), this;
  }
  clean(e) {
    delete this.ids[e], delete this.cache[e];
  }
  getTiming(e) {
    return typeof e == "string" ? td[e] : e;
  }
  getInterp(e, t, r) {
    return e ? e(t, r) : typeof r == "number" ? vf.number(t, r) : typeof r == "string" ? r[0] === "#" ? vf.color(t, r) : vf.unit(t, r) : vf.object(t, r);
  }
  getArgs(e) {
    const t = this.cache[e];
    return {
      path: e,
      startValue: t.startValue,
      targetValue: t.targetValue,
      cell: this.cell
    };
  }
};
(function(n) {
  n.defaultOptions = {
    delay: 10,
    duration: 100,
    timing: "linear"
  };
})(jP || (jP = {}));
var NPe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
}, E9 = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class Qt extends Yn {
  static config(e) {
    const { markup: t, propHooks: r, attrHooks: i } = e, o = E9(e, ["markup", "propHooks", "attrHooks"]);
    t != null && (this.markup = t), r && (this.propHooks = this.propHooks.slice(), Array.isArray(r) ? this.propHooks.push(...r) : typeof r == "function" ? this.propHooks.push(r) : Object.values(r).forEach((a) => {
      typeof a == "function" && this.propHooks.push(a);
    })), i && (this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), i)), this.defaults = er({}, this.defaults, o);
  }
  static getMarkup() {
    return this.markup;
  }
  static getDefaults(e) {
    return e ? this.defaults : Sn(this.defaults);
  }
  static getAttrHooks() {
    return this.attrHooks;
  }
  static applyPropHooks(e, t) {
    return this.propHooks.reduce((r, i) => i ? rt(i, e, r) : r, t);
  }
  // #endregion
  get [Symbol.toStringTag]() {
    return Qt.toStringTag;
  }
  constructor(e = {}) {
    super();
    const r = this.constructor.getDefaults(!0), i = er({}, this.preprocess(r), this.preprocess(e));
    this.id = i.id || gx(), this.store = new k9(i), this.animation = new jP(this), this.setup(), this.init(), this.postprocess(e);
  }
  init() {
  }
  // #region model
  get model() {
    return this._model;
  }
  set model(e) {
    this._model !== e && (this._model = e);
  }
  // #endregion
  preprocess(e, t) {
    const r = e.id, o = this.constructor.applyPropHooks(this, e);
    return r == null && t !== !0 && (o.id = gx()), o;
  }
  postprocess(e) {
  }
  // eslint-disable-line
  setup() {
    this.store.on("change:*", (e) => {
      const { key: t, current: r, previous: i, options: o } = e;
      this.notify("change:*", {
        key: t,
        options: o,
        current: r,
        previous: i,
        cell: this
      }), this.notify(`change:${t}`, {
        options: o,
        current: r,
        previous: i,
        cell: this
      });
      const a = t;
      (a === "source" || a === "target") && this.notify("change:terminal", {
        type: a,
        current: r,
        previous: i,
        options: o,
        cell: this
      });
    }), this.store.on("changed", ({ options: e }) => this.notify("changed", { options: e, cell: this }));
  }
  notify(e, t) {
    this.trigger(e, t);
    const r = this.model;
    return r && (r.notify(`cell:${e}`, t), this.isNode() ? r.notify(`node:${e}`, Object.assign(Object.assign({}, t), { node: this })) : this.isEdge() && r.notify(`edge:${e}`, Object.assign(Object.assign({}, t), { edge: this }))), this;
  }
  isNode() {
    return !1;
  }
  isEdge() {
    return !1;
  }
  isSameStore(e) {
    return this.store === e.store;
  }
  get view() {
    return this.store.get("view");
  }
  get shape() {
    return this.store.get("shape", "");
  }
  getProp(e, t) {
    return e == null ? this.store.get() : this.store.get(e, t);
  }
  setProp(e, t, r) {
    if (typeof e == "string")
      this.store.set(e, t, r);
    else {
      const i = this.preprocess(e, !0);
      this.store.set(er({}, this.getProp(), i), t), this.postprocess(e);
    }
    return this;
  }
  removeProp(e, t) {
    return typeof e == "string" || Array.isArray(e) ? this.store.removeByPath(e, t) : this.store.remove(t), this;
  }
  hasChanged(e) {
    return e == null ? this.store.hasChanged() : this.store.hasChanged(e);
  }
  getPropByPath(e) {
    return this.store.getByPath(e);
  }
  setPropByPath(e, t, r = {}) {
    return this.model && (e === "children" ? this._children = t ? t.map((i) => this.model.getCell(i)).filter((i) => i != null) : null : e === "parent" && (this._parent = t ? this.model.getCell(t) : null)), this.store.setByPath(e, t, r), this;
  }
  removePropByPath(e, t = {}) {
    const r = Array.isArray(e) ? e : e.split("/");
    return r[0] === "attrs" && (t.dirty = !0), this.store.removeByPath(r, t), this;
  }
  prop(e, t, r) {
    return e == null ? this.getProp() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getPropByPath(e) : t == null ? this.removePropByPath(e, r || {}) : this.setPropByPath(e, t, r || {}) : this.setProp(e, t || {});
  }
  previous(e) {
    return this.store.getPrevious(e);
  }
  // #endregion
  // #region zIndex
  get zIndex() {
    return this.getZIndex();
  }
  set zIndex(e) {
    e == null ? this.removeZIndex() : this.setZIndex(e);
  }
  getZIndex() {
    return this.store.get("zIndex");
  }
  setZIndex(e, t = {}) {
    return this.store.set("zIndex", e, t), this;
  }
  removeZIndex(e = {}) {
    return this.store.remove("zIndex", e), this;
  }
  toFront(e = {}) {
    const t = this.model;
    if (t) {
      let r = t.getMaxZIndex(), i;
      e.deep ? (i = this.getDescendants({ deep: !0, breadthFirst: !0 }), i.unshift(this)) : i = [this], r = r - i.length + 1;
      const o = t.total();
      let a = t.indexOf(this) !== o - i.length;
      a || (a = i.some((s, l) => s.getZIndex() !== r + l)), a && this.batchUpdate("to-front", () => {
        r += i.length, i.forEach((s, l) => {
          s.setZIndex(r + l, e);
        });
      });
    }
    return this;
  }
  toBack(e = {}) {
    const t = this.model;
    if (t) {
      let r = t.getMinZIndex(), i;
      e.deep ? (i = this.getDescendants({ deep: !0, breadthFirst: !0 }), i.unshift(this)) : i = [this];
      let o = t.indexOf(this) !== 0;
      o || (o = i.some((a, s) => a.getZIndex() !== r + s)), o && this.batchUpdate("to-back", () => {
        r -= i.length, i.forEach((a, s) => {
          a.setZIndex(r + s, e);
        });
      });
    }
    return this;
  }
  // #endregion
  // #region markup
  get markup() {
    return this.getMarkup();
  }
  set markup(e) {
    e == null ? this.removeMarkup() : this.setMarkup(e);
  }
  getMarkup() {
    let e = this.store.get("markup");
    return e == null && (e = this.constructor.getMarkup()), e;
  }
  setMarkup(e, t = {}) {
    return this.store.set("markup", e, t), this;
  }
  removeMarkup(e = {}) {
    return this.store.remove("markup", e), this;
  }
  // #endregion
  // #region attrs
  get attrs() {
    return this.getAttrs();
  }
  set attrs(e) {
    e == null ? this.removeAttrs() : this.setAttrs(e);
  }
  getAttrs() {
    const e = this.store.get("attrs");
    return e ? Object.assign({}, e) : {};
  }
  setAttrs(e, t = {}) {
    if (e == null)
      this.removeAttrs(t);
    else {
      const r = (i) => this.store.set("attrs", i, t);
      if (t.overwrite === !0)
        r(e);
      else {
        const i = this.getAttrs();
        t.deep === !1 ? r(Object.assign(Object.assign({}, i), e)) : r(er({}, i, e));
      }
    }
    return this;
  }
  replaceAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeAttrs(e = {}) {
    return this.store.remove("attrs", e), this;
  }
  getAttrDefinition(e) {
    if (!e)
      return null;
    const r = this.constructor.getAttrHooks() || {};
    let i = r[e] || bl.registry.get(e);
    if (!i) {
      const o = d_(e);
      i = r[o] || bl.registry.get(o);
    }
    return i || null;
  }
  getAttrByPath(e) {
    return e == null || e === "" ? this.getAttrs() : this.getPropByPath(this.prefixAttrPath(e));
  }
  setAttrByPath(e, t, r = {}) {
    return this.setPropByPath(this.prefixAttrPath(e), t, r), this;
  }
  removeAttrByPath(e, t = {}) {
    return this.removePropByPath(this.prefixAttrPath(e), t), this;
  }
  prefixAttrPath(e) {
    return Array.isArray(e) ? ["attrs"].concat(e) : `attrs/${e}`;
  }
  attr(e, t, r) {
    return e == null ? this.getAttrByPath() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getAttrByPath(e) : t == null ? this.removeAttrByPath(e, r || {}) : this.setAttrByPath(e, t, r || {}) : this.setAttrs(e, t || {});
  }
  // #endregion
  // #region visible
  get visible() {
    return this.isVisible();
  }
  set visible(e) {
    this.setVisible(e);
  }
  setVisible(e, t = {}) {
    return this.store.set("visible", e, t), this;
  }
  isVisible() {
    return this.store.get("visible") !== !1;
  }
  show(e = {}) {
    return this.isVisible() || this.setVisible(!0, e), this;
  }
  hide(e = {}) {
    return this.isVisible() && this.setVisible(!1, e), this;
  }
  toggleVisible(e, t = {}) {
    const r = typeof e == "boolean" ? e : !this.isVisible(), i = typeof e == "boolean" ? t : e;
    return r ? this.show(i) : this.hide(i), this;
  }
  // #endregion
  // #region data
  get data() {
    return this.getData();
  }
  set data(e) {
    this.setData(e);
  }
  getData() {
    return this.store.get("data");
  }
  setData(e, t = {}) {
    if (e == null)
      this.removeData(t);
    else {
      const r = (i) => this.store.set("data", i, t);
      if (t.overwrite === !0)
        r(e);
      else {
        const i = this.getData();
        t.deep === !1 ? r(typeof e == "object" ? Object.assign(Object.assign({}, i), e) : e) : r(er({}, i, e));
      }
    }
    return this;
  }
  replaceData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeData(e = {}) {
    return this.store.remove("data", e), this;
  }
  // #endregion
  // #region parent children
  get parent() {
    return this.getParent();
  }
  get children() {
    return this.getChildren();
  }
  getParentId() {
    return this.store.get("parent");
  }
  getParent() {
    const e = this.getParentId();
    if (e && this.model) {
      const t = this.model.getCell(e);
      return this._parent = t, t;
    }
    return null;
  }
  getChildren() {
    const e = this.store.get("children");
    if (e && e.length && this.model) {
      const t = e.map((r) => {
        var i;
        return (i = this.model) === null || i === void 0 ? void 0 : i.getCell(r);
      }).filter((r) => r != null);
      return this._children = t, [...t];
    }
    return null;
  }
  hasParent() {
    return this.parent != null;
  }
  isParentOf(e) {
    return e != null && e.getParent() === this;
  }
  isChildOf(e) {
    return e != null && this.getParent() === e;
  }
  eachChild(e, t) {
    return this.children && this.children.forEach(e, t), this;
  }
  filterChild(e, t) {
    return this.children ? this.children.filter(e, t) : [];
  }
  getChildCount() {
    return this.children == null ? 0 : this.children.length;
  }
  getChildIndex(e) {
    return this.children == null ? -1 : this.children.indexOf(e);
  }
  getChildAt(e) {
    return this.children != null && e >= 0 ? this.children[e] : null;
  }
  getAncestors(e = {}) {
    const t = [];
    let r = this.getParent();
    for (; r; )
      t.push(r), r = e.deep !== !1 ? r.getParent() : null;
    return t;
  }
  getDescendants(e = {}) {
    if (e.deep !== !1) {
      if (e.breadthFirst) {
        const t = [], r = this.getChildren() || [];
        for (; r.length > 0; ) {
          const i = r.shift(), o = i.getChildren();
          t.push(i), o && r.push(...o);
        }
        return t;
      }
      {
        const t = this.getChildren() || [];
        return t.forEach((r) => {
          t.push(...r.getDescendants(e));
        }), t;
      }
    }
    return this.getChildren() || [];
  }
  isDescendantOf(e, t = {}) {
    if (e == null)
      return !1;
    if (t.deep !== !1) {
      let r = this.getParent();
      for (; r; ) {
        if (r === e)
          return !0;
        r = r.getParent();
      }
      return !1;
    }
    return this.isChildOf(e);
  }
  isAncestorOf(e, t = {}) {
    return e == null ? !1 : e.isDescendantOf(this, t);
  }
  contains(e) {
    return this.isAncestorOf(e);
  }
  getCommonAncestor(...e) {
    return Qt.getCommonAncestor(this, ...e);
  }
  setParent(e, t = {}) {
    return this._parent = e, e ? this.store.set("parent", e.id, t) : this.store.remove("parent", t), this;
  }
  setChildren(e, t = {}) {
    return this._children = e, e != null ? this.store.set("children", e.map((r) => r.id), t) : this.store.remove("children", t), this;
  }
  unembed(e, t = {}) {
    const r = this.children;
    if (r != null && e != null) {
      const i = this.getChildIndex(e);
      i !== -1 && (r.splice(i, 1), e.setParent(null, t), this.setChildren(r, t));
    }
    return this;
  }
  embed(e, t = {}) {
    return e.addTo(this, t), this;
  }
  addTo(e, t = {}) {
    return Qt.isCell(e) ? e.addChild(this, t) : e.addCell(this, t), this;
  }
  insertTo(e, t, r = {}) {
    return e.insertChild(this, t, r), this;
  }
  addChild(e, t = {}) {
    return this.insertChild(e, void 0, t);
  }
  insertChild(e, t, r = {}) {
    if (e != null && e !== this) {
      const i = e.getParent(), o = this !== i;
      let a = t;
      if (a == null && (a = this.getChildCount(), o || (a -= 1)), i) {
        const l = i.getChildren();
        if (l) {
          const u = l.indexOf(e);
          u >= 0 && (e.setParent(null, r), l.splice(u, 1), i.setChildren(l, r));
        }
      }
      let s = this.children;
      if (s == null ? (s = [], s.push(e)) : s.splice(a, 0, e), e.setParent(this, r), this.setChildren(s, r), o && this.model) {
        const l = this.model.getIncomingEdges(this), u = this.model.getOutgoingEdges(this);
        l && l.forEach((c) => c.updateParent(r)), u && u.forEach((c) => c.updateParent(r));
      }
      this.model && this.model.addCell(e, r);
    }
    return this;
  }
  removeFromParent(e = {}) {
    const t = this.getParent();
    if (t != null) {
      const r = t.getChildIndex(this);
      t.removeChildAt(r, e);
    }
    return this;
  }
  removeChild(e, t = {}) {
    const r = this.getChildIndex(e);
    return this.removeChildAt(r, t);
  }
  removeChildAt(e, t = {}) {
    const r = this.getChildAt(e);
    return this.children != null && r != null && (this.unembed(r, t), r.remove(t)), r;
  }
  remove(e = {}) {
    return this.batchUpdate("remove", () => {
      const t = this.getParent();
      t && t.removeChild(this, e), e.deep !== !1 && this.eachChild((r) => r.remove(e)), this.model && this.model.removeCell(this, e);
    }), this;
  }
  transition(e, t, r = {}, i = "/") {
    return this.animation.start(e, t, r, i);
  }
  stopTransition(e, t, r = "/") {
    return this.animation.stop(e, t, r), this;
  }
  getTransitions() {
    return this.animation.get();
  }
  // #endregion
  // #region transform
  // eslint-disable-next-line
  translate(e, t, r) {
    return this;
  }
  scale(e, t, r, i) {
    return this;
  }
  addTools(e, t, r) {
    const i = Array.isArray(e) ? e : [e], o = typeof t == "string" ? t : null, a = typeof t == "object" ? t : typeof r == "object" ? r : {};
    if (a.reset)
      return this.setTools({ name: o, items: i, local: a.local }, a);
    let s = Sn(this.getTools());
    if (s == null || o == null || s.name === o)
      return s == null && (s = {}), s.items || (s.items = []), s.name = o, s.items = [...s.items, ...i], this.setTools(Object.assign({}, s), a);
  }
  setTools(e, t = {}) {
    return e == null ? this.removeTools() : this.store.set("tools", Qt.normalizeTools(e), t), this;
  }
  getTools() {
    return this.store.get("tools");
  }
  removeTools(e = {}) {
    return this.store.remove("tools", e), this;
  }
  hasTools(e) {
    const t = this.getTools();
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  hasTool(e) {
    const t = this.getTools();
    return t == null ? !1 : t.items.some((r) => typeof r == "string" ? r === e : r.name === e);
  }
  removeTool(e, t = {}) {
    const r = Sn(this.getTools());
    if (r) {
      let i = !1;
      const o = r.items.slice(), a = (s) => {
        o.splice(s, 1), i = !0;
      };
      if (typeof e == "number")
        a(e);
      else
        for (let s = o.length - 1; s >= 0; s -= 1) {
          const l = o[s];
          (typeof l == "string" ? l === e : l.name === e) && a(s);
        }
      i && (r.items = o, this.setTools(r, t));
    }
    return this;
  }
  // #endregion
  // #region common
  // eslint-disable-next-line
  getBBox(e) {
    return new Te();
  }
  // eslint-disable-next-line
  getConnectionPoint(e, t) {
    return new G();
  }
  toJSON(e = {}) {
    const t = Object.assign({}, this.store.get()), r = Object.prototype.toString, i = this.isNode() ? "node" : this.isEdge() ? "edge" : "cell";
    if (!t.shape) {
      const p = this.constructor;
      throw new Error(`Unable to serialize ${i} missing "shape" prop, check the ${i} "${p.name || r.call(p)}"`);
    }
    const o = this.constructor, a = e.diff === !0, s = t.attrs || {}, l = o.getDefaults(!0), u = a ? this.preprocess(l, !0) : l, c = u.attrs || {}, h = {};
    Object.entries(t).forEach(([p, g]) => {
      if (g != null && !Array.isArray(g) && typeof g == "object" && !bs(g))
        throw new Error(`Can only serialize ${i} with plain-object props, but got a "${r.call(g)}" type of key "${p}" on ${i} "${this.id}"`);
      if (p !== "attrs" && p !== "shape" && a) {
        const v = u[p];
        hr(g, v) && delete t[p];
      }
    }), Object.keys(s).forEach((p) => {
      const g = s[p], v = c[p];
      Object.keys(g).forEach((m) => {
        const y = g[m], b = v ? v[m] : null;
        y != null && typeof y == "object" && !Array.isArray(y) ? Object.keys(y).forEach((O) => {
          const w = y[O];
          if (v == null || b == null || !tr(b) || !hr(b[O], w)) {
            h[p] == null && (h[p] = {}), h[p][m] == null && (h[p][m] = {});
            const x = h[p][m];
            x[O] = w;
          }
        }) : (v == null || !hr(b, y)) && (h[p] == null && (h[p] = {}), h[p][m] = y);
      });
    });
    const f = Object.assign(Object.assign({}, t), { attrs: zj(h) ? void 0 : h });
    f.attrs == null && delete f.attrs;
    const d = f;
    return d.angle === 0 && delete d.angle, Sn(d);
  }
  clone(e = {}) {
    if (!e.deep) {
      const r = Object.assign({}, this.store.get());
      e.keepId || delete r.id, delete r.parent, delete r.children;
      const i = this.constructor;
      return new i(r);
    }
    return Qt.deepClone(this)[this.id];
  }
  findView(e) {
    return e.findViewByCell(this);
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}, r = this.model) {
    return this.notify("batch:start", { name: e, data: t, cell: this }), r && r.startBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this;
  }
  stopBatch(e, t = {}, r = this.model) {
    return r && r.stopBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this.notify("batch:stop", { name: e, data: t, cell: this }), this;
  }
  batchUpdate(e, t, r) {
    const i = this.model;
    this.startBatch(e, r, i);
    const o = t();
    return this.stopBatch(e, r, i), o;
  }
  // #endregion
  // #region IDisposable
  dispose() {
    this.removeFromParent(), this.store.dispose();
  }
}
Qt.defaults = {};
Qt.attrHooks = {};
Qt.propHooks = [];
NPe([
  Yn.dispose()
], Qt.prototype, "dispose", null);
(function(n) {
  function e(t) {
    return typeof t == "string" ? { items: [t] } : Array.isArray(t) ? { items: t } : t.items ? t : {
      items: [t]
    };
  }
  n.normalizeTools = e;
})(Qt || (Qt = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function";
  }
  n.isCell = e;
})(Qt || (Qt = {}));
(function(n) {
  function e(...o) {
    const a = o.filter((l) => l != null).map((l) => l.getAncestors()).sort((l, u) => l.length - u.length);
    return a.shift().find((l) => a.every((u) => u.includes(l))) || null;
  }
  n.getCommonAncestor = e;
  function t(o, a = {}) {
    let s = null;
    for (let l = 0, u = o.length; l < u; l += 1) {
      const c = o[l];
      let h = c.getBBox(a);
      if (h) {
        if (c.isNode()) {
          const f = c.getAngle();
          f != null && f !== 0 && (h = h.bbox(f));
        }
        s = s == null ? h : s.union(h);
      }
    }
    return s;
  }
  n.getCellsBBox = t;
  function r(o) {
    const a = [o, ...o.getDescendants({ deep: !0 })];
    return n.cloneCells(a);
  }
  n.deepClone = r;
  function i(o) {
    const a = qj(o), s = a.reduce((l, u) => (l[u.id] = u.clone(), l), {});
    return a.forEach((l) => {
      const u = s[l.id];
      if (u.isEdge()) {
        const f = u.getSourceCellId(), d = u.getTargetCellId();
        f && s[f] && u.setSource(Object.assign(Object.assign({}, u.getSource()), { cell: s[f].id })), d && s[d] && u.setTarget(Object.assign(Object.assign({}, u.getTarget()), { cell: s[d].id }));
      }
      const c = l.getParent();
      c && s[c.id] && u.setParent(s[c.id]);
      const h = l.getChildren();
      if (h && h.length) {
        const f = h.reduce((d, p) => (s[p.id] && d.push(s[p.id]), d), []);
        f.length > 0 && u.setChildren(f);
      }
    }), s;
  }
  n.cloneCells = i;
})(Qt || (Qt = {}));
(function(n) {
  n.config({
    propHooks(e) {
      var { tools: t } = e, r = E9(e, ["tools"]);
      return t && (r.tools = n.normalizeTools(t)), r;
    }
  });
})(Qt || (Qt = {}));
var Rg;
(function(n) {
  let e, t;
  function r(a, s) {
    return s ? e != null && e.exist(a) : t != null && t.exist(a);
  }
  n.exist = r;
  function i(a) {
    e = a;
  }
  n.setEdgeRegistry = i;
  function o(a) {
    t = a;
  }
  n.setNodeRegistry = o;
})(Rg || (Rg = {}));
class $Pe {
  constructor(e) {
    this.ports = [], this.groups = {}, this.init(Sn(e));
  }
  getPorts() {
    return this.ports;
  }
  getGroup(e) {
    return e != null ? this.groups[e] : null;
  }
  getPortsByGroup(e) {
    return this.ports.filter((t) => t.group === e || t.group == null && e == null);
  }
  getPortsLayoutByGroup(e, t) {
    const r = this.getPortsByGroup(e), i = e ? this.getGroup(e) : null, o = i ? i.position : null, a = o ? o.name : null;
    let s;
    if (a != null) {
      const h = Rf.registry.get(a);
      if (h == null)
        return Rf.registry.onNotFound(a);
      s = h;
    } else
      s = Rf.presets.left;
    const l = r.map((h) => h && h.position && h.position.args || {}), u = o && o.args || {};
    return s(l, t, u).map((h, f) => {
      const d = r[f];
      return {
        portLayout: h,
        portId: d.id,
        portSize: d.size,
        portAttrs: d.attrs,
        labelSize: d.label.size,
        labelLayout: this.getPortLabelLayout(d, G.create(h.position), t)
      };
    });
  }
  init(e) {
    const { groups: t, items: r } = e;
    t != null && Object.keys(t).forEach((i) => {
      this.groups[i] = this.parseGroup(t[i]);
    }), Array.isArray(r) && r.forEach((i) => {
      this.ports.push(this.parsePort(i));
    });
  }
  parseGroup(e) {
    return Object.assign(Object.assign({}, e), { label: this.getLabel(e, !0), position: this.getPortPosition(e.position, !0) });
  }
  parsePort(e) {
    const t = Object.assign({}, e), r = this.getGroup(e.group) || {};
    return t.markup = t.markup || r.markup, t.attrs = er({}, r.attrs, t.attrs), t.position = this.createPosition(r, t), t.label = er({}, r.label, this.getLabel(t)), t.zIndex = this.getZIndex(r, t), t.size = Object.assign(Object.assign({}, r.size), t.size), t;
  }
  getZIndex(e, t) {
    return typeof t.zIndex == "number" ? t.zIndex : typeof e.zIndex == "number" || e.zIndex === "auto" ? e.zIndex : "auto";
  }
  createPosition(e, t) {
    return er({
      name: "left",
      args: {}
    }, e.position, { args: t.args });
  }
  getPortPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (Array.isArray(e))
        return {
          name: "absolute",
          args: { x: e[0], y: e[1] }
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getPortLabelPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getLabel(e, t = !1) {
    const r = e.label || {};
    return r.position = this.getPortLabelPosition(r.position, t), r;
  }
  getPortLabelLayout(e, t, r) {
    const i = e.label.position.name || "left", o = e.label.position.args || {}, a = kg.registry.get(i) || kg.presets.left;
    return a ? a(t, r, o) : null;
  }
}
var I_ = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
let gr = class M9 extends Qt {
  get [Symbol.toStringTag]() {
    return M9.toStringTag;
  }
  constructor(e = {}) {
    super(e), this.initPorts();
  }
  preprocess(e, t) {
    const { x: r, y: i, width: o, height: a } = e, s = I_(e, ["x", "y", "width", "height"]);
    if (r != null || i != null) {
      const l = s.position;
      s.position = Object.assign(Object.assign({}, l), { x: r ?? (l ? l.x : 0), y: i ?? (l ? l.y : 0) });
    }
    if (o != null || a != null) {
      const l = s.size;
      s.size = Object.assign(Object.assign({}, l), { width: o ?? (l ? l.width : 0), height: a ?? (l ? l.height : 0) });
    }
    return super.preprocess(s, t);
  }
  isNode() {
    return !0;
  }
  size(e, t, r) {
    return e === void 0 ? this.getSize() : typeof e == "number" ? this.setSize(e, t, r) : this.setSize(e, t);
  }
  getSize() {
    const e = this.store.get("size");
    return e ? Object.assign({}, e) : { width: 1, height: 1 };
  }
  setSize(e, t, r) {
    return typeof e == "object" ? this.resize(e.width, e.height, t) : this.resize(e, t, r), this;
  }
  resize(e, t, r = {}) {
    this.startBatch("resize", r);
    const i = r.direction;
    if (i) {
      const o = this.getSize();
      switch (i) {
        case "left":
        case "right":
          t = o.height;
          break;
        case "top":
        case "bottom":
          e = o.width;
          break;
      }
      let s = {
        right: 0,
        "top-right": 0,
        top: 1,
        "top-left": 1,
        left: 2,
        "bottom-left": 2,
        bottom: 3,
        "bottom-right": 3
      }[i];
      const l = Jt.normalize(this.getAngle() || 0);
      r.absolute && (s += Math.floor((l + 45) / 90), s %= 4);
      const u = this.getBBox();
      let c;
      s === 0 ? c = u.getBottomLeft() : s === 1 ? c = u.getCorner() : s === 2 ? c = u.getTopRight() : c = u.getOrigin();
      const h = c.clone().rotate(-l, u.getCenter()), f = Math.sqrt(e * e + t * t) / 2;
      let d = s * Math.PI / 2;
      d += Math.atan(s % 2 === 0 ? t / e : e / t), d -= Jt.toRad(l);
      const g = G.fromPolar(f, d, h).clone().translate(e / -2, t / -2);
      this.store.set("size", { width: e, height: t }, r), this.setPosition(g.x, g.y, r);
    } else
      this.store.set("size", { width: e, height: t }, r);
    return this.stopBatch("resize", r), this;
  }
  scale(e, t, r, i = {}) {
    const o = this.getBBox().scale(e, t, r ?? void 0);
    return this.startBatch("scale", i), this.setPosition(o.x, o.y, i), this.resize(o.width, o.height, i), this.stopBatch("scale"), this;
  }
  position(e, t, r) {
    return typeof e == "number" ? this.setPosition(e, t, r) : this.getPosition(e);
  }
  getPosition(e = {}) {
    if (e.relative) {
      const r = this.getParent();
      if (r != null && r.isNode()) {
        const i = this.getPosition(), o = r.getPosition();
        return {
          x: i.x - o.x,
          y: i.y - o.y
        };
      }
    }
    const t = this.store.get("position");
    return t ? Object.assign({}, t) : { x: 0, y: 0 };
  }
  setPosition(e, t, r = {}) {
    let i, o, a;
    if (typeof e == "object" ? (i = e.x, o = e.y, a = t || {}) : (i = e, o = t, a = r || {}), a.relative) {
      const s = this.getParent();
      if (s != null && s.isNode()) {
        const l = s.getPosition();
        i += l.x, o += l.y;
      }
    }
    if (a.deep) {
      const s = this.getPosition();
      this.translate(i - s.x, o - s.y, a);
    } else
      this.store.set("position", { x: i, y: o }, a);
    return this;
  }
  translate(e = 0, t = 0, r = {}) {
    if (e === 0 && t === 0)
      return this;
    r.translateBy = r.translateBy || this.id;
    const i = this.getPosition();
    if (r.restrict != null && r.translateBy === this.id) {
      const a = this.getBBox({ deep: !0 }), s = r.restrict, l = i.x - a.x, u = i.y - a.y, c = Math.max(s.x + l, Math.min(s.x + s.width + l - a.width, i.x + e)), h = Math.max(s.y + u, Math.min(s.y + s.height + u - a.height, i.y + t));
      e = c - i.x, t = h - i.y;
    }
    const o = {
      x: i.x + e,
      y: i.y + t
    };
    return r.tx = e, r.ty = t, r.transition ? (typeof r.transition != "object" && (r.transition = {}), this.transition("position", o, Object.assign(Object.assign({}, r.transition), { interp: vf.object })), this.eachChild((a) => {
      var s;
      ((s = r.exclude) === null || s === void 0 ? void 0 : s.includes(a)) || a.translate(e, t, r);
    })) : (this.startBatch("translate", r), this.store.set("position", o, r), this.eachChild((a) => {
      var s;
      ((s = r.exclude) === null || s === void 0 ? void 0 : s.includes(a)) || a.translate(e, t, r);
    }), this.stopBatch("translate", r)), this;
  }
  angle(e, t) {
    return e == null ? this.getAngle() : this.rotate(e, t);
  }
  getAngle() {
    return this.store.get("angle", 0);
  }
  rotate(e, t = {}) {
    const r = this.getAngle();
    if (t.center) {
      const i = this.getSize(), o = this.getPosition(), a = this.getBBox().getCenter();
      a.rotate(r - e, t.center);
      const s = a.x - i.width / 2 - o.x, l = a.y - i.height / 2 - o.y;
      this.startBatch("rotate", { angle: e, options: t }), this.setPosition(o.x + s, o.y + l, t), this.rotate(e, Object.assign(Object.assign({}, t), { center: null })), this.stopBatch("rotate");
    } else
      this.store.set("angle", t.absolute ? e : (r + e) % 360, t);
    return this;
  }
  // #endregion
  // #region common
  getBBox(e = {}) {
    if (e.deep) {
      const t = this.getDescendants({ deep: !0, breadthFirst: !0 });
      return t.push(this), Qt.getCellsBBox(t);
    }
    return Te.fromPositionAndSize(this.getPosition(), this.getSize());
  }
  getConnectionPoint(e, t) {
    const r = this.getBBox(), i = r.getCenter(), o = e.getTerminal(t);
    if (o == null)
      return i;
    const a = o.port;
    if (!a || !this.hasPort(a))
      return i;
    const s = this.getPort(a);
    if (!s || !s.group)
      return i;
    const u = this.getPortsPosition(s.group)[a].position, c = G.create(u).translate(r.getOrigin()), h = this.getAngle();
    return h && c.rotate(-h, i), c;
  }
  /**
   * Sets cell's size and position based on the children bbox and given padding.
   */
  fit(e = {}) {
    const r = (this.getChildren() || []).filter((u) => u.isNode());
    if (r.length === 0)
      return this;
    this.startBatch("fit-embeds", e), e.deep && r.forEach((u) => u.fit(e));
    let { x: i, y: o, width: a, height: s } = Qt.getCellsBBox(r);
    const l = Jf(e.padding);
    return i -= l.left, o -= l.top, a += l.left + l.right, s += l.bottom + l.top, this.store.set({
      position: { x: i, y: o },
      size: { width: a, height: s }
    }, e), this.stopBatch("fit-embeds"), this;
  }
  // #endregion
  // #region ports
  get portContainerMarkup() {
    return this.getPortContainerMarkup();
  }
  set portContainerMarkup(e) {
    this.setPortContainerMarkup(e);
  }
  getDefaultPortContainerMarkup() {
    return this.store.get("defaultPortContainerMarkup") || Mn.getPortContainerMarkup();
  }
  getPortContainerMarkup() {
    return this.store.get("portContainerMarkup") || this.getDefaultPortContainerMarkup();
  }
  setPortContainerMarkup(e, t = {}) {
    return this.store.set("portContainerMarkup", Mn.clone(e), t), this;
  }
  get portMarkup() {
    return this.getPortMarkup();
  }
  set portMarkup(e) {
    this.setPortMarkup(e);
  }
  getDefaultPortMarkup() {
    return this.store.get("defaultPortMarkup") || Mn.getPortMarkup();
  }
  getPortMarkup() {
    return this.store.get("portMarkup") || this.getDefaultPortMarkup();
  }
  setPortMarkup(e, t = {}) {
    return this.store.set("portMarkup", Mn.clone(e), t), this;
  }
  get portLabelMarkup() {
    return this.getPortLabelMarkup();
  }
  set portLabelMarkup(e) {
    this.setPortLabelMarkup(e);
  }
  getDefaultPortLabelMarkup() {
    return this.store.get("defaultPortLabelMarkup") || Mn.getPortLabelMarkup();
  }
  getPortLabelMarkup() {
    return this.store.get("portLabelMarkup") || this.getDefaultPortLabelMarkup();
  }
  setPortLabelMarkup(e, t = {}) {
    return this.store.set("portLabelMarkup", Mn.clone(e), t), this;
  }
  get ports() {
    const e = this.store.get("ports", { items: [] });
    return e.items == null && (e.items = []), e;
  }
  getPorts() {
    return Sn(this.ports.items);
  }
  getPortsByGroup(e) {
    return this.getPorts().filter((t) => t.group === e);
  }
  getPort(e) {
    return Sn(this.ports.items.find((t) => t.id && t.id === e));
  }
  getPortAt(e) {
    return this.ports.items[e] || null;
  }
  hasPorts() {
    return this.ports.items.length > 0;
  }
  hasPort(e) {
    return this.getPortIndex(e) !== -1;
  }
  getPortIndex(e) {
    const t = typeof e == "string" ? e : e.id;
    return t != null ? this.ports.items.findIndex((r) => r.id === t) : -1;
  }
  getPortsPosition(e) {
    const t = this.getSize();
    return this.port.getPortsLayoutByGroup(e, new Te(0, 0, t.width, t.height)).reduce((i, o) => {
      const a = o.portLayout;
      return i[o.portId] = {
        position: Object.assign({}, a.position),
        angle: a.angle || 0
      }, i;
    }, {});
  }
  getPortProp(e, t) {
    return this.getPropByPath(this.prefixPortPath(e, t));
  }
  setPortProp(e, t, r, i) {
    if (typeof t == "string" || Array.isArray(t)) {
      const s = this.prefixPortPath(e, t), l = r;
      return this.setPropByPath(s, l, i);
    }
    const o = this.prefixPortPath(e), a = t;
    return this.setPropByPath(o, a, r);
  }
  removePortProp(e, t, r) {
    return typeof t == "string" || Array.isArray(t) ? this.removePropByPath(this.prefixPortPath(e, t), r) : this.removePropByPath(this.prefixPortPath(e), t);
  }
  portProp(e, t, r, i) {
    return t == null ? this.getPortProp(e) : typeof t == "string" || Array.isArray(t) ? arguments.length === 2 ? this.getPortProp(e, t) : r == null ? this.removePortProp(e, t, i) : this.setPortProp(e, t, r, i) : this.setPortProp(e, t, r);
  }
  prefixPortPath(e, t) {
    const r = this.getPortIndex(e);
    if (r === -1)
      throw new Error(`Unable to find port with id: "${e}"`);
    return t == null || t === "" ? ["ports", "items", `${r}`] : Array.isArray(t) ? ["ports", "items", `${r}`, ...t] : `ports/items/${r}/${t}`;
  }
  addPort(e, t) {
    const r = [...this.ports.items];
    return r.push(e), this.setPropByPath("ports/items", r, t), this;
  }
  addPorts(e, t) {
    return this.setPropByPath("ports/items", [...this.ports.items, ...e], t), this;
  }
  insertPort(e, t, r) {
    const i = [...this.ports.items];
    return i.splice(e, 0, t), this.setPropByPath("ports/items", i, r), this;
  }
  removePort(e, t = {}) {
    return this.removePortAt(this.getPortIndex(e), t);
  }
  removePortAt(e, t = {}) {
    if (e >= 0) {
      const r = [...this.ports.items];
      r.splice(e, 1), t.rewrite = !0, this.setPropByPath("ports/items", r, t);
    }
    return this;
  }
  removePorts(e, t) {
    let r;
    if (Array.isArray(e)) {
      if (r = t || {}, e.length) {
        r.rewrite = !0;
        const o = [...this.ports.items].filter((a) => !e.some((s) => {
          const l = typeof s == "string" ? s : s.id;
          return a.id === l;
        }));
        this.setPropByPath("ports/items", o, r);
      }
    } else
      r = e || {}, r.rewrite = !0, this.setPropByPath("ports/items", [], r);
    return this;
  }
  getParsedPorts() {
    return this.port.getPorts();
  }
  getParsedGroups() {
    return this.port.groups;
  }
  getPortsLayoutByGroup(e, t) {
    return this.port.getPortsLayoutByGroup(e, t);
  }
  initPorts() {
    this.updatePortData(), this.on("change:ports", () => {
      this.processRemovedPort(), this.updatePortData();
    });
  }
  processRemovedPort() {
    const e = this.ports, t = {};
    e.items.forEach((a) => {
      a.id && (t[a.id] = !0);
    });
    const r = {};
    (this.store.getPrevious("ports") || {
      items: []
    }).items.forEach((a) => {
      a.id && !t[a.id] && (r[a.id] = !0);
    });
    const o = this.model;
    o && !zj(r) && (o.getConnectedEdges(this, { incoming: !0 }).forEach((l) => {
      const u = l.getTargetPortId();
      u && r[u] && l.remove();
    }), o.getConnectedEdges(this, { outgoing: !0 }).forEach((l) => {
      const u = l.getSourcePortId();
      u && r[u] && l.remove();
    }));
  }
  validatePorts() {
    const e = {}, t = [];
    return this.ports.items.forEach((r) => {
      typeof r != "object" && t.push(`Invalid port ${r}.`), r.id == null && (r.id = this.generatePortId()), e[r.id] && t.push("Duplicitied port id."), e[r.id] = !0;
    }), t;
  }
  generatePortId() {
    return gx();
  }
  updatePortData() {
    const e = this.validatePorts();
    if (e.length > 0)
      throw this.store.set("ports", this.store.getPrevious("ports")), new Error(e.join(" "));
    const t = this.port ? this.port.getPorts() : null;
    this.port = new $Pe(this.ports);
    const r = this.port.getPorts(), i = t ? r.filter((a) => t.find((s) => s.id === a.id) ? null : a) : [...r], o = t ? t.filter((a) => r.find((s) => s.id === a.id) ? null : a) : [];
    i.length > 0 && this.notify("ports:added", { added: i, cell: this, node: this }), o.length > 0 && this.notify("ports:removed", { removed: o, cell: this, node: this });
  }
};
gr.defaults = {
  angle: 0,
  position: { x: 0, y: 0 },
  size: { width: 1, height: 1 }
};
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function" && typeof i.size == "function" && typeof i.position == "function";
  }
  n.isNode = e;
})(gr || (gr = {}));
(function(n) {
  n.config({
    propHooks(e) {
      var { ports: t } = e, r = I_(e, ["ports"]);
      return t && (r.ports = Array.isArray(t) ? { items: t } : t), r;
    }
  });
})(gr || (gr = {}));
(function(n) {
  n.registry = pr.create({
    type: "node",
    process(e, t) {
      if (Rg.exist(e, !0))
        throw new Error(`Node with name '${e}' was registered by anthor Edge`);
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let r = n;
      const { inherit: i } = t, o = I_(t, ["inherit"]);
      if (i)
        if (typeof i == "string") {
          const s = this.get(i);
          s == null ? this.onNotFound(i, "inherited") : r = s;
        } else
          r = i;
      o.constructorName == null && (o.constructorName = e);
      const a = r.define.call(r, o);
      return a.config({ shape: e }), a;
    }
  }), Rg.setNodeRegistry(n.registry);
})(gr || (gr = {}));
(function(n) {
  let e = 0;
  function t(o) {
    return o ? rI(o) : (e += 1, `CustomNode${e}`);
  }
  function r(o) {
    const { constructorName: a, overwrite: s } = o, l = I_(o, ["constructorName", "overwrite"]), u = tI(t(a || l.shape), this);
    return u.config(l), l.shape && n.registry.register(l.shape, u, s), u;
  }
  n.define = r;
  function i(o) {
    const a = o.shape || "rect", s = n.registry.get(a);
    return s ? new s(o) : n.registry.onNotFound(a);
  }
  n.create = i;
})(gr || (gr = {}));
var R_ = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
let rr = class D9 extends Qt {
  get [Symbol.toStringTag]() {
    return D9.toStringTag;
  }
  constructor(e = {}) {
    super(e);
  }
  preprocess(e, t) {
    const { source: r, sourceCell: i, sourcePort: o, sourcePoint: a, target: s, targetCell: l, targetPort: u, targetPoint: c } = e, f = R_(e, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]), d = (p) => typeof p == "string" || typeof p == "number";
    if (r != null)
      if (Qt.isCell(r))
        f.source = { cell: r.id };
      else if (d(r))
        f.source = { cell: r };
      else if (G.isPoint(r))
        f.source = r.toJSON();
      else if (Array.isArray(r))
        f.source = { x: r[0], y: r[1] };
      else {
        const p = r.cell;
        Qt.isCell(p) ? f.source = Object.assign(Object.assign({}, r), { cell: p.id }) : f.source = r;
      }
    if (i != null || o != null) {
      let p = f.source;
      if (i != null) {
        const g = d(i) ? i : i.id;
        p ? p.cell = g : p = f.source = { cell: g };
      }
      o != null && p && (p.port = o);
    } else
      a != null && (f.source = G.create(a).toJSON());
    if (s != null)
      if (Qt.isCell(s))
        f.target = { cell: s.id };
      else if (d(s))
        f.target = { cell: s };
      else if (G.isPoint(s))
        f.target = s.toJSON();
      else if (Array.isArray(s))
        f.target = { x: s[0], y: s[1] };
      else {
        const p = s.cell;
        Qt.isCell(p) ? f.target = Object.assign(Object.assign({}, s), { cell: p.id }) : f.target = s;
      }
    if (l != null || u != null) {
      let p = f.target;
      if (l != null) {
        const g = d(l) ? l : l.id;
        p ? p.cell = g : p = f.target = { cell: g };
      }
      u != null && p && (p.port = u);
    } else
      c != null && (f.target = G.create(c).toJSON());
    return super.preprocess(f, t);
  }
  setup() {
    super.setup(), this.on("change:labels", (e) => this.onLabelsChanged(e)), this.on("change:vertices", (e) => this.onVertexsChanged(e));
  }
  isEdge() {
    return !0;
  }
  // #region terminal
  disconnect(e = {}) {
    return this.store.set({
      source: { x: 0, y: 0 },
      target: { x: 0, y: 0 }
    }, e), this;
  }
  get source() {
    return this.getSource();
  }
  set source(e) {
    this.setSource(e);
  }
  getSource() {
    return this.getTerminal("source");
  }
  getSourceCellId() {
    return this.source.cell;
  }
  getSourcePortId() {
    return this.source.port;
  }
  setSource(e, t, r = {}) {
    return this.setTerminal("source", e, t, r);
  }
  get target() {
    return this.getTarget();
  }
  set target(e) {
    this.setTarget(e);
  }
  getTarget() {
    return this.getTerminal("target");
  }
  getTargetCellId() {
    return this.target.cell;
  }
  getTargetPortId() {
    return this.target.port;
  }
  setTarget(e, t, r = {}) {
    return this.setTerminal("target", e, t, r);
  }
  getTerminal(e) {
    return Object.assign({}, this.store.get(e));
  }
  setTerminal(e, t, r, i = {}) {
    if (Qt.isCell(t))
      return this.store.set(e, er({}, r, { cell: t.id }), i), this;
    const o = t;
    return G.isPoint(t) || o.x != null && o.y != null ? (this.store.set(e, er({}, r, { x: o.x, y: o.y }), i), this) : (this.store.set(e, Sn(t), i), this);
  }
  getSourcePoint() {
    return this.getTerminalPoint("source");
  }
  getTargetPoint() {
    return this.getTerminalPoint("target");
  }
  getTerminalPoint(e) {
    const t = this[e];
    if (G.isPointLike(t))
      return G.create(t);
    const r = this.getTerminalCell(e);
    return r ? r.getConnectionPoint(this, e) : new G();
  }
  getSourceCell() {
    return this.getTerminalCell("source");
  }
  getTargetCell() {
    return this.getTerminalCell("target");
  }
  getTerminalCell(e) {
    if (this.model) {
      const t = e === "source" ? this.getSourceCellId() : this.getTargetCellId();
      if (t)
        return this.model.getCell(t);
    }
    return null;
  }
  getSourceNode() {
    return this.getTerminalNode("source");
  }
  getTargetNode() {
    return this.getTerminalNode("target");
  }
  getTerminalNode(e) {
    let t = this;
    const r = {};
    for (; t && t.isEdge(); ) {
      if (r[t.id])
        return null;
      r[t.id] = !0, t = t.getTerminalCell(e);
    }
    return t && t.isNode() ? t : null;
  }
  // #endregion
  // #region router
  get router() {
    return this.getRouter();
  }
  set router(e) {
    e == null ? this.removeRouter() : this.setRouter(e);
  }
  getRouter() {
    return this.store.get("router");
  }
  setRouter(e, t, r) {
    return typeof e == "object" ? this.store.set("router", e, t) : this.store.set("router", { name: e, args: t }, r), this;
  }
  removeRouter(e = {}) {
    return this.store.remove("router", e), this;
  }
  // #endregion
  // #region connector
  get connector() {
    return this.getConnector();
  }
  set connector(e) {
    e == null ? this.removeConnector() : this.setConnector(e);
  }
  getConnector() {
    return this.store.get("connector");
  }
  setConnector(e, t, r) {
    return typeof e == "object" ? this.store.set("connector", e, t) : this.store.set("connector", { name: e, args: t }, r), this;
  }
  removeConnector(e = {}) {
    return this.store.remove("connector", e);
  }
  // #endregion
  // #region labels
  getDefaultLabel() {
    const e = this.constructor, t = this.store.get("defaultLabel") || e.defaultLabel || {};
    return Sn(t);
  }
  get labels() {
    return this.getLabels();
  }
  set labels(e) {
    this.setLabels(e);
  }
  getLabels() {
    return [...this.store.get("labels", [])].map((e) => this.parseLabel(e));
  }
  setLabels(e, t = {}) {
    return this.store.set("labels", Array.isArray(e) ? e : [e], t), this;
  }
  insertLabel(e, t, r = {}) {
    const i = this.getLabels(), o = i.length;
    let a = t != null && Number.isFinite(t) ? t : o;
    return a < 0 && (a = o + a + 1), i.splice(a, 0, this.parseLabel(e)), this.setLabels(i, r);
  }
  appendLabel(e, t = {}) {
    return this.insertLabel(e, -1, t);
  }
  getLabelAt(e) {
    const t = this.getLabels();
    return e != null && Number.isFinite(e) ? this.parseLabel(t[e]) : null;
  }
  setLabelAt(e, t, r = {}) {
    if (e != null && Number.isFinite(e)) {
      const i = this.getLabels();
      i[e] = this.parseLabel(t), this.setLabels(i, r);
    }
    return this;
  }
  removeLabelAt(e, t = {}) {
    const r = this.getLabels(), i = e != null && Number.isFinite(e) ? e : -1, o = r.splice(i, 1);
    return this.setLabels(r, t), o.length ? o[0] : null;
  }
  parseLabel(e) {
    return typeof e == "string" ? this.constructor.parseStringLabel(e) : e;
  }
  onLabelsChanged({ previous: e, current: t }) {
    const r = e && t ? t.filter((o) => e.find((a) => o === a || hr(o, a)) ? null : o) : t ? [...t] : [], i = e && t ? e.filter((o) => t.find((a) => o === a || hr(o, a)) ? null : o) : e ? [...e] : [];
    r.length > 0 && this.notify("labels:added", { added: r, cell: this, edge: this }), i.length > 0 && this.notify("labels:removed", { removed: i, cell: this, edge: this });
  }
  // #endregion
  // #region vertices
  get vertices() {
    return this.getVertices();
  }
  set vertices(e) {
    this.setVertices(e);
  }
  getVertices() {
    return [...this.store.get("vertices", [])];
  }
  setVertices(e, t = {}) {
    const r = Array.isArray(e) ? e : [e];
    return this.store.set("vertices", r.map((i) => G.toJSON(i)), t), this;
  }
  insertVertex(e, t, r = {}) {
    const i = this.getVertices(), o = i.length;
    let a = t != null && Number.isFinite(t) ? t : o;
    return a < 0 && (a = o + a + 1), i.splice(a, 0, G.toJSON(e)), this.setVertices(i, r);
  }
  appendVertex(e, t = {}) {
    return this.insertVertex(e, -1, t);
  }
  getVertexAt(e) {
    return e != null && Number.isFinite(e) ? this.getVertices()[e] : null;
  }
  setVertexAt(e, t, r = {}) {
    if (e != null && Number.isFinite(e)) {
      const i = this.getVertices();
      i[e] = t, this.setVertices(i, r);
    }
    return this;
  }
  removeVertexAt(e, t = {}) {
    const r = this.getVertices(), i = e != null && Number.isFinite(e) ? e : -1;
    return r.splice(i, 1), this.setVertices(r, t);
  }
  onVertexsChanged({ previous: e, current: t }) {
    const r = e && t ? t.filter((o) => e.find((a) => G.equals(o, a)) ? null : o) : t ? [...t] : [], i = e && t ? e.filter((o) => t.find((a) => G.equals(o, a)) ? null : o) : e ? [...e] : [];
    r.length > 0 && this.notify("vertexs:added", { added: r, cell: this, edge: this }), i.length > 0 && this.notify("vertexs:removed", { removed: i, cell: this, edge: this });
  }
  // #endregion
  // #region markup
  getDefaultMarkup() {
    return this.store.get("defaultMarkup") || Mn.getEdgeMarkup();
  }
  getMarkup() {
    return super.getMarkup() || this.getDefaultMarkup();
  }
  // #endregion
  // #region transform
  /**
   * Translate the edge vertices (and source and target if they are points)
   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
   */
  translate(e, t, r = {}) {
    return r.translateBy = r.translateBy || this.id, r.tx = e, r.ty = t, this.applyToPoints((i) => ({
      x: (i.x || 0) + e,
      y: (i.y || 0) + t
    }), r);
  }
  /**
   * Scales the edge's points (vertices) relative to the given origin.
   */
  scale(e, t, r, i = {}) {
    return this.applyToPoints((o) => G.create(o).scale(e, t, r).toJSON(), i);
  }
  applyToPoints(e, t = {}) {
    const r = {}, i = this.getSource(), o = this.getTarget();
    G.isPointLike(i) && (r.source = e(i)), G.isPointLike(o) && (r.target = e(o));
    const a = this.getVertices();
    return a.length > 0 && (r.vertices = a.map(e)), this.store.set(r, t), this;
  }
  // #endregion
  // #region common
  getBBox() {
    return this.getPolyline().bbox();
  }
  getConnectionPoint() {
    return this.getPolyline().pointAt(0.5);
  }
  getPolyline() {
    const e = [
      this.getSourcePoint(),
      ...this.getVertices().map((t) => G.create(t)),
      this.getTargetPoint()
    ];
    return new Ii(e);
  }
  updateParent(e) {
    let t = null;
    const r = this.getSourceCell(), i = this.getTargetCell(), o = this.getParent();
    return r && i && (r === i || r.isDescendantOf(i) ? t = i : i.isDescendantOf(r) ? t = r : t = Qt.getCommonAncestor(r, i)), o && t && t.id !== o.id && o.unembed(this, e), t && (!o || o.id !== t.id) && t.embed(this, e), t;
  }
  hasLoop(e = {}) {
    const t = this.getSource(), r = this.getTarget(), i = t.cell, o = r.cell;
    if (!i || !o)
      return !1;
    let a = i === o;
    if (!a && e.deep && this._model) {
      const s = this.getSourceCell(), l = this.getTargetCell();
      s && l && (a = s.isAncestorOf(l, e) || l.isAncestorOf(s, e));
    }
    return a;
  }
  getFragmentAncestor() {
    const e = [this, this.getSourceNode(), this.getTargetNode()].filter((t) => t != null);
    return this.getCommonAncestor(...e);
  }
  isFragmentDescendantOf(e) {
    const t = this.getFragmentAncestor();
    return !!t && (t.id === e.id || t.isDescendantOf(e));
  }
};
rr.defaults = {};
(function(n) {
  function e(t, r) {
    const i = t, o = r;
    return i.cell === o.cell ? i.port === o.port || i.port == null && o.port == null : !1;
  }
  n.equalTerminals = e;
})(rr || (rr = {}));
(function(n) {
  n.defaultLabel = {
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      text: {
        fill: "#000",
        fontSize: 14,
        textAnchor: "middle",
        textVerticalAnchor: "middle",
        pointerEvents: "none"
      },
      rect: {
        ref: "label",
        fill: "#fff",
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };
  function e(t) {
    return {
      attrs: { label: { text: t } }
    };
  }
  n.parseStringLabel = e;
})(rr || (rr = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function" && typeof i.disconnect == "function" && typeof i.getSource == "function" && typeof i.getTarget == "function";
  }
  n.isEdge = e;
})(rr || (rr = {}));
(function(n) {
  n.registry = pr.create({
    type: "edge",
    process(e, t) {
      if (Rg.exist(e, !1))
        throw new Error(`Edge with name '${e}' was registered by anthor Node`);
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let r = n;
      const { inherit: i = "edge" } = t, o = R_(t, ["inherit"]);
      if (typeof i == "string") {
        const s = this.get(i || "edge");
        s == null && i ? this.onNotFound(i, "inherited") : r = s;
      } else
        r = i;
      o.constructorName == null && (o.constructorName = e);
      const a = r.define.call(r, o);
      return a.config({ shape: e }), a;
    }
  }), Rg.setEdgeRegistry(n.registry);
})(rr || (rr = {}));
(function(n) {
  let e = 0;
  function t(o) {
    return o ? rI(o) : (e += 1, `CustomEdge${e}`);
  }
  function r(o) {
    const { constructorName: a, overwrite: s } = o, l = R_(o, ["constructorName", "overwrite"]), u = tI(t(a || l.shape), this);
    return u.config(l), l.shape && n.registry.register(l.shape, u, s), u;
  }
  n.define = r;
  function i(o) {
    const a = o.shape || "edge", s = n.registry.get(a);
    return s ? new s(o) : n.registry.onNotFound(a);
  }
  n.create = i;
})(rr || (rr = {}));
(function(n) {
  const e = "basic.edge";
  n.config({
    shape: e,
    propHooks(t) {
      const { label: r, vertices: i } = t, o = R_(t, ["label", "vertices"]);
      if (r) {
        o.labels == null && (o.labels = []);
        const a = typeof r == "string" ? n.parseStringLabel(r) : r;
        o.labels.push(a);
      }
      return i && Array.isArray(i) && (o.vertices = i.map((a) => G.create(a).toJSON())), o;
    }
  }), n.registry.register(e, n);
})(rr || (rr = {}));
var BPe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class kx extends Yn {
  constructor(e, t = {}) {
    super(), this.length = 0, this.comparator = t.comparator || "zIndex", this.clean(), e && this.reset(e, { silent: !0 });
  }
  toJSON() {
    return this.cells.map((e) => e.toJSON());
  }
  add(e, t, r) {
    let i, o;
    typeof t == "number" ? (i = t, o = Object.assign({ merge: !1 }, r)) : (i = this.length, o = Object.assign({ merge: !1 }, t)), i > this.length && (i = this.length), i < 0 && (i += this.length + 1);
    const a = Array.isArray(e) ? e : [e], s = this.comparator && typeof t != "number" && o.sort !== !1, l = this.comparator || null;
    let u = !1;
    const c = [], h = [];
    return a.forEach((f) => {
      const d = this.get(f);
      d ? o.merge && !f.isSameStore(d) && (d.setProp(f.getProp(), r), h.push(d), s && !u && (l == null || typeof l == "function" ? u = d.hasChanged() : typeof l == "string" ? u = d.hasChanged(l) : u = l.some((p) => d.hasChanged(p)))) : (c.push(f), this.reference(f));
    }), c.length && (s && (u = !0), this.cells.splice(i, 0, ...c), this.length = this.cells.length), u && this.sort({ silent: !0 }), o.silent || (c.forEach((f, d) => {
      const p = {
        cell: f,
        index: i + d,
        options: o
      };
      this.trigger("added", p), o.dryrun || f.notify("added", Object.assign({}, p));
    }), u && this.trigger("sorted"), (c.length || h.length) && this.trigger("updated", {
      added: c,
      merged: h,
      removed: [],
      options: o
    })), this;
  }
  remove(e, t = {}) {
    const r = Array.isArray(e) ? e : [e], i = this.removeCells(r, t);
    return !t.silent && i.length > 0 && this.trigger("updated", {
      options: t,
      removed: i,
      added: [],
      merged: []
    }), Array.isArray(e) ? i : i[0];
  }
  removeCells(e, t) {
    const r = [];
    for (let i = 0; i < e.length; i += 1) {
      const o = this.get(e[i]);
      if (o == null)
        continue;
      const a = this.cells.indexOf(o);
      this.cells.splice(a, 1), this.length -= 1, delete this.map[o.id], r.push(o), this.unreference(o), t.dryrun || o.remove(), t.silent || (this.trigger("removed", { cell: o, index: a, options: t }), t.dryrun || o.notify("removed", { cell: o, index: a, options: t }));
    }
    return r;
  }
  reset(e, t = {}) {
    const r = this.cells.slice();
    if (r.forEach((i) => this.unreference(i)), this.clean(), this.add(e, Object.assign({ silent: !0 }, t)), !t.silent) {
      const i = this.cells.slice();
      this.trigger("reseted", {
        options: t,
        previous: r,
        current: i
      });
      const o = [], a = [];
      i.forEach((s) => {
        r.some((u) => u.id === s.id) || o.push(s);
      }), r.forEach((s) => {
        i.some((u) => u.id === s.id) || a.push(s);
      }), this.trigger("updated", { options: t, added: o, removed: a, merged: [] });
    }
    return this;
  }
  push(e, t) {
    return this.add(e, this.length, t);
  }
  pop(e) {
    const t = this.at(this.length - 1);
    return this.remove(t, e);
  }
  unshift(e, t) {
    return this.add(e, 0, t);
  }
  shift(e) {
    const t = this.at(0);
    return this.remove(t, e);
  }
  get(e) {
    if (e == null)
      return null;
    const t = typeof e == "string" || typeof e == "number" ? e : e.id;
    return this.map[t] || null;
  }
  has(e) {
    return this.get(e) != null;
  }
  at(e) {
    return e < 0 && (e += this.length), this.cells[e] || null;
  }
  first() {
    return this.at(0);
  }
  last() {
    return this.at(-1);
  }
  indexOf(e) {
    return this.cells.indexOf(e);
  }
  toArray() {
    return this.cells.slice();
  }
  sort(e = {}) {
    return this.comparator != null && (this.cells = Gj(this.cells, this.comparator), e.silent || this.trigger("sorted")), this;
  }
  clone() {
    const e = this.constructor;
    return new e(this.cells.slice(), {
      comparator: this.comparator
    });
  }
  reference(e) {
    this.map[e.id] = e, e.on("*", this.notifyCellEvent, this);
  }
  unreference(e) {
    e.off("*", this.notifyCellEvent, this), delete this.map[e.id];
  }
  notifyCellEvent(e, t) {
    const r = t.cell;
    this.trigger(`cell:${e}`, t), r && (r.isNode() ? this.trigger(`node:${e}`, Object.assign(Object.assign({}, t), { node: r })) : r.isEdge() && this.trigger(`edge:${e}`, Object.assign(Object.assign({}, t), { edge: r })));
  }
  clean() {
    this.length = 0, this.cells = [], this.map = {};
  }
  dispose() {
    this.reset([]);
  }
}
BPe([
  kx.dispose()
], kx.prototype, "dispose", null);
var VPe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
let Ol = class Ow extends Yn {
  get [Symbol.toStringTag]() {
    return Ow.toStringTag;
  }
  constructor(e = []) {
    super(), this.batches = {}, this.addings = /* @__PURE__ */ new WeakMap(), this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, this.collection = new kx(e), this.setup();
  }
  notify(e, t) {
    this.trigger(e, t);
    const r = this.graph;
    return r && (e === "sorted" || e === "reseted" || e === "updated" ? r.trigger(`model:${e}`, t) : r.trigger(e, t)), this;
  }
  setup() {
    const e = this.collection;
    e.on("sorted", () => this.notify("sorted", null)), e.on("updated", (t) => this.notify("updated", t)), e.on("cell:change:zIndex", () => this.sortOnChangeZ()), e.on("added", ({ cell: t }) => {
      this.onCellAdded(t);
    }), e.on("removed", (t) => {
      const r = t.cell;
      this.onCellRemoved(r, t.options), this.notify("cell:removed", t), r.isNode() ? this.notify("node:removed", Object.assign(Object.assign({}, t), { node: r })) : r.isEdge() && this.notify("edge:removed", Object.assign(Object.assign({}, t), { edge: r }));
    }), e.on("reseted", (t) => {
      this.onReset(t.current), this.notify("reseted", t);
    }), e.on("edge:change:source", ({ edge: t }) => this.onEdgeTerminalChanged(t, "source")), e.on("edge:change:target", ({ edge: t }) => {
      this.onEdgeTerminalChanged(t, "target");
    });
  }
  sortOnChangeZ() {
    this.collection.sort();
  }
  onCellAdded(e) {
    const t = e.id;
    e.isEdge() ? (e.updateParent(), this.edges[t] = !0, this.onEdgeTerminalChanged(e, "source"), this.onEdgeTerminalChanged(e, "target")) : this.nodes[t] = !0;
  }
  onCellRemoved(e, t) {
    const r = e.id;
    if (e.isEdge()) {
      delete this.edges[r];
      const i = e.getSource(), o = e.getTarget();
      if (i && i.cell) {
        const a = this.outgoings[i.cell], s = a ? a.indexOf(r) : -1;
        s >= 0 && (a.splice(s, 1), a.length === 0 && delete this.outgoings[i.cell]);
      }
      if (o && o.cell) {
        const a = this.incomings[o.cell], s = a ? a.indexOf(r) : -1;
        s >= 0 && (a.splice(s, 1), a.length === 0 && delete this.incomings[o.cell]);
      }
    } else
      delete this.nodes[r];
    t.clear || (t.disconnectEdges ? this.disconnectConnectedEdges(e, t) : this.removeConnectedEdges(e, t)), e.model === this && (e.model = null);
  }
  onReset(e) {
    this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, e.forEach((t) => this.onCellAdded(t));
  }
  onEdgeTerminalChanged(e, t) {
    const r = t === "source" ? this.outgoings : this.incomings, i = e.previous(t);
    if (i && i.cell) {
      const a = Qt.isCell(i.cell) ? i.cell.id : i.cell, s = r[a], l = s ? s.indexOf(e.id) : -1;
      l >= 0 && (s.splice(l, 1), s.length === 0 && delete r[a]);
    }
    const o = e.getTerminal(t);
    if (o && o.cell) {
      const a = Qt.isCell(o.cell) ? o.cell.id : o.cell, s = r[a] || [];
      s.indexOf(e.id) === -1 && s.push(e.id), r[a] = s;
    }
  }
  prepareCell(e, t) {
    return !e.model && (!t || !t.dryrun) && (e.model = this), e.zIndex == null && e.setZIndex(this.getMaxZIndex() + 1, { silent: !0 }), e;
  }
  resetCells(e, t = {}) {
    return e.map((r) => this.prepareCell(r, Object.assign(Object.assign({}, t), { dryrun: !0 }))), this.collection.reset(e, t), e.map((r) => this.prepareCell(r, { options: t })), this;
  }
  clear(e = {}) {
    const t = this.getCells();
    if (t.length === 0)
      return this;
    const r = Object.assign(Object.assign({}, e), { clear: !0 });
    return this.batchUpdate("clear", () => {
      const i = t.sort((o, a) => {
        const s = o.isEdge() ? 1 : 2, l = a.isEdge() ? 1 : 2;
        return s - l;
      });
      for (; i.length > 0; ) {
        const o = i.shift();
        o && o.remove(r);
      }
    }, r), this;
  }
  addNode(e, t = {}) {
    const r = gr.isNode(e) ? e : this.createNode(e);
    return this.addCell(r, t), r;
  }
  updateNode(e, t = {}) {
    const r = this.createNode(e), i = r.getProp();
    return r.dispose(), this.updateCell(i, t);
  }
  createNode(e) {
    return gr.create(e);
  }
  addEdge(e, t = {}) {
    const r = rr.isEdge(e) ? e : this.createEdge(e);
    return this.addCell(r, t), r;
  }
  createEdge(e) {
    return rr.create(e);
  }
  updateEdge(e, t = {}) {
    const r = this.createEdge(e), i = r.getProp();
    return r.dispose(), this.updateCell(i, t);
  }
  addCell(e, t = {}) {
    return Array.isArray(e) ? this.addCells(e, t) : (!this.collection.has(e) && !this.addings.has(e) && (this.addings.set(e, !0), this.collection.add(this.prepareCell(e, t), t), e.eachChild((r) => this.addCell(r, t)), this.addings.delete(e)), this);
  }
  addCells(e, t = {}) {
    const r = e.length;
    if (r === 0)
      return this;
    const i = Object.assign(Object.assign({}, t), { position: r - 1, maxPosition: r - 1 });
    return this.startBatch("add", Object.assign(Object.assign({}, i), { cells: e })), e.forEach((o) => {
      this.addCell(o, i), i.position -= 1;
    }), this.stopBatch("add", Object.assign(Object.assign({}, i), { cells: e })), this;
  }
  updateCell(e, t = {}) {
    const r = e.id && this.getCell(e.id);
    return r ? this.batchUpdate("update", () => (Object.entries(e).forEach(([i, o]) => r.setProp(i, o, t)), !0), e) : !1;
  }
  removeCell(e, t = {}) {
    const r = typeof e == "string" ? this.getCell(e) : e;
    return r && this.has(r) ? this.collection.remove(r, t) : null;
  }
  updateCellId(e, t) {
    if (e.id === t)
      return;
    this.startBatch("update", { id: t }), e.prop("id", t);
    const r = e.clone({ keepId: !0 });
    return this.addCell(r), this.getConnectedEdges(e).forEach((o) => {
      const a = o.getSourceCell(), s = o.getTargetCell();
      a === e && o.setSource(Object.assign(Object.assign({}, o.getSource()), { cell: t })), s === e && o.setTarget(Object.assign(Object.assign({}, o.getTarget()), { cell: t }));
    }), this.removeCell(e), this.stopBatch("update", { id: t }), r;
  }
  removeCells(e, t = {}) {
    return e.length ? this.batchUpdate("remove", () => e.map((r) => this.removeCell(r, t))) : [];
  }
  removeConnectedEdges(e, t = {}) {
    const r = this.getConnectedEdges(e);
    return r.forEach((i) => {
      i.remove(t);
    }), r;
  }
  disconnectConnectedEdges(e, t = {}) {
    const r = typeof e == "string" ? e : e.id;
    this.getConnectedEdges(e).forEach((i) => {
      const o = i.getSourceCellId(), a = i.getTargetCellId();
      o === r && i.setSource({ x: 0, y: 0 }, t), a === r && i.setTarget({ x: 0, y: 0 }, t);
    });
  }
  has(e) {
    return this.collection.has(e);
  }
  total() {
    return this.collection.length;
  }
  indexOf(e) {
    return this.collection.indexOf(e);
  }
  /**
   * Returns a cell from the graph by its id.
   */
  getCell(e) {
    return this.collection.get(e);
  }
  /**
   * Returns all the nodes and edges in the graph.
   */
  getCells() {
    return this.collection.toArray();
  }
  /**
   * Returns the first cell (node or edge) in the graph. The first cell is
   * defined as the cell with the lowest `zIndex`.
   */
  getFirstCell() {
    return this.collection.first();
  }
  /**
   * Returns the last cell (node or edge) in the graph. The last cell is
   * defined as the cell with the highest `zIndex`.
   */
  getLastCell() {
    return this.collection.last();
  }
  /**
   * Returns the lowest `zIndex` value in the graph.
   */
  getMinZIndex() {
    const e = this.collection.first();
    return e && e.getZIndex() || 0;
  }
  /**
   * Returns the highest `zIndex` value in the graph.
   */
  getMaxZIndex() {
    const e = this.collection.last();
    return e && e.getZIndex() || 0;
  }
  getCellsFromCache(e) {
    return e ? Object.keys(e).map((t) => this.getCell(t)).filter((t) => t != null) : [];
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.getCellsFromCache(this.nodes);
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.getCellsFromCache(this.edges);
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    const t = typeof e == "string" ? e : e.id, r = this.outgoings[t];
    return r ? r.map((i) => this.getCell(i)).filter((i) => i && i.isEdge()) : null;
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    const t = typeof e == "string" ? e : e.id, r = this.incomings[t];
    return r ? r.map((i) => this.getCell(i)).filter((i) => i && i.isEdge()) : null;
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    const r = [], i = typeof e == "string" ? this.getCell(e) : e;
    if (i == null)
      return r;
    const o = {}, a = t.indirect;
    let s = t.incoming, l = t.outgoing;
    s == null && l == null && (s = l = !0);
    const u = (c, h) => {
      const f = h ? this.getOutgoingEdges(c) : this.getIncomingEdges(c);
      if (f != null && f.forEach((d) => {
        o[d.id] || (r.push(d), o[d.id] = !0, a && (s && u(d, !1), l && u(d, !0)));
      }), a && c.isEdge()) {
        const d = h ? c.getTargetCell() : c.getSourceCell();
        d && d.isEdge() && (o[d.id] || (r.push(d), u(d, h)));
      }
    };
    if (l && u(i, !0), s && u(i, !1), t.deep) {
      const c = i.getDescendants({ deep: !0 }), h = {};
      c.forEach((d) => {
        d.isNode() && (h[d.id] = !0);
      });
      const f = (d, p) => {
        const g = p ? this.getOutgoingEdges(d.id) : this.getIncomingEdges(d.id);
        g != null && g.forEach((v) => {
          if (!o[v.id]) {
            const m = v.getSourceCell(), y = v.getTargetCell();
            if (!t.enclosed && m && h[m.id] && y && h[y.id])
              return;
            r.push(v), o[v.id] = !0;
          }
        });
      };
      c.forEach((d) => {
        d.isEdge() || (l && f(d, !0), s && f(d, !1));
      });
    }
    return r;
  }
  isBoundary(e, t) {
    const r = typeof e == "string" ? this.getCell(e) : e, i = t ? this.getIncomingEdges(r) : this.getOutgoingEdges(r);
    return i == null || i.length === 0;
  }
  getBoundaryNodes(e) {
    const t = [];
    return Object.keys(this.nodes).forEach((r) => {
      if (this.isBoundary(r, e)) {
        const i = this.getCell(r);
        i && t.push(i);
      }
    }), t;
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRoots() {
    return this.getBoundaryNodes(!0);
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafs() {
    return this.getBoundaryNodes(!1);
  }
  /**
   * Returns `true` if the node is a root node, i.e. there is no edges
   * coming to the node.
   */
  isRoot(e) {
    return this.isBoundary(e, !0);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e. there is no edges
   * going out from the node.
   */
  isLeaf(e) {
    return this.isBoundary(e, !1);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    let r = t.incoming, i = t.outgoing;
    r == null && i == null && (r = i = !0);
    const a = this.getConnectedEdges(e, t).reduce((s, l) => {
      const u = l.hasLoop(t), c = l.getSourceCell(), h = l.getTargetCell();
      return r && c && c.isNode() && !s[c.id] && (u || c !== e && (!t.deep || !c.isDescendantOf(e))) && (s[c.id] = c), i && h && h.isNode() && !s[h.id] && (u || h !== e && (!t.deep || !h.isDescendantOf(e))) && (s[h.id] = h), s;
    }, {});
    if (e.isEdge()) {
      if (r) {
        const s = e.getSourceCell();
        s && s.isNode() && !a[s.id] && (a[s.id] = s);
      }
      if (i) {
        const s = e.getTargetCell();
        s && s.isNode() && !a[s.id] && (a[s.id] = s);
      }
    }
    return Object.keys(a).map((s) => a[s]);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, r = {}) {
    let i = r.incoming, o = r.outgoing;
    return i == null && o == null && (i = o = !0), this.getConnectedEdges(e, r).some((a) => {
      const s = a.getSourceCell(), l = a.getTargetCell();
      return !!(i && s && s.id === t.id || o && l && l.id === t.id);
    });
  }
  getSuccessors(e, t = {}) {
    const r = [];
    return this.search(e, (i, o) => {
      i !== e && this.matchDistance(o, t.distance) && r.push(i);
    }, Object.assign(Object.assign({}, t), { outgoing: !0 })), r;
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, r = {}) {
    let i = !1;
    return this.search(e, (o, a) => {
      if (o === t && o !== e && this.matchDistance(a, r.distance))
        return i = !0, !1;
    }, Object.assign(Object.assign({}, r), { outgoing: !0 })), i;
  }
  getPredecessors(e, t = {}) {
    const r = [];
    return this.search(e, (i, o) => {
      i !== e && this.matchDistance(o, t.distance) && r.push(i);
    }, Object.assign(Object.assign({}, t), { incoming: !0 })), r;
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, r = {}) {
    let i = !1;
    return this.search(e, (o, a) => {
      if (o === t && o !== e && this.matchDistance(a, r.distance))
        return i = !0, !1;
    }, Object.assign(Object.assign({}, r), { incoming: !0 })), i;
  }
  matchDistance(e, t) {
    return t == null ? !0 : typeof t == "function" ? t(e) : Array.isArray(t) && t.includes(e) ? !0 : e === t;
  }
  /**
   * Returns the common ancestor of the passed cells.
   */
  getCommonAncestor(...e) {
    const t = [];
    return e.forEach((r) => {
      r && (Array.isArray(r) ? t.push(...r) : t.push(r));
    }), Qt.getCommonAncestor(...t);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    const r = [], i = {}, o = [], a = [], s = (l) => {
      i[l.id] || (r.push(l), i[l.id] = l, l.isEdge() && a.push(l), l.isNode() && o.push(l));
    };
    return e.forEach((l) => {
      s(l), t.deep && l.getDescendants({ deep: !0 }).forEach((c) => s(c));
    }), a.forEach((l) => {
      const u = l.getSourceCell(), c = l.getTargetCell();
      u && !i[u.id] && (r.push(u), i[u.id] = u, u.isNode() && o.push(u)), c && !i[c.id] && (r.push(c), i[c.id] = c, c.isNode() && o.push(c));
    }), o.forEach((l) => {
      this.getConnectedEdges(l, t).forEach((c) => {
        const h = c.getSourceCell(), f = c.getTargetCell();
        !i[c.id] && h && i[h.id] && f && i[f.id] && (r.push(c), i[c.id] = c);
      });
    }), r;
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    const r = this.getSubGraph(e, t);
    return this.cloneCells(r);
  }
  cloneCells(e) {
    return Qt.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    const r = typeof e == "number" ? { x: e, y: t || 0 } : e;
    return this.getNodes().filter((i) => i.getBBox().containsPoint(r));
  }
  getNodesInArea(e, t, r, i, o) {
    const a = typeof e == "number" ? new Te(e, t, r, i) : Te.create(e), s = typeof e == "number" ? o : t, l = s && s.strict;
    return this.getNodes().filter((u) => {
      const c = u.getBBox();
      return l ? a.containsRect(c) : a.isIntersectWithRect(c);
    });
  }
  getEdgesInArea(e, t, r, i, o) {
    const a = typeof e == "number" ? new Te(e, t, r, i) : Te.create(e), s = typeof e == "number" ? o : t, l = s && s.strict;
    return this.getEdges().filter((u) => {
      const c = u.getBBox();
      return c.width === 0 ? c.inflate(1, 0) : c.height === 0 && c.inflate(0, 1), l ? a.containsRect(c) : a.isIntersectWithRect(c);
    });
  }
  getNodesUnderNode(e, t = {}) {
    const r = e.getBBox();
    return (t.by == null || t.by === "bbox" ? this.getNodesInArea(r) : this.getNodesFromPoint(r[t.by])).filter((o) => e.id !== o.id && !o.isDescendantOf(e));
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.getCellsBBox(this.getCells());
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return Qt.getCellsBBox(e, t);
  }
  // #region search
  search(e, t, r = {}) {
    r.breadthFirst ? this.breadthFirstSearch(e, t, r) : this.depthFirstSearch(e, t, r);
  }
  breadthFirstSearch(e, t, r = {}) {
    const i = [], o = {}, a = {};
    for (i.push(e), a[e.id] = 0; i.length > 0; ) {
      const s = i.shift();
      if (s == null || o[s.id] || (o[s.id] = !0, rt(t, this, s, a[s.id]) === !1))
        continue;
      this.getNeighbors(s, r).forEach((u) => {
        a[u.id] = a[s.id] + 1, i.push(u);
      });
    }
  }
  depthFirstSearch(e, t, r = {}) {
    const i = [], o = {}, a = {};
    for (i.push(e), a[e.id] = 0; i.length > 0; ) {
      const s = i.pop();
      if (s == null || o[s.id] || (o[s.id] = !0, rt(t, this, s, a[s.id]) === !1))
        continue;
      const l = this.getNeighbors(s, r), u = i.length;
      l.forEach((c) => {
        a[c.id] = a[s.id] + 1, i.splice(u, 0, c);
      });
    }
  }
  // #endregion
  // #region shortest path
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, r = {}) {
    const i = {};
    this.getEdges().forEach((u) => {
      const c = u.getSourceCellId(), h = u.getTargetCellId();
      c && h && (i[c] || (i[c] = []), i[h] || (i[h] = []), i[c].push(h), r.directed || i[h].push(c));
    });
    const o = typeof e == "string" ? e : e.id, a = zP.run(i, o, r.weight), s = [];
    let l = typeof t == "string" ? t : t.id;
    for (a[l] && s.push(l); l = a[l]; )
      s.unshift(l);
    return s;
  }
  // #endregion
  // #region transform
  /**
   * Translate all cells in the graph by `tx` and `ty` pixels.
   */
  translate(e, t, r) {
    return this.getCells().filter((i) => !i.hasParent()).forEach((i) => i.translate(e, t, r)), this;
  }
  resize(e, t, r) {
    return this.resizeCells(e, t, this.getCells(), r);
  }
  resizeCells(e, t, r, i = {}) {
    const o = this.getCellsBBox(r);
    if (o) {
      const a = Math.max(e / o.width, 0), s = Math.max(t / o.height, 0), l = o.getOrigin();
      r.forEach((u) => u.scale(a, s, l, i));
    }
    return this;
  }
  // #endregion
  // #region serialize/deserialize
  toJSON(e = {}) {
    return Ow.toJSON(this.getCells(), e);
  }
  parseJSON(e) {
    return Ow.fromJSON(e);
  }
  fromJSON(e, t = {}) {
    const r = this.parseJSON(e);
    return this.resetCells(r, t), this;
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) + 1, this.notify("batch:start", { name: e, data: t }), this;
  }
  stopBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) - 1, this.notify("batch:stop", { name: e, data: t }), this;
  }
  batchUpdate(e, t, r = {}) {
    this.startBatch(e, r);
    const i = t();
    return this.stopBatch(e, r), i;
  }
  hasActiveBatch(e = Object.keys(this.batches)) {
    return (Array.isArray(e) ? e : [e]).some((r) => this.batches[r] > 0);
  }
  // #endregion
  dispose() {
    this.collection.dispose();
  }
};
VPe([
  Ol.dispose()
], Ol.prototype, "dispose", null);
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && typeof i.addNode == "function" && typeof i.addEdge == "function" && i.collection != null;
  }
  n.isModel = e;
})(Ol || (Ol = {}));
(function(n) {
  function e(r, i = {}) {
    return {
      cells: r.map((o) => o.toJSON(i))
    };
  }
  n.toJSON = e;
  function t(r) {
    const i = [];
    return Array.isArray(r) ? i.push(...r) : (r.cells && i.push(...r.cells), r.nodes && r.nodes.forEach((o) => {
      o.shape == null && (o.shape = "rect"), i.push(o);
    }), r.edges && r.edges.forEach((o) => {
      o.shape == null && (o.shape = "edge"), i.push(o);
    })), i.map((o) => {
      const a = o.shape;
      if (a) {
        if (gr.registry.exist(a))
          return gr.create(o);
        if (rr.registry.exist(a))
          return rr.create(o);
      }
      throw new Error("The `shape` should be specified when creating a node/edge instance");
    });
  }
  n.fromJSON = t;
})(Ol || (Ol = {}));
var zPe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
let Bc = class extends gr {
  get label() {
    return this.getLabel();
  }
  set label(e) {
    this.setLabel(e);
  }
  getLabel() {
    return this.getAttrByPath("text/text");
  }
  setLabel(e, t) {
    return e == null ? this.removeLabel() : this.setAttrByPath("text/text", e, t), this;
  }
  removeLabel() {
    return this.removeAttrByPath("text/text"), this;
  }
};
(function(n) {
  n.bodyAttr = {
    fill: "#ffffff",
    stroke: "#333333",
    strokeWidth: 2
  }, n.labelAttr = {
    fontSize: 14,
    fill: "#000000",
    refX: 0.5,
    refY: 0.5,
    textAnchor: "middle",
    textVerticalAnchor: "middle",
    fontFamily: "Arial, helvetica, sans-serif"
  }, n.config({
    attrs: { text: Object.assign({}, n.labelAttr) },
    propHooks(e) {
      const { label: t } = e, r = zPe(e, ["label"]);
      return t && vv(r, "attrs/text/text", t), r;
    },
    visible: !0
  });
})(Bc || (Bc = {}));
var FPe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function QPe(n, e = "body") {
  return [
    {
      tagName: n,
      selector: e
    },
    {
      tagName: "text",
      selector: "label"
    }
  ];
}
function ZPe(n = "xlink:href") {
  return (t) => {
    const { imageUrl: r, imageWidth: i, imageHeight: o } = t, a = FPe(t, ["imageUrl", "imageWidth", "imageHeight"]);
    if (r != null || i != null || o != null) {
      const s = () => {
        if (a.attrs) {
          const l = a.attrs.image;
          r != null && (l[n] = r), i != null && (l.width = i), o != null && (l.height = o), a.attrs.image = l;
        }
      };
      a.attrs ? (a.attrs.image == null && (a.attrs.image = {}), s()) : (a.attrs = {
        image: {}
      }, s());
    }
    return a;
  };
}
function Ov(n, e, t = {}) {
  const r = {
    constructorName: n,
    markup: QPe(n, t.selector),
    attrs: {
      [n]: Object.assign({}, Bc.bodyAttr)
    }
  };
  return (t.parent || Bc).define(er(r, e, { shape: n }));
}
Ov("rect", {
  attrs: {
    body: {
      refWidth: "100%",
      refHeight: "100%"
    }
  }
});
const WPe = rr.define({
  shape: "edge",
  markup: [
    {
      tagName: "path",
      selector: "wrap",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        cursor: "pointer",
        stroke: "transparent",
        strokeLinecap: "round"
      }
    },
    {
      tagName: "path",
      selector: "line",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        pointerEvents: "none"
      }
    }
  ],
  attrs: {
    lines: {
      connection: !0,
      strokeLinejoin: "round"
    },
    wrap: {
      strokeWidth: 10
    },
    line: {
      stroke: "#333",
      strokeWidth: 2,
      targetMarker: "classic"
    }
  }
});
Ov("ellipse", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refRx: "50%",
      refRy: "50%"
    }
  }
});
var GPe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class Ng extends Bc {
  get points() {
    return this.getPoints();
  }
  set points(e) {
    this.setPoints(e);
  }
  getPoints() {
    return this.getAttrByPath("body/refPoints");
  }
  setPoints(e, t) {
    return e == null ? this.removePoints() : this.setAttrByPath("body/refPoints", Ng.pointsToString(e), t), this;
  }
  removePoints() {
    return this.removeAttrByPath("body/refPoints"), this;
  }
}
(function(n) {
  function e(t) {
    return typeof t == "string" ? t : t.map((r) => Array.isArray(r) ? r.join(",") : G.isPointLike(r) ? `${r.x}, ${r.y}` : "").join(" ");
  }
  n.pointsToString = e, n.config({
    propHooks(t) {
      const { points: r } = t, i = GPe(t, ["points"]);
      if (r) {
        const o = e(r);
        o && vv(i, "attrs/body/refPoints", o);
      }
      return i;
    }
  });
})(Ng || (Ng = {}));
Ov("polygon", {}, { parent: Ng });
Ov("polyline", {}, { parent: Ng });
var jPe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
Bc.define({
  shape: "path",
  markup: [
    {
      tagName: "rect",
      selector: "bg"
    },
    {
      tagName: "path",
      selector: "body"
    },
    {
      tagName: "text",
      selector: "label"
    }
  ],
  attrs: {
    bg: {
      refWidth: "100%",
      refHeight: "100%",
      fill: "none",
      stroke: "none",
      pointerEvents: "all"
    },
    body: {
      fill: "none",
      stroke: "#000",
      strokeWidth: 2
    }
  },
  propHooks(n) {
    const { path: e } = n, t = jPe(n, ["path"]);
    return e && vv(t, "attrs/body/refD", e), t;
  }
});
var HPe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
Bc.define({
  shape: "text-block",
  markup: [
    {
      tagName: "rect",
      selector: "body"
    },
    Mc.SUPPORT_FOREIGNOBJECT ? {
      tagName: "foreignObject",
      selector: "foreignObject",
      children: [
        {
          tagName: "div",
          ns: Hr.xhtml,
          selector: "label",
          style: {
            width: "100%",
            height: "100%",
            position: "static",
            backgroundColor: "transparent",
            textAlign: "center",
            margin: 0,
            padding: "0px 5px",
            boxSizing: "border-box",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      ]
    } : {
      tagName: "text",
      selector: "label",
      attrs: {
        textAnchor: "middle"
      }
    }
  ],
  attrs: {
    body: Object.assign(Object.assign({}, Bc.bodyAttr), { refWidth: "100%", refHeight: "100%" }),
    foreignObject: {
      refWidth: "100%",
      refHeight: "100%"
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },
  propHooks(n) {
    const { text: e } = n, t = HPe(n, ["text"]);
    return e && vv(t, "attrs/label/text", e), t;
  },
  attrHooks: {
    text: {
      set(n, { cell: e, view: t, refBBox: r, elem: i, attrs: o }) {
        if (i instanceof HTMLElement)
          i.textContent = n;
        else {
          const a = o.style || {}, s = { text: n, width: -5, height: "100%" }, l = Object.assign({ textVerticalAnchor: "middle" }, a), u = bl.presets.textWrap;
          return rt(u.set, this, s, {
            cell: e,
            view: t,
            elem: i,
            refBBox: r,
            attrs: l
          }), { fill: a.color || null };
        }
      },
      position(n, { refBBox: e, elem: t }) {
        if (t instanceof SVGElement)
          return e.getCenter();
      }
    }
  }
});
Ov("image", {
  attrs: {
    image: {
      refWidth: "100%",
      refHeight: "100%"
    }
  },
  propHooks: ZPe()
}, {
  selector: "image"
});
Ov("circle", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refR: "50%"
    }
  }
});
class Uo extends fr {
  constructor() {
    super(...arguments), this.portsCache = {};
  }
  get [Symbol.toStringTag]() {
    return Uo.toStringTag;
  }
  getContainerClassName() {
    const e = [
      super.getContainerClassName(),
      this.prefixClassName("node")
    ];
    return this.can("nodeMovable") || e.push(this.prefixClassName("node-immovable")), e.join(" ");
  }
  updateClassName(e) {
    const t = e.target;
    if (t.hasAttribute("magnet")) {
      const r = this.prefixClassName("port-unconnectable");
      this.can("magnetConnectable") ? br(t, r) : lt(t, r);
    } else {
      const r = this.prefixClassName("node-immovable");
      this.can("nodeMovable") ? this.removeClass(r) : this.addClass(r);
    }
  }
  isNodeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let r = e;
    return this.hasAction(r, "ports") && (this.removePorts(), this.cleanPortsCache()), this.hasAction(r, "render") ? (this.render(), r = this.removeAction(r, [
      "render",
      "update",
      "resize",
      "translate",
      "rotate",
      "ports",
      "tools"
    ])) : (r = this.handleAction(r, "resize", () => this.resize(), "update"), r = this.handleAction(
      r,
      "update",
      () => this.update(),
      // `update()` will render ports when useCSSSelectors are enabled
      "ports"
    ), r = this.handleAction(r, "translate", () => this.translate()), r = this.handleAction(r, "rotate", () => this.rotate()), r = this.handleAction(r, "ports", () => this.renderPorts()), r = this.handleAction(r, "tools", () => {
      this.getFlag("tools") === e ? this.renderTools() : this.updateTools(t);
    })), r;
  }
  update(e) {
    this.cleanCache(), this.removePorts();
    const t = this.cell, r = t.getSize(), i = t.getAttrs();
    this.updateAttrs(this.container, i, {
      attrs: e === i ? null : e,
      rootBBox: new Te(0, 0, r.width, r.height),
      selectors: this.selectors
    }), this.renderPorts();
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid node markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.appendChild(t.fragment);
  }
  render() {
    return this.empty(), this.renderMarkup(), this.resize(), this.updateTransform(), this.renderTools(), this;
  }
  resize() {
    this.cell.getAngle() && this.rotate(), this.update();
  }
  translate() {
    this.updateTransform();
  }
  rotate() {
    this.updateTransform();
  }
  getTranslationString() {
    const e = this.cell.getPosition();
    return `translate(${e.x},${e.y})`;
  }
  getRotationString() {
    const e = this.cell.getAngle();
    if (e) {
      const t = this.cell.getSize();
      return `rotate(${e},${t.width / 2},${t.height / 2})`;
    }
  }
  updateTransform() {
    let e = this.getTranslationString();
    const t = this.getRotationString();
    t && (e += ` ${t}`), this.container.setAttribute("transform", e);
  }
  // #region ports
  findPortElem(e, t) {
    const r = e ? this.portsCache[e] : null;
    if (!r)
      return null;
    const i = r.portContentElement, o = r.portContentSelectors || {};
    return this.findOne(t, i, o);
  }
  cleanPortsCache() {
    this.portsCache = {};
  }
  removePorts() {
    Object.values(this.portsCache).forEach((e) => {
      cl(e.portElement);
    });
  }
  renderPorts() {
    const e = this.container, t = [];
    e.childNodes.forEach((a) => {
      t.push(a);
    });
    const r = this.cell.getParsedPorts(), i = g3(r, "zIndex"), o = "auto";
    i[o] && i[o].forEach((a) => {
      const s = this.getPortElement(a);
      e.append(s), t.push(s);
    }), Object.keys(i).forEach((a) => {
      if (a !== o) {
        const s = parseInt(a, 10);
        this.appendPorts(i[a], s, t);
      }
    }), this.updatePorts();
  }
  appendPorts(e, t, r) {
    const i = e.map((o) => this.getPortElement(o));
    r[t] || t < 0 ? cI(r[Math.max(t, 0)], i) : sh(this.container, i);
  }
  getPortElement(e) {
    const t = this.portsCache[e.id];
    return t ? t.portElement : this.createPortElement(e);
  }
  createPortElement(e) {
    let t = Mn.renderMarkup(this.cell.getPortContainerMarkup());
    const r = t.elem;
    if (r == null)
      throw new Error("Invalid port container markup.");
    t = Mn.renderMarkup(this.getPortMarkup(e));
    const i = t.elem, o = t.selectors;
    if (i == null)
      throw new Error("Invalid port markup.");
    this.setAttrs({
      port: e.id,
      "port-group": e.group
    }, i);
    let a = "x6-port";
    e.group && (a += ` x6-port-${e.group}`), lt(r, a), lt(r, "x6-port"), lt(i, "x6-port-body"), r.appendChild(i);
    let s = o, l, u;
    if (this.existPortLabel(e)) {
      if (t = Mn.renderMarkup(this.getPortLabelMarkup(e.label)), l = t.elem, u = t.selectors, l == null)
        throw new Error("Invalid port label markup.");
      if (o && u) {
        for (const h in u)
          if (o[h] && h !== this.rootSelector)
            throw new Error("Selectors within port must be unique.");
        s = Object.assign(Object.assign({}, o), u);
      }
      lt(l, "x6-port-label"), r.appendChild(l);
    }
    return this.portsCache[e.id] = {
      portElement: r,
      portSelectors: s,
      portLabelElement: l,
      portLabelSelectors: u,
      portContentElement: i,
      portContentSelectors: o
    }, this.graph.options.onPortRendered && this.graph.options.onPortRendered({
      port: e,
      node: this.cell,
      container: r,
      selectors: s,
      labelContainer: l,
      labelSelectors: u,
      contentContainer: i,
      contentSelectors: o
    }), r;
  }
  updatePorts() {
    const e = this.cell.getParsedGroups(), t = Object.keys(e);
    t.length === 0 ? this.updatePortGroup() : t.forEach((r) => this.updatePortGroup(r));
  }
  updatePortGroup(e) {
    const t = Te.fromSize(this.cell.getSize()), r = this.cell.getPortsLayoutByGroup(e, t);
    for (let i = 0, o = r.length; i < o; i += 1) {
      const a = r[i], s = a.portId, l = this.portsCache[s] || {}, u = a.portLayout;
      if (this.applyPortTransform(l.portElement, u), a.portAttrs != null) {
        const h = {
          selectors: l.portSelectors || {}
        };
        a.portSize && (h.rootBBox = Te.fromSize(a.portSize)), this.updateAttrs(l.portElement, a.portAttrs, h);
      }
      const c = a.labelLayout;
      if (c && l.portLabelElement && (this.applyPortTransform(l.portLabelElement, c, -(u.angle || 0)), c.attrs)) {
        const h = {
          selectors: l.portLabelSelectors || {}
        };
        a.labelSize && (h.rootBBox = Te.fromSize(a.labelSize)), this.updateAttrs(l.portLabelElement, c.attrs, h);
      }
    }
  }
  applyPortTransform(e, t, r = 0) {
    const i = t.angle, o = t.position, a = Xr().rotate(r).translate(o.x || 0, o.y || 0).rotate(i || 0);
    _g(e, a, { absolute: !0 });
  }
  getPortMarkup(e) {
    return e.markup || this.cell.portMarkup;
  }
  getPortLabelMarkup(e) {
    return e.markup || this.cell.portLabelMarkup;
  }
  existPortLabel(e) {
    return e.attrs && e.attrs.text;
  }
  getEventArgs(e, t, r) {
    const i = this, o = i.cell, a = o;
    return t == null || r == null ? { e, view: i, node: o, cell: a } : { e, x: t, y: r, view: i, node: o, cell: a };
  }
  getPortEventArgs(e, t, r) {
    const i = this, o = i.cell, a = o;
    return r ? {
      e,
      x: r.x,
      y: r.y,
      view: i,
      node: o,
      cell: a,
      port: t
    } : { e, view: i, node: o, cell: a, port: t };
  }
  notifyMouseDown(e, t, r) {
    super.onMouseDown(e, t, r), this.notify("node:mousedown", this.getEventArgs(e, t, r));
  }
  notifyMouseMove(e, t, r) {
    super.onMouseMove(e, t, r), this.notify("node:mousemove", this.getEventArgs(e, t, r));
  }
  notifyMouseUp(e, t, r) {
    super.onMouseUp(e, t, r), this.notify("node:mouseup", this.getEventArgs(e, t, r));
  }
  notifyPortEvent(e, t, r) {
    const i = this.findAttr("port", t.target);
    if (i) {
      const o = t.type;
      e === "node:port:mouseenter" ? t.type = "mouseenter" : e === "node:port:mouseleave" && (t.type = "mouseleave"), this.notify(e, this.getPortEventArgs(t, i, r)), t.type = o;
    }
  }
  onClick(e, t, r) {
    super.onClick(e, t, r), this.notify("node:click", this.getEventArgs(e, t, r)), this.notifyPortEvent("node:port:click", e, { x: t, y: r });
  }
  onDblClick(e, t, r) {
    super.onDblClick(e, t, r), this.notify("node:dblclick", this.getEventArgs(e, t, r)), this.notifyPortEvent("node:port:dblclick", e, { x: t, y: r });
  }
  onContextMenu(e, t, r) {
    super.onContextMenu(e, t, r), this.notify("node:contextmenu", this.getEventArgs(e, t, r)), this.notifyPortEvent("node:port:contextmenu", e, { x: t, y: r });
  }
  onMouseDown(e, t, r) {
    this.isPropagationStopped(e) || (this.notifyMouseDown(e, t, r), this.notifyPortEvent("node:port:mousedown", e, { x: t, y: r }), this.startNodeDragging(e, t, r));
  }
  onMouseMove(e, t, r) {
    const i = this.getEventData(e), o = i.action;
    if (o === "magnet")
      this.dragMagnet(e, t, r);
    else {
      if (o === "move") {
        const s = i.targetView || this;
        s.dragNode(e, t, r), s.notify("node:moving", {
          e,
          x: t,
          y: r,
          view: s,
          cell: s.cell,
          node: s.cell
        });
      }
      this.notifyMouseMove(e, t, r), this.notifyPortEvent("node:port:mousemove", e, { x: t, y: r });
    }
    this.setEventData(e, i);
  }
  onMouseUp(e, t, r) {
    const i = this.getEventData(e), o = i.action;
    o === "magnet" ? this.stopMagnetDragging(e, t, r) : (this.notifyMouseUp(e, t, r), this.notifyPortEvent("node:port:mouseup", e, { x: t, y: r }), o === "move" && (i.targetView || this).stopNodeDragging(e, t, r));
    const a = i.targetMagnet;
    a && this.onMagnetClick(e, a, t, r), this.checkMouseleave(e);
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("node:mouseover", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseenter", e), this.notifyPortEvent("node:port:mouseover", e);
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("node:mouseout", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseleave", e), this.notifyPortEvent("node:port:mouseout", e);
  }
  onMouseEnter(e) {
    this.updateClassName(e), super.onMouseEnter(e), this.notify("node:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("node:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, r, i) {
    super.onMouseWheel(e, t, r, i), this.notify("node:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, r)));
  }
  onMagnetClick(e, t, r, i) {
    const o = this.graph;
    o.view.getMouseMovedCount(e) > o.options.clickThreshold || this.notify("node:magnet:click", Object.assign({ magnet: t }, this.getEventArgs(e, r, i)));
  }
  onMagnetDblClick(e, t, r, i) {
    this.notify("node:magnet:dblclick", Object.assign({ magnet: t }, this.getEventArgs(e, r, i)));
  }
  onMagnetContextMenu(e, t, r, i) {
    this.notify("node:magnet:contextmenu", Object.assign({ magnet: t }, this.getEventArgs(e, r, i)));
  }
  onMagnetMouseDown(e, t, r, i) {
    this.startMagnetDragging(e, r, i);
  }
  onCustomEvent(e, t, r, i) {
    this.notify("node:customevent", Object.assign({ name: t }, this.getEventArgs(e, r, i))), super.onCustomEvent(e, t, r, i);
  }
  prepareEmbedding(e) {
    const t = this.graph, i = this.getEventData(e).cell || this.cell, o = t.findViewByCell(i), a = t.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embed", {
      e,
      node: i,
      view: o,
      cell: i,
      x: a.x,
      y: a.y,
      currentParent: i.getParent()
    });
  }
  processEmbedding(e, t) {
    const r = t.cell || this.cell, i = t.graph || this.graph, o = i.options.embedding, a = o.findParent;
    let s = typeof a == "function" ? rt(a, i, {
      view: this,
      node: this.cell
    }).filter((f) => Qt.isCell(f) && this.cell.id !== f.id && !f.isDescendantOf(this.cell)) : i.model.getNodesUnderNode(r, {
      by: a
    });
    if (o.frontOnly && s.length > 0) {
      const f = g3(s, "zIndex"), d = pde(Object.keys(f).map((p) => parseInt(p, 10)));
      d && (s = f[d]);
    }
    s = s.filter((f) => f.visible);
    let l = null;
    const u = t.candidateEmbedView, c = o.validate;
    for (let f = s.length - 1; f >= 0; f -= 1) {
      const d = s[f];
      if (u && u.cell.id === d.id) {
        l = u;
        break;
      } else {
        const p = d.findView(i);
        if (c && rt(c, i, {
          child: this.cell,
          parent: p.cell,
          childView: this,
          parentView: p
        })) {
          l = p;
          break;
        }
      }
    }
    this.clearEmbedding(t), l && l.highlight(null, { type: "embedding" }), t.candidateEmbedView = l;
    const h = i.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embedding", {
      e,
      cell: r,
      node: r,
      view: i.findViewByCell(r),
      x: h.x,
      y: h.y,
      currentParent: r.getParent(),
      candidateParent: l ? l.cell : null
    });
  }
  clearEmbedding(e) {
    const t = e.candidateEmbedView;
    t && (t.unhighlight(null, { type: "embedding" }), e.candidateEmbedView = null);
  }
  finalizeEmbedding(e, t) {
    this.graph.startBatch("embedding");
    const r = t.cell || this.cell, i = t.graph || this.graph, o = i.findViewByCell(r), a = r.getParent(), s = t.candidateEmbedView;
    if (s ? (s.unhighlight(null, { type: "embedding" }), t.candidateEmbedView = null, (a == null || a.id !== s.cell.id) && s.cell.insertChild(r, void 0, { ui: !0 })) : a && a.unembed(r, { ui: !0 }), i.model.getConnectedEdges(r, { deep: !0 }).forEach((l) => {
      l.updateParent({ ui: !0 });
    }), o && s) {
      const l = i.snapToGrid(e.clientX, e.clientY);
      o.notify("node:embedded", {
        e,
        cell: r,
        x: l.x,
        y: l.y,
        node: r,
        view: i.findViewByCell(r),
        previousParent: a,
        currentParent: r.getParent()
      });
    }
    this.graph.stopBatch("embedding");
  }
  getDelegatedView() {
    let e = this.cell, t = this;
    for (; t && !e.isEdge(); ) {
      if (!e.hasParent() || t.can("stopDelegateOnDragging"))
        return t;
      e = e.getParent(), t = this.graph.findViewByCell(e);
    }
    return null;
  }
  validateMagnet(e, t, r) {
    if (t.getAttribute("magnet") !== "passive") {
      const i = this.graph.options.connecting.validateMagnet;
      return i ? rt(i, this.graph, {
        e: r,
        magnet: t,
        view: e,
        cell: e.cell
      }) : !0;
    }
    return !1;
  }
  startMagnetDragging(e, t, r) {
    if (!this.can("magnetConnectable"))
      return;
    e.stopPropagation();
    const i = e.currentTarget, o = this.graph;
    this.setEventData(e, {
      targetMagnet: i
    }), this.validateMagnet(this, i, e) ? (o.options.magnetThreshold <= 0 && this.startConnectting(e, i, t, r), this.setEventData(e, {
      action: "magnet"
    }), this.stopPropagation(e)) : this.onMouseDown(e, t, r), o.view.delegateDragEvents(e, this);
  }
  startConnectting(e, t, r, i) {
    this.graph.model.startBatch("add-edge");
    const o = this.createEdgeFromMagnet(t, r, i);
    o.setEventData(e, o.prepareArrowheadDragging("target", {
      x: r,
      y: i,
      isNewEdge: !0,
      fallbackAction: "remove"
    })), this.setEventData(e, { edgeView: o }), o.notifyMouseDown(e, r, i);
  }
  getDefaultEdge(e, t) {
    let r;
    const i = this.graph.options.connecting.createEdge;
    return i && (r = rt(i, this.graph, {
      sourceMagnet: t,
      sourceView: e,
      sourceCell: e.cell
    })), r;
  }
  createEdgeFromMagnet(e, t, r) {
    const i = this.graph, o = i.model, a = this.getDefaultEdge(this, e);
    return a.setSource(Object.assign(Object.assign({}, a.getSource()), this.getEdgeTerminal(e, t, r, a, "source"))), a.setTarget(Object.assign(Object.assign({}, a.getTarget()), { x: t, y: r })), a.addTo(o, { async: !1, ui: !0 }), a.findView(i);
  }
  dragMagnet(e, t, r) {
    const i = this.getEventData(e), o = i.edgeView;
    if (o)
      o.onMouseMove(e, t, r), this.autoScrollGraph(e.clientX, e.clientY);
    else {
      const a = this.graph, s = a.options.magnetThreshold, l = this.getEventTarget(e), u = i.targetMagnet;
      if (s === "onleave") {
        if (u === l || u.contains(l))
          return;
      } else if (a.view.getMouseMovedCount(e) <= s)
        return;
      this.startConnectting(e, u, t, r);
    }
  }
  stopMagnetDragging(e, t, r) {
    const o = this.eventData(e).edgeView;
    o && (o.onMouseUp(e, t, r), this.graph.model.stopBatch("add-edge"));
  }
  notifyUnhandledMouseDown(e, t, r) {
    this.notify("node:unhandled:mousedown", {
      e,
      x: t,
      y: r,
      view: this,
      cell: this.cell,
      node: this.cell
    });
  }
  notifyNodeMove(e, t, r, i, o) {
    let a = [o];
    const s = this.graph.getPlugin("selection");
    if (s && s.isSelectionMovable()) {
      const l = s.getSelectedCells();
      l.includes(o) && (a = l.filter((u) => u.isNode()));
    }
    a.forEach((l) => {
      this.notify(e, {
        e: t,
        x: r,
        y: i,
        cell: l,
        node: l,
        view: l.findView(this.graph)
      });
    });
  }
  getRestrictArea(e) {
    const t = this.graph.options.translating.restrict, r = typeof t == "function" ? rt(t, this.graph, e) : t;
    return typeof r == "number" ? this.graph.transform.getGraphArea().inflate(r) : r === !0 ? this.graph.transform.getGraphArea() : r || null;
  }
  startNodeDragging(e, t, r) {
    const i = this.getDelegatedView();
    if (i == null || !i.can("nodeMovable"))
      return this.notifyUnhandledMouseDown(e, t, r);
    this.setEventData(e, {
      targetView: i,
      action: "move"
    });
    const o = G.create(i.cell.getPosition());
    i.setEventData(e, {
      moving: !1,
      offset: o.diff(t, r),
      restrict: this.getRestrictArea(i)
    });
  }
  dragNode(e, t, r) {
    const i = this.cell, o = this.graph, a = o.getGridSize(), s = this.getEventData(e), l = s.offset, u = s.restrict;
    s.moving || (s.moving = !0, this.addClass("node-moving"), this.notifyNodeMove("node:move", e, t, r, this.cell)), this.autoScrollGraph(e.clientX, e.clientY);
    const c = rn.snapToGrid(t + l.x, a), h = rn.snapToGrid(r + l.y, a);
    i.setPosition(c, h, {
      restrict: u,
      deep: !0,
      ui: !0
    }), o.options.embedding.enabled && (s.embedding || (this.prepareEmbedding(e), s.embedding = !0), this.processEmbedding(e, s));
  }
  stopNodeDragging(e, t, r) {
    const i = this.getEventData(e);
    i.embedding && this.finalizeEmbedding(e, i), i.moving && (this.removeClass("node-moving"), this.notifyNodeMove("node:moved", e, t, r, this.cell)), i.moving = !1, i.embedding = !1;
  }
  // eslint-disable-next-line
  autoScrollGraph(e, t) {
    const r = this.graph.getPlugin("scroller");
    r && r.autoScroll(e, t);
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function" && typeof i.update == "function" && typeof i.findPortElem == "function" && typeof i.resize == "function" && typeof i.rotate == "function" && typeof i.translate == "function";
  }
  n.isNodeView = e;
})(Uo || (Uo = {}));
Uo.config({
  isSvgElement: !0,
  priority: 0,
  bootstrap: ["render"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    size: ["resize", "ports", "tools"],
    angle: ["rotate", "tools"],
    position: ["translate", "tools"],
    ports: ["ports"],
    tools: ["tools"]
  }
});
Uo.registry.register("node", Uo, !0);
var qPe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class lu extends fr {
  constructor() {
    super(...arguments), this.POINT_ROUNDING = 2, this.labelDestroyFn = {};
  }
  get [Symbol.toStringTag]() {
    return lu.toStringTag;
  }
  getContainerClassName() {
    return [super.getContainerClassName(), this.prefixClassName("edge")].join(" ");
  }
  get sourceBBox() {
    const e = this.sourceView;
    if (!e) {
      const r = this.cell.getSource();
      return new Te(r.x, r.y);
    }
    const t = this.sourceMagnet;
    return e.isEdgeElement(t) ? new Te(this.sourceAnchor.x, this.sourceAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  get targetBBox() {
    const e = this.targetView;
    if (!e) {
      const r = this.cell.getTarget();
      return new Te(r.x, r.y);
    }
    const t = this.targetMagnet;
    return e.isEdgeElement(t) ? new Te(this.targetAnchor.x, this.targetAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  isEdgeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let r = e;
    if (this.hasAction(r, "source")) {
      if (!this.updateTerminalProperties("source"))
        return r;
      r = this.removeAction(r, "source");
    }
    if (this.hasAction(r, "target")) {
      if (!this.updateTerminalProperties("target"))
        return r;
      r = this.removeAction(r, "target");
    }
    return this.hasAction(r, "render") ? (this.render(), r = this.removeAction(r, ["render", "update", "labels", "tools"]), r) : (r = this.handleAction(r, "update", () => this.update(t)), r = this.handleAction(r, "labels", () => this.onLabelsChange(t)), r = this.handleAction(r, "tools", () => this.renderTools()), r);
  }
  // #region render
  render() {
    return this.empty(), this.renderMarkup(), this.labelContainer = null, this.renderLabels(), this.update(), this.renderTools(), this;
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid edge markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.append(t.fragment);
  }
  customizeLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels;
      for (let r = 0, i = t.length; r < i; r += 1) {
        const o = t[r], a = this.labelCache[r], s = this.labelSelectors[r], l = this.graph.options.onEdgeLabelRendered;
        if (l) {
          const u = l({
            edge: e,
            label: o,
            container: a,
            selectors: s
          });
          u && (this.labelDestroyFn[r] = u);
        }
      }
    }
  }
  destroyCustomizeLabels() {
    const e = this.cell.labels;
    if (this.labelCache && this.labelSelectors && this.labelDestroyFn)
      for (let t = 0, r = e.length; t < r; t += 1) {
        const i = this.labelDestroyFn[t], o = this.labelCache[t], a = this.labelSelectors[t];
        i && o && a && i({
          edge: this.cell,
          label: e[t],
          container: o,
          selectors: a
        });
      }
    this.labelDestroyFn = {};
  }
  renderLabels() {
    const e = this.cell, t = e.getLabels(), r = t.length;
    let i = this.labelContainer;
    if (this.labelCache = {}, this.labelSelectors = {}, r <= 0)
      return i && i.parentNode && i.parentNode.removeChild(i), this;
    i ? this.empty(i) : (i = xs("g"), this.addClass(this.prefixClassName("edge-labels"), i), this.labelContainer = i);
    for (let o = 0, a = t.length; o < a; o += 1) {
      const s = t[o], l = this.normalizeLabelMarkup(this.parseLabelMarkup(s.markup));
      let u, c;
      if (l)
        u = l.node, c = l.selectors;
      else {
        const f = e.getDefaultLabel(), d = this.normalizeLabelMarkup(this.parseLabelMarkup(f.markup));
        u = d.node, c = d.selectors;
      }
      u.setAttribute("data-index", `${o}`), i.appendChild(u);
      const h = this.rootSelector;
      if (c[h])
        throw new Error("Ambiguous label root selector.");
      c[h] = u, this.labelCache[o] = u, this.labelSelectors[o] = c;
    }
    return i.parentNode == null && this.container.appendChild(i), this.updateLabels(), this.customizeLabels(), this;
  }
  onLabelsChange(e = {}) {
    this.destroyCustomizeLabels(), this.shouldRerenderLabels(e) ? this.renderLabels() : this.updateLabels(), this.updateLabelPositions();
  }
  shouldRerenderLabels(e = {}) {
    const t = this.cell.previous("labels");
    if (t == null)
      return !0;
    if ("propertyPathArray" in e && "propertyValue" in e) {
      const r = e.propertyPathArray || [], i = r.length;
      if (i > 1) {
        const o = r[1];
        if (t[o]) {
          if (i === 2)
            return typeof e.propertyValue == "object" && o1(e.propertyValue, "markup");
          if (r[2] !== "markup")
            return !1;
        }
      }
    }
    return !0;
  }
  parseLabelMarkup(e) {
    return e ? typeof e == "string" ? this.parseLabelStringMarkup(e) : this.parseJSONMarkup(e) : null;
  }
  parseLabelStringMarkup(e) {
    const t = pt.createVectors(e), r = document.createDocumentFragment();
    for (let i = 0, o = t.length; i < o; i += 1) {
      const a = t[i].node;
      r.appendChild(a);
    }
    return { fragment: r, selectors: {} };
  }
  normalizeLabelMarkup(e) {
    if (e == null)
      return;
    const t = e.fragment;
    if (!(t instanceof DocumentFragment) || !t.hasChildNodes())
      throw new Error("Invalid label markup.");
    let r;
    const i = t.childNodes;
    return i.length > 1 || i[0].nodeName.toUpperCase() !== "G" ? r = pt.create("g").append(t) : r = pt.create(i[0]), r.addClass(this.prefixClassName("edge-label")), {
      node: r.node,
      selectors: e.selectors
    };
  }
  updateLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels, r = this.can("edgeLabelMovable"), i = e.getDefaultLabel();
      for (let o = 0, a = t.length; o < a; o += 1) {
        const s = this.labelCache[o], l = this.labelSelectors[o];
        s.setAttribute("cursor", r ? "move" : "default");
        const u = t[o], c = er({}, i.attrs, u.attrs);
        this.updateAttrs(s, c, {
          selectors: l,
          rootBBox: u.size ? Te.fromSize(u.size) : void 0
        });
      }
    }
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  // #endregion
  // #region updating
  update(e = {}) {
    this.cleanCache(), this.updateConnection(e);
    const t = this.cell.getAttrs(), r = qPe(t, ["text"]);
    return r != null && this.updateAttrs(this.container, r, {
      selectors: this.selectors
    }), this.updateLabelPositions(), this.updateTools(e), this;
  }
  removeRedundantLinearVertices(e = {}) {
    const t = this.cell, r = t.getVertices(), i = [this.sourceAnchor, ...r, this.targetAnchor], o = i.length, a = new Ii(i);
    a.simplify({ threshold: 0.01 });
    const s = a.points.map((u) => u.toJSON()), l = s.length;
    return o === l ? 0 : (t.setVertices(s.slice(1, l - 1), e), o - l);
  }
  getTerminalView(e) {
    switch (e) {
      case "source":
        return this.sourceView || null;
      case "target":
        return this.targetView || null;
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  getTerminalAnchor(e) {
    switch (e) {
      case "source":
        return G.create(this.sourceAnchor);
      case "target":
        return G.create(this.targetAnchor);
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  getTerminalConnectionPoint(e) {
    switch (e) {
      case "source":
        return G.create(this.sourcePoint);
      case "target":
        return G.create(this.targetPoint);
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  getTerminalMagnet(e, t = {}) {
    switch (e) {
      case "source": {
        if (t.raw)
          return this.sourceMagnet;
        const r = this.sourceView;
        return r ? this.sourceMagnet || r.container : null;
      }
      case "target": {
        if (t.raw)
          return this.targetMagnet;
        const r = this.targetView;
        return r ? this.targetMagnet || r.container : null;
      }
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  updateConnection(e = {}) {
    const t = this.cell;
    if (e.translateBy && t.isFragmentDescendantOf(e.translateBy)) {
      const r = e.tx || 0, i = e.ty || 0;
      this.routePoints = new Ii(this.routePoints).translate(r, i).points, this.translateConnectionPoints(r, i), this.path.translate(r, i);
    } else {
      const r = t.getVertices(), i = this.findAnchors(r);
      this.sourceAnchor = i.source, this.targetAnchor = i.target, this.routePoints = this.findRoutePoints(r);
      const o = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
      this.sourcePoint = o.source, this.targetPoint = o.target;
      const a = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
      this.path = this.findPath(this.routePoints, a.source || this.sourcePoint, a.target || this.targetPoint);
    }
    this.cleanCache();
  }
  findAnchors(e) {
    const t = this.cell, r = t.source, i = t.target, o = e[0], a = e[e.length - 1];
    return i.priority && !r.priority ? this.findAnchorsOrdered("target", a, "source", o) : this.findAnchorsOrdered("source", o, "target", a);
  }
  findAnchorsOrdered(e, t, r, i) {
    let o, a;
    const s = this.cell, l = s[e], u = s[r], c = this.getTerminalView(e), h = this.getTerminalView(r), f = this.getTerminalMagnet(e), d = this.getTerminalMagnet(r);
    if (c) {
      let p;
      t ? p = G.create(t) : h ? p = d : p = G.create(u), o = this.getAnchor(l.anchor, c, f, p, e);
    } else
      o = G.create(l);
    if (h) {
      const p = G.create(i || o);
      a = this.getAnchor(u.anchor, h, d, p, r);
    } else
      a = G.isPointLike(u) ? G.create(u) : new G();
    return {
      [e]: o,
      [r]: a
    };
  }
  getAnchor(e, t, r, i, o) {
    const a = t.isEdgeElement(r), s = this.graph.options.connecting;
    let l = typeof e == "string" ? { name: e } : e;
    if (!l) {
      const h = a ? (o === "source" ? s.sourceEdgeAnchor : s.targetEdgeAnchor) || s.edgeAnchor : (o === "source" ? s.sourceAnchor : s.targetAnchor) || s.anchor;
      l = typeof h == "string" ? { name: h } : h;
    }
    if (!l)
      throw new Error("Anchor should be specified.");
    let u;
    const c = l.name;
    if (a) {
      const h = Lg.registry.get(c);
      if (typeof h != "function")
        return Lg.registry.onNotFound(c);
      u = rt(h, this, t, r, i, l.args || {}, o);
    } else {
      const h = Dg.registry.get(c);
      if (typeof h != "function")
        return Dg.registry.onNotFound(c);
      u = rt(h, this, t, r, i, l.args || {}, o);
    }
    return u ? u.round(this.POINT_ROUNDING) : new G();
  }
  findRoutePoints(e = []) {
    const t = this.graph.options.connecting.router || lc.presets.normal, r = this.cell.getRouter() || t;
    let i;
    if (typeof r == "function")
      i = rt(r, this, e, {}, this);
    else {
      const o = typeof r == "string" ? r : r.name, a = typeof r == "string" ? {} : r.args || {}, s = o ? lc.registry.get(o) : lc.presets.normal;
      if (typeof s != "function")
        return lc.registry.onNotFound(o);
      i = rt(s, this, e, a, this);
    }
    return i == null ? e.map((o) => G.create(o)) : i.map((o) => G.create(o));
  }
  findConnectionPoints(e, t, r) {
    const i = this.cell, o = this.graph.options.connecting, a = i.getSource(), s = i.getTarget(), l = this.sourceView, u = this.targetView, c = e[0], h = e[e.length - 1];
    let f;
    if (l && !l.isEdgeElement(this.sourceMagnet)) {
      const p = this.sourceMagnet || l.container, g = c || r, v = new Xe(g, t), m = a.connectionPoint || o.sourceConnectionPoint || o.connectionPoint;
      f = this.getConnectionPoint(m, l, p, v, "source");
    } else
      f = t;
    let d;
    if (u && !u.isEdgeElement(this.targetMagnet)) {
      const p = this.targetMagnet || u.container, g = s.connectionPoint || o.targetConnectionPoint || o.connectionPoint, v = h || t, m = new Xe(v, r);
      d = this.getConnectionPoint(g, u, p, m, "target");
    } else
      d = r;
    return {
      source: f,
      target: d
    };
  }
  getConnectionPoint(e, t, r, i, o) {
    const a = i.end;
    if (e == null)
      return a;
    const s = typeof e == "string" ? e : e.name, l = typeof e == "string" ? {} : e.args, u = Ig.registry.get(s);
    if (typeof u != "function")
      return Ig.registry.onNotFound(s);
    const c = rt(u, this, i, t, r, l || {}, o);
    return c ? c.round(this.POINT_ROUNDING) : a;
  }
  findMarkerPoints(e, t, r) {
    const i = (h) => {
      const f = this.cell.getAttrs(), d = Object.keys(f);
      for (let p = 0, g = d.length; p < g; p += 1) {
        const v = f[d[p]];
        if (v[`${h}Marker`] || v[`${h}-marker`]) {
          const m = v.strokeWidth || v["stroke-width"];
          if (m)
            return parseFloat(m);
          break;
        }
      }
      return null;
    }, o = e[0], a = e[e.length - 1];
    let s, l;
    const u = i("source");
    u && (s = t.clone().move(o || r, -u));
    const c = i("target");
    return c && (l = r.clone().move(a || t, -c)), this.sourceMarkerPoint = s || t.clone(), this.targetMarkerPoint = l || r.clone(), {
      source: s,
      target: l
    };
  }
  findPath(e, t, r) {
    const i = this.cell.getConnector() || this.graph.options.connecting.connector;
    let o, a, s;
    if (typeof i == "string" ? o = i : (o = i.name, a = i.args), o) {
      const u = Nf.registry.get(o);
      if (typeof u != "function")
        return Nf.registry.onNotFound(o);
      s = u;
    } else
      s = Nf.presets.normal;
    const l = rt(s, this, t, r, e, Object.assign(Object.assign({}, a), { raw: !0 }), this);
    return typeof l == "string" ? Bt.parse(l) : l;
  }
  translateConnectionPoints(e, t) {
    this.sourcePoint.translate(e, t), this.targetPoint.translate(e, t), this.sourceAnchor.translate(e, t), this.targetAnchor.translate(e, t), this.sourceMarkerPoint.translate(e, t), this.targetMarkerPoint.translate(e, t);
  }
  updateLabelPositions() {
    if (this.labelContainer == null)
      return this;
    if (!this.path)
      return this;
    const t = this.cell, r = t.getLabels();
    if (r.length === 0)
      return this;
    const i = t.getDefaultLabel(), o = this.normalizeLabelPosition(i.position);
    for (let a = 0, s = r.length; a < s; a += 1) {
      const l = r[a], u = this.labelCache[a];
      if (!u)
        continue;
      const c = this.normalizeLabelPosition(l.position), h = er({}, o, c), f = this.getLabelTransformationMatrix(h);
      u.setAttribute("transform", yv(f));
    }
    return this;
  }
  updateTerminalProperties(e) {
    const t = this.cell, r = this.graph, i = t[e], o = i && i.cell, a = `${e}View`;
    if (!o)
      return this[a] = null, this.updateTerminalMagnet(e), !0;
    const s = r.getCellById(o);
    if (!s)
      throw new Error(`Edge's ${e} node with id "${o}" not exists`);
    const l = s.findView(r);
    return l ? (this[a] = l, this.updateTerminalMagnet(e), !0) : !1;
  }
  updateTerminalMagnet(e) {
    const t = `${e}Magnet`, r = this.getTerminalView(e);
    if (r) {
      let i = r.getMagnetFromEdgeTerminal(this.cell[e]);
      i === r.container && (i = null), this[t] = i;
    } else
      this[t] = null;
  }
  getLabelPositionAngle(e) {
    const t = this.cell.getLabelAt(e);
    return t && t.position && typeof t.position == "object" && t.position.angle || 0;
  }
  getLabelPositionArgs(e) {
    const t = this.cell.getLabelAt(e);
    if (t && t.position && typeof t.position == "object")
      return t.position.options;
  }
  getDefaultLabelPositionArgs() {
    const e = this.cell.getDefaultLabel();
    if (e && e.position && typeof e.position == "object")
      return e.position.options;
  }
  mergeLabelPositionArgs(e, t) {
    return e === null ? null : e === void 0 ? t === null ? null : t : er({}, t, e);
  }
  // #endregion
  getConnection() {
    return this.path != null ? this.path.clone() : null;
  }
  getConnectionPathData() {
    if (this.path == null)
      return "";
    const e = this.cache.pathCache;
    return o1(e, "data") || (e.data = this.path.serialize()), e.data || "";
  }
  getConnectionSubdivisions() {
    if (this.path == null)
      return null;
    const e = this.cache.pathCache;
    return o1(e, "segmentSubdivisions") || (e.segmentSubdivisions = this.path.getSegmentSubdivisions()), e.segmentSubdivisions;
  }
  getConnectionLength() {
    if (this.path == null)
      return 0;
    const e = this.cache.pathCache;
    return o1(e, "length") || (e.length = this.path.length({
      segmentSubdivisions: this.getConnectionSubdivisions()
    })), e.length;
  }
  getPointAtLength(e) {
    return this.path == null ? null : this.path.pointAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getPointAtRatio(e) {
    return this.path == null ? null : (su(e) && (e = parseFloat(e) / 100), this.path.pointAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }));
  }
  getTangentAtLength(e) {
    return this.path == null ? null : this.path.tangentAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtRatio(e) {
    return this.path == null ? null : this.path.tangentAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPoint(e) {
    return this.path == null ? null : this.path.closestPoint(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointLength(e) {
    return this.path == null ? null : this.path.closestPointLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointRatio(e) {
    return this.path == null ? null : this.path.closestPointNormalizedLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getLabelPosition(e, t, r, i) {
    const o = { distance: 0 };
    let a = 0, s;
    typeof r == "number" ? (a = r, s = i) : s = r, s != null && (o.options = s);
    const l = s && s.absoluteOffset, u = !(s && s.absoluteDistance), c = s && s.absoluteDistance && s.reverseDistance, h = this.path, f = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }, d = new G(e, t), p = h.closestPointT(d, f), g = this.getConnectionLength() || 0;
    let v = h.lengthAtT(p, f);
    u && (v = g > 0 ? v / g : 0), c && (v = -1 * (g - v) || 1), o.distance = v;
    let m;
    l || (m = h.tangentAtT(p));
    let y;
    if (m)
      y = m.pointOffset(d);
    else {
      const b = h.pointAtT(p), O = d.diff(b);
      y = { x: O.x, y: O.y };
    }
    return o.offset = y, o.angle = a, o;
  }
  normalizeLabelPosition(e) {
    return typeof e == "number" ? { distance: e } : e;
  }
  getLabelTransformationMatrix(e) {
    const t = this.normalizeLabelPosition(e), r = t.options || {}, i = t.angle || 0, o = t.distance, a = o > 0 && o <= 1;
    let s = 0;
    const l = { x: 0, y: 0 }, u = t.offset;
    u && (typeof u == "number" ? s = u : (u.x != null && (l.x = u.x), u.y != null && (l.y = u.y)));
    const c = l.x !== 0 || l.y !== 0 || s === 0, h = r.keepGradient, f = r.ensureLegibility, d = this.path, p = { segmentSubdivisions: this.getConnectionSubdivisions() }, g = a ? o * this.getConnectionLength() : o, v = d.tangentAtLength(g, p);
    let m, y = i;
    if (v) {
      if (c)
        m = v.start, m.translate(l);
      else {
        const b = v.clone();
        b.rotate(-90, v.start), b.setLength(s), m = b.end;
      }
      h && (y = v.angle() + i, f && (y = Jt.normalize((y + 90) % 180 - 90)));
    } else
      m = d.start, c && m.translate(l);
    return Xr().translate(m.x, m.y).rotate(y);
  }
  getVertexIndex(e, t) {
    const i = this.cell.getVertices(), o = this.getClosestPointLength(new G(e, t));
    let a = 0;
    if (o != null)
      for (const s = i.length; a < s; a += 1) {
        const l = i[a], u = this.getClosestPointLength(l);
        if (u != null && o < u)
          break;
      }
    return a;
  }
  getEventArgs(e, t, r) {
    const i = this, o = i.cell, a = o;
    return t == null || r == null ? { e, view: i, edge: o, cell: a } : { e, x: t, y: r, view: i, edge: o, cell: a };
  }
  notifyUnhandledMouseDown(e, t, r) {
    this.notify("edge:unhandled:mousedown", {
      e,
      x: t,
      y: r,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  notifyMouseDown(e, t, r) {
    super.onMouseDown(e, t, r), this.notify("edge:mousedown", this.getEventArgs(e, t, r));
  }
  notifyMouseMove(e, t, r) {
    super.onMouseMove(e, t, r), this.notify("edge:mousemove", this.getEventArgs(e, t, r));
  }
  notifyMouseUp(e, t, r) {
    super.onMouseUp(e, t, r), this.notify("edge:mouseup", this.getEventArgs(e, t, r));
  }
  onClick(e, t, r) {
    super.onClick(e, t, r), this.notify("edge:click", this.getEventArgs(e, t, r));
  }
  onDblClick(e, t, r) {
    super.onDblClick(e, t, r), this.notify("edge:dblclick", this.getEventArgs(e, t, r));
  }
  onContextMenu(e, t, r) {
    super.onContextMenu(e, t, r), this.notify("edge:contextmenu", this.getEventArgs(e, t, r));
  }
  onMouseDown(e, t, r) {
    this.notifyMouseDown(e, t, r), this.startEdgeDragging(e, t, r);
  }
  onMouseMove(e, t, r) {
    const i = this.getEventData(e);
    switch (i.action) {
      case "drag-label": {
        this.dragLabel(e, t, r);
        break;
      }
      case "drag-arrowhead": {
        this.dragArrowhead(e, t, r);
        break;
      }
      case "drag-edge": {
        this.dragEdge(e, t, r);
        break;
      }
    }
    return this.notifyMouseMove(e, t, r), i;
  }
  onMouseUp(e, t, r) {
    const i = this.getEventData(e);
    switch (i.action) {
      case "drag-label": {
        this.stopLabelDragging(e, t, r);
        break;
      }
      case "drag-arrowhead": {
        this.stopArrowheadDragging(e, t, r);
        break;
      }
      case "drag-edge": {
        this.stopEdgeDragging(e, t, r);
        break;
      }
    }
    return this.notifyMouseUp(e, t, r), this.checkMouseleave(e), i;
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("edge:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("edge:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    super.onMouseEnter(e), this.notify("edge:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("edge:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, r, i) {
    super.onMouseWheel(e, t, r, i), this.notify("edge:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, r)));
  }
  onCustomEvent(e, t, r, i) {
    if (xq(e.target, "edge-tool", this.container)) {
      if (e.stopPropagation(), this.can("useEdgeTools")) {
        if (t === "edge:remove") {
          this.cell.remove({ ui: !0 });
          return;
        }
        this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, r, i)));
      }
      this.notifyMouseDown(e, r, i);
    } else
      this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, r, i))), super.onCustomEvent(e, t, r, i);
  }
  onLabelMouseDown(e, t, r) {
    this.notifyMouseDown(e, t, r), this.startLabelDragging(e, t, r), this.getEventData(e).stopPropagation && e.stopPropagation();
  }
  // #region drag edge
  startEdgeDragging(e, t, r) {
    if (!this.can("edgeMovable")) {
      this.notifyUnhandledMouseDown(e, t, r);
      return;
    }
    this.setEventData(e, {
      x: t,
      y: r,
      moving: !1,
      action: "drag-edge"
    });
  }
  dragEdge(e, t, r) {
    const i = this.getEventData(e);
    i.moving || (i.moving = !0, this.addClass("edge-moving"), this.notify("edge:move", {
      e,
      x: t,
      y: r,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), this.cell.translate(t - i.x, r - i.y, { ui: !0 }), this.setEventData(e, { x: t, y: r }), this.notify("edge:moving", {
      e,
      x: t,
      y: r,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  stopEdgeDragging(e, t, r) {
    const i = this.getEventData(e);
    i.moving && (this.removeClass("edge-moving"), this.notify("edge:moved", {
      e,
      x: t,
      y: r,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), i.moving = !1;
  }
  // #endregion
  // #region drag arrowhead
  prepareArrowheadDragging(e, t) {
    const r = this.getTerminalMagnet(e), i = {
      action: "drag-arrowhead",
      x: t.x,
      y: t.y,
      isNewEdge: t.isNewEdge === !0,
      terminalType: e,
      initialMagnet: r,
      initialTerminal: Xy(this.cell[e]),
      fallbackAction: t.fallbackAction || "revert",
      getValidateConnectionArgs: this.createValidateConnectionArgs(e),
      options: t.options
    };
    return this.beforeArrowheadDragging(i), i;
  }
  createValidateConnectionArgs(e) {
    const t = [];
    t[4] = e, t[5] = this;
    let r, i = 0, o = 0;
    e === "source" ? (i = 2, r = "target") : (o = 2, r = "source");
    const a = this.cell[r], s = a.cell;
    if (s) {
      let l;
      const u = t[i] = this.graph.findViewByCell(s);
      u && (l = u.getMagnetFromEdgeTerminal(a), l === u.container && (l = void 0)), t[i + 1] = l;
    }
    return (l, u) => (t[o] = l, t[o + 1] = l.container === u ? void 0 : u, t);
  }
  beforeArrowheadDragging(e) {
    e.zIndex = this.cell.zIndex, this.cell.toFront();
    const t = this.container.style;
    e.pointerEvents = t.pointerEvents, t.pointerEvents = "none", this.graph.options.connecting.highlight && this.highlightAvailableMagnets(e);
  }
  afterArrowheadDragging(e) {
    e.zIndex != null && (this.cell.setZIndex(e.zIndex, { ui: !0 }), e.zIndex = null);
    const t = this.container;
    t.style.pointerEvents = e.pointerEvents || "", this.graph.options.connecting.highlight && this.unhighlightAvailableMagnets(e);
  }
  validateConnection(e, t, r, i, o, a, s) {
    const l = this.graph.options.connecting, u = l.allowLoop, c = l.allowNode, h = l.allowEdge, f = l.allowPort, d = l.allowMulti, p = l.validateConnection, g = a ? a.cell : null, v = o === "target" ? r : e, m = o === "target" ? i : t;
    let y = !0;
    const b = (O) => {
      const w = o === "source" ? s ? s.port : null : g ? g.getSourcePortId() : null, x = o === "target" ? s ? s.port : null : g ? g.getTargetPortId() : null;
      return rt(O, this.graph, {
        edge: g,
        edgeView: a,
        sourceView: e,
        targetView: r,
        sourcePort: w,
        targetPort: x,
        sourceMagnet: t,
        targetMagnet: i,
        sourceCell: e ? e.cell : null,
        targetCell: r ? r.cell : null,
        type: o
      });
    };
    if (u != null && (typeof u == "boolean" ? !u && e === r && (y = !1) : y = b(u)), y && f != null && (typeof f == "boolean" ? !f && m && (y = !1) : y = b(f)), y && h != null && (typeof h == "boolean" ? !h && lu.isEdgeView(v) && (y = !1) : y = b(h)), y && c != null && m == null && (typeof c == "boolean" ? !c && Uo.isNodeView(v) && (y = !1) : y = b(c)), y && d != null && a) {
      const O = a.cell, w = o === "source" ? s : O.getSource(), x = o === "target" ? s : O.getTarget(), S = s ? this.graph.getCellById(s.cell) : null;
      if (w && x && w.cell && x.cell && S)
        if (typeof d == "function")
          y = b(d);
        else {
          const _ = this.graph.model.getConnectedEdges(S, {
            outgoing: o === "source",
            incoming: o === "target"
          });
          _.length && (d === "withPort" ? _.some((A) => {
            const k = A.getSource(), P = A.getTarget();
            return k && P && k.cell === w.cell && P.cell === x.cell && k.port != null && k.port === w.port && P.port != null && P.port === x.port;
          }) && (y = !1) : d || _.some((A) => {
            const k = A.getSource(), P = A.getTarget();
            return k && P && k.cell === w.cell && P.cell === x.cell;
          }) && (y = !1));
        }
    }
    return y && p != null && (y = b(p)), y;
  }
  allowConnectToBlank(e) {
    const t = this.graph, i = t.options.connecting.allowBlank;
    if (typeof i != "function")
      return !!i;
    const o = t.findViewByCell(e), a = e.getSourceCell(), s = e.getTargetCell(), l = t.findViewByCell(a), u = t.findViewByCell(s);
    return rt(i, t, {
      edge: e,
      edgeView: o,
      sourceCell: a,
      targetCell: s,
      sourceView: l,
      targetView: u,
      sourcePort: e.getSourcePortId(),
      targetPort: e.getTargetPortId(),
      sourceMagnet: o.sourceMagnet,
      targetMagnet: o.targetMagnet
    });
  }
  validateEdge(e, t, r) {
    const i = this.graph;
    if (!this.allowConnectToBlank(e)) {
      const a = e.getSourceCellId(), s = e.getTargetCellId();
      if (!(a && s))
        return !1;
    }
    const o = i.options.connecting.validateEdge;
    return o ? rt(o, i, {
      edge: e,
      type: t,
      previous: r
    }) : !0;
  }
  arrowheadDragging(e, t, r, i) {
    i.x = t, i.y = r, i.currentTarget !== e && (i.currentMagnet && i.currentView && i.currentView.unhighlight(i.currentMagnet, {
      type: "magnetAdsorbed"
    }), i.currentView = this.graph.findViewByElem(e), i.currentView ? (i.currentMagnet = i.currentView.findMagnet(e), i.currentMagnet && this.validateConnection(...i.getValidateConnectionArgs(i.currentView, i.currentMagnet), i.currentView.getEdgeTerminal(i.currentMagnet, t, r, this.cell, i.terminalType)) ? i.currentView.highlight(i.currentMagnet, {
      type: "magnetAdsorbed"
    }) : i.currentMagnet = null) : i.currentMagnet = null), i.currentTarget = e, this.cell.prop(i.terminalType, { x: t, y: r }, Object.assign(Object.assign({}, i.options), { ui: !0 }));
  }
  arrowheadDragged(e, t, r) {
    const i = e.currentView, o = e.currentMagnet;
    if (!o || !i)
      return;
    i.unhighlight(o, { type: "magnetAdsorbed" });
    const a = e.terminalType, s = i.getEdgeTerminal(o, t, r, this.cell, a);
    this.cell.setTerminal(a, s, { ui: !0 });
  }
  snapArrowhead(e, t, r) {
    const i = this.graph, { snap: o, allowEdge: a } = i.options.connecting, s = typeof o == "object" && o.radius || 50, l = typeof o == "object" && o.anchor || "center", u = i.renderer.findViewsInArea({
      x: e - s,
      y: t - s,
      width: 2 * s,
      height: 2 * s
    }, { nodeOnly: !0 });
    if (a) {
      const O = i.renderer.findEdgeViewsFromPoint({ x: e, y: t }, s).filter((w) => w !== this);
      u.push(...O);
    }
    const c = r.closestView || null, h = r.closestMagnet || null;
    r.closestView = null, r.closestMagnet = null;
    let f, d = Number.MAX_SAFE_INTEGER;
    const p = new G(e, t);
    u.forEach((O) => {
      if (O.container.getAttribute("magnet") !== "false") {
        if (O.isNodeView())
          f = l === "center" ? O.cell.getBBox().getCenter().distance(p) : O.cell.getBBox().getNearestPointToPoint(p).distance(p);
        else if (O.isEdgeView()) {
          const w = O.getClosestPoint(p);
          w ? f = w.distance(p) : f = Number.MAX_SAFE_INTEGER;
        }
        f < s && f < d && (h === O.container || this.validateConnection(...r.getValidateConnectionArgs(O, null), O.getEdgeTerminal(O.container, e, t, this.cell, r.terminalType))) && (d = f, r.closestView = O, r.closestMagnet = O.container);
      }
      O.container.querySelectorAll("[magnet]").forEach((w) => {
        if (w.getAttribute("magnet") !== "false") {
          const x = O.getBBoxOfElement(w);
          f = p.distance(x.getCenter()), f < s && f < d && (h === w || this.validateConnection(...r.getValidateConnectionArgs(O, w), O.getEdgeTerminal(w, e, t, this.cell, r.terminalType))) && (d = f, r.closestView = O, r.closestMagnet = w);
        }
      });
    });
    let g;
    const v = r.terminalType, m = r.closestView, y = r.closestMagnet, b = h !== y;
    if (c && b && c.unhighlight(h, {
      type: "magnetAdsorbed"
    }), m) {
      if (!b)
        return;
      m.highlight(y, {
        type: "magnetAdsorbed"
      }), g = m.getEdgeTerminal(y, e, t, this.cell, v);
    } else
      g = { x: e, y: t };
    this.cell.setTerminal(v, g, {}, Object.assign(Object.assign({}, r.options), { ui: !0 }));
  }
  snapArrowheadEnd(e) {
    const t = e.closestView, r = e.closestMagnet;
    t && r && (t.unhighlight(r, {
      type: "magnetAdsorbed"
    }), e.currentMagnet = t.findMagnet(r)), e.closestView = null, e.closestMagnet = null;
  }
  finishEmbedding(e) {
    this.graph.options.embedding.enabled && this.cell.updateParent() && (e.zIndex = null);
  }
  fallbackConnection(e) {
    switch (e.fallbackAction) {
      case "remove":
        this.cell.remove({ ui: !0 });
        break;
      case "revert":
      default:
        this.cell.prop(e.terminalType, e.initialTerminal, {
          ui: !0
        });
        break;
    }
  }
  notifyConnectionEvent(e, t) {
    const r = e.terminalType, i = e.initialTerminal, o = this.cell[r];
    if (o && !rr.equalTerminals(i, o)) {
      const s = this.graph, l = i, u = l.cell ? s.getCellById(l.cell) : null, c = l.port, h = u ? s.findViewByCell(u) : null, f = u || e.isNewEdge ? null : G.create(i).toJSON(), d = o, p = d.cell ? s.getCellById(d.cell) : null, g = d.port, v = p ? s.findViewByCell(p) : null, m = p ? null : G.create(o).toJSON();
      this.notify("edge:connected", {
        e: t,
        previousCell: u,
        previousPort: c,
        previousView: h,
        previousPoint: f,
        currentCell: p,
        currentView: v,
        currentPort: g,
        currentPoint: m,
        previousMagnet: e.initialMagnet,
        currentMagnet: e.currentMagnet,
        edge: this.cell,
        view: this,
        type: r,
        isNew: e.isNewEdge
      });
    }
  }
  highlightAvailableMagnets(e) {
    const t = this.graph, r = t.model.getCells();
    e.marked = {};
    for (let i = 0, o = r.length; i < o; i += 1) {
      const a = t.findViewByCell(r[i]);
      if (!a || a.cell.id === this.cell.id)
        continue;
      const s = Array.prototype.slice.call(a.container.querySelectorAll("[magnet]"));
      a.container.getAttribute("magnet") !== "false" && s.push(a.container);
      const l = s.filter((u) => this.validateConnection(...e.getValidateConnectionArgs(a, u), a.getEdgeTerminal(u, e.x, e.y, this.cell, e.terminalType)));
      if (l.length > 0) {
        for (let u = 0, c = l.length; u < c; u += 1)
          a.highlight(l[u], { type: "magnetAvailable" });
        a.highlight(null, { type: "nodeAvailable" }), e.marked[a.cell.id] = l;
      }
    }
  }
  unhighlightAvailableMagnets(e) {
    const t = e.marked || {};
    Object.keys(t).forEach((r) => {
      const i = this.graph.findViewByCell(r);
      i && (t[r].forEach((a) => {
        i.unhighlight(a, { type: "magnetAvailable" });
      }), i.unhighlight(null, { type: "nodeAvailable" }));
    }), e.marked = null;
  }
  startArrowheadDragging(e, t, r) {
    if (!this.can("arrowheadMovable")) {
      this.notifyUnhandledMouseDown(e, t, r);
      return;
    }
    const o = e.target.getAttribute("data-terminal"), a = this.prepareArrowheadDragging(o, { x: t, y: r });
    this.setEventData(e, a);
  }
  dragArrowhead(e, t, r) {
    const i = this.getEventData(e);
    this.graph.options.connecting.snap ? this.snapArrowhead(t, r, i) : this.arrowheadDragging(this.getEventTarget(e), t, r, i);
  }
  stopArrowheadDragging(e, t, r) {
    const i = this.graph, o = this.getEventData(e);
    i.options.connecting.snap ? this.snapArrowheadEnd(o) : this.arrowheadDragged(o, t, r), this.validateEdge(this.cell, o.terminalType, o.initialTerminal) ? (this.finishEmbedding(o), this.notifyConnectionEvent(o, e)) : this.fallbackConnection(o), this.afterArrowheadDragging(o);
  }
  // #endregion
  // #region drag lable
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLabelDragging(e, t, r) {
    if (this.can("edgeLabelMovable")) {
      const i = e.currentTarget, o = parseInt(i.getAttribute("data-index"), 10), a = this.getLabelPositionAngle(o), s = this.getLabelPositionArgs(o), l = this.getDefaultLabelPositionArgs(), u = this.mergeLabelPositionArgs(s, l);
      this.setEventData(e, {
        index: o,
        positionAngle: a,
        positionArgs: u,
        stopPropagation: !0,
        action: "drag-label"
      });
    } else
      this.setEventData(e, { stopPropagation: !0 });
    this.graph.view.delegateDragEvents(e, this);
  }
  dragLabel(e, t, r) {
    const i = this.getEventData(e), o = this.cell.getLabelAt(i.index), a = er({}, o, {
      position: this.getLabelPosition(t, r, i.positionAngle, i.positionArgs)
    });
    this.cell.setLabelAt(i.index, a);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  stopLabelDragging(e, t, r) {
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag], i = t;
    return (r == null || r === n.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function" && typeof i.update == "function" && typeof i.getConnection == "function";
  }
  n.isEdgeView = e;
})(lu || (lu = {}));
lu.config({
  isSvgElement: !0,
  priority: 1,
  bootstrap: ["render", "source", "target"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    source: ["source", "update"],
    target: ["target", "update"],
    router: ["update"],
    connector: ["update"],
    labels: ["labels"],
    defaultLabel: ["labels"],
    tools: ["tools"],
    vertices: ["vertices", "update"]
  }
});
lu.registry.register("edge", lu, !0);
var YPe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
let nd = class HP extends Dn {
  /** Graph's `this.container` is from outer, should not dispose */
  get disposeContainer() {
    return !1;
  }
  get options() {
    return this.graph.options;
  }
  constructor(e) {
    super(), this.graph = e;
    const { selectors: t, fragment: r } = Mn.parseJSONMarkup(HP.markup);
    this.background = t.background, this.grid = t.grid, this.svg = t.svg, this.defs = t.defs, this.viewport = t.viewport, this.primer = t.primer, this.stage = t.stage, this.decorator = t.decorator, this.overlay = t.overlay, this.container = this.options.container, this.restore = HP.snapshoot(this.container), lt(this.container, this.prefixClassName("graph")), sh(this.container, r), this.delegateEvents();
  }
  delegateEvents() {
    const e = this.constructor;
    return super.delegateEvents(e.events), this;
  }
  /**
   * Guard the specified event. If the event is not interesting, it
   * returns `true`, otherwise returns `false`.
   */
  guard(e, t) {
    return e.type === "mousedown" && e.button === 2 || this.options.guard && this.options.guard(e, t) ? !0 : e.data && e.data.guarded !== void 0 ? e.data.guarded : !(t && t.cell && Qt.isCell(t.cell) || this.svg === e.target || this.container === e.target || this.svg.contains(e.target));
  }
  findView(e) {
    return this.graph.findViewByElem(e);
  }
  onDblClick(e) {
    this.options.preventDefaultDblClick && e.preventDefault();
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (this.guard(t, r))
      return;
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    r ? r.onDblClick(t, i.x, i.y) : this.graph.trigger("blank:dblclick", {
      e: t,
      x: i.x,
      y: i.y
    });
  }
  onClick(e) {
    if (this.getMouseMovedCount(e) <= this.options.clickThreshold) {
      const t = this.normalizeEvent(e), r = this.findView(t.target);
      if (this.guard(t, r))
        return;
      const i = this.graph.snapToGrid(t.clientX, t.clientY);
      r ? r.onClick(t, i.x, i.y) : this.graph.trigger("blank:click", {
        e: t,
        x: i.x,
        y: i.y
      });
    }
  }
  isPreventDefaultContextMenu(e) {
    let t = this.options.preventDefaultContextMenu;
    return typeof t == "function" && (t = rt(t, this.graph, { view: e })), t;
  }
  onContextMenu(e) {
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (this.isPreventDefaultContextMenu(r) && e.preventDefault(), this.guard(t, r))
      return;
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    r ? r.onContextMenu(t, i.x, i.y) : this.graph.trigger("blank:contextmenu", {
      e: t,
      x: i.x,
      y: i.y
    });
  }
  delegateDragEvents(e, t) {
    e.data == null && (e.data = {}), this.setEventData(e, {
      currentView: t || null,
      mouseMovedCount: 0,
      startPosition: {
        x: e.clientX,
        y: e.clientY
      }
    });
    const r = this.constructor;
    this.delegateDocumentEvents(r.documentEvents, e.data), this.undelegateEvents();
  }
  getMouseMovedCount(e) {
    return this.getEventData(e).mouseMovedCount || 0;
  }
  onMouseDown(e) {
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (this.guard(t, r))
      return;
    this.options.preventDefaultMouseDown && e.preventDefault();
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    r ? r.onMouseDown(t, i.x, i.y) : (this.options.preventDefaultBlankAction && ["touchstart"].includes(t.type) && e.preventDefault(), this.graph.trigger("blank:mousedown", {
      e: t,
      x: i.x,
      y: i.y
    })), this.delegateDragEvents(t, r);
  }
  onMouseMove(e) {
    const t = this.getEventData(e), r = t.startPosition;
    if (r && r.x === e.clientX && r.y === e.clientY || (t.mouseMovedCount == null && (t.mouseMovedCount = 0), t.mouseMovedCount += 1, t.mouseMovedCount <= this.options.moveThreshold))
      return;
    const o = this.normalizeEvent(e), a = this.graph.snapToGrid(o.clientX, o.clientY), s = t.currentView;
    s ? s.onMouseMove(o, a.x, a.y) : this.graph.trigger("blank:mousemove", {
      e: o,
      x: a.x,
      y: a.y
    }), this.setEventData(o, t);
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), r = this.graph.snapToGrid(t.clientX, t.clientY), o = this.getEventData(e).currentView;
    if (o ? o.onMouseUp(t, r.x, r.y) : this.graph.trigger("blank:mouseup", {
      e: t,
      x: r.x,
      y: r.y
    }), !e.isPropagationStopped()) {
      const a = new hl(e, {
        type: "click",
        data: e.data
      });
      this.onClick(a);
    }
    e.stopImmediatePropagation(), this.delegateEvents();
  }
  onMouseOver(e) {
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (!this.guard(t, r))
      if (r)
        r.onMouseOver(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseover", { e: t });
      }
  }
  onMouseOut(e) {
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (!this.guard(t, r))
      if (r)
        r.onMouseOut(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseout", { e: t });
      }
  }
  onMouseEnter(e) {
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (this.guard(t, r))
      return;
    const i = this.graph.findViewByElem(t.relatedTarget);
    if (r) {
      if (i === r)
        return;
      r.onMouseEnter(t);
    } else {
      if (i)
        return;
      this.graph.trigger("graph:mouseenter", { e: t });
    }
  }
  onMouseLeave(e) {
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (this.guard(t, r))
      return;
    const i = this.graph.findViewByElem(t.relatedTarget);
    if (r) {
      if (i === r)
        return;
      r.onMouseLeave(t);
    } else {
      if (i)
        return;
      this.graph.trigger("graph:mouseleave", { e: t });
    }
  }
  onMouseWheel(e) {
    const t = this.normalizeEvent(e), r = this.findView(t.target);
    if (this.guard(t, r))
      return;
    const i = t.originalEvent, o = this.graph.snapToGrid(i.clientX, i.clientY), a = Math.max(-1, Math.min(1, i.wheelDelta || -i.detail));
    r ? r.onMouseWheel(t, o.x, o.y, a) : this.graph.trigger("blank:mousewheel", {
      e: t,
      delta: a,
      x: o.x,
      y: o.y
    });
  }
  onCustomEvent(e) {
    const t = e.currentTarget, r = t.getAttribute("event") || t.getAttribute("data-event");
    if (r) {
      const i = this.findView(t);
      if (i) {
        const o = this.normalizeEvent(e);
        if (this.guard(o, i))
          return;
        const a = this.graph.snapToGrid(o.clientX, o.clientY);
        i.onCustomEvent(o, r, a.x, a.y);
      }
    }
  }
  handleMagnetEvent(e, t) {
    const r = e.currentTarget, i = r.getAttribute("magnet");
    if (i && i.toLowerCase() !== "false") {
      const o = this.findView(r);
      if (o) {
        const a = this.normalizeEvent(e);
        if (this.guard(a, o))
          return;
        const s = this.graph.snapToGrid(a.clientX, a.clientY);
        rt(t, this.graph, o, a, r, s.x, s.y);
      }
    }
  }
  onMagnetMouseDown(e) {
    this.handleMagnetEvent(e, (t, r, i, o, a) => {
      t.onMagnetMouseDown(r, i, o, a);
    });
  }
  onMagnetDblClick(e) {
    this.handleMagnetEvent(e, (t, r, i, o, a) => {
      t.onMagnetDblClick(r, i, o, a);
    });
  }
  onMagnetContextMenu(e) {
    const t = this.findView(e.target);
    this.isPreventDefaultContextMenu(t) && e.preventDefault(), this.handleMagnetEvent(e, (r, i, o, a, s) => {
      r.onMagnetContextMenu(i, o, a, s);
    });
  }
  onLabelMouseDown(e) {
    const t = e.currentTarget, r = this.findView(t);
    if (r) {
      const i = this.normalizeEvent(e);
      if (this.guard(i, r))
        return;
      const o = this.graph.snapToGrid(i.clientX, i.clientY);
      r.onLabelMouseDown(i, o.x, o.y);
    }
  }
  onImageDragStart() {
    return !1;
  }
  dispose() {
    this.undelegateEvents(), this.undelegateDocumentEvents(), this.restore(), this.restore = () => {
    };
  }
};
YPe([
  Dn.dispose()
], nd.prototype, "dispose", null);
(function(n) {
  const e = `${Da.prefixCls}-graph`;
  n.markup = [
    {
      ns: Hr.xhtml,
      tagName: "div",
      selector: "background",
      className: `${e}-background`
    },
    {
      ns: Hr.xhtml,
      tagName: "div",
      selector: "grid",
      className: `${e}-grid`
    },
    {
      ns: Hr.svg,
      tagName: "svg",
      selector: "svg",
      className: `${e}-svg`,
      attrs: {
        width: "100%",
        height: "100%",
        "xmlns:xlink": Hr.xlink
      },
      children: [
        {
          tagName: "defs",
          selector: "defs"
        },
        {
          tagName: "g",
          selector: "viewport",
          className: `${e}-svg-viewport`,
          children: [
            {
              tagName: "g",
              selector: "primer",
              className: `${e}-svg-primer`
            },
            {
              tagName: "g",
              selector: "stage",
              className: `${e}-svg-stage`
            },
            {
              tagName: "g",
              selector: "decorator",
              className: `${e}-svg-decorator`
            },
            {
              tagName: "g",
              selector: "overlay",
              className: `${e}-svg-overlay`
            }
          ]
        }
      ]
    }
  ];
  function t(r) {
    const i = r.cloneNode();
    return r.childNodes.forEach((o) => i.appendChild(o)), () => {
      for (Sb(r); r.attributes.length > 0; )
        r.removeAttribute(r.attributes[0].name);
      for (let o = 0, a = i.attributes.length; o < a; o += 1) {
        const s = i.attributes[o];
        r.setAttribute(s.name, s.value);
      }
      i.childNodes.forEach((o) => r.appendChild(o));
    };
  }
  n.snapshoot = t;
})(nd || (nd = {}));
(function(n) {
  const e = Da.prefixCls;
  n.events = {
    dblclick: "onDblClick",
    contextmenu: "onContextMenu",
    touchstart: "onMouseDown",
    mousedown: "onMouseDown",
    mouseover: "onMouseOver",
    mouseout: "onMouseOut",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousewheel: "onMouseWheel",
    DOMMouseScroll: "onMouseWheel",
    [`mouseenter  .${e}-cell`]: "onMouseEnter",
    [`mouseleave  .${e}-cell`]: "onMouseLeave",
    [`mouseenter  .${e}-cell-tools`]: "onMouseEnter",
    [`mouseleave  .${e}-cell-tools`]: "onMouseLeave",
    [`mousedown   .${e}-cell [event]`]: "onCustomEvent",
    [`touchstart  .${e}-cell [event]`]: "onCustomEvent",
    [`mousedown   .${e}-cell [data-event]`]: "onCustomEvent",
    [`touchstart  .${e}-cell [data-event]`]: "onCustomEvent",
    [`dblclick    .${e}-cell [magnet]`]: "onMagnetDblClick",
    [`contextmenu .${e}-cell [magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${e}-cell [magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${e}-cell [magnet]`]: "onMagnetMouseDown",
    [`dblclick    .${e}-cell [data-magnet]`]: "onMagnetDblClick",
    [`contextmenu .${e}-cell [data-magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${e}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${e}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`dragstart   .${e}-cell image`]: "onImageDragStart",
    [`mousedown   .${e}-edge .${e}-edge-label`]: "onLabelMouseDown",
    [`touchstart  .${e}-edge .${e}-edge-label`]: "onLabelMouseDown"
  }, n.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
})(nd || (nd = {}));
const XPe = `.x6-graph {
  position: relative;
  overflow: hidden;
  outline: none;
  touch-action: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;
class Ur extends au {
  get options() {
    return this.graph.options;
  }
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.view;
  }
  constructor(e) {
    super(), this.graph = e, this.init();
  }
  init() {
  }
}
var UPe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class qP extends Ur {
  init() {
    T_("core", XPe);
  }
  dispose() {
    k_("core");
  }
}
UPe([
  qP.dispose()
], qP.prototype, "dispose", null);
var KPe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
}, f0;
(function(n) {
  function e(t) {
    const { grid: r, panning: i, mousewheel: o, embedding: a } = t, s = KPe(
      t,
      ["grid", "panning", "mousewheel", "embedding"]
    ), l = t.container;
    if (l != null)
      s.width == null && (s.width = l.clientWidth), s.height == null && (s.height = l.clientHeight);
    else
      throw new Error("Ensure the container of the graph is specified and valid");
    const u = er({}, n.defaults, s), c = { size: 10, visible: !1 };
    return typeof r == "number" ? u.grid = { size: r, visible: !1 } : typeof r == "boolean" ? u.grid = Object.assign(Object.assign({}, c), { visible: r }) : u.grid = Object.assign(Object.assign({}, c), r), [
      "panning",
      "mousewheel",
      "embedding"
    ].forEach((f) => {
      const d = t[f];
      typeof d == "boolean" ? u[f].enabled = d : u[f] = Object.assign(Object.assign({}, u[f]), d);
    }), u;
  }
  n.get = e;
})(f0 || (f0 = {}));
(function(n) {
  n.defaults = {
    x: 0,
    y: 0,
    scaling: {
      min: 0.01,
      max: 16
    },
    grid: {
      size: 10,
      visible: !1
    },
    background: !1,
    panning: {
      enabled: !1,
      eventTypes: ["leftMouseDown"]
    },
    mousewheel: {
      enabled: !1,
      factor: 1.2,
      zoomAtMousePosition: !0
    },
    highlighting: {
      default: {
        name: "stroke",
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: "className",
        args: {
          className: Da.prefix("available-node")
        }
      },
      magnetAvailable: {
        name: "className",
        args: {
          className: Da.prefix("available-magnet")
        }
      }
    },
    connecting: {
      snap: !1,
      allowLoop: !0,
      allowNode: !0,
      allowEdge: !1,
      allowPort: !0,
      allowBlank: !0,
      allowMulti: !0,
      highlight: !1,
      anchor: "center",
      edgeAnchor: "ratio",
      connectionPoint: "boundary",
      router: "normal",
      connector: "normal",
      validateConnection({ type: e, sourceView: t, targetView: r }) {
        return (e === "target" ? r : t) != null;
      },
      createEdge() {
        return new WPe();
      }
    },
    translating: {
      restrict: !1
    },
    embedding: {
      enabled: !1,
      findParent: "bbox",
      frontOnly: !0,
      validate: () => !0
    },
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultDblClick: !0,
    preventDefaultMouseDown: !1,
    preventDefaultContextMenu: !0,
    preventDefaultBlankAction: !0,
    interacting: {
      edgeLabelMovable: !1
    },
    async: !0,
    virtual: !1,
    guard: () => !1
  };
})(f0 || (f0 = {}));
var JPe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
}, eEe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class mI extends Ur {
  get elem() {
    return this.view.grid;
  }
  get grid() {
    return this.options.grid;
  }
  init() {
    this.startListening(), this.draw(this.grid);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  setVisible(e) {
    this.grid.visible !== e && (this.grid.visible = e, this.update());
  }
  getGridSize() {
    return this.grid.size;
  }
  setGridSize(e) {
    this.grid.size = Math.max(e, 1), this.update();
  }
  show() {
    this.setVisible(!0), this.update();
  }
  hide() {
    this.setVisible(!1), this.update();
  }
  clear() {
    this.elem.style.backgroundImage = "";
  }
  draw(e) {
    this.clear(), this.instance = null, Object.assign(this.grid, e), this.patterns = this.resolveGrid(e), this.update();
  }
  update(e = {}) {
    const t = this.grid.size;
    if (t <= 1 || !this.grid.visible)
      return this.clear();
    const r = this.graph.matrix(), i = this.getInstance(), o = Array.isArray(e) ? e : [e];
    this.patterns.forEach((l, u) => {
      const c = `pattern_${u}`, h = r.a || 1, f = r.d || 1, { update: d, markup: p } = l, g = eEe(l, ["update", "markup"]), v = Object.assign(Object.assign(Object.assign({}, g), o[u]), {
        sx: h,
        sy: f,
        ox: r.e || 0,
        oy: r.f || 0,
        width: t * h,
        height: t * f
      });
      i.has(c) || i.add(c, pt.create("pattern", { id: c, patternUnits: "userSpaceOnUse" }, pt.createVectors(p)).node);
      const m = i.get(c);
      typeof d == "function" && d(m.childNodes[0], v);
      let y = v.ox % v.width;
      y < 0 && (y += v.width);
      let b = v.oy % v.height;
      b < 0 && (b += v.height), Xt(m, {
        x: y,
        y: b,
        width: v.width,
        height: v.height
      });
    });
    const a = new XMLSerializer().serializeToString(i.root), s = `url(data:image/svg+xml;base64,${btoa(a)})`;
    this.elem.style.backgroundImage = s;
  }
  getInstance() {
    return this.instance || (this.instance = new sc()), this.instance;
  }
  resolveGrid(e) {
    if (!e)
      return [];
    const t = e.type;
    if (t == null)
      return [
        Object.assign(Object.assign({}, sc.presets.dot), e.args)
      ];
    const r = sc.registry.get(t);
    if (r) {
      let i = e.args || [];
      return Array.isArray(i) || (i = [i]), Array.isArray(r) ? r.map((o, a) => Object.assign(Object.assign({}, o), i[a])) : [Object.assign(Object.assign({}, r), i[0])];
    }
    return sc.registry.onNotFound(t);
  }
  dispose() {
    this.stopListening(), this.clear();
  }
}
JPe([
  Ur.dispose()
], mI.prototype, "dispose", null);
class L9 extends Ur {
  get container() {
    return this.graph.view.container;
  }
  get viewport() {
    return this.graph.view.viewport;
  }
  get stage() {
    return this.graph.view.stage;
  }
  init() {
    this.resize();
  }
  /**
   * Returns the current transformation matrix of the graph.
   */
  getMatrix() {
    const e = this.viewport.getAttribute("transform");
    return e !== this.viewportTransformString && (this.viewportMatrix = this.viewport.getCTM(), this.viewportTransformString = e), Xr(this.viewportMatrix);
  }
  /**
   * Sets new transformation with the given `matrix`
   */
  setMatrix(e) {
    const t = Xr(e), r = yv(t);
    this.viewport.setAttribute("transform", r), this.viewportMatrix = t, this.viewportTransformString = r;
  }
  resize(e, t) {
    let r = e === void 0 ? this.options.width : e, i = t === void 0 ? this.options.height : t;
    this.options.width = r, this.options.height = i, typeof r == "number" && (r = Math.round(r)), typeof i == "number" && (i = Math.round(i)), this.container.style.width = r == null ? "" : `${r}px`, this.container.style.height = i == null ? "" : `${i}px`;
    const o = this.getComputedSize();
    return this.graph.trigger("resize", Object.assign({}, o)), this;
  }
  getComputedSize() {
    let e = this.options.width, t = this.options.height;
    return v3(e) || (e = this.container.clientWidth), v3(t) || (t = this.container.clientHeight), { width: e, height: t };
  }
  getScale() {
    return X2e(this.getMatrix());
  }
  scale(e, t = e, r = 0, i = 0) {
    if (e = this.clampScale(e), t = this.clampScale(t), r || i) {
      const a = this.getTranslation(), s = a.tx - r * (e - 1), l = a.ty - i * (t - 1);
      (s !== a.tx || l !== a.ty) && this.translate(s, l);
    }
    const o = this.getMatrix();
    return o.a = e, o.d = t, this.setMatrix(o), this.graph.trigger("scale", { sx: e, sy: t, ox: r, oy: i }), this;
  }
  clampScale(e) {
    const t = this.graph.options.scaling;
    return wo(e, t.min || 0.01, t.max || 16);
  }
  getZoom() {
    return this.getScale().sx;
  }
  zoom(e, t) {
    t = t || {};
    let r = e, i = e;
    const o = this.getScale(), a = this.getComputedSize();
    let s = a.width / 2, l = a.height / 2;
    if (t.absolute || (r += o.sx, i += o.sy), t.scaleGrid && (r = Math.round(r / t.scaleGrid) * t.scaleGrid, i = Math.round(i / t.scaleGrid) * t.scaleGrid), t.maxScale && (r = Math.min(t.maxScale, r), i = Math.min(t.maxScale, i)), t.minScale && (r = Math.max(t.minScale, r), i = Math.max(t.minScale, i)), t.center && (s = t.center.x, l = t.center.y), r = this.clampScale(r), i = this.clampScale(i), s || l) {
      const u = this.getTranslation(), c = s - (s - u.tx) * (r / o.sx), h = l - (l - u.ty) * (i / o.sy);
      (c !== u.tx || h !== u.ty) && this.translate(c, h);
    }
    return this.scale(r, i), this;
  }
  getRotation() {
    return U2e(this.getMatrix());
  }
  rotate(e, t, r) {
    if (t == null || r == null) {
      const o = gn.getBBox(this.stage);
      t = o.width / 2, r = o.height / 2;
    }
    const i = this.getMatrix().translate(t, r).rotate(e).translate(-t, -r);
    return this.setMatrix(i), this;
  }
  getTranslation() {
    return K2e(this.getMatrix());
  }
  translate(e, t) {
    const r = this.getMatrix();
    r.e = e || 0, r.f = t || 0, this.setMatrix(r);
    const i = this.getTranslation();
    return this.options.x = i.tx, this.options.y = i.ty, this.graph.trigger("translate", Object.assign({}, i)), this;
  }
  setOrigin(e, t) {
    return this.translate(e || 0, t || 0);
  }
  fitToContent(e, t, r, i) {
    if (typeof e == "object") {
      const b = e;
      e = b.gridWidth || 1, t = b.gridHeight || 1, r = b.padding || 0, i = b;
    } else
      e = e || 1, t = t || 1, r = r || 0, i == null && (i = {});
    const o = Jf(r), a = i.border || 0, s = i.contentArea ? Te.create(i.contentArea) : this.getContentArea(i);
    a > 0 && s.inflate(a);
    const l = this.getScale(), u = this.getTranslation(), c = l.sx, h = l.sy;
    s.x *= c, s.y *= h, s.width *= c, s.height *= h;
    let f = Math.max(Math.ceil((s.width + s.x) / e), 1) * e, d = Math.max(Math.ceil((s.height + s.y) / t), 1) * t, p = 0, g = 0;
    (i.allowNewOrigin === "negative" && s.x < 0 || i.allowNewOrigin === "positive" && s.x >= 0 || i.allowNewOrigin === "any") && (p = Math.ceil(-s.x / e) * e, p += o.left, f += p), (i.allowNewOrigin === "negative" && s.y < 0 || i.allowNewOrigin === "positive" && s.y >= 0 || i.allowNewOrigin === "any") && (g = Math.ceil(-s.y / t) * t, g += o.top, d += g), f += o.right, d += o.bottom, f = Math.max(f, i.minWidth || 0), d = Math.max(d, i.minHeight || 0), f = Math.min(f, i.maxWidth || Number.MAX_SAFE_INTEGER), d = Math.min(d, i.maxHeight || Number.MAX_SAFE_INTEGER);
    const v = this.getComputedSize(), m = f !== v.width || d !== v.height;
    return (p !== u.tx || g !== u.ty) && this.translate(p, g), m && this.resize(f, d), new Te(-p / c, -g / h, f / c, d / h);
  }
  scaleContentToFit(e = {}) {
    this.scaleContentToFitImpl(e);
  }
  scaleContentToFitImpl(e = {}, t = !0) {
    let r, i;
    if (e.contentArea) {
      const m = e.contentArea;
      r = this.graph.localToGraph(m), i = G.create(m);
    } else
      r = this.getContentBBox(e), i = this.graph.graphToLocal(r);
    if (!r.width || !r.height)
      return;
    const o = Jf(e.padding), a = e.minScale || 0, s = e.maxScale || Number.MAX_SAFE_INTEGER, l = e.minScaleX || a, u = e.maxScaleX || s, c = e.minScaleY || a, h = e.maxScaleY || s;
    let f;
    if (e.viewportArea)
      f = e.viewportArea;
    else {
      const m = this.getComputedSize(), y = this.getTranslation();
      f = {
        x: y.tx,
        y: y.ty,
        width: m.width,
        height: m.height
      };
    }
    f = Te.create(f).moveAndExpand({
      x: o.left,
      y: o.top,
      width: -o.left - o.right,
      height: -o.top - o.bottom
    });
    const d = this.getScale();
    let p = f.width / r.width * d.sx, g = f.height / r.height * d.sy;
    e.preserveAspectRatio !== !1 && (p = g = Math.min(p, g));
    const v = e.scaleGrid;
    if (v && (p = v * Math.floor(p / v), g = v * Math.floor(g / v)), p = wo(p, l, u), g = wo(g, c, h), this.scale(p, g), t) {
      const m = this.options, y = f.x - i.x * p - m.x, b = f.y - i.y * g - m.y;
      this.translate(y, b);
    }
  }
  getContentArea(e = {}) {
    return e.useCellGeometry !== !1 ? this.model.getAllCellsBBox() || new Te() : gn.getBBox(this.stage);
  }
  getContentBBox(e = {}) {
    return this.graph.localToGraph(this.getContentArea(e));
  }
  getGraphArea() {
    const e = Te.fromSize(this.getComputedSize());
    return this.graph.graphToLocal(e);
  }
  zoomToRect(e, t = {}) {
    const r = Te.create(e), i = this.graph;
    t.contentArea = r, t.viewportArea == null && (t.viewportArea = {
      x: i.options.x,
      y: i.options.y,
      width: this.options.width,
      height: this.options.height
    }), this.scaleContentToFitImpl(t, !1);
    const o = r.getCenter();
    return this.centerPoint(o.x, o.y), this;
  }
  zoomToFit(e = {}) {
    return this.zoomToRect(this.getContentArea(e), e);
  }
  centerPoint(e, t) {
    const r = this.getComputedSize(), i = this.getScale(), o = this.getTranslation(), a = r.width / 2, s = r.height / 2;
    e = typeof e == "number" ? e : a, t = typeof t == "number" ? t : s, e = a - e * i.sx, t = s - t * i.sy, (o.tx !== e || o.ty !== t) && this.translate(e, t);
  }
  centerContent(e) {
    const r = this.graph.getContentArea(e).getCenter();
    this.centerPoint(r.x, r.y);
  }
  centerCell(e) {
    return this.positionCell(e, "center");
  }
  positionPoint(e, t, r) {
    const i = this.getComputedSize();
    t = ss(t, Math.max(0, i.width)), t < 0 && (t = i.width + t), r = ss(r, Math.max(0, i.height)), r < 0 && (r = i.height + r);
    const o = this.getTranslation(), a = this.getScale(), s = t - e.x * a.sx, l = r - e.y * a.sy;
    (o.tx !== s || o.ty !== l) && this.translate(s, l);
  }
  positionRect(e, t) {
    const r = Te.create(e);
    switch (t) {
      case "center":
        return this.positionPoint(r.getCenter(), "50%", "50%");
      case "top":
        return this.positionPoint(r.getTopCenter(), "50%", 0);
      case "top-right":
        return this.positionPoint(r.getTopRight(), "100%", 0);
      case "right":
        return this.positionPoint(r.getRightMiddle(), "100%", "50%");
      case "bottom-right":
        return this.positionPoint(r.getBottomRight(), "100%", "100%");
      case "bottom":
        return this.positionPoint(r.getBottomCenter(), "50%", "100%");
      case "bottom-left":
        return this.positionPoint(r.getBottomLeft(), 0, "100%");
      case "left":
        return this.positionPoint(r.getLeftMiddle(), 0, "50%");
      case "top-left":
        return this.positionPoint(r.getTopLeft(), 0, 0);
      default:
        return this;
    }
  }
  positionCell(e, t) {
    const r = e.getBBox();
    return this.positionRect(r, t);
  }
  positionContent(e, t) {
    const r = this.graph.getContentArea(t);
    return this.positionRect(r, e);
  }
}
var tEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class yI extends Ur {
  get elem() {
    return this.view.background;
  }
  init() {
    this.startListening(), this.options.background && this.draw(this.options.background);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  updateBackgroundImage(e = {}) {
    let t = e.size || "auto auto", r = e.position || "center";
    const i = this.graph.transform.getScale(), o = this.graph.translate();
    if (typeof r == "object") {
      const a = o.tx + i.sx * (r.x || 0), s = o.ty + i.sy * (r.y || 0);
      r = `${a}px ${s}px`;
    }
    typeof t == "object" && (t = Te.fromSize(t).scale(i.sx, i.sy), t = `${t.width}px ${t.height}px`), this.elem.style.backgroundSize = t, this.elem.style.backgroundPosition = r;
  }
  drawBackgroundImage(e, t = {}) {
    if (!(e instanceof HTMLImageElement)) {
      this.elem.style.backgroundImage = "";
      return;
    }
    const r = this.optionsCache;
    if (r && r.image !== t.image)
      return;
    let i;
    const o = t.opacity, a = t.size;
    let s = t.repeat || "no-repeat";
    const l = l0.registry.get(s);
    if (typeof l == "function") {
      const c = t.quality || 1;
      e.width *= c, e.height *= c;
      const h = l(e, t);
      if (!(h instanceof HTMLCanvasElement))
        throw new Error("Background pattern must return an HTML Canvas instance");
      i = h.toDataURL("image/png"), t.repeat && s !== t.repeat ? s = t.repeat : s = "repeat", typeof a == "object" ? (a.width *= h.width / e.width, a.height *= h.height / e.height) : a === void 0 && (t.size = {
        width: h.width / c,
        height: h.height / c
      });
    } else
      i = e.src, a === void 0 && (t.size = {
        width: e.width,
        height: e.height
      });
    r != null && typeof t.size == "object" && t.image === r.image && t.repeat === r.repeat && t.quality === r.quality && (r.size = Xy(t.size));
    const u = this.elem.style;
    u.backgroundImage = `url(${i})`, u.backgroundRepeat = s, u.opacity = o == null || o >= 1 ? "" : `${o}`, this.updateBackgroundImage(t);
  }
  updateBackgroundColor(e) {
    this.elem.style.backgroundColor = e || "";
  }
  updateBackgroundOptions(e) {
    this.graph.options.background = e;
  }
  update() {
    this.optionsCache && this.updateBackgroundImage(this.optionsCache);
  }
  draw(e) {
    const t = e || {};
    if (this.updateBackgroundOptions(e), this.updateBackgroundColor(t.color), t.image) {
      this.optionsCache = Xy(t);
      const r = document.createElement("img");
      r.onload = () => this.drawBackgroundImage(r, e), r.setAttribute("crossorigin", "anonymous"), r.src = t.image;
    } else
      this.drawBackgroundImage(null), this.optionsCache = null;
  }
  clear() {
    this.draw();
  }
  dispose() {
    this.clear(), this.stopListening();
  }
}
tEe([
  Ur.dispose()
], yI.prototype, "dispose", null);
var nEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class bI extends Ur {
  get widgetOptions() {
    return this.options.panning;
  }
  get pannable() {
    return this.widgetOptions && this.widgetOptions.enabled === !0;
  }
  init() {
    this.onRightMouseDown = this.onRightMouseDown.bind(this), this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this), this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this), this.startListening(), this.updateClassName();
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onMouseDown, this), this.graph.on("node:unhandled:mousedown", this.onMouseDown, this), this.graph.on("edge:unhandled:mousedown", this.onMouseDown, this), ii.on(this.graph.container, "mousedown", this.onRightMouseDown), ii.on(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle = new Nq(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.mousewheelHandle.enable();
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onMouseDown, this), this.graph.off("node:unhandled:mousedown", this.onMouseDown, this), this.graph.off("edge:unhandled:mousedown", this.onMouseDown, this), ii.off(this.graph.container, "mousedown", this.onRightMouseDown), ii.off(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle && this.mousewheelHandle.disable();
  }
  allowPanning(e, t) {
    return e.spaceKey = this.isSpaceKeyPressed, this.pannable && Lc.isMatch(e, this.widgetOptions.modifiers, t);
  }
  startPanning(e) {
    const t = this.view.normalizeEvent(e);
    this.clientX = t.clientX, this.clientY = t.clientY, this.panning = !0, this.updateClassName(), ii.on(document.body, {
      "mousemove.panning touchmove.panning": this.pan.bind(this),
      "mouseup.panning touchend.panning": this.stopPanning.bind(this),
      "mouseleave.panning": this.stopPanning.bind(this)
    }), ii.on(window, "mouseup.panning", this.stopPanning.bind(this));
  }
  pan(e) {
    const t = this.view.normalizeEvent(e), r = t.clientX - this.clientX, i = t.clientY - this.clientY;
    this.clientX = t.clientX, this.clientY = t.clientY, this.graph.translateBy(r, i);
  }
  // eslint-disable-next-line
  stopPanning(e) {
    this.panning = !1, this.updateClassName(), ii.off(document.body, ".panning"), ii.off(window, ".panning");
  }
  updateClassName() {
    const e = this.view.container, t = this.view.prefixClassName("graph-panning"), r = this.view.prefixClassName("graph-pannable");
    this.pannable ? this.panning ? (lt(e, t), br(e, r)) : (br(e, t), lt(e, r)) : (br(e, t), br(e, r));
  }
  onMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e))
      return;
    const t = this.graph.getPlugin("selection"), r = t && t.allowRubberband(e, !0);
    (this.allowPanning(e, !0) || this.allowPanning(e) && !r) && this.startPanning(e);
  }
  onRightMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    t != null && t.includes("rightMouseDown") && e.button === 2 && this.allowPanning(e, !0) && this.startPanning(e);
  }
  onMouseWheel(e, t, r) {
    this.graph.translateBy(-t, -r);
  }
  onSpaceKeyDown(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !0);
  }
  onSpaceKeyUp(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !1);
  }
  allowBlankMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    return (t == null ? void 0 : t.includes("leftMouseDown")) && e.button === 0 || (t == null ? void 0 : t.includes("mouseWheelDown")) && e.button === 1;
  }
  allowMouseWheel(e) {
    var t;
    return this.pannable && !e.ctrlKey && ((t = this.widgetOptions.eventTypes) === null || t === void 0 ? void 0 : t.includes("mouseWheel"));
  }
  autoPanning(e, t) {
    const i = this.graph.getGraphArea();
    let o = 0, a = 0;
    e <= i.left + 10 && (o = -10), t <= i.top + 10 && (a = -10), e >= i.right - 10 && (o = 10), t >= i.bottom - 10 && (a = 10), (o !== 0 || a !== 0) && this.graph.translateBy(-o, -a);
  }
  enablePanning() {
    this.pannable || (this.widgetOptions.enabled = !0, this.updateClassName());
  }
  disablePanning() {
    this.pannable && (this.widgetOptions.enabled = !1, this.updateClassName());
  }
  dispose() {
    this.stopListening();
  }
}
nEe([
  Ur.dispose()
], bI.prototype, "dispose", null);
var rEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class OI extends Ur {
  constructor() {
    super(...arguments), this.cumulatedFactor = 1;
  }
  get widgetOptions() {
    return this.options.mousewheel;
  }
  init() {
    this.container = this.graph.container, this.target = this.widgetOptions.global ? document : this.container, this.mousewheelHandle = new Nq(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.widgetOptions.enabled && this.enable(!0);
  }
  get disabled() {
    return this.widgetOptions.enabled !== !0;
  }
  enable(e) {
    (this.disabled || e) && (this.widgetOptions.enabled = !0, this.mousewheelHandle.enable());
  }
  disable() {
    this.disabled || (this.widgetOptions.enabled = !1, this.mousewheelHandle.disable());
  }
  allowMouseWheel(e) {
    const t = this.widgetOptions.guard;
    return (t == null || t(e)) && Lc.isMatch(e, this.widgetOptions.modifiers);
  }
  onMouseWheel(e) {
    const t = this.widgetOptions.guard;
    if ((t == null || t(e)) && Lc.isMatch(e, this.widgetOptions.modifiers)) {
      const r = this.widgetOptions.factor || 1.2;
      this.currentScale == null && (this.startPos = { x: e.clientX, y: e.clientY }, this.currentScale = this.graph.transform.getScale().sx), e.deltaY < 0 ? this.currentScale < 0.15 ? this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * r * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 1.05)) : this.currentScale <= 0.15 ? this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * (1 / r) * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 0.95)), this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
      const o = this.currentScale;
      let a = this.graph.transform.clampScale(o * this.cumulatedFactor);
      const s = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER, l = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
      if (a = wo(a, s, l), a !== o)
        if (this.widgetOptions.zoomAtMousePosition) {
          const c = !!this.graph.getPlugin("scroller") ? this.graph.clientToLocal(this.startPos) : this.graph.clientToGraph(this.startPos);
          this.graph.zoom(a, {
            absolute: !0,
            center: c.clone()
          });
        } else
          this.graph.zoom(a, { absolute: !0 });
      this.currentScale = null, this.cumulatedFactor = 1;
    }
  }
  dispose() {
    this.disable();
  }
}
rEe([
  au.dispose()
], OI.prototype, "dispose", null);
var iEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class I9 extends Ur {
  init() {
    this.resetRenderArea = zde(this.resetRenderArea, 200, {
      leading: !0
    }), this.resetRenderArea(), this.startListening();
  }
  startListening() {
    this.graph.on("translate", this.resetRenderArea, this), this.graph.on("scale", this.resetRenderArea, this), this.graph.on("resize", this.resetRenderArea, this);
  }
  stopListening() {
    this.graph.off("translate", this.resetRenderArea, this), this.graph.off("scale", this.resetRenderArea, this), this.graph.off("resize", this.resetRenderArea, this);
  }
  enableVirtualRender() {
    this.options.virtual = !0, this.resetRenderArea();
  }
  disableVirtualRender() {
    this.options.virtual = !1, this.graph.renderer.setRenderArea(void 0);
  }
  resetRenderArea() {
    if (this.options.virtual) {
      const e = this.graph.getGraphArea();
      this.graph.renderer.setRenderArea(e);
    }
  }
  dispose() {
    this.stopListening();
  }
}
iEe([
  Ur.dispose()
], I9.prototype, "dispose", null);
class oEe {
  constructor() {
    this.isFlushing = !1, this.isFlushPending = !1, this.scheduleId = 0, this.queue = [], this.frameInterval = 33, this.initialTime = Date.now();
  }
  queueJob(e) {
    if (e.priority & Zl.PRIOR)
      e.cb();
    else {
      const t = this.findInsertionIndex(e);
      t >= 0 && this.queue.splice(t, 0, e);
    }
  }
  queueFlush() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.scheduleJob());
  }
  queueFlushSync() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.flushJobsSync());
  }
  clearJobs() {
    this.queue.length = 0, this.isFlushing = !1, this.isFlushPending = !1, this.cancelScheduleJob();
  }
  flushJobs() {
    this.isFlushPending = !1, this.isFlushing = !0;
    const e = this.getCurrentTime();
    let t;
    for (; (t = this.queue.shift()) && (t.cb(), !(this.getCurrentTime() - e >= this.frameInterval)); )
      ;
    this.isFlushing = !1, this.queue.length && this.queueFlush();
  }
  flushJobsSync() {
    this.isFlushPending = !1, this.isFlushing = !0;
    let e;
    for (; e = this.queue.shift(); )
      try {
        e.cb();
      } catch (t) {
        console.log(t);
      }
    this.isFlushing = !1;
  }
  findInsertionIndex(e) {
    let t = 0, r = this.queue.length, i = r - 1;
    const o = e.priority;
    for (; t <= i; ) {
      const a = (i - t >> 1) + t;
      o <= this.queue[a].priority ? t = a + 1 : (r = a, i = a - 1);
    }
    return r;
  }
  scheduleJob() {
    "requestIdleCallback" in window ? (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
      timeout: 100
    })) : (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.setTimeout(this.flushJobs.bind(this)));
  }
  cancelScheduleJob() {
    "cancelIdleCallback" in window ? (this.scheduleId && window.cancelIdleCallback(this.scheduleId), this.scheduleId = 0) : (this.scheduleId && clearTimeout(this.scheduleId), this.scheduleId = 0);
  }
  getCurrentTime() {
    return typeof performance == "object" && typeof performance.now == "function" ? performance.now() : Date.now() - this.initialTime;
  }
}
var Zl;
(function(n) {
  n[n.Update = 2] = "Update", n[n.RenderEdge = 4] = "RenderEdge", n[n.RenderNode = 8] = "RenderNode", n[n.PRIOR = 1048576] = "PRIOR";
})(Zl || (Zl = {}));
var aEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
let $g = class Ro extends au {
  get model() {
    return this.graph.model;
  }
  get container() {
    return this.graph.view.stage;
  }
  constructor(e) {
    super(), this.views = {}, this.willRemoveViews = {}, this.queue = new oEe(), this.graph = e, this.init();
  }
  init() {
    this.startListening(), this.renderViews(this.model.getCells());
  }
  startListening() {
    this.model.on("reseted", this.onModelReseted, this), this.model.on("cell:added", this.onCellAdded, this), this.model.on("cell:removed", this.onCellRemoved, this), this.model.on("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.on("cell:change:visible", this.onCellVisibleChanged, this);
  }
  stopListening() {
    this.model.off("reseted", this.onModelReseted, this), this.model.off("cell:added", this.onCellAdded, this), this.model.off("cell:removed", this.onCellRemoved, this), this.model.off("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.off("cell:change:visible", this.onCellVisibleChanged, this);
  }
  onModelReseted({ options: e }) {
    this.queue.clearJobs(), this.removeZPivots(), this.resetViews();
    const t = this.model.getCells();
    this.renderViews(t, Object.assign(Object.assign({}, e), { queue: t.map((r) => r.id) }));
  }
  onCellAdded({ cell: e, options: t }) {
    this.renderViews([e], t);
  }
  onCellRemoved({ cell: e }) {
    this.removeViews([e]);
  }
  onCellZIndexChanged({ cell: e, options: t }) {
    const r = this.views[e.id];
    r && this.requestViewUpdate(r.view, Ro.FLAG_INSERT, t, Zl.Update, !0);
  }
  onCellVisibleChanged({ cell: e, current: t }) {
    this.toggleVisible(e, !!t);
  }
  requestViewUpdate(e, t, r = {}, i = Zl.Update, o = !0) {
    const a = e.cell.id, s = this.views[a];
    if (!s)
      return;
    s.flag = t, s.options = r, (e.hasAction(t, ["translate", "resize", "rotate"]) || r.async === !1) && (i = Zl.PRIOR, o = !1), this.queue.queueJob({
      id: a,
      priority: i,
      cb: () => {
        this.renderViewInArea(e, t, r);
        const c = r.queue;
        if (c) {
          const h = c.indexOf(e.cell.id);
          h >= 0 && c.splice(h, 1), c.length === 0 && this.graph.trigger("render:done");
        }
      }
    }), this.getEffectedEdges(e).forEach((c) => {
      this.requestViewUpdate(c.view, c.flag, r, i, !1);
    }), o && this.flush();
  }
  setRenderArea(e) {
    this.renderArea = e, this.flushWaitingViews();
  }
  isViewMounted(e) {
    if (e == null)
      return !1;
    const t = this.views[e.cell.id];
    return t ? t.state === Ro.ViewState.MOUNTED : !1;
  }
  renderViews(e, t = {}) {
    e.sort((r, i) => r.isNode() && i.isEdge() ? -1 : 0), e.forEach((r) => {
      const i = r.id, o = this.views;
      let a = 0, s = o[i];
      if (s)
        a = Ro.FLAG_INSERT;
      else {
        const l = this.createCellView(r);
        l && (l.graph = this.graph, a = Ro.FLAG_INSERT | l.getBootstrapFlag(), s = {
          view: l,
          flag: a,
          options: t,
          state: Ro.ViewState.CREATED
        }, this.views[i] = s);
      }
      s && this.requestViewUpdate(s.view, a, t, this.getRenderPriority(s.view), !1);
    }), this.flush();
  }
  renderViewInArea(e, t, r = {}) {
    const i = e.cell, o = i.id, a = this.views[o];
    if (!a)
      return;
    let s = 0;
    this.isUpdatable(e) ? (s = this.updateView(e, t, r), a.flag = s) : a.state === Ro.ViewState.MOUNTED ? (s = this.updateView(e, t, r), a.flag = s) : a.state = Ro.ViewState.WAITING, s && i.isEdge() && !(s & e.getFlag(["source", "target"])) && this.queue.queueJob({
      id: o,
      priority: Zl.RenderEdge,
      cb: () => {
        this.updateView(e, t, r);
      }
    });
  }
  removeViews(e) {
    e.forEach((t) => {
      const r = t.id, i = this.views[r];
      i && (this.willRemoveViews[r] = i, delete this.views[r], this.queue.queueJob({
        id: r,
        priority: this.getRenderPriority(i.view),
        cb: () => {
          this.removeView(i.view);
        }
      }));
    }), this.flush();
  }
  flush() {
    this.graph.options.async ? this.queue.queueFlush() : this.queue.queueFlushSync();
  }
  flushWaitingViews() {
    Object.values(this.views).forEach((e) => {
      if (e && e.state === Ro.ViewState.WAITING) {
        const { view: t, flag: r, options: i } = e;
        this.requestViewUpdate(t, r, i, this.getRenderPriority(t), !1);
      }
    }), this.flush();
  }
  updateView(e, t, r = {}) {
    if (e == null)
      return 0;
    if (fr.isCellView(e)) {
      if (t & Ro.FLAG_REMOVE)
        return this.removeView(e.cell), 0;
      t & Ro.FLAG_INSERT && (this.insertView(e), t ^= Ro.FLAG_INSERT);
    }
    return t ? e.confirmUpdate(t, r) : 0;
  }
  insertView(e) {
    const t = this.views[e.cell.id];
    if (t) {
      const r = e.cell.getZIndex(), i = this.addZPivot(r);
      this.container.insertBefore(e.container, i), e.cell.isVisible() || this.toggleVisible(e.cell, !1), t.state = Ro.ViewState.MOUNTED, this.graph.trigger("view:mounted", { view: e });
    }
  }
  resetViews() {
    this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews), Object.values(this.willRemoveViews).forEach((e) => {
      e && this.removeView(e.view);
    }), this.views = {}, this.willRemoveViews = {};
  }
  removeView(e) {
    const t = e.cell, r = this.willRemoveViews[t.id];
    r && e && (r.view.remove(), delete this.willRemoveViews[t.id], this.graph.trigger("view:unmounted", { view: e }));
  }
  toggleVisible(e, t) {
    const r = this.model.getConnectedEdges(e);
    for (let o = 0, a = r.length; o < a; o += 1) {
      const s = r[o];
      if (t) {
        const l = s.getSourceCell(), u = s.getTargetCell();
        if (l && !l.isVisible() || u && !u.isVisible())
          continue;
        this.toggleVisible(s, !0);
      } else
        this.toggleVisible(s, !1);
    }
    const i = this.views[e.id];
    i && Mr(i.view.container, {
      display: t ? "unset" : "none"
    });
  }
  addZPivot(e = 0) {
    this.zPivots == null && (this.zPivots = {});
    const t = this.zPivots;
    let r = t[e];
    if (r)
      return r;
    r = t[e] = document.createComment(`z-index:${e + 1}`);
    let i = -1 / 0;
    for (const a in t) {
      const s = +a;
      s < e && s > i && (i = s, e - 1);
    }
    const o = this.container;
    if (i !== -1 / 0) {
      const a = t[i];
      o.insertBefore(r, a.nextSibling);
    } else
      o.insertBefore(r, o.firstChild);
    return r;
  }
  removeZPivots() {
    this.zPivots && Object.values(this.zPivots).forEach((e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }), this.zPivots = {};
  }
  createCellView(e) {
    const t = { graph: this.graph }, r = this.graph.options.createCellView;
    if (r) {
      const o = rt(r, this.graph, e);
      if (o)
        return new o(e, t);
      if (o === null)
        return null;
    }
    const i = e.view;
    if (i != null && typeof i == "string") {
      const o = fr.registry.get(i);
      return o ? new o(e, t) : fr.registry.onNotFound(i);
    }
    return e.isNode() ? new Uo(e, t) : e.isEdge() ? new lu(e, t) : null;
  }
  getEffectedEdges(e) {
    const t = [], r = e.cell, i = this.model.getConnectedEdges(r);
    for (let o = 0, a = i.length; o < a; o += 1) {
      const s = i[o], l = this.views[s.id];
      if (!l)
        continue;
      const u = l.view;
      if (!this.isViewMounted(u))
        continue;
      const c = ["update"];
      s.getTargetCell() === r && c.push("target"), s.getSourceCell() === r && c.push("source"), t.push({
        id: s.id,
        view: u,
        flag: u.getFlag(c)
      });
    }
    return t;
  }
  isUpdatable(e) {
    if (e.isNodeView())
      return this.renderArea ? this.renderArea.isIntersectWithRect(e.cell.getBBox()) : !0;
    if (e.isEdgeView()) {
      const t = e.cell, r = t.getSourceCell(), i = t.getTargetCell();
      if (this.renderArea && r && i)
        return this.renderArea.isIntersectWithRect(r.getBBox()) || this.renderArea.isIntersectWithRect(i.getBBox());
    }
    return !0;
  }
  getRenderPriority(e) {
    return e.cell.isNode() ? Zl.RenderNode : Zl.RenderEdge;
  }
  dispose() {
    this.stopListening(), Object.keys(this.views).forEach((e) => {
      this.views[e].view.dispose();
    }), this.views = {};
  }
};
aEe([
  au.dispose()
], $g.prototype, "dispose", null);
(function(n) {
  n.FLAG_INSERT = 1 << 30, n.FLAG_REMOVE = 1 << 29, n.FLAG_RENDER = (1 << 26) - 1;
})($g || ($g = {}));
(function(n) {
  (function(e) {
    e[e.CREATED = 0] = "CREATED", e[e.MOUNTED = 1] = "MOUNTED", e[e.WAITING = 2] = "WAITING";
  })(n.ViewState || (n.ViewState = {}));
})($g || ($g = {}));
var sEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
let wI = class extends Ur {
  constructor() {
    super(...arguments), this.schedule = new $g(this.graph);
  }
  requestViewUpdate(e, t, r = {}) {
    this.schedule.requestViewUpdate(e, t, r);
  }
  isViewMounted(e) {
    return this.schedule.isViewMounted(e);
  }
  setRenderArea(e) {
    this.schedule.setRenderArea(e);
  }
  findViewByElem(e) {
    if (e == null)
      return null;
    const t = this.options.container, r = typeof e == "string" ? t.querySelector(e) : e instanceof Element ? e : e[0];
    if (r) {
      const i = this.graph.view.findAttr("data-cell-id", r);
      if (i) {
        const o = this.schedule.views;
        if (o[i])
          return o[i].view;
      }
    }
    return null;
  }
  findViewByCell(e) {
    if (e == null)
      return null;
    const t = Qt.isCell(e) ? e.id : e, r = this.schedule.views;
    return r[t] ? r[t].view : null;
  }
  findViewsFromPoint(e) {
    const t = { x: e.x, y: e.y };
    return this.model.getCells().map((r) => this.findViewByCell(r)).filter((r) => r != null ? gn.getBBox(r.container, {
      target: this.view.stage
    }).containsPoint(t) : !1);
  }
  findEdgeViewsFromPoint(e, t = 5) {
    return this.model.getEdges().map((r) => this.findViewByCell(r)).filter((r) => {
      if (r != null) {
        const i = r.getClosestPoint(e);
        if (i)
          return i.distance(e) <= t;
      }
      return !1;
    });
  }
  findViewsInArea(e, t = {}) {
    const r = Te.create(e);
    return this.model.getCells().map((i) => this.findViewByCell(i)).filter((i) => {
      if (i) {
        if (t.nodeOnly && !i.isNodeView())
          return !1;
        const o = gn.getBBox(i.container, {
          target: this.view.stage
        });
        return o.width === 0 ? o.inflate(1, 0) : o.height === 0 && o.inflate(0, 1), t.strict ? r.containsRect(o) : r.isIntersectWithRect(o);
      }
      return !1;
    });
  }
  dispose() {
    this.schedule.dispose();
  }
};
sEe([
  Ur.dispose()
], wI.prototype, "dispose", null);
var v5 = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class R9 extends Ur {
  get cid() {
    return this.graph.view.cid;
  }
  get svg() {
    return this.view.svg;
  }
  get defs() {
    return this.view.defs;
  }
  isDefined(e) {
    return this.svg.getElementById(e) != null;
  }
  filter(e) {
    let t = e.id;
    const r = e.name;
    if (t || (t = `filter-${r}-${this.cid}-${w2(JSON.stringify(e))}`), !this.isDefined(t)) {
      const i = Tg.registry.get(r);
      if (i == null)
        return Tg.registry.onNotFound(r);
      const o = i(e.args || {}), a = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: "objectBoundingBox" }, e.attrs), { id: t });
      pt.create(Mn.sanitize(o), a).appendTo(this.defs);
    }
    return t;
  }
  gradient(e) {
    let t = e.id;
    const r = e.type;
    if (t || (t = `gradient-${r}-${this.cid}-${w2(JSON.stringify(e))}`), !this.isDefined(t)) {
      const o = e.stops.map((l) => {
        const u = l.opacity != null && Number.isFinite(l.opacity) ? l.opacity : 1;
        return `<stop offset="${l.offset}" stop-color="${l.color}" stop-opacity="${u}"/>`;
      }), a = `<${r}>${o.join("")}</${r}>`, s = Object.assign({ id: t }, e.attrs);
      pt.create(a, s).appendTo(this.defs);
    }
    return t;
  }
  marker(e) {
    const { id: t, refX: r, refY: i, markerUnits: o, markerOrient: a, tagName: s, children: l } = e, u = v5(e, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
    let c = t;
    if (c || (c = `marker-${this.cid}-${w2(JSON.stringify(e))}`), !this.isDefined(c)) {
      s !== "path" && delete u.d;
      const h = pt.create("marker", {
        refX: r,
        refY: i,
        id: c,
        overflow: "visible",
        orient: a ?? "auto",
        markerUnits: o || "userSpaceOnUse"
      }, l ? l.map((f) => {
        var { tagName: d } = f, p = v5(f, ["tagName"]);
        return pt.create(`${d}` || "path", i0(Object.assign(Object.assign({}, u), p)));
      }) : [pt.create(s || "path", i0(u))]);
      this.defs.appendChild(h.node);
    }
    return c;
  }
  remove(e) {
    const t = this.svg.getElementById(e);
    t && t.parentNode && t.parentNode.removeChild(t);
  }
}
class N9 extends Ur {
  getClientMatrix() {
    return Xr(this.view.stage.getScreenCTM());
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */
  getClientOffset() {
    const e = this.view.svg.getBoundingClientRect();
    return new G(e.left, e.top);
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */
  getPageOffset() {
    return this.getClientOffset().translate(window.scrollX, window.scrollY);
  }
  snapToGrid(e, t) {
    return (typeof e == "number" ? this.clientToLocalPoint(e, t) : this.clientToLocalPoint(e.x, e.y)).snapToGrid(this.graph.getGridSize());
  }
  localToGraphPoint(e, t) {
    const r = G.create(e, t);
    return gn.transformPoint(r, this.graph.matrix());
  }
  localToClientPoint(e, t) {
    const r = G.create(e, t);
    return gn.transformPoint(r, this.getClientMatrix());
  }
  localToPagePoint(e, t) {
    return (typeof e == "number" ? this.localToGraphPoint(e, t) : this.localToGraphPoint(e)).translate(this.getPageOffset());
  }
  localToGraphRect(e, t, r, i) {
    const o = Te.create(e, t, r, i);
    return gn.transformRectangle(o, this.graph.matrix());
  }
  localToClientRect(e, t, r, i) {
    const o = Te.create(e, t, r, i);
    return gn.transformRectangle(o, this.getClientMatrix());
  }
  localToPageRect(e, t, r, i) {
    return (typeof e == "number" ? this.localToGraphRect(e, t, r, i) : this.localToGraphRect(e)).translate(this.getPageOffset());
  }
  graphToLocalPoint(e, t) {
    const r = G.create(e, t);
    return gn.transformPoint(r, this.graph.matrix().inverse());
  }
  clientToLocalPoint(e, t) {
    const r = G.create(e, t);
    return gn.transformPoint(r, this.getClientMatrix().inverse());
  }
  clientToGraphPoint(e, t) {
    const r = G.create(e, t);
    return gn.transformPoint(r, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalPoint(e, t) {
    const i = G.create(e, t).diff(this.getPageOffset());
    return this.graphToLocalPoint(i);
  }
  graphToLocalRect(e, t, r, i) {
    const o = Te.create(e, t, r, i);
    return gn.transformRectangle(o, this.graph.matrix().inverse());
  }
  clientToLocalRect(e, t, r, i) {
    const o = Te.create(e, t, r, i);
    return gn.transformRectangle(o, this.getClientMatrix().inverse());
  }
  clientToGraphRect(e, t, r, i) {
    const o = Te.create(e, t, r, i);
    return gn.transformRectangle(o, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalRect(e, t, r, i) {
    const o = Te.create(e, t, r, i), a = this.getPageOffset();
    return o.x -= a.x, o.y -= a.y, this.graphToLocalRect(o);
  }
}
var lEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class Px extends Ur {
  constructor() {
    super(...arguments), this.highlights = {};
  }
  init() {
    this.startListening();
  }
  startListening() {
    this.graph.on("cell:highlight", this.onCellHighlight, this), this.graph.on("cell:unhighlight", this.onCellUnhighlight, this);
  }
  stopListening() {
    this.graph.off("cell:highlight", this.onCellHighlight, this), this.graph.off("cell:unhighlight", this.onCellUnhighlight, this);
  }
  onCellHighlight({ view: e, magnet: t, options: r = {} }) {
    const i = this.resolveHighlighter(r);
    if (!i)
      return;
    const o = this.getHighlighterId(t, i);
    if (!this.highlights[o]) {
      const a = i.highlighter;
      a.highlight(e, t, Object.assign({}, i.args)), this.highlights[o] = {
        cellView: e,
        magnet: t,
        highlighter: a,
        args: i.args
      };
    }
  }
  onCellUnhighlight({ magnet: e, options: t = {} }) {
    const r = this.resolveHighlighter(t);
    if (!r)
      return;
    const i = this.getHighlighterId(e, r);
    this.unhighlight(i);
  }
  resolveHighlighter(e) {
    const t = this.options;
    let r = e.highlighter;
    if (r == null) {
      const s = e.type;
      r = s && t.highlighting[s] || t.highlighting.default;
    }
    if (r == null)
      return null;
    const i = typeof r == "string" ? {
      name: r
    } : r, o = i.name, a = Kl.registry.get(o);
    return a == null ? Kl.registry.onNotFound(o) : (Kl.check(o, a), {
      name: o,
      highlighter: a,
      args: i.args || {}
    });
  }
  getHighlighterId(e, t) {
    return sI(e), t.name + e.id + JSON.stringify(t.args);
  }
  unhighlight(e) {
    const t = this.highlights[e];
    t && (t.highlighter.unhighlight(t.cellView, t.magnet, t.args), delete this.highlights[e]);
  }
  dispose() {
    Object.keys(this.highlights).forEach((e) => this.unhighlight(e)), this.stopListening();
  }
}
lEe([
  Px.dispose()
], Px.prototype, "dispose", null);
var uEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class $9 extends Ur {
  getScroller() {
    const e = this.graph.getPlugin("scroller");
    return e && e.options.enabled ? e : null;
  }
  getContainer() {
    const e = this.getScroller();
    return e ? e.container.parentElement : this.graph.container.parentElement;
  }
  getSensorTarget() {
    const e = this.options.autoResize;
    if (e)
      return typeof e == "boolean" ? this.getContainer() : e;
  }
  init() {
    if (this.options.autoResize) {
      const t = this.getSensorTarget();
      t && bx.bind(t, () => {
        const r = t.offsetWidth, i = t.offsetHeight;
        this.resize(r, i);
      });
    }
  }
  resize(e, t) {
    const r = this.getScroller();
    r ? r.resize(e, t) : this.graph.transform.resize(e, t);
  }
  dispose() {
    bx.clear(this.graph.container);
  }
}
uEe([
  Ur.dispose()
], $9.prototype, "dispose", null);
var cEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
let Ie = class B9 extends Yn {
  get container() {
    return this.options.container;
  }
  get [Symbol.toStringTag]() {
    return B9.toStringTag;
  }
  constructor(e) {
    super(), this.installedPlugins = /* @__PURE__ */ new Set(), this.options = f0.get(e), this.css = new qP(this), this.view = new nd(this), this.defs = new R9(this), this.coord = new N9(this), this.transform = new L9(this), this.highlight = new Px(this), this.grid = new mI(this), this.background = new yI(this), this.options.model ? this.model = this.options.model : (this.model = new Ol(), this.model.graph = this), this.renderer = new wI(this), this.panning = new bI(this), this.mousewheel = new OI(this), this.virtualRender = new I9(this), this.size = new $9(this);
  }
  // #region model
  isNode(e) {
    return e.isNode();
  }
  isEdge(e) {
    return e.isEdge();
  }
  resetCells(e, t = {}) {
    return this.model.resetCells(e, t), this;
  }
  clearCells(e = {}) {
    return this.model.clear(e), this;
  }
  toJSON(e = {}) {
    return this.model.toJSON(e);
  }
  parseJSON(e) {
    return this.model.parseJSON(e);
  }
  fromJSON(e, t = {}) {
    return this.model.fromJSON(e, t), this;
  }
  getCellById(e) {
    return this.model.getCell(e);
  }
  addNode(e, t = {}) {
    return this.model.addNode(e, t);
  }
  addNodes(e, t = {}) {
    return this.addCell(e.map((r) => gr.isNode(r) ? r : this.createNode(r)), t);
  }
  createNode(e) {
    return this.model.createNode(e);
  }
  removeNode(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  addEdge(e, t = {}) {
    return this.model.addEdge(e, t);
  }
  addEdges(e, t = {}) {
    return this.addCell(e.map((r) => rr.isEdge(r) ? r : this.createEdge(r)), t);
  }
  removeEdge(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  createEdge(e) {
    return this.model.createEdge(e);
  }
  addCell(e, t = {}) {
    return this.model.addCell(e, t), this;
  }
  removeCell(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  removeCells(e, t = {}) {
    return this.model.removeCells(e, t);
  }
  removeConnectedEdges(e, t = {}) {
    return this.model.removeConnectedEdges(e, t);
  }
  disconnectConnectedEdges(e, t = {}) {
    return this.model.disconnectConnectedEdges(e, t), this;
  }
  hasCell(e) {
    return this.model.has(e);
  }
  getCells() {
    return this.model.getCells();
  }
  getCellCount() {
    return this.model.total();
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.model.getNodes();
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.model.getEdges();
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    return this.model.getOutgoingEdges(e);
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    return this.model.getIncomingEdges(e);
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    return this.model.getConnectedEdges(e, t);
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRootNodes() {
    return this.model.getRoots();
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafNodes() {
    return this.model.getLeafs();
  }
  /**
   * Returns `true` if the node is a root node, i.e.
   * there is no  edges coming to the node.
   */
  isRootNode(e) {
    return this.model.isRoot(e);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e.
   * there is no edges going out from the node.
   */
  isLeafNode(e) {
    return this.model.isLeaf(e);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    return this.model.getNeighbors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, r = {}) {
    return this.model.isNeighbor(e, t, r);
  }
  getSuccessors(e, t = {}) {
    return this.model.getSuccessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, r = {}) {
    return this.model.isSuccessor(e, t, r);
  }
  getPredecessors(e, t = {}) {
    return this.model.getPredecessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, r = {}) {
    return this.model.isPredecessor(e, t, r);
  }
  getCommonAncestor(...e) {
    return this.model.getCommonAncestor(...e);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    return this.model.getSubGraph(e, t);
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    return this.model.cloneSubGraph(e, t);
  }
  cloneCells(e) {
    return this.model.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    return this.model.getNodesFromPoint(e, t);
  }
  getNodesInArea(e, t, r, i, o) {
    return this.model.getNodesInArea(e, t, r, i, o);
  }
  getNodesUnderNode(e, t = {}) {
    return this.model.getNodesUnderNode(e, t);
  }
  searchCell(e, t, r = {}) {
    return this.model.search(e, t, r), this;
  }
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, r = {}) {
    return this.model.getShortestPath(e, t, r);
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.model.getAllCellsBBox();
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return this.model.getCellsBBox(e, t);
  }
  startBatch(e, t = {}) {
    this.model.startBatch(e, t);
  }
  stopBatch(e, t = {}) {
    this.model.stopBatch(e, t);
  }
  batchUpdate(e, t, r) {
    const i = typeof e == "string" ? e : "update", o = typeof e == "string" ? t : e, a = typeof t == "function" ? r : t;
    this.startBatch(i, a);
    const s = o();
    return this.stopBatch(i, a), s;
  }
  updateCellId(e, t) {
    return this.model.updateCellId(e, t);
  }
  // #endregion
  // #region view
  findView(e) {
    return Qt.isCell(e) ? this.findViewByCell(e) : this.findViewByElem(e);
  }
  findViews(e) {
    return Te.isRectangleLike(e) ? this.findViewsInArea(e) : G.isPointLike(e) ? this.findViewsFromPoint(e) : [];
  }
  findViewByCell(e) {
    return this.renderer.findViewByCell(e);
  }
  findViewByElem(e) {
    return this.renderer.findViewByElem(e);
  }
  findViewsFromPoint(e, t) {
    const r = typeof e == "number" ? { x: e, y: t } : e;
    return this.renderer.findViewsFromPoint(r);
  }
  findViewsInArea(e, t, r, i, o) {
    const a = typeof e == "number" ? {
      x: e,
      y: t,
      width: r,
      height: i
    } : e, s = typeof e == "number" ? o : t;
    return this.renderer.findViewsInArea(a, s);
  }
  matrix(e) {
    return typeof e > "u" ? this.transform.getMatrix() : (this.transform.setMatrix(e), this);
  }
  resize(e, t) {
    const r = this.getPlugin("scroller");
    return r ? r.resize(e, t) : this.transform.resize(e, t), this;
  }
  scale(e, t = e, r = 0, i = 0) {
    return typeof e > "u" ? this.transform.getScale() : (this.transform.scale(e, t, r, i), this);
  }
  zoom(e, t) {
    const r = this.getPlugin("scroller");
    if (r) {
      if (typeof e > "u")
        return r.zoom();
      r.zoom(e, t);
    } else {
      if (typeof e > "u")
        return this.transform.getZoom();
      this.transform.zoom(e, t);
    }
    return this;
  }
  zoomTo(e, t = {}) {
    const r = this.getPlugin("scroller");
    return r ? r.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })) : this.transform.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })), this;
  }
  zoomToRect(e, t = {}) {
    const r = this.getPlugin("scroller");
    return r ? r.zoomToRect(e, t) : this.transform.zoomToRect(e, t), this;
  }
  zoomToFit(e = {}) {
    const t = this.getPlugin("scroller");
    return t ? t.zoomToFit(e) : this.transform.zoomToFit(e), this;
  }
  rotate(e, t, r) {
    return typeof e > "u" ? this.transform.getRotation() : (this.transform.rotate(e, t, r), this);
  }
  translate(e, t) {
    return typeof e > "u" ? this.transform.getTranslation() : (this.transform.translate(e, t), this);
  }
  translateBy(e, t) {
    const r = this.translate(), i = r.tx + e, o = r.ty + t;
    return this.translate(i, o);
  }
  getGraphArea() {
    return this.transform.getGraphArea();
  }
  getContentArea(e = {}) {
    return this.transform.getContentArea(e);
  }
  getContentBBox(e = {}) {
    return this.transform.getContentBBox(e);
  }
  fitToContent(e, t, r, i) {
    return this.transform.fitToContent(e, t, r, i);
  }
  scaleContentToFit(e = {}) {
    return this.transform.scaleContentToFit(e), this;
  }
  /**
   * Position the center of graph to the center of the viewport.
   */
  center(e) {
    return this.centerPoint(e);
  }
  centerPoint(e, t, r) {
    const i = this.getPlugin("scroller");
    return i ? i.centerPoint(e, t, r) : this.transform.centerPoint(e, t), this;
  }
  centerContent(e) {
    const t = this.getPlugin("scroller");
    return t ? t.centerContent(e) : this.transform.centerContent(e), this;
  }
  centerCell(e, t) {
    const r = this.getPlugin("scroller");
    return r ? r.centerCell(e, t) : this.transform.centerCell(e), this;
  }
  positionPoint(e, t, r, i = {}) {
    const o = this.getPlugin("scroller");
    return o ? o.positionPoint(e, t, r, i) : this.transform.positionPoint(e, t, r), this;
  }
  positionRect(e, t, r) {
    const i = this.getPlugin("scroller");
    return i ? i.positionRect(e, t, r) : this.transform.positionRect(e, t), this;
  }
  positionCell(e, t, r) {
    const i = this.getPlugin("scroller");
    return i ? i.positionCell(e, t, r) : this.transform.positionCell(e, t), this;
  }
  positionContent(e, t) {
    const r = this.getPlugin("scroller");
    return r ? r.positionContent(e, t) : this.transform.positionContent(e, t), this;
  }
  snapToGrid(e, t) {
    return this.coord.snapToGrid(e, t);
  }
  pageToLocal(e, t, r, i) {
    return Te.isRectangleLike(e) ? this.coord.pageToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof i == "number" ? this.coord.pageToLocalRect(e, t, r, i) : this.coord.pageToLocalPoint(e, t);
  }
  localToPage(e, t, r, i) {
    return Te.isRectangleLike(e) ? this.coord.localToPageRect(e) : typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof i == "number" ? this.coord.localToPageRect(e, t, r, i) : this.coord.localToPagePoint(e, t);
  }
  clientToLocal(e, t, r, i) {
    return Te.isRectangleLike(e) ? this.coord.clientToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof i == "number" ? this.coord.clientToLocalRect(e, t, r, i) : this.coord.clientToLocalPoint(e, t);
  }
  localToClient(e, t, r, i) {
    return Te.isRectangleLike(e) ? this.coord.localToClientRect(e) : typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof i == "number" ? this.coord.localToClientRect(e, t, r, i) : this.coord.localToClientPoint(e, t);
  }
  localToGraph(e, t, r, i) {
    return Te.isRectangleLike(e) ? this.coord.localToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof i == "number" ? this.coord.localToGraphRect(e, t, r, i) : this.coord.localToGraphPoint(e, t);
  }
  graphToLocal(e, t, r, i) {
    return Te.isRectangleLike(e) ? this.coord.graphToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof i == "number" ? this.coord.graphToLocalRect(e, t, r, i) : this.coord.graphToLocalPoint(e, t);
  }
  clientToGraph(e, t, r, i) {
    return Te.isRectangleLike(e) ? this.coord.clientToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof i == "number" ? this.coord.clientToGraphRect(e, t, r, i) : this.coord.clientToGraphPoint(e, t);
  }
  // #endregion
  // #region defs
  defineFilter(e) {
    return this.defs.filter(e);
  }
  defineGradient(e) {
    return this.defs.gradient(e);
  }
  defineMarker(e) {
    return this.defs.marker(e);
  }
  // #endregion
  // #region grid
  getGridSize() {
    return this.grid.getGridSize();
  }
  setGridSize(e) {
    return this.grid.setGridSize(e), this;
  }
  showGrid() {
    return this.grid.show(), this;
  }
  hideGrid() {
    return this.grid.hide(), this;
  }
  clearGrid() {
    return this.grid.clear(), this;
  }
  drawGrid(e) {
    return this.grid.draw(e), this;
  }
  // #endregion
  // #region background
  updateBackground() {
    return this.background.update(), this;
  }
  drawBackground(e, t) {
    const r = this.getPlugin("scroller");
    return r != null && (this.options.background == null || !t) ? r.drawBackground(e, t) : this.background.draw(e), this;
  }
  clearBackground(e) {
    const t = this.getPlugin("scroller");
    return t != null && (this.options.background == null || !e) ? t.clearBackground(e) : this.background.clear(), this;
  }
  // #endregion
  // #region virtual-render
  enableVirtualRender() {
    return this.virtualRender.enableVirtualRender(), this;
  }
  disableVirtualRender() {
    return this.virtualRender.disableVirtualRender(), this;
  }
  // #endregion
  // #region mousewheel
  isMouseWheelEnabled() {
    return !this.mousewheel.disabled;
  }
  enableMouseWheel() {
    return this.mousewheel.enable(), this;
  }
  disableMouseWheel() {
    return this.mousewheel.disable(), this;
  }
  toggleMouseWheel(e) {
    return e == null ? this.isMouseWheelEnabled() ? this.disableMouseWheel() : this.enableMouseWheel() : e ? this.enableMouseWheel() : this.disableMouseWheel(), this;
  }
  // #endregion
  // #region panning
  isPannable() {
    const e = this.getPlugin("scroller");
    return e ? e.isPannable() : this.panning.pannable;
  }
  enablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.enablePanning() : this.panning.enablePanning(), this;
  }
  disablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.disablePanning() : this.panning.disablePanning(), this;
  }
  togglePanning(e) {
    return e == null ? this.isPannable() ? this.disablePanning() : this.enablePanning() : e !== this.isPannable() && (e ? this.enablePanning() : this.disablePanning()), this;
  }
  // #endregion
  // #region plugin
  use(e, ...t) {
    return this.installedPlugins.has(e) || (this.installedPlugins.add(e), e.init(this, ...t)), this;
  }
  getPlugin(e) {
    return Array.from(this.installedPlugins).find((t) => t.name === e);
  }
  getPlugins(e) {
    return Array.from(this.installedPlugins).filter((t) => e.includes(t.name));
  }
  enablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const r = this.getPlugins(t);
    return r == null || r.forEach((i) => {
      var o;
      (o = i == null ? void 0 : i.enable) === null || o === void 0 || o.call(i);
    }), this;
  }
  disablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const r = this.getPlugins(t);
    return r == null || r.forEach((i) => {
      var o;
      (o = i == null ? void 0 : i.disable) === null || o === void 0 || o.call(i);
    }), this;
  }
  isPluginEnabled(e) {
    var t;
    const r = this.getPlugin(e);
    return (t = r == null ? void 0 : r.isEnabled) === null || t === void 0 ? void 0 : t.call(r);
  }
  disposePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const r = this.getPlugins(t);
    return r == null || r.forEach((i) => {
      i.dispose(), this.installedPlugins.delete(i);
    }), this;
  }
  // #endregion
  // #region dispose
  dispose(e = !0) {
    e && this.model.dispose(), this.css.dispose(), this.defs.dispose(), this.grid.dispose(), this.coord.dispose(), this.transform.dispose(), this.highlight.dispose(), this.background.dispose(), this.mousewheel.dispose(), this.panning.dispose(), this.view.dispose(), this.renderer.dispose(), this.installedPlugins.forEach((t) => {
      t.dispose();
    });
  }
};
cEe([
  Yn.dispose()
], Ie.prototype, "dispose", null);
(function(n) {
  n.View = nd, n.Renderer = wI, n.MouseWheel = OI, n.DefsManager = R9, n.GridManager = mI, n.CoordManager = N9, n.TransformManager = L9, n.HighlightManager = Px, n.BackgroundManager = yI, n.PanningManager = bI;
})(Ie || (Ie = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const r = t[Symbol.toStringTag];
    return r == null || r === n.toStringTag;
  }
  n.isGraph = e;
})(Ie || (Ie = {}));
(function(n) {
  function e(t, r) {
    const i = t instanceof HTMLElement ? new n({ container: t }) : new n(t);
    return r != null && i.fromJSON(r), i;
  }
  n.render = e;
})(Ie || (Ie = {}));
(function(n) {
  n.registerNode = gr.registry.register, n.registerEdge = rr.registry.register, n.registerView = fr.registry.register, n.registerAttr = bl.registry.register, n.registerGrid = sc.registry.register, n.registerFilter = Tg.registry.register, n.registerNodeTool = Eg.registry.register, n.registerEdgeTool = Mg.registry.register, n.registerBackground = l0.registry.register, n.registerHighlighter = Kl.registry.register, n.registerPortLayout = Rf.registry.register, n.registerPortLabelLayout = kg.registry.register, n.registerMarker = Nc.registry.register, n.registerRouter = lc.registry.register, n.registerConnector = Nf.registry.register, n.registerAnchor = Dg.registry.register, n.registerEdgeAnchor = Lg.registry.register, n.registerConnectionPoint = Ig.registry.register;
})(Ie || (Ie = {}));
(function(n) {
  n.unregisterNode = gr.registry.unregister, n.unregisterEdge = rr.registry.unregister, n.unregisterView = fr.registry.unregister, n.unregisterAttr = bl.registry.unregister, n.unregisterGrid = sc.registry.unregister, n.unregisterFilter = Tg.registry.unregister, n.unregisterNodeTool = Eg.registry.unregister, n.unregisterEdgeTool = Mg.registry.unregister, n.unregisterBackground = l0.registry.unregister, n.unregisterHighlighter = Kl.registry.unregister, n.unregisterPortLayout = Rf.registry.unregister, n.unregisterPortLabelLayout = kg.registry.unregister, n.unregisterMarker = Nc.registry.unregister, n.unregisterRouter = lc.registry.unregister, n.unregisterConnector = Nf.registry.unregister, n.unregisterAnchor = Dg.registry.unregister, n.unregisterEdgeAnchor = Lg.registry.unregister, n.unregisterConnectionPoint = Ig.registry.unregister;
})(Ie || (Ie = {}));
var hEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
}, fEe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class Bg extends gr {
}
(function(n) {
  class e extends Uo {
    init() {
      super.init(), this.cell.on("change:*", this.onCellChangeAny, this);
    }
    onCellChangeAny({ key: r }) {
      const i = n.shapeMaps[this.cell.shape];
      if (i) {
        const { effect: o } = i;
        (!o || o.includes(r)) && this.renderHTMLComponent();
      }
    }
    confirmUpdate(r) {
      const i = super.confirmUpdate(r);
      return this.handleAction(i, e.action, () => this.renderHTMLComponent());
    }
    renderHTMLComponent() {
      const r = this.selectors && this.selectors.foContent;
      if (r) {
        Sb(r);
        const i = n.shapeMaps[this.cell.shape];
        if (!i)
          return;
        let { html: o } = i;
        typeof o == "function" && (o = o(this.cell)), o && (typeof o == "string" ? r.innerHTML = o : sh(r, o));
      }
    }
    dispose() {
      this.cell.off("change:*", this.onCellChangeAny, this);
    }
  }
  hEe([
    e.dispose()
  ], e.prototype, "dispose", null), n.View = e, function(t) {
    t.action = "html", t.config({
      bootstrap: [t.action],
      actions: {
        html: t.action
      }
    }), Uo.registry.register("html-view", t, !0);
  }(e = n.View || (n.View = {}));
})(Bg || (Bg = {}));
(function(n) {
  n.config({
    view: "html-view",
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      Object.assign({}, Mn.getForeignObjectMarkup()),
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    }
  }), gr.registry.register("html", n, !0);
})(Bg || (Bg = {}));
(function(n) {
  n.shapeMaps = {};
  function e(t) {
    const { shape: r, html: i, effect: o, inherit: a } = t, s = fEe(t, ["shape", "html", "effect", "inherit"]);
    if (!r)
      throw new Error("should specify shape in config");
    n.shapeMaps[r] = {
      html: i,
      effect: o
    }, Ie.registerNode(r, Object.assign({ inherit: a || "html" }, s), !0);
  }
  n.register = e;
})(Bg || (Bg = {}));
class m5 extends gr {
}
(function(n) {
  function e(t) {
    const r = [], i = Mn.getForeignObjectMarkup();
    return t ? r.push({
      tagName: t,
      selector: "body"
    }, i) : r.push(i), r;
  }
  n.config({
    view: "vue-shape-view",
    markup: e(),
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    },
    propHooks(t) {
      if (t.markup == null) {
        const r = t.primer;
        if (r) {
          t.markup = e(r);
          let i = {};
          switch (r) {
            case "circle":
              i = {
                refCx: "50%",
                refCy: "50%",
                refR: "50%"
              };
              break;
            case "ellipse":
              i = {
                refCx: "50%",
                refCy: "50%",
                refRx: "50%",
                refRy: "50%"
              };
              break;
          }
          t.attrs = er({}, {
            body: Object.assign({ refWidth: null, refHeight: null }, i)
          }, t.attrs || {});
        }
      }
      return t;
    }
  }), gr.registry.register("vue-shape", n, !0);
})(m5 || (m5 = {}));
var dEe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const V9 = {};
function N6t(n) {
  const { shape: e, component: t, inherit: r } = n, i = dEe(n, ["shape", "component", "inherit"]);
  if (!e)
    throw new Error("should specify shape in config");
  V9[e] = {
    component: t
  }, Ie.registerNode(e, Object.assign({ inherit: r || "vue-shape" }, i), !0);
}
let N_ = !1;
const Ex = dr({});
function pEe(n, e, t, r, i) {
  N_ && (Ex[n] = hae(U({
    render: () => et(a_, { to: t }, [et(e, { node: r, graph: i })]),
    provide: () => ({
      getNode: () => r,
      getGraph: () => i
    })
  })));
}
function y5(n) {
  N_ && delete Ex[n];
}
function b5() {
  return N_;
}
function $6t() {
  return N_ = !0, U({
    setup() {
      return () => et(yn, {}, Object.keys(Ex).map((n) => et(Ex[n])));
    }
  });
}
class Mx extends Uo {
  getComponentContainer() {
    return this.selectors && this.selectors.foContent;
  }
  confirmUpdate(e) {
    const t = super.confirmUpdate(e);
    return this.handleAction(t, Mx.action, () => {
      this.renderVueComponent();
    });
  }
  targetId() {
    return `${this.graph.view.cid}:${this.cell.id}`;
  }
  renderVueComponent() {
    console.log("======renderVueComponent====>1"), this.unmountVueComponent();
    const e = this.getComponentContainer(), t = this.cell, r = this.graph;
    if (e) {
      const { component: i } = V9[t.shape];
      i && (b5() ? (y5(this.targetId()), pEe(this.targetId(), i, e, t, r)) : (this.vm = fae({
        render() {
          return et(i, { node: t, graph: r });
        },
        provide() {
          return {
            getNode: () => t,
            getGraph: () => r
          };
        }
      }), this.vm.mount(e)));
    }
  }
  unmountVueComponent() {
    const e = this.getComponentContainer();
    return this.vm && (this.vm.unmount(), this.vm = null), e && (e.innerHTML = ""), e;
  }
  onMouseDown(e, t, r) {
    const i = e.target;
    if (i.tagName.toLowerCase() === "input") {
      const a = i.getAttribute("type");
      if (a == null || [
        "text",
        "password",
        "number",
        "email",
        "search",
        "tel",
        "url"
      ].includes(a))
        return;
    }
    super.onMouseDown(e, t, r);
  }
  unmount() {
    return b5() && y5(this.targetId()), this.unmountVueComponent(), super.unmount(), this;
  }
}
(function(n) {
  n.action = "vue", n.config({
    bootstrap: [n.action],
    actions: {
      component: n.action
    }
  }), Uo.registry.register("vue-shape-view", n, !0);
})(Mx || (Mx = {}));
const gEe = `.x6-widget-dnd {
  position: absolute;
  top: -10000px;
  left: -10000px;
  z-index: 999999;
  display: none;
  cursor: move;
  opacity: 0.7;
  pointer-events: 'cursor';
}
.x6-widget-dnd.dragging {
  display: inline-block;
}
.x6-widget-dnd.dragging * {
  pointer-events: none !important;
}
.x6-widget-dnd .x6-graph {
  background: transparent;
  box-shadow: none;
}
`;
var vEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class Vg extends Dn {
  get targetScroller() {
    return this.options.target.getPlugin("scroller");
  }
  get targetGraph() {
    return this.options.target;
  }
  get targetModel() {
    return this.targetGraph.model;
  }
  get snapline() {
    return this.options.target.getPlugin("snapline");
  }
  constructor(e) {
    super(), this.name = "dnd", this.options = Object.assign(Object.assign({}, Vg.defaults), e), this.init();
  }
  init() {
    T_(this.name, gEe), this.container = document.createElement("div"), lt(this.container, this.prefixClassName("widget-dnd")), this.draggingGraph = new Ie(Object.assign(Object.assign({}, this.options.delegateGraphOptions), { container: document.createElement("div"), width: 1, height: 1, async: !1 })), sh(this.container, this.draggingGraph.container);
  }
  start(e, t) {
    const r = t;
    r.preventDefault(), this.targetModel.startBatch("dnd"), lt(this.container, "dragging"), vy(this.container, this.options.draggingContainer || document.body), this.sourceNode = e, this.prepareDragging(e, r.clientX, r.clientY);
    const i = this.updateNodePosition(r.clientX, r.clientY);
    this.isSnaplineEnabled() && (this.snapline.captureCursorOffset({
      e: r,
      node: e,
      cell: e,
      view: this.draggingView,
      x: i.x,
      y: i.y
    }), this.draggingNode.on("change:position", this.snap, this)), this.delegateDocumentEvents(Vg.documentEvents, r.data);
  }
  isSnaplineEnabled() {
    return this.snapline && this.snapline.isEnabled();
  }
  prepareDragging(e, t, r) {
    const i = this.draggingGraph, o = i.model, a = this.options.getDragNode(e, {
      sourceNode: e,
      draggingGraph: i,
      targetGraph: this.targetGraph
    });
    a.position(0, 0);
    let s = 5;
    if (this.isSnaplineEnabled() && (s += this.snapline.options.tolerance || 0), this.isSnaplineEnabled() || this.options.scaled) {
      const c = this.targetGraph.transform.getScale();
      i.scale(c.sx, c.sy), s *= Math.max(c.sx, c.sy);
    } else
      i.scale(1, 1);
    this.clearDragging(), o.resetCells([a]);
    const l = i.findViewByCell(a);
    l.undelegateEvents(), l.cell.off("changed"), i.fitToContent({
      padding: s,
      allowNewOrigin: "any",
      useCellGeometry: !1
    });
    const u = l.getBBox();
    this.geometryBBox = l.getBBox({ useCellGeometry: !0 }), this.delta = this.geometryBBox.getTopLeft().diff(u.getTopLeft()), this.draggingNode = a, this.draggingView = l, this.draggingBBox = a.getBBox(), this.padding = s, this.originOffset = this.updateGraphPosition(t, r);
  }
  updateGraphPosition(e, t) {
    const r = document.body.scrollTop || document.documentElement.scrollTop, i = document.body.scrollLeft || document.documentElement.scrollLeft, o = this.delta, a = this.geometryBBox, s = this.padding || 5, l = {
      left: e - o.x - a.width / 2 - s + i,
      top: t - o.y - a.height / 2 - s + r
    };
    return this.draggingGraph && Mr(this.container, {
      left: `${l.left}px`,
      top: `${l.top}px`
    }), l;
  }
  updateNodePosition(e, t) {
    const r = this.targetGraph.clientToLocal(e, t), i = this.draggingBBox;
    return r.x -= i.width / 2, r.y -= i.height / 2, this.draggingNode.position(r.x, r.y), r;
  }
  snap({ cell: e, current: t, options: r }) {
    const i = e;
    if (r.snapped) {
      const o = this.draggingBBox;
      i.position(o.x + r.tx, o.y + r.ty, { silent: !0 }), this.draggingView.translate(), i.position(t.x, t.y, { silent: !0 }), this.snapOffset = {
        x: r.tx,
        y: r.ty
      };
    } else
      this.snapOffset = null;
  }
  onDragging(e) {
    const t = this.draggingView;
    if (t) {
      e.preventDefault();
      const r = this.normalizeEvent(e), i = r.clientX, o = r.clientY;
      this.updateGraphPosition(i, o);
      const a = this.updateNodePosition(i, o), s = this.targetGraph.options.embedding.enabled, l = (s || this.isSnaplineEnabled()) && this.isInsideValidArea({
        x: i,
        y: o
      });
      if (s) {
        t.setEventData(r, {
          graph: this.targetGraph,
          candidateEmbedView: this.candidateEmbedView
        });
        const u = t.getEventData(r);
        l ? t.processEmbedding(r, u) : t.clearEmbedding(u), this.candidateEmbedView = u.candidateEmbedView;
      }
      this.isSnaplineEnabled() && (l ? this.snapline.snapOnMoving({
        e: r,
        view: t,
        x: a.x,
        y: a.y
      }) : this.snapline.hide());
    }
  }
  onDragEnd(e) {
    const t = this.draggingNode;
    if (t) {
      const r = this.normalizeEvent(e), i = this.draggingView, o = this.draggingBBox, a = this.snapOffset;
      let s = o.x, l = o.y;
      a && (s += a.x, l += a.y), t.position(s, l, { silent: !0 });
      const u = this.drop(t, { x: r.clientX, y: r.clientY }), c = (h) => {
        h ? (this.onDropped(t), this.targetGraph.options.embedding.enabled && i && (i.setEventData(r, {
          cell: h,
          graph: this.targetGraph,
          candidateEmbedView: this.candidateEmbedView
        }), i.finalizeEmbedding(r, i.getEventData(r)))) : this.onDropInvalid(), this.candidateEmbedView = null, this.targetModel.stopBatch("dnd");
      };
      LP(u) ? (this.undelegateDocumentEvents(), u.then(c)) : c(u);
    }
  }
  clearDragging() {
    this.draggingNode && (this.sourceNode = null, this.draggingNode.remove(), this.draggingNode = null, this.draggingView = null, this.delta = null, this.padding = null, this.snapOffset = null, this.originOffset = null, this.undelegateDocumentEvents());
  }
  onDropped(e) {
    this.draggingNode === e && (this.clearDragging(), br(this.container, "dragging"), cl(this.container));
  }
  onDropInvalid() {
    const e = this.draggingNode;
    e && this.onDropped(e);
  }
  isInsideValidArea(e) {
    let t, r = null;
    const i = this.targetGraph, o = this.targetScroller;
    this.options.dndContainer && (r = this.getDropArea(this.options.dndContainer));
    const a = r && r.containsPoint(e);
    if (o)
      if (o.options.autoResize)
        t = this.getDropArea(o.container);
      else {
        const s = this.getDropArea(o.container);
        t = this.getDropArea(i.container).intersectsWithRect(s);
      }
    else
      t = this.getDropArea(i.container);
    return !a && t && t.containsPoint(e);
  }
  getDropArea(e) {
    const t = VP(e), r = document.body.scrollTop || document.documentElement.scrollTop, i = document.body.scrollLeft || document.documentElement.scrollLeft;
    return Te.create({
      x: t.left + parseInt(Mr(e, "border-left-width"), 10) - i,
      y: t.top + parseInt(Mr(e, "border-top-width"), 10) - r,
      width: e.clientWidth,
      height: e.clientHeight
    });
  }
  drop(e, t) {
    if (this.isInsideValidArea(t)) {
      const r = this.targetGraph, i = r.model, o = r.clientToLocal(t), a = this.sourceNode, s = this.options.getDropNode(e, {
        sourceNode: a,
        draggingNode: e,
        targetGraph: this.targetGraph,
        draggingGraph: this.draggingGraph
      }), l = s.getBBox();
      o.x += l.x - l.width / 2, o.y += l.y - l.height / 2;
      const u = this.snapOffset ? 1 : r.getGridSize();
      s.position(rn.snapToGrid(o.x, u), rn.snapToGrid(o.y, u)), s.removeZIndex();
      const c = this.options.validateNode, h = c ? c(s, {
        sourceNode: a,
        draggingNode: e,
        droppingNode: s,
        targetGraph: r,
        draggingGraph: this.draggingGraph
      }) : !0;
      return typeof h == "boolean" ? h ? (i.addCell(s, { stencil: this.cid }), s) : null : a2e(h).then((f) => f ? (i.addCell(s, { stencil: this.cid }), s) : null);
    }
    return null;
  }
  onRemove() {
    this.draggingGraph && (this.draggingGraph.view.remove(), this.draggingGraph.dispose());
  }
  dispose() {
    this.remove(), k_(this.name);
  }
}
vEe([
  Dn.dispose()
], Vg.prototype, "dispose", null);
(function(n) {
  n.defaults = {
    // animation: false,
    getDragNode: (e) => e.clone(),
    getDropNode: (e) => e.clone()
  }, n.documentEvents = {
    mousemove: "onDragging",
    touchmove: "onDragging",
    mouseup: "onDragEnd",
    touchend: "onDragEnd",
    touchcancel: "onDragEnd"
  };
})(Vg || (Vg = {}));
var mEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class z9 extends Dn {
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.renderer.findViewByCell(this.node);
  }
  get containerClassName() {
    return this.prefixClassName("widget-transform");
  }
  get resizeClassName() {
    return `${this.containerClassName}-resize`;
  }
  get rotateClassName() {
    return `${this.containerClassName}-rotate`;
  }
  constructor(e, t, r) {
    super(), this.node = t, this.graph = r, this.options = Object.assign(Object.assign({}, kr.defaultOptions), e), this.render(), this.startListening();
  }
  startListening() {
    this.delegateEvents({
      [`mousedown .${this.resizeClassName}`]: "startResizing",
      [`touchstart .${this.resizeClassName}`]: "startResizing",
      [`mousedown .${this.rotateClassName}`]: "startRotating",
      [`touchstart .${this.rotateClassName}`]: "startRotating"
    }), this.model.on("*", this.update, this), this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this), this.node.on("removed", this.remove, this), this.model.on("reseted", this.remove, this), this.view.on("cell:knob:mousedown", this.onKnobMouseDown, this), this.view.on("cell:knob:mouseup", this.onKnobMouseUp, this);
  }
  stopListening() {
    this.undelegateEvents(), this.model.off("*", this.update, this), this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this), this.node.off("removed", this.remove, this), this.model.off("reseted", this.remove, this), this.view.off("cell:knob:mousedown", this.onKnobMouseDown, this), this.view.off("cell:knob:mouseup", this.onKnobMouseUp, this);
  }
  renderHandles() {
    this.container = document.createElement("div");
    const e = document.createElement("div");
    Xt(e, "draggable", "false");
    const t = e.cloneNode(!0);
    lt(t, this.rotateClassName);
    const r = kr.POSITIONS.map((i) => {
      const o = e.cloneNode(!0);
      return lt(o, this.resizeClassName), Xt(o, "data-position", i), o;
    });
    this.empty(), sh(this.container, [...r, t]);
  }
  render() {
    return this.renderHandles(), this.view && this.view.addClass(kr.NODE_CLS), lt(this.container, this.containerClassName), gy(this.container, "no-orth-resize", this.options.preserveAspectRatio || !this.options.orthogonalResizing), gy(this.container, "no-resize", !this.options.resizable), gy(this.container, "no-rotate", !this.options.rotatable), this.options.className && lt(this.container, this.options.className), this.graph.container.appendChild(this.container), this.update();
  }
  update() {
    const e = this.graph.matrix(), t = this.node.getBBox();
    t.x *= e.a, t.x += e.e, t.y *= e.d, t.y += e.f, t.width *= e.a, t.height *= e.d;
    const r = Jt.normalize(this.node.getAngle()), i = r !== 0 ? `rotate(${r}deg)` : "";
    return Mr(this.container, {
      transform: i,
      width: t.width,
      height: t.height,
      left: t.x,
      top: t.y
    }), this.updateResizerDirections(), this;
  }
  remove() {
    return this.view && this.view.removeClass(kr.NODE_CLS), super.remove();
  }
  onKnobMouseDown() {
    this.startHandle();
  }
  onKnobMouseUp() {
    this.stopHandle();
  }
  updateResizerDirections() {
    const e = Jt.normalize(this.node.getAngle()), t = Math.floor(e * (kr.DIRECTIONS.length / 360));
    if (t !== this.prevShift) {
      const r = kr.DIRECTIONS.slice(t).concat(kr.DIRECTIONS.slice(0, t)), i = (a) => `${this.containerClassName}-cursor-${a}`;
      this.container.querySelectorAll(`.${this.resizeClassName}`).forEach((a, s) => {
        br(a, kr.DIRECTIONS.map((l) => i(l)).join(" ")), lt(a, i(r[s]));
      }), this.prevShift = t;
    }
  }
  getTrueDirection(e) {
    const t = Jt.normalize(this.node.getAngle());
    let r = kr.POSITIONS.indexOf(e);
    return r += Math.floor(t * (kr.POSITIONS.length / 360)), r %= kr.POSITIONS.length, kr.POSITIONS[r];
  }
  toValidResizeDirection(e) {
    return {
      top: "top-left",
      bottom: "bottom-right",
      left: "bottom-left",
      right: "top-right"
    }[e] || e;
  }
  startResizing(e) {
    e.stopPropagation(), this.model.startBatch("resize", { cid: this.cid });
    const t = Xt(e.target, "data-position");
    this.prepareResizing(e, t), this.startAction(e);
  }
  prepareResizing(e, t) {
    const r = this.getTrueDirection(t);
    let i = 0, o = 0;
    t.split("-").forEach((u) => {
      i = { left: -1, right: 1 }[u] || i, o = { top: -1, bottom: 1 }[u] || o;
    });
    const a = this.toValidResizeDirection(t), s = {
      "top-right": "bottomLeft",
      "top-left": "bottomRight",
      "bottom-left": "topRight",
      "bottom-right": "topLeft"
    }[a], l = Jt.normalize(this.node.getAngle());
    this.setEventData(e, {
      selector: s,
      direction: a,
      trueDirection: r,
      relativeDirection: t,
      angle: l,
      resizeX: i,
      resizeY: o,
      action: "resizing"
    });
  }
  startRotating(e) {
    e.stopPropagation(), this.model.startBatch("rotate", { cid: this.cid });
    const t = this.node.getBBox().getCenter(), r = this.normalizeEvent(e), i = this.graph.snapToGrid(r.clientX, r.clientY);
    this.setEventData(e, {
      center: t,
      action: "rotating",
      angle: Jt.normalize(this.node.getAngle()),
      start: G.create(i).theta(t)
    }), this.startAction(e);
  }
  onMouseMove(e) {
    const t = this.graph.findViewByCell(this.node);
    let r = this.getEventData(e);
    if (r.action) {
      const i = this.normalizeEvent(e);
      let o = i.clientX, a = i.clientY;
      const s = this.graph.getPlugin("scroller"), l = this.options.restrictedResizing;
      if (l === !0 || typeof l == "number") {
        const d = l === !0 ? 0 : l, p = s ? Math.max(d, 8) : d, g = this.graph.container.getBoundingClientRect();
        o = wo(o, g.left + p, g.right - p), a = wo(a, g.top + p, g.bottom - p);
      } else
        this.options.autoScrollOnResizing && s && s.autoScroll(o, a);
      const u = this.graph.snapToGrid(o, a), c = this.graph.getGridSize(), h = this.node, f = this.options;
      if (r.action === "resizing") {
        r = r, r.resized || (t && (t.addClass("node-resizing"), this.notify("node:resize", e, t)), r.resized = !0);
        const d = h.getBBox(), p = G.create(u).rotate(r.angle, d.getCenter()).diff(d[r.selector]);
        let g = r.resizeX ? p.x * r.resizeX : d.width, v = r.resizeY ? p.y * r.resizeY : d.height;
        const m = g, y = v;
        if (g = rn.snapToGrid(g, c), v = rn.snapToGrid(v, c), g = Math.max(g, f.minWidth || c), v = Math.max(v, f.minHeight || c), g = Math.min(g, f.maxWidth || 1 / 0), v = Math.min(v, f.maxHeight || 1 / 0), f.preserveAspectRatio) {
          const O = d.width * v / d.height, w = d.height * g / d.width;
          g < O ? v = w : g = O;
        }
        const b = r.relativeDirection;
        if (f.allowReverse && (m <= -g || y <= -v)) {
          let O;
          b === "left" ? m <= -g && (O = "right") : b === "right" ? m <= -g && (O = "left") : b === "top" ? y <= -v && (O = "bottom") : b === "bottom" ? y <= -v && (O = "top") : b === "top-left" ? m <= -g && y <= -v ? O = "bottom-right" : m <= -g ? O = "top-right" : y <= -v && (O = "bottom-left") : b === "top-right" ? m <= -g && y <= -v ? O = "bottom-left" : m <= -g ? O = "top-left" : y <= -v && (O = "bottom-right") : b === "bottom-left" ? m <= -g && y <= -v ? O = "top-right" : m <= -g ? O = "bottom-right" : y <= -v && (O = "top-left") : b === "bottom-right" && (m <= -g && y <= -v ? O = "top-left" : m <= -g ? O = "bottom-left" : y <= -v && (O = "top-right"));
          const w = O;
          this.stopHandle();
          const x = this.container.querySelector(`.${this.resizeClassName}[data-position="${w}"]`);
          this.startHandle(x), this.prepareResizing(e, w), this.onMouseMove(e);
        }
        if (d.width !== g || d.height !== v) {
          const O = {
            ui: !0,
            direction: r.direction,
            relativeDirection: r.relativeDirection,
            trueDirection: r.trueDirection,
            minWidth: f.minWidth,
            minHeight: f.minHeight,
            maxWidth: f.maxWidth,
            maxHeight: f.maxHeight,
            preserveAspectRatio: f.preserveAspectRatio === !0
          };
          h.resize(g, v, O), this.notify("node:resizing", e, t);
        }
      } else if (r.action === "rotating") {
        r = r, r.rotated || (t && (t.addClass("node-rotating"), this.notify("node:rotate", e, t)), r.rotated = !0);
        const d = h.getAngle(), p = r.start - G.create(u).theta(r.center);
        let g = r.angle + p;
        f.rotateGrid && (g = rn.snapToGrid(g, f.rotateGrid)), g = Jt.normalize(g), d !== g && (h.rotate(g, { absolute: !0 }), this.notify("node:rotating", e, t));
      }
    }
  }
  onMouseUp(e) {
    const t = this.getEventData(e);
    t.action && (this.stopAction(e), this.model.stopBatch(t.action === "resizing" ? "resize" : "rotate", {
      cid: this.cid
    }));
  }
  startHandle(e) {
    if (this.handle = e || null, lt(this.container, `${this.containerClassName}-active`), e) {
      lt(e, `${this.containerClassName}-active-handle`);
      const t = e.getAttribute("data-position");
      if (t) {
        const r = kr.DIRECTIONS[kr.POSITIONS.indexOf(t)];
        lt(this.container, `${this.containerClassName}-cursor-${r}`);
      }
    }
  }
  stopHandle() {
    if (br(this.container, `${this.containerClassName}-active`), this.handle) {
      br(this.handle, `${this.containerClassName}-active-handle`);
      const e = this.handle.getAttribute("data-position");
      if (e) {
        const t = kr.DIRECTIONS[kr.POSITIONS.indexOf(e)];
        br(this.container, `${this.containerClassName}-cursor-${t}`);
      }
      this.handle = null;
    }
  }
  startAction(e) {
    this.startHandle(e.target), this.graph.view.undelegateEvents(), this.delegateDocumentEvents(kr.documentEvents, e.data);
  }
  stopAction(e) {
    this.stopHandle(), this.undelegateDocumentEvents(), this.graph.view.delegateEvents();
    const t = this.graph.findViewByCell(this.node), r = this.getEventData(e);
    t && (t.removeClass(`node-${r.action}`), r.action === "resizing" && r.resized ? this.notify("node:resized", e, t) : r.action === "rotating" && r.rotated && this.notify("node:rotated", e, t));
  }
  notify(e, t, r, i = {}) {
    if (r) {
      const o = r.graph, a = o.view.normalizeEvent(t), s = o.snapToGrid(a.clientX, a.clientY);
      this.trigger(e, Object.assign({
        e: a,
        view: r,
        node: r.cell,
        cell: r.cell,
        x: s.x,
        y: s.y
      }, i));
    }
  }
  dispose() {
    this.stopListening(), this.remove(), this.off();
  }
}
mEe([
  Dn.dispose()
], z9.prototype, "dispose", null);
var kr;
(function(n) {
  n.NODE_CLS = "has-widget-transform", n.DIRECTIONS = ["nw", "n", "ne", "e", "se", "s", "sw", "w"], n.POSITIONS = [
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ], n.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp"
  }, n.defaultOptions = {
    minWidth: 0,
    minHeight: 0,
    maxWidth: 1 / 0,
    maxHeight: 1 / 0,
    rotateGrid: 15,
    rotatable: !0,
    preserveAspectRatio: !1,
    orthogonalResizing: !0,
    restrictedResizing: !1,
    autoScrollOnResizing: !0,
    allowReverse: !0
  };
})(kr || (kr = {}));
const yEe = `.x6-widget-transform {
  position: absolute;
  box-sizing: content-box !important;
  margin: -5px 0 0 -5px;
  padding: 4px;
  border: 1px dashed #000;
  border-radius: 5px;
  user-select: none;
  pointer-events: none;
}
.x6-widget-transform > div {
  position: absolute;
  box-sizing: border-box;
  background-color: #fff;
  border: 1px solid #000;
  transition: background-color 0.2s;
  pointer-events: auto;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-transform > div:hover {
  background-color: #d3d3d3;
}
.x6-widget-transform-cursor-n {
  cursor: n-resize;
}
.x6-widget-transform-cursor-s {
  cursor: s-resize;
}
.x6-widget-transform-cursor-e {
  cursor: e-resize;
}
.x6-widget-transform-cursor-w {
  cursor: w-resize;
}
.x6-widget-transform-cursor-ne {
  cursor: ne-resize;
}
.x6-widget-transform-cursor-nw {
  cursor: nw-resize;
}
.x6-widget-transform-cursor-se {
  cursor: se-resize;
}
.x6-widget-transform-cursor-sw {
  cursor: sw-resize;
}
.x6-widget-transform-resize {
  width: 10px;
  height: 10px;
  border-radius: 6px;
}
.x6-widget-transform-resize[data-position='top-left'] {
  top: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='top-right'] {
  top: -5px;
  right: -5px;
}
.x6-widget-transform-resize[data-position='bottom-left'] {
  bottom: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='bottom-right'] {
  right: -5px;
  bottom: -5px;
}
.x6-widget-transform-resize[data-position='top'] {
  top: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='bottom'] {
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='left'] {
  top: 50%;
  left: -5px;
  margin-top: -5px;
}
.x6-widget-transform-resize[data-position='right'] {
  top: 50%;
  right: -5px;
  margin-top: -5px;
}
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='top'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='right'] {
  display: none;
}
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='right'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='top'] {
  display: none;
}
.x6-widget-transform.no-resize .x6-widget-transform-resize {
  display: none;
}
.x6-widget-transform-rotate {
  top: -20px;
  left: -20px;
  width: 12px;
  height: 12px;
  border-radius: 6px;
  cursor: crosshair;
}
.x6-widget-transform.no-rotate .x6-widget-transform-rotate {
  display: none;
}
.x6-widget-transform-active {
  border-color: transparent;
  pointer-events: all;
}
.x6-widget-transform-active > div {
  display: none;
}
.x6-widget-transform-active > .x6-widget-transform-active-handle {
  display: block;
  background-color: #808080;
}
`;
Ie.prototype.createTransformWidget = function(n) {
  const e = this.getPlugin("transform");
  return e && e.createWidget(n), this;
};
Ie.prototype.clearTransformWidgets = function() {
  const n = this.getPlugin("transform");
  return n && n.clearWidgets(), this;
};
var bEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class zg extends Yn {
  constructor(e = {}) {
    super(), this.name = "transform", this.widgets = /* @__PURE__ */ new Map(), this.disabled = !1, this.options = e, T_(this.name, yEe);
  }
  init(e) {
    this.graph = e, !this.disabled && this.startListening();
  }
  startListening() {
    this.graph.on("node:click", this.onNodeClick, this), this.graph.on("blank:mousedown", this.onBlankMouseDown, this);
  }
  stopListening() {
    this.graph.off("node:click", this.onNodeClick, this), this.graph.off("blank:mousedown", this.onBlankMouseDown, this);
  }
  enable() {
    this.disabled && (this.disabled = !1, this.startListening());
  }
  disable() {
    this.disabled || (this.disabled = !0, this.stopListening());
  }
  isEnabled() {
    return !this.disabled;
  }
  createWidget(e) {
    this.clearWidgets();
    const t = this.createTransform(e);
    t && (this.widgets.set(e, t), t.on("*", (r, i) => {
      this.trigger(r, i), this.graph.trigger(r, i);
    }));
  }
  onNodeClick({ node: e }) {
    this.createWidget(e);
  }
  onBlankMouseDown() {
    this.clearWidgets();
  }
  createTransform(e) {
    const t = this.getTransformOptions(e);
    return t.resizable || t.rotatable ? new z9(t, e, this.graph) : null;
  }
  getTransformOptions(e) {
    this.options.resizing || (this.options.resizing = {
      enabled: !1
    }), this.options.rotating || (this.options.rotating = {
      enabled: !1
    }), typeof this.options.resizing == "boolean" && (this.options.resizing = {
      enabled: this.options.resizing
    }), typeof this.options.rotating == "boolean" && (this.options.rotating = {
      enabled: this.options.rotating
    });
    const t = zg.parseOptionGroup(this.graph, e, this.options.resizing), r = zg.parseOptionGroup(this.graph, e, this.options.rotating);
    return {
      resizable: !!t.enabled,
      minWidth: t.minWidth || 0,
      maxWidth: t.maxWidth || Number.MAX_SAFE_INTEGER,
      minHeight: t.minHeight || 0,
      maxHeight: t.maxHeight || Number.MAX_SAFE_INTEGER,
      orthogonalResizing: typeof t.orthogonal == "boolean" ? t.orthogonal : !0,
      restrictedResizing: !!t.restrict,
      autoScrollOnResizing: typeof t.autoScroll == "boolean" ? t.autoScroll : !0,
      preserveAspectRatio: !!t.preserveAspectRatio,
      allowReverse: typeof t.allowReverse == "boolean" ? t.allowReverse : !0,
      rotatable: !!r.enabled,
      rotateGrid: r.grid || 15
    };
  }
  clearWidgets() {
    this.widgets.forEach((e, t) => {
      this.graph.getCellById(t.id) && e.dispose();
    }), this.widgets.clear();
  }
  dispose() {
    this.clearWidgets(), this.stopListening(), this.off(), k_(this.name);
  }
}
bEe([
  Yn.dispose()
], zg.prototype, "dispose", null);
(function(n) {
  function e(t, r, i) {
    const o = {};
    return Object.keys(i || {}).forEach((a) => {
      const s = i[a];
      o[a] = typeof s == "function" ? s.call(t, r) : s;
    }), o;
  }
  n.parseOptionGroup = e;
})(zg || (zg = {}));
var OEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class F9 extends Dn {
  get graph() {
    return this.options.graph;
  }
  get boxClassName() {
    return this.prefixClassName(co.classNames.box);
  }
  get $boxes() {
    return w2e(this.container, this.boxClassName);
  }
  get handleOptions() {
    return this.options;
  }
  constructor(e) {
    super(), this.options = e, this.options.model && (this.options.collection = this.options.model.collection), this.options.collection ? this.collection = this.options.collection : (this.collection = new kx([], {
      comparator: co.depthComparator
    }), this.options.collection = this.collection), this.boxCount = 0, this.createContainer(), this.startListening();
  }
  startListening() {
    const e = this.graph, t = this.collection;
    this.delegateEvents({
      [`mousedown .${this.boxClassName}`]: "onSelectionBoxMouseDown",
      [`touchstart .${this.boxClassName}`]: "onSelectionBoxMouseDown"
    }, !0), e.on("scale", this.onGraphTransformed, this), e.on("translate", this.onGraphTransformed, this), e.model.on("updated", this.onModelUpdated, this), t.on("added", this.onCellAdded, this), t.on("removed", this.onCellRemoved, this), t.on("reseted", this.onReseted, this), t.on("updated", this.onCollectionUpdated, this), t.on("node:change:position", this.onNodePositionChanged, this), t.on("cell:changed", this.onCellChanged, this);
  }
  stopListening() {
    const e = this.graph, t = this.collection;
    this.undelegateEvents(), e.off("scale", this.onGraphTransformed, this), e.off("translate", this.onGraphTransformed, this), e.model.off("updated", this.onModelUpdated, this), t.off("added", this.onCellAdded, this), t.off("removed", this.onCellRemoved, this), t.off("reseted", this.onReseted, this), t.off("updated", this.onCollectionUpdated, this), t.off("node:change:position", this.onNodePositionChanged, this), t.off("cell:changed", this.onCellChanged, this);
  }
  onRemove() {
    this.stopListening();
  }
  onGraphTransformed() {
    this.updateSelectionBoxes();
  }
  onCellChanged() {
    this.updateSelectionBoxes();
  }
  onNodePositionChanged({ node: e, options: t }) {
    const { showNodeSelectionBox: r, pointerEvents: i } = this.options, { ui: o, selection: a, translateBy: s, snapped: l } = t, u = (r !== !0 || i && this.getPointerEventsValue(i) === "none") && !this.translating && !a, c = o && s && e.id === s;
    if (u && (c || l)) {
      this.translating = !0;
      const h = e.position(), f = e.previous("position"), d = h.x - f.x, p = h.y - f.y;
      (d !== 0 || p !== 0) && this.translateSelectedNodes(d, p, e, t), this.translating = !1;
    }
  }
  onModelUpdated({ removed: e }) {
    e && e.length && this.unselect(e);
  }
  isEmpty() {
    return this.length <= 0;
  }
  isSelected(e) {
    return this.collection.has(e);
  }
  get length() {
    return this.collection.length;
  }
  get cells() {
    return this.collection.toArray();
  }
  select(e, t = {}) {
    t.dryrun = !0;
    const r = this.filter(Array.isArray(e) ? e : [e]);
    return this.collection.add(r, t), this;
  }
  unselect(e, t = {}) {
    return t.dryrun = !0, this.collection.remove(Array.isArray(e) ? e : [e], t), this;
  }
  reset(e, t = {}) {
    if (e) {
      if (t.batch) {
        const u = this.filter(Array.isArray(e) ? e : [e]);
        return this.collection.reset(u, Object.assign(Object.assign({}, t), { ui: !0 })), this;
      }
      const r = this.cells, i = this.filter(Array.isArray(e) ? e : [e]), o = {}, a = {};
      r.forEach((u) => o[u.id] = u), i.forEach((u) => a[u.id] = u);
      const s = [], l = [];
      return i.forEach((u) => {
        o[u.id] || s.push(u);
      }), r.forEach((u) => {
        a[u.id] || l.push(u);
      }), l.length && this.unselect(l, Object.assign(Object.assign({}, t), { ui: !0 })), s.length && this.select(s, Object.assign(Object.assign({}, t), { ui: !0 })), l.length === 0 && s.length === 0 && this.updateContainer(), this;
    }
    return this.clean(t);
  }
  clean(e = {}) {
    return this.length && (e.batch === !1 ? this.unselect(this.cells, e) : this.collection.reset([], Object.assign(Object.assign({}, e), { ui: !0 }))), this;
  }
  setFilter(e) {
    this.options.filter = e;
  }
  setContent(e) {
    this.options.content = e;
  }
  startSelecting(e) {
    e = this.normalizeEvent(e), this.clean();
    let t, r;
    const i = this.graph.container;
    if (e.offsetX != null && e.offsetY != null && i.contains(e.target))
      t = e.offsetX, r = e.offsetY;
    else {
      const o = VP(i), a = i.scrollLeft, s = i.scrollTop;
      t = e.clientX - o.left + window.pageXOffset + a, r = e.clientY - o.top + window.pageYOffset + s;
    }
    Mr(this.container, {
      top: r,
      left: t,
      width: 1,
      height: 1
    }), this.setEventData(e, {
      action: "selecting",
      clientX: e.clientX,
      clientY: e.clientY,
      offsetX: t,
      offsetY: r,
      scrollerX: 0,
      scrollerY: 0,
      moving: !1
    }), this.delegateDocumentEvents(co.documentEvents, e.data);
  }
  filter(e) {
    const t = this.options.filter;
    return e.filter((r) => Array.isArray(t) ? t.some((i) => typeof i == "string" ? r.shape === i : r.id === i.id) : typeof t == "function" ? rt(t, this.graph, r) : !0);
  }
  stopSelecting(e) {
    const t = this.graph, r = this.getEventData(e);
    switch (r.action) {
      case "selecting": {
        let o = nAe(this.container), a = rAe(this.container);
        const s = VP(this.container), l = t.pageToLocal(s.left, s.top), u = t.transform.getScale();
        o /= u.sx, a /= u.sy;
        const c = new Te(l.x, l.y, o, a), h = this.getCellViewsInArea(c).map((f) => f.cell);
        this.reset(h, { batch: !0 }), this.hideRubberband();
        break;
      }
      case "translating": {
        const o = t.snapToGrid(e.clientX, e.clientY);
        if (!this.options.following) {
          const a = r;
          this.updateSelectedNodesPosition({
            dx: a.clientX - a.originX,
            dy: a.clientY - a.originY
          });
        }
        this.graph.model.stopBatch("move-selection"), this.notifyBoxEvent("box:mouseup", e, o.x, o.y);
        break;
      }
      default: {
        this.clean();
        break;
      }
    }
  }
  onMouseUp(e) {
    this.getEventData(e).action && (this.stopSelecting(e), this.undelegateDocumentEvents());
  }
  onSelectionBoxMouseDown(e) {
    this.options.following || e.stopPropagation();
    const t = this.normalizeEvent(e);
    this.options.movable && this.startTranslating(t);
    const r = this.getCellViewFromElem(t.target);
    this.setEventData(t, { activeView: r });
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    this.notifyBoxEvent("box:mousedown", t, i.x, i.y), this.delegateDocumentEvents(co.documentEvents, t.data);
  }
  startTranslating(e) {
    this.graph.model.startBatch("move-selection");
    const t = this.graph.snapToGrid(e.clientX, e.clientY);
    this.setEventData(e, {
      action: "translating",
      clientX: t.x,
      clientY: t.y,
      originX: t.x,
      originY: t.y
    });
  }
  getRestrictArea() {
    const e = this.graph.options.translating.restrict, t = typeof e == "function" ? rt(e, this.graph, null) : e;
    return typeof t == "number" ? this.graph.transform.getGraphArea().inflate(t) : t === !0 ? this.graph.transform.getGraphArea() : t || null;
  }
  getSelectionOffset(e, t) {
    let r = e.x - t.clientX, i = e.y - t.clientY;
    const o = this.getRestrictArea();
    if (o) {
      const a = this.collection.toArray(), s = Qt.getCellsBBox(a, { deep: !0 }) || Te.create(), l = o.x - s.x, u = o.y - s.y, c = o.x + o.width - (s.x + s.width), h = o.y + o.height - (s.y + s.height);
      if (r < l && (r = l), i < u && (i = u), c < r && (r = c), h < i && (i = h), !this.options.following) {
        const f = e.x - t.originX, d = e.y - t.originY;
        r = f <= l || f >= c ? 0 : r, i = d <= u || d >= h ? 0 : i;
      }
    }
    return {
      dx: r,
      dy: i
    };
  }
  updateElementPosition(e, t, r) {
    const i = Mr(e, "left"), o = Mr(e, "top"), a = i ? parseFloat(i) : 0, s = o ? parseFloat(o) : 0;
    Mr(e, "left", a + t), Mr(e, "top", s + r);
  }
  updateSelectedNodesPosition(e) {
    const { dx: t, dy: r } = e;
    if (t || r)
      if (this.translateSelectedNodes(t, r), this.boxesUpdated)
        this.collection.length > 1 && this.updateSelectionBoxes();
      else {
        const i = this.graph.transform.getScale();
        for (let o = 0, a = this.$boxes, s = a.length; o < s; o += 1)
          this.updateElementPosition(a[o], t * i.sx, r * i.sy);
        this.updateElementPosition(this.selectionContainer, t * i.sx, r * i.sy);
      }
  }
  autoScrollGraph(e, t) {
    const r = this.graph.getPlugin("scroller");
    return r ? r.autoScroll(e, t) : { scrollerX: 0, scrollerY: 0 };
  }
  adjustSelection(e) {
    const t = this.normalizeEvent(e), r = this.getEventData(t);
    switch (r.action) {
      case "selecting": {
        const o = r;
        o.moving !== !0 && (vy(this.container, this.graph.container), this.showRubberband(), o.moving = !0);
        const { scrollerX: a, scrollerY: s } = this.autoScrollGraph(t.clientX, t.clientY);
        o.scrollerX += a, o.scrollerY += s;
        const l = t.clientX - o.clientX + o.scrollerX, u = t.clientY - o.clientY + o.scrollerY, c = parseInt(Mr(this.container, "left") || "0", 10), h = parseInt(Mr(this.container, "top") || "0", 10);
        Mr(this.container, {
          left: l < 0 ? o.offsetX + l : c,
          top: u < 0 ? o.offsetY + u : h,
          width: Math.abs(l),
          height: Math.abs(u)
        });
        break;
      }
      case "translating": {
        const o = this.graph.snapToGrid(t.clientX, t.clientY), a = r, s = this.getSelectionOffset(o, a);
        this.options.following ? this.updateSelectedNodesPosition(s) : this.updateContainerPosition(s), s.dx && (a.clientX = o.x), s.dy && (a.clientY = o.y), this.notifyBoxEvent("box:mousemove", e, o.x, o.y);
        break;
      }
    }
    this.boxesUpdated = !1;
  }
  translateSelectedNodes(e, t, r, i) {
    const o = {}, a = [];
    if (r && (o[r.id] = !0), this.collection.toArray().forEach((s) => {
      s.getDescendants({ deep: !0 }).forEach((l) => {
        o[l.id] = !0;
      });
    }), i && i.translateBy) {
      const s = this.graph.getCellById(i.translateBy);
      s && (o[s.id] = !0, s.getDescendants({ deep: !0 }).forEach((l) => {
        o[l.id] = !0;
      }), a.push(s));
    }
    this.collection.toArray().forEach((s) => {
      if (!o[s.id]) {
        const l = Object.assign(Object.assign({}, i), { selection: this.cid, exclude: a });
        s.translate(e, t, l), this.graph.model.getConnectedEdges(s).forEach((u) => {
          o[u.id] || (u.translate(e, t, l), o[u.id] = !0);
        });
      }
    });
  }
  getCellViewsInArea(e) {
    const t = this.graph, r = {
      strict: this.options.strict
    };
    let i = [];
    return this.options.rubberNode && (i = i.concat(t.model.getNodesInArea(e, r).map((o) => t.renderer.findViewByCell(o)).filter((o) => o != null))), this.options.rubberEdge && (i = i.concat(t.model.getEdgesInArea(e, r).map((o) => t.renderer.findViewByCell(o)).filter((o) => o != null))), i;
  }
  notifyBoxEvent(e, t, r, i) {
    const a = this.getEventData(t).activeView;
    this.trigger(e, { e: t, view: a, x: r, y: i, cell: a.cell });
  }
  getSelectedClassName(e) {
    return this.prefixClassName(`${e.isNode() ? "node" : "edge"}-selected`);
  }
  addCellSelectedClassName(e) {
    const t = this.graph.renderer.findViewByCell(e);
    t && t.addClass(this.getSelectedClassName(e));
  }
  removeCellUnSelectedClassName(e) {
    const t = this.graph.renderer.findViewByCell(e);
    t && t.removeClass(this.getSelectedClassName(e));
  }
  destroySelectionBox(e) {
    this.removeCellUnSelectedClassName(e), this.canShowSelectionBox(e) && (cl(this.container.querySelector(`[data-cell-id="${e.id}"]`)), this.$boxes.length === 0 && this.hide(), this.boxCount = Math.max(0, this.boxCount - 1));
  }
  destroyAllSelectionBoxes(e) {
    e.forEach((t) => this.removeCellUnSelectedClassName(t)), this.hide(), cl(this.$boxes), this.boxCount = 0;
  }
  hide() {
    br(this.container, this.prefixClassName(co.classNames.rubberband)), br(this.container, this.prefixClassName(co.classNames.selected));
  }
  showRubberband() {
    lt(this.container, this.prefixClassName(co.classNames.rubberband));
  }
  hideRubberband() {
    br(this.container, this.prefixClassName(co.classNames.rubberband));
  }
  showSelected() {
    hI(this.container, "style"), lt(this.container, this.prefixClassName(co.classNames.selected));
  }
  createContainer() {
    this.container = document.createElement("div"), lt(this.container, this.prefixClassName(co.classNames.root)), this.options.className && lt(this.container, this.options.className), this.selectionContainer = document.createElement("div"), lt(this.selectionContainer, this.prefixClassName(co.classNames.inner)), this.selectionContent = document.createElement("div"), lt(this.selectionContent, this.prefixClassName(co.classNames.content)), sh(this.selectionContainer, this.selectionContent), Xt(this.selectionContainer, "data-selection-length", this.collection.length), _q(this.container, this.selectionContainer);
  }
  updateContainerPosition(e) {
    (e.dx || e.dy) && this.updateElementPosition(this.selectionContainer, e.dx, e.dy);
  }
  updateContainer() {
    const e = { x: 1 / 0, y: 1 / 0 }, t = { x: 0, y: 0 };
    this.collection.toArray().filter((o) => this.canShowSelectionBox(o)).forEach((o) => {
      const a = this.graph.renderer.findViewByCell(o);
      if (a) {
        const s = a.getBBox({
          useCellGeometry: !0
        });
        e.x = Math.min(e.x, s.x), e.y = Math.min(e.y, s.y), t.x = Math.max(t.x, s.x + s.width), t.y = Math.max(t.y, s.y + s.height);
      }
    }), Mr(this.selectionContainer, {
      position: "absolute",
      pointerEvents: "none",
      left: e.x,
      top: e.y,
      width: t.x - e.x,
      height: t.y - e.y
    }), Xt(this.selectionContainer, "data-selection-length", this.collection.length);
    const i = this.options.content;
    if (i)
      if (typeof i == "function") {
        const o = rt(i, this.graph, this, this.selectionContent);
        o && (this.selectionContent.innerHTML = o);
      } else
        this.selectionContent.innerHTML = i;
    this.collection.length > 0 && !this.container.parentNode ? vy(this.container, this.graph.container) : this.collection.length <= 0 && this.container.parentNode && this.container.parentNode.removeChild(this.container);
  }
  canShowSelectionBox(e) {
    return e.isNode() && this.options.showNodeSelectionBox === !0 || e.isEdge() && this.options.showEdgeSelectionBox === !0;
  }
  getPointerEventsValue(e) {
    return typeof e == "string" ? e : e(this.cells);
  }
  createSelectionBox(e) {
    if (this.addCellSelectedClassName(e), this.canShowSelectionBox(e)) {
      const t = this.graph.renderer.findViewByCell(e);
      if (t) {
        const r = t.getBBox({
          useCellGeometry: !0
        }), i = this.boxClassName, o = document.createElement("div"), a = this.options.pointerEvents;
        lt(o, i), lt(o, `${i}-${e.isNode() ? "node" : "edge"}`), Xt(o, "data-cell-id", e.id), Mr(o, {
          position: "absolute",
          left: r.x,
          top: r.y,
          width: r.width,
          height: r.height,
          pointerEvents: a ? this.getPointerEventsValue(a) : "auto"
        }), vy(o, this.container), this.showSelected(), this.boxCount += 1;
      }
    }
  }
  updateSelectionBoxes() {
    this.collection.length > 0 && (this.boxesUpdated = !0, this.confirmUpdate());
  }
  confirmUpdate() {
    if (this.boxCount) {
      this.hide();
      for (let e = 0, t = this.$boxes, r = t.length; e < r; e += 1) {
        const i = t[e], o = Xt(i, "data-cell-id");
        cl(i), this.boxCount -= 1;
        const a = this.collection.get(o);
        a && this.createSelectionBox(a);
      }
      this.updateContainer();
    }
    return 0;
  }
  getCellViewFromElem(e) {
    const t = e.getAttribute("data-cell-id");
    if (t) {
      const r = this.collection.get(t);
      if (r)
        return this.graph.renderer.findViewByCell(r);
    }
    return null;
  }
  onCellRemoved({ cell: e }) {
    this.destroySelectionBox(e), this.updateContainer();
  }
  onReseted({ previous: e, current: t }) {
    this.destroyAllSelectionBoxes(e), t.forEach((r) => {
      this.listenCellRemoveEvent(r), this.createSelectionBox(r);
    }), this.updateContainer();
  }
  onCellAdded({ cell: e }) {
    this.listenCellRemoveEvent(e), this.createSelectionBox(e), this.updateContainer();
  }
  listenCellRemoveEvent(e) {
    e.off("removed", this.onCellRemoved, this), e.on("removed", this.onCellRemoved, this);
  }
  onCollectionUpdated({ added: e, removed: t, options: r }) {
    e.forEach((o) => {
      this.trigger("cell:selected", { cell: o, options: r }), o.isNode() ? this.trigger("node:selected", { cell: o, options: r, node: o }) : o.isEdge() && this.trigger("edge:selected", { cell: o, options: r, edge: o });
    }), t.forEach((o) => {
      this.trigger("cell:unselected", { cell: o, options: r }), o.isNode() ? this.trigger("node:unselected", { cell: o, options: r, node: o }) : o.isEdge() && this.trigger("edge:unselected", { cell: o, options: r, edge: o });
    });
    const i = {
      added: e,
      removed: t,
      options: r,
      selected: this.cells.filter((o) => !!this.graph.getCellById(o.id))
    };
    this.trigger("selection:changed", i);
  }
  // #endregion
  dispose() {
    this.clean(), this.remove(), this.off();
  }
}
OEe([
  Dn.dispose()
], F9.prototype, "dispose", null);
var co;
(function(n) {
  const e = "widget-selection";
  n.classNames = {
    root: e,
    inner: `${e}-inner`,
    box: `${e}-box`,
    content: `${e}-content`,
    rubberband: `${e}-rubberband`,
    selected: `${e}-selected`
  }, n.documentEvents = {
    mousemove: "adjustSelection",
    touchmove: "adjustSelection",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
  function t(r) {
    return r.getAncestors().length;
  }
  n.depthComparator = t;
})(co || (co = {}));
const wEe = `.x6-widget-selection {
  position: absolute;
  top: 0;
  left: 0;
  display: none;
  width: 0;
  height: 0;
  touch-action: none;
}
.x6-widget-selection-rubberband {
  display: block;
  overflow: visible;
  opacity: 0.3;
}
.x6-widget-selection-selected {
  display: block;
}
.x6-widget-selection-box {
  cursor: move;
}
.x6-widget-selection-inner[data-selection-length='0'],
.x6-widget-selection-inner[data-selection-length='1'] {
  display: none;
}
.x6-widget-selection-content {
  position: absolute;
  top: 100%;
  right: -20px;
  left: -20px;
  margin-top: 30px;
  padding: 6px;
  line-height: 14px;
  text-align: center;
  border-radius: 6px;
}
.x6-widget-selection-content:empty {
  display: none;
}
.x6-widget-selection-rubberband {
  background-color: #3498db;
  border: 2px solid #2980b9;
}
.x6-widget-selection-box {
  box-sizing: content-box !important;
  margin-top: -4px;
  margin-left: -4px;
  padding-right: 4px;
  padding-bottom: 4px;
  border: 2px dashed #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-inner {
  box-sizing: content-box !important;
  margin-top: -8px;
  margin-left: -8px;
  padding-right: 12px;
  padding-bottom: 12px;
  border: 2px solid #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-content {
  color: #fff;
  font-size: 10px;
  background-color: #6a6b8a;
}
`;
Ie.prototype.isSelectionEnabled = function() {
  const n = this.getPlugin("selection");
  return n ? n.isEnabled() : !1;
};
Ie.prototype.enableSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.enable(), this;
};
Ie.prototype.disableSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.disable(), this;
};
Ie.prototype.toggleSelection = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleEnabled(n), this;
};
Ie.prototype.isMultipleSelection = function() {
  const n = this.getPlugin("selection");
  return n ? n.isMultipleSelection() : !1;
};
Ie.prototype.enableMultipleSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.enableMultipleSelection(), this;
};
Ie.prototype.disableMultipleSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.disableMultipleSelection(), this;
};
Ie.prototype.toggleMultipleSelection = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleMultipleSelection(n), this;
};
Ie.prototype.isSelectionMovable = function() {
  const n = this.getPlugin("selection");
  return n ? n.isSelectionMovable() : !1;
};
Ie.prototype.enableSelectionMovable = function() {
  const n = this.getPlugin("selection");
  return n && n.enableSelectionMovable(), this;
};
Ie.prototype.disableSelectionMovable = function() {
  const n = this.getPlugin("selection");
  return n && n.disableSelectionMovable(), this;
};
Ie.prototype.toggleSelectionMovable = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleSelectionMovable(n), this;
};
Ie.prototype.isRubberbandEnabled = function() {
  const n = this.getPlugin("selection");
  return n ? n.isRubberbandEnabled() : !1;
};
Ie.prototype.enableRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.enableRubberband(), this;
};
Ie.prototype.disableRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.disableRubberband(), this;
};
Ie.prototype.toggleRubberband = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleRubberband(n), this;
};
Ie.prototype.isStrictRubberband = function() {
  const n = this.getPlugin("selection");
  return n ? n.isStrictRubberband() : !1;
};
Ie.prototype.enableStrictRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.enableStrictRubberband(), this;
};
Ie.prototype.disableStrictRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.disableStrictRubberband(), this;
};
Ie.prototype.toggleStrictRubberband = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleStrictRubberband(n), this;
};
Ie.prototype.setRubberbandModifiers = function(n) {
  const e = this.getPlugin("selection");
  return e && e.setRubberbandModifiers(n), this;
};
Ie.prototype.setSelectionFilter = function(n) {
  const e = this.getPlugin("selection");
  return e && e.setSelectionFilter(n), this;
};
Ie.prototype.setSelectionDisplayContent = function(n) {
  const e = this.getPlugin("selection");
  return e && e.setSelectionDisplayContent(n), this;
};
Ie.prototype.isSelectionEmpty = function() {
  const n = this.getPlugin("selection");
  return n ? n.isEmpty() : !0;
};
Ie.prototype.cleanSelection = function(n) {
  const e = this.getPlugin("selection");
  return e && e.clean(n), this;
};
Ie.prototype.resetSelection = function(n, e) {
  const t = this.getPlugin("selection");
  return t && t.reset(n, e), this;
};
Ie.prototype.getSelectedCells = function() {
  const n = this.getPlugin("selection");
  return n ? n.getSelectedCells() : [];
};
Ie.prototype.getSelectedCellCount = function() {
  const n = this.getPlugin("selection");
  return n ? n.getSelectedCellCount() : 0;
};
Ie.prototype.isSelected = function(n) {
  const e = this.getPlugin("selection");
  return e ? e.isSelected(n) : !1;
};
Ie.prototype.select = function(n, e) {
  const t = this.getPlugin("selection");
  return t && t.select(n, e), this;
};
Ie.prototype.unselect = function(n, e) {
  const t = this.getPlugin("selection");
  return t && t.unselect(n, e), this;
};
var xEe = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class d0 extends Yn {
  get rubberbandDisabled() {
    return this.options.enabled !== !0 || this.options.rubberband !== !0;
  }
  get disabled() {
    return this.options.enabled !== !0;
  }
  get length() {
    return this.selectionImpl.length;
  }
  get cells() {
    return this.selectionImpl.cells;
  }
  constructor(e = {}) {
    super(), this.name = "selection", this.movedMap = /* @__PURE__ */ new WeakMap(), this.unselectMap = /* @__PURE__ */ new WeakMap(), this.options = Object.assign(Object.assign({ enabled: !0 }, d0.defaultOptions), e), T_(this.name, wEe);
  }
  init(e) {
    this.graph = e, this.selectionImpl = new F9(Object.assign(Object.assign({}, this.options), { graph: e })), this.setup(), this.startListening();
  }
  // #region api
  isEnabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled && (this.options.enabled = !0);
  }
  disable() {
    this.disabled || (this.options.enabled = !1);
  }
  toggleEnabled(e) {
    return e != null ? e !== this.isEnabled() && (e ? this.enable() : this.disable()) : this.isEnabled() ? this.disable() : this.enable(), this;
  }
  isMultipleSelection() {
    return this.isMultiple();
  }
  enableMultipleSelection() {
    return this.enableMultiple(), this;
  }
  disableMultipleSelection() {
    return this.disableMultiple(), this;
  }
  toggleMultipleSelection(e) {
    return e != null ? e !== this.isMultipleSelection() && (e ? this.enableMultipleSelection() : this.disableMultipleSelection()) : this.isMultipleSelection() ? this.disableMultipleSelection() : this.enableMultipleSelection(), this;
  }
  isSelectionMovable() {
    return this.options.movable !== !1;
  }
  enableSelectionMovable() {
    return this.selectionImpl.options.movable = !0, this;
  }
  disableSelectionMovable() {
    return this.selectionImpl.options.movable = !1, this;
  }
  toggleSelectionMovable(e) {
    return e != null ? e !== this.isSelectionMovable() && (e ? this.enableSelectionMovable() : this.disableSelectionMovable()) : this.isSelectionMovable() ? this.disableSelectionMovable() : this.enableSelectionMovable(), this;
  }
  isRubberbandEnabled() {
    return !this.rubberbandDisabled;
  }
  enableRubberband() {
    return this.rubberbandDisabled && (this.options.rubberband = !0), this;
  }
  disableRubberband() {
    return this.rubberbandDisabled || (this.options.rubberband = !1), this;
  }
  toggleRubberband(e) {
    return e != null ? e !== this.isRubberbandEnabled() && (e ? this.enableRubberband() : this.disableRubberband()) : this.isRubberbandEnabled() ? this.disableRubberband() : this.enableRubberband(), this;
  }
  isStrictRubberband() {
    return this.selectionImpl.options.strict === !0;
  }
  enableStrictRubberband() {
    return this.selectionImpl.options.strict = !0, this;
  }
  disableStrictRubberband() {
    return this.selectionImpl.options.strict = !1, this;
  }
  toggleStrictRubberband(e) {
    return e != null ? e !== this.isStrictRubberband() && (e ? this.enableStrictRubberband() : this.disableStrictRubberband()) : this.isStrictRubberband() ? this.disableStrictRubberband() : this.enableStrictRubberband(), this;
  }
  setRubberbandModifiers(e) {
    this.setModifiers(e);
  }
  setSelectionFilter(e) {
    return this.setFilter(e), this;
  }
  setSelectionDisplayContent(e) {
    return this.setContent(e), this;
  }
  isEmpty() {
    return this.length <= 0;
  }
  clean(e = {}) {
    return this.selectionImpl.clean(e), this;
  }
  reset(e, t = {}) {
    return this.selectionImpl.reset(e ? this.getCells(e) : [], t), this;
  }
  getSelectedCells() {
    return this.cells;
  }
  getSelectedCellCount() {
    return this.length;
  }
  isSelected(e) {
    return this.selectionImpl.isSelected(e);
  }
  select(e, t = {}) {
    const r = this.getCells(e);
    return r.length && (this.isMultiple() ? this.selectionImpl.select(r, t) : this.reset(r.slice(0, 1), t)), this;
  }
  unselect(e, t = {}) {
    return this.selectionImpl.unselect(this.getCells(e), t), this;
  }
  // #endregion
  setup() {
    this.selectionImpl.on("*", (e, t) => {
      this.trigger(e, t), this.graph.trigger(e, t);
    });
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onBlankMouseDown, this), this.graph.on("blank:click", this.onBlankClick, this), this.graph.on("cell:mousemove", this.onCellMouseMove, this), this.graph.on("cell:mouseup", this.onCellMouseUp, this), this.selectionImpl.on("box:mousedown", this.onBoxMouseDown, this);
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onBlankMouseDown, this), this.graph.off("blank:click", this.onBlankClick, this), this.graph.off("cell:mousemove", this.onCellMouseMove, this), this.graph.off("cell:mouseup", this.onCellMouseUp, this), this.selectionImpl.off("box:mousedown", this.onBoxMouseDown, this);
  }
  onBlankMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e))
      return;
    const t = this.graph.panning.allowPanning(e, !0), r = this.graph.getPlugin("scroller"), i = r && r.allowPanning(e, !0);
    (this.allowRubberband(e, !0) || this.allowRubberband(e) && !i && !t) && this.startRubberband(e);
  }
  allowBlankMouseDown(e) {
    const t = this.options.eventTypes;
    return (t == null ? void 0 : t.includes("leftMouseDown")) && e.button === 0 || (t == null ? void 0 : t.includes("mouseWheelDown")) && e.button === 1;
  }
  onBlankClick() {
    this.clean();
  }
  allowRubberband(e, t) {
    return !this.rubberbandDisabled && Lc.isMatch(e, this.options.modifiers, t);
  }
  allowMultipleSelection(e) {
    return this.isMultiple() && Lc.isMatch(e, this.options.multipleSelectionModifiers);
  }
  onCellMouseMove({ cell: e }) {
    this.movedMap.set(e, !0);
  }
  onCellMouseUp({ e, cell: t }) {
    const r = this.options;
    let i = this.disabled;
    !i && this.movedMap.has(t) && (i = r.selectCellOnMoved === !1, i || (i = r.selectNodeOnMoved === !1 && t.isNode()), i || (i = r.selectEdgeOnMoved === !1 && t.isEdge())), i || (this.allowMultipleSelection(e) ? this.unselectMap.has(t) ? this.unselectMap.delete(t) : this.isSelected(t) ? this.unselect(t) : this.select(t) : this.reset(t)), this.movedMap.delete(t);
  }
  onBoxMouseDown({ e, cell: t }) {
    this.disabled || this.allowMultipleSelection(e) && (this.unselect(t), this.unselectMap.set(t, !0));
  }
  getCells(e) {
    return (Array.isArray(e) ? e : [e]).map((t) => typeof t == "string" ? this.graph.getCellById(t) : t).filter((t) => t != null);
  }
  startRubberband(e) {
    return this.rubberbandDisabled || this.selectionImpl.startSelecting(e), this;
  }
  isMultiple() {
    return this.options.multiple !== !1;
  }
  enableMultiple() {
    return this.options.multiple = !0, this;
  }
  disableMultiple() {
    return this.options.multiple = !1, this;
  }
  setModifiers(e) {
    return this.options.modifiers = e, this;
  }
  setContent(e) {
    return this.selectionImpl.setContent(e), this;
  }
  setFilter(e) {
    return this.selectionImpl.setFilter(e), this;
  }
  dispose() {
    this.stopListening(), this.off(), this.selectionImpl.dispose(), k_(this.name);
  }
}
xEe([
  Yn.dispose()
], d0.prototype, "dispose", null);
(function(n) {
  n.defaultOptions = {
    rubberband: !1,
    rubberNode: !0,
    rubberEdge: !1,
    pointerEvents: "auto",
    multiple: !0,
    multipleSelectionModifiers: ["ctrl", "meta"],
    movable: !0,
    strict: !1,
    selectCellOnMoved: !1,
    selectNodeOnMoved: !1,
    selectEdgeOnMoved: !1,
    following: !0,
    content: null,
    eventTypes: ["leftMouseDown", "mouseWheelDown"]
  };
})(d0 || (d0 = {}));
class SEe {
  constructor() {
    this.cells = [];
  }
  copy(e, t, r = {}) {
    this.options = Object.assign({}, r);
    const o = (Ol.isModel(t) ? t : t.model).cloneSubGraph(e, r);
    this.cells = Gj(Object.keys(o).map((a) => o[a]), (a) => a.isEdge() ? 2 : 1), this.serialize(r);
  }
  cut(e, t, r = {}) {
    this.copy(e, t, r), (Ie.isGraph(t) ? t.model : t).batchUpdate("cut", () => {
      e.forEach((o) => o.remove());
    });
  }
  paste(e, t = {}) {
    const r = Object.assign(Object.assign({}, this.options), t), { offset: i, edgeProps: o, nodeProps: a } = r;
    let s = 20, l = 20;
    i && (s = typeof i == "number" ? i : i.dx, l = typeof i == "number" ? i : i.dy), this.deserialize(r);
    const u = this.cells;
    u.forEach((h) => {
      h.model = null, h.removeProp("zIndex"), (s || l) && h.translate(s, l), a && h.isNode() && h.prop(a), o && h.isEdge() && h.prop(o);
    });
    const c = Ie.isGraph(e) ? e.model : e;
    return c.batchUpdate("paste", () => {
      c.addCells(this.cells);
    }), this.copy(u, e, t), u;
  }
  serialize(e) {
    e.useLocalStorage !== !1 && xy.save(this.cells);
  }
  deserialize(e) {
    if (e.useLocalStorage) {
      const t = xy.fetch();
      t && (this.cells = t);
    }
  }
  isEmpty(e = {}) {
    return e.useLocalStorage && this.deserialize(e), this.cells.length <= 0;
  }
  clean() {
    this.options = {}, this.cells = [], xy.clean();
  }
}
var xy;
(function(n) {
  const e = `${Da.prefixCls}.clipboard.cells`;
  function t(o) {
    if (window.localStorage) {
      const a = o.map((s) => s.toJSON());
      localStorage.setItem(e, JSON.stringify(a));
    }
  }
  n.save = t;
  function r() {
    if (window.localStorage) {
      const o = localStorage.getItem(e), a = o ? JSON.parse(o) : [];
      if (a)
        return Ol.fromJSON(a);
    }
  }
  n.fetch = r;
  function i() {
    window.localStorage && localStorage.removeItem(e);
  }
  n.clean = i;
})(xy || (xy = {}));
Ie.prototype.isClipboardEnabled = function() {
  const n = this.getPlugin("clipboard");
  return n ? n.isEnabled() : !1;
};
Ie.prototype.enableClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n && n.enable(), this;
};
Ie.prototype.disableClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n && n.disable(), this;
};
Ie.prototype.toggleClipboard = function(n) {
  const e = this.getPlugin("clipboard");
  return e && e.toggleEnabled(n), this;
};
Ie.prototype.isClipboardEmpty = function(n) {
  const e = this.getPlugin("clipboard");
  return e ? e.isEmpty(n) : !0;
};
Ie.prototype.getCellsInClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n ? n.getCellsInClipboard() : [];
};
Ie.prototype.cleanClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n && n.clean(), this;
};
Ie.prototype.copy = function(n, e) {
  const t = this.getPlugin("clipboard");
  return t && t.copy(n, e), this;
};
Ie.prototype.cut = function(n, e) {
  const t = this.getPlugin("clipboard");
  return t && t.cut(n, e), this;
};
Ie.prototype.paste = function(n, e) {
  const t = this.getPlugin("clipboard");
  return t ? t.paste(n, e) : [];
};
var _Ee = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
}, CEe = function(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
class AEe extends Yn {
  get disabled() {
    return this.options.enabled !== !0;
  }
  get cells() {
    return this.clipboardImpl.cells;
  }
  constructor(e = {}) {
    super(), this.name = "clipboard", this.options = Object.assign({ enabled: !0 }, e);
  }
  init(e) {
    this.graph = e, this.clipboardImpl = new SEe(), this.clipboardImpl.deserialize(this.options);
  }
  // #region api
  isEnabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled && (this.options.enabled = !0);
  }
  disable() {
    this.disabled || (this.options.enabled = !1);
  }
  toggleEnabled(e) {
    return e != null ? e !== this.isEnabled() && (e ? this.enable() : this.disable()) : this.isEnabled() ? this.disable() : this.enable(), this;
  }
  isEmpty(e = {}) {
    return this.clipboardImpl.isEmpty(e);
  }
  getCellsInClipboard() {
    return this.cells;
  }
  clean(e) {
    return (!this.disabled || e) && (this.clipboardImpl.clean(), this.notify("clipboard:changed", { cells: [] })), this;
  }
  copy(e, t = {}) {
    return this.disabled || (this.clipboardImpl.copy(e, this.graph, Object.assign(Object.assign({}, this.commonOptions), t)), this.notify("clipboard:changed", { cells: e })), this;
  }
  cut(e, t = {}) {
    return this.disabled || (this.clipboardImpl.cut(e, this.graph, Object.assign(Object.assign({}, this.commonOptions), t)), this.notify("clipboard:changed", { cells: e })), this;
  }
  paste(e = {}, t = this.graph) {
    return this.disabled ? [] : this.clipboardImpl.paste(t, Object.assign(Object.assign({}, this.commonOptions), e));
  }
  // #endregion
  get commonOptions() {
    const e = this.options;
    return CEe(e, ["enabled"]);
  }
  notify(e, t) {
    this.trigger(e, t), this.graph.trigger(e, t);
  }
  dispose() {
    this.clean(!0), this.off();
  }
}
_Ee([
  Yn.dispose()
], AEe.prototype, "dispose", null);
Ie.prototype.isHistoryEnabled = function() {
  const n = this.getPlugin("history");
  return n ? n.isEnabled() : !1;
};
Ie.prototype.enableHistory = function() {
  const n = this.getPlugin("history");
  return n && n.enable(), this;
};
Ie.prototype.disableHistory = function() {
  const n = this.getPlugin("history");
  return n && n.disable(), this;
};
Ie.prototype.toggleHistory = function(n) {
  const e = this.getPlugin("history");
  return e && e.toggleEnabled(n), this;
};
Ie.prototype.undo = function(n) {
  const e = this.getPlugin("history");
  return e && e.undo(n), this;
};
Ie.prototype.redo = function(n) {
  const e = this.getPlugin("history");
  return e && e.redo(n), this;
};
Ie.prototype.undoAndCancel = function(n) {
  const e = this.getPlugin("history");
  return e && e.cancel(n), this;
};
Ie.prototype.canUndo = function() {
  const n = this.getPlugin("history");
  return n ? n.canUndo() : !1;
};
Ie.prototype.canRedo = function() {
  const n = this.getPlugin("history");
  return n ? n.canRedo() : !1;
};
Ie.prototype.cleanHistory = function(n) {
  const e = this.getPlugin("history");
  return e && e.clean(n), this;
};
Ie.prototype.getHistoryStackSize = function() {
  return this.getPlugin("history").getSize();
};
Ie.prototype.getUndoStackSize = function() {
  return this.getPlugin("history").getUndoSize();
};
Ie.prototype.getRedoStackSize = function() {
  return this.getPlugin("history").getRedoSize();
};
Ie.prototype.getUndoRemainSize = function() {
  return this.getPlugin("history").getUndoRemainSize();
};
var Q9 = function(n, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, r);
  else
    for (var s = n.length - 1; s >= 0; s--)
      (a = n[s]) && (o = (i < 3 ? a(o) : i > 3 ? a(e, t, o) : a(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
};
class p0 extends Yn {
  constructor(e = {}) {
    super(), this.name = "history", this.batchCommands = null, this.batchLevel = 0, this.lastBatchIndex = -1, this.freezed = !1, this.stackSize = 0, this.handlers = [];
    const { stackSize: t = 0 } = e;
    this.stackSize = t, this.options = Hn.getOptions(e), this.validator = new p0.Validator({
      history: this,
      cancelInvalid: this.options.cancelInvalid
    });
  }
  init(e) {
    this.graph = e, this.model = this.graph.model, this.clean(), this.startListening();
  }
  // #region api
  isEnabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled && (this.options.enabled = !0);
  }
  disable() {
    this.disabled || (this.options.enabled = !1);
  }
  toggleEnabled(e) {
    return e != null ? e !== this.isEnabled() && (e ? this.enable() : this.disable()) : this.isEnabled() ? this.disable() : this.enable(), this;
  }
  undo(e = {}) {
    if (!this.disabled) {
      const t = this.undoStack.pop();
      t && (this.revertCommand(t, e), this.redoStack.push(t), this.notify("undo", t, e));
    }
    return this;
  }
  redo(e = {}) {
    if (!this.disabled) {
      const t = this.redoStack.pop();
      t && (this.applyCommand(t, e), this.undoStackPush(t), this.notify("redo", t, e));
    }
    return this;
  }
  /**
   * Same as `undo()` but does not store the undo-ed command to the
   * `redoStack`. Canceled command therefore cannot be redo-ed.
   */
  cancel(e = {}) {
    if (!this.disabled) {
      const t = this.undoStack.pop();
      t && (this.revertCommand(t, e), this.redoStack = [], this.notify("cancel", t, e));
    }
    return this;
  }
  getSize() {
    return this.stackSize;
  }
  getUndoRemainSize() {
    const e = this.undoStack.length;
    return this.stackSize - e;
  }
  getUndoSize() {
    return this.undoStack.length;
  }
  getRedoSize() {
    return this.redoStack.length;
  }
  canUndo() {
    return !this.disabled && this.undoStack.length > 0;
  }
  canRedo() {
    return !this.disabled && this.redoStack.length > 0;
  }
  clean(e = {}) {
    return this.undoStack = [], this.redoStack = [], this.notify("clean", null, e), this;
  }
  // #endregion
  get disabled() {
    return this.options.enabled !== !0;
  }
  validate(e, ...t) {
    return this.validator.validate(e, ...t), this;
  }
  startListening() {
    this.model.on("batch:start", this.initBatchCommand, this), this.model.on("batch:stop", this.storeBatchCommand, this), this.options.eventNames && this.options.eventNames.forEach((e, t) => {
      this.handlers[t] = this.addCommand.bind(this, e), this.model.on(e, this.handlers[t]);
    }), this.validator.on("invalid", (e) => this.trigger("invalid", e));
  }
  stopListening() {
    this.model.off("batch:start", this.initBatchCommand, this), this.model.off("batch:stop", this.storeBatchCommand, this), this.options.eventNames && (this.options.eventNames.forEach((e, t) => {
      this.model.off(e, this.handlers[t]);
    }), this.handlers.length = 0), this.validator.off("invalid");
  }
  createCommand(e) {
    return {
      batch: e ? e.batch : !1,
      data: {}
    };
  }
  revertCommand(e, t) {
    this.freezed = !0;
    const r = Array.isArray(e) ? Hn.sortBatchCommands(e) : [e];
    for (let i = r.length - 1; i >= 0; i -= 1) {
      const o = r[i], a = Object.assign(Object.assign({}, t), Uk(o.options, this.options.revertOptionsList || []));
      this.executeCommand(o, !0, a);
    }
    this.freezed = !1;
  }
  applyCommand(e, t) {
    this.freezed = !0;
    const r = Array.isArray(e) ? Hn.sortBatchCommands(e) : [e];
    for (let i = 0; i < r.length; i += 1) {
      const o = r[i], a = Object.assign(Object.assign({}, t), Uk(o.options, this.options.applyOptionsList || []));
      this.executeCommand(o, !1, a);
    }
    this.freezed = !1;
  }
  executeCommand(e, t, r) {
    const i = this.model, o = i.getCell(e.data.id), a = e.event;
    if (Hn.isAddEvent(a) && t || Hn.isRemoveEvent(a) && !t)
      o && o.remove(r);
    else if (Hn.isAddEvent(a) && !t || Hn.isRemoveEvent(a) && t) {
      const s = e.data;
      s.node ? i.addNode(s.props, r) : s.edge && i.addEdge(s.props, r);
    } else if (Hn.isChangeEvent(a)) {
      const s = e.data, l = s.key;
      if (l && o) {
        const u = t ? s.prev[l] : s.next[l];
        s.key === "attrs" && this.ensureUndefinedAttrs(u, t ? s.next[l] : s.prev[l]) && (r.dirty = !0), o.prop(l, u, r);
      }
    } else {
      const s = this.options.executeCommand;
      s && rt(s, this, e, t, r);
    }
  }
  addCommand(e, t) {
    if (this.freezed || this.disabled)
      return;
    const r = t, i = r.options || {};
    if (i.dryrun || Hn.isAddEvent(e) && this.options.ignoreAdd || Hn.isRemoveEvent(e) && this.options.ignoreRemove || Hn.isChangeEvent(e) && this.options.ignoreChange)
      return;
    const o = this.options.beforeAddCommand;
    if (o != null && rt(o, this, e, t) === !1)
      return;
    e === "cell:change:*" && (e = `cell:change:${r.key}`);
    const a = r.cell, s = Ol.isModel(a);
    let l;
    if (this.batchCommands) {
      l = this.batchCommands[Math.max(this.lastBatchIndex, 0)];
      const c = s && !l.modelChange || l.data.id !== a.id, h = l.event !== e;
      if (this.lastBatchIndex >= 0 && (c || h)) {
        const f = this.batchCommands.findIndex((d) => (s && d.modelChange || d.data.id === a.id) && d.event === e);
        f < 0 || Hn.isAddEvent(e) || Hn.isRemoveEvent(e) ? l = this.createCommand({ batch: !0 }) : (l = this.batchCommands[f], this.batchCommands.splice(f, 1)), this.batchCommands.push(l), this.lastBatchIndex = this.batchCommands.length - 1;
      }
    } else
      l = this.createCommand({ batch: !1 });
    if (Hn.isAddEvent(e) || Hn.isRemoveEvent(e)) {
      const c = l.data;
      return l.event = e, l.options = i, c.id = a.id, c.props = Sn(a.toJSON()), a.isEdge() ? c.edge = !0 : a.isNode() && (c.node = !0), this.push(l, i);
    }
    if (Hn.isChangeEvent(e)) {
      const c = t.key, h = l.data;
      return (!l.batch || !l.event) && (l.event = e, l.options = i, h.key = c, h.prev == null && (h.prev = {}), h.prev[c] = Sn(a.previous(c)), s ? l.modelChange = !0 : h.id = a.id), h.next == null && (h.next = {}), h.next[c] = Sn(a.prop(c)), this.push(l, i);
    }
    const u = this.options.afterAddCommand;
    u && rt(u, this, e, t, l), this.push(l, i);
  }
  /**
   * Gather multiple changes into a single command. These commands could
   * be reverted with single `undo()` call. From the moment the function
   * is called every change made on model is not stored into the undoStack.
   * Changes are temporarily kept until `storeBatchCommand()` is called.
   */
  // eslint-disable-next-line
  initBatchCommand(e) {
    this.freezed || (this.batchCommands ? this.batchLevel += 1 : (this.batchCommands = [this.createCommand({ batch: !0 })], this.batchLevel = 0, this.lastBatchIndex = -1));
  }
  /**
   * Store changes temporarily kept in the undoStack. You have to call this
   * function as many times as `initBatchCommand()` been called.
   */
  storeBatchCommand(e) {
    if (!this.freezed)
      if (this.batchCommands && this.batchLevel <= 0) {
        const t = this.filterBatchCommand(this.batchCommands);
        t.length > 0 && (this.redoStack = [], this.undoStackPush(t), this.consolidateCommands(), this.notify("add", t, e)), this.batchCommands = null, this.lastBatchIndex = -1, this.batchLevel = 0;
      } else
        this.batchCommands && this.batchLevel > 0 && (this.batchLevel -= 1);
  }
  filterBatchCommand(e) {
    let t = e.slice();
    const r = [];
    for (; t.length > 0; ) {
      const i = t.shift(), o = i.event, a = i.data.id;
      if (o != null && (a != null || i.modelChange)) {
        if (Hn.isAddEvent(o)) {
          const s = t.findIndex((l) => Hn.isRemoveEvent(l.event) && l.data.id === a);
          if (s >= 0) {
            t = t.filter((l, u) => s < u || l.data.id !== a);
            continue;
          }
        } else if (Hn.isRemoveEvent(o)) {
          const s = t.findIndex((l) => Hn.isAddEvent(l.event) && l.data.id === a);
          if (s >= 0) {
            t.splice(s, 1);
            continue;
          }
        } else if (Hn.isChangeEvent(o)) {
          const s = i.data;
          if (hr(s.prev, s.next))
            continue;
        }
        r.push(i);
      }
    }
    return r;
  }
  notify(e, t, r) {
    const i = t == null ? null : Array.isArray(t) ? t : [t];
    this.emit(e, { cmds: i, options: r }), this.graph.trigger(`history:${e}`, { cmds: i, options: r }), this.emit("change", { cmds: i, options: r }), this.graph.trigger("history:change", { cmds: i, options: r });
  }
  push(e, t) {
    this.redoStack = [], e.batch ? (this.lastBatchIndex = Math.max(this.lastBatchIndex, 0), this.emit("batch", { cmd: e, options: t })) : (this.undoStackPush(e), this.consolidateCommands(), this.notify("add", e, t));
  }
  /**
   * Conditionally combine multiple undo items into one.
   *
   * Currently this is only used combine a `cell:changed:position` event
   * followed by multiple `cell:change:parent` and `cell:change:children`
   * events, such that a "move + embed" action can be undone in one step.
   *
   * See https://github.com/antvis/X6/issues/2421
   *
   * This is an ugly WORKAROUND. It does not solve deficiencies in the batch
   * system itself.
   */
  consolidateCommands() {
    var e;
    const t = this.undoStack[this.undoStack.length - 1], r = this.undoStack[this.undoStack.length - 2];
    if (!Array.isArray(t))
      return;
    const i = new Set(t.map((a) => a.event));
    if (i.size !== 2 || !i.has("cell:change:parent") || !i.has("cell:change:children") || !t.every((a) => {
      var s;
      return a.batch && ((s = a.options) === null || s === void 0 ? void 0 : s.ui);
    }) || !Array.isArray(r) || r.length !== 1)
      return;
    const o = r[0];
    o.event !== "cell:change:position" || !(!((e = o.options) === null || e === void 0) && e.ui) || (r.push(...t), this.undoStack.pop());
  }
  undoStackPush(e) {
    if (this.stackSize === 0) {
      this.undoStack.push(e);
      return;
    }
    this.undoStack.length >= this.stackSize && this.undoStack.shift(), this.undoStack.push(e);
  }
  ensureUndefinedAttrs(e, t) {
    let r = !1;
    return e !== null && t !== null && typeof e == "object" && typeof t == "object" && Object.keys(t).forEach((i) => {
      e[i] === void 0 && t[i] !== void 0 ? (e[i] = void 0, r = !0) : typeof e[i] == "object" && typeof t[i] == "object" && (r = this.ensureUndefinedAttrs(e[i], t[i]));
    }), r;
  }
  dispose() {
    this.validator.dispose(), this.clean(), this.stopListening(), this.off();
  }
}
Q9([
  Yn.dispose()
], p0.prototype, "dispose", null);
(function(n) {
  class e extends Yn {
    constructor(r) {
      super(), this.map = {}, this.command = r.history, this.cancelInvalid = r.cancelInvalid !== !1, this.command.on("add", this.onCommandAdded, this);
    }
    onCommandAdded({ cmds: r }) {
      return Array.isArray(r) ? r.every((i) => this.isValidCommand(i)) : this.isValidCommand(r);
    }
    isValidCommand(r) {
      if (r.options && r.options.validation === !1)
        return !0;
      const i = r.event && this.map[r.event] || [];
      let o = null;
      return i.forEach((a) => {
        let s = 0;
        const l = (u) => {
          const c = a[s];
          s += 1;
          try {
            if (c)
              c(u, r, l);
            else {
              o = u;
              return;
            }
          } catch (h) {
            l(h);
          }
        };
        l(o);
      }), o ? (this.cancelInvalid && this.command.cancel(), this.emit("invalid", { err: o }), !1) : !0;
    }
    validate(r, ...i) {
      const o = Array.isArray(r) ? r : r.split(/\s+/);
      return i.forEach((a) => {
        if (typeof a != "function")
          throw new Error(`${o.join(" ")} requires callback functions.`);
      }), o.forEach((a) => {
        this.map[a] == null && (this.map[a] = []), this.map[a].push(i);
      }), this;
    }
    dispose() {
      this.command.off("add", this.onCommandAdded, this);
    }
  }
  Q9([
    Yn.dispose()
  ], e.prototype, "dispose", null), n.Validator = e;
})(p0 || (p0 = {}));
var Hn;
(function(n) {
  function e(a) {
    return a === "cell:added";
  }
  n.isAddEvent = e;
  function t(a) {
    return a === "cell:removed";
  }
  n.isRemoveEvent = t;
  function r(a) {
    return a != null && a.startsWith("cell:change:");
  }
  n.isChangeEvent = r;
  function i(a) {
    const s = [
      "cell:added",
      "cell:removed",
      "cell:change:*"
    ], l = ["batch:start", "batch:stop"], u = a.eventNames ? a.eventNames.filter((c) => !(n.isChangeEvent(c) || s.includes(c) || l.includes(c))) : s;
    return Object.assign(Object.assign({ enabled: !0 }, a), { eventNames: u, applyOptionsList: a.applyOptionsList || ["propertyPath"], revertOptionsList: a.revertOptionsList || ["propertyPath"] });
  }
  n.getOptions = i;
  function o(a) {
    const s = [];
    for (let l = 0, u = a.length; l < u; l += 1) {
      const c = a[l];
      let h = null;
      if (n.isAddEvent(c.event)) {
        const f = c.data.id;
        for (let d = 0; d < l; d += 1)
          if (a[d].data.id === f) {
            h = d;
            break;
          }
      }
      h !== null ? s.splice(h, 0, c) : s.push(c);
    }
    return s;
  }
  n.sortBatchCommands = o;
})(Hn || (Hn = {}));
const hn = "md-editor", TEe = "md-editor-v3", kEe = "https://at.alicdn.com/t/c/font_2605852_prouiefeic.js", PEe = "https://at.alicdn.com/t/c/font_2605852_prouiefeic.css", yr = "https://cdnjs.cloudflare.com/ajax/libs", EEe = `${yr}/highlight.js/11.8.0/highlight.min.js`, MEe = [
  "bold",
  "underline",
  "italic",
  "strikeThrough",
  "-",
  "title",
  "sub",
  "sup",
  "quote",
  "unorderedList",
  "orderedList",
  "task",
  "-",
  "codeRow",
  "code",
  "link",
  "image",
  "table",
  "mermaid",
  "katex",
  "-",
  "revoke",
  "next",
  "save",
  "=",
  "prettier",
  "pageFullscreen",
  "fullscreen",
  "preview",
  "htmlPreview",
  "catalog",
  "github"
], DEe = ["markdownTotal", "=", "scrollSwitch"], O5 = {
  "zh-CN": {
    toolbarTips: {
      bold: "加粗",
      underline: "下划线",
      italic: "斜体",
      strikeThrough: "删除线",
      title: "标题",
      sub: "下标",
      sup: "上标",
      quote: "引用",
      unorderedList: "无序列表",
      orderedList: "有序列表",
      task: "任务列表",
      codeRow: "行内代码",
      code: "块级代码",
      link: "链接",
      image: "图片",
      table: "表格",
      mermaid: "mermaid图",
      katex: "katex公式",
      revoke: "后退",
      next: "前进",
      save: "保存",
      prettier: "美化",
      pageFullscreen: "浏览器全屏",
      fullscreen: "屏幕全屏",
      preview: "预览",
      htmlPreview: "html代码预览",
      catalog: "目录",
      github: "源码地址"
    },
    titleItem: {
      h1: "一级标题",
      h2: "二级标题",
      h3: "三级标题",
      h4: "四级标题",
      h5: "五级标题",
      h6: "六级标题"
    },
    imgTitleItem: {
      link: "添加链接",
      upload: "上传图片",
      clip2upload: "裁剪上传"
    },
    linkModalTips: {
      linkTitle: "添加链接",
      imageTitle: "添加图片",
      descLabel: "链接描述：",
      descLabelPlaceHolder: "请输入描述...",
      urlLabel: "链接地址：",
      urlLabelPlaceHolder: "请输入链接...",
      buttonOK: "确定"
    },
    clipModalTips: {
      title: "裁剪图片上传",
      buttonUpload: "上传"
    },
    copyCode: {
      text: "复制代码",
      successTips: "已复制！",
      failTips: "复制失败！"
    },
    mermaid: {
      flow: "流程图",
      sequence: "时序图",
      gantt: "甘特图",
      class: "类图",
      state: "状态图",
      pie: "饼图",
      relationship: "关系图",
      journey: "旅程图"
    },
    katex: {
      inline: "行内公式",
      block: "块级公式"
    },
    footer: {
      markdownTotal: "字数",
      scrollAuto: "同步滚动"
    }
  },
  "en-US": {
    toolbarTips: {
      bold: "bold",
      underline: "underline",
      italic: "italic",
      strikeThrough: "strikeThrough",
      title: "title",
      sub: "subscript",
      sup: "superscript",
      quote: "quote",
      unorderedList: "unordered list",
      orderedList: "ordered list",
      task: "task list",
      codeRow: "inline code",
      code: "block-level code",
      link: "link",
      image: "image",
      table: "table",
      mermaid: "mermaid",
      katex: "formula",
      revoke: "revoke",
      next: "undo revoke",
      save: "save",
      prettier: "prettier",
      pageFullscreen: "fullscreen in page",
      fullscreen: "fullscreen",
      preview: "preview",
      htmlPreview: "html preview",
      catalog: "catalog",
      github: "source code"
    },
    titleItem: {
      h1: "Lv1 Heading",
      h2: "Lv2 Heading",
      h3: "Lv3 Heading",
      h4: "Lv4 Heading",
      h5: "Lv5 Heading",
      h6: "Lv6 Heading"
    },
    imgTitleItem: {
      link: "Add Img Link",
      upload: "Upload Img",
      clip2upload: "Clip Upload"
    },
    linkModalTips: {
      linkTitle: "Add Link",
      imageTitle: "Add Image",
      descLabel: "Desc:",
      descLabelPlaceHolder: "Enter a description...",
      urlLabel: "Link:",
      urlLabelPlaceHolder: "Enter a link...",
      buttonOK: "OK"
    },
    clipModalTips: {
      title: "Crop Image",
      buttonUpload: "Upload"
    },
    copyCode: {
      text: "Copy",
      successTips: "Copied!",
      failTips: "Copy failed!"
    },
    mermaid: {
      flow: "flow",
      sequence: "sequence",
      gantt: "gantt",
      class: "class",
      state: "state",
      pie: "pie",
      relationship: "relationship",
      journey: "journey"
    },
    katex: {
      inline: "inline",
      block: "block"
    },
    footer: {
      markdownTotal: "Character Count",
      scrollAuto: "Scroll Auto"
    }
  }
}, LEe = `${yr}/mermaid/10.6.1/mermaid.esm.min.mjs`, w5 = {
  js: `${yr}/KaTeX/0.16.9/katex.min.js`,
  css: `${yr}/KaTeX/0.16.9/katex.min.css`
}, x5 = {
  a11y: {
    light: `${yr}/highlight.js/11.8.0/styles/a11y-light.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/a11y-dark.min.css`
  },
  atom: {
    light: `${yr}/highlight.js/11.8.0/styles/atom-one-light.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/atom-one-dark.min.css`
  },
  github: {
    light: `${yr}/highlight.js/11.8.0/styles/github.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/github-dark.min.css`
  },
  gradient: {
    light: `${yr}/highlight.js/11.8.0/styles/gradient-light.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/gradient-dark.min.css`
  },
  kimbie: {
    light: `${yr}/highlight.js/11.8.0/styles/kimbie-light.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/kimbie-dark.min.css`
  },
  paraiso: {
    light: `${yr}/highlight.js/11.8.0/styles/paraiso-light.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/paraiso-dark.min.css`
  },
  qtcreator: {
    light: `${yr}/highlight.js/11.8.0/styles/qtcreator-light.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/qtcreator-dark.min.css`
  },
  stackoverflow: {
    light: `${yr}/highlight.js/11.8.0/styles/stackoverflow-light.min.css`,
    dark: `${yr}/highlight.js/11.8.0/styles/stackoverflow-dark.min.css`
  }
}, fl = {
  editorExtensions: {},
  editorConfig: {},
  codeMirrorExtensions: (n, e) => e,
  markdownItConfig: () => {
  },
  markdownItPlugins: (n) => n,
  iconfontType: "svg",
  mermaidConfig: (n) => n
}, xI = (n, e = 200) => {
  let t = 0;
  return (...r) => new Promise((i) => {
    t && (clearTimeout(t), i("cancel")), t = window.setTimeout(() => {
      n.apply(void 0, r), t = 0, i("done");
    }, e);
  });
}, YP = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`;
var IEe = Object.defineProperty, REe = (n, e, t) => e in n ? IEe(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, NEe = (n, e, t) => (REe(n, typeof e != "symbol" ? e + "" : e, t), t);
let $Ee = class {
  constructor() {
    NEe(this, "pools", {});
  }
  // 移除事件监听
  remove(e, t, r) {
    const i = this.pools[e] && this.pools[e][t];
    i && (this.pools[e][t] = i.filter((o) => o !== r));
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(e) {
    this.pools[e] = {};
  }
  // 注册事件监听
  on(e, t) {
    return this.pools[e] || (this.pools[e] = {}), this.pools[e][t.name] || (this.pools[e][t.name] = []), this.pools[e][t.name].push(t.callback), this.pools[e][t.name].includes(t.callback);
  }
  // 触发事件
  emit(e, t, ...r) {
    this.pools[e] || (this.pools[e] = {});
    const i = this.pools[e][t];
    i && i.forEach((o) => {
      try {
        o(...r);
      } catch (a) {
        console.error(`${t} monitor event exception！`, a);
      }
    });
  }
};
const nf = new $Ee(), BEe = "buildFinished", S5 = "catalogChanged", VEe = "pushCatalog", Z9 = "rerender", zEe = (n) => {
  if (!n)
    return n;
  const e = n.split(`
`), t = ['<span rn-wrapper aria-hidden="true">'];
  return e.forEach(() => {
    t.push("<span></span>");
  }), t.push("</span>"), `<span class="code-block">${n}</span>${t.join("")}`;
}, rd = (n, e = "") => {
  const t = document.getElementById(n.id), r = n.onload;
  n.onload = null;
  const i = function(o) {
    typeof r == "function" && r.bind(this)(o), n.removeEventListener("load", i);
  };
  t ? e !== "" && (t.addEventListener("load", i), Reflect.get(window, e) && t.dispatchEvent(new Event("load"))) : (n.addEventListener("load", i), document.head.appendChild(n));
}, FEe = xI((n, e, t) => {
  const r = document.getElementById(n);
  r && r.setAttribute(e, t);
}, 10);
class on {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = Fg(this, e, t);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      i,
      1
      /* Open.From */
    ), Hs.from(i, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = Fg(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), Hs.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Sy(this), o = new Sy(e);
    for (let a = t, s = t; ; ) {
      if (i.next(a), o.next(a), a = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
        return !1;
      if (s += i.value.length, i.done || s >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Sy(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new W9(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new G9(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? on.empty : e.length <= 32 ? new sr(e) : Hs.from(sr.split(e, []));
  }
}
class sr extends on {
  constructor(e, t = QEe(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, i) {
    for (let o = 0; ; o++) {
      let a = this.text[o], s = i + a.length;
      if ((t ? r : s) >= e)
        return new ZEe(i, s, r, a);
      i = s + 1, r++;
    }
  }
  decompose(e, t, r, i) {
    let o = e <= 0 && t >= this.length ? this : new sr(_5(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (i & 1) {
      let a = r.pop(), s = ww(o.text, a.text.slice(), 0, o.length);
      if (s.length <= 32)
        r.push(new sr(s, a.length + o.length));
      else {
        let l = s.length >> 1;
        r.push(new sr(s.slice(0, l)), new sr(s.slice(l)));
      }
    } else
      r.push(o);
  }
  replace(e, t, r) {
    if (!(r instanceof sr))
      return super.replace(e, t, r);
    [e, t] = Fg(this, e, t);
    let i = ww(this.text, ww(r.text, _5(this.text, 0, e)), t), o = this.length + r.length - (t - e);
    return i.length <= 32 ? new sr(i, o) : Hs.from(sr.split(i, []), o);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = Fg(this, e, t);
    let i = "";
    for (let o = 0, a = 0; o <= t && a < this.text.length; a++) {
      let s = this.text[a], l = o + s.length;
      o > e && a && (i += r), e < l && t > o && (i += s.slice(Math.max(0, e - o), t - o)), o = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], i = -1;
    for (let o of e)
      r.push(o), i += o.length + 1, r.length == 32 && (t.push(new sr(r, i)), r = [], i = -1);
    return i > -1 && t.push(new sr(r, i)), t;
  }
}
class Hs extends on {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, i) {
    for (let o = 0; ; o++) {
      let a = this.children[o], s = i + a.length, l = r + a.lines - 1;
      if ((t ? l : s) >= e)
        return a.lineInner(e, t, r, i);
      i = s + 1, r = l + 1;
    }
  }
  decompose(e, t, r, i) {
    for (let o = 0, a = 0; a <= t && o < this.children.length; o++) {
      let s = this.children[o], l = a + s.length;
      if (e <= l && t >= a) {
        let u = i & ((a <= e ? 1 : 0) | (l >= t ? 2 : 0));
        a >= e && l <= t && !u ? r.push(s) : s.decompose(e - a, t - a, r, u);
      }
      a = l + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = Fg(this, e, t), r.lines < this.lines)
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let a = this.children[i], s = o + a.length;
        if (e >= o && t <= s) {
          let l = a.replace(e - o, t - o, r), u = this.lines - a.lines + l.lines;
          if (l.lines < u >> 4 && l.lines > u >> 6) {
            let c = this.children.slice();
            return c[i] = l, new Hs(c, this.length - (t - e) + r.length);
          }
          return super.replace(o, s, l);
        }
        o = s + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = Fg(this, e, t);
    let i = "";
    for (let o = 0, a = 0; o < this.children.length && a <= t; o++) {
      let s = this.children[o], l = a + s.length;
      a > e && o && (i += r), e < l && t > a && (i += s.sliceString(e - a, t - a, r)), a = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Hs))
      return 0;
    let r = 0, [i, o, a, s] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += t, o += t) {
      if (i == a || o == s)
        return r;
      let l = this.children[i], u = e.children[o];
      if (l != u)
        return r + l.scanIdentical(u, t);
      r += l.length + 1;
    }
  }
  static from(e, t = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let d of e)
      r += d.lines;
    if (r < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new sr(d, t);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), o = i << 1, a = i >> 1, s = [], l = 0, u = -1, c = [];
    function h(d) {
      let p;
      if (d.lines > o && d instanceof Hs)
        for (let g of d.children)
          h(g);
      else
        d.lines > a && (l > a || !l) ? (f(), s.push(d)) : d instanceof sr && l && (p = c[c.length - 1]) instanceof sr && d.lines + p.lines <= 32 ? (l += d.lines, u += d.length + 1, c[c.length - 1] = new sr(p.text.concat(d.text), p.length + 1 + d.length)) : (l + d.lines > i && f(), l += d.lines, u += d.length + 1, c.push(d));
    }
    function f() {
      l != 0 && (s.push(c.length == 1 ? c[0] : Hs.from(c, u)), u = -1, l = c.length = 0);
    }
    for (let d of e)
      h(d);
    return f(), s.length == 1 ? s[0] : new Hs(s, t);
  }
}
on.empty = /* @__PURE__ */ new sr([""], 0);
function QEe(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function ww(n, e, t = 0, r = 1e9) {
  for (let i = 0, o = 0, a = !0; o < n.length && i <= r; o++) {
    let s = n[o], l = i + s.length;
    l >= t && (l > r && (s = s.slice(0, r - i)), i < t && (s = s.slice(t - i)), a ? (e[e.length - 1] += s, a = !1) : e.push(s)), i = l + 1;
  }
  return e;
}
function _5(n, e, t) {
  return ww(n, [""], e, t);
}
class Sy {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof sr ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], o = this.offsets[r], a = o >> 1, s = i instanceof sr ? i.text.length : i.children.length;
      if (a == (t > 0 ? s : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof sr) {
        let l = i.text[a + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = i.children[a + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof sr ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class W9 {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new Sy(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * t, this.value = i.length <= r ? i : t < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class G9 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: i } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (on.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Sy.prototype[Symbol.iterator] = W9.prototype[Symbol.iterator] = G9.prototype[Symbol.iterator] = function() {
  return this;
});
let ZEe = class {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function Fg(n, e, t) {
  return e = Math.max(0, Math.min(n.length, e)), [e, Math.max(e, Math.min(n.length, t))];
}
let Fp = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((n) => n ? parseInt(n, 36) : 1);
for (let n = 1; n < Fp.length; n++)
  Fp[n] += Fp[n - 1];
function WEe(n) {
  for (let e = 1; e < Fp.length; e += 2)
    if (Fp[e] > n)
      return Fp[e - 1] <= n;
  return !1;
}
function C5(n) {
  return n >= 127462 && n <= 127487;
}
const A5 = 8205;
function hi(n, e, t = !0, r = !0) {
  return (t ? j9 : GEe)(n, e, r);
}
function j9(n, e, t) {
  if (e == n.length)
    return e;
  e && H9(n.charCodeAt(e)) && q9(n.charCodeAt(e - 1)) && e--;
  let r = ai(n, e);
  for (e += va(r); e < n.length; ) {
    let i = ai(n, e);
    if (r == A5 || i == A5 || t && WEe(i))
      e += va(i), r = i;
    else if (C5(i)) {
      let o = 0, a = e - 2;
      for (; a >= 0 && C5(ai(n, a)); )
        o++, a -= 2;
      if (o % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function GEe(n, e, t) {
  for (; e > 0; ) {
    let r = j9(n, e - 2, t);
    if (r < e)
      return r;
    e--;
  }
  return 0;
}
function H9(n) {
  return n >= 56320 && n < 57344;
}
function q9(n) {
  return n >= 55296 && n < 56320;
}
function ai(n, e) {
  let t = n.charCodeAt(e);
  if (!q9(t) || e + 1 == n.length)
    return t;
  let r = n.charCodeAt(e + 1);
  return H9(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function SI(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function va(n) {
  return n < 65536 ? 1 : 2;
}
const XP = /\r\n?|\n/;
var ui = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(ui || (ui = {}));
class dl {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, i = 0; t < this.sections.length; ) {
      let o = this.sections[t++], a = this.sections[t++];
      a < 0 ? (e(r, i, o), i += o) : i += a, r += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    UP(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new dl(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Y9(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : KP(this, e, t);
  }
  mapPos(e, t = -1, r = ui.Simple) {
    let i = 0, o = 0;
    for (let a = 0; a < this.sections.length; ) {
      let s = this.sections[a++], l = this.sections[a++], u = i + s;
      if (l < 0) {
        if (u > e)
          return o + (e - i);
        o += s;
      } else {
        if (r != ui.Simple && u >= e && (r == ui.TrackDel && i < e && u > e || r == ui.TrackBefore && i < e || r == ui.TrackAfter && u > e))
          return null;
        if (u > e || u == e && t < 0 && !s)
          return e == i || t < 0 ? o : o + l;
        o += l;
      }
      i = u;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= t; ) {
      let o = this.sections[r++], a = this.sections[r++], s = i + o;
      if (a >= 0 && i <= t && s >= e)
        return i < e && s > t ? "cover" : !0;
      i = s;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new dl(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new dl(e);
  }
}
class Lr extends dl {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return UP(this, (t, r, i, o, a) => e = e.replace(i, i + (r - t), a), !1), e;
  }
  mapDesc(e, t = !1) {
    return KP(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let i = 0, o = 0; i < t.length; i += 2) {
      let a = t[i], s = t[i + 1];
      if (s >= 0) {
        t[i] = s, t[i + 1] = a;
        let l = i >> 1;
        for (; r.length < l; )
          r.push(on.empty);
        r.push(a ? e.slice(o, o + a) : on.empty);
      }
      o += a;
    }
    return new Lr(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Y9(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : KP(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    UP(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return dl.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], i = [], o = new g0(this);
    e:
      for (let a = 0, s = 0; ; ) {
        let l = a == e.length ? 1e9 : e[a++];
        for (; s < l || s == l && o.len == 0; ) {
          if (o.done)
            break e;
          let c = Math.min(o.len, l - s);
          Pi(i, c, -1);
          let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
          Pi(t, c, h), h > 0 && uc(r, t, o.text), o.forward(c), s += c;
        }
        let u = e[a++];
        for (; s < u; ) {
          if (o.done)
            break e;
          let c = Math.min(o.len, u - s);
          Pi(t, c, -1), Pi(i, c, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(c), s += c;
        }
      }
    return {
      changes: new Lr(t, r),
      filtered: dl.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], i = this.sections[t + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let i = [], o = [], a = 0, s = null;
    function l(c = !1) {
      if (!c && !i.length)
        return;
      a < t && Pi(i, t - a, -1);
      let h = new Lr(i, o);
      s = s ? s.compose(h.map(s)) : h, i = [], o = [], a = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let h of c)
          u(h);
      else if (c instanceof Lr) {
        if (c.length != t)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${t})`);
        l(), s = s ? s.compose(c.map(s)) : c;
      } else {
        let { from: h, to: f = h, insert: d } = c;
        if (h > f || h < 0 || f > t)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? on.of(d.split(r || XP)) : d : on.empty, g = p.length;
        if (h == f && g == 0)
          return;
        h < a && l(), h > a && Pi(i, h - a, -1), Pi(i, f - h, g), uc(o, i, p), a = f;
      }
    }
    return u(e), l(!s), s;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Lr(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (typeof o == "number")
        t.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((a, s) => s && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          t.push(o[0], 0);
        else {
          for (; r.length < i; )
            r.push(on.empty);
          r[i] = on.of(o.slice(1)), t.push(o[0], r[i].length);
        }
      }
    }
    return new Lr(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new Lr(e, t);
  }
}
function Pi(n, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let i = n.length - 2;
  i >= 0 && t <= 0 && t == n[i + 1] ? n[i] += e : e == 0 && n[i] == 0 ? n[i + 1] += t : r ? (n[i] += e, n[i + 1] += t) : n.push(e, t);
}
function uc(n, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < r; )
      n.push(on.empty);
    n.push(t);
  }
}
function UP(n, e, t) {
  let r = n.inserted;
  for (let i = 0, o = 0, a = 0; a < n.sections.length; ) {
    let s = n.sections[a++], l = n.sections[a++];
    if (l < 0)
      i += s, o += s;
    else {
      let u = i, c = o, h = on.empty;
      for (; u += s, c += l, l && r && (h = h.append(r[a - 2 >> 1])), !(t || a == n.sections.length || n.sections[a + 1] < 0); )
        s = n.sections[a++], l = n.sections[a++];
      e(i, u, o, c, h), i = u, o = c;
    }
  }
}
function KP(n, e, t, r = !1) {
  let i = [], o = r ? [] : null, a = new g0(n), s = new g0(e);
  for (let l = -1; ; )
    if (a.ins == -1 && s.ins == -1) {
      let u = Math.min(a.len, s.len);
      Pi(i, u, -1), a.forward(u), s.forward(u);
    } else if (s.ins >= 0 && (a.ins < 0 || l == a.i || a.off == 0 && (s.len < a.len || s.len == a.len && !t))) {
      let u = s.len;
      for (Pi(i, s.ins, -1); u; ) {
        let c = Math.min(a.len, u);
        a.ins >= 0 && l < a.i && a.len <= c && (Pi(i, 0, a.ins), o && uc(o, i, a.text), l = a.i), a.forward(c), u -= c;
      }
      s.next();
    } else if (a.ins >= 0) {
      let u = 0, c = a.len;
      for (; c; )
        if (s.ins == -1) {
          let h = Math.min(c, s.len);
          u += h, c -= h, s.forward(h);
        } else if (s.ins == 0 && s.len < c)
          c -= s.len, s.next();
        else
          break;
      Pi(i, u, l < a.i ? a.ins : 0), o && l < a.i && uc(o, i, a.text), l = a.i, a.forward(a.len - c);
    } else {
      if (a.done && s.done)
        return o ? Lr.createSet(i, o) : dl.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function Y9(n, e, t = !1) {
  let r = [], i = t ? [] : null, o = new g0(n), a = new g0(e);
  for (let s = !1; ; ) {
    if (o.done && a.done)
      return i ? Lr.createSet(r, i) : dl.create(r);
    if (o.ins == 0)
      Pi(r, o.len, 0, s), o.next();
    else if (a.len == 0 && !a.done)
      Pi(r, 0, a.ins, s), i && uc(i, r, a.text), a.next();
    else {
      if (o.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(o.len2, a.len), u = r.length;
        if (o.ins == -1) {
          let c = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          Pi(r, l, c, s), i && c && uc(i, r, a.text);
        } else
          a.ins == -1 ? (Pi(r, o.off ? 0 : o.len, l, s), i && uc(i, r, o.textBit(l))) : (Pi(r, o.off ? 0 : o.len, a.off ? 0 : a.ins, s), i && !a.off && uc(i, r, a.text));
        s = (o.ins > l || a.ins >= 0 && a.len > l) && (s || r.length > u), o.forward2(l), a.forward(l);
      }
    }
  }
}
class g0 {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? on.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? on.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class mf {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new mf(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return me.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return me.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return me.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new mf(e, t, r);
  }
}
class me {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : me.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new me([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return me.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, me.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new me(e.ranges.map((t) => mf.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new me([me.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let o = e[i];
      if (o.empty ? o.from <= r : o.from < r)
        return me.normalized(e.slice(), t);
      r = o.to;
    }
    return new me(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, i) {
    return mf.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, i) {
    let o = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return t < e ? mf.create(t, e, 48 | o) : mf.create(e, t, (t > e ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((i, o) => i.from - o.from), t = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let o = e[i], a = e[i - 1];
      if (o.empty ? o.from <= a.to : o.from < a.to) {
        let s = a.from, l = Math.max(o.to, a.to);
        i <= t && t--, e.splice(--i, 2, o.anchor > o.head ? me.range(l, s) : me.range(s, l));
      }
    }
    return new me(e, t);
  }
}
function X9(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let _I = 0;
class Ze {
  constructor(e, t, r, i, o) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = i, this.id = _I++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Ze(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : CI), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new xw([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xw(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xw(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function CI(n, e) {
  return n == e || n.length == e.length && n.every((t, r) => t === e[r]);
}
class xw {
  constructor(e, t, r, i) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = i, this.id = _I++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, i = this.facet.compareInput, o = this.id, a = e[o] >> 1, s = this.type == 2, l = !1, u = !1, c = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? u = !0 : ((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1 || c.push(e[h.id]);
    return {
      create(h) {
        return h.values[a] = r(h), 1;
      },
      update(h, f) {
        if (l && f.docChanged || u && (f.docChanged || f.selection) || JP(h, c)) {
          let d = r(h);
          if (s ? !T5(d, h.values[a], i) : !i(d, h.values[a]))
            return h.values[a] = d, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d, p = f.config.address[o];
        if (p != null) {
          let g = Lx(f, p);
          if (this.dependencies.every((v) => v instanceof Ze ? f.facet(v) === h.facet(v) : v instanceof Kr ? f.field(v, !1) == h.field(v, !1) : !0) || (s ? T5(d = r(h), g, i) : i(d = r(h), g)))
            return h.values[a] = g, 0;
        } else
          d = r(h);
        return h.values[a] = d, 1;
      }
    };
  }
}
function T5(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!t(n[r], e[r]))
      return !1;
  return !0;
}
function JP(n, e) {
  let t = !1;
  for (let r of e)
    _y(n, r) & 1 && (t = !0);
  return t;
}
function jEe(n, e, t) {
  let r = t.map((l) => n[l.id]), i = t.map((l) => l.type), o = r.filter((l) => !(l & 1)), a = n[e.id] >> 1;
  function s(l) {
    let u = [];
    for (let c = 0; c < r.length; c++) {
      let h = Lx(l, r[c]);
      if (i[c] == 2)
        for (let f of h)
          u.push(f);
      else
        u.push(h);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of r)
        _y(l, u);
      return l.values[a] = s(l), 1;
    },
    update(l, u) {
      if (!JP(l, o))
        return 0;
      let c = s(l);
      return e.compare(c, l.values[a]) ? 0 : (l.values[a] = c, 1);
    },
    reconfigure(l, u) {
      let c = JP(l, r), h = u.config.facets[e.id], f = u.facet(e);
      if (h && !c && CI(t, h))
        return l.values[a] = f, 0;
      let d = s(l);
      return e.compare(d, f) ? (l.values[a] = f, 0) : (l.values[a] = d, 1);
    }
  };
}
const k5 = /* @__PURE__ */ Ze.define({ static: !0 });
class Kr {
  constructor(e, t, r, i, o) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = i, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new Kr(_I++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(k5).find((r) => r.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, i) => {
        let o = r.values[t], a = this.updateF(o, i);
        return this.compareF(o, a) ? 0 : (r.values[t] = a, 1);
      },
      reconfigure: (r, i) => i.config.address[this.id] != null ? (r.values[t] = i.field(this), 0) : (r.values[t] = this.create(r), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, k5.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const rf = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Xv(n) {
  return (e) => new U9(e, n);
}
const kd = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Xv(rf.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Xv(rf.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Xv(rf.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Xv(rf.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Xv(rf.lowest)
};
class U9 {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class $_ {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new eE(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return $_.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class eE {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Dx {
  constructor(e, t, r, i, o, a) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = i, this.staticValues = o, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let i = [], o = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let f of HEe(e, t, a))
      f instanceof Kr ? i.push(f) : (o[f.facet.id] || (o[f.facet.id] = [])).push(f);
    let s = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let f of i)
      s[f.id] = u.length << 1, u.push((d) => f.slot(d));
    let c = r == null ? void 0 : r.config.facets;
    for (let f in o) {
      let d = o[f], p = d[0].facet, g = c && c[f] || [];
      if (d.every(
        (v) => v.type == 0
        /* Provider.Static */
      ))
        if (s[p.id] = l.length << 1 | 1, CI(g, d))
          l.push(r.facet(p));
        else {
          let v = p.combine(d.map((m) => m.value));
          l.push(r && p.compare(v, r.facet(p)) ? r.facet(p) : v);
        }
      else {
        for (let v of d)
          v.type == 0 ? (s[v.id] = l.length << 1 | 1, l.push(v.value)) : (s[v.id] = u.length << 1, u.push((m) => v.dynamicSlot(m)));
        s[p.id] = u.length << 1, u.push((v) => jEe(v, p, d));
      }
    }
    let h = u.map((f) => f(s));
    return new Dx(e, a, h, s, l, o);
  }
}
function HEe(n, e, t) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function o(a, s) {
    let l = i.get(a);
    if (l != null) {
      if (l <= s)
        return;
      let u = r[l].indexOf(a);
      u > -1 && r[l].splice(u, 1), a instanceof eE && t.delete(a.compartment);
    }
    if (i.set(a, s), Array.isArray(a))
      for (let u of a)
        o(u, s);
    else if (a instanceof eE) {
      if (t.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(a.compartment) || a.inner;
      t.set(a.compartment, u), o(u, s);
    } else if (a instanceof U9)
      o(a.inner, a.prec);
    else if (a instanceof Kr)
      r[s].push(a), a.provides && o(a.provides, s);
    else if (a instanceof xw)
      r[s].push(a), a.facet.extensions && o(a.facet.extensions, rf.default);
    else {
      let u = a.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(u, s);
    }
  }
  return o(n, rf.default), r.reduce((a, s) => a.concat(s));
}
function _y(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = n.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  n.status[t] = 4;
  let i = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | i;
}
function Lx(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const K9 = /* @__PURE__ */ Ze.define(), tE = /* @__PURE__ */ Ze.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), J9 = /* @__PURE__ */ Ze.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), eY = /* @__PURE__ */ Ze.define(), tY = /* @__PURE__ */ Ze.define(), nY = /* @__PURE__ */ Ze.define(), rY = /* @__PURE__ */ Ze.define({
  combine: (n) => n.length ? n[0] : !1
});
class Cu {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new qEe();
  }
}
class qEe {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Cu(this, e);
  }
}
class YEe {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Et(this, e);
  }
}
class Et {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new Et(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new YEe(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let o = i.map(t);
      o && r.push(o);
    }
    return r;
  }
}
Et.reconfigure = /* @__PURE__ */ Et.define();
Et.appendConfig = /* @__PURE__ */ Et.define();
class Or {
  constructor(e, t, r, i, o, a) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = i, this.annotations = o, this.scrollIntoView = a, this._doc = null, this._state = null, r && X9(r, t.newLength), o.some((s) => s.type == Or.time) || (this.annotations = o.concat(Or.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, i, o, a) {
    return new Or(e, t, r, i, o, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(Or.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
Or.time = /* @__PURE__ */ Cu.define();
Or.userEvent = /* @__PURE__ */ Cu.define();
Or.addToHistory = /* @__PURE__ */ Cu.define();
Or.remote = /* @__PURE__ */ Cu.define();
function XEe(n, e) {
  let t = [];
  for (let r = 0, i = 0; ; ) {
    let o, a;
    if (r < n.length && (i == e.length || e[i] >= n[r]))
      o = n[r++], a = n[r++];
    else if (i < e.length)
      o = e[i++], a = e[i++];
    else
      return t;
    !t.length || t[t.length - 1] < o ? t.push(o, a) : t[t.length - 1] < a && (t[t.length - 1] = a);
  }
}
function iY(n, e, t) {
  var r;
  let i, o, a;
  return t ? (i = e.changes, o = Lr.empty(e.changes.length), a = n.changes.compose(e.changes)) : (i = e.changes.map(n.changes), o = n.changes.mapDesc(e.changes, !0), a = n.changes.compose(i)), {
    changes: a,
    selection: e.selection ? e.selection.map(o) : (r = n.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: Et.mapEffects(n.effects, i).concat(Et.mapEffects(e.effects, o)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function nE(n, e, t) {
  let r = e.selection, i = Qp(e.annotations);
  return e.userEvent && (i = i.concat(Or.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Lr ? e.changes : Lr.of(e.changes || [], t, n.facet(J9)),
    selection: r && (r instanceof me ? r : me.single(r.anchor, r.head)),
    effects: Qp(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function oY(n, e, t) {
  let r = nE(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (t = !1);
    let a = !!e[o].sequential;
    r = iY(r, nE(n, e[o], a ? r.changes.newLength : n.doc.length), a);
  }
  let i = Or.create(n, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return KEe(t ? UEe(i) : i);
}
function UEe(n) {
  let e = n.startState, t = !0;
  for (let i of e.facet(eY)) {
    let o = i(n);
    if (o === !1) {
      t = !1;
      break;
    }
    Array.isArray(o) && (t = t === !0 ? o : XEe(t, o));
  }
  if (t !== !0) {
    let i, o;
    if (t === !1)
      o = n.changes.invertedDesc, i = Lr.empty(e.doc.length);
    else {
      let a = n.changes.filter(t);
      i = a.changes, o = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    n = Or.create(e, i, n.selection && n.selection.map(o), Et.mapEffects(n.effects, o), n.annotations, n.scrollIntoView);
  }
  let r = e.facet(tY);
  for (let i = r.length - 1; i >= 0; i--) {
    let o = r[i](n);
    o instanceof Or ? n = o : Array.isArray(o) && o.length == 1 && o[0] instanceof Or ? n = o[0] : n = oY(e, Qp(o), !1);
  }
  return n;
}
function KEe(n) {
  let e = n.startState, t = e.facet(nY), r = n;
  for (let i = t.length - 1; i >= 0; i--) {
    let o = t[i](n);
    o && Object.keys(o).length && (r = iY(r, nE(e, o, n.changes.newLength), !0));
  }
  return r == n ? n : Or.create(e, n.changes, n.selection, r.effects, r.annotations, r.scrollIntoView);
}
const JEe = [];
function Qp(n) {
  return n == null ? JEe : Array.isArray(n) ? n : [n];
}
var Zn = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(Zn || (Zn = {}));
const eMe = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let rE;
try {
  rE = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function tMe(n) {
  if (rE)
    return rE.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || eMe.test(t)))
      return !0;
  }
  return !1;
}
function nMe(n) {
  return (e) => {
    if (!/\S/.test(e))
      return Zn.Space;
    if (tMe(e))
      return Zn.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return Zn.Word;
    return Zn.Other;
  };
}
class nn {
  constructor(e, t, r, i, o, a) {
    this.config = e, this.doc = t, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, a && (a._state = this);
    for (let s = 0; s < this.config.dynamicSlots.length; s++)
      _y(this, s << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return _y(this, r), Lx(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return oY(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: i } = t;
    for (let s of e.effects)
      s.is($_.reconfigure) ? (t && (i = /* @__PURE__ */ new Map(), t.compartments.forEach((l, u) => i.set(u, l)), t = null), i.set(s.value.compartment, s.value.extension)) : s.is(Et.reconfigure) ? (t = null, r = s.value) : s.is(Et.appendConfig) && (t = null, r = Qp(r).concat(s.value));
    let o;
    t ? o = e.startState.values.slice() : (t = Dx.resolve(r, i, this), o = new nn(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, u) => u.reconfigure(l, this), null).values);
    let a = e.startState.facet(tE) ? e.newSelection : e.newSelection.asSingle();
    new nn(t, e.newDoc, a, o, (s, l) => l.update(s, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: me.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), i = this.changes(r.changes), o = [r.range], a = Qp(r.effects);
    for (let s = 1; s < t.ranges.length; s++) {
      let l = e(t.ranges[s]), u = this.changes(l.changes), c = u.map(i);
      for (let f = 0; f < s; f++)
        o[f] = o[f].map(c);
      let h = i.mapDesc(u, !0);
      o.push(l.range.map(h)), i = i.compose(c), a = Et.mapEffects(a, c).concat(Et.mapEffects(Qp(l.effects), h));
    }
    return {
      changes: i,
      selection: me.create(o, t.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Lr ? e : Lr.of(e, this.doc.length, this.facet(nn.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return on.of(e.split(this.facet(nn.lineSeparator) || XP));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (_y(this, t), Lx(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof Kr && this.config.address[i.id] != null && (t[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let o in r)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let a = r[o], s = e[o];
          i.push(a.init((l) => a.spec.fromJSON(s, l)));
        }
    }
    return nn.create({
      doc: e.doc,
      selection: me.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Dx.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof on ? e.doc : on.of((e.doc || "").split(t.staticFacet(nn.lineSeparator) || XP)), i = e.selection ? e.selection instanceof me ? e.selection : me.single(e.selection.anchor, e.selection.head) : me.single(0);
    return X9(i, r.length), t.staticFacet(tE) || (i = i.asSingle()), new nn(t, r, i, t.dynamicSlots.map(() => null), (o, a) => a.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(nn.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(nn.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(rY);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(nn.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let o = +(i || 1);
      return !o || o > t.length ? r : t[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let i = [];
    for (let o of this.facet(K9))
      for (let a of o(this, t, r))
        Object.prototype.hasOwnProperty.call(a, e) && i.push(a[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return nMe(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), a = e - r, s = e - r;
    for (; a > 0; ) {
      let l = hi(t, a, !1);
      if (o(t.slice(l, a)) != Zn.Word)
        break;
      a = l;
    }
    for (; s < i; ) {
      let l = hi(t, s);
      if (o(t.slice(s, l)) != Zn.Word)
        break;
      s = l;
    }
    return a == s ? null : me.range(a + r, s + r);
  }
}
nn.allowMultipleSelections = tE;
nn.tabSize = /* @__PURE__ */ Ze.define({
  combine: (n) => n.length ? n[0] : 4
});
nn.lineSeparator = J9;
nn.readOnly = rY;
nn.phrases = /* @__PURE__ */ Ze.define({
  compare(n, e) {
    let t = Object.keys(n), r = Object.keys(e);
    return t.length == r.length && t.every((i) => n[i] == e[i]);
  }
});
nn.languageData = K9;
nn.changeFilter = eY;
nn.transactionFilter = tY;
nn.transactionExtender = nY;
$_.reconfigure = /* @__PURE__ */ Et.define();
function El(n, e, t = {}) {
  let r = {};
  for (let i of n)
    for (let o of Object.keys(i)) {
      let a = i[o], s = r[o];
      if (s === void 0)
        r[o] = a;
      else if (!(s === a || a === void 0))
        if (Object.hasOwnProperty.call(t, o))
          r[o] = t[o](s, a);
        else
          throw new Error("Config merge conflict for field " + o);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class id {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return iE.create(e, t, this);
  }
}
id.prototype.startSide = id.prototype.endSide = 0;
id.prototype.point = !1;
id.prototype.mapMode = ui.TrackDel;
let iE = class aY {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new aY(e, t, r);
  }
};
function oE(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class AI {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, i = 0) {
    let o = r ? this.to : this.from;
    for (let a = i, s = o.length; ; ) {
      if (a == s)
        return a;
      let l = a + s >> 1, u = o[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == a)
        return u >= 0 ? a : s;
      u >= 0 ? s = l : a = l + 1;
    }
  }
  between(e, t, r, i) {
    for (let o = this.findIndex(t, -1e9, !0), a = this.findIndex(r, 1e9, !1, o); o < a; o++)
      if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], i = [], o = [], a = -1, s = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], c = this.from[l] + e, h = this.to[l] + e, f, d;
      if (c == h) {
        let p = t.mapPos(c, u.startSide, u.mapMode);
        if (p == null || (f = d = p, u.startSide != u.endSide && (d = t.mapPos(c, u.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(c, u.startSide), d = t.mapPos(h, u.endSide), f > d || f == d && u.startSide > 0 && u.endSide <= 0)
        continue;
      (d - f || u.endSide - u.startSide) < 0 || (a < 0 && (a = f), u.point && (s = Math.max(s, d - f)), r.push(u), i.push(f - a), o.push(d - a));
    }
    return { mapped: r.length ? new AI(i, o, r, s) : null, pos: a };
  }
}
class Kt {
  constructor(e, t, r, i) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, t, r, i) {
    return new Kt(e, t, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: i = 0, filterTo: o = this.length } = e, a = e.filter;
    if (t.length == 0 && !a)
      return this;
    if (r && (t = t.slice().sort(oE)), this.isEmpty)
      return t.length ? Kt.of(t) : this;
    let s = new sY(this, null, -1).goto(0), l = 0, u = [], c = new Vc();
    for (; s.value || l < t.length; )
      if (l < t.length && (s.from - t[l].from || s.startSide - t[l].value.startSide) >= 0) {
        let h = t[l++];
        c.addInner(h.from, h.to, h.value) || u.push(h);
      } else
        s.rangeIndex == 1 && s.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(s.chunkIndex) < t[l].from) && (!a || i > this.chunkEnd(s.chunkIndex) || o < this.chunkPos[s.chunkIndex]) && c.addChunk(this.chunkPos[s.chunkIndex], this.chunk[s.chunkIndex]) ? s.nextChunk() : ((!a || i > s.to || o < s.from || a(s.from, s.to, s.value)) && (c.addInner(s.from, s.to, s.value) || u.push(iE.create(s.from, s.to, s.value))), s.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? Kt.empty : this.nextLayer.update({ add: u, filter: a, filterFrom: i, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], i = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let s = this.chunkPos[a], l = this.chunk[a], u = e.touchesRange(s, s + l.length);
      if (u === !1)
        i = Math.max(i, l.maxPoint), t.push(l), r.push(e.mapPos(s));
      else if (u === !0) {
        let { mapped: c, pos: h } = l.map(s, e);
        c && (i = Math.max(i, c.maxPoint), t.push(c), r.push(h));
      }
    }
    let o = this.nextLayer.map(e);
    return t.length == 0 ? o : new Kt(r, t, o || Kt.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i], a = this.chunk[i];
        if (t >= o && e <= o + a.length && a.between(o, e - o, t - o, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return v0.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return v0.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, i, o = -1) {
    let a = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), s = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), l = P5(a, s, r), u = new Uv(a, l, o), c = new Uv(s, l, o);
    r.iterGaps((h, f, d) => E5(u, h, c, f, d, i)), r.empty && r.length == 0 && E5(u, 0, c, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, i) {
    i == null && (i = 999999999);
    let o = e.filter((c) => !c.isEmpty && t.indexOf(c) < 0), a = t.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (o.length != a.length)
      return !1;
    if (!o.length)
      return !0;
    let s = P5(o, a), l = new Uv(o, s, 0).goto(r), u = new Uv(a, s, 0).goto(r);
    for (; ; ) {
      if (l.to != u.to || !aE(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, i, o = -1) {
    let a = new Uv(e, null, o).goto(t), s = t, l = a.openStart;
    for (; ; ) {
      let u = Math.min(a.to, r);
      if (a.point) {
        let c = a.activeForPoint(a.to), h = a.pointFrom < t ? c.length + 1 : a.point.startSide < 0 ? c.length : Math.min(c.length, l);
        i.point(s, u, a.point, c, h, a.pointRank), l = Math.min(a.openEnd(u), c.length);
      } else
        u > s && (i.span(s, u, a.active, l), l = a.openEnd(u));
      if (a.to > r)
        return l + (a.point && a.to > r ? 1 : 0);
      s = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new Vc();
    for (let i of e instanceof iE ? [e] : t ? rMe(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Kt.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != Kt.empty; i = i.nextLayer)
        t = new Kt(i.chunkPos, i.chunk, t, Math.max(i.maxPoint, t.maxPoint));
    return t;
  }
}
Kt.empty = /* @__PURE__ */ new Kt([], [], null, -1);
function rMe(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let r = n[t];
      if (oE(e, r) > 0)
        return n.slice().sort(oE);
      e = r;
    }
  return n;
}
Kt.empty.nextLayer = Kt.empty;
class Vc {
  finishChunk(e) {
    this.chunks.push(new AI(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new Vc())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Kt.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Kt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function P5(n, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let o of n)
    for (let a = 0; a < o.chunk.length; a++)
      o.chunk[a].maxPoint <= 0 && r.set(o.chunk[a], o.chunkPos[a]);
  let i = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let a = 0; a < o.chunk.length; a++) {
      let s = r.get(o.chunk[a]);
      s != null && (t ? t.mapPos(s) : s) == o.chunkPos[a] && !(t != null && t.touchesRange(s, s + o.chunk[a].length)) && i.add(o.chunk[a]);
    }
  return i;
}
class sY {
  constructor(e, t, r, i = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class v0 {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let i = [];
    for (let o = 0; o < e.length; o++)
      for (let a = e[o]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= r && i.push(new sY(a, t, r, o));
    return i.length == 1 ? i[0] : new v0(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      T2(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      T2(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), T2(this.heap, 0);
    }
  }
}
function T2(n, e) {
  for (let t = n[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= n.length)
      break;
    let i = n[r];
    if (r + 1 < n.length && i.compare(n[r + 1]) >= 0 && (i = n[r + 1], r++), t.compare(i) < 0)
      break;
    n[r] = t, n[e] = i, e = r;
  }
}
class Uv {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = v0.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    S1(this.active, e), S1(this.activeTo, e), S1(this.activeRank, e), this.minActive = M5(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: i, rank: o } = this.cursor;
    for (; t < this.activeRank.length && (o - this.activeRank[t] || i - this.activeTo[t]) > 0; )
      t++;
    _1(this.active, t, r), _1(this.activeTo, t, i), _1(this.activeRank, t, o), e && _1(e, t, this.cursor.from), this.minActive = M5(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && S1(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function E5(n, e, t, r, i, o) {
  n.goto(e), t.goto(r);
  let a = r + i, s = r, l = r - e;
  for (; ; ) {
    let u = n.to + l - t.to || n.endSide - t.endSide, c = u < 0 ? n.to + l : t.to, h = Math.min(c, a);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && aE(n.activeForPoint(n.to), t.activeForPoint(t.to)) || o.comparePoint(s, h, n.point, t.point) : h > s && !aE(n.active, t.active) && o.compareRange(s, h, n.active, t.active), c > a)
      break;
    s = c, u <= 0 && n.next(), u >= 0 && t.next();
  }
}
function aE(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function S1(n, e) {
  for (let t = e, r = n.length - 1; t < r; t++)
    n[t] = n[t + 1];
  n.pop();
}
function _1(n, e, t) {
  for (let r = n.length - 1; r >= e; r--)
    n[r + 1] = n[r];
  n[e] = t;
}
function M5(n, e) {
  let t = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || n[i].endSide - n[t].endSide) < 0 && (t = i, r = e[i]);
  return t;
}
function wv(n, e, t = n.length) {
  let r = 0;
  for (let i = 0; i < t; )
    n.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = hi(n, i));
  return r;
}
function sE(n, e, t, r) {
  for (let i = 0, o = 0; ; ) {
    if (o >= e)
      return i;
    if (i == n.length)
      break;
    o += n.charCodeAt(i) == 9 ? t - o % t : 1, i = hi(n, i);
  }
  return r === !0 ? -1 : n.length;
}
const lE = "ͼ", D5 = typeof Symbol > "u" ? "__" + lE : Symbol.for(lE), uE = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), L5 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class zc {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function i(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    function o(a, s, l, u) {
      let c = [], h = /^@(\w+)\b/.exec(a[0]), f = h && h[1] == "keyframes";
      if (h && s == null)
        return l.push(a[0] + ";");
      for (let d in s) {
        let p = s[d];
        if (/&/.test(d))
          o(
            d.split(/,\s*/).map((g) => a.map((v) => g.replace(/&/, v))).reduce((g, v) => g.concat(v)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!h)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          o(i(d), p, c, f);
        } else
          p != null && c.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (c.length || f) && l.push((r && !h && !u ? a.map(r) : a).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let a in e)
      o(i(a), e[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = L5[D5] || 1;
    return L5[D5] = e + 1, lE + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let i = e[uE], o = r && r.nonce;
    i ? o && i.setNonce(o) : i = new iMe(e, o), i.mount(Array.isArray(t) ? t : [t]);
  }
}
let I5 = /* @__PURE__ */ new Map();
class iMe {
  constructor(e, t) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = I5.get(r);
      if (o)
        return e.adoptedStyleSheets = [o.sheet, ...e.adoptedStyleSheets], e[uE] = o;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], I5.set(r, this);
    } else {
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
      let o = e.head || e;
      o.insertBefore(this.styleTag, o.firstChild);
    }
    this.modules = [], e[uE] = this;
  }
  mount(e) {
    let t = this.sheet, r = 0, i = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], s = this.modules.indexOf(a);
      if (s < i && s > -1 && (this.modules.splice(s, 1), i--, s = -1), s == -1) {
        if (this.modules.splice(i++, 0, a), t)
          for (let l = 0; l < a.rules.length; l++)
            t.insertRule(a.rules[l], r++);
      } else {
        for (; i < s; )
          r += this.modules[i++].rules.length;
        r += a.rules.length, i++;
      }
    }
    if (!t) {
      let o = "";
      for (let a = 0; a < this.modules.length; a++)
        o += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = o;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Fc = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, m0 = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, oMe = typeof navigator < "u" && /Mac/.test(navigator.platform), aMe = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var si = 0; si < 10; si++)
  Fc[48 + si] = Fc[96 + si] = String(si);
for (var si = 1; si <= 24; si++)
  Fc[si + 111] = "F" + si;
for (var si = 65; si <= 90; si++)
  Fc[si] = String.fromCharCode(si + 32), m0[si] = String.fromCharCode(si);
for (var k2 in Fc)
  m0.hasOwnProperty(k2) || (m0[k2] = Fc[k2]);
function sMe(n) {
  var e = oMe && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || aMe && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? m0 : Fc)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Ix(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function cE(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function lMe(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Sw(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return cE(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function y0(n) {
  return n.nodeType == 3 ? od(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function Cy(n, e, t, r) {
  return t ? R5(n, e, t, r, -1) || R5(n, e, t, r, 1) : !1;
}
function b0(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function R5(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : uu(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let o = n.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      e = b0(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = i < 0 ? uu(n) : 0;
    } else
      return !1;
  }
}
function uu(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function TI(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function uMe(n) {
  return {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function lY(n, e) {
  let t = e.width / n.offsetWidth, r = e.height / n.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - n.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - n.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function cMe(n, e, t, r, i, o, a, s) {
  let l = n.ownerDocument, u = l.defaultView || window;
  for (let c = n, h = !1; c && !h; )
    if (c.nodeType == 1) {
      let f, d = c == l.body, p = 1, g = 1;
      if (d)
        f = uMe(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (h = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let y = c.getBoundingClientRect();
        ({ scaleX: p, scaleY: g } = lY(c, y)), f = {
          left: y.left,
          right: y.left + c.clientWidth * p,
          top: y.top,
          bottom: y.top + c.clientHeight * g
        };
      }
      let v = 0, m = 0;
      if (i == "nearest")
        e.top < f.top ? (m = -(f.top - e.top + a), t > 0 && e.bottom > f.bottom + m && (m = e.bottom - f.bottom + m + a)) : e.bottom > f.bottom && (m = e.bottom - f.bottom + a, t < 0 && e.top - m < f.top && (m = -(f.top + m - e.top + a)));
      else {
        let y = e.bottom - e.top, b = f.bottom - f.top;
        m = (i == "center" && y <= b ? e.top + y / 2 - b / 2 : i == "start" || i == "center" && t < 0 ? e.top - a : e.bottom - b + a) - f.top;
      }
      if (r == "nearest" ? e.left < f.left ? (v = -(f.left - e.left + o), t > 0 && e.right > f.right + v && (v = e.right - f.right + v + o)) : e.right > f.right && (v = e.right - f.right + o, t < 0 && e.left < f.left + v && (v = -(f.left + v - e.left + o))) : v = (r == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == "start" == s ? e.left - o : e.right - (f.right - f.left) + o) - f.left, v || m)
        if (d)
          u.scrollBy(v, m);
        else {
          let y = 0, b = 0;
          if (m) {
            let O = c.scrollTop;
            c.scrollTop += m / g, b = (c.scrollTop - O) * g;
          }
          if (v) {
            let O = c.scrollLeft;
            c.scrollLeft += v / p, y = (c.scrollLeft - O) * p;
          }
          e = {
            left: e.left - y,
            top: e.top - b,
            right: e.right - y,
            bottom: e.bottom - b
          }, y && Math.abs(y - v) < 1 && (r = "nearest"), b && Math.abs(b - m) < 1 && (i = "nearest");
        }
      if (d)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function hMe(n) {
  let e = n.ownerDocument;
  for (let t = n.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class fMe {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? uu(t) : 0), r, Math.min(e.focusOffset, r ? uu(r) : 0));
  }
  set(e, t, r, i) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = i;
  }
}
let jd = null;
function uY(n) {
  if (n.setActive)
    return n.setActive();
  if (jd)
    return n.focus(jd);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(jd == null ? {
    get preventScroll() {
      return jd = { preventScroll: !0 }, !0;
    }
  } : void 0), !jd) {
    jd = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], i = e[t++], o = e[t++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
    }
  }
}
let N5;
function od(n, e, t = e) {
  let r = N5 || (N5 = document.createRange());
  return r.setEnd(n, t), r.setStart(n, e), r;
}
function Zp(n, e, t) {
  let r = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, i = new KeyboardEvent("keydown", r);
  i.synthetic = !0, n.dispatchEvent(i);
  let o = new KeyboardEvent("keyup", r);
  return o.synthetic = !0, n.dispatchEvent(o), i.defaultPrevented || o.defaultPrevented;
}
function dMe(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function cY(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function pMe(n, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, uu(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let i = t.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (t = i, r = uu(t));
    } else {
      if (t == n)
        return !0;
      r = b0(t), t = t.parentNode;
    }
}
function hY(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
class Di {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new Di(e.parentNode, b0(e), t);
  }
  static after(e, t) {
    return new Di(e.parentNode, b0(e) + 1, t);
  }
}
const kI = [];
class Bn {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, i = null, o;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (o = i ? i.nextSibling : r.firstChild)) {
            let s = Bn.get(o);
            (!s || !s.parent && s.canReuseDOM(a)) && a.reuseDOM(o);
          }
          a.sync(e, t), a.flags &= -8;
        }
        if (o = i ? i.nextSibling : r.firstChild, t && !t.written && t.node == r && o != a.dom && (t.written = !0), a.dom.parentNode == r)
          for (; o && o != a.dom; )
            o = $5(o);
        else
          r.insertBefore(a.dom, o);
        i = a.dom;
      }
      for (o = i ? i.nextSibling : r.firstChild, o && t && t.node == r && (t.written = !0); o; )
        o = $5(o);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let i = uu(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Bn.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, o = 0; ; i++) {
      let a = this.children[i];
      if (a.dom == r)
        return o;
      o += a.length + a.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let i = -1, o = -1, a = -1, s = -1;
    for (let l = 0, u = r, c = r; l < this.children.length; l++) {
      let h = this.children[l], f = u + h.length;
      if (u < e && f > t)
        return h.domBoundsAround(e, t, u);
      if (f >= e && i == -1 && (i = l, o = u), u > t && h.dom.parentNode == this.dom) {
        a = l, s = c;
        break;
      }
      c = f, u = f + h.breakAfter;
    }
    return {
      from: o,
      to: s < 0 ? r + this.length : s,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = kI) {
    this.markDirty();
    for (let i = e; i < t; i++) {
      let o = this.children[i];
      o.parent == this && r.indexOf(o) < 0 && o.destroy();
    }
    this.children.splice(e, t - e, ...r);
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new fY(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, i, o, a) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Bn.prototype.breakAfter = 0;
function $5(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class fY {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function dY(n, e, t, r, i, o, a, s, l) {
  let { children: u } = n, c = u.length ? u[e] : null, h = o.length ? o[o.length - 1] : null, f = h ? h.breakAfter : a;
  if (!(e == r && c && !a && !f && o.length < 2 && c.merge(t, i, o.length ? h : null, t == 0, s, l))) {
    if (r < u.length) {
      let d = u[r];
      d && (i < d.length || d.breakAfter && (h != null && h.breakAfter)) ? (e == r && (d = d.split(i), i = 0), !f && h && d.merge(0, i, h, !0, 0, l) ? o[o.length - 1] = d : ((i || d.children.length && !d.children[0].length) && d.merge(0, i, null, !1, 0, l), o.push(d))) : d != null && d.breakAfter && (h ? h.breakAfter = 1 : a = 1), r++;
    }
    for (c && (c.breakAfter = a, t > 0 && (!a && o.length && c.merge(t, c.length, o[0], !1, s, 0) ? c.breakAfter = o.shift().breakAfter : (t < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(t, c.length, null, !1, s, 0), e++)); e < r && o.length; )
      if (u[r - 1].become(o[o.length - 1]))
        r--, o.pop(), l = o.length ? 0 : s;
      else if (u[e].become(o[0]))
        e++, o.shift(), s = o.length ? 0 : l;
      else
        break;
    !o.length && e && r < u.length && !u[e - 1].breakAfter && u[r].merge(0, 0, u[e - 1], !1, s, l) && e--, (e < r || o.length) && n.replaceChildren(e, r, o);
  }
}
function pY(n, e, t, r, i, o) {
  let a = n.childCursor(), { i: s, off: l } = a.findPos(t, 1), { i: u, off: c } = a.findPos(e, -1), h = e - t;
  for (let f of r)
    h += f.length;
  n.length += h, dY(n, u, c, s, l, r, 0, i, o);
}
let Qo = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, hE = typeof document < "u" ? document : { documentElement: { style: {} } };
const fE = /* @__PURE__ */ /Edge\/(\d+)/.exec(Qo.userAgent), gY = /* @__PURE__ */ /MSIE \d/.test(Qo.userAgent), dE = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Qo.userAgent), B_ = !!(gY || dE || fE), B5 = !B_ && /* @__PURE__ */ /gecko\/(\d+)/i.test(Qo.userAgent), P2 = !B_ && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Qo.userAgent), V5 = "webkitFontSmoothing" in hE.documentElement.style, vY = !B_ && /* @__PURE__ */ /Apple Computer/.test(Qo.vendor), z5 = vY && (/* @__PURE__ */ /Mobile\/\w+/.test(Qo.userAgent) || Qo.maxTouchPoints > 2);
var je = {
  mac: z5 || /* @__PURE__ */ /Mac/.test(Qo.platform),
  windows: /* @__PURE__ */ /Win/.test(Qo.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Qo.platform),
  ie: B_,
  ie_version: gY ? hE.documentMode || 6 : dE ? +dE[1] : fE ? +fE[1] : 0,
  gecko: B5,
  gecko_version: B5 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Qo.userAgent) || [0, 0])[1] : 0,
  chrome: !!P2,
  chrome_version: P2 ? +P2[1] : 0,
  ios: z5,
  android: /* @__PURE__ */ /Android\b/.test(Qo.userAgent),
  webkit: V5,
  safari: vY,
  webkit_version: V5 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: hE.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const gMe = 256;
class cu extends Bn {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof cu) || this.length - (t - e) + r.length > gMe || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new cu(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Di(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return vMe(this.dom, e, t);
  }
}
class hu extends Bn {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let i of t)
      i.setParent(this);
  }
  setAttrs(e) {
    if (cY(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, i, o, a) {
    return r && (!(r instanceof hu && r.mark.eq(this.mark)) || e && o <= 0 || t < this.length && a <= 0) ? !1 : (pY(this, e, t, r ? r.children.slice() : [], o - 1, a - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, i = -1, o = 0;
    for (let s of this.children) {
      let l = r + s.length;
      l > e && t.push(r < e ? s.split(e - r) : s), i < 0 && r >= e && (i = o), r = l, o++;
    }
    let a = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new hu(this.mark, t, a);
  }
  domAtPos(e) {
    return mY(this, e);
  }
  coordsAt(e, t) {
    return bY(this, e, t);
  }
}
function vMe(n, e, t) {
  let r = n.nodeValue.length;
  e > r && (e = r);
  let i = e, o = e, a = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? je.chrome || je.gecko || (e ? (i--, a = 1) : o < r && (o++, a = -1)) : t < 0 ? i-- : o < r && o++;
  let s = od(n, i, o).getClientRects();
  if (!s.length)
    return null;
  let l = s[(a ? a < 0 : t >= 0) ? 0 : s.length - 1];
  return je.safari && !a && l.width == 0 && (l = Array.prototype.find.call(s, (u) => u.width) || l), a ? TI(l, a < 0) : l || null;
}
class cc extends Bn {
  static create(e, t, r) {
    return new cc(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = cc.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, i, o, a) {
    return r && (!(r instanceof cc) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || t < this.length && a <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof cc && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return on.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : on.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Di.before(this.dom) : Di.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let i = this.dom.getClientRects(), o = null;
    if (!i.length)
      return null;
    let a = this.side ? this.side < 0 : e > 0;
    for (let s = a ? i.length - 1 : 0; o = i[s], !(e > 0 ? s == 0 : s == i.length - 1 || o.top < o.bottom); s += a ? -1 : 1)
      ;
    return TI(o, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Qg extends Bn {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Qg && e.side == this.side;
  }
  split() {
    return new Qg(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Di.before(this.dom) : Di.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return on.empty;
  }
  get isHidden() {
    return !0;
  }
}
cu.prototype.children = cc.prototype.children = Qg.prototype.children = kI;
function mY(n, e) {
  let t = n.dom, { children: r } = n, i = 0;
  for (let o = 0; i < r.length; i++) {
    let a = r[i], s = o + a.length;
    if (!(s == o && a.getSide() <= 0)) {
      if (e > o && e < s && a.dom.parentNode == t)
        return a.domAtPos(e - o);
      if (e <= o)
        break;
      o = s;
    }
  }
  for (let o = i; o > 0; o--) {
    let a = r[o - 1];
    if (a.dom.parentNode == t)
      return a.domAtPos(a.length);
  }
  for (let o = i; o < r.length; o++) {
    let a = r[o];
    if (a.dom.parentNode == t)
      return a.domAtPos(0);
  }
  return new Di(t, 0);
}
function yY(n, e, t) {
  let r, { children: i } = n;
  t > 0 && e instanceof hu && i.length && (r = i[i.length - 1]) instanceof hu && r.mark.eq(e.mark) ? yY(r, e.children[0], t - 1) : (i.push(e), e.setParent(n)), n.length += e.length;
}
function bY(n, e, t) {
  let r = null, i = -1, o = null, a = -1;
  function s(u, c) {
    for (let h = 0, f = 0; h < u.children.length && f <= c; h++) {
      let d = u.children[h], p = f + d.length;
      p >= c && (d.children.length ? s(d, c - f) : (!o || o.isHidden && t > 0) && (p > c || f == p && d.getSide() > 0) ? (o = d, a = c - f) : (f < c || f == p && d.getSide() < 0 && !d.isHidden) && (r = d, i = c - f)), f = p;
    }
  }
  s(n, e);
  let l = (t < 0 ? r : o) || r || o;
  return l ? l.coordsAt(Math.max(0, l == r ? i : a), t) : mMe(n);
}
function mMe(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = y0(e);
  return t[t.length - 1] || null;
}
function pE(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const F5 = /* @__PURE__ */ Object.create(null);
function PI(n, e, t) {
  if (n == e)
    return !0;
  n || (n = F5), e || (e = F5);
  let r = Object.keys(n), i = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != i.length - (t && i.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let o of r)
    if (o != t && (i.indexOf(o) == -1 || n[o] !== e[o]))
      return !1;
  return !0;
}
function gE(n, e, t) {
  let r = !1;
  if (e)
    for (let i in e)
      t && i in t || (r = !0, i == "style" ? n.style.cssText = "" : n.removeAttribute(i));
  if (t)
    for (let i in t)
      e && e[i] == t[i] || (r = !0, i == "style" ? n.style.cssText = t[i] : n.setAttribute(i, t[i]));
  return r;
}
function yMe(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let r = n.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
let Wi = class _w extends Bn {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, i, o, a) {
    if (r) {
      if (!(r instanceof _w))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), pY(this, e, t, r ? r.children.slice() : [], o, a), !0;
  }
  split(e) {
    let t = new _w();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: i } = this.childPos(e);
    i && (t.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let o = r; o < this.children.length; o++)
      t.append(this.children[o], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    PI(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    yY(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = pE(t, this.attrs || {})), r && (this.attrs = pE({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return mY(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (cY(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (gE(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let i = this.dom.lastChild;
    for (; i && Bn.get(i) instanceof hu; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = Bn.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!je.ios || !this.children.some((o) => o instanceof cu))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof cu) || /[^ -~]/.test(r.text))
        return null;
      let i = y0(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, t = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = bY(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, o = r.bottom - r.top;
      if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
        let a = (o - i.textHeight) / 2;
        return { top: r.top + a, bottom: r.bottom - a, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let o = e.children[r], a = i + o.length;
      if (a >= t) {
        if (o instanceof _w)
          return o;
        if (a > t)
          break;
      }
      i = a + o.breakAfter;
    }
    return null;
  }
};
class wc extends Bn {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, i, o, a) {
    return r && (!(r instanceof wc) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || t < this.length && a <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Di.before(this.dom) : Di.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new wc(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return kI;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : on.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof wc && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class Au {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Xi = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(Xi || (Xi = {}));
class st extends id {
  constructor(e, t, r, i) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Ab(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Qc(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: o, end: a } = OY(e, t);
      r = (o ? t ? -3e8 : -1 : 5e8) - 1, i = (a ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Qc(e, r, i, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Tb(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Kt.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
st.none = Kt.empty;
class Ab extends st {
  constructor(e) {
    let { start: t, end: r } = OY(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof Ab && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && PI(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
Ab.prototype.point = !1;
class Tb extends st {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Tb && this.spec.class == e.spec.class && PI(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
Tb.prototype.mapMode = ui.TrackBefore;
Tb.prototype.point = !0;
class Qc extends st {
  constructor(e, t, r, i, o, a) {
    super(t, r, o, e), this.block = i, this.isReplace = a, this.mapMode = i ? t <= 0 ? ui.TrackBefore : ui.TrackAfter : ui.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Xi.WidgetRange : this.startSide <= 0 ? Xi.WidgetBefore : Xi.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Qc && bMe(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Qc.prototype.point = !0;
function OY(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = n;
  return t == null && (t = n.inclusive), r == null && (r = n.inclusive), { start: t ?? e, end: r ?? e };
}
function bMe(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function vE(n, e, t, r = 0) {
  let i = t.length - 1;
  i >= 0 && t[i] + r >= n ? t[i] = Math.max(t[i], e) : t.push(n, e);
}
class Ay {
  constructor(e, t, r, i) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof wc && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Wi()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(C1(new Qg(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof wc) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: a, done: s } = this.cursor.next(this.skip);
        if (this.skip = 0, s)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(C1(new cu(this.text.slice(this.textOff, this.textOff + i)), t), r), this.atCursorPos = !0, this.textOff += i, e -= i, r = 0;
    }
  }
  span(e, t, r, i) {
    this.buildText(t - e, r, i), this.pos = t, this.openStart < 0 && (this.openStart = i);
  }
  point(e, t, r, i, o, a) {
    if (this.disallowBlockEffectsFor[a] && r instanceof Qc) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let s = t - e;
    if (r instanceof Qc)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new wc(r.widget || new Q5("div"), s, r));
      else {
        let l = cc.create(r.widget || new Q5("span"), s, s ? 0 : r.startSide), u = this.atCursorPos && !l.isEditable && o <= i.length && (e < t || r.startSide > 0), c = !l.isEditable && (e < t || o > i.length || r.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), u && (h.append(C1(new Qg(1), i), o), o = i.length + Math.max(0, o - i.length)), h.append(C1(l, i), o), this.atCursorPos = c, this.pendingBuffer = c ? e < t || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, t, r, i, o) {
    let a = new Ay(e, t, r, o);
    return a.openEnd = Kt.spans(i, t, r, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}
function C1(n, e) {
  for (let t of e)
    n = new hu(t, [n], n.length);
  return n;
}
class Q5 extends Au {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var Vn = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(Vn || (Vn = {}));
const ad = Vn.LTR, EI = Vn.RTL;
function wY(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const OMe = /* @__PURE__ */ wY("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), wMe = /* @__PURE__ */ wY("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), mE = /* @__PURE__ */ Object.create(null), ks = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  mE[e] = t, mE[t] = -e;
}
function xY(n) {
  return n <= 247 ? OMe[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? wMe[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const xMe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class hc {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? EI : ad;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, i) {
    let o = -1;
    for (let a = 0; a < e.length; a++) {
      let s = e[a];
      if (s.from <= t && s.to >= t) {
        if (s.level == r)
          return a;
        (o < 0 || (i != 0 ? i < 0 ? s.from < t : s.to > t : e[o].level > s.level)) && (o = a);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function SY(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let r = n[t], i = e[t];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !SY(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const xn = [];
function SMe(n, e, t, r, i) {
  for (let o = 0; o <= r.length; o++) {
    let a = o ? r[o - 1].to : e, s = o < r.length ? r[o].from : t, l = o ? 256 : i;
    for (let u = a, c = l, h = l; u < s; u++) {
      let f = xY(n.charCodeAt(u));
      f == 512 ? f = c : f == 8 && h == 4 && (f = 16), xn[u] = f == 4 ? 2 : f, f & 7 && (h = f), c = f;
    }
    for (let u = a, c = l, h = l; u < s; u++) {
      let f = xn[u];
      if (f == 128)
        u < s - 1 && c == xn[u + 1] && c & 24 ? f = xn[u] = c : xn[u] = 256;
      else if (f == 64) {
        let d = u + 1;
        for (; d < s && xn[d] == 64; )
          d++;
        let p = u && c == 8 || d < t && xn[d] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let g = u; g < d; g++)
          xn[g] = p;
        u = d - 1;
      } else
        f == 8 && h == 1 && (xn[u] = 1);
      c = f, f & 7 && (h = f);
    }
  }
}
function _Me(n, e, t, r, i) {
  let o = i == 1 ? 2 : 1;
  for (let a = 0, s = 0, l = 0; a <= r.length; a++) {
    let u = a ? r[a - 1].to : e, c = a < r.length ? r[a].from : t;
    for (let h = u, f, d, p; h < c; h++)
      if (d = mE[f = n.charCodeAt(h)])
        if (d < 0) {
          for (let g = s - 3; g >= 0; g -= 3)
            if (ks[g + 1] == -d) {
              let v = ks[g + 2], m = v & 2 ? i : v & 4 ? v & 1 ? o : i : 0;
              m && (xn[h] = xn[ks[g]] = m), s = g;
              break;
            }
        } else {
          if (ks.length == 189)
            break;
          ks[s++] = h, ks[s++] = f, ks[s++] = l;
        }
      else if ((p = xn[h]) == 2 || p == 1) {
        let g = p == i;
        l = g ? 0 : 1;
        for (let v = s - 3; v >= 0; v -= 3) {
          let m = ks[v + 2];
          if (m & 2)
            break;
          if (g)
            ks[v + 2] |= 2;
          else {
            if (m & 4)
              break;
            ks[v + 2] |= 4;
          }
        }
      }
  }
}
function CMe(n, e, t, r) {
  for (let i = 0, o = r; i <= t.length; i++) {
    let a = i ? t[i - 1].to : n, s = i < t.length ? t[i].from : e;
    for (let l = a; l < s; ) {
      let u = xn[l];
      if (u == 256) {
        let c = l + 1;
        for (; ; )
          if (c == s) {
            if (i == t.length)
              break;
            c = t[i++].to, s = i < t.length ? t[i].from : e;
          } else if (xn[c] == 256)
            c++;
          else
            break;
        let h = o == 1, f = (c < e ? xn[c] : r) == 1, d = h == f ? h ? 1 : 2 : r;
        for (let p = c, g = i, v = g ? t[g - 1].to : n; p > l; )
          p == v && (p = t[--g].from, v = g ? t[g - 1].to : n), xn[--p] = d;
        l = c;
      } else
        o = u, l++;
    }
  }
}
function yE(n, e, t, r, i, o, a) {
  let s = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let l = e, u = 0; l < t; ) {
      let c = !0, h = !1;
      if (u == o.length || l < o[u].from) {
        let g = xn[l];
        g != s && (c = !1, h = g == 16);
      }
      let f = !c && s == 1 ? [] : null, d = c ? r : r + 1, p = l;
      e:
        for (; ; )
          if (u < o.length && p == o[u].from) {
            if (h)
              break e;
            let g = o[u];
            if (!c)
              for (let v = g.to, m = u + 1; ; ) {
                if (v == t)
                  break e;
                if (m < o.length && o[m].from == v)
                  v = o[m++].to;
                else {
                  if (xn[v] == s)
                    break e;
                  break;
                }
              }
            if (u++, f)
              f.push(g);
            else {
              g.from > l && a.push(new hc(l, g.from, d));
              let v = g.direction == ad != !(d % 2);
              bE(n, v ? r + 1 : r, i, g.inner, g.from, g.to, a), l = g.to;
            }
            p = g.to;
          } else {
            if (p == t || (c ? xn[p] != s : xn[p] == s))
              break;
            p++;
          }
      f ? yE(n, l, p, r + 1, i, f, a) : l < p && a.push(new hc(l, p, d)), l = p;
    }
  else
    for (let l = t, u = o.length; l > e; ) {
      let c = !0, h = !1;
      if (!u || l > o[u - 1].to) {
        let g = xn[l - 1];
        g != s && (c = !1, h = g == 16);
      }
      let f = !c && s == 1 ? [] : null, d = c ? r : r + 1, p = l;
      e:
        for (; ; )
          if (u && p == o[u - 1].to) {
            if (h)
              break e;
            let g = o[--u];
            if (!c)
              for (let v = g.from, m = u; ; ) {
                if (v == e)
                  break e;
                if (m && o[m - 1].to == v)
                  v = o[--m].from;
                else {
                  if (xn[v - 1] == s)
                    break e;
                  break;
                }
              }
            if (f)
              f.push(g);
            else {
              g.to < l && a.push(new hc(g.to, l, d));
              let v = g.direction == ad != !(d % 2);
              bE(n, v ? r + 1 : r, i, g.inner, g.from, g.to, a), l = g.from;
            }
            p = g.from;
          } else {
            if (p == e || (c ? xn[p - 1] != s : xn[p - 1] == s))
              break;
            p--;
          }
      f ? yE(n, p, l, r + 1, i, f, a) : p < l && a.push(new hc(p, l, d)), l = p;
    }
}
function bE(n, e, t, r, i, o, a) {
  let s = e % 2 ? 2 : 1;
  SMe(n, i, o, r, s), _Me(n, i, o, r, s), CMe(i, o, r, s), yE(n, i, o, e, t, r, a);
}
function AMe(n, e, t) {
  if (!n)
    return [new hc(0, 0, e == EI ? 1 : 0)];
  if (e == ad && !t.length && !xMe.test(n))
    return _Y(n.length);
  if (t.length)
    for (; n.length > xn.length; )
      xn[xn.length] = 256;
  let r = [], i = e == ad ? 0 : 1;
  return bE(n, i, i, t, 0, n.length, r), r;
}
function _Y(n) {
  return [new hc(0, n, 0)];
}
let CY = "";
function TMe(n, e, t, r, i) {
  var o;
  let a = r.head - n.from, s = hc.find(e, a, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc), l = e[s], u = l.side(i, t);
  if (a == u) {
    let f = s += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    l = e[s = f], a = l.side(!i, t), u = l.side(i, t);
  }
  let c = hi(n.text, a, l.forward(i, t));
  (c < l.from || c > l.to) && (c = u), CY = n.text.slice(Math.min(a, c), Math.max(a, c));
  let h = s == (i ? e.length - 1 : 0) ? null : e[s + (i ? 1 : -1)];
  return h && c == u && h.level + (i ? 0 : 1) < l.level ? me.cursor(h.side(!i, t) + n.from, h.forward(i, t) ? 1 : -1, h.level) : me.cursor(c + n.from, l.forward(i, t) ? -1 : 1, l.level);
}
function kMe(n, e, t) {
  for (let r = e; r < t; r++) {
    let i = xY(n.charCodeAt(r));
    if (i == 1)
      return ad;
    if (i == 2 || i == 4)
      return EI;
  }
  return ad;
}
const AY = /* @__PURE__ */ Ze.define(), TY = /* @__PURE__ */ Ze.define(), kY = /* @__PURE__ */ Ze.define(), PY = /* @__PURE__ */ Ze.define(), OE = /* @__PURE__ */ Ze.define(), EY = /* @__PURE__ */ Ze.define(), MY = /* @__PURE__ */ Ze.define(), DY = /* @__PURE__ */ Ze.define({
  combine: (n) => n.some((e) => e)
}), LY = /* @__PURE__ */ Ze.define({
  combine: (n) => n.some((e) => e)
});
class Wp {
  constructor(e, t = "nearest", r = "nearest", i = 5, o = 5, a = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = i, this.xMargin = o, this.isSnapshot = a;
  }
  map(e) {
    return e.empty ? this : new Wp(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Wp(me.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const A1 = /* @__PURE__ */ Et.define({ map: (n, e) => n.map(e) });
function _a(n, e, t) {
  let r = n.facet(PY);
  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const V_ = /* @__PURE__ */ Ze.define({ combine: (n) => n.length ? n[0] : !0 });
let PMe = 0;
const zm = /* @__PURE__ */ Ze.define();
class Sr {
  constructor(e, t, r, i, o) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = i, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: i, provide: o, decorations: a } = t || {};
    return new Sr(PMe++, e, r, i, (s) => {
      let l = [zm.of(s)];
      return a && l.push(O0.of((u) => {
        let c = u.plugin(s);
        return c ? a(c) : st.none;
      })), o && l.push(o(s)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Sr.define((r) => new e(r), t);
  }
}
class E2 {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (_a(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        _a(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        _a(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const IY = /* @__PURE__ */ Ze.define(), MI = /* @__PURE__ */ Ze.define(), O0 = /* @__PURE__ */ Ze.define(), RY = /* @__PURE__ */ Ze.define(), DI = /* @__PURE__ */ Ze.define(), NY = /* @__PURE__ */ Ze.define();
function Z5(n, e) {
  let t = n.state.facet(NY);
  if (!t.length)
    return t;
  let r = t.map((o) => o instanceof Function ? o(n) : o), i = [];
  return Kt.spans(r, e.from, e.to, {
    point() {
    },
    span(o, a, s, l) {
      let u = o - e.from, c = a - e.from, h = i;
      for (let f = s.length - 1; f >= 0; f--, l--) {
        let d = s[f].spec.bidiIsolate, p;
        if (d == null && (d = kMe(e.text, u, c)), l > 0 && h.length && (p = h[h.length - 1]).to == u && p.direction == d)
          p.to = c, h = p.inner;
        else {
          let g = { from: u, to: c, direction: d, inner: [] };
          h.push(g), h = g.inner;
        }
      }
    }
  }), i;
}
const $Y = /* @__PURE__ */ Ze.define();
function BY(n) {
  let e = 0, t = 0, r = 0, i = 0;
  for (let o of n.state.facet($Y)) {
    let a = o(n);
    a && (a.left != null && (e = Math.max(e, a.left)), a.right != null && (t = Math.max(t, a.right)), a.top != null && (r = Math.max(r, a.top)), a.bottom != null && (i = Math.max(i, a.bottom)));
  }
  return { left: e, right: t, top: r, bottom: i };
}
const Fm = /* @__PURE__ */ Ze.define();
class Ca {
  constructor(e, t, r, i) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new Ca(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let i = e[t - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let i = 0, o = 0, a = 0, s = 0; ; i++) {
      let l = i == e.length ? null : e[i], u = a - s, c = l ? l.fromB : 1e9;
      for (; o < t.length && t[o] < c; ) {
        let h = t[o], f = t[o + 1], d = Math.max(s, h), p = Math.min(c, f);
        if (d <= p && new Ca(d + u, p + u, d, p).addToSet(r), f > c)
          break;
        o += 2;
      }
      if (!l)
        return r;
      new Ca(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), a = l.toA, s = l.toB;
    }
  }
}
class Rx {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Lr.empty(this.startState.doc.length);
    for (let o of r)
      this.changes = this.changes.compose(o.changes);
    let i = [];
    this.changes.iterChangedRanges((o, a, s, l) => i.push(new Ca(o, a, s, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Rx(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class W5 extends Bn {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Wi()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Ca(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? i = this.domChanged.newSel.head : !NMe(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let o = i > -1 ? MMe(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      r = new Ca(u, c, e.changes.mapPos(u, -1), e.changes.mapPos(c, 1)).addToSet(r.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (je.ie || je.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, s = this.updateDeco(), l = IMe(a, s, e.changes);
    return r = Ca.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = je.chrome || je.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || i.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof wc && a.widget instanceof G5 && o.push(a.dom);
    i.updateGaps(o);
  }
  updateChildren(e, t, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, o = this.childCursor(t);
    for (let a = i.length - 1; ; a--) {
      let s = a >= 0 ? i[a] : null;
      if (!s)
        break;
      let { fromA: l, toA: u, fromB: c, toB: h } = s, f, d, p, g;
      if (r && r.range.fromB < h && r.range.toB > c) {
        let O = Ay.build(this.view.state.doc, c, r.range.fromB, this.decorations, this.dynamicDecorationMap), w = Ay.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        d = O.breakAtStart, p = O.openStart, g = w.openEnd;
        let x = this.compositionView(r);
        w.breakAtStart ? x.breakAfter = 1 : w.content.length && x.merge(x.length, x.length, w.content[0], !1, w.openStart, 0) && (x.breakAfter = w.content[0].breakAfter, w.content.shift()), O.content.length && x.merge(0, 0, O.content[O.content.length - 1], !0, 0, O.openEnd) && O.content.pop(), f = O.content.concat(x).concat(w.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: g } = Ay.build(this.view.state.doc, c, h, this.decorations, this.dynamicDecorationMap));
      let { i: v, off: m } = o.findPos(u, 1), { i: y, off: b } = o.findPos(l, -1);
      dY(this, y, b, v, m, f, d, p, g);
    }
    r && this.fixCompositionDOM(r);
  }
  compositionView(e) {
    let t = new cu(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: i } of e.marks)
      t = new hu(i, [t], t.length);
    let r = new Wi();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (o, a) => {
      a.flags |= 8 | (a.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let s = Bn.get(o);
      s && s != a && (s.dom = null), a.setDOM(o);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    t(e.line, i);
    for (let o = e.marks.length - 1; o >= -1; o--)
      r = i.childPos(r.off, 1), i = i.children[r.i], t(o >= 0 ? e.marks[o].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, o = !i && Sw(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || t || o))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let s = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(s.anchor)), u = s.empty ? l : this.moveToLine(this.domAtPos(s.head));
    if (je.gecko && s.empty && !this.hasComposition && EMe(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = u = new Di(h, 0), a = !0;
    }
    let c = this.view.observer.selectionRange;
    (a || !c.focusNode || (!Cy(l.node, l.offset, c.anchorNode, c.anchorOffset) || !Cy(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, s)) && (this.view.observer.ignore(() => {
      je.android && je.chrome && this.dom.contains(c.focusNode) && RMe(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Ix(this.view.root);
      if (h)
        if (s.empty) {
          if (je.gecko) {
            let f = DMe(l.node, l.offset);
            if (f && f != 3) {
              let d = zY(l.node, l.offset, f == 1 ? 1 : -1);
              d && (l = new Di(d.node, d.offset));
            }
          }
          h.collapse(l.node, l.offset), s.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = s.bidiLevel);
        } else if (h.extend) {
          h.collapse(l.node, l.offset);
          try {
            h.extend(u.node, u.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          s.anchor > s.head && ([l, u] = [u, l]), f.setEnd(u.node, u.offset), f.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(f);
        }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new Di(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new Di(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && Cy(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = Ix(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let a = Wi.find(this, t.head);
    if (!a)
      return;
    let s = a.posAtStart;
    if (t.head == s || t.head == s + a.length)
      return;
    let l = this.coordsAt(t.head, -1), u = this.coordsAt(t.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let c = this.domAtPos(t.head + t.assoc);
    r.collapse(c.node, c.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && r.collapse(i, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let i = e.offset; !r && i < t.childNodes.length; i++) {
      let o = Bn.get(t.childNodes[i]);
      o instanceof Wi && (r = o.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let o = Bn.get(t.childNodes[i]);
      o instanceof Wi && (r = o.domAtPos(o.length));
    }
    return r ? new Di(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = Bn.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let i = this.children[t];
      if (r < i.length || i instanceof Wi)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, i = 0;
    for (let o = this.length, a = this.children.length - 1; a >= 0; a--) {
      let s = this.children[a], l = o - s.breakAfter, u = l - s.length;
      if (l < e)
        break;
      u <= e && (u < e || s.covers(-1)) && (l > e || s.covers(1)) && (!r || s instanceof Wi && !(r instanceof Wi && t >= 0)) && (r = s, i = u), o = u;
    }
    return r ? r.coordsAt(e - i, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), i = this.children[t];
    if (!(i instanceof Wi))
      return null;
    for (; i.children.length; ) {
      let { i: s, off: l } = i.childPos(r, 1);
      for (; ; s++) {
        if (s == i.children.length)
          return null;
        if ((i = i.children[s]).length)
          break;
      }
      r = l;
    }
    if (!(i instanceof cu))
      return null;
    let o = hi(i.text, r);
    if (o == r)
      return null;
    let a = od(i.dom, r, o).getClientRects();
    for (let s = 0; s < a.length; s++) {
      let l = a[s];
      if (s == a.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: i } = e, o = this.view.contentDOM.clientWidth, a = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, s = -1, l = this.view.textDirection == Vn.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let h = this.children[c], f = u + h.length;
      if (f > i)
        break;
      if (u >= r) {
        let d = h.dom.getBoundingClientRect();
        if (t.push(d.height), a) {
          let p = h.dom.lastChild, g = p ? y0(p) : [];
          if (g.length) {
            let v = g[g.length - 1], m = l ? v.right - d.left : d.right - v.left;
            m > s && (s = m, this.minWidth = o, this.minWidthFrom = u, this.minWidthTo = f);
          }
        }
      }
      u = f + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Vn.RTL : Vn.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof Wi) {
        let a = o.measureTextSize();
        if (a)
          return a;
      }
    let e = document.createElement("div"), t, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let o = y0(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = o ? o.width / 27 : 7, i = o ? o.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new fY(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let o = i == t.viewports.length ? null : t.viewports[i], a = o ? o.from - 1 : this.length;
      if (a > r) {
        let s = (t.lineBlockAt(a).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(st.replace({
          widget: new G5(s),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, a));
      }
      if (!o)
        break;
      r = o.to + 1;
    }
    return st.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(O0).map((i, o) => (this.dynamicDecorationMap[o] = typeof i == "function") ? i(this.view) : i), t = !1, r = this.view.state.facet(RY).map((i, o) => {
      let a = typeof i == "function";
      return a && (t = !0), a ? i(this.view) : i;
    });
    r.length && (this.dynamicDecorationMap[e.length] = t, e.push(Kt.join(r)));
    for (let i = e.length; i < e.length + 3; i++)
      this.dynamicDecorationMap[i] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = u.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), i;
    if (!r)
      return;
    !t.empty && (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let o = BY(this.view), a = {
      left: r.left - o.left,
      top: r.top - o.top,
      right: r.right + o.right,
      bottom: r.bottom + o.bottom
    }, { offsetWidth: s, offsetHeight: l } = this.view.scrollDOM;
    cMe(this.view.scrollDOM, a, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, s), -s), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Vn.LTR);
  }
}
function EMe(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
class G5 extends Au {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function VY(n, e) {
  let t = n.observer.selectionRange, r = t.focusNode && zY(t.focusNode, t.focusOffset, 0);
  if (!r)
    return null;
  let i = e - r.offset;
  return { from: i, to: i + r.node.nodeValue.length, node: r.node };
}
function MMe(n, e, t) {
  let r = VY(n, t);
  if (!r)
    return null;
  let { node: i, from: o, to: a } = r, s = i.nodeValue;
  if (/[\n\r]/.test(s) || n.state.doc.sliceString(r.from, r.to) != s)
    return null;
  let l = e.invertedDesc, u = new Ca(l.mapPos(o), l.mapPos(a), o, a), c = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = Bn.get(h);
    if (f instanceof hu)
      c.push({ node: h, deco: f.mark });
    else {
      if (f instanceof Wi || h.nodeName == "DIV" && h.parentNode == n.contentDOM)
        return { range: u, text: i, marks: c, line: h };
      if (h != n.contentDOM)
        c.push({ node: h, deco: new Ab({
          inclusive: !0,
          attributes: yMe(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function zY(n, e, t) {
  if (t <= 0)
    for (let r = n, i = e; ; ) {
      if (r.nodeType == 3)
        return { node: r, offset: i };
      if (r.nodeType == 1 && i > 0)
        r = r.childNodes[i - 1], i = uu(r);
      else
        break;
    }
  if (t >= 0)
    for (let r = n, i = e; ; ) {
      if (r.nodeType == 3)
        return { node: r, offset: i };
      if (r.nodeType == 1 && i < r.childNodes.length && t >= 0)
        r = r.childNodes[i], i = 0;
      else
        break;
    }
  return null;
}
function DMe(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let LMe = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    vE(e, t, this.changes);
  }
  comparePoint(e, t) {
    vE(e, t, this.changes);
  }
};
function IMe(n, e, t) {
  let r = new LMe();
  return Kt.compare(n, e, t, r), r.changes;
}
function RMe(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function NMe(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (t = !0);
  }), t;
}
function $Me(n, e, t = 1) {
  let r = n.charCategorizer(e), i = n.doc.lineAt(e), o = e - i.from;
  if (i.length == 0)
    return me.cursor(e);
  o == 0 ? t = 1 : o == i.length && (t = -1);
  let a = o, s = o;
  t < 0 ? a = hi(i.text, o, !1) : s = hi(i.text, o);
  let l = r(i.text.slice(a, s));
  for (; a > 0; ) {
    let u = hi(i.text, a, !1);
    if (r(i.text.slice(u, a)) != l)
      break;
    a = u;
  }
  for (; s < i.length; ) {
    let u = hi(i.text, s);
    if (r(i.text.slice(s, u)) != l)
      break;
    s = u;
  }
  return me.range(a + i.from, s + i.from);
}
function BMe(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function VMe(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function M2(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function j5(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function H5(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function wE(n, e, t) {
  let r, i, o, a, s = !1, l, u, c, h;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let g = y0(p);
    for (let v = 0; v < g.length; v++) {
      let m = g[v];
      i && M2(i, m) && (m = j5(H5(m, i.bottom), i.top));
      let y = BMe(e, m), b = VMe(t, m);
      if (y == 0 && b == 0)
        return p.nodeType == 3 ? q5(p, e, t) : wE(p, e, t);
      if (!r || a > b || a == b && o > y) {
        r = p, i = m, o = y, a = b;
        let O = b ? t < m.top ? -1 : 1 : y ? e < m.left ? -1 : 1 : 0;
        s = !O || (O > 0 ? v < g.length - 1 : v > 0);
      }
      y == 0 ? t > m.bottom && (!c || c.bottom < m.bottom) ? (l = p, c = m) : t < m.top && (!h || h.top > m.top) && (u = p, h = m) : c && M2(c, m) ? c = H5(c, m.bottom) : h && M2(h, m) && (h = j5(h, m.top));
    }
  }
  if (c && c.bottom >= t ? (r = l, i = c) : h && h.top <= t && (r = u, i = h), !r)
    return { node: n, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return q5(r, f, t);
  if (s && r.contentEditable != "false")
    return wE(r, f, t);
  let d = Array.prototype.indexOf.call(n.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: n, offset: d };
}
function q5(n, e, t) {
  let r = n.nodeValue.length, i = -1, o = 1e9, a = 0;
  for (let s = 0; s < r; s++) {
    let l = od(n, s, s + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let c = l[u];
      if (c.top == c.bottom)
        continue;
      a || (a = e - c.left);
      let h = (c.top > t ? c.top - t : t - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && h < o) {
        let f = e >= (c.left + c.right) / 2, d = f;
        if ((je.chrome || je.gecko) && od(n, s).getBoundingClientRect().left == c.right && (d = !f), h <= 0)
          return { node: n, offset: s + (d ? 1 : 0) };
        i = s + (d ? 1 : 0), o = h;
      }
    }
  }
  return { node: n, offset: i > -1 ? i : a > 0 ? n.nodeValue.length : 0 };
}
function FY(n, e, t, r = -1) {
  var i, o;
  let a = n.contentDOM.getBoundingClientRect(), s = a.top + n.viewState.paddingTop, l, { docHeight: u } = n.viewState, { x: c, y: h } = e, f = h - s;
  if (f < 0)
    return 0;
  if (f > u)
    return n.state.doc.length;
  for (let O = n.viewState.heightOracle.textHeight / 2, w = !1; l = n.elementAtHeight(f), l.type != Xi.Text; )
    for (; f = r > 0 ? l.bottom + O : l.top - O, !(f >= 0 && f <= u); ) {
      if (w)
        return t ? null : 0;
      w = !0, r = -r;
    }
  h = s + f;
  let d = l.from;
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : Y5(n, a, l, c, h);
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : Y5(n, a, l, c, h);
  let p = n.dom.ownerDocument, g = n.root.elementFromPoint ? n.root : p, v = g.elementFromPoint(c, h);
  v && !n.contentDOM.contains(v) && (v = null), v || (c = Math.max(a.left + 1, Math.min(a.right - 1, c)), v = g.elementFromPoint(c, h), v && !n.contentDOM.contains(v) && (v = null));
  let m, y = -1;
  if (v && ((i = n.docView.nearest(v)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let O = p.caretPositionFromPoint(c, h);
      O && ({ offsetNode: m, offset: y } = O);
    } else if (p.caretRangeFromPoint) {
      let O = p.caretRangeFromPoint(c, h);
      O && ({ startContainer: m, startOffset: y } = O, (!n.contentDOM.contains(m) || je.safari && zMe(m, y, c) || je.chrome && FMe(m, y, c)) && (m = void 0));
    }
  }
  if (!m || !n.docView.dom.contains(m)) {
    let O = Wi.find(n.docView, d);
    if (!O)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: m, offset: y } = wE(O.dom, c, h));
  }
  let b = n.docView.nearest(m);
  if (!b)
    return null;
  if (b.isWidget && ((o = b.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let O = b.dom.getBoundingClientRect();
    return e.y < O.top || e.y <= O.bottom && e.x <= (O.left + O.right) / 2 ? b.posAtStart : b.posAtEnd;
  } else
    return b.localPosFromDOM(m, y) + b.posAtStart;
}
function Y5(n, e, t, r, i) {
  let o = Math.round((r - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let s = n.viewState.heightOracle.textHeight, l = Math.floor((i - t.top - (n.defaultLineHeight - s) * 0.5) / s);
    o += l * n.viewState.heightOracle.lineLength;
  }
  let a = n.state.sliceDoc(t.from, t.to);
  return t.from + sE(a, o, n.state.tabSize);
}
function zMe(n, e, t) {
  let r;
  if (n.nodeType != 3 || e != (r = n.nodeValue.length))
    return !1;
  for (let i = n.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return od(n, r - 1, r).getBoundingClientRect().left > t;
}
function FMe(n, e, t) {
  if (e != 0)
    return !1;
  for (let i = n; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    i = o;
  }
  let r = n.nodeType == 1 ? n.getBoundingClientRect() : od(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function xE(n, e) {
  let t = n.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let r of t.type)
      if (r.to > e || r.to == e && (r.to == t.to || r.type == Xi.Text))
        return r;
  }
  return t;
}
function QMe(n, e, t, r) {
  let i = xE(n, e.head), o = !r || i.type != Xi.Text || !(n.lineWrapping || i.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (o) {
    let a = n.dom.getBoundingClientRect(), s = n.textDirectionAt(i.from), l = n.posAtCoords({
      x: t == (s == Vn.LTR) ? a.right - 1 : a.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (l != null)
      return me.cursor(l, t ? -1 : 1);
  }
  return me.cursor(t ? i.to : i.from, t ? -1 : 1);
}
function X5(n, e, t, r) {
  let i = n.state.doc.lineAt(e.head), o = n.bidiSpans(i), a = n.textDirectionAt(i.from);
  for (let s = e, l = null; ; ) {
    let u = TMe(i, o, a, s, t), c = CY;
    if (!u) {
      if (i.number == (t ? n.state.doc.lines : 1))
        return s;
      c = `
`, i = n.state.doc.line(i.number + (t ? 1 : -1)), o = n.bidiSpans(i), u = n.visualLineSide(i, !t);
    }
    if (l) {
      if (!l(c))
        return s;
    } else {
      if (!r)
        return u;
      l = r(c);
    }
    s = u;
  }
}
function ZMe(n, e, t) {
  let r = n.state.charCategorizer(e), i = r(t);
  return (o) => {
    let a = r(o);
    return i == Zn.Space && (i = a), i == a;
  };
}
function WMe(n, e, t, r) {
  let i = e.head, o = t ? 1 : -1;
  if (i == (t ? n.state.doc.length : 0))
    return me.cursor(i, e.assoc);
  let a = e.goalColumn, s, l = n.contentDOM.getBoundingClientRect(), u = n.coordsAtPos(i, e.assoc || -1), c = n.documentTop;
  if (u)
    a == null && (a = u.left - l.left), s = o < 0 ? u.top : u.bottom;
  else {
    let d = n.viewState.lineBlockAt(i);
    a == null && (a = Math.min(l.right - l.left, n.defaultCharacterWidth * (i - d.from))), s = (o < 0 ? d.top : d.bottom) + c;
  }
  let h = l.left + a, f = r ?? n.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = s + (f + d) * o, g = FY(n, { x: h, y: p }, !1, o);
    if (p < l.top || p > l.bottom || (o < 0 ? g < i : g > i)) {
      let v = n.docView.coordsForChar(g), m = !v || p < v.top ? -1 : 1;
      return me.cursor(g, m, void 0, a);
    }
  }
}
function Cw(n, e, t) {
  for (; ; ) {
    let r = 0;
    for (let i of n)
      i.between(e - 1, e + 1, (o, a, s) => {
        if (e > o && e < a) {
          let l = r || t || (e - o < a - e ? -1 : 1);
          e = l < 0 ? o : a, r = l;
        }
      });
    if (!r)
      return e;
  }
}
function D2(n, e, t) {
  let r = Cw(n.state.facet(DI).map((i) => i(n)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : me.cursor(r, r < t.from ? 1 : -1);
}
class GMe {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, je.safari && e.contentDOM.addEventListener("input", () => null), je.gecko && sDe(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !JMe(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, t);
      for (let i of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (i(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = jMe(e), r = this.handlers, i = this.view.contentDOM;
    for (let o in t)
      if (o != "scroll") {
        let a = !t[o].handlers.length, s = r[o];
        s && a != !s.handlers.length && (i.removeEventListener(o, this.handleEvent), s = null), s || i.addEventListener(o, this.handleEvent, { passive: a });
      }
    for (let o in r)
      o != "scroll" && !t[o] && i.removeEventListener(o, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && ZY.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), je.android && je.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return je.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = QY.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || HMe.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, Zp(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : je.safari && !je.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function U5(n, e) {
  return (t, r) => {
    try {
      return e.call(n, r, t);
    } catch (i) {
      _a(t.state, i);
    }
  };
}
function jMe(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of n) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let o in i.domEventHandlers) {
        let a = i.domEventHandlers[o];
        a && t(o).handlers.push(U5(r.value, a));
      }
    if (i && i.domEventObservers)
      for (let o in i.domEventObservers) {
        let a = i.domEventObservers[o];
        a && t(o).observers.push(U5(r.value, a));
      }
  }
  for (let r in ds)
    t(r).handlers.push(ds[r]);
  for (let r in ps)
    t(r).observers.push(ps[r]);
  return e;
}
const QY = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], HMe = "dthko", ZY = [16, 17, 18, 20, 91, 92, 224, 225], T1 = 6;
function k1(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function qMe(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class YMe {
  constructor(e, t, r, i) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = hMe(e.contentDOM), this.atoms = e.state.facet(DI).map((a) => a(e));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(nn.allowMultipleSelections) && XMe(e, t), this.dragging = KMe(e, t) && HY(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && qMe(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let r = 0, i = 0, o = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, a = BY(this.view);
    e.clientX - a.left <= o.left + T1 ? r = -k1(o.left - e.clientX) : e.clientX + a.right >= o.right - T1 && (r = k1(e.clientX - o.right)), e.clientY - a.top <= o.top + T1 ? i = -k1(o.top - e.clientY) : e.clientY + a.bottom >= o.bottom - T1 && (i = k1(e.clientY - o.bottom)), this.setScrollSpeed(r, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r], o = null;
      if (i.empty) {
        let a = Cw(this.atoms, i.from, 0);
        a != i.from && (o = me.cursor(a, -1));
      } else {
        let a = Cw(this.atoms, i.from, -1), s = Cw(this.atoms, i.to, 1);
        (a != i.from || s != i.to) && (o = me.range(i.from == i.anchor ? a : s, i.from == i.head ? a : s));
      }
      o && (t || (t = e.ranges.slice()), t[r] = o);
    }
    return t ? me.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function XMe(n, e) {
  let t = n.state.facet(AY);
  return t.length ? t[0](e) : je.mac ? e.metaKey : e.ctrlKey;
}
function UMe(n, e) {
  let t = n.state.facet(TY);
  return t.length ? t[0](e) : je.mac ? !e.altKey : !e.ctrlKey;
}
function KMe(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let r = Ix(n.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let a = i[o];
    if (a.left <= e.clientX && a.right >= e.clientX && a.top <= e.clientY && a.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function JMe(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = Bn.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const ds = /* @__PURE__ */ Object.create(null), ps = /* @__PURE__ */ Object.create(null), WY = je.ie && je.ie_version < 15 || je.ios && je.webkit_version < 604;
function eDe(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), GY(n, t.value);
  }, 50);
}
function GY(n, e) {
  let { state: t } = n, r, i = 1, o = t.toText(e), a = o.lines == t.selection.ranges.length;
  if (SE != null && t.selection.ranges.every((l) => l.empty) && SE == o.toString()) {
    let l = -1;
    r = t.changeByRange((u) => {
      let c = t.doc.lineAt(u.from);
      if (c.from == l)
        return { range: u };
      l = c.from;
      let h = t.toText((a ? o.line(i++).text : e) + t.lineBreak);
      return {
        changes: { from: c.from, insert: h },
        range: me.cursor(u.from + h.length)
      };
    });
  } else
    a ? r = t.changeByRange((l) => {
      let u = o.line(i++);
      return {
        changes: { from: l.from, to: l.to, insert: u.text },
        range: me.cursor(l.from + u.length)
      };
    }) : r = t.replaceSelection(o);
  n.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
ps.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
ds.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (n.inputState.lastEscPress = Date.now()), !1);
ps.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
ps.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
ds.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of n.state.facet(kY))
    if (t = r(n, e), t)
      break;
  if (!t && e.button == 0 && (t = rDe(n, e)), t) {
    let r = !n.hasFocus;
    n.inputState.startMouseSelection(new YMe(n, e, t, r)), r && n.observer.ignore(() => uY(n.contentDOM));
    let i = n.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function K5(n, e, t, r) {
  if (r == 1)
    return me.cursor(e, t);
  if (r == 2)
    return $Me(n.state, e, t);
  {
    let i = Wi.find(n.docView, e), o = n.state.doc.lineAt(i ? i.posAtEnd : e), a = i ? i.posAtStart : o.from, s = i ? i.posAtEnd : o.to;
    return s < n.state.doc.length && s == o.to && s++, me.range(a, s);
  }
}
let jY = (n, e) => n >= e.top && n <= e.bottom, J5 = (n, e, t) => jY(e, t) && n >= t.left && n <= t.right;
function tDe(n, e, t, r) {
  let i = Wi.find(n.docView, e);
  if (!i)
    return 1;
  let o = e - i.posAtStart;
  if (o == 0)
    return 1;
  if (o == i.length)
    return -1;
  let a = i.coordsAt(o, -1);
  if (a && J5(t, r, a))
    return -1;
  let s = i.coordsAt(o, 1);
  return s && J5(t, r, s) ? 1 : a && jY(r, a) ? -1 : 1;
}
function eV(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: tDe(n, t, e.clientX, e.clientY) };
}
const nDe = je.ie && je.ie_version <= 11;
let tV = null, nV = 0, rV = 0;
function HY(n) {
  if (!nDe)
    return n.detail;
  let e = tV, t = rV;
  return tV = n, rV = Date.now(), nV = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (nV + 1) % 3 : 1;
}
function rDe(n, e) {
  let t = eV(n, e), r = HY(e), i = n.state.selection;
  return {
    update(o) {
      o.docChanged && (t.pos = o.changes.mapPos(t.pos), i = i.map(o.changes));
    },
    get(o, a, s) {
      let l = eV(n, o), u, c = K5(n, l.pos, l.bias, r);
      if (t.pos != l.pos && !a) {
        let h = K5(n, t.pos, t.bias, r), f = Math.min(h.from, c.from), d = Math.max(h.to, c.to);
        c = f < c.from ? me.range(f, d) : me.range(d, f);
      }
      return a ? i.replaceRange(i.main.extend(c.from, c.to)) : s && r == 1 && i.ranges.length > 1 && (u = iDe(i, l.pos)) ? u : s ? i.addRange(c) : me.create([c]);
    }
  };
}
function iDe(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: r, to: i } = n.ranges[t];
    if (r <= e && i >= e)
      return me.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
ds.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let i = n.docView.nearest(e.target);
    if (i && i.isWidget) {
      let o = i.posAtStart, a = o + i.length;
      (o >= t.to || a <= t.from) && (t = me.range(o, a));
    }
  }
  let { inputState: r } = n;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", n.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
ds.dragend = (n) => (n.inputState.draggedContent = null, !1);
function iV(n, e, t, r) {
  if (!t)
    return;
  let i = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: o } = n.inputState, a = r && o && UMe(n, e) ? { from: o.from, to: o.to } : null, s = { from: i, insert: t }, l = n.state.changes(a ? [a, s] : s);
  n.focus(), n.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
ds.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), i = 0, o = () => {
      ++i == t.length && iV(n, e, r.filter((a) => a != null).join(n.state.lineBreak), !1);
    };
    for (let a = 0; a < t.length; a++) {
      let s = new FileReader();
      s.onerror = o, s.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(s.result) || (r[a] = s.result), o();
      }, s.readAsText(t[a]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return iV(n, e, r, !0), !0;
  }
  return !1;
};
ds.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = WY ? null : e.clipboardData;
  return t ? (GY(n, t.getData("text/plain") || t.getData("text/uri-text")), !0) : (eDe(n), !1);
};
function oDe(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), n.focus();
  }, 50);
}
function aDe(n) {
  let e = [], t = [], r = !1;
  for (let i of n.selection.ranges)
    i.empty || (e.push(n.sliceDoc(i.from, i.to)), t.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: o } of n.selection.ranges) {
      let a = n.doc.lineAt(o);
      a.number > i && (e.push(a.text), t.push({ from: a.from, to: Math.min(n.doc.length, a.to + 1) })), i = a.number;
    }
    r = !0;
  }
  return { text: e.join(n.lineBreak), ranges: t, linewise: r };
}
let SE = null;
ds.copy = ds.cut = (n, e) => {
  let { text: t, ranges: r, linewise: i } = aDe(n.state);
  if (!t && !i)
    return !1;
  SE = i ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = WY ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", t), !0) : (oDe(n, t), !1);
};
const qY = /* @__PURE__ */ Cu.define();
function YY(n, e) {
  let t = [];
  for (let r of n.facet(MY)) {
    let i = r(n, e);
    i && t.push(i);
  }
  return t ? n.update({ effects: t, annotations: qY.of(!0) }) : null;
}
function XY(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = YY(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
ps.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), XY(n);
};
ps.blur = (n) => {
  n.observer.clearSelectionRange(), XY(n);
};
ps.compositionstart = ps.compositionupdate = (n) => {
  n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0);
};
ps.compositionend = (n) => {
  n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, je.chrome && je.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50);
};
ps.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
ds.beforeinput = (n, e) => {
  var t;
  let r;
  if (je.chrome && je.android && (r = QY.find((i) => i.inputType == e.inputType)) && (n.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let i = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > i + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return !1;
};
const oV = /* @__PURE__ */ new Set();
function sDe(n) {
  oV.has(n) || (oV.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const aV = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class lDe {
  constructor(e) {
    this.lineWrapping = e, this.doc = on.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return aV.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (t = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, i, o, a) {
    let s = aV.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != s;
    if (this.lineWrapping = s, this.lineHeight = t, this.charWidth = r, this.textHeight = i, this.lineLength = o, l) {
      this.heightSamples = {};
      for (let u = 0; u < a.length; u++) {
        let c = a[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return l;
  }
}
class uDe {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class qs {
  /**
  @internal
  */
  constructor(e, t, r, i, o) {
    this.from = e, this.length = t, this.top = r, this.height = i, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Xi.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Qc ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new qs(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Nn = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(Nn || (Nn = {}));
const Aw = 1e-3;
class Ui {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > Aw && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return Ui.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, i) {
    let o = this, a = r.doc;
    for (let s = i.length - 1; s >= 0; s--) {
      let { fromA: l, toA: u, fromB: c, toB: h } = i[s], f = o.lineAt(l, Nn.ByPosNoHeight, r.setDoc(t), 0, 0), d = f.to >= u ? f : o.lineAt(u, Nn.ByPosNoHeight, r, 0, 0);
      for (h += d.to - u, u = d.to; s > 0 && f.from <= i[s - 1].toA; )
        l = i[s - 1].fromA, c = i[s - 1].fromB, s--, l < f.from && (f = o.lineAt(l, Nn.ByPosNoHeight, r, 0, 0));
      c += f.from - l, l = f.from;
      let p = LI.build(r.setDoc(a), e, c, h);
      o = o.replace(l, u, p);
    }
    return o.updateHeight(r, 0);
  }
  static empty() {
    return new zo(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, i = 0, o = 0;
    for (; ; )
      if (t == r)
        if (i > o * 2) {
          let s = e[t - 1];
          s.break ? e.splice(--t, 1, s.left, null, s.right) : e.splice(--t, 1, s.left, s.right), r += 1 + s.break, i -= s.size;
        } else if (o > i * 2) {
          let s = e[r];
          s.break ? e.splice(r, 1, s.left, null, s.right) : e.splice(r, 1, s.left, s.right), r += 2 + s.break, o -= s.size;
        } else
          break;
      else if (i < o) {
        let s = e[t++];
        s && (i += s.size);
      } else {
        let s = e[--r];
        s && (o += s.size);
      }
    let a = 0;
    return e[t - 1] == null ? (a = 1, t--) : e[t] == null && (a = 1, r++), new cDe(Ui.of(e.slice(0, t)), a, Ui.of(e.slice(r)));
  }
}
Ui.prototype.size = 1;
class UY extends Ui {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, i) {
    return new qs(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, i, o) {
    return this.blockAt(0, r, i, o);
  }
  forEachLine(e, t, r, i, o, a) {
    e <= o + this.length && t >= o && a(this.blockAt(0, r, i, o));
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class zo extends UY {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, i) {
    return new qs(i, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof zo || i instanceof ni && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof ni ? i = new zo(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Ui.of(r);
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more ? this.setHeight(e, i.heights[i.index++]) : (r || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class ni extends Ui {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, i = e.doc.lineAt(t + this.length).number, o = i - r + 1, a, s = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * o);
      a = l / o, this.length > o + 1 && (s = (this.height - l) / (this.length - o - 1));
    } else
      a = this.height / o;
    return { firstLine: r, lastLine: i, perLine: a, perChar: s };
  }
  blockAt(e, t, r, i) {
    let { firstLine: o, lastLine: a, perLine: s, perChar: l } = this.heightMetrics(t, i);
    if (t.lineWrapping) {
      let u = i + Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length), c = t.doc.lineAt(u), h = s + c.length * l, f = Math.max(r, e - h / 2);
      return new qs(c.from, c.length, f, h, 0);
    } else {
      let u = Math.max(0, Math.min(a - o, Math.floor((e - r) / s))), { from: c, length: h } = t.doc.line(o + u);
      return new qs(c, h, r + s * u, s, 0);
    }
  }
  lineAt(e, t, r, i, o) {
    if (t == Nn.ByHeight)
      return this.blockAt(e, r, i, o);
    if (t == Nn.ByPosNoHeight) {
      let { from: d, to: p } = r.doc.lineAt(e);
      return new qs(d, p - d, 0, 0, 0);
    }
    let { firstLine: a, perLine: s, perChar: l } = this.heightMetrics(r, o), u = r.doc.lineAt(e), c = s + u.length * l, h = u.number - a, f = i + s * h + l * (u.from - o - h);
    return new qs(u.from, u.length, Math.max(i, Math.min(f, i + this.height - c)), c, 0);
  }
  forEachLine(e, t, r, i, o, a) {
    e = Math.max(e, o), t = Math.min(t, o + this.length);
    let { firstLine: s, perLine: l, perChar: u } = this.heightMetrics(r, o);
    for (let c = e, h = i; c <= t; ) {
      let f = r.doc.lineAt(c);
      if (c == e) {
        let p = f.number - s;
        h += l * p + u * (e - o - p);
      }
      let d = l + u * f.length;
      a(new qs(f.from, f.length, h, d, 0)), h += d, c = f.to + 1;
    }
  }
  replace(e, t, r) {
    let i = this.length - t;
    if (i > 0) {
      let o = r[r.length - 1];
      o instanceof ni ? r[r.length - 1] = new ni(o.length + i) : r.push(null, new ni(i - 1));
    }
    if (e > 0) {
      let o = r[0];
      o instanceof ni ? r[0] = new ni(e + o.length) : r.unshift(new ni(e - 1), null);
    }
    return Ui.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new ni(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new ni(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, i) {
    let o = t + this.length;
    if (i && i.from <= t + this.length && i.more) {
      let a = [], s = Math.max(t, i.from), l = -1;
      for (i.from > t && a.push(new ni(i.from - t - 1).updateHeight(e, t)); s <= o && i.more; ) {
        let c = e.doc.lineAt(s).length;
        a.length && a.push(null);
        let h = i.heights[i.index++];
        l == -1 ? l = h : Math.abs(h - l) >= Aw && (l = -2);
        let f = new zo(c, h);
        f.outdated = !1, a.push(f), s += c + 1;
      }
      s <= o && a.push(null, new ni(o - s).updateHeight(e, s));
      let u = Ui.of(a);
      return (l < 0 || Math.abs(u.height - this.height) >= Aw || Math.abs(l - this.heightMetrics(e, t).perLine) >= Aw) && (e.heightChanged = !0), u;
    } else
      (r || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class cDe extends Ui {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, i) {
    let o = r + this.left.height;
    return e < o ? this.left.blockAt(e, t, r, i) : this.right.blockAt(e, t, o, i + this.left.length + this.break);
  }
  lineAt(e, t, r, i, o) {
    let a = i + this.left.height, s = o + this.left.length + this.break, l = t == Nn.ByHeight ? e < a : e < s, u = l ? this.left.lineAt(e, t, r, i, o) : this.right.lineAt(e, t, r, a, s);
    if (this.break || (l ? u.to < s : u.from > s))
      return u;
    let c = t == Nn.ByPosNoHeight ? Nn.ByPosNoHeight : Nn.ByPos;
    return l ? u.join(this.right.lineAt(s, c, r, a, s)) : this.left.lineAt(s, c, r, i, o).join(u);
  }
  forEachLine(e, t, r, i, o, a) {
    let s = i + this.left.height, l = o + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, r, i, o, a), t >= l && this.right.forEachLine(e, t, r, s, l, a);
    else {
      let u = this.lineAt(l, Nn.ByPos, r, i, o);
      e < u.from && this.left.forEachLine(e, u.from - 1, r, i, o, a), u.to >= e && u.from <= t && a(u), t > u.to && this.right.forEachLine(u.to + 1, t, r, s, l, a);
    }
  }
  replace(e, t, r) {
    let i = this.left.length + this.break;
    if (t < i)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, r));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let a = o.length;
    for (let s of r)
      o.push(s);
    if (e > 0 && sV(o, a - 1), t < this.length) {
      let s = o.length;
      this.decomposeRight(t, o), sV(o, s);
    }
    return Ui.of(o);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < i && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Ui.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, i) {
    let { left: o, right: a } = this, s = t + o.length + this.break, l = null;
    return i && i.from <= t + o.length && i.more ? l = o = o.updateHeight(e, t, r, i) : o.updateHeight(e, t, r), i && i.from <= s + a.length && i.more ? l = a = a.updateHeight(e, s, r, i) : a.updateHeight(e, s, r), l ? this.balanced(o, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function sV(n, e) {
  let t, r;
  n[e] == null && (t = n[e - 1]) instanceof ni && (r = n[e + 1]) instanceof ni && n.splice(e - 1, 3, new ni(t.length + 1 + r.length));
}
const hDe = 5;
class LI {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof zo ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new zo(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, o = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let a = t - e;
      r.block ? this.addBlock(new UY(a, i, r)) : (a || o || i >= hDe) && this.addLineDeco(i, o, a);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new zo(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new ni(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof zo)
      return e;
    let t = new zo(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof zo) && !this.isCovered ? this.nodes.push(new zo(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof zo && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, i) {
    let o = new LI(r, e);
    return Kt.spans(t, r, i, o, 0), o.finish(r);
  }
}
function fDe(n, e, t) {
  let r = new dDe();
  return Kt.compare(n, e, t, r, 0), r.changes;
}
class dDe {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, i) {
    (e < t || r && r.heightRelevant || i && i.heightRelevant) && vE(e, t, this.changes, 5);
  }
}
function pDe(n, e) {
  let t = n.getBoundingClientRect(), r = n.ownerDocument, i = r.defaultView || window, o = Math.max(0, t.left), a = Math.min(i.innerWidth, t.right), s = Math.max(0, t.top), l = Math.min(i.innerHeight, t.bottom);
  for (let u = n.parentNode; u && u != r.body; )
    if (u.nodeType == 1) {
      let c = u, h = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && h.overflow != "visible") {
        let f = c.getBoundingClientRect();
        o = Math.max(o, f.left), a = Math.min(a, f.right), s = Math.max(s, f.top), l = u == n.parentNode ? f.bottom : Math.min(l, f.bottom);
      }
      u = h.position == "absolute" || h.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: o - t.left,
    right: Math.max(o, a) - t.left,
    top: s - (t.top + e),
    bottom: Math.max(s, l) - (t.top + e)
  };
}
function gDe(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class L2 {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.size = r;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], o = t[r];
      if (i.from != o.from || i.to != o.to || i.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return st.replace({
      widget: new vDe(this.size * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class vDe extends Au {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class lV {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = uV, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Vn.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(MI).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new lDe(t), this.stateDeco = e.facet(O0).filter((r) => typeof r != "function"), this.heightMap = Ui.empty().applyChanges(this.stateDeco, on.empty, this.heightOracle.setDoc(e.doc), [new Ca(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = st.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? t.head : t.anchor;
      if (!e.some(({ from: o, to: a }) => i >= o && i <= a)) {
        let { from: o, to: a } = this.lineBlockAt(i);
        e.push(new P1(o, a));
      }
    }
    this.viewports = e.sort((r, i) => r.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? uV : new bDe(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Qm(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(O0).filter((c) => typeof c != "function");
    let i = e.changedRanges, o = Ca.extendWithRanges(i, fDe(r, this.stateDeco, e ? e.changes : Lr.empty(this.state.doc.length))), a = this.heightMap.height, s = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), this.heightMap.height != a && (e.flags |= 2), s ? (this.scrollAnchorPos = e.changes.mapPos(s.from, -1), this.scrollAnchorHeight = s.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let u = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), u && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(LY) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), i = this.heightOracle, o = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? Vn.RTL : Vn.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(o), s = t.getBoundingClientRect(), l = a || this.mustMeasureContent || this.contentDOMHeight != s.height;
    this.contentDOMHeight = s.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (s.width && s.height) {
      let { scaleX: O, scaleY: w } = lY(t, s);
      (this.scaleX != O || this.scaleY != w) && (this.scaleX = O, this.scaleY = w, u |= 8, a = l = !0);
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, u |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 8);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = hY(e.scrollDOM);
    let p = (this.printing ? gDe : pDe)(t, this.paddingTop), g = p.top - this.pixelViewport.top, v = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let m = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (m != this.inView && (this.inView = m, m && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let y = s.width;
    if ((this.contentDOMWidth != y || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = s.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 8), l) {
      let O = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(O) && (a = !0), a || i.lineWrapping && Math.abs(y - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: w, charWidth: x, textHeight: S } = e.docView.measureTextSize();
        a = w > 0 && i.refresh(o, w, x, S, y / x, O), a && (e.docView.minWidth = 0, u |= 8);
      }
      g > 0 && v > 0 ? c = Math.max(g, v) : g < 0 && v < 0 && (c = Math.min(g, v)), i.heightChanged = !1;
      for (let w of this.viewports) {
        let x = w.from == this.viewport.from ? O : e.docView.measureVisibleLineHeights(w);
        this.heightMap = (a ? Ui.empty().applyChanges(this.stateDeco, on.empty, this.heightOracle, [new Ca(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, a, new uDe(w.from, x));
      }
      i.heightChanged && (u |= 2);
    }
    let b = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b && (this.viewport = this.getViewport(c, this.scrollTarget)), this.updateForViewport(), (u & 2 || b) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: a, visibleBottom: s } = this, l = new P1(i.lineAt(a - r * 1e3, Nn.ByHeight, o, 0, 0).from, i.lineAt(s + (1 - r) * 1e3, Nn.ByHeight, o, 0, 0).to);
    if (t) {
      let { head: u } = t.range;
      if (u < l.from || u > l.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(u, Nn.ByPos, o, 0, 0), f;
        t.y == "center" ? f = (h.top + h.bottom) / 2 - c / 2 : t.y == "start" || t.y == "nearest" && u < l.from ? f = h.top : f = h.bottom - c, l = new P1(i.lineAt(f - 1e3 / 2, Nn.ByHeight, o, 0, 0).from, i.lineAt(f + c + 1e3 / 2, Nn.ByHeight, o, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), i = t.mapPos(e.to, 1);
    return new P1(this.heightMap.lineAt(r, Nn.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Nn.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Nn.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(t, Nn.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: s } = this;
    return (e == 0 || i <= a - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || o >= s + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > a - 2 * 1e3 && o < s + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let i of e)
      t.touchesRange(i.from, i.to) || r.push(new L2(t.mapPos(i.from), t.mapPos(i.to), i.size));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, o = i >> 1, a = i << 1;
    if (this.defaultTextDirection != Vn.LTR && !r)
      return [];
    let s = [], l = (u, c, h, f) => {
      if (c - u < o)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let v of p)
        if (v > u && v < c) {
          l(u, v - 10, h, f), l(v + 10, c, h, f);
          return;
        }
      let g = yDe(e, (v) => v.from >= h.from && v.to <= h.to && Math.abs(v.from - u) < o && Math.abs(v.to - c) < o && !p.some((m) => v.from < m && v.to > m));
      if (!g) {
        if (c < h.to && t && r && t.visibleRanges.some((v) => v.from <= c && v.to >= c)) {
          let v = t.moveToLineBoundary(me.cursor(c), !1, !0).head;
          v > u && (c = v);
        }
        g = new L2(u, c, this.gapSize(h, u, c, f));
      }
      s.push(g);
    };
    for (let u of this.viewportLines) {
      if (u.length < a)
        continue;
      let c = mDe(u.from, u.to, this.stateDeco);
      if (c.total < a)
        continue;
      let h = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (r) {
        let p = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, v;
        if (h != null) {
          let m = M1(c, h), y = ((this.visibleBottom - this.visibleTop) / 2 + p) / u.height;
          g = m - y, v = m + y;
        } else
          g = (this.visibleTop - u.top - p) / u.height, v = (this.visibleBottom - u.top + p) / u.height;
        f = E1(c, g), d = E1(c, v);
      } else {
        let p = c.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, v, m;
        if (h != null) {
          let y = M1(c, h), b = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          v = y - b, m = y + b;
        } else
          v = (this.pixelViewport.left - g) / p, m = (this.pixelViewport.right + g) / p;
        f = E1(c, v), d = E1(c, m);
      }
      f > u.from && l(u.from, f, u, c), d < u.to && l(d, u.to, u, c);
    }
    return s;
  }
  gapSize(e, t, r, i) {
    let o = M1(i, r) - M1(i, t);
    return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    L2.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = st.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    Kt.spans(e, this.viewport.from, this.viewport.to, {
      span(i, o) {
        t.push({ from: i, to: o });
      },
      point() {
      }
    }, 20);
    let r = t.length != this.visibleRanges.length || this.visibleRanges.some((i, o) => i.from != t[o].from || i.to != t[o].to);
    return this.visibleRanges = t, r ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Qm(this.heightMap.lineAt(e, Nn.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Qm(this.heightMap.lineAt(this.scaler.fromDOM(e), Nn.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Qm(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class P1 {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function mDe(n, e, t) {
  let r = [], i = n, o = 0;
  return Kt.spans(t, n, e, {
    span() {
    },
    point(a, s) {
      a > i && (r.push({ from: i, to: a }), o += a - i), i = s;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), o += e - i), { total: o, ranges: r };
}
function E1({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(n * t);
  for (let i = 0; ; i++) {
    let { from: o, to: a } = e[i], s = a - o;
    if (r <= s)
      return o + r;
    r -= s;
  }
}
function M1(n, e) {
  let t = 0;
  for (let { from: r, to: i } of n.ranges) {
    if (e <= i) {
      t += e - r;
      break;
    }
    t += i - r;
  }
  return t / n.total;
}
function yDe(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const uV = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
class bDe {
  constructor(e, t, r) {
    let i = 0, o = 0, a = 0;
    this.viewports = r.map(({ from: s, to: l }) => {
      let u = t.lineAt(s, Nn.ByPos, e, 0, 0).top, c = t.lineAt(l, Nn.ByPos, e, 0, 0).bottom;
      return i += c - u, { from: s, to: l, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (t.height - i);
    for (let s of this.viewports)
      s.domTop = a + (s.top - o) * this.scale, a = s.domBottom = s.domTop + (s.bottom - s.top), o = s.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let o = t < this.viewports.length ? this.viewports[t] : null;
      if (!o || e < o.top)
        return i + (e - r) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      r = o.bottom, i = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let o = t < this.viewports.length ? this.viewports[t] : null;
      if (!o || e < o.domTop)
        return r + (e - i) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      r = o.bottom, i = o.domBottom;
    }
  }
}
function Qm(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), r = e.toDOM(n.bottom);
  return new qs(n.from, n.length, t, r - t, Array.isArray(n._content) ? n._content.map((i) => Qm(i, e)) : n._content);
}
const D1 = /* @__PURE__ */ Ze.define({ combine: (n) => n.join(" ") }), _E = /* @__PURE__ */ Ze.define({ combine: (n) => n.indexOf(!0) > -1 }), CE = /* @__PURE__ */ zc.newName(), KY = /* @__PURE__ */ zc.newName(), JY = /* @__PURE__ */ zc.newName(), eX = { "&light": "." + KY, "&dark": "." + JY };
function AE(n, e, t) {
  return new zc(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return n;
        if (!t || !t[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return t[i];
      }) : n + " " + r;
    }
  });
}
const ODe = /* @__PURE__ */ AE("." + CE, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, eX), Zm = "￿";
class wDe {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(nn.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Zm;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let o = this.text.length;
      this.readNode(i);
      let a = i.nextSibling;
      if (a == t)
        break;
      let s = Bn.get(i), l = Bn.get(a);
      (s && l ? s.breakAfter : (s ? s.breakAfter : cV(i)) || cV(a) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && this.lineBreak(), i = a;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, a = 1, s;
      if (this.lineSeparator ? (o = t.indexOf(this.lineSeparator, r), a = this.lineSeparator.length) : (s = i.exec(t)) && (o = s.index, a = s[0].length), this.append(t.slice(r, o < 0 ? t.length : o)), o < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= a - 1);
      r = o + a;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Bn.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (xDe(e, r.node, r.offset) ? t : 0));
  }
}
function xDe(n, e, t) {
  for (; ; ) {
    if (!e || t < uu(e))
      return !1;
    if (e == n)
      return !0;
    t = b0(e) + 1, e = e.parentNode;
  }
}
function cV(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
class hV {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class SDe {
  constructor(e, t, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: o, impreciseAnchor: a } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let s = o || a ? [] : ADe(e), l = new wDe(s, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = TDe(s, this.bounds.from);
    } else {
      let s = e.observer.selectionRange, l = o && o.node == s.focusNode && o.offset == s.focusOffset || !cE(e.contentDOM, s.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(s.focusNode, s.focusOffset), u = a && a.node == s.anchorNode && a.offset == s.anchorOffset || !cE(e.contentDOM, s.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(s.anchorNode, s.anchorOffset), c = e.viewport;
      if ((je.ios || je.chrome) && e.state.selection.main.empty && l != u && (c.from > 0 || c.to < e.state.doc.length)) {
        let h = Math.min(l, u), f = Math.max(l, u), d = c.from - h, p = c.to - f;
        (d == 0 || d == 1 || h == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (l = 0, u = e.state.doc.length);
      }
      this.newSel = me.single(u, l);
    }
  }
}
function tX(n, e) {
  let t, { newSel: r } = e, i = n.state.selection.main, o = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: a, to: s } = e.bounds, l = i.from, u = null;
    (o === 8 || je.android && e.text.length < s - a) && (l = i.to, u = "end");
    let c = CDe(n.state.doc.sliceString(a, s, Zm), e.text, l - a, u);
    c && (je.chrome && o == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == Zm + Zm && c.toB--, t = {
      from: a + c.from,
      to: a + c.toA,
      insert: on.of(e.text.slice(c.from, c.toB).split(Zm))
    });
  } else
    r && (!n.hasFocus && n.state.facet(V_) || r.main.eq(i)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !i.empty && r && r.main.empty ? t = { from: i.from, to: i.to, insert: n.state.doc.slice(i.from, i.to) } : t && t.from >= i.from && t.to <= i.to && (t.from != i.from || t.to != i.to) && i.to - i.from - (t.to - t.from) <= 4 ? t = {
    from: i.from,
    to: i.to,
    insert: n.state.doc.slice(i.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, i.to))
  } : (je.mac || je.android) && t && t.from == t.to && t.from == i.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = me.single(r.main.anchor - 1, r.main.head - 1)), t = { from: i.from, to: i.to, insert: on.of([" "]) }) : je.chrome && t && t.from == t.to && t.from == i.head && t.insert.toString() == `
 ` && n.lineWrapping && (r && (r = me.single(r.main.anchor - 1, r.main.head - 1)), t = { from: i.from, to: i.to, insert: on.of([" "]) }), t) {
    if (je.ios && n.inputState.flushIOSKey() || je.android && (t.from == i.from && t.to == i.to && t.insert.length == 1 && t.insert.lines == 2 && Zp(n.contentDOM, "Enter", 13) || (t.from == i.from - 1 && t.to == i.to && t.insert.length == 0 || o == 8 && t.insert.length < t.to - t.from && t.to > i.head) && Zp(n.contentDOM, "Backspace", 8) || t.from == i.from && t.to == i.to + 1 && t.insert.length == 0 && Zp(n.contentDOM, "Delete", 46)))
      return !0;
    let a = t.insert.toString();
    n.inputState.composing >= 0 && n.inputState.composing++;
    let s, l = () => s || (s = _De(n, t, r));
    return n.state.facet(EY).some((u) => u(n, t.from, t.to, a, l)) || n.dispatch(l()), !0;
  } else if (r && !r.main.eq(i)) {
    let a = !1, s = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (a = !0), s = n.inputState.lastSelectionOrigin), n.dispatch({ selection: r, scrollIntoView: a, userEvent: s }), !0;
  } else
    return !1;
}
function _De(n, e, t) {
  let r, i = n.state, o = i.selection.main;
  if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let s = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", l = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
    r = i.replaceSelection(n.state.toText(s + e.insert.sliceString(0, void 0, n.state.lineBreak) + l));
  } else {
    let s = i.changes(e), l = t && t.main.to <= s.newLength ? t.main : void 0;
    if (i.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let u = n.state.sliceDoc(e.from, e.to), c, h = t && VY(n, t.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        c = { from: h.from, to: h.to - p };
      } else
        c = n.state.doc.lineAt(o.head);
      let f = o.to - e.to, d = o.to - o.from;
      r = i.changeByRange((p) => {
        if (p.from == o.from && p.to == o.to)
          return { changes: s, range: l || p.map(s) };
        let g = p.to - f, v = g - u.length;
        if (p.to - p.from != d || n.state.sliceDoc(v, g) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= c.from && p.from <= c.to)
          return { range: p };
        let m = i.changes({ from: v, to: g, insert: e.insert }), y = p.to - o.to;
        return {
          changes: m,
          range: l ? me.range(Math.max(0, l.anchor + y), Math.max(0, l.head + y)) : p.map(m)
        };
      });
    } else
      r = {
        changes: s,
        selection: l && i.selection.replaceRange(l)
      };
  }
  let a = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, a += ".compose", n.inputState.compositionFirstChange && (a += ".start", n.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: a, scrollIntoView: !0 });
}
function CDe(n, e, t, r) {
  let i = Math.min(n.length, e.length), o = 0;
  for (; o < i && n.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == i && n.length == e.length)
    return null;
  let a = n.length, s = e.length;
  for (; a > 0 && s > 0 && n.charCodeAt(a - 1) == e.charCodeAt(s - 1); )
    a--, s--;
  if (r == "end") {
    let l = Math.max(0, o - Math.min(a, s));
    t -= a + l - o;
  }
  if (a < o && n.length < e.length) {
    let l = t <= o && t >= a ? o - t : 0;
    o -= l, s = o + (s - a), a = o;
  } else if (s < o) {
    let l = t <= o && t >= s ? o - t : 0;
    o -= l, a = o + (a - s), s = o;
  }
  return { from: o, toA: a, toB: s };
}
function ADe(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: o } = n.observer.selectionRange;
  return t && (e.push(new hV(t, r)), (i != t || o != r) && e.push(new hV(i, o))), e;
}
function TDe(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, r = n.length == 2 ? n[1].pos : t;
  return t > -1 && r > -1 ? me.single(t + e, r + e) : null;
}
const kDe = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, I2 = je.ie && je.ie_version <= 11;
class PDe {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new fMe(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (je.ie && je.ie_version <= 11 || je.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), I2 && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(V_) ? r.root.activeElement != this.dom : !Sw(r.dom, i))
      return;
    let o = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (je.ie && je.ie_version <= 11 || je.android && je.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Cy(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = je.safari && e.root.nodeType == 11 && lMe(this.dom.ownerDocument) == this.dom && EDe(this.view) || Ix(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let r = Sw(this.dom, t);
    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && pMe(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, kDe), I2 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), I2 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Zp(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, i = !1;
    for (let o of e) {
      let a = this.readMutation(o);
      a && (a.typeOver && (i = !0), t == -1 ? { from: t, to: r } = a : (t = Math.min(a.from, t), r = Math.max(a.to, r)));
    }
    return { from: t, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), i = this.selectionChanged && Sw(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new SDe(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = tX(this.view, t);
    return this.view.state == r && this.view.update([]), i;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = fV(t, e.previousSibling || e.target.previousSibling, -1), i = fV(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function fV(n, e, t) {
  for (; e; ) {
    let r = Bn.get(e);
    if (r && r.parent == n)
      return r;
    let i = e.parentNode;
    e = i != n.dom ? i : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function EDe(n) {
  let e = null;
  function t(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (n.contentDOM.addEventListener("beforeinput", t, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let r = e.startContainer, i = e.startOffset, o = e.endContainer, a = e.endOffset, s = n.docView.domAtPos(n.state.selection.main.anchor);
  return Cy(s.node, s.offset, o, a) && ([r, i, o, a] = [o, a, r, i]), { anchorNode: r, anchorOffset: i, focusNode: o, focusOffset: a };
}
class Qe {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: t } = e;
    this.dispatchTransactions = e.dispatchTransactions || t && ((r) => r.forEach((i) => t(i, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = e.root || dMe(e.parent) || document, this.viewState = new lV(e.state || nn.create(e)), e.scrollTo && e.scrollTo.is(A1) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(zm).map((r) => new E2(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new PDe(this), this.inputState = new GMe(this), this.inputState.ensureHandlers(this.plugins), this.docView = new W5(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Or ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, i, o = this.state;
    for (let f of e) {
      if (f.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let a = this.hasFocus, s = 0, l = null;
    e.some((f) => f.annotation(qY)) ? (this.inputState.notifiedFocused = a, s = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, l = YY(o, a), l || (s = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (c = null)) : this.observer.clear(), o.facet(nn.phrases) != this.state.facet(nn.phrases))
      return this.setState(o);
    i = Rx.create(this, o, e), i.flags |= s;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          h = new Wp(d.empty ? d : me.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(A1) && (h = d.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = Nx.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(Fm) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(D1) != i.state.facet(D1) && (this.viewState.mustMeasureContent = !0), (t || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let f of this.state.facet(OE))
        try {
          f(i);
        } catch (d) {
          _a(this.state, d, "update listener");
        }
    (l || c) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), c && !tX(this, c) && u.force && Zp(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new lV(e), this.plugins = e.facet(zm).map((r) => new E2(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new W5(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(zm), r = e.state.facet(zm);
    if (t != r) {
      let i = [];
      for (let o of r) {
        let a = t.indexOf(o);
        if (a < 0)
          i.push(new E2(o));
        else {
          let s = this.plugins[a];
          s.mustUpdate = e, i.push(s);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: a } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let s = 0; ; s++) {
        if (a < 0)
          if (hY(r))
            o = -1, a = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(i);
            o = d.from, a = d.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (s > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        l & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return _a(this.state, p), dV;
          }
        }), h = Rx.create(this, this.state, []), f = !1;
        h.flags |= l, t ? t.flags |= l : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h));
        for (let d = 0; d < u.length; d++)
          if (c[d] != dV)
            try {
              let p = u[d];
              p.write && p.write(c[d], this);
            } catch (p) {
              _a(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - a;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let s of this.state.facet(OE))
        s(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return CE + " " + (this.state.facet(_E) ? JY : KY) + " " + this.state.facet(D1);
  }
  updateAttrs() {
    let e = pV(this, IY, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(V_) ? "true" : "false",
      class: "cm-content",
      style: `${je.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), pV(this, MI, t);
    let r = this.observer.ignore(() => {
      let i = gE(this.contentDOM, this.contentAttrs, t), o = gE(this.dom, this.editorAttrs, e);
      return i || o;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(Qe.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Fm);
    let e = this.state.facet(Qe.cspNonce);
    zc.mount(this.root, this.styleModules.concat(ODe).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return D2(this, e, X5(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return D2(this, e, X5(this, e, t, (r) => ZMe(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = r[t ? r.length - 1 : 0];
    return me.cursor(o.side(t, i) + e.from, o.forward(!t, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return QMe(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return D2(this, e, WMe(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), FY(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), a = o[hc.find(o, e - i.from, -1, t)];
    return TI(r, a.dir == Vn.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(DY) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > MDe)
      return _Y(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == t && (o.fresh || SY(o.isolates, r = Z5(this, e))))
        return o.order;
    r || (r = Z5(this, e));
    let i = AMe(e.text, t, r);
    return this.bidiCache.push(new Nx(e.from, e.to, t, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || je.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      uY(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return A1.of(new Wp(typeof e == "number" ? me.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return A1.of(new Wp(me.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Sr.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Sr.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = zc.newName(), i = [D1.of(r), Fm.of(AE(`.${r}`, e))];
    return t && t.dark && i.push(_E.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return kd.lowest(Fm.of(AE("." + CE, e, eX)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), i = r && Bn.get(r) || Bn.get(e);
    return ((t = i == null ? void 0 : i.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
Qe.styleModule = Fm;
Qe.inputHandler = EY;
Qe.focusChangeEffect = MY;
Qe.perLineTextDirection = DY;
Qe.exceptionSink = PY;
Qe.updateListener = OE;
Qe.editable = V_;
Qe.mouseSelectionStyle = kY;
Qe.dragMovesSelection = TY;
Qe.clickAddsSelectionRange = AY;
Qe.decorations = O0;
Qe.outerDecorations = RY;
Qe.atomicRanges = DI;
Qe.bidiIsolatedRanges = NY;
Qe.scrollMargins = $Y;
Qe.darkTheme = _E;
Qe.cspNonce = /* @__PURE__ */ Ze.define({ combine: (n) => n.length ? n[0] : "" });
Qe.contentAttributes = MI;
Qe.editorAttributes = IY;
Qe.lineWrapping = /* @__PURE__ */ Qe.contentAttributes.of({ class: "cm-lineWrapping" });
Qe.announce = /* @__PURE__ */ Et.define();
const MDe = 4096, dV = {};
class Nx {
  constructor(e, t, r, i, o, a) {
    this.from = e, this.to = t, this.dir = r, this.isolates = i, this.fresh = o, this.order = a;
  }
  static update(e, t) {
    if (t.empty && !e.some((o) => o.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : Vn.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let a = e[o];
      a.dir == i && !t.touchesRange(a.from, a.to) && r.push(new Nx(t.mapPos(a.from, 1), t.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return r;
  }
}
function pV(n, e, t) {
  for (let r = n.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let o = r[i], a = typeof o == "function" ? o(n) : o;
    a && pE(a, t);
  }
  return t;
}
const DDe = je.mac ? "mac" : je.windows ? "win" : je.linux ? "linux" : "key";
function LDe(n, e) {
  const t = n.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let i, o, a, s;
  for (let l = 0; l < t.length - 1; ++l) {
    const u = t[l];
    if (/^(cmd|meta|m)$/i.test(u))
      s = !0;
    else if (/^a(lt)?$/i.test(u))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      o = !0;
    else if (/^s(hift)?$/i.test(u))
      a = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? s = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), s && (r = "Meta-" + r), a && (r = "Shift-" + r), r;
}
function L1(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const IDe = /* @__PURE__ */ kd.default(/* @__PURE__ */ Qe.domEventHandlers({
  keydown(n, e) {
    return rX(nX(e.state), n, e, "editor");
  }
})), z_ = /* @__PURE__ */ Ze.define({ enables: IDe }), gV = /* @__PURE__ */ new WeakMap();
function nX(n) {
  let e = n.facet(z_), t = gV.get(e);
  return t || gV.set(e, t = $De(e.reduce((r, i) => r.concat(i), []))), t;
}
function RDe(n, e, t) {
  return rX(nX(n.state), e, n, t);
}
let ic = null;
const NDe = 4e3;
function $De(n, e = DDe) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (a, s) => {
    let l = r[a];
    if (l == null)
      r[a] = s;
    else if (l != s)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (a, s, l, u, c) => {
    var h, f;
    let d = t[a] || (t[a] = /* @__PURE__ */ Object.create(null)), p = s.split(/ (?!$)/).map((m) => LDe(m, e));
    for (let m = 1; m < p.length; m++) {
      let y = p.slice(0, m).join(" ");
      i(y, !0), d[y] || (d[y] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(b) => {
          let O = ic = { view: b, prefix: y, scope: a };
          return setTimeout(() => {
            ic == O && (ic = null);
          }, NDe), !0;
        }]
      });
    }
    let g = p.join(" ");
    i(g, !1);
    let v = d[g] || (d[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && v.run.push(l), u && (v.preventDefault = !0), c && (v.stopPropagation = !0);
  };
  for (let a of n) {
    let s = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let u of s) {
        let c = t[u] || (t[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let h in c)
          c[h].run.push(a.any);
      }
    let l = a[e] || a.key;
    if (l)
      for (let u of s)
        o(u, l, a.run, a.preventDefault, a.stopPropagation), a.shift && o(u, "Shift-" + l, a.shift, a.preventDefault, a.stopPropagation);
  }
  return t;
}
function rX(n, e, t, r) {
  let i = sMe(e), o = ai(i, 0), a = va(o) == i.length && i != " ", s = "", l = !1, u = !1, c = !1;
  ic && ic.view == t && ic.scope == r && (s = ic.prefix + " ", ZY.indexOf(e.keyCode) < 0 && (u = !0, ic = null));
  let h = /* @__PURE__ */ new Set(), f = (v) => {
    if (v) {
      for (let m of v.run)
        if (!h.has(m) && (h.add(m), m(t, e)))
          return v.stopPropagation && (c = !0), !0;
      v.preventDefault && (v.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, d = n[r], p, g;
  return d && (f(d[s + L1(i, e, !a)]) ? l = !0 : a && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(je.windows && e.ctrlKey && e.altKey) && (p = Fc[e.keyCode]) && p != i ? (f(d[s + L1(p, e, !0)]) || e.shiftKey && (g = m0[e.keyCode]) != i && g != p && f(d[s + L1(g, e, !1)])) && (l = !0) : a && e.shiftKey && f(d[s + L1(i, e, !0)]) && (l = !0), !l && f(d._any) && (l = !0)), u && (l = !0), l && c && e.stopPropagation(), l;
}
class kb {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, i, o) {
    this.className = e, this.left = t, this.top = r, this.width = i, this.height = o;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let o = iX(e);
      return [new kb(t, i.left - o.left, i.top - o.top, null, i.bottom - i.top)];
    } else
      return BDe(e, t, r);
  }
}
function iX(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == Vn.LTR ? e.left : e.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: e.top - n.scrollDOM.scrollTop * n.scaleY };
}
function vV(n, e, t) {
  let r = me.cursor(e);
  return {
    from: Math.max(t.from, n.moveToLineBoundary(r, !1, !0).from),
    to: Math.min(t.to, n.moveToLineBoundary(r, !0, !0).from),
    type: Xi.Text
  };
}
function BDe(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let r = Math.max(t.from, n.viewport.from), i = Math.min(t.to, n.viewport.to), o = n.textDirection == Vn.LTR, a = n.contentDOM, s = a.getBoundingClientRect(), l = iX(n), u = a.querySelector(".cm-line"), c = u && window.getComputedStyle(u), h = s.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), f = s.right - (c ? parseInt(c.paddingRight) : 0), d = xE(n, r), p = xE(n, i), g = d.type == Xi.Text ? d : null, v = p.type == Xi.Text ? p : null;
  if (g && (n.lineWrapping || d.widgetLineBreaks) && (g = vV(n, r, g)), v && (n.lineWrapping || p.widgetLineBreaks) && (v = vV(n, i, v)), g && v && g.from == v.from)
    return y(b(t.from, t.to, g));
  {
    let w = g ? b(t.from, null, g) : O(d, !1), x = v ? b(null, t.to, v) : O(p, !0), S = [];
    return (g || d).to < (v || p).from - (g && v ? 1 : 0) || d.widgetLineBreaks > 1 && w.bottom + n.defaultLineHeight / 2 < x.top ? S.push(m(h, w.bottom, f, x.top)) : w.bottom < x.top && n.elementAtHeight((w.bottom + x.top) / 2).type == Xi.Text && (w.bottom = x.top = (w.bottom + x.top) / 2), y(w).concat(S).concat(y(x));
  }
  function m(w, x, S, _) {
    return new kb(
      e,
      w - l.left,
      x - l.top - 0.01,
      S - w,
      _ - x + 0.01
      /* C.Epsilon */
    );
  }
  function y({ top: w, bottom: x, horizontal: S }) {
    let _ = [];
    for (let C = 0; C < S.length; C += 2)
      _.push(m(S[C], w, S[C + 1], x));
    return _;
  }
  function b(w, x, S) {
    let _ = 1e9, C = -1e9, A = [];
    function k(D, E, M, R, N) {
      let $ = n.coordsAtPos(D, D == S.to ? -2 : 2), F = n.coordsAtPos(M, M == S.from ? 2 : -2);
      !$ || !F || (_ = Math.min($.top, F.top, _), C = Math.max($.bottom, F.bottom, C), N == Vn.LTR ? A.push(o && E ? h : $.left, o && R ? f : F.right) : A.push(!o && R ? h : F.left, !o && E ? f : $.right));
    }
    let P = w ?? S.from, L = x ?? S.to;
    for (let D of n.visibleRanges)
      if (D.to > P && D.from < L)
        for (let E = Math.max(D.from, P), M = Math.min(D.to, L); ; ) {
          let R = n.state.doc.lineAt(E);
          for (let N of n.bidiSpans(R)) {
            let $ = N.from + R.from, F = N.to + R.from;
            if ($ >= M)
              break;
            F > E && k(Math.max($, E), w == null && $ <= P, Math.min(F, M), x == null && F >= L, N.dir);
          }
          if (E = R.to + 1, E >= M)
            break;
        }
    return A.length == 0 && k(P, w == null, L, x == null, n.textDirection), { top: _, bottom: C, horizontal: A };
  }
  function O(w, x) {
    let S = s.top + (x ? w.top : w.bottom);
    return { top: S, bottom: S, horizontal: [] };
  }
}
function VDe(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class zDe {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Tw) != e.state.facet(Tw) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let t = 0, r = e.facet(Tw);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !VDe(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && t && i.constructor && this.drawn[r].constructor && i.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(i.draw(), t);
      for (; t; ) {
        let i = t.nextSibling;
        t.remove(), t = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Tw = /* @__PURE__ */ Ze.define();
function oX(n) {
  return [
    Sr.define((e) => new zDe(e, n)),
    Tw.of(n)
  ];
}
const aX = !je.ios, w0 = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function FDe(n = {}) {
  return [
    w0.of(n),
    QDe,
    ZDe,
    WDe,
    LY.of(!0)
  ];
}
function sX(n) {
  return n.startState.facet(w0) != n.state.facet(w0);
}
const QDe = /* @__PURE__ */ oX({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(w0), r = [];
    for (let i of e.selection.ranges) {
      let o = i == e.selection.main;
      if (i.empty ? !o || aX : t.drawRangeCursor) {
        let a = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", s = i.empty ? i : me.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of kb.forRange(n, a, s))
          r.push(l);
      }
    }
    return r;
  },
  update(n, e) {
    n.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = sX(n);
    return t && mV(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    mV(e.state, n);
  },
  class: "cm-cursorLayer"
});
function mV(n, e) {
  e.style.animationDuration = n.facet(w0).cursorBlinkRate + "ms";
}
const ZDe = /* @__PURE__ */ oX({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : kb.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || sX(n);
  },
  class: "cm-selectionLayer"
}), TE = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
aX && (TE[".cm-line"].caretColor = "transparent !important", TE[".cm-content"] = { caretColor: "transparent !important" });
const WDe = /* @__PURE__ */ kd.highest(/* @__PURE__ */ Qe.theme(TE)), lX = /* @__PURE__ */ Et.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), Wm = /* @__PURE__ */ Kr.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, r) => r.is(lX) ? r.value : t, n);
  }
}), GDe = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(Wm);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(Wm) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, e = n.state.field(Wm), t = e != null && n.coordsAtPos(e);
    if (!t)
      return null;
    let r = n.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: t.top - r.top + n.scrollDOM.scrollTop * n.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      n ? (this.cursor.style.left = n.left / e + "px", this.cursor.style.top = n.top / t + "px", this.cursor.style.height = n.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(Wm) != n && this.view.dispatch({ effects: lX.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function jDe() {
  return [Wm, GDe];
}
function yV(n, e, t, r, i) {
  e.lastIndex = 0;
  for (let o = n.iterRange(t, r), a = t, s; !o.next().done; a += o.value.length)
    if (!o.lineBreak)
      for (; s = e.exec(o.value); )
        i(a + s.index, s);
}
function HDe(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let r = [];
  for (let { from: i, to: o } of t)
    i = Math.max(n.state.doc.lineAt(i).from, i - e), o = Math.min(n.state.doc.lineAt(o).to, o + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = o : r.push({ from: i, to: o });
  return r;
}
class qDe {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: i, boundary: o, maxLength: a = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, i)
      this.addMatch = (s, l, u, c) => i(c, u, u + s[0].length, s, l);
    else if (typeof r == "function")
      this.addMatch = (s, l, u, c) => {
        let h = r(s, l, u);
        h && c(u, u + s[0].length, h);
      };
    else if (r)
      this.addMatch = (s, l, u, c) => c(u, u + s[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Vc(), r = t.add.bind(t);
    for (let { from: i, to: o } of HDe(e, this.maxLength))
      yV(e.state.doc, this.regexp, i, o, (a, s) => this.addMatch(s, e, a, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((o, a, s, l) => {
      l > e.view.viewport.from && s < e.view.viewport.to && (r = Math.min(s, r), i = Math.max(l, i));
    }), e.viewportChanged || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, t.map(e.changes), r, i) : t;
  }
  updateRange(e, t, r, i) {
    for (let o of e.visibleRanges) {
      let a = Math.max(o.from, r), s = Math.min(o.to, i);
      if (s > a) {
        let l = e.state.doc.lineAt(a), u = l.to < s ? e.state.doc.lineAt(s) : l, c = Math.max(o.from, l.from), h = Math.min(o.to, u.to);
        if (this.boundary) {
          for (; a > l.from; a--)
            if (this.boundary.test(l.text[a - 1 - l.from])) {
              c = a;
              break;
            }
          for (; s < u.to; s++)
            if (this.boundary.test(u.text[s - u.from])) {
              h = s;
              break;
            }
        }
        let f = [], d, p = (g, v, m) => f.push(m.range(g, v));
        if (l == u)
          for (this.regexp.lastIndex = c - l.from; (d = this.regexp.exec(l.text)) && d.index < h - l.from; )
            this.addMatch(d, e, d.index + l.from, p);
        else
          yV(e.state.doc, this.regexp, c, h, (g, v) => this.addMatch(v, e, g, p));
        t = t.update({ filterFrom: c, filterTo: h, filter: (g, v) => g < c || v > h, add: f });
      }
    }
    return t;
  }
}
const kE = /x/.unicode != null ? "gu" : "g", YDe = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, kE), XDe = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let R2 = null;
function UDe() {
  var n;
  if (R2 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    R2 = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return R2 || !1;
}
const kw = /* @__PURE__ */ Ze.define({
  combine(n) {
    let e = El(n, {
      render: null,
      specialChars: YDe,
      addSpecialChars: null
    });
    return (e.replaceTabs = !UDe()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, kE)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, kE)), e;
  }
});
function KDe(n = {}) {
  return [kw.of(n), JDe()];
}
let bV = null;
function JDe() {
  return bV || (bV = Sr.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = st.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(kw)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new qDe({
        regexp: n.specialChars,
        decoration: (e, t, r) => {
          let { doc: i } = t.state, o = ai(e[0], 0);
          if (o == 9) {
            let a = i.lineAt(r), s = t.state.tabSize, l = wv(a.text, s, r - a.from);
            return st.replace({
              widget: new rLe((s - l % s) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = st.replace({ widget: new nLe(n, o) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(kw);
      n.startState.facet(kw) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const eLe = "•";
function tLe(n) {
  return n >= 32 ? eLe : n == 10 ? "␤" : String.fromCharCode(9216 + n);
}
class nLe extends Au {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = tLe(this.code), r = e.state.phrase("Control character") + " " + (XDe[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, t);
    if (i)
      return i;
    let o = document.createElement("span");
    return o.textContent = t, o.title = r, o.setAttribute("aria-label", r), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class rLe extends Au {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function iLe() {
  return aLe;
}
const oLe = /* @__PURE__ */ st.line({ class: "cm-activeLine" }), aLe = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let r of n.state.selection.ranges) {
      let i = n.lineBlockAt(r.head);
      i.from > e && (t.push(oLe.range(i.from)), e = i.from);
    }
    return st.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), PE = 2e3;
function sLe(n, e, t) {
  let r = Math.min(e.line, t.line), i = Math.max(e.line, t.line), o = [];
  if (e.off > PE || t.off > PE || e.col < 0 || t.col < 0) {
    let a = Math.min(e.off, t.off), s = Math.max(e.off, t.off);
    for (let l = r; l <= i; l++) {
      let u = n.doc.line(l);
      u.length <= s && o.push(me.range(u.from + a, u.to + s));
    }
  } else {
    let a = Math.min(e.col, t.col), s = Math.max(e.col, t.col);
    for (let l = r; l <= i; l++) {
      let u = n.doc.line(l), c = sE(u.text, a, n.tabSize, !0);
      if (c < 0)
        o.push(me.cursor(u.to));
      else {
        let h = sE(u.text, s, n.tabSize);
        o.push(me.range(u.from + c, u.from + h));
      }
    }
  }
  return o;
}
function lLe(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function OV(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = n.state.doc.lineAt(t), i = t - r.from, o = i > PE ? -1 : i == r.length ? lLe(n, e.clientX) : wv(r.text, n.state.tabSize, t - r.from);
  return { line: r.number, col: o, off: i };
}
function uLe(n, e) {
  let t = OV(n, e), r = n.state.selection;
  return t ? {
    update(i) {
      if (i.docChanged) {
        let o = i.changes.mapPos(i.startState.doc.line(t.line).from), a = i.state.doc.lineAt(o);
        t = { line: a.number, col: t.col, off: Math.min(t.off, a.length) }, r = r.map(i.changes);
      }
    },
    get(i, o, a) {
      let s = OV(n, i);
      if (!s)
        return r;
      let l = sLe(n.state, t, s);
      return l.length ? a ? me.create(l.concat(r.ranges)) : me.create(l) : r;
    }
  } : null;
}
function cLe(n) {
  let e = (n == null ? void 0 : n.eventFilter) || ((t) => t.altKey && t.button == 0);
  return Qe.mouseSelectionStyle.of((t, r) => e(r) ? uLe(t, r) : null);
}
const hLe = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, fLe = { style: "cursor: crosshair" };
function dLe(n = {}) {
  let [e, t] = hLe[n.key || "Alt"], r = Sr.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || t(i));
      },
      keyup(i) {
        (i.keyCode == e || !t(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(t(i));
      }
    }
  });
  return [
    r,
    Qe.contentAttributes.of((i) => {
      var o;
      return !((o = i.plugin(r)) === null || o === void 0) && o.isDown ? fLe : null;
    })
  ];
}
const Kv = "-10000px";
class uX {
  constructor(e, t, r, i) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((a) => a);
    let o = null;
    this.tooltipViews = this.tooltips.map((a) => o = r(a, o));
  }
  update(e, t) {
    var r;
    let i = e.state.facet(this.facet), o = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let a = [], s = t ? [] : null;
    for (let l = 0; l < o.length; l++) {
      let u = o[l], c = -1;
      if (u) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == u.create && (c = h);
        }
        if (c < 0)
          a[l] = this.createTooltipView(u, l ? a[l - 1] : null), s && (s[l] = !!u.above);
        else {
          let h = a[l] = this.tooltipViews[c];
          s && (s[l] = t[c]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return t && (s.forEach((l, u) => t[u] = l), t.length = s.length), this.input = i, this.tooltips = o, this.tooltipViews = a, !0;
  }
}
function pLe(n) {
  let { win: e } = n;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const N2 = /* @__PURE__ */ Ze.define({
  combine: (n) => {
    var e, t, r;
    return {
      position: je.ios ? "absolute" : ((e = n.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((i) => i.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = n.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || pLe
    };
  }
}), wV = /* @__PURE__ */ new WeakMap(), II = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(N2);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new uX(n, RI, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n, this.above);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, r = n.state.facet(N2);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n, e) {
    let t = n.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), n.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", t.dom.insertBefore(i, r);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Kv, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var n, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (n = r.destroy) === null || n === void 0 || n.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = this.view.dom.getBoundingClientRect(), e = 1, t = 1, r = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (je.gecko)
        r = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == Kv && i.style.left == "0px") {
        let o = i.getBoundingClientRect();
        r = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (e = i.width / this.parent.offsetWidth, t = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: t } = this.view.viewState);
    return {
      editor: n,
      parent: this.parent ? this.container.getBoundingClientRect() : n,
      pos: this.manager.tooltips.map((i, o) => {
        let a = this.manager.tooltipViews[o];
        return a.getCoords ? a.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(N2).tooltipSpace(this.view),
      scaleX: e,
      scaleY: t,
      makeAbsolute: r
    };
  }
  writeMeasure(n) {
    var e;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = "absolute";
    }
    let { editor: t, space: r, scaleX: i, scaleY: o } = n, a = [];
    for (let s = 0; s < this.manager.tooltips.length; s++) {
      let l = this.manager.tooltips[s], u = this.manager.tooltipViews[s], { dom: c } = u, h = n.pos[s], f = n.size[s];
      if (!h || h.bottom <= Math.max(t.top, r.top) || h.top >= Math.min(t.bottom, r.bottom) || h.right < Math.max(t.left, r.left) - 0.1 || h.left > Math.min(t.right, r.right) + 0.1) {
        c.style.top = Kv;
        continue;
      }
      let d = l.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, g = f.right - f.left, v = (e = wV.get(u)) !== null && e !== void 0 ? e : f.bottom - f.top, m = u.offset || vLe, y = this.view.textDirection == Vn.LTR, b = f.width > r.right - r.left ? y ? r.left : r.right - f.width : y ? Math.min(h.left - (d ? 14 : 0) + m.x, r.right - g) : Math.max(r.left, h.left - g + (d ? 14 : 0) - m.x), O = this.above[s];
      !l.strictSide && (O ? h.top - (f.bottom - f.top) - m.y < r.top : h.bottom + (f.bottom - f.top) + m.y > r.bottom) && O == r.bottom - h.bottom > h.top - r.top && (O = this.above[s] = !O);
      let w = (O ? h.top - r.top : r.bottom - h.bottom) - p;
      if (w < v && u.resize !== !1) {
        if (w < this.view.defaultLineHeight) {
          c.style.top = Kv;
          continue;
        }
        wV.set(u, v), c.style.height = (v = w) / o + "px";
      } else
        c.style.height && (c.style.height = "");
      let x = O ? h.top - v - p - m.y : h.bottom + p + m.y, S = b + g;
      if (u.overlap !== !0)
        for (let _ of a)
          _.left < S && _.right > b && _.top < x + v && _.bottom > x && (x = O ? _.top - v - 2 - p : _.bottom + p + 2);
      if (this.position == "absolute" ? (c.style.top = (x - n.parent.top) / o + "px", c.style.left = (b - n.parent.left) / i + "px") : (c.style.top = x / o + "px", c.style.left = b / i + "px"), d) {
        let _ = h.left + (y ? m.x : -m.x) - (b + 14 - 7);
        d.style.left = _ / i + "px";
      }
      u.overlap !== !0 && a.push({ left: b, top: x, right: S, bottom: x + v }), c.classList.toggle("cm-tooltip-above", O), c.classList.toggle("cm-tooltip-below", !O), u.positioned && u.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = Kv;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), gLe = /* @__PURE__ */ Qe.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), vLe = { x: 0, y: 0 }, RI = /* @__PURE__ */ Ze.define({
  enables: [II, gLe]
}), $x = /* @__PURE__ */ Ze.define({
  combine: (n) => n.reduce((e, t) => e.concat(t), [])
});
class F_ {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new F_(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new uX(e, $x, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (t === void 0)
          t = i;
        else if (t !== i)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const mLe = /* @__PURE__ */ RI.compute([$x], (n) => {
  let e = n.facet($x);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: F_.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class yLe {
  constructor(e, t, r, i, o) {
    this.view = e, this.source = t, this.field = r, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let i, o = 1;
    if (r instanceof cc)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(t), i == null)
        return;
      let s = e.coordsAtPos(i);
      if (!s || t.y < s.top || t.y > s.bottom || t.x < s.left - e.defaultCharacterWidth || t.x > s.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(i)).find((c) => c.from <= i && c.to >= i), u = l && l.dir == Vn.RTL ? -1 : 1;
      o = t.x < s.left ? -u : u;
    }
    let a = this.source(e, i, o);
    if (a != null && a.then) {
      let s = this.pending = { pos: i };
      a.then((l) => {
        this.pending == s && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => _a(e.state, l, "hover tooltip"));
    } else
      a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) });
  }
  get tooltip() {
    let e = this.view.plugin(II), t = e ? e.manager.tooltips.findIndex((r) => r.create == F_.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: o } = this;
    if (i.length && o && !bLe(o.dom, e) || this.pending) {
      let { pos: a } = i[0] || this.pending, s = (r = (t = i[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : a;
      (a == s ? this.view.posAtCoords(this.lastMove) != a : !OLe(this.view, a, s, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const I1 = 4;
function bLe(n, e) {
  let t = n.getBoundingClientRect();
  return e.clientX >= t.left - I1 && e.clientX <= t.right + I1 && e.clientY >= t.top - I1 && e.clientY <= t.bottom + I1;
}
function OLe(n, e, t, r, i, o) {
  let a = n.scrollDOM.getBoundingClientRect(), s = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (a.left > r || a.right < r || a.top > i || Math.min(a.bottom, s) < i)
    return !1;
  let l = n.posAtCoords({ x: r, y: i }, !1);
  return l >= e && l <= t;
}
function wLe(n, e = {}) {
  let t = Et.define(), r = Kr.define({
    create() {
      return [];
    },
    update(i, o) {
      if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((a) => !e.hideOn(o, a))), o.docChanged)) {
        let a = [];
        for (let s of i) {
          let l = o.changes.mapPos(s.pos, -1, ui.TrackDel);
          if (l != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), s);
            u.pos = l, u.end != null && (u.end = o.changes.mapPos(u.end)), a.push(u);
          }
        }
        i = a;
      }
      for (let a of o.effects)
        a.is(t) && (i = a.value), a.is(xLe) && (i = []);
      return i;
    },
    provide: (i) => $x.from(i)
  });
  return [
    r,
    Sr.define((i) => new yLe(
      i,
      n,
      r,
      t,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    mLe
  ];
}
function cX(n, e) {
  let t = n.plugin(II);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const xLe = /* @__PURE__ */ Et.define(), xV = /* @__PURE__ */ Ze.define({
  combine(n) {
    let e, t;
    for (let r of n)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function x0(n, e) {
  let t = n.plugin(hX), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const hX = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(S0), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(xV);
    this.top = new R1(n, !0, e.topContainer), this.bottom = new R1(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(xV);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new R1(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new R1(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet(S0);
    if (t != this.input) {
      let r = t.filter((l) => l), i = [], o = [], a = [], s = [];
      for (let l of r) {
        let u = this.specs.indexOf(l), c;
        u < 0 ? (c = l(n.view), s.push(c)) : (c = this.panels[u], c.update && c.update(n)), i.push(c), (c.top ? o : a).push(c);
      }
      this.specs = r, this.panels = i, this.top.sync(o), this.bottom.sync(a);
      for (let l of s)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => Qe.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class R1 {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = SV(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = SV(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function SV(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const S0 = /* @__PURE__ */ Ze.define({
  enables: hX
});
class fu extends id {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
fu.prototype.elementClass = "";
fu.prototype.toDOM = void 0;
fu.prototype.mapMode = ui.TrackBefore;
fu.prototype.startSide = fu.prototype.endSide = -1;
fu.prototype.point = !0;
const Pw = /* @__PURE__ */ Ze.define(), SLe = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Kt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Ty = /* @__PURE__ */ Ze.define();
function _Le(n) {
  return [fX(), Ty.of(Object.assign(Object.assign({}, SLe), n))];
}
const EE = /* @__PURE__ */ Ze.define({
  combine: (n) => n.some((e) => e)
});
function fX(n) {
  let e = [
    CLe
  ];
  return n && n.fixed === !1 && e.push(EE.of(!0)), e;
}
const CLe = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.view = n, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(Ty).map((e) => new CV(n, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !n.state.facet(EE), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    n.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(EE) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && this.dom.remove();
    let t = Kt.iter(this.view.state.facet(Pw), this.view.viewport.from), r = [], i = this.gutters.map((o) => new ALe(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(o.type)) {
        let a = !0;
        for (let s of o.type)
          if (s.type == Xi.Text && a) {
            ME(t, r, s.from);
            for (let l of i)
              l.line(this.view, s, r);
            a = !1;
          } else if (s.widget)
            for (let l of i)
              l.widget(this.view, s);
      } else if (o.type == Xi.Text) {
        ME(t, r, o.from);
        for (let a of i)
          a.line(this.view, o, r);
      } else if (o.widget)
        for (let a of i)
          a.widget(this.view, o);
    for (let o of i)
      o.finish();
    n && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(n) {
    let e = n.startState.facet(Ty), t = n.state.facet(Ty), r = n.docChanged || n.heightChanged || n.viewportChanged || !Kt.eq(n.startState.facet(Pw), n.state.facet(Pw), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let i of this.gutters)
        i.update(n) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let o of t) {
        let a = e.indexOf(o);
        a < 0 ? i.push(new CV(this.view, o)) : (this.gutters[a].update(n), i.push(this.gutters[a]));
      }
      for (let o of this.gutters)
        o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
      for (let o of i)
        this.dom.appendChild(o.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove();
  }
}, {
  provide: (n) => Qe.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Vn.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function _V(n) {
  return Array.isArray(n) ? n : [n];
}
function ME(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class ALe {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = Kt.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: i } = this, o = (t.top - this.height) / e.scaleY, a = t.height / e.scaleY;
    if (this.i == i.elements.length) {
      let s = new dX(e, a, o, r);
      i.elements.push(s), i.dom.appendChild(s.dom);
    } else
      i.elements[this.i].update(e, a, o, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let i = [];
    ME(this.cursor, i, t.from), r.length && (i = i.concat(r));
    let o = this.gutter.config.lineMarker(e, t, i);
    o && i.unshift(o);
    let a = this.gutter;
    i.length == 0 && !a.config.renderEmptyElements || this.addElement(e, t, i);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t);
    r && this.addElement(e, t, [r]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class CV {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let o = i.target, a;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let l = o.getBoundingClientRect();
          a = (l.top + l.bottom) / 2;
        } else
          a = i.clientY;
        let s = e.lineBlockAtHeight(a - e.documentTop);
        t.domEventHandlers[r](e, s, i) && i.preventDefault();
      });
    this.markers = _V(t.markers(e)), t.initialSpacer && (this.spacer = new dX(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = _V(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !Kt.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class dX {
  constructor(e, t, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, i);
  }
  update(e, t, r, i) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), TLe(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let o = 0, a = 0; ; ) {
      let s = a, l = o < t.length ? t[o++] : null, u = !1;
      if (l) {
        let c = l.elementClass;
        c && (r += " " + c);
        for (let h = a; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            s = h, u = !0;
            break;
          }
      } else
        s = this.markers.length;
      for (; a < s; ) {
        let c = this.markers[a++];
        if (c.toDOM) {
          c.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), u && a++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function TLe(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const kLe = /* @__PURE__ */ Ze.define(), kp = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let i in t) {
          let o = r[i], a = t[i];
          r[i] = o ? (s, l, u) => o(s, l, u) || a(s, l, u) : a;
        }
        return r;
      }
    });
  }
});
class $2 extends fu {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function B2(n, e) {
  return n.state.facet(kp).formatNumber(e, n.state);
}
const PLe = /* @__PURE__ */ Ty.compute([kp], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(kLe);
  },
  lineMarker(e, t, r) {
    return r.some((i) => i.toDOM) ? null : new $2(B2(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(kp) != e.state.facet(kp),
  initialSpacer(e) {
    return new $2(B2(e, AV(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = B2(t.view, AV(t.view.state.doc.lines));
    return r == e.number ? e : new $2(r);
  },
  domEventHandlers: n.facet(kp).domEventHandlers
}));
function ELe(n = {}) {
  return [
    kp.of(n),
    fX(),
    PLe
  ];
}
function AV(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const MLe = /* @__PURE__ */ new class extends fu {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), DLe = /* @__PURE__ */ Pw.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.head).from;
    i > t && (t = i, e.push(MLe.range(i)));
  }
  return Kt.of(e);
});
function LLe() {
  return DLe;
}
const pX = 1024;
let ILe = 0;
class V2 {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class Zt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = ILe++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Po.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
Zt.closedBy = new Zt({ deserialize: (n) => n.split(" ") });
Zt.openedBy = new Zt({ deserialize: (n) => n.split(" ") });
Zt.group = new Zt({ deserialize: (n) => n.split(" ") });
Zt.isolate = new Zt({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
Zt.contextHash = new Zt({ perNode: !0 });
Zt.lookAhead = new Zt({ perNode: !0 });
Zt.mounted = new Zt({ perNode: !0 });
class Bx {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Zt.mounted.id];
  }
}
const RLe = /* @__PURE__ */ Object.create(null);
class Po {
  /**
  @internal
  */
  constructor(e, t, r, i = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : RLe, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Po(e.name || "", t, e.id, r);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(i)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[o[0].id] = o[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(Zt.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        t[i] = e[r];
    return (r) => {
      for (let i = r.prop(Zt.group), o = -1; o < (i ? i.length : 0); o++) {
        let a = t[o < 0 ? r.name : i[o]];
        if (a)
          return a;
      }
    };
  }
}
Po.none = new Po(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class NI {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let i = null;
      for (let o of e) {
        let a = o(r);
        a && (i || (i = Object.assign({}, r.props)), i[a[0].id] = a[1]);
      }
      t.push(i ? new Po(r.name, i, r.id, r.flags) : r);
    }
    return new NI(t);
  }
}
const N1 = /* @__PURE__ */ new WeakMap(), TV = /* @__PURE__ */ new WeakMap();
var Ir;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ir || (Ir = {}));
let fi = class DE {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, i, o) {
    if (this.type = e, this.children = t, this.positions = r, this.length = i, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, s] of o)
        this.props[typeof a == "number" ? a : a.id] = s;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Bx.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (t && (t += ","), t += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new IE(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let i = N1.get(this) || this.topNode, o = new IE(i);
    return o.moveTo(e, t), N1.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new wl(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = _0(N1.get(this) || this.topNode, e, t, !1);
    return N1.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = _0(TV.get(this) || this.topNode, e, t, !0);
    return TV.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return BLe(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: i = 0, to: o = this.length } = e, a = e.mode || 0, s = (a & Ir.IncludeAnonymous) > 0;
    for (let l = this.cursor(a | Ir.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= o && l.to >= i && (!s && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && r && (s || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : VI(Po.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, i) => new DE(this.type, t, r, i, this.propValues), e.makeTree || ((t, r, i) => new DE(Po.none, t, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return VLe(e);
  }
};
fi.empty = new fi(Po.none, [], [], 0);
class $I {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new $I(this.buffer, this.index);
  }
}
class Zc {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Po.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[t], o = i.name;
    if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, r == e)
      return o;
    let a = [];
    for (; e < r; )
      a.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, i, o) {
    let { buffer: a } = this, s = -1;
    for (let l = e; l != t && !(gX(o, i, a[l + 1], a[l + 2]) && (s = l, r > 0)); l = a[l + 3])
      ;
    return s;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let i = this.buffer, o = new Uint16Array(t - e), a = 0;
    for (let s = e, l = 0; s < t; ) {
      o[l++] = i[s++], o[l++] = i[s++] - r;
      let u = o[l++] = i[s++] - r;
      o[l++] = i[s++] - e, a = Math.max(a, u);
    }
    return new Zc(o, a, this.set);
  }
}
function gX(n, e, t, r) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function _0(n, e, t, r) {
  for (var i; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let a = !r && n instanceof wl && n.index < 0 ? null : n.parent;
    if (!a)
      return n;
    n = a;
  }
  let o = r ? 0 : Ir.IgnoreOverlays;
  if (r)
    for (let a = n, s = a.parent; s; a = s, s = a.parent)
      a instanceof wl && a.index < 0 && ((i = s.enter(e, t, o)) === null || i === void 0 ? void 0 : i.from) != a.from && (n = s);
  for (; ; ) {
    let a = n.enter(e, t, o);
    if (!a)
      return n;
    n = a;
  }
}
class vX {
  cursor(e = 0) {
    return new IE(this, e);
  }
  getChild(e, t = null, r = null) {
    let i = kV(this, e, t, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return kV(this, e, t, r);
  }
  resolve(e, t = 0) {
    return _0(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return _0(this, e, t, !0);
  }
  matchContext(e) {
    return LE(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let i = t.lastChild;
      if (!i || i.to != t.to)
        break;
      i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
let wl = class Ew extends vX {
  constructor(e, t, r, i) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, i, o = 0) {
    for (let a = this; ; ) {
      for (let { children: s, positions: l } = a._tree, u = t > 0 ? s.length : -1; e != u; e += t) {
        let c = s[e], h = l[e] + a.from;
        if (gX(i, r, h, h + c.length)) {
          if (c instanceof Zc) {
            if (o & Ir.ExcludeBuffers)
              continue;
            let f = c.findChild(0, c.buffer.length, t, r - h, i);
            if (f > -1)
              return new Ks(new NLe(a, c, e, h), null, f);
          } else if (o & Ir.IncludeAnonymous || !c.type.isAnonymous || BI(c)) {
            let f;
            if (!(o & Ir.IgnoreMounts) && (f = Bx.get(c)) && !f.overlay)
              return new Ew(f.tree, h, e, a);
            let d = new Ew(c, h, e, a);
            return o & Ir.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? c.children.length - 1 : 0, t, r, i);
          }
        }
      }
      if (o & Ir.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? e = a.index + t : e = t < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let i;
    if (!(r & Ir.IgnoreOverlays) && (i = Bx.get(this._tree)) && i.overlay) {
      let o = e - this.from;
      for (let { from: a, to: s } of i.overlay)
        if ((t > 0 ? a <= o : a < o) && (t < 0 ? s >= o : s > o))
          return new Ew(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function kV(n, e, t, r) {
  let i = n.cursor(), o = [];
  if (!i.firstChild())
    return o;
  if (t != null) {
    for (let a = !1; !a; )
      if (a = i.type.is(t), !i.nextSibling())
        return o;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return o;
    if (i.type.is(e) && o.push(i.node), !i.nextSibling())
      return r == null ? o : [];
  }
}
function LE(n, e, t = e.length - 1) {
  for (let r = n.parent; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class NLe {
  constructor(e, t, r, i) {
    this.parent = e, this.buffer = t, this.index = r, this.start = i;
  }
}
class Ks extends vX {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.context.start, r);
    return o < 0 ? null : new Ks(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Ir.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return o < 0 ? null : new Ks(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ks(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Ks(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, i = this.index + 4, o = r.buffer[this.index + 3];
    if (o > i) {
      let a = r.buffer[this.index + 1];
      e.push(r.slice(i, o, a)), t.push(0);
    }
    return new fi(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function mX(n) {
  if (!n.length)
    return null;
  let e = 0, t = n[0];
  for (let o = 1; o < n.length; o++) {
    let a = n[o];
    (a.from > t.from || a.to < t.to) && (t = a, e = o);
  }
  let r = t instanceof wl && t.index < 0 ? null : t.parent, i = n.slice();
  return r ? i[e] = r : i.splice(e, 1), new $Le(i, t);
}
class $Le {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return mX(this.heads);
  }
}
function BLe(n, e, t) {
  let r = n.resolveInner(e, t), i = null;
  for (let o = r instanceof wl ? r : r.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let a = o.parent;
      (i || (i = [r])).push(a.resolve(e, t)), o = a;
    } else {
      let a = Bx.get(o.tree);
      if (a && a.overlay && a.overlay[0].from <= e && a.overlay[a.overlay.length - 1].to >= e) {
        let s = new wl(a.tree, a.overlay[0].from + o.from, -1, o);
        (i || (i = [r])).push(_0(s, e, t, !1));
      }
    }
  return i ? mX(i) : r;
}
class IE {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof wl)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = t || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof wl ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.buffer.start, r);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Ir.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ir.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Ir.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(t.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = t.buffer[this.index + 3];
      if (i < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (i.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = i);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let o = t + e, a = e < 0 ? -1 : r._tree.children.length; o != a; o += e) {
          let s = r._tree.children[o];
          if (this.mode & Ir.IncludeAnonymous || s instanceof Zc || !s.type.isAnonymous || BI(s))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e:
        for (let i = this.index, o = this.stack.length; o >= 0; ) {
          for (let a = e; a; a = a._parent)
            if (a.index == i) {
              if (i == this.index)
                return a;
              t = a, r = o + 1;
              break e;
            }
          i = this.stack[--o];
        }
    for (let i = r; i < this.stack.length; i++)
      t = new Ks(this.buffer, t, this.stack[i]);
    return this.bufferNode = new Ks(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && t && t(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!r)
          return;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return LE(this.node, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0)
        return LE(this.node, e, i);
      let a = r[t.buffer[this.stack[o]]];
      if (!a.isAnonymous) {
        if (e[i] && e[i] != a.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function BI(n) {
  return n.children.some((e) => e instanceof Zc || !e.type.isAnonymous || BI(e));
}
function VLe(n) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: i = pX, reused: o = [], minRepeatType: a = r.types.length } = n, s = Array.isArray(t) ? new $I(t, t.length) : t, l = r.types, u = 0, c = 0;
  function h(w, x, S, _, C, A) {
    let { id: k, start: P, end: L, size: D } = s, E = c;
    for (; D < 0; )
      if (s.next(), D == -1) {
        let F = o[k];
        S.push(F), _.push(P - w);
        return;
      } else if (D == -3) {
        u = k;
        return;
      } else if (D == -4) {
        c = k;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${D}`);
    let M = l[k], R, N, $ = P - w;
    if (L - P <= i && (N = v(s.pos - x, C))) {
      let F = new Uint16Array(N.size - N.skip), W = s.pos - N.size, j = F.length;
      for (; s.pos > W; )
        j = m(N.start, F, j);
      R = new Zc(F, L - N.start, r), $ = N.start - w;
    } else {
      let F = s.pos - D;
      s.next();
      let W = [], j = [], Y = k >= a ? k : -1, X = 0, ie = L;
      for (; s.pos > F; )
        Y >= 0 && s.id == Y && s.size >= 0 ? (s.end <= ie - i && (p(W, j, P, X, s.end, ie, Y, E), X = W.length, ie = s.end), s.next()) : A > 2500 ? f(P, F, W, j) : h(P, F, W, j, Y, A + 1);
      if (Y >= 0 && X > 0 && X < W.length && p(W, j, P, X, P, ie, Y, E), W.reverse(), j.reverse(), Y > -1 && X > 0) {
        let ae = d(M);
        R = VI(M, W, j, 0, W.length, 0, L - P, ae, ae);
      } else
        R = g(M, W, j, L - P, E - L);
    }
    S.push(R), _.push($);
  }
  function f(w, x, S, _) {
    let C = [], A = 0, k = -1;
    for (; s.pos > x; ) {
      let { id: P, start: L, end: D, size: E } = s;
      if (E > 4)
        s.next();
      else {
        if (k > -1 && L < k)
          break;
        k < 0 && (k = D - i), C.push(P, L, D), A++, s.next();
      }
    }
    if (A) {
      let P = new Uint16Array(A * 4), L = C[C.length - 2];
      for (let D = C.length - 3, E = 0; D >= 0; D -= 3)
        P[E++] = C[D], P[E++] = C[D + 1] - L, P[E++] = C[D + 2] - L, P[E++] = E;
      S.push(new Zc(P, C[2] - L, r)), _.push(L - w);
    }
  }
  function d(w) {
    return (x, S, _) => {
      let C = 0, A = x.length - 1, k, P;
      if (A >= 0 && (k = x[A]) instanceof fi) {
        if (!A && k.type == w && k.length == _)
          return k;
        (P = k.prop(Zt.lookAhead)) && (C = S[A] + k.length + P);
      }
      return g(w, x, S, _, C);
    };
  }
  function p(w, x, S, _, C, A, k, P) {
    let L = [], D = [];
    for (; w.length > _; )
      L.push(w.pop()), D.push(x.pop() + S - C);
    w.push(g(r.types[k], L, D, A - C, P - A)), x.push(C - S);
  }
  function g(w, x, S, _, C = 0, A) {
    if (u) {
      let k = [Zt.contextHash, u];
      A = A ? [k].concat(A) : [k];
    }
    if (C > 25) {
      let k = [Zt.lookAhead, C];
      A = A ? [k].concat(A) : [k];
    }
    return new fi(w, x, S, _, A);
  }
  function v(w, x) {
    let S = s.fork(), _ = 0, C = 0, A = 0, k = S.end - i, P = { size: 0, start: 0, skip: 0 };
    e:
      for (let L = S.pos - w; S.pos > L; ) {
        let D = S.size;
        if (S.id == x && D >= 0) {
          P.size = _, P.start = C, P.skip = A, A += 4, _ += 4, S.next();
          continue;
        }
        let E = S.pos - D;
        if (D < 0 || E < L || S.start < k)
          break;
        let M = S.id >= a ? 4 : 0, R = S.start;
        for (S.next(); S.pos > E; ) {
          if (S.size < 0)
            if (S.size == -3)
              M += 4;
            else
              break e;
          else
            S.id >= a && (M += 4);
          S.next();
        }
        C = R, _ += D, A += M;
      }
    return (x < 0 || _ == w) && (P.size = _, P.start = C, P.skip = A), P.size > 4 ? P : void 0;
  }
  function m(w, x, S) {
    let { id: _, start: C, end: A, size: k } = s;
    if (s.next(), k >= 0 && _ < a) {
      let P = S;
      if (k > 4) {
        let L = s.pos - (k - 4);
        for (; s.pos > L; )
          S = m(w, x, S);
      }
      x[--S] = P, x[--S] = A - w, x[--S] = C - w, x[--S] = _;
    } else
      k == -3 ? u = _ : k == -4 && (c = _);
    return S;
  }
  let y = [], b = [];
  for (; s.pos > 0; )
    h(n.start || 0, n.bufferStart || 0, y, b, -1, 0);
  let O = (e = n.length) !== null && e !== void 0 ? e : y.length ? b[0] + y[0].length : 0;
  return new fi(l[n.topID], y.reverse(), b.reverse(), O);
}
const PV = /* @__PURE__ */ new WeakMap();
function Mw(n, e) {
  if (!n.isAnonymous || e instanceof Zc || e.type != n)
    return 1;
  let t = PV.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != n || !(r instanceof fi)) {
        t = 1;
        break;
      }
      t += Mw(n, r);
    }
    PV.set(e, t);
  }
  return t;
}
function VI(n, e, t, r, i, o, a, s, l) {
  let u = 0;
  for (let p = r; p < i; p++)
    u += Mw(n, e[p]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function d(p, g, v, m, y) {
    for (let b = v; b < m; ) {
      let O = b, w = g[b], x = Mw(n, p[b]);
      for (b++; b < m; b++) {
        let S = Mw(n, p[b]);
        if (x + S >= c)
          break;
        x += S;
      }
      if (b == O + 1) {
        if (x > c) {
          let S = p[O];
          d(S.children, S.positions, 0, S.children.length, g[O] + y);
          continue;
        }
        h.push(p[O]);
      } else {
        let S = g[b - 1] + p[b - 1].length - w;
        h.push(VI(n, p, g, O, b, w, S, null, l));
      }
      f.push(w + y - o);
    }
  }
  return d(e, t, r, i, 0), (s || l)(h, f, a);
}
class zLe {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Ks ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof wl && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Ks ? this.getBuffer(e.context.buffer, e.index) : e instanceof wl ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class $f {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, i, o = !1, a = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = i, this.open = (o ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let i = [new $f(0, e.length, e, 0, !1, r)];
    for (let o of t)
      o.to > e.length && i.push(o);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let i = [], o = 1, a = e.length ? e[0] : null;
    for (let s = 0, l = 0, u = 0; ; s++) {
      let c = s < t.length ? t[s] : null, h = c ? c.fromA : 1e9;
      if (h - l >= r)
        for (; a && a.from < h; ) {
          let f = a;
          if (l >= f.from || h <= f.to || u) {
            let d = Math.max(f.from, l) - u, p = Math.min(f.to, h) - u;
            f = d >= p ? null : new $f(d, p, f.tree, f.offset + u, s > 0, !!c);
          }
          if (f && i.push(f), a.to > h)
            break;
          a = o < e.length ? e[o++] : null;
        }
      if (!c)
        break;
      l = c.toA, u = c.toA - c.toB;
    }
    return i;
  }
}
class yX {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new FLe(e)), r = r ? r.length ? r.map((i) => new V2(i.from, i.to)) : [new V2(0, 0)] : [new V2(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let i = this.startParse(e, t, r);
    for (; ; ) {
      let o = i.advance();
      if (o)
        return o;
    }
  }
}
class FLe {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
new Zt({ perNode: !0 });
let QLe = 0;
class Ws {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.set = e, this.base = t, this.modified = r, this.id = QLe++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Ws([], null, []);
    if (t.set.push(t), e)
      for (let r of e.set)
        t.set.push(r);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Vx();
    return (t) => t.modified.indexOf(e) > -1 ? t : Vx.get(t.base || t, t.modified.concat(e).sort((r, i) => r.id - i.id));
  }
}
let ZLe = 0;
class Vx {
  constructor() {
    this.instances = [], this.id = ZLe++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((s) => s.base == e && WLe(t, s.modified));
    if (r)
      return r;
    let i = [], o = new Ws(i, e, t);
    for (let s of t)
      s.instances.push(o);
    let a = GLe(t);
    for (let s of e.set)
      if (!s.modified.length)
        for (let l of a)
          i.push(Vx.get(s, l));
    return o;
  }
}
function WLe(n, e) {
  return n.length == e.length && n.every((t, r) => t == e[r]);
}
function GLe(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(n[t]));
  return e.sort((t, r) => r.length - t.length);
}
function Q_(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    Array.isArray(r) || (r = [r]);
    for (let i of t.split(" "))
      if (i) {
        let o = [], a = 2, s = i;
        for (let h = 0; ; ) {
          if (s == "..." && h > 0 && h + 3 == i.length) {
            a = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(s);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (o.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == i.length)
            break;
          let d = i[h++];
          if (h == i.length && d == "!") {
            a = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + i);
          s = i.slice(h);
        }
        let l = o.length - 1, u = o[l];
        if (!u)
          throw new RangeError("Invalid path: " + i);
        let c = new zx(r, a, l > 0 ? o.slice(0, l) : null);
        e[u] = c.sort(e[u]);
      }
  }
  return bX.add(e);
}
const bX = new Zt();
class zx {
  constructor(e, t, r, i) {
    this.tags = e, this.mode = t, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
zx.empty = new zx([], 2, null);
function OX(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let o of n)
    if (!Array.isArray(o.tag))
      t[o.tag.id] = o.class;
    else
      for (let a of o.tag)
        t[a.id] = o.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (o) => {
      let a = i;
      for (let s of o)
        for (let l of s.set) {
          let u = t[l.id];
          if (u) {
            a = a ? a + " " + u : u;
            break;
          }
        }
      return a;
    },
    scope: r
  };
}
function jLe(n, e) {
  let t = null;
  for (let r of n) {
    let i = r.style(e);
    i && (t = t ? t + " " + i : i);
  }
  return t;
}
function HLe(n, e, t, r = 0, i = n.length) {
  let o = new qLe(r, Array.isArray(e) ? e : [e], t);
  o.highlightRange(n.cursor(), r, i, "", o.highlighters), o.flush(i);
}
class qLe {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, i, o) {
    let { type: a, from: s, to: l } = e;
    if (s >= r || l <= t)
      return;
    a.isTop && (o = this.highlighters.filter((d) => !d.scope || d.scope(a)));
    let u = i, c = YLe(e) || zx.empty, h = jLe(o, c.tags);
    if (h && (u && (u += " "), u += h, c.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(t, s), u), c.opaque)
      return;
    let f = e.tree && e.tree.prop(Zt.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + s, 1), p = this.highlighters.filter((v) => !v.scope || v.scope(f.tree.type)), g = e.firstChild();
      for (let v = 0, m = s; ; v++) {
        let y = v < f.overlay.length ? f.overlay[v] : null, b = y ? y.from + s : l, O = Math.max(t, m), w = Math.min(r, b);
        if (O < w && g)
          for (; e.from < w && (this.highlightRange(e, O, w, i, o), this.startSpan(Math.min(w, e.to), u), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!y || b > r)
          break;
        m = y.to + s, m > t && (this.highlightRange(d.cursor(), Math.max(t, y.from + s), Math.min(r, m), "", p), this.startSpan(Math.min(r, m), u));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, i, o), this.startSpan(Math.min(r, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function YLe(n) {
  let e = n.type.prop(bX);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const De = Ws.define, $1 = De(), Uu = De(), EV = De(Uu), MV = De(Uu), Ku = De(), B1 = De(Ku), z2 = De(Ku), Ns = De(), yh = De(Ns), Ps = De(), Es = De(), RE = De(), Jv = De(RE), V1 = De(), K = {
  /**
  A comment.
  */
  comment: $1,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: De($1),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: De($1),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: De($1),
  /**
  Any kind of identifier.
  */
  name: Uu,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: De(Uu),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: EV,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: De(EV),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: MV,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: De(MV),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: De(Uu),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: De(Uu),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: De(Uu),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: De(Uu),
  /**
  A literal value.
  */
  literal: Ku,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: B1,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: De(B1),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: De(B1),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: De(B1),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: z2,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: De(z2),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: De(z2),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: De(Ku),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: De(Ku),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: De(Ku),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: De(Ku),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: De(Ku),
  /**
  A language keyword.
  */
  keyword: Ps,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: De(Ps),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: De(Ps),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: De(Ps),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: De(Ps),
  /**
  An operator.
  */
  operator: Es,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: De(Es),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: De(Es),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: De(Es),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: De(Es),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: De(Es),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: De(Es),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: De(Es),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: De(Es),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: De(Es),
  /**
  Program or markup punctuation.
  */
  punctuation: RE,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: De(RE),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Jv,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: De(Jv),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: De(Jv),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: De(Jv),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: De(Jv),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Ns,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: yh,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: De(yh),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: De(yh),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: De(yh),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: De(yh),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: De(yh),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: De(yh),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: De(Ns),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: De(Ns),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: De(Ns),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: De(Ns),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: De(Ns),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: De(Ns),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: De(Ns),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: De(Ns),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: De(),
  /**
  Deleted text.
  */
  deleted: De(),
  /**
  Changed text.
  */
  changed: De(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: De(),
  /**
  Metadata or meta-instruction.
  */
  meta: V1,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: De(V1),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: De(V1),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: De(V1),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Ws.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Ws.defineModifier()
};
OX([
  { tag: K.link, class: "tok-link" },
  { tag: K.heading, class: "tok-heading" },
  { tag: K.emphasis, class: "tok-emphasis" },
  { tag: K.strong, class: "tok-strong" },
  { tag: K.keyword, class: "tok-keyword" },
  { tag: K.atom, class: "tok-atom" },
  { tag: K.bool, class: "tok-bool" },
  { tag: K.url, class: "tok-url" },
  { tag: K.labelName, class: "tok-labelName" },
  { tag: K.inserted, class: "tok-inserted" },
  { tag: K.deleted, class: "tok-deleted" },
  { tag: K.literal, class: "tok-literal" },
  { tag: K.string, class: "tok-string" },
  { tag: K.number, class: "tok-number" },
  { tag: [K.regexp, K.escape, K.special(K.string)], class: "tok-string2" },
  { tag: K.variableName, class: "tok-variableName" },
  { tag: K.local(K.variableName), class: "tok-variableName tok-local" },
  { tag: K.definition(K.variableName), class: "tok-variableName tok-definition" },
  { tag: K.special(K.variableName), class: "tok-variableName2" },
  { tag: K.definition(K.propertyName), class: "tok-propertyName tok-definition" },
  { tag: K.typeName, class: "tok-typeName" },
  { tag: K.namespace, class: "tok-namespace" },
  { tag: K.className, class: "tok-className" },
  { tag: K.macroName, class: "tok-macroName" },
  { tag: K.propertyName, class: "tok-propertyName" },
  { tag: K.operator, class: "tok-operator" },
  { tag: K.comment, class: "tok-comment" },
  { tag: K.meta, class: "tok-meta" },
  { tag: K.invalid, class: "tok-invalid" },
  { tag: K.punctuation, class: "tok-punctuation" }
]);
var F2;
const Pp = /* @__PURE__ */ new Zt();
function wX(n) {
  return Ze.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const zI = /* @__PURE__ */ new Zt();
class rs {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, nn.prototype.hasOwnProperty("tree") || Object.defineProperty(nn.prototype, "tree", { get() {
      return _r(this);
    } }), this.parser = t, this.extension = [
      Wc.of(this),
      nn.languageData.of((o, a, s) => {
        let l = DV(o, a, s), u = l.type.prop(Pp);
        if (!u)
          return [];
        let c = o.facet(u), h = l.type.prop(zI);
        if (h) {
          let f = l.resolve(a - l.from, s);
          for (let d of h)
            if (d.test(f, o)) {
              let p = o.facet(d.facet);
              return d.type == "replace" ? p : p.concat(c);
            }
        }
        return c;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return DV(e, t, r).type.prop(Pp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(Wc);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (o, a) => {
      if (o.prop(Pp) == this.data) {
        r.push({ from: a, to: a + o.length });
        return;
      }
      let s = o.prop(Zt.mounted);
      if (s) {
        if (s.tree.prop(Pp) == this.data) {
          if (s.overlay)
            for (let l of s.overlay)
              r.push({ from: l.from + a, to: l.to + a });
          else
            r.push({ from: a, to: a + o.length });
          return;
        } else if (s.overlay) {
          let l = r.length;
          if (i(s.tree, s.overlay[0].from + a), r.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let u = o.children[l];
        u instanceof fi && i(u, o.positions[l] + a);
      }
    };
    return i(_r(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
rs.setState = /* @__PURE__ */ Et.define();
function DV(n, e, t) {
  let r = n.facet(Wc), i = _r(n).topNode;
  if (!r || r.allowsNesting)
    for (let o = i; o; o = o.enter(e, t, Ir.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
class Zg extends rs {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = wX(e.languageData);
    return new Zg(t, e.parser.configure({
      props: [Pp.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Zg(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function _r(n) {
  let e = n.field(rs.state, !1);
  return e ? e.tree : fi.empty;
}
class XLe {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let em = null;
class Fx {
  constructor(e, t, r = [], i, o, a, s, l) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = a, this.skipped = s, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Fx(e, t, [], fi.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new XLe(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != fi.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped($f.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped($f.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = em;
    em = this;
    try {
      return e();
    } finally {
      em = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = LV(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: o, viewport: a, skipped: s } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, c, h, f) => l.push({ fromA: u, toA: c, fromB: h, toB: f })), r = $f.applyChanges(r, l), i = fi.empty, o = 0, a = { from: e.mapPos(a.from, -1), to: e.mapPos(a.to, 1) }, this.skipped.length) {
        s = [];
        for (let u of this.skipped) {
          let c = e.mapPos(u.from, 1), h = e.mapPos(u.to, -1);
          c < h && s.push({ from: c, to: h });
        }
      }
    }
    return new Fx(this.parser, t, r, i, o, a, s, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: o } = this.skipped[r];
      i < e.to && o > e.from && (this.fragments = LV(this.fragments, i, o), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends yX {
      createParse(t, r, i) {
        let o = i[0].from, a = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let l = em;
            if (l) {
              for (let u of i)
                l.tempSkipped.push(u);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = a, new fi(Po.none, [], [], a - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return em;
  }
}
function LV(n, e, t) {
  return $f.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Wg {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new Wg(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = Fx.create(e.facet(Wc).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new Wg(r);
  }
}
rs.state = /* @__PURE__ */ Kr.define({
  create: Wg.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(rs.setState))
        return t.value;
    return e.startState.facet(Wc) != e.state.facet(Wc) ? Wg.init(e.state) : n.apply(e);
  }
});
let xX = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (xX = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const Q2 = typeof navigator < "u" && (!((F2 = navigator.scheduling) === null || F2 === void 0) && F2.isInputPending) ? () => navigator.scheduling.isInputPending() : null, ULe = /* @__PURE__ */ Sr.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(rs.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(rs.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = xX(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, o = r.field(rs.state);
    if (o.tree == o.context.tree && o.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, e && !Q2 ? Math.max(25, e.timeRemaining() - 5) : 1e9), s = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => Q2 && Q2() || Date.now() > a, i + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: rs.setState.of(new Wg(o.context)) })), this.chunkBudget > 0 && !(l && !s) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => _a(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Wc = /* @__PURE__ */ Ze.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    rs.state,
    ULe,
    Qe.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class FI {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const KLe = /* @__PURE__ */ Ze.define(), Z_ = /* @__PURE__ */ Ze.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function Qx(n) {
  let e = n.facet(Z_);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function C0(n, e) {
  let t = "", r = n.tabSize, i = n.facet(Z_)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let o = 0; o < e; o++)
    t += i;
  return t;
}
function QI(n, e) {
  n instanceof nn && (n = new W_(n));
  for (let r of n.state.facet(KLe)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = _r(n.state);
  return t.length >= e ? JLe(n, t, e) : null;
}
class W_ {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Qx(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= r.from && i <= r.to ? o && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), o = this.countColumn(r, e - i), a = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return a > -1 && (o += a - this.countColumn(r, r.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return wv(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), o = this.options.overrideIndentation;
    if (o) {
      let a = o(i);
      if (a > -1)
        return a;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const G_ = /* @__PURE__ */ new Zt();
function JLe(n, e, t) {
  let r = e.resolveStack(t), i = r.node.enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let o = [];
    for (let a = i; a != r.node; a = a.parent)
      o.push(a);
    for (let a = o.length - 1; a >= 0; a--)
      r = { node: o[a], next: r };
  }
  return SX(r, n, t);
}
function SX(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = tIe(r.node);
    if (i)
      return i(ZI.create(e, t, r));
  }
  return 0;
}
function eIe(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function tIe(n) {
  let e = n.type.prop(G_);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(Zt.closedBy))) {
    let i = n.lastChild, o = i && r.indexOf(i.name) > -1;
    return (a) => _X(a, !0, 1, void 0, o && !eIe(a) ? i.from : void 0);
  }
  return n.parent == null ? nIe : null;
}
function nIe() {
  return 0;
}
class ZI extends W_ {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new ZI(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (rIe(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return SX(this.context.next, this.base, this.pos);
  }
}
function rIe(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function iIe(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, o = n.state.doc.lineAt(t.from), a = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let s = t.to; ; ) {
    let l = e.childAfter(s);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped)
      return l.from < a ? t : null;
    s = l.to;
  }
}
function oIe({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => _X(r, e, t, n);
}
function _X(n, e, t, r, i) {
  let o = n.textAfter, a = o.match(/^\s*/)[0].length, s = r && o.slice(a, a + r.length) == r || i == n.pos + a, l = e ? iIe(n) : null;
  return l ? s ? n.column(l.from) : n.column(l.to) : n.baseIndent + (s ? 0 : n.unit * t);
}
const aIe = (n) => n.baseIndent;
function Gp({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const sIe = 200;
function lIe() {
  return nn.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + sIe)
      return n;
    let o = t.sliceString(i.from, r);
    if (!e.some((u) => u.test(o)))
      return n;
    let { state: a } = n, s = -1, l = [];
    for (let { head: u } of a.selection.ranges) {
      let c = a.doc.lineAt(u);
      if (c.from == s)
        continue;
      s = c.from;
      let h = QI(a, c.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(c.text)[0], d = C0(a, h);
      f != d && l.push({ from: c.from, to: c.from + f.length, insert: d });
    }
    return l.length ? [n, { changes: l, sequential: !0 }] : n;
  });
}
const uIe = /* @__PURE__ */ Ze.define(), j_ = /* @__PURE__ */ new Zt();
function CX(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function cIe(n, e, t) {
  let r = _r(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), o = null;
  for (let a = i; a; a = a.next) {
    let s = a.node;
    if (s.to <= t || s.from > t)
      continue;
    if (o && s.from < e)
      break;
    let l = s.type.prop(j_);
    if (l && (s.to < r.length - 50 || r.length == n.doc.length || !hIe(s))) {
      let u = l(s, n);
      u && u.from <= t && u.from >= e && u.to > t && (o = u);
    }
  }
  return o;
}
function hIe(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function Zx(n, e, t) {
  for (let r of n.facet(uIe)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return cIe(n, e, t);
}
function AX(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const H_ = /* @__PURE__ */ Et.define({ map: AX }), Pb = /* @__PURE__ */ Et.define({ map: AX });
function TX(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const sd = /* @__PURE__ */ Kr.define({
  create() {
    return st.none;
  },
  update(n, e) {
    n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(H_) && !fIe(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(WI), i = r ? st.replace({ widget: new bIe(r(e.state, t.value)) }) : IV;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else
        t.is(Pb) && (n = n.update({
          filter: (r, i) => t.value.from != r || t.value.to != i,
          filterFrom: t.value.from,
          filterTo: t.value.to
        }));
    if (e.selection) {
      let t = !1, { head: r } = e.selection.main;
      n.between(r, r, (i, o) => {
        i < r && o > r && (t = !0);
      }), t && (n = n.update({
        filterFrom: r,
        filterTo: r,
        filter: (i, o) => o <= r || i >= r
      }));
    }
    return n;
  },
  provide: (n) => Qe.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(IV.range(r, i));
    }
    return st.set(e, !0);
  }
});
function Wx(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(sd, !1)) === null || r === void 0 || r.between(e, t, (o, a) => {
    (!i || i.from > o) && (i = { from: o, to: a });
  }), i;
}
function fIe(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, o) => {
    i == e && o == t && (r = !0);
  }), r;
}
function kX(n, e) {
  return n.field(sd, !1) ? e : e.concat(Et.appendConfig.of(EX()));
}
const dIe = (n) => {
  for (let e of TX(n)) {
    let t = Zx(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: kX(n.state, [H_.of(t), PX(n, t)]) }), !0;
  }
  return !1;
}, pIe = (n) => {
  if (!n.state.field(sd, !1))
    return !1;
  let e = [];
  for (let t of TX(n)) {
    let r = Wx(n.state, t.from, t.to);
    r && e.push(Pb.of(r), PX(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function PX(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return Qe.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const gIe = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), o = Zx(e, i.from, i.to);
    o && t.push(H_.of(o)), r = (o ? n.lineBlockAt(o.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: kX(n.state, t) }), !!t.length;
}, vIe = (n) => {
  let e = n.state.field(sd, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(Pb.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, mIe = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: dIe },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: pIe },
  { key: "Ctrl-Alt-[", run: gIe },
  { key: "Ctrl-Alt-]", run: vIe }
], yIe = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, WI = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, yIe);
  }
});
function EX(n) {
  let e = [sd, xIe];
  return n && e.push(WI.of(n)), e;
}
function MX(n, e) {
  let { state: t } = n, r = t.facet(WI), i = (a) => {
    let s = n.lineBlockAt(n.posAtDOM(a.target)), l = Wx(n.state, s.from, s.to);
    l && n.dispatch({ effects: Pb.of(l) }), a.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let o = document.createElement("span");
  return o.textContent = r.placeholderText, o.setAttribute("aria-label", t.phrase("folded code")), o.title = t.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
}
const IV = /* @__PURE__ */ st.replace({ widget: /* @__PURE__ */ new class extends Au {
  toDOM(n) {
    return MX(n, null);
  }
}() });
class bIe extends Au {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return MX(e, this.value);
  }
}
const OIe = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Z2 extends fu {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function wIe(n = {}) {
  let e = Object.assign(Object.assign({}, OIe), n), t = new Z2(e, !0), r = new Z2(e, !1), i = Sr.fromClass(class {
    constructor(a) {
      this.from = a.viewport.from, this.markers = this.buildMarkers(a);
    }
    update(a) {
      (a.docChanged || a.viewportChanged || a.startState.facet(Wc) != a.state.facet(Wc) || a.startState.field(sd, !1) != a.state.field(sd, !1) || _r(a.startState) != _r(a.state) || e.foldingChanged(a)) && (this.markers = this.buildMarkers(a.view));
    }
    buildMarkers(a) {
      let s = new Vc();
      for (let l of a.viewportLineBlocks) {
        let u = Wx(a.state, l.from, l.to) ? r : Zx(a.state, l.from, l.to) ? t : null;
        u && s.add(l.from, l.from, u);
      }
      return s.finish();
    }
  }), { domEventHandlers: o } = e;
  return [
    i,
    _Le({
      class: "cm-foldGutter",
      markers(a) {
        var s;
        return ((s = a.plugin(i)) === null || s === void 0 ? void 0 : s.markers) || Kt.empty;
      },
      initialSpacer() {
        return new Z2(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, o), { click: (a, s, l) => {
        if (o.click && o.click(a, s, l))
          return !0;
        let u = Wx(a.state, s.from, s.to);
        if (u)
          return a.dispatch({ effects: Pb.of(u) }), !0;
        let c = Zx(a.state, s.from, s.to);
        return c ? (a.dispatch({ effects: H_.of(c) }), !0) : !1;
      } })
    }),
    EX()
  ];
}
const xIe = /* @__PURE__ */ Qe.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class q_ {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(s) {
      let l = zc.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = s, l;
    }
    const o = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, a = t.scope;
    this.scope = a instanceof rs ? (s) => s.prop(Pp) == a.data : a ? (s) => s == a : void 0, this.style = OX(e.map((s) => ({
      tag: s.tag,
      class: s.class || i(Object.assign({}, s, { tag: null }))
    })), {
      all: o
    }).style, this.module = r ? new zc(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new q_(e, t || {});
  }
}
const NE = /* @__PURE__ */ Ze.define(), DX = /* @__PURE__ */ Ze.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function W2(n) {
  let e = n.facet(NE);
  return e.length ? e : n.facet(DX);
}
function SIe(n, e) {
  let t = [CIe], r;
  return n instanceof q_ && (n.module && t.push(Qe.styleModule.of(n.module)), r = n.themeType), e != null && e.fallback ? t.push(DX.of(n)) : r ? t.push(NE.computeN([Qe.darkTheme], (i) => i.facet(Qe.darkTheme) == (r == "dark") ? [n] : [])) : t.push(NE.of(n)), t;
}
class _Ie {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = _r(e.state), this.decorations = this.buildDeco(e, W2(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = _r(e.state), r = W2(e.state), i = r != W2(e.startState), { viewport: o } = e.view, a = e.changes.mapPos(this.decoratedTo, 1);
    t.length < o.to && !i && t.type == this.tree.type && a >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = a) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return st.none;
    let r = new Vc();
    for (let { from: i, to: o } of e.visibleRanges)
      HLe(this.tree, t, (a, s, l) => {
        r.add(a, s, this.markCache[l] || (this.markCache[l] = st.mark({ class: l })));
      }, i, o);
    return r.finish();
  }
}
const CIe = /* @__PURE__ */ kd.high(/* @__PURE__ */ Sr.fromClass(_Ie, {
  decorations: (n) => n.decorations
})), AIe = /* @__PURE__ */ q_.define([
  {
    tag: K.meta,
    color: "#404740"
  },
  {
    tag: K.link,
    textDecoration: "underline"
  },
  {
    tag: K.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: K.emphasis,
    fontStyle: "italic"
  },
  {
    tag: K.strong,
    fontWeight: "bold"
  },
  {
    tag: K.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: K.keyword,
    color: "#708"
  },
  {
    tag: [K.atom, K.bool, K.url, K.contentSeparator, K.labelName],
    color: "#219"
  },
  {
    tag: [K.literal, K.inserted],
    color: "#164"
  },
  {
    tag: [K.string, K.deleted],
    color: "#a11"
  },
  {
    tag: [K.regexp, K.escape, /* @__PURE__ */ K.special(K.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ K.definition(K.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ K.local(K.variableName),
    color: "#30a"
  },
  {
    tag: [K.typeName, K.namespace],
    color: "#085"
  },
  {
    tag: K.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ K.special(K.variableName), K.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ K.definition(K.propertyName),
    color: "#00c"
  },
  {
    tag: K.comment,
    color: "#940"
  },
  {
    tag: K.invalid,
    color: "#f00"
  }
]), TIe = /* @__PURE__ */ Qe.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), LX = 1e4, IX = "()[]{}", RX = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, {
      afterCursor: !0,
      brackets: IX,
      maxScanDistance: LX,
      renderMatch: EIe
    });
  }
}), kIe = /* @__PURE__ */ st.mark({ class: "cm-matchingBracket" }), PIe = /* @__PURE__ */ st.mark({ class: "cm-nonmatchingBracket" });
function EIe(n) {
  let e = [], t = n.matched ? kIe : PIe;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const MIe = /* @__PURE__ */ Kr.define({
  create() {
    return st.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(RX);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = Js(e.state, i.head, -1, r) || i.head > 0 && Js(e.state, i.head - 1, 1, r) || r.afterCursor && (Js(e.state, i.head, 1, r) || i.head < e.state.doc.length && Js(e.state, i.head + 1, -1, r));
      o && (t = t.concat(r.renderMatch(o, e.state)));
    }
    return st.set(t, !0);
  },
  provide: (n) => Qe.decorations.from(n)
}), DIe = [
  MIe,
  TIe
];
function LIe(n = {}) {
  return [RX.of(n), DIe];
}
const IIe = /* @__PURE__ */ new Zt();
function $E(n, e, t) {
  let r = n.prop(e < 0 ? Zt.openedBy : Zt.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function BE(n) {
  let e = n.type.prop(IIe);
  return e ? e(n.node) : n;
}
function Js(n, e, t, r = {}) {
  let i = r.maxScanDistance || LX, o = r.brackets || IX, a = _r(n), s = a.resolveInner(e, t);
  for (let l = s; l; l = l.parent) {
    let u = $E(l.type, t, o);
    if (u && l.from < l.to) {
      let c = BE(l);
      if (c && (t > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return RIe(n, e, t, l, c, u, o);
    }
  }
  return NIe(n, e, t, a, s.type, i, o);
}
function RIe(n, e, t, r, i, o, a) {
  let s = r.parent, l = { from: i.from, to: i.to }, u = 0, c = s == null ? void 0 : s.cursor();
  if (c && (t < 0 ? c.childBefore(r.from) : c.childAfter(r.to)))
    do
      if (t < 0 ? c.to <= r.from : c.from >= r.to) {
        if (u == 0 && o.indexOf(c.type.name) > -1 && c.from < c.to) {
          let h = BE(c);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if ($E(c.type, t, a))
          u++;
        else if ($E(c.type, -t, a)) {
          if (u == 0) {
            let h = BE(c);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (t < 0 ? c.prevSibling() : c.nextSibling());
  return { start: l, matched: !1 };
}
function NIe(n, e, t, r, i, o, a) {
  let s = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), l = a.indexOf(s);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let u = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, c = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let f = 0; !c.next().done && f <= o; ) {
    let d = c.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let g = t > 0 ? 0 : d.length - 1, v = t > 0 ? d.length : -1; g != v; g += t) {
      let m = a.indexOf(d[g]);
      if (!(m < 0 || r.resolveInner(p + g, 1).type != i))
        if (m % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: u, end: { from: p + g, to: p + g + 1 }, matched: m >> 1 == l >> 1 };
          h--;
        }
    }
    t > 0 && (f += d.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const $Ie = /* @__PURE__ */ Object.create(null), RV = [Po.none], NV = [], $V = /* @__PURE__ */ Object.create(null), BIe = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  BIe[n] = /* @__PURE__ */ VIe($Ie, e);
function G2(n, e) {
  NV.indexOf(n) > -1 || (NV.push(n), console.warn(e));
}
function VIe(n, e) {
  let t = [];
  for (let s of e.split(" ")) {
    let l = [];
    for (let u of s.split(".")) {
      let c = n[u] || K[u];
      c ? typeof c == "function" ? l.length ? l = l.map(c) : G2(u, `Modifier ${u} used at start of tag`) : l.length ? G2(u, `Tag ${u} used as modifier`) : l = Array.isArray(c) ? c : [c] : G2(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of l)
      t.push(u);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((s) => s.id), o = $V[i];
  if (o)
    return o.id;
  let a = $V[i] = Po.define({
    id: RV.length,
    name: r,
    props: [Q_({ [r]: t })]
  });
  return RV.push(a), a.id;
}
Vn.RTL, Vn.LTR;
const zIe = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), r = jI(n.state, t.from);
  return r.line ? FIe(n) : r.block ? ZIe(n) : !1;
};
function GI(n, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let i = n(e, t);
    return i ? (r(t.update(i)), !0) : !1;
  };
}
const FIe = /* @__PURE__ */ GI(
  jIe,
  0
  /* CommentOption.Toggle */
), QIe = /* @__PURE__ */ GI(
  NX,
  0
  /* CommentOption.Toggle */
), ZIe = /* @__PURE__ */ GI(
  (n, e) => NX(n, e, GIe(e)),
  0
  /* CommentOption.Toggle */
);
function jI(n, e) {
  let t = n.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const tm = 50;
function WIe(n, { open: e, close: t }, r, i) {
  let o = n.sliceDoc(r - tm, r), a = n.sliceDoc(i, i + tm), s = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(a)[0].length, u = o.length - s;
  if (o.slice(u - e.length, u) == e && a.slice(l, l + t.length) == t)
    return {
      open: { pos: r - s, margin: s && 1 },
      close: { pos: i + l, margin: l && 1 }
    };
  let c, h;
  i - r <= 2 * tm ? c = h = n.sliceDoc(r, i) : (c = n.sliceDoc(r, r + tm), h = n.sliceDoc(i - tm, i));
  let f = /^\s*/.exec(c)[0].length, d = /\s*$/.exec(h)[0].length, p = h.length - d - t.length;
  return c.slice(f, f + e.length) == e && h.slice(p, p + t.length) == t ? {
    open: {
      pos: r + f + e.length,
      margin: /\s/.test(c.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - d - t.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function GIe(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let r = n.doc.lineAt(t.from), i = t.to <= r.to ? r : n.doc.lineAt(t.to), o = e.length - 1;
    o >= 0 && e[o].to > r.from ? e[o].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function NX(n, e, t = e.selection.ranges) {
  let r = t.map((o) => jI(e, o.from).block);
  if (!r.every((o) => o))
    return null;
  let i = t.map((o, a) => WIe(e, r[a], o.from, o.to));
  if (n != 2 && !i.every((o) => o))
    return { changes: e.changes(t.map((o, a) => i[a] ? [] : [{ from: o.from, insert: r[a].open + " " }, { from: o.to, insert: " " + r[a].close }])) };
  if (n != 1 && i.some((o) => o)) {
    let o = [];
    for (let a = 0, s; a < i.length; a++)
      if (s = i[a]) {
        let l = r[a], { open: u, close: c } = s;
        o.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + l.close.length });
      }
    return { changes: o };
  }
  return null;
}
function jIe(n, e, t = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: o, to: a } of t) {
    let s = r.length, l = 1e9, u = jI(e, o).line;
    if (u) {
      for (let c = o; c <= a; ) {
        let h = e.doc.lineAt(c);
        if (h.from > i && (o == a || a > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length, d = f == h.length, p = h.text.slice(f, f + u.length) == u ? f : -1;
          f < h.text.length && f < l && (l = f), r.push({ line: h, comment: p, token: u, indent: f, empty: d, single: !1 });
        }
        c = h.to + 1;
      }
      if (l < 1e9)
        for (let c = s; c < r.length; c++)
          r[c].indent < r[c].line.text.length && (r[c].indent = l);
      r.length == s + 1 && (r[s].single = !0);
    }
  }
  if (n != 2 && r.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: s, token: l, indent: u, empty: c, single: h } of r)
      (h || !c) && o.push({ from: s.from + u, insert: l + " " });
    let a = e.changes(o);
    return { changes: a, selection: e.selection.map(a, 1) };
  } else if (n != 1 && r.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: a, comment: s, token: l } of r)
      if (s >= 0) {
        let u = a.from + s, c = u + l.length;
        a.text[c - a.from] == " " && c++, o.push({ from: u, to: c });
      }
    return { changes: o };
  }
  return null;
}
const VE = /* @__PURE__ */ Cu.define(), HIe = /* @__PURE__ */ Cu.define(), qIe = /* @__PURE__ */ Ze.define(), $X = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, i) => e(r, i) || t(r, i)
    });
  }
}), BX = /* @__PURE__ */ Kr.define({
  create() {
    return el.empty;
  },
  update(n, e) {
    let t = e.state.facet($X), r = e.annotation(VE);
    if (r) {
      let l = xo.fromTransaction(e, r.selection), u = r.side, c = u == 0 ? n.undone : n.done;
      return l ? c = Gx(c, c.length, t.minDepth, l) : c = FX(c, e.startState.selection), new el(u == 0 ? r.rest : c, u == 0 ? c : r.rest);
    }
    let i = e.annotation(HIe);
    if ((i == "full" || i == "before") && (n = n.isolate()), e.annotation(Or.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let o = xo.fromTransaction(e), a = e.annotation(Or.time), s = e.annotation(Or.userEvent);
    return o ? n = n.addChanges(o, a, s, t, e) : e.selection && (n = n.addSelection(e.startState.selection, a, s, t.newGroupDelay)), (i == "full" || i == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new el(n.done.map(xo.fromJSON), n.undone.map(xo.fromJSON));
  }
});
function YIe(n = {}) {
  return [
    BX,
    $X.of(n),
    Qe.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? VX : e.inputType == "historyRedo" ? zE : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function Y_(n, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let i = t.field(BX, !1);
    if (!i)
      return !1;
    let o = i.pop(n, t, e);
    return o ? (r(o), !0) : !1;
  };
}
const VX = /* @__PURE__ */ Y_(0, !1), zE = /* @__PURE__ */ Y_(1, !1), XIe = /* @__PURE__ */ Y_(0, !0), UIe = /* @__PURE__ */ Y_(1, !0);
class xo {
  constructor(e, t, r, i, o) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = i, this.selectionsAfter = o;
  }
  setSelAfter(e) {
    return new xo(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new xo(e.changes && Lr.fromJSON(e.changes), [], e.mapped && dl.fromJSON(e.mapped), e.startSelection && me.fromJSON(e.startSelection), e.selectionsAfter.map(me.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = Oa;
    for (let i of e.startState.facet(qIe)) {
      let o = i(e);
      o.length && (r = r.concat(o));
    }
    return !r.length && e.changes.empty ? null : new xo(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, Oa);
  }
  static selection(e) {
    return new xo(void 0, Oa, void 0, void 0, e);
  }
}
function Gx(n, e, t, r) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0, o = n.slice(i, e);
  return o.push(r), o;
}
function KIe(n, e) {
  let t = [], r = !1;
  return n.iterChangedRanges((i, o) => t.push(i, o)), e.iterChangedRanges((i, o, a, s) => {
    for (let l = 0; l < t.length; ) {
      let u = t[l++], c = t[l++];
      s >= u && a <= c && (r = !0);
    }
  }), r;
}
function JIe(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function zX(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const Oa = [], eRe = 200;
function FX(n, e) {
  if (n.length) {
    let t = n[n.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - eRe));
    return r.length && r[r.length - 1].eq(e) ? n : (r.push(e), Gx(n, n.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [xo.selection([e])];
}
function tRe(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function j2(n, e) {
  if (!n.length)
    return n;
  let t = n.length, r = Oa;
  for (; t; ) {
    let i = nRe(n[t - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let o = n.slice(0, t);
      return o[t - 1] = i, o;
    } else
      e = i.mapped, t--, r = i.selectionsAfter;
  }
  return r.length ? [xo.selection(r)] : Oa;
}
function nRe(n, e, t) {
  let r = zX(n.selectionsAfter.length ? n.selectionsAfter.map((s) => s.map(e)) : Oa, t);
  if (!n.changes)
    return xo.selection(r);
  let i = n.changes.map(e), o = e.mapDesc(n.changes, !0), a = n.mapped ? n.mapped.composeDesc(o) : o;
  return new xo(i, Et.mapEffects(n.effects, e), a, n.startSelection.map(o), r);
}
const rRe = /^(input\.type|delete)($|\.)/;
class el {
  constructor(e, t, r = 0, i = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new el(this.done, this.undone) : this;
  }
  addChanges(e, t, r, i, o) {
    let a = this.done, s = a[a.length - 1];
    return s && s.changes && !s.changes.empty && e.changes && (!r || rRe.test(r)) && (!s.selectionsAfter.length && t - this.prevTime < i.newGroupDelay && i.joinToEvent(o, KIe(s.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? a = Gx(a, a.length - 1, i.minDepth, new xo(e.changes.compose(s.changes), zX(e.effects, s.effects), s.mapped, s.startSelection, Oa)) : a = Gx(a, a.length, i.minDepth, e), new el(a, Oa, t, r);
  }
  addSelection(e, t, r, i) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Oa;
    return o.length > 0 && t - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && JIe(o[o.length - 1], e) ? this : new el(FX(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new el(j2(this.done, e), j2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let o = i[i.length - 1], a = o.selectionsAfter[0] || t.selection;
    if (r && o.selectionsAfter.length)
      return t.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: VE.of({ side: e, rest: tRe(i), selection: a }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let s = i.length == 1 ? Oa : i.slice(0, i.length - 1);
      return o.mapped && (s = j2(s, o.mapped)), t.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: VE.of({ side: e, rest: s, selection: a }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
el.empty = /* @__PURE__ */ new el(Oa, Oa);
const iRe = [
  { key: "Mod-z", run: VX, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: zE, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: zE, preventDefault: !0 },
  { key: "Mod-u", run: XIe, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: UIe, preventDefault: !0 }
];
function xv(n, e) {
  return me.create(n.ranges.map(e), n.mainIndex);
}
function Ml(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Ss({ state: n, dispatch: e }, t) {
  let r = xv(n.selection, t);
  return r.eq(n.selection, !0) ? !1 : (e(Ml(n, r)), !0);
}
function X_(n, e) {
  return me.cursor(e ? n.to : n.from);
}
function QX(n, e) {
  return Ss(n, (t) => t.empty ? n.moveByChar(t, e) : X_(t, e));
}
function Bi(n) {
  return n.textDirectionAt(n.state.selection.main.head) == Vn.LTR;
}
const ZX = (n) => QX(n, !Bi(n)), WX = (n) => QX(n, Bi(n));
function GX(n, e) {
  return Ss(n, (t) => t.empty ? n.moveByGroup(t, e) : X_(t, e));
}
const oRe = (n) => GX(n, !Bi(n)), aRe = (n) => GX(n, Bi(n));
function sRe(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function U_(n, e, t) {
  let r = _r(n).resolveInner(e.head), i = t ? Zt.closedBy : Zt.openedBy;
  for (let l = e.head; ; ) {
    let u = t ? r.childAfter(l) : r.childBefore(l);
    if (!u)
      break;
    sRe(n, u, i) ? r = u : l = t ? u.to : u.from;
  }
  let o = r.type.prop(i), a, s;
  return o && (a = t ? Js(n, r.from, 1) : Js(n, r.to, -1)) && a.matched ? s = t ? a.end.to : a.end.from : s = t ? r.to : r.from, me.cursor(s, t ? -1 : 1);
}
const lRe = (n) => Ss(n, (e) => U_(n.state, e, !Bi(n))), uRe = (n) => Ss(n, (e) => U_(n.state, e, Bi(n)));
function jX(n, e) {
  return Ss(n, (t) => {
    if (!t.empty)
      return X_(t, e);
    let r = n.moveVertically(t, e);
    return r.head != t.head ? r : n.moveToLineBoundary(t, e);
  });
}
const HX = (n) => jX(n, !1), qX = (n) => jX(n, !0);
function YX(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, r = 0, i;
  if (e) {
    for (let o of n.state.facet(Qe.scrollMargins)) {
      let a = o(n);
      a != null && a.top && (t = Math.max(a == null ? void 0 : a.top, t)), a != null && a.bottom && (r = Math.max(a == null ? void 0 : a.bottom, r));
    }
    i = n.scrollDOM.clientHeight - t - r;
  } else
    i = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, i - 5)
  };
}
function XX(n, e) {
  let t = YX(n), { state: r } = n, i = xv(r.selection, (a) => a.empty ? n.moveVertically(a, e, t.height) : X_(a, e));
  if (i.eq(r.selection))
    return !1;
  let o;
  if (t.selfScroll) {
    let a = n.coordsAtPos(r.selection.main.head), s = n.scrollDOM.getBoundingClientRect(), l = s.top + t.marginTop, u = s.bottom - t.marginBottom;
    a && a.top > l && a.bottom < u && (o = Qe.scrollIntoView(i.main.head, { y: "start", yMargin: a.top - l }));
  }
  return n.dispatch(Ml(r, i), { effects: o }), !0;
}
const BV = (n) => XX(n, !1), FE = (n) => XX(n, !0);
function hh(n, e, t) {
  let r = n.lineBlockAt(e.head), i = n.moveToLineBoundary(e, t);
  if (i.head == e.head && i.head != (t ? r.to : r.from) && (i = n.moveToLineBoundary(e, t, !1)), !t && i.head == r.from && r.length) {
    let o = /^\s*/.exec(n.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    o && e.head != r.from + o && (i = me.cursor(r.from + o));
  }
  return i;
}
const cRe = (n) => Ss(n, (e) => hh(n, e, !0)), hRe = (n) => Ss(n, (e) => hh(n, e, !1)), fRe = (n) => Ss(n, (e) => hh(n, e, !Bi(n))), dRe = (n) => Ss(n, (e) => hh(n, e, Bi(n))), pRe = (n) => Ss(n, (e) => me.cursor(n.lineBlockAt(e.head).from, 1)), gRe = (n) => Ss(n, (e) => me.cursor(n.lineBlockAt(e.head).to, -1));
function vRe(n, e, t) {
  let r = !1, i = xv(n.selection, (o) => {
    let a = Js(n, o.head, -1) || Js(n, o.head, 1) || o.head > 0 && Js(n, o.head - 1, 1) || o.head < n.doc.length && Js(n, o.head + 1, -1);
    if (!a || !a.end)
      return o;
    r = !0;
    let s = a.start.from == o.head ? a.end.to : a.end.from;
    return t ? me.range(o.anchor, s) : me.cursor(s);
  });
  return r ? (e(Ml(n, i)), !0) : !1;
}
const mRe = ({ state: n, dispatch: e }) => vRe(n, e, !1);
function $a(n, e) {
  let t = xv(n.state.selection, (r) => {
    let i = e(r);
    return me.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(Ml(n.state, t)), !0);
}
function UX(n, e) {
  return $a(n, (t) => n.moveByChar(t, e));
}
const KX = (n) => UX(n, !Bi(n)), JX = (n) => UX(n, Bi(n));
function eU(n, e) {
  return $a(n, (t) => n.moveByGroup(t, e));
}
const yRe = (n) => eU(n, !Bi(n)), bRe = (n) => eU(n, Bi(n)), ORe = (n) => $a(n, (e) => U_(n.state, e, !Bi(n))), wRe = (n) => $a(n, (e) => U_(n.state, e, Bi(n)));
function tU(n, e) {
  return $a(n, (t) => n.moveVertically(t, e));
}
const nU = (n) => tU(n, !1), rU = (n) => tU(n, !0);
function iU(n, e) {
  return $a(n, (t) => n.moveVertically(t, e, YX(n).height));
}
const VV = (n) => iU(n, !1), zV = (n) => iU(n, !0), xRe = (n) => $a(n, (e) => hh(n, e, !0)), SRe = (n) => $a(n, (e) => hh(n, e, !1)), _Re = (n) => $a(n, (e) => hh(n, e, !Bi(n))), CRe = (n) => $a(n, (e) => hh(n, e, Bi(n))), ARe = (n) => $a(n, (e) => me.cursor(n.lineBlockAt(e.head).from)), TRe = (n) => $a(n, (e) => me.cursor(n.lineBlockAt(e.head).to)), FV = ({ state: n, dispatch: e }) => (e(Ml(n, { anchor: 0 })), !0), QV = ({ state: n, dispatch: e }) => (e(Ml(n, { anchor: n.doc.length })), !0), ZV = ({ state: n, dispatch: e }) => (e(Ml(n, { anchor: n.selection.main.anchor, head: 0 })), !0), WV = ({ state: n, dispatch: e }) => (e(Ml(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), kRe = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), PRe = ({ state: n, dispatch: e }) => {
  let t = K_(n).map(({ from: r, to: i }) => me.range(r, Math.min(i + 1, n.doc.length)));
  return e(n.update({ selection: me.create(t), userEvent: "select" })), !0;
}, ERe = ({ state: n, dispatch: e }) => {
  let t = xv(n.selection, (r) => {
    var i;
    let o = _r(n).resolveStack(r.from, 1);
    for (let a = o; a; a = a.next) {
      let { node: s } = a;
      if ((s.from < r.from && s.to >= r.to || s.to > r.to && s.from <= r.from) && (!((i = s.parent) === null || i === void 0) && i.parent))
        return me.range(s.to, s.from);
    }
    return r;
  });
  return e(Ml(n, t)), !0;
}, MRe = ({ state: n, dispatch: e }) => {
  let t = n.selection, r = null;
  return t.ranges.length > 1 ? r = me.create([t.main]) : t.main.empty || (r = me.create([me.cursor(t.main.head)])), r ? (e(Ml(n, r)), !0) : !1;
};
function Eb(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = n, i = r.changeByRange((o) => {
    let { from: a, to: s } = o;
    if (a == s) {
      let l = e(o);
      l < a ? (t = "delete.backward", l = z1(n, l, !1)) : l > a && (t = "delete.forward", l = z1(n, l, !0)), a = Math.min(a, l), s = Math.max(s, l);
    } else
      a = z1(n, a, !1), s = z1(n, s, !0);
    return a == s ? { range: o } : { changes: { from: a, to: s }, range: me.cursor(a, a < o.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (n.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? Qe.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function z1(n, e, t) {
  if (n instanceof Qe)
    for (let r of n.state.facet(Qe.atomicRanges).map((i) => i(n)))
      r.between(e, e, (i, o) => {
        i < e && o > e && (e = t ? o : i);
      });
  return e;
}
const oU = (n, e) => Eb(n, (t) => {
  let r = t.from, { state: i } = n, o = i.doc.lineAt(r), a, s;
  if (!e && r > o.from && r < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, r - o.from))) {
    if (a[a.length - 1] == "	")
      return r - 1;
    let l = wv(a, i.tabSize), u = l % Qx(i) || Qx(i);
    for (let c = 0; c < u && a[a.length - 1 - c] == " "; c++)
      r--;
    s = r;
  } else
    s = hi(o.text, r - o.from, e, e) + o.from, s == r && o.number != (e ? i.doc.lines : 1) ? s += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(s - o.from, r - o.from)) && (s = hi(o.text, s - o.from, !1, !1) + o.from);
  return s;
}), QE = (n) => oU(n, !1), aU = (n) => oU(n, !0), sU = (n, e) => Eb(n, (t) => {
  let r = t.head, { state: i } = n, o = i.doc.lineAt(r), a = i.charCategorizer(r);
  for (let s = null; ; ) {
    if (r == (e ? o.to : o.from)) {
      r == t.head && o.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let l = hi(o.text, r - o.from, e) + o.from, u = o.text.slice(Math.min(r, l) - o.from, Math.max(r, l) - o.from), c = a(u);
    if (s != null && c != s)
      break;
    (u != " " || r != t.head) && (s = c), r = l;
  }
  return r;
}), lU = (n) => sU(n, !1), DRe = (n) => sU(n, !0), LRe = (n) => Eb(n, (e) => {
  let t = n.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), IRe = (n) => Eb(n, (e) => {
  let t = n.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), RRe = (n) => Eb(n, (e) => {
  let t = n.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), NRe = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: on.of(["", ""]) },
    range: me.cursor(r.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, $Re = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == n.doc.length)
      return { range: r };
    let i = r.from, o = n.doc.lineAt(i), a = i == o.from ? i - 1 : hi(o.text, i - o.from, !1) + o.from, s = i == o.to ? i + 1 : hi(o.text, i - o.from, !0) + o.from;
    return {
      changes: { from: a, to: s, insert: n.doc.slice(i, s).append(n.doc.slice(a, i)) },
      range: me.cursor(s)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function K_(n) {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.from), o = n.doc.lineAt(r.to);
    if (!r.empty && r.to == o.from && (o = n.doc.lineAt(r.to - 1)), t >= i.number) {
      let a = e[e.length - 1];
      a.to = o.to, a.ranges.push(r);
    } else
      e.push({ from: i.from, to: o.to, ranges: [r] });
    t = o.number + 1;
  }
  return e;
}
function uU(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [], i = [];
  for (let o of K_(n)) {
    if (t ? o.to == n.doc.length : o.from == 0)
      continue;
    let a = n.doc.lineAt(t ? o.to + 1 : o.from - 1), s = a.length + 1;
    if (t) {
      r.push({ from: o.to, to: a.to }, { from: o.from, insert: a.text + n.lineBreak });
      for (let l of o.ranges)
        i.push(me.range(Math.min(n.doc.length, l.anchor + s), Math.min(n.doc.length, l.head + s)));
    } else {
      r.push({ from: a.from, to: o.from }, { from: o.to, insert: n.lineBreak + a.text });
      for (let l of o.ranges)
        i.push(me.range(l.anchor - s, l.head - s));
    }
  }
  return r.length ? (e(n.update({
    changes: r,
    scrollIntoView: !0,
    selection: me.create(i, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const BRe = ({ state: n, dispatch: e }) => uU(n, e, !1), VRe = ({ state: n, dispatch: e }) => uU(n, e, !0);
function cU(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [];
  for (let i of K_(n))
    t ? r.push({ from: i.from, insert: n.doc.slice(i.from, i.to) + n.lineBreak }) : r.push({ from: i.to, insert: n.lineBreak + n.doc.slice(i.from, i.to) });
  return e(n.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const zRe = ({ state: n, dispatch: e }) => cU(n, e, !1), FRe = ({ state: n, dispatch: e }) => cU(n, e, !0), QRe = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(K_(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, { from: i, to: o }))), r = xv(e.selection, (i) => n.moveVertically(i, !0)).map(t);
  return n.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function ZRe(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = _r(n).resolveInner(e), r = t.childBefore(e), i = t.childAfter(e), o;
  return r && i && r.to <= e && i.from >= e && (o = r.type.prop(Zt.closedBy)) && o.indexOf(i.name) > -1 && n.doc.lineAt(r.to).from == n.doc.lineAt(i.from).from && !/\S/.test(n.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const WRe = /* @__PURE__ */ hU(!1), GRe = /* @__PURE__ */ hU(!0);
function hU(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: o, to: a } = i, s = e.doc.lineAt(o), l = !n && o == a && ZRe(e, o);
      n && (o = a = (a <= s.to ? s : e.doc.lineAt(a)).to);
      let u = new W_(e, { simulateBreak: o, simulateDoubleBreak: !!l }), c = QI(u, o);
      for (c == null && (c = wv(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); a < s.to && /\s/.test(s.text[a - s.from]); )
        a++;
      l ? { from: o, to: a } = l : o > s.from && o < s.from + 100 && !/\S/.test(s.text.slice(0, o)) && (o = s.from);
      let h = ["", C0(e, c)];
      return l && h.push(C0(e, u.lineIndent(s.from, -1))), {
        changes: { from: o, to: a, insert: on.of(h) },
        range: me.cursor(o + 1 + h[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function HI(n, e) {
  let t = -1;
  return n.changeByRange((r) => {
    let i = [];
    for (let a = r.from; a <= r.to; ) {
      let s = n.doc.lineAt(a);
      s.number > t && (r.empty || r.to > s.from) && (e(s, i, r), t = s.number), a = s.to + 1;
    }
    let o = n.changes(i);
    return {
      changes: i,
      range: me.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1))
    };
  });
}
const jRe = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new W_(n, { overrideIndentation: (o) => {
    let a = t[o];
    return a ?? -1;
  } }), i = HI(n, (o, a, s) => {
    let l = QI(r, o.from);
    if (l == null)
      return;
    /\S/.test(o.text) || (l = 0);
    let u = /^\s*/.exec(o.text)[0], c = C0(n, l);
    (u != c || s.from < o.from + u.length) && (t[o.from] = l, a.push({ from: o.from, to: o.from + u.length, insert: c }));
  });
  return i.changes.empty || e(n.update(i, { userEvent: "indent" })), !0;
}, HRe = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(HI(n, (t, r) => {
  r.push({ from: t.from, insert: n.facet(Z_) });
}), { userEvent: "input.indent" })), !0), qRe = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(HI(n, (t, r) => {
  let i = /^\s*/.exec(t.text)[0];
  if (!i)
    return;
  let o = wv(i, n.tabSize), a = 0, s = C0(n, Math.max(0, o - Qx(n)));
  for (; a < i.length && a < s.length && i.charCodeAt(a) == s.charCodeAt(a); )
    a++;
  r.push({ from: t.from + a, to: t.from + i.length, insert: s.slice(a) });
}), { userEvent: "delete.dedent" })), !0), YRe = [
  { key: "Ctrl-b", run: ZX, shift: KX, preventDefault: !0 },
  { key: "Ctrl-f", run: WX, shift: JX },
  { key: "Ctrl-p", run: HX, shift: nU },
  { key: "Ctrl-n", run: qX, shift: rU },
  { key: "Ctrl-a", run: pRe, shift: ARe },
  { key: "Ctrl-e", run: gRe, shift: TRe },
  { key: "Ctrl-d", run: aU },
  { key: "Ctrl-h", run: QE },
  { key: "Ctrl-k", run: LRe },
  { key: "Ctrl-Alt-h", run: lU },
  { key: "Ctrl-o", run: NRe },
  { key: "Ctrl-t", run: $Re },
  { key: "Ctrl-v", run: FE }
], XRe = /* @__PURE__ */ [
  { key: "ArrowLeft", run: ZX, shift: KX, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: oRe, shift: yRe, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: fRe, shift: _Re, preventDefault: !0 },
  { key: "ArrowRight", run: WX, shift: JX, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: aRe, shift: bRe, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: dRe, shift: CRe, preventDefault: !0 },
  { key: "ArrowUp", run: HX, shift: nU, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: FV, shift: ZV },
  { mac: "Ctrl-ArrowUp", run: BV, shift: VV },
  { key: "ArrowDown", run: qX, shift: rU, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: QV, shift: WV },
  { mac: "Ctrl-ArrowDown", run: FE, shift: zV },
  { key: "PageUp", run: BV, shift: VV },
  { key: "PageDown", run: FE, shift: zV },
  { key: "Home", run: hRe, shift: SRe, preventDefault: !0 },
  { key: "Mod-Home", run: FV, shift: ZV },
  { key: "End", run: cRe, shift: xRe, preventDefault: !0 },
  { key: "Mod-End", run: QV, shift: WV },
  { key: "Enter", run: WRe },
  { key: "Mod-a", run: kRe },
  { key: "Backspace", run: QE, shift: QE },
  { key: "Delete", run: aU },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: lU },
  { key: "Mod-Delete", mac: "Alt-Delete", run: DRe },
  { mac: "Mod-Backspace", run: IRe },
  { mac: "Mod-Delete", run: RRe }
].concat(/* @__PURE__ */ YRe.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), URe = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: lRe, shift: ORe },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: uRe, shift: wRe },
  { key: "Alt-ArrowUp", run: BRe },
  { key: "Shift-Alt-ArrowUp", run: zRe },
  { key: "Alt-ArrowDown", run: VRe },
  { key: "Shift-Alt-ArrowDown", run: FRe },
  { key: "Escape", run: MRe },
  { key: "Mod-Enter", run: GRe },
  { key: "Alt-l", mac: "Ctrl-l", run: PRe },
  { key: "Mod-i", run: ERe, preventDefault: !0 },
  { key: "Mod-[", run: qRe },
  { key: "Mod-]", run: HRe },
  { key: "Mod-Alt-\\", run: jRe },
  { key: "Shift-Mod-k", run: QRe },
  { key: "Shift-Mod-\\", run: mRe },
  { key: "Mod-/", run: zIe },
  { key: "Alt-A", run: QIe }
].concat(XRe);
function En() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t)
      if (Object.prototype.hasOwnProperty.call(t, r)) {
        var i = t[r];
        typeof i == "string" ? n.setAttribute(r, i) : i != null && (n[r] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    fU(n, arguments[e]);
  return n;
}
function fU(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      n.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        fU(n, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const GV = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class Gg {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, i = e.length, o, a) {
    this.test = a, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = o ? (s) => o(GV(s)) : GV, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return ai(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = SI(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += va(e);
      let i = this.normalize(t);
      for (let o = 0, a = r; ; o++) {
        let s = i.charCodeAt(o), l = this.match(s, a, this.bufferPos + this.bufferStart);
        if (o == i.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        a == r && o < t.length && t.charCodeAt(o) == s && a++;
      }
    }
  }
  match(e, t, r) {
    let i = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let a = this.matches[o], s = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? i = { from: this.matches[o + 1], to: r } : (this.matches[o]++, s = !0)), s || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: r } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Gg.prototype[Symbol.iterator] = function() {
  return this;
});
const dU = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, qI = "gm" + (/x/.unicode == null ? "" : "u");
class pU {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, i = 0, o = e.length) {
    if (this.text = e, this.to = o, this.curLine = "", this.done = !1, this.value = dU, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new gU(e, t, r, i, o);
    this.re = new RegExp(t, qI + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
    let a = e.lineAt(i);
    this.curLineStart = a.from, this.matchPos = jx(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, i = r + t[0].length;
        if (this.matchPos = jx(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const H2 = /* @__PURE__ */ new WeakMap();
class jp {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let i = H2.get(e);
    if (!i || i.from >= r || i.to <= t) {
      let s = new jp(t, e.sliceString(t, r));
      return H2.set(e, s), s;
    }
    if (i.from == t && i.to == r)
      return i;
    let { text: o, from: a } = i;
    return a > t && (o = e.sliceString(t, a) + o, a = t), i.to < r && (o += e.sliceString(i.to, r)), H2.set(e, new jp(a, o)), new jp(t, o.slice(t - a, r - a));
  }
}
class gU {
  constructor(e, t, r, i, o) {
    this.text = e, this.to = o, this.done = !1, this.value = dU, this.matchPos = jx(e, i), this.re = new RegExp(t, qI + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = jp.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, i = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this.matchPos = jx(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = jp.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (pU.prototype[Symbol.iterator] = gU.prototype[Symbol.iterator] = function() {
  return this;
});
function KRe(n) {
  try {
    return new RegExp(n, qI), !0;
  } catch {
    return !1;
  }
}
function jx(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function ZE(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number), t = En("input", { class: "cm-textfield", name: "line", value: e }), r = En("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), n.dispatch({ effects: Hx.of(!1) }), n.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
    },
    onsubmit: (o) => {
      o.preventDefault(), i();
    }
  }, En("label", n.state.phrase("Go to line"), ": ", t), " ", En("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")));
  function i() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!o)
      return;
    let { state: a } = n, s = a.doc.lineAt(a.selection.main.head), [, l, u, c, h] = o, f = c ? +c.slice(1) : 0, d = u ? +u : s.number;
    if (u && h) {
      let v = d / 100;
      l && (v = v * (l == "-" ? -1 : 1) + s.number / a.doc.lines), d = Math.round(a.doc.lines * v);
    } else
      u && l && (d = d * (l == "-" ? -1 : 1) + s.number);
    let p = a.doc.line(Math.max(1, Math.min(a.doc.lines, d))), g = me.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    n.dispatch({
      effects: [Hx.of(!1), Qe.scrollIntoView(g.from, { y: "center" })],
      selection: g
    }), n.focus();
  }
  return { dom: r };
}
const Hx = /* @__PURE__ */ Et.define(), jV = /* @__PURE__ */ Kr.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Hx) && (n = t.value);
    return n;
  },
  provide: (n) => S0.from(n, (e) => e ? ZE : null)
}), JRe = (n) => {
  let e = x0(n, ZE);
  if (!e) {
    let t = [Hx.of(!0)];
    n.state.field(jV, !1) == null && t.push(Et.appendConfig.of([jV, eNe])), n.dispatch({ effects: t }), e = x0(n, ZE);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, eNe = /* @__PURE__ */ Qe.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), tNe = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, vU = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, tNe, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function nNe(n) {
  let e = [sNe, aNe];
  return n && e.push(vU.of(n)), e;
}
const rNe = /* @__PURE__ */ st.mark({ class: "cm-selectionMatch" }), iNe = /* @__PURE__ */ st.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function HV(n, e, t, r) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != Zn.Word) && (r == e.doc.length || n(e.sliceDoc(r, r + 1)) != Zn.Word);
}
function oNe(n, e, t, r) {
  return n(e.sliceDoc(t, t + 1)) == Zn.Word && n(e.sliceDoc(r - 1, r)) == Zn.Word;
}
const aNe = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(vU), { state: t } = n, r = t.selection;
    if (r.ranges.length > 1)
      return st.none;
    let i = r.main, o, a = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return st.none;
      let l = t.wordAt(i.head);
      if (!l)
        return st.none;
      a = t.charCategorizer(i.head), o = t.sliceDoc(l.from, l.to);
    } else {
      let l = i.to - i.from;
      if (l < e.minSelectionLength || l > 200)
        return st.none;
      if (e.wholeWords) {
        if (o = t.sliceDoc(i.from, i.to), a = t.charCategorizer(i.head), !(HV(a, t, i.from, i.to) && oNe(a, t, i.from, i.to)))
          return st.none;
      } else if (o = t.sliceDoc(i.from, i.to), !o)
        return st.none;
    }
    let s = [];
    for (let l of n.visibleRanges) {
      let u = new Gg(t.doc, o, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: c, to: h } = u.value;
        if ((!a || HV(a, t, c, h)) && (i.empty && c <= i.from && h >= i.to ? s.push(iNe.range(c, h)) : (c >= i.to || h <= i.from) && s.push(rNe.range(c, h)), s.length > e.maxMatches))
          return st.none;
      }
    }
    return st.set(s);
  }
}, {
  decorations: (n) => n.decorations
}), sNe = /* @__PURE__ */ Qe.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), lNe = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, r = me.create(t.ranges.map((i) => n.wordAt(i.head) || me.cursor(i.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(n.update({ selection: r })), !0);
};
function uNe(n, e) {
  let { main: t, ranges: r } = n.selection, i = n.wordAt(t.head), o = i && i.from == t.from && i.to == t.to;
  for (let a = !1, s = new Gg(n.doc, e, r[r.length - 1].to); ; )
    if (s.next(), s.done) {
      if (a)
        return null;
      s = new Gg(n.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), a = !0;
    } else {
      if (a && r.some((l) => l.from == s.value.from))
        continue;
      if (o) {
        let l = n.wordAt(s.value.from);
        if (!l || l.from != s.value.from || l.to != s.value.to)
          continue;
      }
      return s.value;
    }
}
const cNe = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((o) => o.from === o.to))
    return lNe({ state: n, dispatch: e });
  let r = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((o) => n.sliceDoc(o.from, o.to) != r))
    return !1;
  let i = uNe(n, r);
  return i ? (e(n.update({
    selection: n.selection.addRange(me.range(i.from, i.to), !1),
    effects: Qe.scrollIntoView(i.to)
  })), !0) : !1;
}, Sv = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new xNe(e),
      scrollToMatch: (e) => Qe.scrollIntoView(e)
    });
  }
});
class mU {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || KRe(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new pNe(this) : new fNe(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let i = e.doc ? e : nn.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? xp(this, i, t, r) : wp(this, i, t, r);
  }
}
class yU {
  constructor(e) {
    this.spec = e;
  }
}
function wp(n, e, t, r) {
  return new Gg(e.doc, n.unquoted, t, r, n.caseSensitive ? void 0 : (i) => i.toLowerCase(), n.wholeWord ? hNe(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function hNe(n, e) {
  return (t, r, i, o) => ((o > t || o + i.length < r) && (o = Math.max(0, t - 2), i = n.sliceString(o, Math.min(n.length, r + 2))), (e(qx(i, t - o)) != Zn.Word || e(Yx(i, t - o)) != Zn.Word) && (e(Yx(i, r - o)) != Zn.Word || e(qx(i, r - o)) != Zn.Word));
}
class fNe extends yU {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let i = wp(this.spec, e, r, e.doc.length).nextOverlapping();
    return i.done && (i = wp(this.spec, e, 0, t).nextOverlapping()), i.done ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let i = r; ; ) {
      let o = Math.max(t, i - 1e4 - this.spec.unquoted.length), a = wp(this.spec, e, o, i), s = null;
      for (; !a.nextOverlapping().done; )
        s = a.value;
      if (s)
        return s;
      if (o == t)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = wp(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let o = wp(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
function xp(n, e, t, r) {
  return new pU(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? dNe(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function qx(n, e) {
  return n.slice(hi(n, e, !1), e);
}
function Yx(n, e) {
  return n.slice(e, hi(n, e));
}
function dNe(n) {
  return (e, t, r) => !r[0].length || (n(qx(r.input, r.index)) != Zn.Word || n(Yx(r.input, r.index)) != Zn.Word) && (n(Yx(r.input, r.index + r[0].length)) != Zn.Word || n(qx(r.input, r.index + r[0].length)) != Zn.Word);
}
class pNe extends yU {
  nextMatch(e, t, r) {
    let i = xp(this.spec, e, r, e.doc.length).next();
    return i.done && (i = xp(this.spec, e, 0, t).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, t, r) {
    for (let i = 1; ; i++) {
      let o = Math.max(
        t,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), a = xp(this.spec, e, o, r), s = null;
      for (; !a.next().done; )
        s = a.value;
      if (s && (o == t || s.from > o + 10))
        return s;
      if (o == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (t, r) => r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : t);
  }
  matchAll(e, t) {
    let r = xp(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let o = xp(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
const A0 = /* @__PURE__ */ Et.define(), YI = /* @__PURE__ */ Et.define(), xc = /* @__PURE__ */ Kr.define({
  create(n) {
    return new q2(WE(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(A0) ? n = new q2(t.value.create(), n.panel) : t.is(YI) && (n = new q2(n.query, t.value ? XI : null));
    return n;
  },
  provide: (n) => S0.from(n, (e) => e.panel)
});
class q2 {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const gNe = /* @__PURE__ */ st.mark({ class: "cm-searchMatch" }), vNe = /* @__PURE__ */ st.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), mNe = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(xc));
  }
  update(n) {
    let e = n.state.field(xc);
    (e != n.startState.field(xc) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return st.none;
    let { view: t } = this, r = new Vc();
    for (let i = 0, o = t.visibleRanges, a = o.length; i < a; i++) {
      let { from: s, to: l } = o[i];
      for (; i < a - 1 && l > o[i + 1].from - 2 * 250; )
        l = o[++i].to;
      n.highlight(t.state, s, l, (u, c) => {
        let h = t.state.selection.ranges.some((f) => f.from == u && f.to == c);
        r.add(u, c, h ? vNe : gNe);
      });
    }
    return r.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function Mb(n) {
  return (e) => {
    let t = e.state.field(xc, !1);
    return t && t.query.spec.valid ? n(e, t) : wU(e);
  };
}
const Xx = /* @__PURE__ */ Mb((n, { query: e }) => {
  let { to: t } = n.state.selection.main, r = e.nextMatch(n.state, t, t);
  if (!r)
    return !1;
  let i = me.single(r.from, r.to), o = n.state.facet(Sv);
  return n.dispatch({
    selection: i,
    effects: [UI(n, r), o.scrollToMatch(i.main, n)],
    userEvent: "select.search"
  }), OU(n), !0;
}), Ux = /* @__PURE__ */ Mb((n, { query: e }) => {
  let { state: t } = n, { from: r } = t.selection.main, i = e.prevMatch(t, r, r);
  if (!i)
    return !1;
  let o = me.single(i.from, i.to), a = n.state.facet(Sv);
  return n.dispatch({
    selection: o,
    effects: [UI(n, i), a.scrollToMatch(o.main, n)],
    userEvent: "select.search"
  }), OU(n), !0;
}), yNe = /* @__PURE__ */ Mb((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: me.create(t.map((r) => me.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), bNe = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: i } = t.main, o = [], a = 0;
  for (let s = new Gg(n.doc, n.sliceDoc(r, i)); !s.next().done; ) {
    if (o.length > 1e3)
      return !1;
    s.value.from == r && (a = o.length), o.push(me.range(s.value.from, s.value.to));
  }
  return e(n.update({
    selection: me.create(o, a),
    userEvent: "select.search.matches"
  })), !0;
}, qV = /* @__PURE__ */ Mb((n, { query: e }) => {
  let { state: t } = n, { from: r, to: i } = t.selection.main;
  if (t.readOnly)
    return !1;
  let o = e.nextMatch(t, r, r);
  if (!o)
    return !1;
  let a = [], s, l, u = [];
  if (o.from == r && o.to == i && (l = t.toText(e.getReplacement(o)), a.push({ from: o.from, to: o.to, insert: l }), o = e.nextMatch(t, o.from, o.to), u.push(Qe.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + "."))), o) {
    let c = a.length == 0 || a[0].from >= o.to ? 0 : o.to - o.from - l.length;
    s = me.single(o.from - c, o.to - c), u.push(UI(n, o)), u.push(t.facet(Sv).scrollToMatch(s.main, n));
  }
  return n.dispatch({
    changes: a,
    selection: s,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), ONe = /* @__PURE__ */ Mb((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((i) => {
    let { from: o, to: a } = i;
    return { from: o, to: a, insert: e.getReplacement(i) };
  });
  if (!t.length)
    return !1;
  let r = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: Qe.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function XI(n) {
  return n.state.facet(Sv).createPanel(n);
}
function WE(n, e) {
  var t, r, i, o, a;
  let s = n.selection.main, l = s.empty || s.to > s.from + 100 ? "" : n.sliceDoc(s.from, s.to);
  if (e && !l)
    return e;
  let u = n.facet(Sv);
  return new mU({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : u.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : u.literal,
    regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : u.regexp,
    wholeWord: (a = e == null ? void 0 : e.wholeWord) !== null && a !== void 0 ? a : u.wholeWord
  });
}
function bU(n) {
  let e = x0(n, XI);
  return e && e.dom.querySelector("[main-field]");
}
function OU(n) {
  let e = bU(n);
  e && e == n.root.activeElement && e.select();
}
const wU = (n) => {
  let e = n.state.field(xc, !1);
  if (e && e.panel) {
    let t = bU(n);
    if (t && t != n.root.activeElement) {
      let r = WE(n.state, e.query.spec);
      r.valid && n.dispatch({ effects: A0.of(r) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      YI.of(!0),
      e ? A0.of(WE(n.state, e.query.spec)) : Et.appendConfig.of(_Ne)
    ] });
  return !0;
}, xU = (n) => {
  let e = n.state.field(xc, !1);
  if (!e || !e.panel)
    return !1;
  let t = x0(n, XI);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: YI.of(!1) }), !0;
}, wNe = [
  { key: "Mod-f", run: wU, scope: "editor search-panel" },
  { key: "F3", run: Xx, shift: Ux, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Xx, shift: Ux, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: xU, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: bNe },
  { key: "Mod-Alt-g", run: JRe },
  { key: "Mod-d", run: cNe, preventDefault: !0 }
];
class xNe {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(xc).query.spec;
    this.commit = this.commit.bind(this), this.searchField = En("input", {
      value: t.search,
      placeholder: Mo(e, "Find"),
      "aria-label": Mo(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = En("input", {
      value: t.replace,
      placeholder: Mo(e, "Replace"),
      "aria-label": Mo(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = En("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = En("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = En("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(i, o, a) {
      return En("button", { class: "cm-button", name: i, onclick: o, type: "button" }, a);
    }
    this.dom = En("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Xx(e), [Mo(e, "next")]),
      r("prev", () => Ux(e), [Mo(e, "previous")]),
      r("select", () => yNe(e), [Mo(e, "all")]),
      En("label", null, [this.caseField, Mo(e, "match case")]),
      En("label", null, [this.reField, Mo(e, "regexp")]),
      En("label", null, [this.wordField, Mo(e, "by word")]),
      ...e.state.readOnly ? [] : [
        En("br"),
        this.replaceField,
        r("replace", () => qV(e), [Mo(e, "replace")]),
        r("replaceAll", () => ONe(e), [Mo(e, "replace all")])
      ],
      En("button", {
        name: "close",
        onclick: () => xU(e),
        "aria-label": Mo(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new mU({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: A0.of(e) }));
  }
  keydown(e) {
    RDe(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Ux : Xx)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), qV(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(A0) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Sv).top;
  }
}
function Mo(n, e) {
  return n.state.phrase(e);
}
const F1 = 30, Q1 = /[\s\.,:;?!]/;
function UI(n, { from: e, to: t }) {
  let r = n.state.doc.lineAt(e), i = n.state.doc.lineAt(t).to, o = Math.max(r.from, e - F1), a = Math.min(i, t + F1), s = n.state.sliceDoc(o, a);
  if (o != r.from) {
    for (let l = 0; l < F1; l++)
      if (!Q1.test(s[l + 1]) && Q1.test(s[l])) {
        s = s.slice(l);
        break;
      }
  }
  if (a != i) {
    for (let l = s.length - 1; l > s.length - F1; l--)
      if (!Q1.test(s[l - 1]) && Q1.test(s[l])) {
        s = s.slice(0, l);
        break;
      }
  }
  return Qe.announce.of(`${n.state.phrase("current match")}. ${s} ${n.state.phrase("on line")} ${r.number}.`);
}
const SNe = /* @__PURE__ */ Qe.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), _Ne = [
  xc,
  /* @__PURE__ */ kd.low(mNe),
  SNe
];
class SU {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r) {
    this.state = e, this.pos = t, this.explicit = r, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = _r(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), i = t.text.slice(r - t.from, this.pos - t.from), o = i.search(CU(e, !1));
    return o < 0 ? null : { from: r + o, to: this.pos, text: i.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function YV(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function CNe(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of n) {
    e[i[0]] = !0;
    for (let o = 1; o < i.length; o++)
      t[i[o]] = !0;
  }
  let r = YV(e) + YV(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function KI(n) {
  let e = n.map((i) => typeof i == "string" ? { label: i } : i), [t, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : CNe(e);
  return (i) => {
    let o = i.matchBefore(r);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: e, validFor: t } : null;
  };
}
function _U(n, e) {
  return (t) => {
    for (let r = _r(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (n.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class XV {
  constructor(e, t, r, i) {
    this.completion = e, this.source = t, this.match = r, this.score = i;
  }
}
function Sc(n) {
  return n.selection.main.from;
}
function CU(n, e) {
  var t;
  let { source: r } = n, i = e && r[0] != "^", o = r[r.length - 1] != "$";
  return !i && !o ? n : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const AU = /* @__PURE__ */ Cu.define();
function ANe(n, e, t, r) {
  let { main: i } = n.selection, o = t - i.from, a = r - i.from;
  return Object.assign(Object.assign({}, n.changeByRange((s) => s != i && t != r && n.sliceDoc(s.from + o, s.from + a) != n.sliceDoc(t, r) ? { range: s } : {
    changes: { from: s.from + o, to: r == i.from ? s.to : s.from + a, insert: e },
    range: me.cursor(s.from + o + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const UV = /* @__PURE__ */ new WeakMap();
function TNe(n) {
  if (!Array.isArray(n))
    return n;
  let e = UV.get(n);
  return e || UV.set(n, e = KI(n)), e;
}
const Kx = /* @__PURE__ */ Et.define(), T0 = /* @__PURE__ */ Et.define();
class kNe {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = ai(e, t), i = va(r);
      this.chars.push(r);
      let o = e.slice(t, t + i), a = o.toUpperCase();
      this.folded.push(ai(a == o ? o.toLowerCase() : a, 0)), t += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: t, folded: r, any: i, precise: o, byWord: a } = this;
    if (t.length == 1) {
      let y = ai(e, 0), b = va(y), O = b == e.length ? 0 : -100;
      if (y != t[0])
        if (y == r[0])
          O += -200;
        else
          return !1;
      return this.ret(O, [0, b]);
    }
    let s = e.indexOf(this.pattern);
    if (s == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, u = 0;
    if (s < 0) {
      for (let y = 0, b = Math.min(e.length, 200); y < b && u < l; ) {
        let O = ai(e, y);
        (O == t[u] || O == r[u]) && (i[u++] = y), y += va(O);
      }
      if (u < l)
        return !1;
    }
    let c = 0, h = 0, f = !1, d = 0, p = -1, g = -1, v = /[a-z]/.test(e), m = !0;
    for (let y = 0, b = Math.min(e.length, 200), O = 0; y < b && h < l; ) {
      let w = ai(e, y);
      s < 0 && (c < l && w == t[c] && (o[c++] = y), d < l && (w == t[d] || w == r[d] ? (d == 0 && (p = y), g = y + 1, d++) : d = 0));
      let x, S = w < 255 ? w >= 48 && w <= 57 || w >= 97 && w <= 122 ? 2 : w >= 65 && w <= 90 ? 1 : 0 : (x = SI(w)) != x.toLowerCase() ? 1 : x != x.toUpperCase() ? 2 : 0;
      (!y || S == 1 && v || O == 0 && S != 0) && (t[h] == w || r[h] == w && (f = !0) ? a[h++] = y : a.length && (m = !1)), O = S, y += va(w);
    }
    return h == l && a[0] == 0 && m ? this.result(-100 + (f ? -200 : 0), a, e) : d == l && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : s > -1 ? this.ret(-700 - e.length, [s, s + this.pattern.length]) : d == l ? this.ret(-900 - e.length, [p, g]) : h == l ? this.result(-100 + (f ? -200 : 0) + -700 + (m ? 0 : -1100), a, e) : t.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, t, r) {
    let i = [], o = 0;
    for (let a of t) {
      let s = a + (this.astral ? va(ai(r, a)) : 1);
      o && i[o - 1] == a ? i[o - 1] = s : (i[o++] = a, i[o++] = s);
    }
    return this.ret(e - r.length, i);
  }
}
const ci = /* @__PURE__ */ Ze.define({
  combine(n) {
    return El(n, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: PNe,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => KV(e(r), t(r)),
      optionClass: (e, t) => (r) => KV(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function KV(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function PNe(n, e, t, r, i, o) {
  let a = n.textDirection == Vn.RTL, s = a, l = !1, u = "top", c, h, f = e.left - i.left, d = i.right - e.right, p = r.right - r.left, g = r.bottom - r.top;
  if (s && f < Math.min(p, d) ? s = !1 : !s && d < Math.min(p, f) && (s = !0), p <= (s ? f : d))
    c = Math.max(i.top, Math.min(t.top, i.bottom - g)) - e.top, h = Math.min(400, s ? f : d);
  else {
    l = !0, h = Math.min(
      400,
      (a ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let y = i.bottom - e.bottom;
    y >= g || y > e.top ? c = t.bottom - e.top : (u = "bottom", c = e.bottom - t.top);
  }
  let v = (e.bottom - e.top) / o.offsetHeight, m = (e.right - e.left) / o.offsetWidth;
  return {
    style: `${u}: ${c / v}px; max-width: ${h / m}px`,
    class: "cm-completionInfo-" + (l ? a ? "left-narrow" : "right-narrow" : s ? "left" : "right")
  };
}
function ENe(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, i, o) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let s = t.displayLabel || t.label, l = 0;
      for (let u = 0; u < o.length; ) {
        let c = o[u++], h = o[u++];
        c > l && a.appendChild(document.createTextNode(s.slice(l, c)));
        let f = a.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(s.slice(c, h))), f.className = "cm-completionMatchedText", l = h;
      }
      return l < s.length && a.appendChild(document.createTextNode(s.slice(l))), a;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function Y2(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let i = Math.floor(e / t);
    return { from: i * t, to: (i + 1) * t };
  }
  let r = Math.floor((n - e) / t);
  return { from: n - (r + 1) * t, to: n - r * t };
}
class MNe {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(t), { options: o, selected: a } = i.open, s = e.state.facet(ci);
    this.optionContent = ENe(s), this.optionClass = s.optionClass, this.tooltipClass = s.tooltipClass, this.range = Y2(o.length, a, s.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: u } = e.state.field(t).open;
      for (let c = l.target, h; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (h = /-(\d+)$/.exec(c.id)) && +h[1] < u.length) {
          this.applyCompletion(e, u[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(ci).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: T0.of(null) });
    }), this.showOptions(o, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: o, selected: a, disabled: s } = r.open;
      (!i.open || i.open.options != o) && (this.range = Y2(o.length, a, e.state.facet(ci).maxRenderedOptions), this.showOptions(o, r.id)), this.updateSel(), s != ((t = i.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!s);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Y2(t.options.length, t.selected, this.view.state.facet(ci).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: i } = r;
      if (!i)
        return;
      let o = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!o)
        return;
      "then" in o ? o.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, r);
      }).catch((a) => _a(this.view.state, a, "completion info")) : this.addInfoPane(o, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: o } = e;
      r.appendChild(i), this.infoDestroy = o || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && LNe(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
    if (!o) {
      let a = this.dom.ownerDocument.defaultView || window;
      o = { left: 0, top: 0, right: a.innerWidth, bottom: a.innerHeight };
    }
    return i.top > Math.min(o.bottom, t.bottom) - 10 || i.bottom < Math.max(o.top, t.top) + 10 ? null : this.view.state.facet(ci).positionInfo(this.view, t, i, r, o, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const i = document.createElement("ul");
    i.id = t, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let o = null;
    for (let a = r.from; a < r.to; a++) {
      let { completion: s, match: l } = e[a], { section: u } = s;
      if (u) {
        let f = typeof u == "string" ? u : u.name;
        if (f != o && (a > r.from || r.from == 0))
          if (o = f, typeof u != "string" && u.header)
            i.appendChild(u.header(u));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const c = i.appendChild(document.createElement("li"));
      c.id = t + "-" + a, c.setAttribute("role", "option");
      let h = this.optionClass(s);
      h && (c.className = h);
      for (let f of this.optionContent) {
        let d = f(s, this.view.state, this.view, l);
        d && c.appendChild(d);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function DNe(n, e) {
  return (t) => new MNe(t, n, e);
}
function LNe(n, e) {
  let t = n.getBoundingClientRect(), r = e.getBoundingClientRect(), i = t.height / n.offsetHeight;
  r.top < t.top ? n.scrollTop -= (t.top - r.top) / i : r.bottom > t.bottom && (n.scrollTop += (r.bottom - t.bottom) / i);
}
function JV(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function INe(n, e) {
  let t = [], r = null, i = (l) => {
    t.push(l);
    let { section: u } = l.completion;
    if (u) {
      r || (r = []);
      let c = typeof u == "string" ? u : u.name;
      r.some((h) => h.name == c) || r.push(typeof u == "string" ? { name: c } : u);
    }
  };
  for (let l of n)
    if (l.hasResult()) {
      let u = l.result.getMatch;
      if (l.result.filter === !1)
        for (let c of l.result.options)
          i(new XV(c, l.source, u ? u(c) : [], 1e9 - t.length));
      else {
        let c = new kNe(e.sliceDoc(l.from, l.to));
        for (let h of l.result.options)
          if (c.match(h.label)) {
            let f = h.displayLabel ? u ? u(h, c.matched) : [] : c.matched;
            i(new XV(h, l.source, f, c.score + (h.boost || 0)));
          }
      }
    }
  if (r) {
    let l = /* @__PURE__ */ Object.create(null), u = 0, c = (h, f) => {
      var d, p;
      return ((d = h.rank) !== null && d !== void 0 ? d : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (h.name < f.name ? -1 : 1);
    };
    for (let h of r.sort(c))
      u -= 1e5, l[h.name] = u;
    for (let h of t) {
      let { section: f } = h.completion;
      f && (h.score += l[typeof f == "string" ? f : f.name]);
    }
  }
  let o = [], a = null, s = e.facet(ci).compareCompletions;
  for (let l of t.sort((u, c) => c.score - u.score || s(u.completion, c.completion))) {
    let u = l.completion;
    !a || a.label != u.label || a.detail != u.detail || a.type != null && u.type != null && a.type != u.type || a.apply != u.apply || a.boost != u.boost ? o.push(l) : JV(l.completion) > JV(a) && (o[o.length - 1] = l), a = l.completion;
  }
  return o;
}
class Ep {
  constructor(e, t, r, i, o, a) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = i, this.selected = o, this.disabled = a;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Ep(this.options, e4(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, i, o) {
    let a = INe(e, t);
    if (!a.length)
      return i && e.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new Ep(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let s = t.facet(ci).selectOnOpen ? 0 : -1;
    if (i && i.selected != s && i.selected != -1) {
      let l = i.options[i.selected].completion;
      for (let u = 0; u < a.length; u++)
        if (a[u].completion == l) {
          s = u;
          break;
        }
    }
    return new Ep(a, e4(r, s), {
      pos: e.reduce((l, u) => u.hasResult() ? Math.min(l, u.from) : l, 1e8),
      create: VNe,
      above: o.aboveCursor
    }, i ? i.timestamp : Date.now(), s, !1);
  }
  map(e) {
    return new Ep(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Jx {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new Jx($Ne, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(ci), o = (r.override || t.languageDataAt("autocomplete", Sc(t)).map(TNe)).map((s) => (this.active.find((u) => u.source == s) || new vo(
      s,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    o.length == this.active.length && o.every((s, l) => s == this.active[l]) && (o = this.active);
    let a = this.open;
    a && e.docChanged && (a = a.map(e.changes)), e.selection || o.some((s) => s.hasResult() && e.changes.touchesRange(s.from, s.to)) || !RNe(o, this.active) ? a = Ep.build(o, t, this.id, a, r) : a && a.disabled && !o.some(
      (s) => s.state == 1
      /* State.Pending */
    ) && (a = null), !a && o.every(
      (s) => s.state != 1
      /* State.Pending */
    ) && o.some((s) => s.hasResult()) && (o = o.map((s) => s.hasResult() ? new vo(
      s.source,
      0
      /* State.Inactive */
    ) : s));
    for (let s of e.effects)
      s.is(kU) && (a = a && a.setSelected(s.value, this.id));
    return o == this.active && a == this.open ? this : new Jx(o, this.id, a);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : NNe;
  }
}
function RNe(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < n.length && !n[t].hasResult; )
      t++;
    for (; r < e.length && !e[r].hasResult; )
      r++;
    let i = t == n.length, o = r == e.length;
    if (i || o)
      return i == o;
    if (n[t++].result != e[r++].result)
      return !1;
  }
}
const NNe = {
  "aria-autocomplete": "list"
};
function e4(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const $Ne = [];
function GE(n) {
  return n.isUserEvent("input.type") ? "input" : n.isUserEvent("delete.backward") ? "delete" : null;
}
class vo {
  constructor(e, t, r = -1) {
    this.source = e, this.state = t, this.explicitPos = r;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let r = GE(e), i = this;
    r ? i = i.handleUserEvent(e, r, t) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new vo(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let o of e.effects)
      if (o.is(Kx))
        i = new vo(i.source, 1, o.value ? Sc(e.state) : -1);
      else if (o.is(T0))
        i = new vo(
          i.source,
          0
          /* State.Inactive */
        );
      else if (o.is(TU))
        for (let a of o.value)
          a.source == i.source && (i = a);
    return i;
  }
  handleUserEvent(e, t, r) {
    return t == "delete" || !r.activateOnTyping ? this.map(e.changes) : new vo(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Sc(e.startState)) ? new vo(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new vo(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Hp extends vo {
  constructor(e, t, r, i, o) {
    super(e, 2, t), this.result = r, this.from = i, this.to = o;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, r) {
    var i;
    let o = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), s = Sc(e.state);
    if ((this.explicitPos < 0 ? s <= o : s < this.from) || s > a || t == "delete" && Sc(e.startState) == this.from)
      return new vo(
        this.source,
        t == "input" && r.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), u;
    return BNe(this.result.validFor, e.state, o, a) ? new Hp(this.source, l, this.result, o, a) : this.result.update && (u = this.result.update(this.result, o, a, new SU(e.state, s, l >= 0))) ? new Hp(this.source, l, u, u.from, (i = u.to) !== null && i !== void 0 ? i : Sc(e.state)) : new vo(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new vo(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Hp(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function BNe(n, e, t, r) {
  if (!n)
    return !1;
  let i = e.sliceDoc(t, r);
  return typeof n == "function" ? n(i, t, r, e) : CU(n, !0).test(i);
}
const TU = /* @__PURE__ */ Et.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), kU = /* @__PURE__ */ Et.define(), Fo = /* @__PURE__ */ Kr.define({
  create() {
    return Jx.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    RI.from(n, (e) => e.tooltip),
    Qe.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function PU(n, e) {
  const t = e.completion.apply || e.completion.label;
  let r = n.state.field(Fo).active.find((i) => i.source == e.source);
  return r instanceof Hp ? (typeof t == "string" ? n.dispatch(Object.assign(Object.assign({}, ANe(n.state, t, r.from, r.to)), { annotations: AU.of(e.completion) })) : t(n, e.completion, r.from, r.to), !0) : !1;
}
const VNe = /* @__PURE__ */ DNe(Fo, PU);
function Z1(n, e = "option") {
  return (t) => {
    let r = t.state.field(Fo, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(ci).interactionDelay)
      return !1;
    let i = 1, o;
    e == "page" && (o = cX(t, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = r.open.options, s = r.open.selected > -1 ? r.open.selected + i * (n ? 1 : -1) : n ? 0 : a - 1;
    return s < 0 ? s = e == "page" ? 0 : a - 1 : s >= a && (s = e == "page" ? a - 1 : 0), t.dispatch({ effects: kU.of(s) }), !0;
  };
}
const zNe = (n) => {
  let e = n.state.field(Fo, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(ci).interactionDelay ? !1 : PU(n, e.open.options[e.open.selected]);
}, FNe = (n) => n.state.field(Fo, !1) ? (n.dispatch({ effects: Kx.of(!0) }), !0) : !1, QNe = (n) => {
  let e = n.state.field(Fo, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: T0.of(null) }), !0);
};
class ZNe {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const WNe = 50, GNe = 1e3, jNe = /* @__PURE__ */ Sr.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of n.state.field(Fo).active)
      e.state == 1 && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(Fo);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Fo) == e)
      return;
    let t = n.transactions.some((i) => (i.selection || i.docChanged) && !GE(i));
    for (let i = 0; i < this.running.length; i++) {
      let o = this.running[i];
      if (t || o.updates.length + n.transactions.length > WNe && Date.now() - o.time > GNe) {
        for (let a of o.context.abortListeners)
          try {
            a();
          } catch (s) {
            _a(this.view.state, s);
          }
        o.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        o.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((i) => i.effects.some((o) => o.is(Kx))) && (this.pendingStart = !0);
    let r = this.pendingStart ? 50 : n.state.facet(ci).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((o) => o.active.source == i.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)
      for (let i of n.transactions)
        GE(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, e = n.field(Fo);
    for (let t of e.active)
      t.state == 1 && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
  }
  startQuery(n) {
    let { state: e } = this.view, t = Sc(e), r = new SU(e, t, n.explicitPos == t), i = new ZNe(n, r);
    this.running.push(i), Promise.resolve(n.source(r)).then((o) => {
      i.context.aborted || (i.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: T0.of(null) }), _a(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ci).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(ci);
    for (let r = 0; r < this.running.length; r++) {
      let i = this.running[r];
      if (i.done === void 0)
        continue;
      if (this.running.splice(r--, 1), i.done) {
        let a = new Hp(i.active.source, i.active.explicitPos, i.done, i.done.from, (n = i.done.to) !== null && n !== void 0 ? n : Sc(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let s of i.updates)
          a = a.update(s, t);
        if (a.hasResult()) {
          e.push(a);
          continue;
        }
      }
      let o = this.view.state.field(Fo).active.find((a) => a.source == i.active.source);
      if (o && o.state == 1)
        if (i.done == null) {
          let a = new vo(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let s of i.updates)
            a = a.update(s, t);
          a.state != 1 && e.push(a);
        } else
          this.startQuery(o);
    }
    e.length && this.view.dispatch({ effects: TU.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(Fo, !1);
      if (e && e.tooltip && this.view.state.facet(ci).closeOnBlur) {
        let t = e.open && cX(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: T0.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Kx.of(!1) }), 20), this.composing = 0;
    }
  }
}), EU = /* @__PURE__ */ Qe.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class HNe {
  constructor(e, t, r, i) {
    this.field = e, this.line = t, this.from = r, this.to = i;
  }
}
class JI {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, ui.TrackDel), r = e.mapPos(this.to, 1, ui.TrackDel);
    return t == null || r == null ? null : new JI(this.field, t, r);
  }
}
class eR {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], i = [t], o = e.doc.lineAt(t), a = /^\s*/.exec(o.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let u = a, c = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < c; h++)
          u += e.facet(Z_);
        i.push(t + u.length - c), l = u + l.slice(c);
      }
      r.push(l), t += l.length + 1;
    }
    let s = this.fieldPositions.map((l) => new JI(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: r, ranges: s };
  }
  static parse(e) {
    let t = [], r = [], i = [], o;
    for (let a of e.split(/\r\n?|\n/)) {
      for (; o = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(a); ) {
        let s = o[1] ? +o[1] : null, l = o[2] || o[3] || "", u = -1;
        for (let c = 0; c < t.length; c++)
          (s != null ? t[c].seq == s : l && t[c].name == l) && (u = c);
        if (u < 0) {
          let c = 0;
          for (; c < t.length && (s == null || t[c].seq != null && t[c].seq < s); )
            c++;
          t.splice(c, 0, { seq: s, name: l }), u = c;
          for (let h of i)
            h.field >= u && h.field++;
        }
        i.push(new HNe(u, r.length, o.index, o.index + l.length)), a = a.slice(0, o.index) + l + a.slice(o.index + o[0].length);
      }
      for (let s; s = /\\([{}])/.exec(a); ) {
        a = a.slice(0, s.index) + s[1] + a.slice(s.index + s[0].length);
        for (let l of i)
          l.line == r.length && l.from > s.index && (l.from--, l.to--);
      }
      r.push(a);
    }
    return new eR(r, i);
  }
}
let qNe = /* @__PURE__ */ st.widget({ widget: /* @__PURE__ */ new class extends Au {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), YNe = /* @__PURE__ */ st.mark({ class: "cm-snippetField" });
class _v {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = st.set(e.map((r) => (r.from == r.to ? qNe : YNe).range(r.from, r.to)));
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      t.push(i);
    }
    return new _v(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const Db = /* @__PURE__ */ Et.define({
  map(n, e) {
    return n && n.map(e);
  }
}), XNe = /* @__PURE__ */ Et.define(), k0 = /* @__PURE__ */ Kr.define({
  create() {
    return null;
  },
  update(n, e) {
    for (let t of e.effects) {
      if (t.is(Db))
        return t.value;
      if (t.is(XNe) && n)
        return new _v(n.ranges, t.value);
    }
    return n && e.docChanged && (n = n.map(e.changes)), n && e.selection && !n.selectionInsideField(e.selection) && (n = null), n;
  },
  provide: (n) => Qe.decorations.from(n, (e) => e ? e.deco : st.none)
});
function tR(n, e) {
  return me.create(n.filter((t) => t.field == e).map((t) => me.range(t.from, t.to)));
}
function UNe(n) {
  let e = eR.parse(n);
  return (t, r, i, o) => {
    let { text: a, ranges: s } = e.instantiate(t.state, i), l = {
      changes: { from: i, to: o, insert: on.of(a) },
      scrollIntoView: !0,
      annotations: r ? [AU.of(r), Or.userEvent.of("input.complete")] : void 0
    };
    if (s.length && (l.selection = tR(s, 0)), s.some((u) => u.field > 0)) {
      let u = new _v(s, 0), c = l.effects = [Db.of(u)];
      t.state.field(k0, !1) === void 0 && c.push(Et.appendConfig.of([k0, n$e, r$e, EU]));
    }
    t.dispatch(t.state.update(l));
  };
}
function MU(n) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(k0, !1);
    if (!r || n < 0 && r.active == 0)
      return !1;
    let i = r.active + n, o = n > 0 && !r.ranges.some((a) => a.field == i + n);
    return t(e.update({
      selection: tR(r.ranges, i),
      effects: Db.of(o ? null : new _v(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const KNe = ({ state: n, dispatch: e }) => n.field(k0, !1) ? (e(n.update({ effects: Db.of(null) })), !0) : !1, JNe = /* @__PURE__ */ MU(1), e$e = /* @__PURE__ */ MU(-1), t$e = [
  { key: "Tab", run: JNe, shift: e$e },
  { key: "Escape", run: KNe }
], t4 = /* @__PURE__ */ Ze.define({
  combine(n) {
    return n.length ? n[0] : t$e;
  }
}), n$e = /* @__PURE__ */ kd.highest(/* @__PURE__ */ z_.compute([t4], (n) => n.facet(t4)));
function ho(n, e) {
  return Object.assign(Object.assign({}, e), { apply: UNe(n) });
}
const r$e = /* @__PURE__ */ Qe.domEventHandlers({
  mousedown(n, e) {
    let t = e.state.field(k0, !1), r;
    if (!t || (r = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let i = t.ranges.find((o) => o.from <= r && o.to >= r);
    return !i || i.field == t.active ? !1 : (e.dispatch({
      selection: tR(t.ranges, i.field),
      effects: Db.of(t.ranges.some((o) => o.field > i.field) ? new _v(t.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), P0 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, yf = /* @__PURE__ */ Et.define({
  map(n, e) {
    let t = e.mapPos(n, -1, ui.TrackAfter);
    return t ?? void 0;
  }
}), nR = /* @__PURE__ */ new class extends id {
}();
nR.startSide = 1;
nR.endSide = -1;
const DU = /* @__PURE__ */ Kr.define({
  create() {
    return Kt.empty;
  },
  update(n, e) {
    if (n = n.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      n = n.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(yf) && (n = n.update({ add: [nR.range(t.value, t.value + 1)] }));
    return n;
  }
});
function i$e() {
  return [a$e, DU];
}
const X2 = "()[]{}<>";
function LU(n) {
  for (let e = 0; e < X2.length; e += 2)
    if (X2.charCodeAt(e) == n)
      return X2.charAt(e + 1);
  return SI(n < 128 ? n : n + 1);
}
function IU(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || P0;
}
const o$e = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), a$e = /* @__PURE__ */ Qe.inputHandler.of((n, e, t, r) => {
  if ((o$e ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let i = n.state.selection.main;
  if (r.length > 2 || r.length == 2 && va(ai(r, 0)) == 1 || e != i.from || t != i.to)
    return !1;
  let o = u$e(n.state, r);
  return o ? (n.dispatch(o), !0) : !1;
}), s$e = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let r = IU(n, n.selection.main.head).brackets || P0.brackets, i = null, o = n.changeByRange((a) => {
    if (a.empty) {
      let s = c$e(n.doc, a.head);
      for (let l of r)
        if (l == s && J_(n.doc, a.head) == LU(ai(l, 0)))
          return {
            changes: { from: a.head - l.length, to: a.head + l.length },
            range: me.cursor(a.head - l.length)
          };
    }
    return { range: i = a };
  });
  return i || e(n.update(o, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, l$e = [
  { key: "Backspace", run: s$e }
];
function u$e(n, e) {
  let t = IU(n, n.selection.main.head), r = t.brackets || P0.brackets;
  for (let i of r) {
    let o = LU(ai(i, 0));
    if (e == i)
      return o == i ? d$e(n, i, r.indexOf(i + i + i) > -1, t) : h$e(n, i, o, t.before || P0.before);
    if (e == o && RU(n, n.selection.main.from))
      return f$e(n, i, o);
  }
  return null;
}
function RU(n, e) {
  let t = !1;
  return n.field(DU).between(0, n.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function J_(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, va(ai(t, 0)));
}
function c$e(n, e) {
  let t = n.sliceString(e - 2, e);
  return va(ai(t, 0)) == t.length ? t : t.slice(1);
}
function h$e(n, e, t, r) {
  let i = null, o = n.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: t, from: a.to }],
        effects: yf.of(a.to + e.length),
        range: me.range(a.anchor + e.length, a.head + e.length)
      };
    let s = J_(n.doc, a.head);
    return !s || /\s/.test(s) || r.indexOf(s) > -1 ? {
      changes: { insert: e + t, from: a.head },
      effects: yf.of(a.head + e.length),
      range: me.cursor(a.head + e.length)
    } : { range: i = a };
  });
  return i ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function f$e(n, e, t) {
  let r = null, i = n.changeByRange((o) => o.empty && J_(n.doc, o.head) == t ? {
    changes: { from: o.head, to: o.head + t.length, insert: t },
    range: me.cursor(o.head + t.length)
  } : r = { range: o });
  return r ? null : n.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function d$e(n, e, t, r) {
  let i = r.stringPrefixes || P0.stringPrefixes, o = null, a = n.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: e, from: s.to }],
        effects: yf.of(s.to + e.length),
        range: me.range(s.anchor + e.length, s.head + e.length)
      };
    let l = s.head, u = J_(n.doc, l), c;
    if (u == e) {
      if (n4(n, l))
        return {
          changes: { insert: e + e, from: l },
          effects: yf.of(l + e.length),
          range: me.cursor(l + e.length)
        };
      if (RU(n, l)) {
        let f = t && n.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + f.length, insert: f },
          range: me.cursor(l + f.length)
        };
      }
    } else {
      if (t && n.sliceDoc(l - 2 * e.length, l) == e + e && (c = r4(n, l - 2 * e.length, i)) > -1 && n4(n, c))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: yf.of(l + e.length),
          range: me.cursor(l + e.length)
        };
      if (n.charCategorizer(l)(u) != Zn.Word && r4(n, l, i) > -1 && !p$e(n, l, e, i))
        return {
          changes: { insert: e + e, from: l },
          effects: yf.of(l + e.length),
          range: me.cursor(l + e.length)
        };
    }
    return { range: o = s };
  });
  return o ? null : n.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function n4(n, e) {
  let t = _r(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function p$e(n, e, t, r) {
  let i = _r(n).resolveInner(e, -1), o = r.reduce((a, s) => Math.max(a, s.length), 0);
  for (let a = 0; a < 5; a++) {
    let s = n.sliceDoc(i.from, Math.min(i.to, i.from + t.length + o)), l = s.indexOf(t);
    if (!l || l > -1 && r.indexOf(s.slice(0, l)) > -1) {
      let c = i.firstChild;
      for (; c && c.from == i.from && c.to - c.from > t.length + l; ) {
        if (n.sliceDoc(c.to - t.length, c.to) == t)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = i.to == e && i.parent;
    if (!u)
      break;
    i = u;
  }
  return !1;
}
function r4(n, e, t) {
  let r = n.charCategorizer(e);
  if (r(n.sliceDoc(e - 1, e)) != Zn.Word)
    return e;
  for (let i of t) {
    let o = e - i.length;
    if (n.sliceDoc(o, e) == i && r(n.sliceDoc(o - 1, o)) != Zn.Word)
      return o;
  }
  return -1;
}
function g$e(n = {}) {
  return [
    Fo,
    ci.of(n),
    jNe,
    v$e,
    EU
  ];
}
const NU = [
  { key: "Ctrl-Space", run: FNe },
  { key: "Escape", run: QNe },
  { key: "ArrowDown", run: /* @__PURE__ */ Z1(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Z1(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Z1(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Z1(!1, "page") },
  { key: "Enter", run: zNe }
], v$e = /* @__PURE__ */ kd.highest(/* @__PURE__ */ z_.computeN([ci], (n) => n.facet(ci).defaultKeymap ? [NU] : []));
class m$e {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class of {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let i = e, o = r.facet(VU).markerFilter;
    o && (i = o(i, r));
    let a = st.set(i.map((s) => s.from == s.to || s.from == s.to - 1 && r.doc.lineAt(s.from).to == s.from ? st.widget({
      widget: new A$e(s),
      diagnostic: s
    }).range(s.from) : st.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + s.severity + (s.markClass ? " " + s.markClass : "") },
      diagnostic: s,
      inclusive: !0
    }).range(s.from, s.to)), !0);
    return new of(a, t, jg(a));
  }
}
function jg(n, e = null, t = 0) {
  let r = null;
  return n.between(t, 1e9, (i, o, { spec: a }) => {
    if (!(e && a.diagnostic != e))
      return r = new m$e(i, o, a.diagnostic), !1;
  }), r;
}
function y$e(n, e) {
  let t = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((r) => r.is($U)) || n.changes.touchesRange(t.from, t.to));
}
function b$e(n, e) {
  return n.field(Go, !1) ? e : e.concat(Et.appendConfig.of(P$e));
}
const $U = /* @__PURE__ */ Et.define(), rR = /* @__PURE__ */ Et.define(), BU = /* @__PURE__ */ Et.define(), Go = /* @__PURE__ */ Kr.define({
  create() {
    return new of(st.none, null, null);
  },
  update(n, e) {
    if (e.docChanged) {
      let t = n.diagnostics.map(e.changes), r = null;
      if (n.selected) {
        let i = e.changes.mapPos(n.selected.from, 1);
        r = jg(t, n.selected.diagnostic, i) || jg(t, null, i);
      }
      n = new of(t, n.panel, r);
    }
    for (let t of e.effects)
      t.is($U) ? n = of.init(t.value, n.panel, e.state) : t.is(rR) ? n = new of(n.diagnostics, t.value ? eC.open : null, n.selected) : t.is(BU) && (n = new of(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    S0.from(n, (e) => e.panel),
    Qe.decorations.from(n, (e) => e.diagnostics)
  ]
}), O$e = /* @__PURE__ */ st.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: !0 });
function w$e(n, e, t) {
  let { diagnostics: r } = n.state.field(Go), i = [], o = 2e8, a = 0;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, u, { spec: c }) => {
    e >= l && e <= u && (l == u || (e > l || t > 0) && (e < u || t < 0)) && (i.push(c.diagnostic), o = Math.min(l, o), a = Math.max(u, a));
  });
  let s = n.state.facet(VU).tooltipFilter;
  return s && (i = s(i, n.state)), i.length ? {
    pos: o,
    end: a,
    above: n.state.doc.lineAt(o).to < a,
    create() {
      return { dom: x$e(n, i) };
    }
  } : null;
}
function x$e(n, e) {
  return En("ul", { class: "cm-tooltip-lint" }, e.map((t) => FU(n, t, !1)));
}
const S$e = (n) => {
  let e = n.state.field(Go, !1);
  (!e || !e.panel) && n.dispatch({ effects: b$e(n.state, [rR.of(!0)]) });
  let t = x0(n, eC.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, i4 = (n) => {
  let e = n.state.field(Go, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: rR.of(!1) }), !0);
}, _$e = (n) => {
  let e = n.state.field(Go, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, C$e = [
  { key: "Mod-Shift-m", run: S$e, preventDefault: !0 },
  { key: "F8", run: _$e }
], VU = /* @__PURE__ */ Ze.define({
  combine(n) {
    return Object.assign({ sources: n.map((e) => e.source).filter((e) => e != null) }, El(n.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t
    }));
  }
});
function zU(n) {
  let e = [];
  if (n)
    e:
      for (let { name: t } of n) {
        for (let r = 0; r < t.length; r++) {
          let i = t[r];
          if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
            e.push(i);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function FU(n, e, t) {
  var r;
  let i = t ? zU(e.actions) : [];
  return En("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, En("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((o, a) => {
    let s = !1, l = (f) => {
      if (f.preventDefault(), s)
        return;
      s = !0;
      let d = jg(n.state.field(Go).diagnostics, e);
      d && o.apply(n, d.from, d.to);
    }, { name: u } = o, c = i[a] ? u.indexOf(i[a]) : -1, h = c < 0 ? u : [
      u.slice(0, c),
      En("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ];
    return En("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${i[a]})"`}.`
    }, h);
  }), e.source && En("div", { class: "cm-diagnosticSource" }, e.source));
}
class A$e extends Au {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return En("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class o4 {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = FU(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class eC {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (i) => {
      if (i.keyCode == 27)
        i4(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: o } = this.items[this.selectedIndex], a = zU(o.actions);
        for (let s = 0; s < a.length; s++)
          if (a[s].toUpperCase().charCodeAt(0) == i.keyCode) {
            let l = jg(this.view.state.field(Go).diagnostics, o);
            l && o.actions[s].apply(e, l.from, l.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let o = 0; o < this.items.length; o++)
        this.items[o].dom.contains(i.target) && this.moveSelection(o);
    };
    this.list = En("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = En("div", { class: "cm-panel-lint" }, this.list, En("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => i4(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Go).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Go), r = 0, i = !1, o = null;
    for (e.between(0, this.view.state.doc.length, (a, s, { spec: l }) => {
      let u = -1, c;
      for (let h = r; h < this.items.length; h++)
        if (this.items[h].diagnostic == l.diagnostic) {
          u = h;
          break;
        }
      u < 0 ? (c = new o4(this.view, l.diagnostic), this.items.splice(r, 0, c), i = !0) : (c = this.items[u], u > r && (this.items.splice(r, u - r), i = !0)), t && c.diagnostic == t.diagnostic ? c.dom.hasAttribute("aria-selected") || (c.dom.setAttribute("aria-selected", "true"), o = c) : c.dom.hasAttribute("aria-selected") && c.dom.removeAttribute("aria-selected"), r++;
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new o4(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: s }) => {
        let l = s.height / this.list.offsetHeight;
        a.top < s.top ? this.list.scrollTop -= (s.top - a.top) / l : a.bottom > s.bottom && (this.list.scrollTop += (a.bottom - s.bottom) / l);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Go), r = jg(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: BU.of(r)
    });
  }
  static open(e) {
    return new eC(e);
  }
}
function T$e(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function W1(n) {
  return T$e(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const k$e = /* @__PURE__ */ Qe.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ W1("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ W1("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ W1("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ W1("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), P$e = [
  Go,
  /* @__PURE__ */ Qe.decorations.compute([Go], (n) => {
    let { selected: e, panel: t } = n.field(Go);
    return !e || !t || e.from == e.to ? st.none : st.set([
      O$e.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ wLe(w$e, { hideOn: y$e }),
  k$e
], Q6t = [
  ELe(),
  LLe(),
  KDe(),
  YIe(),
  wIe(),
  FDe(),
  jDe(),
  nn.allowMultipleSelections.of(!0),
  lIe(),
  SIe(AIe, { fallback: !0 }),
  LIe(),
  i$e(),
  g$e(),
  cLe(),
  dLe(),
  iLe(),
  nNe(),
  z_.of([
    ...l$e,
    ...URe,
    ...wNe,
    ...iRe,
    ...mIe,
    ...NU,
    ...C$e
  ])
];
let E$e = class jE {
  /**
  @internal
  */
  constructor(e, t, r, i, o, a, s, l, u, c = 0, h) {
    this.p = e, this.stack = t, this.state = r, this.reducePos = i, this.pos = o, this.score = a, this.buffer = s, this.bufferBase = l, this.curContext = u, this.lookAhead = c, this.parent = h;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, r = 0) {
    let i = e.parser.context;
    return new jE(e, [], t, r, r, 0, [], 0, i ? new a4(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let r = e >> 19, i = e & 65535, { parser: o } = this.p, a = o.dynamicPrecedence(i);
    if (a && (this.score += a), r == 0) {
      this.pushState(o.getGoto(this.state, i, !0), this.reducePos), i < o.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let s = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), l = s ? this.stack[s - 2] : this.p.ranges[0].from, u = this.reducePos - l;
    u >= 2e3 && !(!((t = this.p.parser.nodeSet.types[i]) === null || t === void 0) && t.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = u));
    let c = s ? this.stack[s - 1] : 0, h = this.bufferBase + this.buffer.length - c;
    if (i < o.minRepeatTerm || e & 131072) {
      let f = o.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, l, f, h + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[s];
    else {
      let f = this.stack[s - 3];
      this.state = o.getGoto(f, i, !0);
    }
    for (; this.stack.length > s; )
      this.stack.pop();
    this.reduceContext(i, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, r, i = 4, o = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, s = this.buffer.length;
      if (s == 0 && a.parent && (s = a.bufferBase - a.parent.bufferBase, a = a.parent), s > 0 && a.buffer[s - 4] == 0 && a.buffer[s - 1] > -1) {
        if (t == r)
          return;
        if (a.buffer[s - 2] >= t) {
          a.buffer[s - 2] = r;
          return;
        }
      }
    }
    if (!o || this.pos == r)
      this.buffer.push(e, t, r, i);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0)
        for (; a > 0 && this.buffer[a - 2] > r; )
          this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, i > 4 && (i -= 4);
      this.buffer[a] = e, this.buffer[a + 1] = t, this.buffer[a + 2] = r, this.buffer[a + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, r, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(t, r), t <= this.p.parser.maxNode && this.buffer.push(t, r, i, 4);
    else {
      let o = e, { parser: a } = this.p;
      (i > this.pos || t <= a.maxNode) && (this.pos = i, a.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(o, r), this.shiftContext(t, r), t <= a.maxNode && this.buffer.push(t, r, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, r, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(t, i), this.buffer.push(
      r,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let r = e.buffer.slice(t), i = e.bufferBase + t;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new jE(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, r ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new M$e(this); ; ) {
      let r = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (r == 0)
        return !1;
      if (!(r & 65536))
        return !0;
      t.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, a; o < t.length; o += 2)
        (a = t[o + 1]) != this.state && this.p.parser.hasAction(a, e) && i.push(t[o], a);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 8 && o < t.length; o += 2) {
          let a = t[o + 1];
          i.some((s, l) => l & 1 && s == a) || i.push(t[o], a);
        }
      t = i;
    }
    let r = [];
    for (let i = 0; i < t.length && r.length < 4; i += 2) {
      let o = t[i + 1];
      if (o == this.state)
        continue;
      let a = this.split();
      a.pushState(o, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(t[i], this.pos), a.reducePos = this.pos, a.score -= 200, r.push(a);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(t & 65536))
      return !1;
    if (!e.validAction(this.state, t)) {
      let r = t >> 19, i = t & 65535, o = this.stack.length - r * 3;
      if (o < 0 || e.getGoto(this.stack[o], i, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        t = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], r = (i, o) => {
      if (!t.includes(i))
        return t.push(i), e.allActions(i, (a) => {
          if (!(a & 393216))
            if (a & 65536) {
              let s = (a >> 19) - o;
              if (s > 1) {
                let l = a & 65535, u = this.stack.length - s * 3;
                if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                  return s << 19 | 65536 | l;
              }
            } else {
              let s = r(a, o + 1);
              if (s != null)
                return s;
            }
        });
    };
    return r(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new a4(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
class a4 {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class M$e {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = i;
  }
}
class eS {
  constructor(e, t, r) {
    this.stack = e, this.pos = t, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new eS(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new eS(this.stack, this.pos, this.index);
  }
}
function Gm(n, e = Uint16Array) {
  if (typeof n != "string")
    return n;
  let t = null;
  for (let r = 0, i = 0; r < n.length; ) {
    let o = 0;
    for (; ; ) {
      let a = n.charCodeAt(r++), s = !1;
      if (a == 126) {
        o = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let l = a - 32;
      if (l >= 46 && (l -= 46, s = !0), o += l, s)
        break;
      o *= 46;
    }
    t ? t[i++] = o : t = new e(o);
  }
  return t;
}
class Dw {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const s4 = new Dw();
class D$e {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = s4, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let r = this.range, i = this.rangeIndex, o = this.pos + e;
    for (; o < r.from; ) {
      if (!i)
        return null;
      let a = this.ranges[--i];
      o -= r.from - a.to, r = a;
    }
    for (; t < 0 ? o > r.to : o >= r.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let a = this.ranges[++i];
      o += a.from - r.to, r = a;
    }
    return o;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, r, i;
    if (t >= 0 && t < this.chunk.length)
      r = this.pos + e, i = this.chunk.charCodeAt(t);
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null)
        return -1;
      if (r = o, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let a = this.rangeIndex, s = this.range;
        for (; s.to <= r; )
          s = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > s.to && (this.chunk2 = this.chunk2.slice(0, s.to - r)), i = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let r = t ? this.resolveOffset(t, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, t) {
    this.token.value = e, this.token.end = t;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = s4, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= t)
        break;
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, t)));
    }
    return r;
  }
}
class qp {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: r } = t.p;
    QU(this.data, e, t, this.id, r.data, r.tokenPrecTable);
  }
}
qp.prototype.contextual = qp.prototype.fallback = qp.prototype.extend = !1;
class HE {
  constructor(e, t, r) {
    this.precTable = t, this.elseToken = r, this.data = typeof e == "string" ? Gm(e) : e;
  }
  token(e, t) {
    let r = e.pos, i = 0;
    for (; ; ) {
      let o = e.next < 0, a = e.resolveOffset(1, 1);
      if (QU(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (o || i++, a == null)
        break;
      e.reset(a, e.token);
    }
    i && (e.reset(r, e.token), e.acceptToken(this.elseToken, i));
  }
}
HE.prototype.contextual = qp.prototype.fallback = qp.prototype.extend = !1;
class Lb {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function QU(n, e, t, r, i, o) {
  let a = 0, s = 1 << r, { dialect: l } = t.p.parser;
  e:
    for (; s & n[a]; ) {
      let u = n[a + 1];
      for (let d = a + 3; d < u; d += 2)
        if ((n[d + 1] & s) > 0) {
          let p = n[d];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || L$e(p, e.token.value, i, o))) {
            e.acceptToken(p);
            break;
          }
        }
      let c = e.next, h = 0, f = n[a + 2];
      if (e.next < 0 && f > h && n[u + f * 3 - 3] == 65535) {
        a = n[u + f * 3 - 1];
        continue e;
      }
      for (; h < f; ) {
        let d = h + f >> 1, p = u + d + (d << 1), g = n[p], v = n[p + 1] || 65536;
        if (c < g)
          f = d;
        else if (c >= v)
          h = d + 1;
        else {
          a = n[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function l4(n, e, t) {
  for (let r = e, i; (i = n[r]) != 65535; r++)
    if (i == t)
      return r - e;
  return -1;
}
function L$e(n, e, t, r) {
  let i = l4(t, r, e);
  return i < 0 || l4(t, r, n) < i;
}
const Do = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let U2 = null;
function u4(n, e, t) {
  let r = n.cursor(Ir.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(t < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            r.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(n.length, Math.max(
            r.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return t < 0 ? 0 : n.length;
      }
}
class I$e {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? u4(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? u4(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let r = this.trees[t], i = this.index[t];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = r.children[i], a = this.start[t] + r.positions[i];
      if (a > e)
        return this.nextStart = a, null;
      if (o instanceof fi) {
        if (a == e) {
          if (a < this.safeFrom)
            return null;
          let s = a + o.length;
          if (s <= this.safeTo) {
            let l = o.prop(Zt.lookAhead);
            if (!l || s + l < this.fragment.to)
              return o;
          }
        }
        this.index[t]++, a + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(a), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = a + o.length;
    }
  }
}
class R$e {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new Dw());
  }
  getActions(e) {
    let t = 0, r = null, { parser: i } = e.p, { tokenizers: o } = i, a = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), s = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < o.length; u++) {
      if (!(1 << u & a))
        continue;
      let c = o[u], h = this.tokens[u];
      if (!(r && !c.fallback) && ((c.contextual || h.start != e.pos || h.mask != a || h.context != s) && (this.updateCachedToken(h, c, e), h.mask = a, h.context = s), h.lookAhead > h.end + 25 && (l = Math.max(h.lookAhead, l)), h.value != 0)) {
        let f = t;
        if (h.extended > -1 && (t = this.addActions(e, h.extended, h.end, t)), t = this.addActions(e, h.value, h.end, t), !c.extend && (r = h, t > f))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !r && e.pos == this.stream.end && (r = new Dw(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, t = this.addActions(e, r.value, r.end, t)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new Dw(), { pos: r, p: i } = e;
    return t.start = r, t.end = Math.min(r + 1, i.stream.end), t.value = r == i.stream.end ? i.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, r) {
    let i = this.stream.clipPos(r.pos);
    if (t.token(this.stream.reset(i, e), r), e.value > -1) {
      let { parser: o } = r.p;
      for (let a = 0; a < o.specialized.length; a++)
        if (o.specialized[a] == e.value) {
          let s = o.specializers[a](this.stream.read(e.start, e.end), r);
          if (s >= 0 && r.p.parser.dialect.allows(s >> 1)) {
            s & 1 ? e.extended = s >> 1 : e.value = s >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, t, r, i) {
    for (let o = 0; o < i; o += 3)
      if (this.actions[o] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = t, this.actions[i++] = r, i;
  }
  addActions(e, t, r, i) {
    let { state: o } = e, { parser: a } = e.p, { data: s } = a;
    for (let l = 0; l < 2; l++)
      for (let u = a.stateSlot(
        o,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (s[u] == 65535)
          if (s[u + 1] == 1)
            u = Wl(s, u + 2);
          else {
            i == 0 && s[u + 1] == 2 && (i = this.putAction(Wl(s, u + 2), t, r, i));
            break;
          }
        s[u] == t && (i = this.putAction(Wl(s, u + 1), t, r, i));
      }
    return i;
  }
}
class N$e {
  constructor(e, t, r, i) {
    this.parser = e, this.input = t, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new D$e(t, i), this.tokens = new R$e(e, this.stream), this.topTerm = e.top[1];
    let { from: o } = i[0];
    this.stacks = [E$e.start(this, e.top[0], o)], this.fragments = r.length && this.stream.end - o > e.bufferLength * 4 ? new I$e(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, r = this.stacks = [], i, o;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [a] = e;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < e.length; a++) {
      let s = e[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, s.pos > t)
          r.push(s);
        else {
          if (this.advanceStack(s, r, e))
            continue;
          {
            i || (i = [], o = []), i.push(s);
            let l = this.tokens.getMainToken(s);
            o.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let a = i && V$e(i);
      if (a)
        return Do && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw Do && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let a = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, r);
      if (a)
        return Do && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > a)
        for (r.sort((s, l) => l.score - s.score); r.length > a; )
          r.pop();
      r.some((s) => s.reducePos > t) && this.recovering--;
    } else if (r.length > 1) {
      e:
        for (let a = 0; a < r.length - 1; a++) {
          let s = r[a];
          for (let l = a + 1; l < r.length; l++) {
            let u = r[l];
            if (s.sameState(u) || s.buffer.length > 500 && u.buffer.length > 500)
              if ((s.score - u.score || s.buffer.length - u.buffer.length) > 0)
                r.splice(l--, 1);
              else {
                r.splice(a--, 1);
                continue e;
              }
          }
        }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let a = 1; a < r.length; a++)
      r[a].pos < this.minStackPos && (this.minStackPos = r[a].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, r) {
    let i = e.pos, { parser: o } = this, a = Do ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, c = u ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(i); h; ) {
        let f = this.parser.nodeSet.types[h.type.id] == h.type ? o.getGoto(e.state, h.type.id) : -1;
        if (f > -1 && h.length && (!u || (h.prop(Zt.contextHash) || 0) == c))
          return e.useNode(h, f), Do && console.log(a + this.stackID(e) + ` (via reuse of ${o.getName(h.type.id)})`), !0;
        if (!(h instanceof fi) || h.children.length == 0 || h.positions[0] > 0)
          break;
        let d = h.children[0];
        if (d instanceof fi && h.positions[0] == 0)
          h = d;
        else
          break;
      }
    }
    let s = o.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (s > 0)
      return e.reduce(s), Do && console.log(a + this.stackID(e) + ` (via always-reduce ${o.getName(
        s & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let c = l[u++], h = l[u++], f = l[u++], d = u == l.length || !r, p = d ? e : e.split(), g = this.tokens.mainToken;
      if (p.apply(c, h, g ? g.start : p.pos, f), Do && console.log(a + this.stackID(p) + ` (via ${c & 65536 ? `reduce of ${o.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${o.getName(h)} @ ${i}${p == e ? "" : ", split"})`), d)
        return !0;
      p.pos > i ? t.push(p) : r.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > r)
        return c4(e, t), !0;
    }
  }
  runRecovery(e, t, r) {
    let i = null, o = !1;
    for (let a = 0; a < e.length; a++) {
      let s = e[a], l = t[a << 1], u = t[(a << 1) + 1], c = Do ? this.stackID(s) + " -> " : "";
      if (s.deadEnd && (o || (o = !0, s.restart(), Do && console.log(c + this.stackID(s) + " (restarted)"), this.advanceFully(s, r))))
        continue;
      let h = s.split(), f = c;
      for (let d = 0; h.forceReduce() && d < 10 && (Do && console.log(f + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, r)); d++)
        Do && (f = this.stackID(h) + " -> ");
      for (let d of s.recoverByInsert(l))
        Do && console.log(c + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, r);
      this.stream.end > s.pos ? (u == s.pos && (u++, l = 0), s.recoverByDelete(l, u), Do && console.log(c + this.stackID(s) + ` (via recover-delete ${this.parser.getName(l)})`), c4(s, r)) : (!i || i.score < s.score) && (i = s);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), fi.build({
      buffer: eS.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (U2 || (U2 = /* @__PURE__ */ new WeakMap())).get(e);
    return t || U2.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function c4(n, e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    if (r.pos == n.pos && r.sameState(n)) {
      e[t].score < n.score && (e[t] = n);
      return;
    }
  }
  e.push(n);
}
class $$e {
  constructor(e, t, r) {
    this.source = e, this.flags = t, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const K2 = (n) => n;
class B$e {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || K2, this.reduce = e.reduce || K2, this.reuse = e.reuse || K2, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Hg extends yX {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let s = 0; s < e.repeatNodeCount; s++)
      t.push("");
    let r = Object.keys(e.topRules).map((s) => e.topRules[s][1]), i = [];
    for (let s = 0; s < t.length; s++)
      i.push([]);
    function o(s, l, u) {
      i[s].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let s of e.nodeProps) {
        let l = s[0];
        typeof l == "string" && (l = Zt[l]);
        for (let u = 1; u < s.length; ) {
          let c = s[u++];
          if (c >= 0)
            o(c, l, s[u++]);
          else {
            let h = s[u + -c];
            for (let f = -c; f > 0; f--)
              o(s[u++], l, h);
            u++;
          }
        }
      }
    this.nodeSet = new NI(t.map((s, l) => Po.define({
      name: l >= this.minRepeatTerm ? void 0 : s,
      id: l,
      props: i[l],
      top: r.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = pX;
    let a = Gm(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let s = 0; s < this.specializerSpecs.length; s++)
      this.specialized[s] = this.specializerSpecs[s].term;
    this.specializers = this.specializerSpecs.map(h4), this.states = Gm(e.states, Uint32Array), this.data = Gm(e.stateData), this.goto = Gm(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((s) => typeof s == "number" ? new qp(a, s) : s), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, r) {
    let i = new N$e(this, e, t, r);
    for (let o of this.wrappers)
      i = o(i, e, t, r);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, r = !1) {
    let i = this.goto;
    if (t >= i[0])
      return -1;
    for (let o = i[t + 1]; ; ) {
      let a = i[o++], s = a & 1, l = i[o++];
      if (s && r)
        return l;
      for (let u = o + (a >> 1); o < u; o++)
        if (i[o] == e)
          return l;
      if (s)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), a; ; o += 3) {
        if ((a = r[o]) == 65535)
          if (r[o + 1] == 1)
            a = r[o = Wl(r, o + 2)];
          else {
            if (r[o + 1] == 2)
              return Wl(r, o + 2);
            break;
          }
        if (a == t || a == 0)
          return Wl(r, o + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (r) => r == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let r = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = r ? t(r) : void 0;
    for (let o = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1)
          o = Wl(this.data, o + 2);
        else
          break;
      i = t(Wl(this.data, o + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Wl(this.data, r + 2);
        else
          break;
      if (!(this.data[r + 2] & 1)) {
        let i = this.data[r + 1];
        t.some((o, a) => a & 1 && o == i) || t.push(this.data[r], i);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(Hg.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = r;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((r) => {
      let i = e.tokenizers.find((o) => o.from == r);
      return i ? i.to : r;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((r, i) => {
      let o = e.specializers.find((s) => s.from == r.external);
      if (!o)
        return r;
      let a = Object.assign(Object.assign({}, r), { external: o.to });
      return t.specializers[i] = h4(a), a;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), r = t.map(() => !1);
    if (e)
      for (let o of e.split(" ")) {
        let a = t.indexOf(o);
        a >= 0 && (r[a] = !0);
      }
    let i = null;
    for (let o = 0; o < t.length; o++)
      if (!r[o])
        for (let a = this.dialects[t[o]], s; (s = this.data[a++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[s] = 1;
    return new $$e(e, r, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Hg(e);
  }
}
function Wl(n, e) {
  return n[e] | n[e + 1] << 16;
}
function V$e(n) {
  let e = null;
  for (let t of n) {
    let r = t.p.stoppedAt;
    (t.pos == t.p.stream.end || r != null && t.pos > r) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function h4(n) {
  if (n.external) {
    let e = n.extend ? 1 : 0;
    return (t, r) => n.external(t, r) << 1 | e;
  }
  return n.get;
}
const z$e = 309, f4 = 1, F$e = 2, Q$e = 3, Z$e = 310, W$e = 312, G$e = 313, j$e = 4, H$e = 5, q$e = 0, qE = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], ZU = 125, Y$e = 59, YE = 47, X$e = 42, U$e = 43, K$e = 45, J$e = 60, e3e = 44, t3e = new B$e({
  start: !1,
  shift(n, e) {
    return e == j$e || e == H$e || e == W$e ? n : e == G$e;
  },
  strict: !1
}), n3e = new Lb((n, e) => {
  let { next: t } = n;
  (t == ZU || t == -1 || e.context) && n.acceptToken(Z$e);
}, { contextual: !0, fallback: !0 }), r3e = new Lb((n, e) => {
  let { next: t } = n, r;
  qE.indexOf(t) > -1 || t == YE && ((r = n.peek(1)) == YE || r == X$e) || t != ZU && t != Y$e && t != -1 && !e.context && n.acceptToken(z$e);
}, { contextual: !0 }), i3e = new Lb((n, e) => {
  let { next: t } = n;
  if ((t == U$e || t == K$e) && (n.advance(), t == n.next)) {
    n.advance();
    let r = !e.context && e.canShift(f4);
    n.acceptToken(r ? f4 : F$e);
  }
}, { contextual: !0 });
function J2(n, e) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n == 95 || n >= 192 || !e && n >= 48 && n <= 57;
}
const o3e = new Lb((n, e) => {
  if (n.next != J$e || !e.dialectEnabled(q$e) || (n.advance(), n.next == YE))
    return;
  let t = 0;
  for (; qE.indexOf(n.next) > -1; )
    n.advance(), t++;
  if (J2(n.next, !0)) {
    for (n.advance(), t++; J2(n.next, !1); )
      n.advance(), t++;
    for (; qE.indexOf(n.next) > -1; )
      n.advance(), t++;
    if (n.next == e3e)
      return;
    for (let r = 0; ; r++) {
      if (r == 7) {
        if (!J2(n.next, !0))
          return;
        break;
      }
      if (n.next != "extends".charCodeAt(r))
        break;
      n.advance(), t++;
    }
  }
  n.acceptToken(Q$e, -t);
}), a3e = Q_({
  "get set async static": K.modifier,
  "for while do if else switch try catch finally return throw break continue default case": K.controlKeyword,
  "in of await yield void typeof delete instanceof": K.operatorKeyword,
  "let var const using function class extends": K.definitionKeyword,
  "import export from": K.moduleKeyword,
  "with debugger as new": K.keyword,
  TemplateString: K.special(K.string),
  super: K.atom,
  BooleanLiteral: K.bool,
  this: K.self,
  null: K.null,
  Star: K.modifier,
  VariableName: K.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": K.function(K.variableName),
  VariableDefinition: K.definition(K.variableName),
  Label: K.labelName,
  PropertyName: K.propertyName,
  PrivatePropertyName: K.special(K.propertyName),
  "CallExpression/MemberExpression/PropertyName": K.function(K.propertyName),
  "FunctionDeclaration/VariableDefinition": K.function(K.definition(K.variableName)),
  "ClassDeclaration/VariableDefinition": K.definition(K.className),
  PropertyDefinition: K.definition(K.propertyName),
  PrivatePropertyDefinition: K.definition(K.special(K.propertyName)),
  UpdateOp: K.updateOperator,
  "LineComment Hashbang": K.lineComment,
  BlockComment: K.blockComment,
  Number: K.number,
  String: K.string,
  Escape: K.escape,
  ArithOp: K.arithmeticOperator,
  LogicOp: K.logicOperator,
  BitOp: K.bitwiseOperator,
  CompareOp: K.compareOperator,
  RegExp: K.regexp,
  Equals: K.definitionOperator,
  Arrow: K.function(K.punctuation),
  ": Spread": K.punctuation,
  "( )": K.paren,
  "[ ]": K.squareBracket,
  "{ }": K.brace,
  "InterpolationStart InterpolationEnd": K.special(K.brace),
  ".": K.derefOperator,
  ", ;": K.separator,
  "@": K.meta,
  TypeName: K.typeName,
  TypeDefinition: K.definition(K.typeName),
  "type enum interface implements namespace module declare": K.definitionKeyword,
  "abstract global Privacy readonly override": K.modifier,
  "is keyof unique infer": K.operatorKeyword,
  JSXAttributeValue: K.attributeValue,
  JSXText: K.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": K.angleBracket,
  "JSXIdentifier JSXNameSpacedName": K.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": K.attributeName,
  "JSXBuiltin/JSXIdentifier": K.standard(K.tagName)
}), s3e = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, l3e = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, u3e = { __proto__: null, "<": 143 }, c3e = Hg.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "⚠ ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: t3e,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [a3e],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [r3e, i3e, o3e, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, n3e, new HE("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new HE("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14614 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (n) => s3e[n] || -1 }, { term: 334, get: (n) => l3e[n] || -1 }, { term: 70, get: (n) => u3e[n] || -1 }],
  tokenPrec: 14638
}), WU = [
  /* @__PURE__ */ ho("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ho("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ho("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ho("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ho("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ho(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ ho("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ ho(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ ho(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ho('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ ho('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], h3e = /* @__PURE__ */ WU.concat([
  /* @__PURE__ */ ho("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ho("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ho("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), d4 = /* @__PURE__ */ new zLe(), GU = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function nm(n) {
  return (e, t) => {
    let r = e.node.getChild("VariableDefinition");
    return r && t(r, n), !0;
  };
}
const f3e = ["FunctionDeclaration"], d3e = {
  FunctionDeclaration: /* @__PURE__ */ nm("function"),
  ClassDeclaration: /* @__PURE__ */ nm("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ nm("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ nm("type"),
  NamespaceDeclaration: /* @__PURE__ */ nm("namespace"),
  VariableDefinition(n, e) {
    n.matchContext(f3e) || e(n, "variable");
  },
  TypeDefinition(n, e) {
    e(n, "type");
  },
  __proto__: null
};
function jU(n, e) {
  let t = d4.get(e);
  if (t)
    return t;
  let r = [], i = !0;
  function o(a, s) {
    let l = n.sliceString(a.from, a.to);
    r.push({ label: l, type: s });
  }
  return e.cursor(Ir.IncludeAnonymous).iterate((a) => {
    if (i)
      i = !1;
    else if (a.name) {
      let s = d3e[a.name];
      if (s && s(a, o) || GU.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let s of jU(n, a.node))
        r.push(s);
      return !1;
    }
  }), d4.set(e, r), r;
}
const p4 = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, HU = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function p3e(n) {
  let e = _r(n.state).resolveInner(n.pos, -1);
  if (HU.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && p4.test(n.state.sliceDoc(e.from, e.to));
  if (!t && !n.explicit)
    return null;
  let r = [];
  for (let i = e; i; i = i.parent)
    GU.has(i.name) && (r = r.concat(jU(n.state.doc, i)));
  return {
    options: r,
    from: t ? e.from : n.pos,
    validFor: p4
  };
}
const Bf = /* @__PURE__ */ Zg.define({
  name: "javascript",
  parser: /* @__PURE__ */ c3e.configure({
    props: [
      /* @__PURE__ */ G_.add({
        IfStatement: /* @__PURE__ */ Gp({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Gp({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: aIe,
        SwitchBody: (n) => {
          let e = n.textAfter, t = /^\s*\}/.test(e), r = /^\s*(case|default)\b/.test(e);
          return n.baseIndent + (t ? 0 : r ? 1 : 2) * n.unit;
        },
        Block: /* @__PURE__ */ oIe({ closing: "}" }),
        ArrowFunction: (n) => n.baseIndent + n.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Gp({ except: /^{/ }),
        JSXElement(n) {
          let e = /^\s*<\//.test(n.textAfter);
          return n.lineIndent(n.node.from) + (e ? 0 : n.unit);
        },
        JSXEscape(n) {
          let e = /\s*\}/.test(n.textAfter);
          return n.lineIndent(n.node.from) + (e ? 0 : n.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        }
      }),
      /* @__PURE__ */ j_.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": CX,
        BlockComment(n) {
          return { from: n.from + 2, to: n.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), qU = {
  test: (n) => /^JSX/.test(n.name),
  facet: /* @__PURE__ */ wX({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, g3e = /* @__PURE__ */ Bf.configure({ dialect: "ts" }, "typescript"), v3e = /* @__PURE__ */ Bf.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ zI.add((n) => n.isTop ? [qU] : void 0)]
}), m3e = /* @__PURE__ */ Bf.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ zI.add((n) => n.isTop ? [qU] : void 0)]
}, "typescript");
let YU = (n) => ({ label: n, type: "keyword" });
const XU = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(YU), y3e = /* @__PURE__ */ XU.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(YU));
function Z6t(n = {}) {
  let e = n.jsx ? n.typescript ? m3e : v3e : n.typescript ? g3e : Bf, t = n.typescript ? h3e.concat(y3e) : WU.concat(XU);
  return new FI(e, [
    Bf.data.of({
      autocomplete: _U(HU, KI(t))
    }),
    Bf.data.of({
      autocomplete: p3e
    }),
    n.jsx ? w3e : []
  ]);
}
function b3e(n) {
  for (; ; ) {
    if (n.name == "JSXOpenTag" || n.name == "JSXSelfClosingTag" || n.name == "JSXFragmentTag")
      return n;
    if (n.name == "JSXEscape" || !n.parent)
      return null;
    n = n.parent;
  }
}
function g4(n, e, t = n.length) {
  for (let r = e == null ? void 0 : e.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return n.sliceString(r.from, Math.min(r.to, t));
  return "";
}
const O3e = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), w3e = /* @__PURE__ */ Qe.inputHandler.of((n, e, t, r, i) => {
  if ((O3e ? n.composing : n.compositionStarted) || n.state.readOnly || e != t || r != ">" && r != "/" || !Bf.isActiveAt(n.state, e, -1))
    return !1;
  let o = i(), { state: a } = o, s = a.changeByRange((l) => {
    var u;
    let { head: c } = l, h = _r(a).resolveInner(c - 1, -1), f;
    if (h.name == "JSXStartTag" && (h = h.parent), !(a.doc.sliceString(c - 1, c) != r || h.name == "JSXAttributeValue" && h.to > c)) {
      if (r == ">" && h.name == "JSXFragmentTag")
        return { range: l, changes: { from: c, insert: "</>" } };
      if (r == "/" && h.name == "JSXStartCloseTag") {
        let d = h.parent, p = d.parent;
        if (p && d.from == c - 2 && ((f = g4(a.doc, p.firstChild, c)) || ((u = p.firstChild) === null || u === void 0 ? void 0 : u.name) == "JSXFragmentTag")) {
          let g = `${f}>`;
          return { range: me.cursor(c + g.length, -1), changes: { from: c, insert: g } };
        }
      } else if (r == ">") {
        let d = b3e(h);
        if (d && d.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(c, c + 2)) && (f = g4(a.doc, d, c)))
          return { range: l, changes: { from: c, insert: `</${f}>` } };
      }
    }
    return { range: l };
  });
  return s.changes.empty ? !1 : (n.dispatch([
    o,
    a.update(s, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
/*! medium-zoom 1.1.0 | MIT License | https://github.com/francoischalifour/medium-zoom */
var jh = Object.assign || function(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e];
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
  }
  return n;
}, G1 = function(e) {
  return e.tagName === "IMG";
}, x3e = function(e) {
  return NodeList.prototype.isPrototypeOf(e);
}, Lw = function(e) {
  return e && e.nodeType === 1;
}, v4 = function(e) {
  var t = e.currentSrc || e.src;
  return t.substr(-4).toLowerCase() === ".svg";
}, m4 = function(e) {
  try {
    return Array.isArray(e) ? e.filter(G1) : x3e(e) ? [].slice.call(e).filter(G1) : Lw(e) ? [e].filter(G1) : typeof e == "string" ? [].slice.call(document.querySelectorAll(e)).filter(G1) : [];
  } catch {
    throw new TypeError(`The provided selector is invalid.
Expects a CSS selector, a Node element, a NodeList or an array.
See: https://github.com/francoischalifour/medium-zoom`);
  }
}, S3e = function(e) {
  var t = document.createElement("div");
  return t.classList.add("medium-zoom-overlay"), t.style.background = e, t;
}, _3e = function(e) {
  var t = e.getBoundingClientRect(), r = t.top, i = t.left, o = t.width, a = t.height, s = e.cloneNode(), l = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, u = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
  return s.removeAttribute("id"), s.style.position = "absolute", s.style.top = r + l + "px", s.style.left = i + u + "px", s.style.width = o + "px", s.style.height = a + "px", s.style.transform = "", s;
}, Hd = function(e, t) {
  var r = jh({
    bubbles: !1,
    cancelable: !1,
    detail: void 0
  }, t);
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(e, r);
  var i = document.createEvent("CustomEvent");
  return i.initCustomEvent(e, r.bubbles, r.cancelable, r.detail), i;
}, C3e = function n(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = window.Promise || function(P) {
    function L() {
    }
    P(L, L);
  }, i = function(P) {
    var L = P.target;
    if (L === C) {
      p();
      return;
    }
    b.indexOf(L) !== -1 && g({ target: L });
  }, o = function() {
    if (!(w || !_.original)) {
      var P = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      Math.abs(x - P) > S.scrollOffset && setTimeout(p, 150);
    }
  }, a = function(P) {
    var L = P.key || P.keyCode;
    (L === "Escape" || L === "Esc" || L === 27) && p();
  }, s = function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, L = P;
    if (P.background && (C.style.background = P.background), P.container && P.container instanceof Object && (L.container = jh({}, S.container, P.container)), P.template) {
      var D = Lw(P.template) ? P.template : document.querySelector(P.template);
      L.template = D;
    }
    return S = jh({}, S, L), b.forEach(function(E) {
      E.dispatchEvent(Hd("medium-zoom:update", {
        detail: { zoom: A }
      }));
    }), A;
  }, l = function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return n(jh({}, S, P));
  }, u = function() {
    for (var P = arguments.length, L = Array(P), D = 0; D < P; D++)
      L[D] = arguments[D];
    var E = L.reduce(function(M, R) {
      return [].concat(M, m4(R));
    }, []);
    return E.filter(function(M) {
      return b.indexOf(M) === -1;
    }).forEach(function(M) {
      b.push(M), M.classList.add("medium-zoom-image");
    }), O.forEach(function(M) {
      var R = M.type, N = M.listener, $ = M.options;
      E.forEach(function(F) {
        F.addEventListener(R, N, $);
      });
    }), A;
  }, c = function() {
    for (var P = arguments.length, L = Array(P), D = 0; D < P; D++)
      L[D] = arguments[D];
    _.zoomed && p();
    var E = L.length > 0 ? L.reduce(function(M, R) {
      return [].concat(M, m4(R));
    }, []) : b;
    return E.forEach(function(M) {
      M.classList.remove("medium-zoom-image"), M.dispatchEvent(Hd("medium-zoom:detach", {
        detail: { zoom: A }
      }));
    }), b = b.filter(function(M) {
      return E.indexOf(M) === -1;
    }), A;
  }, h = function(P, L) {
    var D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return b.forEach(function(E) {
      E.addEventListener("medium-zoom:" + P, L, D);
    }), O.push({ type: "medium-zoom:" + P, listener: L, options: D }), A;
  }, f = function(P, L) {
    var D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return b.forEach(function(E) {
      E.removeEventListener("medium-zoom:" + P, L, D);
    }), O = O.filter(function(E) {
      return !(E.type === "medium-zoom:" + P && E.listener.toString() === L.toString());
    }), A;
  }, d = function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, L = P.target, D = function() {
      var M = {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }, R = void 0, N = void 0;
      if (S.container)
        if (S.container instanceof Object)
          M = jh({}, M, S.container), R = M.width - M.left - M.right - S.margin * 2, N = M.height - M.top - M.bottom - S.margin * 2;
        else {
          var $ = Lw(S.container) ? S.container : document.querySelector(S.container), F = $.getBoundingClientRect(), W = F.width, j = F.height, Y = F.left, X = F.top;
          M = jh({}, M, {
            width: W,
            height: j,
            left: Y,
            top: X
          });
        }
      R = R || M.width - S.margin * 2, N = N || M.height - S.margin * 2;
      var ie = _.zoomedHd || _.original, ae = v4(ie) ? R : ie.naturalWidth || R, ee = v4(ie) ? N : ie.naturalHeight || N, ne = ie.getBoundingClientRect(), ye = ne.top, te = ne.left, ue = ne.width, xe = ne.height, dt = Math.min(Math.max(ue, ae), R) / ue, Ue = Math.min(Math.max(xe, ee), N) / xe, Rt = Math.min(dt, Ue), zt = (-te + (R - ue) / 2 + S.margin + M.left) / Rt, tn = (-ye + (N - xe) / 2 + S.margin + M.top) / Rt, jn = "scale(" + Rt + ") translate3d(" + zt + "px, " + tn + "px, 0)";
      _.zoomed.style.transform = jn, _.zoomedHd && (_.zoomedHd.style.transform = jn);
    };
    return new r(function(E) {
      if (L && b.indexOf(L) === -1) {
        E(A);
        return;
      }
      var M = function W() {
        w = !1, _.zoomed.removeEventListener("transitionend", W), _.original.dispatchEvent(Hd("medium-zoom:opened", {
          detail: { zoom: A }
        })), E(A);
      };
      if (_.zoomed) {
        E(A);
        return;
      }
      if (L)
        _.original = L;
      else if (b.length > 0) {
        var R = b;
        _.original = R[0];
      } else {
        E(A);
        return;
      }
      if (_.original.dispatchEvent(Hd("medium-zoom:open", {
        detail: { zoom: A }
      })), x = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, w = !0, _.zoomed = _3e(_.original), document.body.appendChild(C), S.template) {
        var N = Lw(S.template) ? S.template : document.querySelector(S.template);
        _.template = document.createElement("div"), _.template.appendChild(N.content.cloneNode(!0)), document.body.appendChild(_.template);
      }
      if (_.original.parentElement && _.original.parentElement.tagName === "PICTURE" && _.original.currentSrc && (_.zoomed.src = _.original.currentSrc), document.body.appendChild(_.zoomed), window.requestAnimationFrame(function() {
        document.body.classList.add("medium-zoom--opened");
      }), _.original.classList.add("medium-zoom-image--hidden"), _.zoomed.classList.add("medium-zoom-image--opened"), _.zoomed.addEventListener("click", p), _.zoomed.addEventListener("transitionend", M), _.original.getAttribute("data-zoom-src")) {
        _.zoomedHd = _.zoomed.cloneNode(), _.zoomedHd.removeAttribute("srcset"), _.zoomedHd.removeAttribute("sizes"), _.zoomedHd.removeAttribute("loading"), _.zoomedHd.src = _.zoomed.getAttribute("data-zoom-src"), _.zoomedHd.onerror = function() {
          clearInterval($), console.warn("Unable to reach the zoom image target " + _.zoomedHd.src), _.zoomedHd = null, D();
        };
        var $ = setInterval(function() {
          _.zoomedHd.complete && (clearInterval($), _.zoomedHd.classList.add("medium-zoom-image--opened"), _.zoomedHd.addEventListener("click", p), document.body.appendChild(_.zoomedHd), D());
        }, 10);
      } else if (_.original.hasAttribute("srcset")) {
        _.zoomedHd = _.zoomed.cloneNode(), _.zoomedHd.removeAttribute("sizes"), _.zoomedHd.removeAttribute("loading");
        var F = _.zoomedHd.addEventListener("load", function() {
          _.zoomedHd.removeEventListener("load", F), _.zoomedHd.classList.add("medium-zoom-image--opened"), _.zoomedHd.addEventListener("click", p), document.body.appendChild(_.zoomedHd), D();
        });
      } else
        D();
    });
  }, p = function() {
    return new r(function(P) {
      if (w || !_.original) {
        P(A);
        return;
      }
      var L = function D() {
        _.original.classList.remove("medium-zoom-image--hidden"), document.body.removeChild(_.zoomed), _.zoomedHd && document.body.removeChild(_.zoomedHd), document.body.removeChild(C), _.zoomed.classList.remove("medium-zoom-image--opened"), _.template && document.body.removeChild(_.template), w = !1, _.zoomed.removeEventListener("transitionend", D), _.original.dispatchEvent(Hd("medium-zoom:closed", {
          detail: { zoom: A }
        })), _.original = null, _.zoomed = null, _.zoomedHd = null, _.template = null, P(A);
      };
      w = !0, document.body.classList.remove("medium-zoom--opened"), _.zoomed.style.transform = "", _.zoomedHd && (_.zoomedHd.style.transform = ""), _.template && (_.template.style.transition = "opacity 150ms", _.template.style.opacity = 0), _.original.dispatchEvent(Hd("medium-zoom:close", {
        detail: { zoom: A }
      })), _.zoomed.addEventListener("transitionend", L);
    });
  }, g = function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, L = P.target;
    return _.original ? p() : d({ target: L });
  }, v = function() {
    return S;
  }, m = function() {
    return b;
  }, y = function() {
    return _.original;
  }, b = [], O = [], w = !1, x = 0, S = t, _ = {
    original: null,
    zoomed: null,
    zoomedHd: null,
    template: null
    // If the selector is omitted, it's replaced by the options
  };
  Object.prototype.toString.call(e) === "[object Object]" ? S = e : (e || typeof e == "string") && u(e), S = jh({
    margin: 0,
    background: "#fff",
    scrollOffset: 40,
    container: null,
    template: null
  }, S);
  var C = S3e(S.background);
  document.addEventListener("click", i), document.addEventListener("keyup", a), document.addEventListener("scroll", o), window.addEventListener("resize", p);
  var A = {
    open: d,
    close: p,
    toggle: g,
    update: s,
    clone: l,
    attach: u,
    detach: c,
    on: h,
    off: f,
    getOptions: v,
    getImages: m,
    getZoomedImage: y
  };
  return A;
};
function A3e(n, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(!n || typeof document > "u")) {
    var r = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style");
    i.type = "text/css", t === "top" && r.firstChild ? r.insertBefore(i, r.firstChild) : r.appendChild(i), i.styleSheet ? i.styleSheet.cssText = n : i.appendChild(document.createTextNode(n));
  }
}
var T3e = ".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";
A3e(T3e);
const k3e = C3e;
var P3e = function() {
  var n = document.getSelection();
  if (!n.rangeCount)
    return function() {
    };
  for (var e = document.activeElement, t = [], r = 0; r < n.rangeCount; r++)
    t.push(n.getRangeAt(r));
  switch (e.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      e.blur();
      break;
    default:
      e = null;
      break;
  }
  return n.removeAllRanges(), function() {
    n.type === "Caret" && n.removeAllRanges(), n.rangeCount || t.forEach(function(i) {
      n.addRange(i);
    }), e && e.focus();
  };
}, E3e = P3e, y4 = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, M3e = "Copy to clipboard: #{key}, Enter";
function D3e(n) {
  var e = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return n.replace(/#{\s*key\s*}/g, e);
}
function L3e(n, e) {
  var t, r, i, o, a, s, l = !1;
  e || (e = {}), t = e.debug || !1;
  try {
    i = E3e(), o = document.createRange(), a = document.getSelection(), s = document.createElement("span"), s.textContent = n, s.ariaHidden = "true", s.style.all = "unset", s.style.position = "fixed", s.style.top = 0, s.style.clip = "rect(0, 0, 0, 0)", s.style.whiteSpace = "pre", s.style.webkitUserSelect = "text", s.style.MozUserSelect = "text", s.style.msUserSelect = "text", s.style.userSelect = "text", s.addEventListener("copy", function(c) {
      if (c.stopPropagation(), e.format)
        if (c.preventDefault(), typeof c.clipboardData > "u") {
          t && console.warn("unable to use e.clipboardData"), t && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var h = y4[e.format] || y4.default;
          window.clipboardData.setData(h, n);
        } else
          c.clipboardData.clearData(), c.clipboardData.setData(e.format, n);
      e.onCopy && (c.preventDefault(), e.onCopy(c.clipboardData));
    }), document.body.appendChild(s), o.selectNodeContents(s), a.addRange(o);
    var u = document.execCommand("copy");
    if (!u)
      throw new Error("copy command was unsuccessful");
    l = !0;
  } catch (c) {
    t && console.error("unable to copy using execCommand: ", c), t && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(e.format || "text", n), e.onCopy && e.onCopy(window.clipboardData), l = !0;
    } catch (h) {
      t && console.error("unable to copy using clipboardData: ", h), t && console.error("falling back to prompt"), r = D3e("message" in e ? e.message : M3e), window.prompt(r, n);
    }
  } finally {
    a && (typeof a.removeRange == "function" ? a.removeRange(o) : a.removeAllRanges()), s && document.body.removeChild(s), i();
  }
  return l;
}
var I3e = L3e;
const R3e = /* @__PURE__ */ wb(I3e);
var sn = {};
const N3e = "Á", $3e = "á", B3e = "Ă", V3e = "ă", z3e = "∾", F3e = "∿", Q3e = "∾̳", Z3e = "Â", W3e = "â", G3e = "´", j3e = "А", H3e = "а", q3e = "Æ", Y3e = "æ", X3e = "⁡", U3e = "𝔄", K3e = "𝔞", J3e = "À", eBe = "à", tBe = "ℵ", nBe = "ℵ", rBe = "Α", iBe = "α", oBe = "Ā", aBe = "ā", sBe = "⨿", lBe = "&", uBe = "&", cBe = "⩕", hBe = "⩓", fBe = "∧", dBe = "⩜", pBe = "⩘", gBe = "⩚", vBe = "∠", mBe = "⦤", yBe = "∠", bBe = "⦨", OBe = "⦩", wBe = "⦪", xBe = "⦫", SBe = "⦬", _Be = "⦭", CBe = "⦮", ABe = "⦯", TBe = "∡", kBe = "∟", PBe = "⊾", EBe = "⦝", MBe = "∢", DBe = "Å", LBe = "⍼", IBe = "Ą", RBe = "ą", NBe = "𝔸", $Be = "𝕒", BBe = "⩯", VBe = "≈", zBe = "⩰", FBe = "≊", QBe = "≋", ZBe = "'", WBe = "⁡", GBe = "≈", jBe = "≊", HBe = "Å", qBe = "å", YBe = "𝒜", XBe = "𝒶", UBe = "≔", KBe = "*", JBe = "≈", e5e = "≍", t5e = "Ã", n5e = "ã", r5e = "Ä", i5e = "ä", o5e = "∳", a5e = "⨑", s5e = "≌", l5e = "϶", u5e = "‵", c5e = "∽", h5e = "⋍", f5e = "∖", d5e = "⫧", p5e = "⊽", g5e = "⌅", v5e = "⌆", m5e = "⌅", y5e = "⎵", b5e = "⎶", O5e = "≌", w5e = "Б", x5e = "б", S5e = "„", _5e = "∵", C5e = "∵", A5e = "∵", T5e = "⦰", k5e = "϶", P5e = "ℬ", E5e = "ℬ", M5e = "Β", D5e = "β", L5e = "ℶ", I5e = "≬", R5e = "𝔅", N5e = "𝔟", $5e = "⋂", B5e = "◯", V5e = "⋃", z5e = "⨀", F5e = "⨁", Q5e = "⨂", Z5e = "⨆", W5e = "★", G5e = "▽", j5e = "△", H5e = "⨄", q5e = "⋁", Y5e = "⋀", X5e = "⤍", U5e = "⧫", K5e = "▪", J5e = "▴", eVe = "▾", tVe = "◂", nVe = "▸", rVe = "␣", iVe = "▒", oVe = "░", aVe = "▓", sVe = "█", lVe = "=⃥", uVe = "≡⃥", cVe = "⫭", hVe = "⌐", fVe = "𝔹", dVe = "𝕓", pVe = "⊥", gVe = "⊥", vVe = "⋈", mVe = "⧉", yVe = "┐", bVe = "╕", OVe = "╖", wVe = "╗", xVe = "┌", SVe = "╒", _Ve = "╓", CVe = "╔", AVe = "─", TVe = "═", kVe = "┬", PVe = "╤", EVe = "╥", MVe = "╦", DVe = "┴", LVe = "╧", IVe = "╨", RVe = "╩", NVe = "⊟", $Ve = "⊞", BVe = "⊠", VVe = "┘", zVe = "╛", FVe = "╜", QVe = "╝", ZVe = "└", WVe = "╘", GVe = "╙", jVe = "╚", HVe = "│", qVe = "║", YVe = "┼", XVe = "╪", UVe = "╫", KVe = "╬", JVe = "┤", e4e = "╡", t4e = "╢", n4e = "╣", r4e = "├", i4e = "╞", o4e = "╟", a4e = "╠", s4e = "‵", l4e = "˘", u4e = "˘", c4e = "¦", h4e = "𝒷", f4e = "ℬ", d4e = "⁏", p4e = "∽", g4e = "⋍", v4e = "⧅", m4e = "\\", y4e = "⟈", b4e = "•", O4e = "•", w4e = "≎", x4e = "⪮", S4e = "≏", _4e = "≎", C4e = "≏", A4e = "Ć", T4e = "ć", k4e = "⩄", P4e = "⩉", E4e = "⩋", M4e = "∩", D4e = "⋒", L4e = "⩇", I4e = "⩀", R4e = "ⅅ", N4e = "∩︀", $4e = "⁁", B4e = "ˇ", V4e = "ℭ", z4e = "⩍", F4e = "Č", Q4e = "č", Z4e = "Ç", W4e = "ç", G4e = "Ĉ", j4e = "ĉ", H4e = "∰", q4e = "⩌", Y4e = "⩐", X4e = "Ċ", U4e = "ċ", K4e = "¸", J4e = "¸", eze = "⦲", tze = "¢", nze = "·", rze = "·", ize = "𝔠", oze = "ℭ", aze = "Ч", sze = "ч", lze = "✓", uze = "✓", cze = "Χ", hze = "χ", fze = "ˆ", dze = "≗", pze = "↺", gze = "↻", vze = "⊛", mze = "⊚", yze = "⊝", bze = "⊙", Oze = "®", wze = "Ⓢ", xze = "⊖", Sze = "⊕", _ze = "⊗", Cze = "○", Aze = "⧃", Tze = "≗", kze = "⨐", Pze = "⫯", Eze = "⧂", Mze = "∲", Dze = "”", Lze = "’", Ize = "♣", Rze = "♣", Nze = ":", $ze = "∷", Bze = "⩴", Vze = "≔", zze = "≔", Fze = ",", Qze = "@", Zze = "∁", Wze = "∘", Gze = "∁", jze = "ℂ", Hze = "≅", qze = "⩭", Yze = "≡", Xze = "∮", Uze = "∯", Kze = "∮", Jze = "𝕔", eFe = "ℂ", tFe = "∐", nFe = "∐", rFe = "©", iFe = "©", oFe = "℗", aFe = "∳", sFe = "↵", lFe = "✗", uFe = "⨯", cFe = "𝒞", hFe = "𝒸", fFe = "⫏", dFe = "⫑", pFe = "⫐", gFe = "⫒", vFe = "⋯", mFe = "⤸", yFe = "⤵", bFe = "⋞", OFe = "⋟", wFe = "↶", xFe = "⤽", SFe = "⩈", _Fe = "⩆", CFe = "≍", AFe = "∪", TFe = "⋓", kFe = "⩊", PFe = "⊍", EFe = "⩅", MFe = "∪︀", DFe = "↷", LFe = "⤼", IFe = "⋞", RFe = "⋟", NFe = "⋎", $Fe = "⋏", BFe = "¤", VFe = "↶", zFe = "↷", FFe = "⋎", QFe = "⋏", ZFe = "∲", WFe = "∱", GFe = "⌭", jFe = "†", HFe = "‡", qFe = "ℸ", YFe = "↓", XFe = "↡", UFe = "⇓", KFe = "‐", JFe = "⫤", e6e = "⊣", t6e = "⤏", n6e = "˝", r6e = "Ď", i6e = "ď", o6e = "Д", a6e = "д", s6e = "‡", l6e = "⇊", u6e = "ⅅ", c6e = "ⅆ", h6e = "⤑", f6e = "⩷", d6e = "°", p6e = "∇", g6e = "Δ", v6e = "δ", m6e = "⦱", y6e = "⥿", b6e = "𝔇", O6e = "𝔡", w6e = "⥥", x6e = "⇃", S6e = "⇂", _6e = "´", C6e = "˙", A6e = "˝", T6e = "`", k6e = "˜", P6e = "⋄", E6e = "⋄", M6e = "⋄", D6e = "♦", L6e = "♦", I6e = "¨", R6e = "ⅆ", N6e = "ϝ", $6e = "⋲", B6e = "÷", V6e = "÷", z6e = "⋇", F6e = "⋇", Q6e = "Ђ", Z6e = "ђ", W6e = "⌞", G6e = "⌍", j6e = "$", H6e = "𝔻", q6e = "𝕕", Y6e = "¨", X6e = "˙", U6e = "⃜", K6e = "≐", J6e = "≑", e8e = "≐", t8e = "∸", n8e = "∔", r8e = "⊡", i8e = "⌆", o8e = "∯", a8e = "¨", s8e = "⇓", l8e = "⇐", u8e = "⇔", c8e = "⫤", h8e = "⟸", f8e = "⟺", d8e = "⟹", p8e = "⇒", g8e = "⊨", v8e = "⇑", m8e = "⇕", y8e = "∥", b8e = "⤓", O8e = "↓", w8e = "↓", x8e = "⇓", S8e = "⇵", _8e = "̑", C8e = "⇊", A8e = "⇃", T8e = "⇂", k8e = "⥐", P8e = "⥞", E8e = "⥖", M8e = "↽", D8e = "⥟", L8e = "⥗", I8e = "⇁", R8e = "↧", N8e = "⊤", $8e = "⤐", B8e = "⌟", V8e = "⌌", z8e = "𝒟", F8e = "𝒹", Q8e = "Ѕ", Z8e = "ѕ", W8e = "⧶", G8e = "Đ", j8e = "đ", H8e = "⋱", q8e = "▿", Y8e = "▾", X8e = "⇵", U8e = "⥯", K8e = "⦦", J8e = "Џ", eQe = "џ", tQe = "⟿", nQe = "É", rQe = "é", iQe = "⩮", oQe = "Ě", aQe = "ě", sQe = "Ê", lQe = "ê", uQe = "≖", cQe = "≕", hQe = "Э", fQe = "э", dQe = "⩷", pQe = "Ė", gQe = "ė", vQe = "≑", mQe = "ⅇ", yQe = "≒", bQe = "𝔈", OQe = "𝔢", wQe = "⪚", xQe = "È", SQe = "è", _Qe = "⪖", CQe = "⪘", AQe = "⪙", TQe = "∈", kQe = "⏧", PQe = "ℓ", EQe = "⪕", MQe = "⪗", DQe = "Ē", LQe = "ē", IQe = "∅", RQe = "∅", NQe = "◻", $Qe = "∅", BQe = "▫", VQe = " ", zQe = " ", FQe = " ", QQe = "Ŋ", ZQe = "ŋ", WQe = " ", GQe = "Ę", jQe = "ę", HQe = "𝔼", qQe = "𝕖", YQe = "⋕", XQe = "⧣", UQe = "⩱", KQe = "ε", JQe = "Ε", eZe = "ε", tZe = "ϵ", nZe = "≖", rZe = "≕", iZe = "≂", oZe = "⪖", aZe = "⪕", sZe = "⩵", lZe = "=", uZe = "≂", cZe = "≟", hZe = "⇌", fZe = "≡", dZe = "⩸", pZe = "⧥", gZe = "⥱", vZe = "≓", mZe = "ℯ", yZe = "ℰ", bZe = "≐", OZe = "⩳", wZe = "≂", xZe = "Η", SZe = "η", _Ze = "Ð", CZe = "ð", AZe = "Ë", TZe = "ë", kZe = "€", PZe = "!", EZe = "∃", MZe = "∃", DZe = "ℰ", LZe = "ⅇ", IZe = "ⅇ", RZe = "≒", NZe = "Ф", $Ze = "ф", BZe = "♀", VZe = "ﬃ", zZe = "ﬀ", FZe = "ﬄ", QZe = "𝔉", ZZe = "𝔣", WZe = "ﬁ", GZe = "◼", jZe = "▪", HZe = "fj", qZe = "♭", YZe = "ﬂ", XZe = "▱", UZe = "ƒ", KZe = "𝔽", JZe = "𝕗", eWe = "∀", tWe = "∀", nWe = "⋔", rWe = "⫙", iWe = "ℱ", oWe = "⨍", aWe = "½", sWe = "⅓", lWe = "¼", uWe = "⅕", cWe = "⅙", hWe = "⅛", fWe = "⅔", dWe = "⅖", pWe = "¾", gWe = "⅗", vWe = "⅜", mWe = "⅘", yWe = "⅚", bWe = "⅝", OWe = "⅞", wWe = "⁄", xWe = "⌢", SWe = "𝒻", _We = "ℱ", CWe = "ǵ", AWe = "Γ", TWe = "γ", kWe = "Ϝ", PWe = "ϝ", EWe = "⪆", MWe = "Ğ", DWe = "ğ", LWe = "Ģ", IWe = "Ĝ", RWe = "ĝ", NWe = "Г", $We = "г", BWe = "Ġ", VWe = "ġ", zWe = "≥", FWe = "≧", QWe = "⪌", ZWe = "⋛", WWe = "≥", GWe = "≧", jWe = "⩾", HWe = "⪩", qWe = "⩾", YWe = "⪀", XWe = "⪂", UWe = "⪄", KWe = "⋛︀", JWe = "⪔", eGe = "𝔊", tGe = "𝔤", nGe = "≫", rGe = "⋙", iGe = "⋙", oGe = "ℷ", aGe = "Ѓ", sGe = "ѓ", lGe = "⪥", uGe = "≷", cGe = "⪒", hGe = "⪤", fGe = "⪊", dGe = "⪊", pGe = "⪈", gGe = "≩", vGe = "⪈", mGe = "≩", yGe = "⋧", bGe = "𝔾", OGe = "𝕘", wGe = "`", xGe = "≥", SGe = "⋛", _Ge = "≧", CGe = "⪢", AGe = "≷", TGe = "⩾", kGe = "≳", PGe = "𝒢", EGe = "ℊ", MGe = "≳", DGe = "⪎", LGe = "⪐", IGe = "⪧", RGe = "⩺", NGe = ">", $Ge = ">", BGe = "≫", VGe = "⋗", zGe = "⦕", FGe = "⩼", QGe = "⪆", ZGe = "⥸", WGe = "⋗", GGe = "⋛", jGe = "⪌", HGe = "≷", qGe = "≳", YGe = "≩︀", XGe = "≩︀", UGe = "ˇ", KGe = " ", JGe = "½", eje = "ℋ", tje = "Ъ", nje = "ъ", rje = "⥈", ije = "↔", oje = "⇔", aje = "↭", sje = "^", lje = "ℏ", uje = "Ĥ", cje = "ĥ", hje = "♥", fje = "♥", dje = "…", pje = "⊹", gje = "𝔥", vje = "ℌ", mje = "ℋ", yje = "⤥", bje = "⤦", Oje = "⇿", wje = "∻", xje = "↩", Sje = "↪", _je = "𝕙", Cje = "ℍ", Aje = "―", Tje = "─", kje = "𝒽", Pje = "ℋ", Eje = "ℏ", Mje = "Ħ", Dje = "ħ", Lje = "≎", Ije = "≏", Rje = "⁃", Nje = "‐", $je = "Í", Bje = "í", Vje = "⁣", zje = "Î", Fje = "î", Qje = "И", Zje = "и", Wje = "İ", Gje = "Е", jje = "е", Hje = "¡", qje = "⇔", Yje = "𝔦", Xje = "ℑ", Uje = "Ì", Kje = "ì", Jje = "ⅈ", e7e = "⨌", t7e = "∭", n7e = "⧜", r7e = "℩", i7e = "Ĳ", o7e = "ĳ", a7e = "Ī", s7e = "ī", l7e = "ℑ", u7e = "ⅈ", c7e = "ℐ", h7e = "ℑ", f7e = "ı", d7e = "ℑ", p7e = "⊷", g7e = "Ƶ", v7e = "⇒", m7e = "℅", y7e = "∞", b7e = "⧝", O7e = "ı", w7e = "⊺", x7e = "∫", S7e = "∬", _7e = "ℤ", C7e = "∫", A7e = "⊺", T7e = "⋂", k7e = "⨗", P7e = "⨼", E7e = "⁣", M7e = "⁢", D7e = "Ё", L7e = "ё", I7e = "Į", R7e = "į", N7e = "𝕀", $7e = "𝕚", B7e = "Ι", V7e = "ι", z7e = "⨼", F7e = "¿", Q7e = "𝒾", Z7e = "ℐ", W7e = "∈", G7e = "⋵", j7e = "⋹", H7e = "⋴", q7e = "⋳", Y7e = "∈", X7e = "⁢", U7e = "Ĩ", K7e = "ĩ", J7e = "І", eHe = "і", tHe = "Ï", nHe = "ï", rHe = "Ĵ", iHe = "ĵ", oHe = "Й", aHe = "й", sHe = "𝔍", lHe = "𝔧", uHe = "ȷ", cHe = "𝕁", hHe = "𝕛", fHe = "𝒥", dHe = "𝒿", pHe = "Ј", gHe = "ј", vHe = "Є", mHe = "є", yHe = "Κ", bHe = "κ", OHe = "ϰ", wHe = "Ķ", xHe = "ķ", SHe = "К", _He = "к", CHe = "𝔎", AHe = "𝔨", THe = "ĸ", kHe = "Х", PHe = "х", EHe = "Ќ", MHe = "ќ", DHe = "𝕂", LHe = "𝕜", IHe = "𝒦", RHe = "𝓀", NHe = "⇚", $He = "Ĺ", BHe = "ĺ", VHe = "⦴", zHe = "ℒ", FHe = "Λ", QHe = "λ", ZHe = "⟨", WHe = "⟪", GHe = "⦑", jHe = "⟨", HHe = "⪅", qHe = "ℒ", YHe = "«", XHe = "⇤", UHe = "⤟", KHe = "←", JHe = "↞", eqe = "⇐", tqe = "⤝", nqe = "↩", rqe = "↫", iqe = "⤹", oqe = "⥳", aqe = "↢", sqe = "⤙", lqe = "⤛", uqe = "⪫", cqe = "⪭", hqe = "⪭︀", fqe = "⤌", dqe = "⤎", pqe = "❲", gqe = "{", vqe = "[", mqe = "⦋", yqe = "⦏", bqe = "⦍", Oqe = "Ľ", wqe = "ľ", xqe = "Ļ", Sqe = "ļ", _qe = "⌈", Cqe = "{", Aqe = "Л", Tqe = "л", kqe = "⤶", Pqe = "“", Eqe = "„", Mqe = "⥧", Dqe = "⥋", Lqe = "↲", Iqe = "≤", Rqe = "≦", Nqe = "⟨", $qe = "⇤", Bqe = "←", Vqe = "←", zqe = "⇐", Fqe = "⇆", Qqe = "↢", Zqe = "⌈", Wqe = "⟦", Gqe = "⥡", jqe = "⥙", Hqe = "⇃", qqe = "⌊", Yqe = "↽", Xqe = "↼", Uqe = "⇇", Kqe = "↔", Jqe = "↔", e9e = "⇔", t9e = "⇆", n9e = "⇋", r9e = "↭", i9e = "⥎", o9e = "↤", a9e = "⊣", s9e = "⥚", l9e = "⋋", u9e = "⧏", c9e = "⊲", h9e = "⊴", f9e = "⥑", d9e = "⥠", p9e = "⥘", g9e = "↿", v9e = "⥒", m9e = "↼", y9e = "⪋", b9e = "⋚", O9e = "≤", w9e = "≦", x9e = "⩽", S9e = "⪨", _9e = "⩽", C9e = "⩿", A9e = "⪁", T9e = "⪃", k9e = "⋚︀", P9e = "⪓", E9e = "⪅", M9e = "⋖", D9e = "⋚", L9e = "⪋", I9e = "⋚", R9e = "≦", N9e = "≶", $9e = "≶", B9e = "⪡", V9e = "≲", z9e = "⩽", F9e = "≲", Q9e = "⥼", Z9e = "⌊", W9e = "𝔏", G9e = "𝔩", j9e = "≶", H9e = "⪑", q9e = "⥢", Y9e = "↽", X9e = "↼", U9e = "⥪", K9e = "▄", J9e = "Љ", eYe = "љ", tYe = "⇇", nYe = "≪", rYe = "⋘", iYe = "⌞", oYe = "⇚", aYe = "⥫", sYe = "◺", lYe = "Ŀ", uYe = "ŀ", cYe = "⎰", hYe = "⎰", fYe = "⪉", dYe = "⪉", pYe = "⪇", gYe = "≨", vYe = "⪇", mYe = "≨", yYe = "⋦", bYe = "⟬", OYe = "⇽", wYe = "⟦", xYe = "⟵", SYe = "⟵", _Ye = "⟸", CYe = "⟷", AYe = "⟷", TYe = "⟺", kYe = "⟼", PYe = "⟶", EYe = "⟶", MYe = "⟹", DYe = "↫", LYe = "↬", IYe = "⦅", RYe = "𝕃", NYe = "𝕝", $Ye = "⨭", BYe = "⨴", VYe = "∗", zYe = "_", FYe = "↙", QYe = "↘", ZYe = "◊", WYe = "◊", GYe = "⧫", jYe = "(", HYe = "⦓", qYe = "⇆", YYe = "⌟", XYe = "⇋", UYe = "⥭", KYe = "‎", JYe = "⊿", eXe = "‹", tXe = "𝓁", nXe = "ℒ", rXe = "↰", iXe = "↰", oXe = "≲", aXe = "⪍", sXe = "⪏", lXe = "[", uXe = "‘", cXe = "‚", hXe = "Ł", fXe = "ł", dXe = "⪦", pXe = "⩹", gXe = "<", vXe = "<", mXe = "≪", yXe = "⋖", bXe = "⋋", OXe = "⋉", wXe = "⥶", xXe = "⩻", SXe = "◃", _Xe = "⊴", CXe = "◂", AXe = "⦖", TXe = "⥊", kXe = "⥦", PXe = "≨︀", EXe = "≨︀", MXe = "¯", DXe = "♂", LXe = "✠", IXe = "✠", RXe = "↦", NXe = "↦", $Xe = "↧", BXe = "↤", VXe = "↥", zXe = "▮", FXe = "⨩", QXe = "М", ZXe = "м", WXe = "—", GXe = "∺", jXe = "∡", HXe = " ", qXe = "ℳ", YXe = "𝔐", XXe = "𝔪", UXe = "℧", KXe = "µ", JXe = "*", eUe = "⫰", tUe = "∣", nUe = "·", rUe = "⊟", iUe = "−", oUe = "∸", aUe = "⨪", sUe = "∓", lUe = "⫛", uUe = "…", cUe = "∓", hUe = "⊧", fUe = "𝕄", dUe = "𝕞", pUe = "∓", gUe = "𝓂", vUe = "ℳ", mUe = "∾", yUe = "Μ", bUe = "μ", OUe = "⊸", wUe = "⊸", xUe = "∇", SUe = "Ń", _Ue = "ń", CUe = "∠⃒", AUe = "≉", TUe = "⩰̸", kUe = "≋̸", PUe = "ŉ", EUe = "≉", MUe = "♮", DUe = "ℕ", LUe = "♮", IUe = " ", RUe = "≎̸", NUe = "≏̸", $Ue = "⩃", BUe = "Ň", VUe = "ň", zUe = "Ņ", FUe = "ņ", QUe = "≇", ZUe = "⩭̸", WUe = "⩂", GUe = "Н", jUe = "н", HUe = "–", qUe = "⤤", YUe = "↗", XUe = "⇗", UUe = "↗", KUe = "≠", JUe = "≐̸", eKe = "​", tKe = "​", nKe = "​", rKe = "​", iKe = "≢", oKe = "⤨", aKe = "≂̸", sKe = "≫", lKe = "≪", uKe = `
`, cKe = "∄", hKe = "∄", fKe = "𝔑", dKe = "𝔫", pKe = "≧̸", gKe = "≱", vKe = "≱", mKe = "≧̸", yKe = "⩾̸", bKe = "⩾̸", OKe = "⋙̸", wKe = "≵", xKe = "≫⃒", SKe = "≯", _Ke = "≯", CKe = "≫̸", AKe = "↮", TKe = "⇎", kKe = "⫲", PKe = "∋", EKe = "⋼", MKe = "⋺", DKe = "∋", LKe = "Њ", IKe = "њ", RKe = "↚", NKe = "⇍", $Ke = "‥", BKe = "≦̸", VKe = "≰", zKe = "↚", FKe = "⇍", QKe = "↮", ZKe = "⇎", WKe = "≰", GKe = "≦̸", jKe = "⩽̸", HKe = "⩽̸", qKe = "≮", YKe = "⋘̸", XKe = "≴", UKe = "≪⃒", KKe = "≮", JKe = "⋪", eJe = "⋬", tJe = "≪̸", nJe = "∤", rJe = "⁠", iJe = " ", oJe = "𝕟", aJe = "ℕ", sJe = "⫬", lJe = "¬", uJe = "≢", cJe = "≭", hJe = "∦", fJe = "∉", dJe = "≠", pJe = "≂̸", gJe = "∄", vJe = "≯", mJe = "≱", yJe = "≧̸", bJe = "≫̸", OJe = "≹", wJe = "⩾̸", xJe = "≵", SJe = "≎̸", _Je = "≏̸", CJe = "∉", AJe = "⋵̸", TJe = "⋹̸", kJe = "∉", PJe = "⋷", EJe = "⋶", MJe = "⧏̸", DJe = "⋪", LJe = "⋬", IJe = "≮", RJe = "≰", NJe = "≸", $Je = "≪̸", BJe = "⩽̸", VJe = "≴", zJe = "⪢̸", FJe = "⪡̸", QJe = "∌", ZJe = "∌", WJe = "⋾", GJe = "⋽", jJe = "⊀", HJe = "⪯̸", qJe = "⋠", YJe = "∌", XJe = "⧐̸", UJe = "⋫", KJe = "⋭", JJe = "⊏̸", eet = "⋢", tet = "⊐̸", net = "⋣", ret = "⊂⃒", iet = "⊈", oet = "⊁", aet = "⪰̸", set = "⋡", uet = "≿̸", cet = "⊃⃒", het = "⊉", fet = "≁", det = "≄", pet = "≇", get = "≉", vet = "∤", met = "∦", yet = "∦", bet = "⫽⃥", Oet = "∂̸", wet = "⨔", xet = "⊀", _et = "⋠", Cet = "⊀", Aet = "⪯̸", Tet = "⪯̸", ket = "⤳̸", Pet = "↛", Eet = "⇏", Met = "↝̸", Det = "↛", Let = "⇏", Iet = "⋫", Ret = "⋭", Net = "⊁", $et = "⋡", Bet = "⪰̸", Vet = "𝒩", zet = "𝓃", Fet = "∤", Qet = "∦", Zet = "≁", Wet = "≄", Get = "≄", jet = "∤", Het = "∦", qet = "⋢", Yet = "⋣", Xet = "⊄", Uet = "⫅̸", Ket = "⊈", Jet = "⊂⃒", ett = "⊈", ttt = "⫅̸", ntt = "⊁", rtt = "⪰̸", itt = "⊅", ott = "⫆̸", att = "⊉", stt = "⊃⃒", ltt = "⊉", utt = "⫆̸", ctt = "≹", htt = "Ñ", ftt = "ñ", dtt = "≸", ptt = "⋪", gtt = "⋬", vtt = "⋫", mtt = "⋭", ytt = "Ν", btt = "ν", Ott = "#", wtt = "№", xtt = " ", Stt = "≍⃒", _tt = "⊬", Ctt = "⊭", Att = "⊮", Ttt = "⊯", ktt = "≥⃒", Ptt = ">⃒", Ett = "⤄", Mtt = "⧞", Dtt = "⤂", Ltt = "≤⃒", Itt = "<⃒", Rtt = "⊴⃒", Ntt = "⤃", $tt = "⊵⃒", Btt = "∼⃒", Vtt = "⤣", ztt = "↖", Ftt = "⇖", Qtt = "↖", Ztt = "⤧", Wtt = "Ó", Gtt = "ó", jtt = "⊛", Htt = "Ô", qtt = "ô", Ytt = "⊚", Xtt = "О", Utt = "о", Ktt = "⊝", Jtt = "Ő", ent = "ő", tnt = "⨸", nnt = "⊙", rnt = "⦼", int = "Œ", ont = "œ", ant = "⦿", snt = "𝔒", lnt = "𝔬", unt = "˛", cnt = "Ò", hnt = "ò", fnt = "⧁", dnt = "⦵", pnt = "Ω", gnt = "∮", vnt = "↺", mnt = "⦾", ynt = "⦻", bnt = "‾", Ont = "⧀", wnt = "Ō", xnt = "ō", Snt = "Ω", _nt = "ω", Cnt = "Ο", Ant = "ο", Tnt = "⦶", knt = "⊖", Pnt = "𝕆", Ent = "𝕠", Mnt = "⦷", Dnt = "“", Lnt = "‘", Int = "⦹", Rnt = "⊕", Nnt = "↻", $nt = "⩔", Bnt = "∨", Vnt = "⩝", znt = "ℴ", Fnt = "ℴ", Qnt = "ª", Znt = "º", Wnt = "⊶", Gnt = "⩖", jnt = "⩗", Hnt = "⩛", qnt = "Ⓢ", Ynt = "𝒪", Xnt = "ℴ", Unt = "Ø", Knt = "ø", Jnt = "⊘", ert = "Õ", trt = "õ", nrt = "⨶", rrt = "⨷", irt = "⊗", ort = "Ö", art = "ö", srt = "⌽", lrt = "‾", urt = "⏞", crt = "⎴", hrt = "⏜", frt = "¶", drt = "∥", prt = "∥", grt = "⫳", vrt = "⫽", mrt = "∂", yrt = "∂", brt = "П", Ort = "п", wrt = "%", xrt = ".", Srt = "‰", _rt = "⊥", Crt = "‱", Art = "𝔓", Trt = "𝔭", krt = "Φ", Prt = "φ", Ert = "ϕ", Mrt = "ℳ", Drt = "☎", Lrt = "Π", Irt = "π", Rrt = "⋔", Nrt = "ϖ", $rt = "ℏ", Brt = "ℎ", Vrt = "ℏ", zrt = "⨣", Frt = "⊞", Qrt = "⨢", Zrt = "+", Wrt = "∔", Grt = "⨥", jrt = "⩲", Hrt = "±", qrt = "±", Yrt = "⨦", Xrt = "⨧", Urt = "±", Krt = "ℌ", Jrt = "⨕", eit = "𝕡", tit = "ℙ", nit = "£", rit = "⪷", iit = "⪻", oit = "≺", ait = "≼", sit = "⪷", lit = "≺", uit = "≼", cit = "≺", hit = "⪯", fit = "≼", dit = "≾", pit = "⪯", git = "⪹", vit = "⪵", mit = "⋨", yit = "⪯", bit = "⪳", Oit = "≾", wit = "′", xit = "″", Sit = "ℙ", _it = "⪹", Cit = "⪵", Ait = "⋨", Tit = "∏", kit = "∏", Pit = "⌮", Eit = "⌒", Mit = "⌓", Dit = "∝", Lit = "∝", Iit = "∷", Rit = "∝", Nit = "≾", $it = "⊰", Bit = "𝒫", Vit = "𝓅", zit = "Ψ", Fit = "ψ", Qit = " ", Zit = "𝔔", Wit = "𝔮", Git = "⨌", jit = "𝕢", Hit = "ℚ", qit = "⁗", Yit = "𝒬", Xit = "𝓆", Uit = "ℍ", Kit = "⨖", Jit = "?", eot = "≟", tot = '"', not = '"', rot = "⇛", iot = "∽̱", oot = "Ŕ", aot = "ŕ", sot = "√", lot = "⦳", uot = "⟩", cot = "⟫", hot = "⦒", fot = "⦥", dot = "⟩", pot = "»", got = "⥵", vot = "⇥", mot = "⤠", yot = "⤳", bot = "→", Oot = "↠", wot = "⇒", xot = "⤞", Sot = "↪", _ot = "↬", Cot = "⥅", Aot = "⥴", Tot = "⤖", kot = "↣", Pot = "↝", Eot = "⤚", Mot = "⤜", Dot = "∶", Lot = "ℚ", Iot = "⤍", Rot = "⤏", Not = "⤐", $ot = "❳", Bot = "}", Vot = "]", zot = "⦌", Fot = "⦎", Qot = "⦐", Zot = "Ř", Wot = "ř", Got = "Ŗ", jot = "ŗ", Hot = "⌉", qot = "}", Yot = "Р", Xot = "р", Uot = "⤷", Kot = "⥩", Jot = "”", eat = "”", tat = "↳", nat = "ℜ", rat = "ℛ", iat = "ℜ", oat = "ℝ", aat = "ℜ", sat = "▭", lat = "®", uat = "®", cat = "∋", hat = "⇋", fat = "⥯", dat = "⥽", pat = "⌋", gat = "𝔯", vat = "ℜ", mat = "⥤", yat = "⇁", bat = "⇀", Oat = "⥬", wat = "Ρ", xat = "ρ", Sat = "ϱ", _at = "⟩", Cat = "⇥", Aat = "→", Tat = "→", kat = "⇒", Pat = "⇄", Eat = "↣", Mat = "⌉", Dat = "⟧", Lat = "⥝", Iat = "⥕", Rat = "⇂", Nat = "⌋", $at = "⇁", Bat = "⇀", Vat = "⇄", zat = "⇌", Fat = "⇉", Qat = "↝", Zat = "↦", Wat = "⊢", Gat = "⥛", jat = "⋌", Hat = "⧐", qat = "⊳", Yat = "⊵", Xat = "⥏", Uat = "⥜", Kat = "⥔", Jat = "↾", est = "⥓", tst = "⇀", nst = "˚", rst = "≓", ist = "⇄", ost = "⇌", ast = "‏", sst = "⎱", lst = "⎱", ust = "⫮", cst = "⟭", hst = "⇾", fst = "⟧", dst = "⦆", pst = "𝕣", gst = "ℝ", vst = "⨮", mst = "⨵", yst = "⥰", bst = ")", Ost = "⦔", wst = "⨒", xst = "⇉", Sst = "⇛", _st = "›", Cst = "𝓇", Ast = "ℛ", Tst = "↱", kst = "↱", Pst = "]", Est = "’", Mst = "’", Dst = "⋌", Lst = "⋊", Ist = "▹", Rst = "⊵", Nst = "▸", $st = "⧎", Bst = "⧴", Vst = "⥨", zst = "℞", Fst = "Ś", Qst = "ś", Zst = "‚", Wst = "⪸", Gst = "Š", jst = "š", Hst = "⪼", qst = "≻", Yst = "≽", Xst = "⪰", Ust = "⪴", Kst = "Ş", Jst = "ş", elt = "Ŝ", tlt = "ŝ", nlt = "⪺", rlt = "⪶", ilt = "⋩", olt = "⨓", alt = "≿", slt = "С", llt = "с", ult = "⊡", clt = "⋅", hlt = "⩦", flt = "⤥", dlt = "↘", plt = "⇘", glt = "↘", vlt = "§", mlt = ";", ylt = "⤩", blt = "∖", Olt = "∖", wlt = "✶", xlt = "𝔖", Slt = "𝔰", _lt = "⌢", Clt = "♯", Alt = "Щ", Tlt = "щ", klt = "Ш", Plt = "ш", Elt = "↓", Mlt = "←", Dlt = "∣", Llt = "∥", Ilt = "→", Rlt = "↑", Nlt = "­", $lt = "Σ", Blt = "σ", Vlt = "ς", zlt = "ς", Flt = "∼", Qlt = "⩪", Zlt = "≃", Wlt = "≃", Glt = "⪞", jlt = "⪠", Hlt = "⪝", qlt = "⪟", Ylt = "≆", Xlt = "⨤", Ult = "⥲", Klt = "←", Jlt = "∘", eut = "∖", tut = "⨳", nut = "⧤", rut = "∣", iut = "⌣", out = "⪪", aut = "⪬", sut = "⪬︀", lut = "Ь", uut = "ь", cut = "⌿", hut = "⧄", fut = "/", dut = "𝕊", put = "𝕤", gut = "♠", vut = "♠", mut = "∥", yut = "⊓", but = "⊓︀", Out = "⊔", wut = "⊔︀", xut = "√", Sut = "⊏", _ut = "⊑", Cut = "⊏", Aut = "⊑", Tut = "⊐", kut = "⊒", Put = "⊐", Eut = "⊒", Mut = "□", Dut = "□", Lut = "⊓", Iut = "⊏", Rut = "⊑", Nut = "⊐", $ut = "⊒", But = "⊔", Vut = "▪", zut = "□", Fut = "▪", Qut = "→", Zut = "𝒮", Wut = "𝓈", Gut = "∖", jut = "⌣", Hut = "⋆", qut = "⋆", Yut = "☆", Xut = "★", Uut = "ϵ", Kut = "ϕ", Jut = "¯", ect = "⊂", tct = "⋐", nct = "⪽", rct = "⫅", ict = "⊆", oct = "⫃", act = "⫁", sct = "⫋", lct = "⊊", uct = "⪿", cct = "⥹", hct = "⊂", fct = "⋐", dct = "⊆", pct = "⫅", gct = "⊆", vct = "⊊", mct = "⫋", yct = "⫇", bct = "⫕", Oct = "⫓", wct = "⪸", xct = "≻", Sct = "≽", _ct = "≻", Cct = "⪰", Act = "≽", Tct = "≿", kct = "⪰", Pct = "⪺", Ect = "⪶", Mct = "⋩", Dct = "≿", Lct = "∋", Ict = "∑", Rct = "∑", Nct = "♪", $ct = "¹", Bct = "²", Vct = "³", zct = "⊃", Fct = "⋑", Qct = "⪾", Zct = "⫘", Wct = "⫆", Gct = "⊇", jct = "⫄", Hct = "⊃", qct = "⊇", Yct = "⟉", Xct = "⫗", Uct = "⥻", Kct = "⫂", Jct = "⫌", eht = "⊋", tht = "⫀", nht = "⊃", rht = "⋑", iht = "⊇", oht = "⫆", aht = "⊋", sht = "⫌", lht = "⫈", uht = "⫔", cht = "⫖", hht = "⤦", fht = "↙", dht = "⇙", pht = "↙", ght = "⤪", vht = "ß", mht = "	", yht = "⌖", bht = "Τ", Oht = "τ", wht = "⎴", xht = "Ť", Sht = "ť", _ht = "Ţ", Cht = "ţ", Aht = "Т", Tht = "т", kht = "⃛", Pht = "⌕", Eht = "𝔗", Mht = "𝔱", Dht = "∴", Lht = "∴", Iht = "∴", Rht = "Θ", Nht = "θ", $ht = "ϑ", Bht = "ϑ", Vht = "≈", zht = "∼", Fht = "  ", Qht = " ", Zht = " ", Wht = "≈", Ght = "∼", jht = "Þ", Hht = "þ", qht = "˜", Yht = "∼", Xht = "≃", Uht = "≅", Kht = "≈", Jht = "⨱", eft = "⊠", tft = "×", nft = "⨰", rft = "∭", ift = "⤨", oft = "⌶", aft = "⫱", sft = "⊤", lft = "𝕋", uft = "𝕥", cft = "⫚", hft = "⤩", fft = "‴", dft = "™", pft = "™", gft = "▵", vft = "▿", mft = "◃", yft = "⊴", bft = "≜", Oft = "▹", wft = "⊵", xft = "◬", Sft = "≜", _ft = "⨺", Cft = "⃛", Aft = "⨹", Tft = "⧍", kft = "⨻", Pft = "⏢", Eft = "𝒯", Mft = "𝓉", Dft = "Ц", Lft = "ц", Ift = "Ћ", Rft = "ћ", Nft = "Ŧ", $ft = "ŧ", Bft = "≬", Vft = "↞", zft = "↠", Fft = "Ú", Qft = "ú", Zft = "↑", Wft = "↟", Gft = "⇑", jft = "⥉", Hft = "Ў", qft = "ў", Yft = "Ŭ", Xft = "ŭ", Uft = "Û", Kft = "û", Jft = "У", edt = "у", tdt = "⇅", ndt = "Ű", rdt = "ű", idt = "⥮", odt = "⥾", adt = "𝔘", sdt = "𝔲", ldt = "Ù", udt = "ù", cdt = "⥣", hdt = "↿", fdt = "↾", ddt = "▀", pdt = "⌜", gdt = "⌜", vdt = "⌏", mdt = "◸", ydt = "Ū", bdt = "ū", Odt = "¨", wdt = "_", xdt = "⏟", Sdt = "⎵", _dt = "⏝", Cdt = "⋃", Adt = "⊎", Tdt = "Ų", kdt = "ų", Pdt = "𝕌", Edt = "𝕦", Mdt = "⤒", Ddt = "↑", Ldt = "↑", Idt = "⇑", Rdt = "⇅", Ndt = "↕", $dt = "↕", Bdt = "⇕", Vdt = "⥮", zdt = "↿", Fdt = "↾", Qdt = "⊎", Zdt = "↖", Wdt = "↗", Gdt = "υ", jdt = "ϒ", Hdt = "ϒ", qdt = "Υ", Ydt = "υ", Xdt = "↥", Udt = "⊥", Kdt = "⇈", Jdt = "⌝", ept = "⌝", tpt = "⌎", npt = "Ů", rpt = "ů", ipt = "◹", opt = "𝒰", apt = "𝓊", spt = "⋰", lpt = "Ũ", upt = "ũ", cpt = "▵", hpt = "▴", fpt = "⇈", dpt = "Ü", ppt = "ü", gpt = "⦧", vpt = "⦜", mpt = "ϵ", ypt = "ϰ", bpt = "∅", Opt = "ϕ", wpt = "ϖ", xpt = "∝", Spt = "↕", _pt = "⇕", Cpt = "ϱ", Apt = "ς", Tpt = "⊊︀", kpt = "⫋︀", Ppt = "⊋︀", Ept = "⫌︀", Mpt = "ϑ", Dpt = "⊲", Lpt = "⊳", Ipt = "⫨", Rpt = "⫫", Npt = "⫩", $pt = "В", Bpt = "в", Vpt = "⊢", zpt = "⊨", Fpt = "⊩", Qpt = "⊫", Zpt = "⫦", Wpt = "⊻", Gpt = "∨", jpt = "⋁", Hpt = "≚", qpt = "⋮", Ypt = "|", Xpt = "‖", Upt = "|", Kpt = "‖", Jpt = "∣", egt = "|", tgt = "❘", ngt = "≀", rgt = " ", igt = "𝔙", ogt = "𝔳", agt = "⊲", sgt = "⊂⃒", lgt = "⊃⃒", ugt = "𝕍", cgt = "𝕧", hgt = "∝", fgt = "⊳", dgt = "𝒱", pgt = "𝓋", ggt = "⫋︀", vgt = "⊊︀", mgt = "⫌︀", ygt = "⊋︀", bgt = "⊪", Ogt = "⦚", wgt = "Ŵ", xgt = "ŵ", Sgt = "⩟", _gt = "∧", Cgt = "⋀", Agt = "≙", Tgt = "℘", kgt = "𝔚", Pgt = "𝔴", Egt = "𝕎", Mgt = "𝕨", Dgt = "℘", Lgt = "≀", Igt = "≀", Rgt = "𝒲", Ngt = "𝓌", $gt = "⋂", Bgt = "◯", Vgt = "⋃", zgt = "▽", Fgt = "𝔛", Qgt = "𝔵", Zgt = "⟷", Wgt = "⟺", Ggt = "Ξ", jgt = "ξ", Hgt = "⟵", qgt = "⟸", Ygt = "⟼", Xgt = "⋻", Ugt = "⨀", Kgt = "𝕏", Jgt = "𝕩", evt = "⨁", tvt = "⨂", nvt = "⟶", rvt = "⟹", ivt = "𝒳", ovt = "𝓍", avt = "⨆", svt = "⨄", lvt = "△", uvt = "⋁", cvt = "⋀", hvt = "Ý", fvt = "ý", dvt = "Я", pvt = "я", gvt = "Ŷ", vvt = "ŷ", mvt = "Ы", yvt = "ы", bvt = "¥", Ovt = "𝔜", wvt = "𝔶", xvt = "Ї", Svt = "ї", _vt = "𝕐", Cvt = "𝕪", Avt = "𝒴", Tvt = "𝓎", kvt = "Ю", Pvt = "ю", Evt = "ÿ", Mvt = "Ÿ", Dvt = "Ź", Lvt = "ź", Ivt = "Ž", Rvt = "ž", Nvt = "З", $vt = "з", Bvt = "Ż", Vvt = "ż", zvt = "ℨ", Fvt = "​", Qvt = "Ζ", Zvt = "ζ", Wvt = "𝔷", Gvt = "ℨ", jvt = "Ж", Hvt = "ж", qvt = "⇝", Yvt = "𝕫", Xvt = "ℤ", Uvt = "𝒵", Kvt = "𝓏", Jvt = "‍", emt = "‌", tmt = {
  Aacute: N3e,
  aacute: $3e,
  Abreve: B3e,
  abreve: V3e,
  ac: z3e,
  acd: F3e,
  acE: Q3e,
  Acirc: Z3e,
  acirc: W3e,
  acute: G3e,
  Acy: j3e,
  acy: H3e,
  AElig: q3e,
  aelig: Y3e,
  af: X3e,
  Afr: U3e,
  afr: K3e,
  Agrave: J3e,
  agrave: eBe,
  alefsym: tBe,
  aleph: nBe,
  Alpha: rBe,
  alpha: iBe,
  Amacr: oBe,
  amacr: aBe,
  amalg: sBe,
  amp: lBe,
  AMP: uBe,
  andand: cBe,
  And: hBe,
  and: fBe,
  andd: dBe,
  andslope: pBe,
  andv: gBe,
  ang: vBe,
  ange: mBe,
  angle: yBe,
  angmsdaa: bBe,
  angmsdab: OBe,
  angmsdac: wBe,
  angmsdad: xBe,
  angmsdae: SBe,
  angmsdaf: _Be,
  angmsdag: CBe,
  angmsdah: ABe,
  angmsd: TBe,
  angrt: kBe,
  angrtvb: PBe,
  angrtvbd: EBe,
  angsph: MBe,
  angst: DBe,
  angzarr: LBe,
  Aogon: IBe,
  aogon: RBe,
  Aopf: NBe,
  aopf: $Be,
  apacir: BBe,
  ap: VBe,
  apE: zBe,
  ape: FBe,
  apid: QBe,
  apos: ZBe,
  ApplyFunction: WBe,
  approx: GBe,
  approxeq: jBe,
  Aring: HBe,
  aring: qBe,
  Ascr: YBe,
  ascr: XBe,
  Assign: UBe,
  ast: KBe,
  asymp: JBe,
  asympeq: e5e,
  Atilde: t5e,
  atilde: n5e,
  Auml: r5e,
  auml: i5e,
  awconint: o5e,
  awint: a5e,
  backcong: s5e,
  backepsilon: l5e,
  backprime: u5e,
  backsim: c5e,
  backsimeq: h5e,
  Backslash: f5e,
  Barv: d5e,
  barvee: p5e,
  barwed: g5e,
  Barwed: v5e,
  barwedge: m5e,
  bbrk: y5e,
  bbrktbrk: b5e,
  bcong: O5e,
  Bcy: w5e,
  bcy: x5e,
  bdquo: S5e,
  becaus: _5e,
  because: C5e,
  Because: A5e,
  bemptyv: T5e,
  bepsi: k5e,
  bernou: P5e,
  Bernoullis: E5e,
  Beta: M5e,
  beta: D5e,
  beth: L5e,
  between: I5e,
  Bfr: R5e,
  bfr: N5e,
  bigcap: $5e,
  bigcirc: B5e,
  bigcup: V5e,
  bigodot: z5e,
  bigoplus: F5e,
  bigotimes: Q5e,
  bigsqcup: Z5e,
  bigstar: W5e,
  bigtriangledown: G5e,
  bigtriangleup: j5e,
  biguplus: H5e,
  bigvee: q5e,
  bigwedge: Y5e,
  bkarow: X5e,
  blacklozenge: U5e,
  blacksquare: K5e,
  blacktriangle: J5e,
  blacktriangledown: eVe,
  blacktriangleleft: tVe,
  blacktriangleright: nVe,
  blank: rVe,
  blk12: iVe,
  blk14: oVe,
  blk34: aVe,
  block: sVe,
  bne: lVe,
  bnequiv: uVe,
  bNot: cVe,
  bnot: hVe,
  Bopf: fVe,
  bopf: dVe,
  bot: pVe,
  bottom: gVe,
  bowtie: vVe,
  boxbox: mVe,
  boxdl: yVe,
  boxdL: bVe,
  boxDl: OVe,
  boxDL: wVe,
  boxdr: xVe,
  boxdR: SVe,
  boxDr: _Ve,
  boxDR: CVe,
  boxh: AVe,
  boxH: TVe,
  boxhd: kVe,
  boxHd: PVe,
  boxhD: EVe,
  boxHD: MVe,
  boxhu: DVe,
  boxHu: LVe,
  boxhU: IVe,
  boxHU: RVe,
  boxminus: NVe,
  boxplus: $Ve,
  boxtimes: BVe,
  boxul: VVe,
  boxuL: zVe,
  boxUl: FVe,
  boxUL: QVe,
  boxur: ZVe,
  boxuR: WVe,
  boxUr: GVe,
  boxUR: jVe,
  boxv: HVe,
  boxV: qVe,
  boxvh: YVe,
  boxvH: XVe,
  boxVh: UVe,
  boxVH: KVe,
  boxvl: JVe,
  boxvL: e4e,
  boxVl: t4e,
  boxVL: n4e,
  boxvr: r4e,
  boxvR: i4e,
  boxVr: o4e,
  boxVR: a4e,
  bprime: s4e,
  breve: l4e,
  Breve: u4e,
  brvbar: c4e,
  bscr: h4e,
  Bscr: f4e,
  bsemi: d4e,
  bsim: p4e,
  bsime: g4e,
  bsolb: v4e,
  bsol: m4e,
  bsolhsub: y4e,
  bull: b4e,
  bullet: O4e,
  bump: w4e,
  bumpE: x4e,
  bumpe: S4e,
  Bumpeq: _4e,
  bumpeq: C4e,
  Cacute: A4e,
  cacute: T4e,
  capand: k4e,
  capbrcup: P4e,
  capcap: E4e,
  cap: M4e,
  Cap: D4e,
  capcup: L4e,
  capdot: I4e,
  CapitalDifferentialD: R4e,
  caps: N4e,
  caret: $4e,
  caron: B4e,
  Cayleys: V4e,
  ccaps: z4e,
  Ccaron: F4e,
  ccaron: Q4e,
  Ccedil: Z4e,
  ccedil: W4e,
  Ccirc: G4e,
  ccirc: j4e,
  Cconint: H4e,
  ccups: q4e,
  ccupssm: Y4e,
  Cdot: X4e,
  cdot: U4e,
  cedil: K4e,
  Cedilla: J4e,
  cemptyv: eze,
  cent: tze,
  centerdot: nze,
  CenterDot: rze,
  cfr: ize,
  Cfr: oze,
  CHcy: aze,
  chcy: sze,
  check: lze,
  checkmark: uze,
  Chi: cze,
  chi: hze,
  circ: fze,
  circeq: dze,
  circlearrowleft: pze,
  circlearrowright: gze,
  circledast: vze,
  circledcirc: mze,
  circleddash: yze,
  CircleDot: bze,
  circledR: Oze,
  circledS: wze,
  CircleMinus: xze,
  CirclePlus: Sze,
  CircleTimes: _ze,
  cir: Cze,
  cirE: Aze,
  cire: Tze,
  cirfnint: kze,
  cirmid: Pze,
  cirscir: Eze,
  ClockwiseContourIntegral: Mze,
  CloseCurlyDoubleQuote: Dze,
  CloseCurlyQuote: Lze,
  clubs: Ize,
  clubsuit: Rze,
  colon: Nze,
  Colon: $ze,
  Colone: Bze,
  colone: Vze,
  coloneq: zze,
  comma: Fze,
  commat: Qze,
  comp: Zze,
  compfn: Wze,
  complement: Gze,
  complexes: jze,
  cong: Hze,
  congdot: qze,
  Congruent: Yze,
  conint: Xze,
  Conint: Uze,
  ContourIntegral: Kze,
  copf: Jze,
  Copf: eFe,
  coprod: tFe,
  Coproduct: nFe,
  copy: rFe,
  COPY: iFe,
  copysr: oFe,
  CounterClockwiseContourIntegral: aFe,
  crarr: sFe,
  cross: lFe,
  Cross: uFe,
  Cscr: cFe,
  cscr: hFe,
  csub: fFe,
  csube: dFe,
  csup: pFe,
  csupe: gFe,
  ctdot: vFe,
  cudarrl: mFe,
  cudarrr: yFe,
  cuepr: bFe,
  cuesc: OFe,
  cularr: wFe,
  cularrp: xFe,
  cupbrcap: SFe,
  cupcap: _Fe,
  CupCap: CFe,
  cup: AFe,
  Cup: TFe,
  cupcup: kFe,
  cupdot: PFe,
  cupor: EFe,
  cups: MFe,
  curarr: DFe,
  curarrm: LFe,
  curlyeqprec: IFe,
  curlyeqsucc: RFe,
  curlyvee: NFe,
  curlywedge: $Fe,
  curren: BFe,
  curvearrowleft: VFe,
  curvearrowright: zFe,
  cuvee: FFe,
  cuwed: QFe,
  cwconint: ZFe,
  cwint: WFe,
  cylcty: GFe,
  dagger: jFe,
  Dagger: HFe,
  daleth: qFe,
  darr: YFe,
  Darr: XFe,
  dArr: UFe,
  dash: KFe,
  Dashv: JFe,
  dashv: e6e,
  dbkarow: t6e,
  dblac: n6e,
  Dcaron: r6e,
  dcaron: i6e,
  Dcy: o6e,
  dcy: a6e,
  ddagger: s6e,
  ddarr: l6e,
  DD: u6e,
  dd: c6e,
  DDotrahd: h6e,
  ddotseq: f6e,
  deg: d6e,
  Del: p6e,
  Delta: g6e,
  delta: v6e,
  demptyv: m6e,
  dfisht: y6e,
  Dfr: b6e,
  dfr: O6e,
  dHar: w6e,
  dharl: x6e,
  dharr: S6e,
  DiacriticalAcute: _6e,
  DiacriticalDot: C6e,
  DiacriticalDoubleAcute: A6e,
  DiacriticalGrave: T6e,
  DiacriticalTilde: k6e,
  diam: P6e,
  diamond: E6e,
  Diamond: M6e,
  diamondsuit: D6e,
  diams: L6e,
  die: I6e,
  DifferentialD: R6e,
  digamma: N6e,
  disin: $6e,
  div: B6e,
  divide: V6e,
  divideontimes: z6e,
  divonx: F6e,
  DJcy: Q6e,
  djcy: Z6e,
  dlcorn: W6e,
  dlcrop: G6e,
  dollar: j6e,
  Dopf: H6e,
  dopf: q6e,
  Dot: Y6e,
  dot: X6e,
  DotDot: U6e,
  doteq: K6e,
  doteqdot: J6e,
  DotEqual: e8e,
  dotminus: t8e,
  dotplus: n8e,
  dotsquare: r8e,
  doublebarwedge: i8e,
  DoubleContourIntegral: o8e,
  DoubleDot: a8e,
  DoubleDownArrow: s8e,
  DoubleLeftArrow: l8e,
  DoubleLeftRightArrow: u8e,
  DoubleLeftTee: c8e,
  DoubleLongLeftArrow: h8e,
  DoubleLongLeftRightArrow: f8e,
  DoubleLongRightArrow: d8e,
  DoubleRightArrow: p8e,
  DoubleRightTee: g8e,
  DoubleUpArrow: v8e,
  DoubleUpDownArrow: m8e,
  DoubleVerticalBar: y8e,
  DownArrowBar: b8e,
  downarrow: O8e,
  DownArrow: w8e,
  Downarrow: x8e,
  DownArrowUpArrow: S8e,
  DownBreve: _8e,
  downdownarrows: C8e,
  downharpoonleft: A8e,
  downharpoonright: T8e,
  DownLeftRightVector: k8e,
  DownLeftTeeVector: P8e,
  DownLeftVectorBar: E8e,
  DownLeftVector: M8e,
  DownRightTeeVector: D8e,
  DownRightVectorBar: L8e,
  DownRightVector: I8e,
  DownTeeArrow: R8e,
  DownTee: N8e,
  drbkarow: $8e,
  drcorn: B8e,
  drcrop: V8e,
  Dscr: z8e,
  dscr: F8e,
  DScy: Q8e,
  dscy: Z8e,
  dsol: W8e,
  Dstrok: G8e,
  dstrok: j8e,
  dtdot: H8e,
  dtri: q8e,
  dtrif: Y8e,
  duarr: X8e,
  duhar: U8e,
  dwangle: K8e,
  DZcy: J8e,
  dzcy: eQe,
  dzigrarr: tQe,
  Eacute: nQe,
  eacute: rQe,
  easter: iQe,
  Ecaron: oQe,
  ecaron: aQe,
  Ecirc: sQe,
  ecirc: lQe,
  ecir: uQe,
  ecolon: cQe,
  Ecy: hQe,
  ecy: fQe,
  eDDot: dQe,
  Edot: pQe,
  edot: gQe,
  eDot: vQe,
  ee: mQe,
  efDot: yQe,
  Efr: bQe,
  efr: OQe,
  eg: wQe,
  Egrave: xQe,
  egrave: SQe,
  egs: _Qe,
  egsdot: CQe,
  el: AQe,
  Element: TQe,
  elinters: kQe,
  ell: PQe,
  els: EQe,
  elsdot: MQe,
  Emacr: DQe,
  emacr: LQe,
  empty: IQe,
  emptyset: RQe,
  EmptySmallSquare: NQe,
  emptyv: $Qe,
  EmptyVerySmallSquare: BQe,
  emsp13: VQe,
  emsp14: zQe,
  emsp: FQe,
  ENG: QQe,
  eng: ZQe,
  ensp: WQe,
  Eogon: GQe,
  eogon: jQe,
  Eopf: HQe,
  eopf: qQe,
  epar: YQe,
  eparsl: XQe,
  eplus: UQe,
  epsi: KQe,
  Epsilon: JQe,
  epsilon: eZe,
  epsiv: tZe,
  eqcirc: nZe,
  eqcolon: rZe,
  eqsim: iZe,
  eqslantgtr: oZe,
  eqslantless: aZe,
  Equal: sZe,
  equals: lZe,
  EqualTilde: uZe,
  equest: cZe,
  Equilibrium: hZe,
  equiv: fZe,
  equivDD: dZe,
  eqvparsl: pZe,
  erarr: gZe,
  erDot: vZe,
  escr: mZe,
  Escr: yZe,
  esdot: bZe,
  Esim: OZe,
  esim: wZe,
  Eta: xZe,
  eta: SZe,
  ETH: _Ze,
  eth: CZe,
  Euml: AZe,
  euml: TZe,
  euro: kZe,
  excl: PZe,
  exist: EZe,
  Exists: MZe,
  expectation: DZe,
  exponentiale: LZe,
  ExponentialE: IZe,
  fallingdotseq: RZe,
  Fcy: NZe,
  fcy: $Ze,
  female: BZe,
  ffilig: VZe,
  fflig: zZe,
  ffllig: FZe,
  Ffr: QZe,
  ffr: ZZe,
  filig: WZe,
  FilledSmallSquare: GZe,
  FilledVerySmallSquare: jZe,
  fjlig: HZe,
  flat: qZe,
  fllig: YZe,
  fltns: XZe,
  fnof: UZe,
  Fopf: KZe,
  fopf: JZe,
  forall: eWe,
  ForAll: tWe,
  fork: nWe,
  forkv: rWe,
  Fouriertrf: iWe,
  fpartint: oWe,
  frac12: aWe,
  frac13: sWe,
  frac14: lWe,
  frac15: uWe,
  frac16: cWe,
  frac18: hWe,
  frac23: fWe,
  frac25: dWe,
  frac34: pWe,
  frac35: gWe,
  frac38: vWe,
  frac45: mWe,
  frac56: yWe,
  frac58: bWe,
  frac78: OWe,
  frasl: wWe,
  frown: xWe,
  fscr: SWe,
  Fscr: _We,
  gacute: CWe,
  Gamma: AWe,
  gamma: TWe,
  Gammad: kWe,
  gammad: PWe,
  gap: EWe,
  Gbreve: MWe,
  gbreve: DWe,
  Gcedil: LWe,
  Gcirc: IWe,
  gcirc: RWe,
  Gcy: NWe,
  gcy: $We,
  Gdot: BWe,
  gdot: VWe,
  ge: zWe,
  gE: FWe,
  gEl: QWe,
  gel: ZWe,
  geq: WWe,
  geqq: GWe,
  geqslant: jWe,
  gescc: HWe,
  ges: qWe,
  gesdot: YWe,
  gesdoto: XWe,
  gesdotol: UWe,
  gesl: KWe,
  gesles: JWe,
  Gfr: eGe,
  gfr: tGe,
  gg: nGe,
  Gg: rGe,
  ggg: iGe,
  gimel: oGe,
  GJcy: aGe,
  gjcy: sGe,
  gla: lGe,
  gl: uGe,
  glE: cGe,
  glj: hGe,
  gnap: fGe,
  gnapprox: dGe,
  gne: pGe,
  gnE: gGe,
  gneq: vGe,
  gneqq: mGe,
  gnsim: yGe,
  Gopf: bGe,
  gopf: OGe,
  grave: wGe,
  GreaterEqual: xGe,
  GreaterEqualLess: SGe,
  GreaterFullEqual: _Ge,
  GreaterGreater: CGe,
  GreaterLess: AGe,
  GreaterSlantEqual: TGe,
  GreaterTilde: kGe,
  Gscr: PGe,
  gscr: EGe,
  gsim: MGe,
  gsime: DGe,
  gsiml: LGe,
  gtcc: IGe,
  gtcir: RGe,
  gt: NGe,
  GT: $Ge,
  Gt: BGe,
  gtdot: VGe,
  gtlPar: zGe,
  gtquest: FGe,
  gtrapprox: QGe,
  gtrarr: ZGe,
  gtrdot: WGe,
  gtreqless: GGe,
  gtreqqless: jGe,
  gtrless: HGe,
  gtrsim: qGe,
  gvertneqq: YGe,
  gvnE: XGe,
  Hacek: UGe,
  hairsp: KGe,
  half: JGe,
  hamilt: eje,
  HARDcy: tje,
  hardcy: nje,
  harrcir: rje,
  harr: ije,
  hArr: oje,
  harrw: aje,
  Hat: sje,
  hbar: lje,
  Hcirc: uje,
  hcirc: cje,
  hearts: hje,
  heartsuit: fje,
  hellip: dje,
  hercon: pje,
  hfr: gje,
  Hfr: vje,
  HilbertSpace: mje,
  hksearow: yje,
  hkswarow: bje,
  hoarr: Oje,
  homtht: wje,
  hookleftarrow: xje,
  hookrightarrow: Sje,
  hopf: _je,
  Hopf: Cje,
  horbar: Aje,
  HorizontalLine: Tje,
  hscr: kje,
  Hscr: Pje,
  hslash: Eje,
  Hstrok: Mje,
  hstrok: Dje,
  HumpDownHump: Lje,
  HumpEqual: Ije,
  hybull: Rje,
  hyphen: Nje,
  Iacute: $je,
  iacute: Bje,
  ic: Vje,
  Icirc: zje,
  icirc: Fje,
  Icy: Qje,
  icy: Zje,
  Idot: Wje,
  IEcy: Gje,
  iecy: jje,
  iexcl: Hje,
  iff: qje,
  ifr: Yje,
  Ifr: Xje,
  Igrave: Uje,
  igrave: Kje,
  ii: Jje,
  iiiint: e7e,
  iiint: t7e,
  iinfin: n7e,
  iiota: r7e,
  IJlig: i7e,
  ijlig: o7e,
  Imacr: a7e,
  imacr: s7e,
  image: l7e,
  ImaginaryI: u7e,
  imagline: c7e,
  imagpart: h7e,
  imath: f7e,
  Im: d7e,
  imof: p7e,
  imped: g7e,
  Implies: v7e,
  incare: m7e,
  in: "∈",
  infin: y7e,
  infintie: b7e,
  inodot: O7e,
  intcal: w7e,
  int: x7e,
  Int: S7e,
  integers: _7e,
  Integral: C7e,
  intercal: A7e,
  Intersection: T7e,
  intlarhk: k7e,
  intprod: P7e,
  InvisibleComma: E7e,
  InvisibleTimes: M7e,
  IOcy: D7e,
  iocy: L7e,
  Iogon: I7e,
  iogon: R7e,
  Iopf: N7e,
  iopf: $7e,
  Iota: B7e,
  iota: V7e,
  iprod: z7e,
  iquest: F7e,
  iscr: Q7e,
  Iscr: Z7e,
  isin: W7e,
  isindot: G7e,
  isinE: j7e,
  isins: H7e,
  isinsv: q7e,
  isinv: Y7e,
  it: X7e,
  Itilde: U7e,
  itilde: K7e,
  Iukcy: J7e,
  iukcy: eHe,
  Iuml: tHe,
  iuml: nHe,
  Jcirc: rHe,
  jcirc: iHe,
  Jcy: oHe,
  jcy: aHe,
  Jfr: sHe,
  jfr: lHe,
  jmath: uHe,
  Jopf: cHe,
  jopf: hHe,
  Jscr: fHe,
  jscr: dHe,
  Jsercy: pHe,
  jsercy: gHe,
  Jukcy: vHe,
  jukcy: mHe,
  Kappa: yHe,
  kappa: bHe,
  kappav: OHe,
  Kcedil: wHe,
  kcedil: xHe,
  Kcy: SHe,
  kcy: _He,
  Kfr: CHe,
  kfr: AHe,
  kgreen: THe,
  KHcy: kHe,
  khcy: PHe,
  KJcy: EHe,
  kjcy: MHe,
  Kopf: DHe,
  kopf: LHe,
  Kscr: IHe,
  kscr: RHe,
  lAarr: NHe,
  Lacute: $He,
  lacute: BHe,
  laemptyv: VHe,
  lagran: zHe,
  Lambda: FHe,
  lambda: QHe,
  lang: ZHe,
  Lang: WHe,
  langd: GHe,
  langle: jHe,
  lap: HHe,
  Laplacetrf: qHe,
  laquo: YHe,
  larrb: XHe,
  larrbfs: UHe,
  larr: KHe,
  Larr: JHe,
  lArr: eqe,
  larrfs: tqe,
  larrhk: nqe,
  larrlp: rqe,
  larrpl: iqe,
  larrsim: oqe,
  larrtl: aqe,
  latail: sqe,
  lAtail: lqe,
  lat: uqe,
  late: cqe,
  lates: hqe,
  lbarr: fqe,
  lBarr: dqe,
  lbbrk: pqe,
  lbrace: gqe,
  lbrack: vqe,
  lbrke: mqe,
  lbrksld: yqe,
  lbrkslu: bqe,
  Lcaron: Oqe,
  lcaron: wqe,
  Lcedil: xqe,
  lcedil: Sqe,
  lceil: _qe,
  lcub: Cqe,
  Lcy: Aqe,
  lcy: Tqe,
  ldca: kqe,
  ldquo: Pqe,
  ldquor: Eqe,
  ldrdhar: Mqe,
  ldrushar: Dqe,
  ldsh: Lqe,
  le: Iqe,
  lE: Rqe,
  LeftAngleBracket: Nqe,
  LeftArrowBar: $qe,
  leftarrow: Bqe,
  LeftArrow: Vqe,
  Leftarrow: zqe,
  LeftArrowRightArrow: Fqe,
  leftarrowtail: Qqe,
  LeftCeiling: Zqe,
  LeftDoubleBracket: Wqe,
  LeftDownTeeVector: Gqe,
  LeftDownVectorBar: jqe,
  LeftDownVector: Hqe,
  LeftFloor: qqe,
  leftharpoondown: Yqe,
  leftharpoonup: Xqe,
  leftleftarrows: Uqe,
  leftrightarrow: Kqe,
  LeftRightArrow: Jqe,
  Leftrightarrow: e9e,
  leftrightarrows: t9e,
  leftrightharpoons: n9e,
  leftrightsquigarrow: r9e,
  LeftRightVector: i9e,
  LeftTeeArrow: o9e,
  LeftTee: a9e,
  LeftTeeVector: s9e,
  leftthreetimes: l9e,
  LeftTriangleBar: u9e,
  LeftTriangle: c9e,
  LeftTriangleEqual: h9e,
  LeftUpDownVector: f9e,
  LeftUpTeeVector: d9e,
  LeftUpVectorBar: p9e,
  LeftUpVector: g9e,
  LeftVectorBar: v9e,
  LeftVector: m9e,
  lEg: y9e,
  leg: b9e,
  leq: O9e,
  leqq: w9e,
  leqslant: x9e,
  lescc: S9e,
  les: _9e,
  lesdot: C9e,
  lesdoto: A9e,
  lesdotor: T9e,
  lesg: k9e,
  lesges: P9e,
  lessapprox: E9e,
  lessdot: M9e,
  lesseqgtr: D9e,
  lesseqqgtr: L9e,
  LessEqualGreater: I9e,
  LessFullEqual: R9e,
  LessGreater: N9e,
  lessgtr: $9e,
  LessLess: B9e,
  lesssim: V9e,
  LessSlantEqual: z9e,
  LessTilde: F9e,
  lfisht: Q9e,
  lfloor: Z9e,
  Lfr: W9e,
  lfr: G9e,
  lg: j9e,
  lgE: H9e,
  lHar: q9e,
  lhard: Y9e,
  lharu: X9e,
  lharul: U9e,
  lhblk: K9e,
  LJcy: J9e,
  ljcy: eYe,
  llarr: tYe,
  ll: nYe,
  Ll: rYe,
  llcorner: iYe,
  Lleftarrow: oYe,
  llhard: aYe,
  lltri: sYe,
  Lmidot: lYe,
  lmidot: uYe,
  lmoustache: cYe,
  lmoust: hYe,
  lnap: fYe,
  lnapprox: dYe,
  lne: pYe,
  lnE: gYe,
  lneq: vYe,
  lneqq: mYe,
  lnsim: yYe,
  loang: bYe,
  loarr: OYe,
  lobrk: wYe,
  longleftarrow: xYe,
  LongLeftArrow: SYe,
  Longleftarrow: _Ye,
  longleftrightarrow: CYe,
  LongLeftRightArrow: AYe,
  Longleftrightarrow: TYe,
  longmapsto: kYe,
  longrightarrow: PYe,
  LongRightArrow: EYe,
  Longrightarrow: MYe,
  looparrowleft: DYe,
  looparrowright: LYe,
  lopar: IYe,
  Lopf: RYe,
  lopf: NYe,
  loplus: $Ye,
  lotimes: BYe,
  lowast: VYe,
  lowbar: zYe,
  LowerLeftArrow: FYe,
  LowerRightArrow: QYe,
  loz: ZYe,
  lozenge: WYe,
  lozf: GYe,
  lpar: jYe,
  lparlt: HYe,
  lrarr: qYe,
  lrcorner: YYe,
  lrhar: XYe,
  lrhard: UYe,
  lrm: KYe,
  lrtri: JYe,
  lsaquo: eXe,
  lscr: tXe,
  Lscr: nXe,
  lsh: rXe,
  Lsh: iXe,
  lsim: oXe,
  lsime: aXe,
  lsimg: sXe,
  lsqb: lXe,
  lsquo: uXe,
  lsquor: cXe,
  Lstrok: hXe,
  lstrok: fXe,
  ltcc: dXe,
  ltcir: pXe,
  lt: gXe,
  LT: vXe,
  Lt: mXe,
  ltdot: yXe,
  lthree: bXe,
  ltimes: OXe,
  ltlarr: wXe,
  ltquest: xXe,
  ltri: SXe,
  ltrie: _Xe,
  ltrif: CXe,
  ltrPar: AXe,
  lurdshar: TXe,
  luruhar: kXe,
  lvertneqq: PXe,
  lvnE: EXe,
  macr: MXe,
  male: DXe,
  malt: LXe,
  maltese: IXe,
  Map: "⤅",
  map: RXe,
  mapsto: NXe,
  mapstodown: $Xe,
  mapstoleft: BXe,
  mapstoup: VXe,
  marker: zXe,
  mcomma: FXe,
  Mcy: QXe,
  mcy: ZXe,
  mdash: WXe,
  mDDot: GXe,
  measuredangle: jXe,
  MediumSpace: HXe,
  Mellintrf: qXe,
  Mfr: YXe,
  mfr: XXe,
  mho: UXe,
  micro: KXe,
  midast: JXe,
  midcir: eUe,
  mid: tUe,
  middot: nUe,
  minusb: rUe,
  minus: iUe,
  minusd: oUe,
  minusdu: aUe,
  MinusPlus: sUe,
  mlcp: lUe,
  mldr: uUe,
  mnplus: cUe,
  models: hUe,
  Mopf: fUe,
  mopf: dUe,
  mp: pUe,
  mscr: gUe,
  Mscr: vUe,
  mstpos: mUe,
  Mu: yUe,
  mu: bUe,
  multimap: OUe,
  mumap: wUe,
  nabla: xUe,
  Nacute: SUe,
  nacute: _Ue,
  nang: CUe,
  nap: AUe,
  napE: TUe,
  napid: kUe,
  napos: PUe,
  napprox: EUe,
  natural: MUe,
  naturals: DUe,
  natur: LUe,
  nbsp: IUe,
  nbump: RUe,
  nbumpe: NUe,
  ncap: $Ue,
  Ncaron: BUe,
  ncaron: VUe,
  Ncedil: zUe,
  ncedil: FUe,
  ncong: QUe,
  ncongdot: ZUe,
  ncup: WUe,
  Ncy: GUe,
  ncy: jUe,
  ndash: HUe,
  nearhk: qUe,
  nearr: YUe,
  neArr: XUe,
  nearrow: UUe,
  ne: KUe,
  nedot: JUe,
  NegativeMediumSpace: eKe,
  NegativeThickSpace: tKe,
  NegativeThinSpace: nKe,
  NegativeVeryThinSpace: rKe,
  nequiv: iKe,
  nesear: oKe,
  nesim: aKe,
  NestedGreaterGreater: sKe,
  NestedLessLess: lKe,
  NewLine: uKe,
  nexist: cKe,
  nexists: hKe,
  Nfr: fKe,
  nfr: dKe,
  ngE: pKe,
  nge: gKe,
  ngeq: vKe,
  ngeqq: mKe,
  ngeqslant: yKe,
  nges: bKe,
  nGg: OKe,
  ngsim: wKe,
  nGt: xKe,
  ngt: SKe,
  ngtr: _Ke,
  nGtv: CKe,
  nharr: AKe,
  nhArr: TKe,
  nhpar: kKe,
  ni: PKe,
  nis: EKe,
  nisd: MKe,
  niv: DKe,
  NJcy: LKe,
  njcy: IKe,
  nlarr: RKe,
  nlArr: NKe,
  nldr: $Ke,
  nlE: BKe,
  nle: VKe,
  nleftarrow: zKe,
  nLeftarrow: FKe,
  nleftrightarrow: QKe,
  nLeftrightarrow: ZKe,
  nleq: WKe,
  nleqq: GKe,
  nleqslant: jKe,
  nles: HKe,
  nless: qKe,
  nLl: YKe,
  nlsim: XKe,
  nLt: UKe,
  nlt: KKe,
  nltri: JKe,
  nltrie: eJe,
  nLtv: tJe,
  nmid: nJe,
  NoBreak: rJe,
  NonBreakingSpace: iJe,
  nopf: oJe,
  Nopf: aJe,
  Not: sJe,
  not: lJe,
  NotCongruent: uJe,
  NotCupCap: cJe,
  NotDoubleVerticalBar: hJe,
  NotElement: fJe,
  NotEqual: dJe,
  NotEqualTilde: pJe,
  NotExists: gJe,
  NotGreater: vJe,
  NotGreaterEqual: mJe,
  NotGreaterFullEqual: yJe,
  NotGreaterGreater: bJe,
  NotGreaterLess: OJe,
  NotGreaterSlantEqual: wJe,
  NotGreaterTilde: xJe,
  NotHumpDownHump: SJe,
  NotHumpEqual: _Je,
  notin: CJe,
  notindot: AJe,
  notinE: TJe,
  notinva: kJe,
  notinvb: PJe,
  notinvc: EJe,
  NotLeftTriangleBar: MJe,
  NotLeftTriangle: DJe,
  NotLeftTriangleEqual: LJe,
  NotLess: IJe,
  NotLessEqual: RJe,
  NotLessGreater: NJe,
  NotLessLess: $Je,
  NotLessSlantEqual: BJe,
  NotLessTilde: VJe,
  NotNestedGreaterGreater: zJe,
  NotNestedLessLess: FJe,
  notni: QJe,
  notniva: ZJe,
  notnivb: WJe,
  notnivc: GJe,
  NotPrecedes: jJe,
  NotPrecedesEqual: HJe,
  NotPrecedesSlantEqual: qJe,
  NotReverseElement: YJe,
  NotRightTriangleBar: XJe,
  NotRightTriangle: UJe,
  NotRightTriangleEqual: KJe,
  NotSquareSubset: JJe,
  NotSquareSubsetEqual: eet,
  NotSquareSuperset: tet,
  NotSquareSupersetEqual: net,
  NotSubset: ret,
  NotSubsetEqual: iet,
  NotSucceeds: oet,
  NotSucceedsEqual: aet,
  NotSucceedsSlantEqual: set,
  NotSucceedsTilde: uet,
  NotSuperset: cet,
  NotSupersetEqual: het,
  NotTilde: fet,
  NotTildeEqual: det,
  NotTildeFullEqual: pet,
  NotTildeTilde: get,
  NotVerticalBar: vet,
  nparallel: met,
  npar: yet,
  nparsl: bet,
  npart: Oet,
  npolint: wet,
  npr: xet,
  nprcue: _et,
  nprec: Cet,
  npreceq: Aet,
  npre: Tet,
  nrarrc: ket,
  nrarr: Pet,
  nrArr: Eet,
  nrarrw: Met,
  nrightarrow: Det,
  nRightarrow: Let,
  nrtri: Iet,
  nrtrie: Ret,
  nsc: Net,
  nsccue: $et,
  nsce: Bet,
  Nscr: Vet,
  nscr: zet,
  nshortmid: Fet,
  nshortparallel: Qet,
  nsim: Zet,
  nsime: Wet,
  nsimeq: Get,
  nsmid: jet,
  nspar: Het,
  nsqsube: qet,
  nsqsupe: Yet,
  nsub: Xet,
  nsubE: Uet,
  nsube: Ket,
  nsubset: Jet,
  nsubseteq: ett,
  nsubseteqq: ttt,
  nsucc: ntt,
  nsucceq: rtt,
  nsup: itt,
  nsupE: ott,
  nsupe: att,
  nsupset: stt,
  nsupseteq: ltt,
  nsupseteqq: utt,
  ntgl: ctt,
  Ntilde: htt,
  ntilde: ftt,
  ntlg: dtt,
  ntriangleleft: ptt,
  ntrianglelefteq: gtt,
  ntriangleright: vtt,
  ntrianglerighteq: mtt,
  Nu: ytt,
  nu: btt,
  num: Ott,
  numero: wtt,
  numsp: xtt,
  nvap: Stt,
  nvdash: _tt,
  nvDash: Ctt,
  nVdash: Att,
  nVDash: Ttt,
  nvge: ktt,
  nvgt: Ptt,
  nvHarr: Ett,
  nvinfin: Mtt,
  nvlArr: Dtt,
  nvle: Ltt,
  nvlt: Itt,
  nvltrie: Rtt,
  nvrArr: Ntt,
  nvrtrie: $tt,
  nvsim: Btt,
  nwarhk: Vtt,
  nwarr: ztt,
  nwArr: Ftt,
  nwarrow: Qtt,
  nwnear: Ztt,
  Oacute: Wtt,
  oacute: Gtt,
  oast: jtt,
  Ocirc: Htt,
  ocirc: qtt,
  ocir: Ytt,
  Ocy: Xtt,
  ocy: Utt,
  odash: Ktt,
  Odblac: Jtt,
  odblac: ent,
  odiv: tnt,
  odot: nnt,
  odsold: rnt,
  OElig: int,
  oelig: ont,
  ofcir: ant,
  Ofr: snt,
  ofr: lnt,
  ogon: unt,
  Ograve: cnt,
  ograve: hnt,
  ogt: fnt,
  ohbar: dnt,
  ohm: pnt,
  oint: gnt,
  olarr: vnt,
  olcir: mnt,
  olcross: ynt,
  oline: bnt,
  olt: Ont,
  Omacr: wnt,
  omacr: xnt,
  Omega: Snt,
  omega: _nt,
  Omicron: Cnt,
  omicron: Ant,
  omid: Tnt,
  ominus: knt,
  Oopf: Pnt,
  oopf: Ent,
  opar: Mnt,
  OpenCurlyDoubleQuote: Dnt,
  OpenCurlyQuote: Lnt,
  operp: Int,
  oplus: Rnt,
  orarr: Nnt,
  Or: $nt,
  or: Bnt,
  ord: Vnt,
  order: znt,
  orderof: Fnt,
  ordf: Qnt,
  ordm: Znt,
  origof: Wnt,
  oror: Gnt,
  orslope: jnt,
  orv: Hnt,
  oS: qnt,
  Oscr: Ynt,
  oscr: Xnt,
  Oslash: Unt,
  oslash: Knt,
  osol: Jnt,
  Otilde: ert,
  otilde: trt,
  otimesas: nrt,
  Otimes: rrt,
  otimes: irt,
  Ouml: ort,
  ouml: art,
  ovbar: srt,
  OverBar: lrt,
  OverBrace: urt,
  OverBracket: crt,
  OverParenthesis: hrt,
  para: frt,
  parallel: drt,
  par: prt,
  parsim: grt,
  parsl: vrt,
  part: mrt,
  PartialD: yrt,
  Pcy: brt,
  pcy: Ort,
  percnt: wrt,
  period: xrt,
  permil: Srt,
  perp: _rt,
  pertenk: Crt,
  Pfr: Art,
  pfr: Trt,
  Phi: krt,
  phi: Prt,
  phiv: Ert,
  phmmat: Mrt,
  phone: Drt,
  Pi: Lrt,
  pi: Irt,
  pitchfork: Rrt,
  piv: Nrt,
  planck: $rt,
  planckh: Brt,
  plankv: Vrt,
  plusacir: zrt,
  plusb: Frt,
  pluscir: Qrt,
  plus: Zrt,
  plusdo: Wrt,
  plusdu: Grt,
  pluse: jrt,
  PlusMinus: Hrt,
  plusmn: qrt,
  plussim: Yrt,
  plustwo: Xrt,
  pm: Urt,
  Poincareplane: Krt,
  pointint: Jrt,
  popf: eit,
  Popf: tit,
  pound: nit,
  prap: rit,
  Pr: iit,
  pr: oit,
  prcue: ait,
  precapprox: sit,
  prec: lit,
  preccurlyeq: uit,
  Precedes: cit,
  PrecedesEqual: hit,
  PrecedesSlantEqual: fit,
  PrecedesTilde: dit,
  preceq: pit,
  precnapprox: git,
  precneqq: vit,
  precnsim: mit,
  pre: yit,
  prE: bit,
  precsim: Oit,
  prime: wit,
  Prime: xit,
  primes: Sit,
  prnap: _it,
  prnE: Cit,
  prnsim: Ait,
  prod: Tit,
  Product: kit,
  profalar: Pit,
  profline: Eit,
  profsurf: Mit,
  prop: Dit,
  Proportional: Lit,
  Proportion: Iit,
  propto: Rit,
  prsim: Nit,
  prurel: $it,
  Pscr: Bit,
  pscr: Vit,
  Psi: zit,
  psi: Fit,
  puncsp: Qit,
  Qfr: Zit,
  qfr: Wit,
  qint: Git,
  qopf: jit,
  Qopf: Hit,
  qprime: qit,
  Qscr: Yit,
  qscr: Xit,
  quaternions: Uit,
  quatint: Kit,
  quest: Jit,
  questeq: eot,
  quot: tot,
  QUOT: not,
  rAarr: rot,
  race: iot,
  Racute: oot,
  racute: aot,
  radic: sot,
  raemptyv: lot,
  rang: uot,
  Rang: cot,
  rangd: hot,
  range: fot,
  rangle: dot,
  raquo: pot,
  rarrap: got,
  rarrb: vot,
  rarrbfs: mot,
  rarrc: yot,
  rarr: bot,
  Rarr: Oot,
  rArr: wot,
  rarrfs: xot,
  rarrhk: Sot,
  rarrlp: _ot,
  rarrpl: Cot,
  rarrsim: Aot,
  Rarrtl: Tot,
  rarrtl: kot,
  rarrw: Pot,
  ratail: Eot,
  rAtail: Mot,
  ratio: Dot,
  rationals: Lot,
  rbarr: Iot,
  rBarr: Rot,
  RBarr: Not,
  rbbrk: $ot,
  rbrace: Bot,
  rbrack: Vot,
  rbrke: zot,
  rbrksld: Fot,
  rbrkslu: Qot,
  Rcaron: Zot,
  rcaron: Wot,
  Rcedil: Got,
  rcedil: jot,
  rceil: Hot,
  rcub: qot,
  Rcy: Yot,
  rcy: Xot,
  rdca: Uot,
  rdldhar: Kot,
  rdquo: Jot,
  rdquor: eat,
  rdsh: tat,
  real: nat,
  realine: rat,
  realpart: iat,
  reals: oat,
  Re: aat,
  rect: sat,
  reg: lat,
  REG: uat,
  ReverseElement: cat,
  ReverseEquilibrium: hat,
  ReverseUpEquilibrium: fat,
  rfisht: dat,
  rfloor: pat,
  rfr: gat,
  Rfr: vat,
  rHar: mat,
  rhard: yat,
  rharu: bat,
  rharul: Oat,
  Rho: wat,
  rho: xat,
  rhov: Sat,
  RightAngleBracket: _at,
  RightArrowBar: Cat,
  rightarrow: Aat,
  RightArrow: Tat,
  Rightarrow: kat,
  RightArrowLeftArrow: Pat,
  rightarrowtail: Eat,
  RightCeiling: Mat,
  RightDoubleBracket: Dat,
  RightDownTeeVector: Lat,
  RightDownVectorBar: Iat,
  RightDownVector: Rat,
  RightFloor: Nat,
  rightharpoondown: $at,
  rightharpoonup: Bat,
  rightleftarrows: Vat,
  rightleftharpoons: zat,
  rightrightarrows: Fat,
  rightsquigarrow: Qat,
  RightTeeArrow: Zat,
  RightTee: Wat,
  RightTeeVector: Gat,
  rightthreetimes: jat,
  RightTriangleBar: Hat,
  RightTriangle: qat,
  RightTriangleEqual: Yat,
  RightUpDownVector: Xat,
  RightUpTeeVector: Uat,
  RightUpVectorBar: Kat,
  RightUpVector: Jat,
  RightVectorBar: est,
  RightVector: tst,
  ring: nst,
  risingdotseq: rst,
  rlarr: ist,
  rlhar: ost,
  rlm: ast,
  rmoustache: sst,
  rmoust: lst,
  rnmid: ust,
  roang: cst,
  roarr: hst,
  robrk: fst,
  ropar: dst,
  ropf: pst,
  Ropf: gst,
  roplus: vst,
  rotimes: mst,
  RoundImplies: yst,
  rpar: bst,
  rpargt: Ost,
  rppolint: wst,
  rrarr: xst,
  Rrightarrow: Sst,
  rsaquo: _st,
  rscr: Cst,
  Rscr: Ast,
  rsh: Tst,
  Rsh: kst,
  rsqb: Pst,
  rsquo: Est,
  rsquor: Mst,
  rthree: Dst,
  rtimes: Lst,
  rtri: Ist,
  rtrie: Rst,
  rtrif: Nst,
  rtriltri: $st,
  RuleDelayed: Bst,
  ruluhar: Vst,
  rx: zst,
  Sacute: Fst,
  sacute: Qst,
  sbquo: Zst,
  scap: Wst,
  Scaron: Gst,
  scaron: jst,
  Sc: Hst,
  sc: qst,
  sccue: Yst,
  sce: Xst,
  scE: Ust,
  Scedil: Kst,
  scedil: Jst,
  Scirc: elt,
  scirc: tlt,
  scnap: nlt,
  scnE: rlt,
  scnsim: ilt,
  scpolint: olt,
  scsim: alt,
  Scy: slt,
  scy: llt,
  sdotb: ult,
  sdot: clt,
  sdote: hlt,
  searhk: flt,
  searr: dlt,
  seArr: plt,
  searrow: glt,
  sect: vlt,
  semi: mlt,
  seswar: ylt,
  setminus: blt,
  setmn: Olt,
  sext: wlt,
  Sfr: xlt,
  sfr: Slt,
  sfrown: _lt,
  sharp: Clt,
  SHCHcy: Alt,
  shchcy: Tlt,
  SHcy: klt,
  shcy: Plt,
  ShortDownArrow: Elt,
  ShortLeftArrow: Mlt,
  shortmid: Dlt,
  shortparallel: Llt,
  ShortRightArrow: Ilt,
  ShortUpArrow: Rlt,
  shy: Nlt,
  Sigma: $lt,
  sigma: Blt,
  sigmaf: Vlt,
  sigmav: zlt,
  sim: Flt,
  simdot: Qlt,
  sime: Zlt,
  simeq: Wlt,
  simg: Glt,
  simgE: jlt,
  siml: Hlt,
  simlE: qlt,
  simne: Ylt,
  simplus: Xlt,
  simrarr: Ult,
  slarr: Klt,
  SmallCircle: Jlt,
  smallsetminus: eut,
  smashp: tut,
  smeparsl: nut,
  smid: rut,
  smile: iut,
  smt: out,
  smte: aut,
  smtes: sut,
  SOFTcy: lut,
  softcy: uut,
  solbar: cut,
  solb: hut,
  sol: fut,
  Sopf: dut,
  sopf: put,
  spades: gut,
  spadesuit: vut,
  spar: mut,
  sqcap: yut,
  sqcaps: but,
  sqcup: Out,
  sqcups: wut,
  Sqrt: xut,
  sqsub: Sut,
  sqsube: _ut,
  sqsubset: Cut,
  sqsubseteq: Aut,
  sqsup: Tut,
  sqsupe: kut,
  sqsupset: Put,
  sqsupseteq: Eut,
  square: Mut,
  Square: Dut,
  SquareIntersection: Lut,
  SquareSubset: Iut,
  SquareSubsetEqual: Rut,
  SquareSuperset: Nut,
  SquareSupersetEqual: $ut,
  SquareUnion: But,
  squarf: Vut,
  squ: zut,
  squf: Fut,
  srarr: Qut,
  Sscr: Zut,
  sscr: Wut,
  ssetmn: Gut,
  ssmile: jut,
  sstarf: Hut,
  Star: qut,
  star: Yut,
  starf: Xut,
  straightepsilon: Uut,
  straightphi: Kut,
  strns: Jut,
  sub: ect,
  Sub: tct,
  subdot: nct,
  subE: rct,
  sube: ict,
  subedot: oct,
  submult: act,
  subnE: sct,
  subne: lct,
  subplus: uct,
  subrarr: cct,
  subset: hct,
  Subset: fct,
  subseteq: dct,
  subseteqq: pct,
  SubsetEqual: gct,
  subsetneq: vct,
  subsetneqq: mct,
  subsim: yct,
  subsub: bct,
  subsup: Oct,
  succapprox: wct,
  succ: xct,
  succcurlyeq: Sct,
  Succeeds: _ct,
  SucceedsEqual: Cct,
  SucceedsSlantEqual: Act,
  SucceedsTilde: Tct,
  succeq: kct,
  succnapprox: Pct,
  succneqq: Ect,
  succnsim: Mct,
  succsim: Dct,
  SuchThat: Lct,
  sum: Ict,
  Sum: Rct,
  sung: Nct,
  sup1: $ct,
  sup2: Bct,
  sup3: Vct,
  sup: zct,
  Sup: Fct,
  supdot: Qct,
  supdsub: Zct,
  supE: Wct,
  supe: Gct,
  supedot: jct,
  Superset: Hct,
  SupersetEqual: qct,
  suphsol: Yct,
  suphsub: Xct,
  suplarr: Uct,
  supmult: Kct,
  supnE: Jct,
  supne: eht,
  supplus: tht,
  supset: nht,
  Supset: rht,
  supseteq: iht,
  supseteqq: oht,
  supsetneq: aht,
  supsetneqq: sht,
  supsim: lht,
  supsub: uht,
  supsup: cht,
  swarhk: hht,
  swarr: fht,
  swArr: dht,
  swarrow: pht,
  swnwar: ght,
  szlig: vht,
  Tab: mht,
  target: yht,
  Tau: bht,
  tau: Oht,
  tbrk: wht,
  Tcaron: xht,
  tcaron: Sht,
  Tcedil: _ht,
  tcedil: Cht,
  Tcy: Aht,
  tcy: Tht,
  tdot: kht,
  telrec: Pht,
  Tfr: Eht,
  tfr: Mht,
  there4: Dht,
  therefore: Lht,
  Therefore: Iht,
  Theta: Rht,
  theta: Nht,
  thetasym: $ht,
  thetav: Bht,
  thickapprox: Vht,
  thicksim: zht,
  ThickSpace: Fht,
  ThinSpace: Qht,
  thinsp: Zht,
  thkap: Wht,
  thksim: Ght,
  THORN: jht,
  thorn: Hht,
  tilde: qht,
  Tilde: Yht,
  TildeEqual: Xht,
  TildeFullEqual: Uht,
  TildeTilde: Kht,
  timesbar: Jht,
  timesb: eft,
  times: tft,
  timesd: nft,
  tint: rft,
  toea: ift,
  topbot: oft,
  topcir: aft,
  top: sft,
  Topf: lft,
  topf: uft,
  topfork: cft,
  tosa: hft,
  tprime: fft,
  trade: dft,
  TRADE: pft,
  triangle: gft,
  triangledown: vft,
  triangleleft: mft,
  trianglelefteq: yft,
  triangleq: bft,
  triangleright: Oft,
  trianglerighteq: wft,
  tridot: xft,
  trie: Sft,
  triminus: _ft,
  TripleDot: Cft,
  triplus: Aft,
  trisb: Tft,
  tritime: kft,
  trpezium: Pft,
  Tscr: Eft,
  tscr: Mft,
  TScy: Dft,
  tscy: Lft,
  TSHcy: Ift,
  tshcy: Rft,
  Tstrok: Nft,
  tstrok: $ft,
  twixt: Bft,
  twoheadleftarrow: Vft,
  twoheadrightarrow: zft,
  Uacute: Fft,
  uacute: Qft,
  uarr: Zft,
  Uarr: Wft,
  uArr: Gft,
  Uarrocir: jft,
  Ubrcy: Hft,
  ubrcy: qft,
  Ubreve: Yft,
  ubreve: Xft,
  Ucirc: Uft,
  ucirc: Kft,
  Ucy: Jft,
  ucy: edt,
  udarr: tdt,
  Udblac: ndt,
  udblac: rdt,
  udhar: idt,
  ufisht: odt,
  Ufr: adt,
  ufr: sdt,
  Ugrave: ldt,
  ugrave: udt,
  uHar: cdt,
  uharl: hdt,
  uharr: fdt,
  uhblk: ddt,
  ulcorn: pdt,
  ulcorner: gdt,
  ulcrop: vdt,
  ultri: mdt,
  Umacr: ydt,
  umacr: bdt,
  uml: Odt,
  UnderBar: wdt,
  UnderBrace: xdt,
  UnderBracket: Sdt,
  UnderParenthesis: _dt,
  Union: Cdt,
  UnionPlus: Adt,
  Uogon: Tdt,
  uogon: kdt,
  Uopf: Pdt,
  uopf: Edt,
  UpArrowBar: Mdt,
  uparrow: Ddt,
  UpArrow: Ldt,
  Uparrow: Idt,
  UpArrowDownArrow: Rdt,
  updownarrow: Ndt,
  UpDownArrow: $dt,
  Updownarrow: Bdt,
  UpEquilibrium: Vdt,
  upharpoonleft: zdt,
  upharpoonright: Fdt,
  uplus: Qdt,
  UpperLeftArrow: Zdt,
  UpperRightArrow: Wdt,
  upsi: Gdt,
  Upsi: jdt,
  upsih: Hdt,
  Upsilon: qdt,
  upsilon: Ydt,
  UpTeeArrow: Xdt,
  UpTee: Udt,
  upuparrows: Kdt,
  urcorn: Jdt,
  urcorner: ept,
  urcrop: tpt,
  Uring: npt,
  uring: rpt,
  urtri: ipt,
  Uscr: opt,
  uscr: apt,
  utdot: spt,
  Utilde: lpt,
  utilde: upt,
  utri: cpt,
  utrif: hpt,
  uuarr: fpt,
  Uuml: dpt,
  uuml: ppt,
  uwangle: gpt,
  vangrt: vpt,
  varepsilon: mpt,
  varkappa: ypt,
  varnothing: bpt,
  varphi: Opt,
  varpi: wpt,
  varpropto: xpt,
  varr: Spt,
  vArr: _pt,
  varrho: Cpt,
  varsigma: Apt,
  varsubsetneq: Tpt,
  varsubsetneqq: kpt,
  varsupsetneq: Ppt,
  varsupsetneqq: Ept,
  vartheta: Mpt,
  vartriangleleft: Dpt,
  vartriangleright: Lpt,
  vBar: Ipt,
  Vbar: Rpt,
  vBarv: Npt,
  Vcy: $pt,
  vcy: Bpt,
  vdash: Vpt,
  vDash: zpt,
  Vdash: Fpt,
  VDash: Qpt,
  Vdashl: Zpt,
  veebar: Wpt,
  vee: Gpt,
  Vee: jpt,
  veeeq: Hpt,
  vellip: qpt,
  verbar: Ypt,
  Verbar: Xpt,
  vert: Upt,
  Vert: Kpt,
  VerticalBar: Jpt,
  VerticalLine: egt,
  VerticalSeparator: tgt,
  VerticalTilde: ngt,
  VeryThinSpace: rgt,
  Vfr: igt,
  vfr: ogt,
  vltri: agt,
  vnsub: sgt,
  vnsup: lgt,
  Vopf: ugt,
  vopf: cgt,
  vprop: hgt,
  vrtri: fgt,
  Vscr: dgt,
  vscr: pgt,
  vsubnE: ggt,
  vsubne: vgt,
  vsupnE: mgt,
  vsupne: ygt,
  Vvdash: bgt,
  vzigzag: Ogt,
  Wcirc: wgt,
  wcirc: xgt,
  wedbar: Sgt,
  wedge: _gt,
  Wedge: Cgt,
  wedgeq: Agt,
  weierp: Tgt,
  Wfr: kgt,
  wfr: Pgt,
  Wopf: Egt,
  wopf: Mgt,
  wp: Dgt,
  wr: Lgt,
  wreath: Igt,
  Wscr: Rgt,
  wscr: Ngt,
  xcap: $gt,
  xcirc: Bgt,
  xcup: Vgt,
  xdtri: zgt,
  Xfr: Fgt,
  xfr: Qgt,
  xharr: Zgt,
  xhArr: Wgt,
  Xi: Ggt,
  xi: jgt,
  xlarr: Hgt,
  xlArr: qgt,
  xmap: Ygt,
  xnis: Xgt,
  xodot: Ugt,
  Xopf: Kgt,
  xopf: Jgt,
  xoplus: evt,
  xotime: tvt,
  xrarr: nvt,
  xrArr: rvt,
  Xscr: ivt,
  xscr: ovt,
  xsqcup: avt,
  xuplus: svt,
  xutri: lvt,
  xvee: uvt,
  xwedge: cvt,
  Yacute: hvt,
  yacute: fvt,
  YAcy: dvt,
  yacy: pvt,
  Ycirc: gvt,
  ycirc: vvt,
  Ycy: mvt,
  ycy: yvt,
  yen: bvt,
  Yfr: Ovt,
  yfr: wvt,
  YIcy: xvt,
  yicy: Svt,
  Yopf: _vt,
  yopf: Cvt,
  Yscr: Avt,
  yscr: Tvt,
  YUcy: kvt,
  yucy: Pvt,
  yuml: Evt,
  Yuml: Mvt,
  Zacute: Dvt,
  zacute: Lvt,
  Zcaron: Ivt,
  zcaron: Rvt,
  Zcy: Nvt,
  zcy: $vt,
  Zdot: Bvt,
  zdot: Vvt,
  zeetrf: zvt,
  ZeroWidthSpace: Fvt,
  Zeta: Qvt,
  zeta: Zvt,
  zfr: Wvt,
  Zfr: Gvt,
  ZHcy: jvt,
  zhcy: Hvt,
  zigrarr: qvt,
  zopf: Yvt,
  Zopf: Xvt,
  Zscr: Uvt,
  zscr: Kvt,
  zwj: Jvt,
  zwnj: emt
};
var UU = tmt, iR = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, Cv = {}, b4 = {};
function nmt(n) {
  var e, t, r = b4[n];
  if (r)
    return r;
  for (r = b4[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? r.push(t) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    r[n.charCodeAt(e)] = n[e];
  return r;
}
function tC(n, e, t) {
  var r, i, o, a, s, l = "";
  for (typeof e != "string" && (t = e, e = tC.defaultChars), typeof t > "u" && (t = !0), s = nmt(e), r = 0, i = n.length; r < i; r++) {
    if (o = n.charCodeAt(r), t && o === 37 && r + 2 < i && /^[0-9a-f]{2}$/i.test(n.slice(r + 1, r + 3))) {
      l += n.slice(r, r + 3), r += 2;
      continue;
    }
    if (o < 128) {
      l += s[o];
      continue;
    }
    if (o >= 55296 && o <= 57343) {
      if (o >= 55296 && o <= 56319 && r + 1 < i && (a = n.charCodeAt(r + 1), a >= 56320 && a <= 57343)) {
        l += encodeURIComponent(n[r] + n[r + 1]), r++;
        continue;
      }
      l += "%EF%BF%BD";
      continue;
    }
    l += encodeURIComponent(n[r]);
  }
  return l;
}
tC.defaultChars = ";/?:@&=+$,-_.!~*'()#";
tC.componentChars = "-_.!~*'()";
var rmt = tC, O4 = {};
function imt(n) {
  var e, t, r = O4[n];
  if (r)
    return r;
  for (r = O4[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), r.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), r[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return r;
}
function nC(n, e) {
  var t;
  return typeof e != "string" && (e = nC.defaultChars), t = imt(e), n.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var i, o, a, s, l, u, c, h = "";
    for (i = 0, o = r.length; i < o; i += 3) {
      if (a = parseInt(r.slice(i + 1, i + 3), 16), a < 128) {
        h += t[a];
        continue;
      }
      if ((a & 224) === 192 && i + 3 < o && (s = parseInt(r.slice(i + 4, i + 6), 16), (s & 192) === 128)) {
        c = a << 6 & 1984 | s & 63, c < 128 ? h += "��" : h += String.fromCharCode(c), i += 3;
        continue;
      }
      if ((a & 240) === 224 && i + 6 < o && (s = parseInt(r.slice(i + 4, i + 6), 16), l = parseInt(r.slice(i + 7, i + 9), 16), (s & 192) === 128 && (l & 192) === 128)) {
        c = a << 12 & 61440 | s << 6 & 4032 | l & 63, c < 2048 || c >= 55296 && c <= 57343 ? h += "���" : h += String.fromCharCode(c), i += 6;
        continue;
      }
      if ((a & 248) === 240 && i + 9 < o && (s = parseInt(r.slice(i + 4, i + 6), 16), l = parseInt(r.slice(i + 7, i + 9), 16), u = parseInt(r.slice(i + 10, i + 12), 16), (s & 192) === 128 && (l & 192) === 128 && (u & 192) === 128)) {
        c = a << 18 & 1835008 | s << 12 & 258048 | l << 6 & 4032 | u & 63, c < 65536 || c > 1114111 ? h += "����" : (c -= 65536, h += String.fromCharCode(55296 + (c >> 10), 56320 + (c & 1023))), i += 9;
        continue;
      }
      h += "�";
    }
    return h;
  });
}
nC.defaultChars = ";/?:@&=+$,#";
nC.componentChars = "";
var omt = nC, amt = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function tS() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var smt = /^([a-z0-9.+-]+:)/i, lmt = /:[0-9]*$/, umt = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, cmt = ["<", ">", '"', "`", " ", "\r", `
`, "	"], hmt = ["{", "}", "|", "\\", "^", "`"].concat(cmt), fmt = ["'"].concat(hmt), w4 = ["%", "/", "?", ";", "#"].concat(fmt), x4 = ["/", "?", "#"], dmt = 255, S4 = /^[+a-z0-9A-Z_-]{0,63}$/, pmt = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, _4 = {
  javascript: !0,
  "javascript:": !0
}, C4 = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function gmt(n, e) {
  if (n && n instanceof tS)
    return n;
  var t = new tS();
  return t.parse(n, e), t;
}
tS.prototype.parse = function(n, e) {
  var t, r, i, o, a, s = n;
  if (s = s.trim(), !e && n.split("#").length === 1) {
    var l = umt.exec(s);
    if (l)
      return this.pathname = l[1], l[2] && (this.search = l[2]), this;
  }
  var u = smt.exec(s);
  if (u && (u = u[0], i = u.toLowerCase(), this.protocol = u, s = s.substr(u.length)), (e || u || s.match(/^\/\/[^@\/]+@[^@\/]+/)) && (a = s.substr(0, 2) === "//", a && !(u && _4[u]) && (s = s.substr(2), this.slashes = !0)), !_4[u] && (a || u && !C4[u])) {
    var c = -1;
    for (t = 0; t < x4.length; t++)
      o = s.indexOf(x4[t]), o !== -1 && (c === -1 || o < c) && (c = o);
    var h, f;
    for (c === -1 ? f = s.lastIndexOf("@") : f = s.lastIndexOf("@", c), f !== -1 && (h = s.slice(0, f), s = s.slice(f + 1), this.auth = h), c = -1, t = 0; t < w4.length; t++)
      o = s.indexOf(w4[t]), o !== -1 && (c === -1 || o < c) && (c = o);
    c === -1 && (c = s.length), s[c - 1] === ":" && c--;
    var d = s.slice(0, c);
    s = s.slice(c), this.parseHost(d), this.hostname = this.hostname || "";
    var p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      var g = this.hostname.split(/\./);
      for (t = 0, r = g.length; t < r; t++) {
        var v = g[t];
        if (v && !v.match(S4)) {
          for (var m = "", y = 0, b = v.length; y < b; y++)
            v.charCodeAt(y) > 127 ? m += "x" : m += v[y];
          if (!m.match(S4)) {
            var O = g.slice(0, t), w = g.slice(t + 1), x = v.match(pmt);
            x && (O.push(x[1]), w.unshift(x[2])), w.length && (s = w.join(".") + s), this.hostname = O.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > dmt && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var S = s.indexOf("#");
  S !== -1 && (this.hash = s.substr(S), s = s.slice(0, S));
  var _ = s.indexOf("?");
  return _ !== -1 && (this.search = s.substr(_), s = s.slice(0, _)), s && (this.pathname = s), C4[i] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
tS.prototype.parseHost = function(n) {
  var e = lmt.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var vmt = gmt;
Cv.encode = rmt;
Cv.decode = omt;
Cv.format = amt;
Cv.parse = vmt;
var bh = {}, eA, A4;
function KU() {
  return A4 || (A4 = 1, eA = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), eA;
}
var tA, T4;
function JU() {
  return T4 || (T4 = 1, tA = /[\0-\x1F\x7F-\x9F]/), tA;
}
var nA, k4;
function mmt() {
  return k4 || (k4 = 1, nA = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), nA;
}
var rA, P4;
function eK() {
  return P4 || (P4 = 1, rA = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), rA;
}
var E4;
function ymt() {
  return E4 || (E4 = 1, bh.Any = KU(), bh.Cc = JU(), bh.Cf = mmt(), bh.P = iR, bh.Z = eK()), bh;
}
(function(n) {
  function e(D) {
    return Object.prototype.toString.call(D);
  }
  function t(D) {
    return e(D) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function i(D, E) {
    return r.call(D, E);
  }
  function o(D) {
    var E = Array.prototype.slice.call(arguments, 1);
    return E.forEach(function(M) {
      if (M) {
        if (typeof M != "object")
          throw new TypeError(M + "must be object");
        Object.keys(M).forEach(function(R) {
          D[R] = M[R];
        });
      }
    }), D;
  }
  function a(D, E, M) {
    return [].concat(D.slice(0, E), M, D.slice(E + 1));
  }
  function s(D) {
    return !(D >= 55296 && D <= 57343 || D >= 64976 && D <= 65007 || (D & 65535) === 65535 || (D & 65535) === 65534 || D >= 0 && D <= 8 || D === 11 || D >= 14 && D <= 31 || D >= 127 && D <= 159 || D > 1114111);
  }
  function l(D) {
    if (D > 65535) {
      D -= 65536;
      var E = 55296 + (D >> 10), M = 56320 + (D & 1023);
      return String.fromCharCode(E, M);
    }
    return String.fromCharCode(D);
  }
  var u = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, c = /&([a-z#][a-z0-9]{1,31});/gi, h = new RegExp(u.source + "|" + c.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i, d = UU;
  function p(D, E) {
    var M;
    return i(d, E) ? d[E] : E.charCodeAt(0) === 35 && f.test(E) && (M = E[1].toLowerCase() === "x" ? parseInt(E.slice(2), 16) : parseInt(E.slice(1), 10), s(M)) ? l(M) : D;
  }
  function g(D) {
    return D.indexOf("\\") < 0 ? D : D.replace(u, "$1");
  }
  function v(D) {
    return D.indexOf("\\") < 0 && D.indexOf("&") < 0 ? D : D.replace(h, function(E, M, R) {
      return M || p(E, R);
    });
  }
  var m = /[&<>"]/, y = /[&<>"]/g, b = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function O(D) {
    return b[D];
  }
  function w(D) {
    return m.test(D) ? D.replace(y, O) : D;
  }
  var x = /[.?*+^$[\]\\(){}|-]/g;
  function S(D) {
    return D.replace(x, "\\$&");
  }
  function _(D) {
    switch (D) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function C(D) {
    if (D >= 8192 && D <= 8202)
      return !0;
    switch (D) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var A = iR;
  function k(D) {
    return A.test(D);
  }
  function P(D) {
    switch (D) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function L(D) {
    return D = D.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (D = D.replace(/ẞ/g, "ß")), D.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = Cv, n.lib.ucmicro = ymt(), n.assign = o, n.isString = t, n.has = i, n.unescapeMd = g, n.unescapeAll = v, n.isValidEntityCode = s, n.fromCodePoint = l, n.escapeHtml = w, n.arrayReplaceAt = a, n.isSpace = _, n.isWhiteSpace = C, n.isMdAsciiPunct = P, n.isPunctChar = k, n.escapeRE = S, n.normalizeReference = L;
})(sn);
var rC = {}, bmt = function(e, t, r) {
  var i, o, a, s, l = -1, u = e.posMax, c = e.pos;
  for (e.pos = t + 1, i = 1; e.pos < u; ) {
    if (a = e.src.charCodeAt(e.pos), a === 93 && (i--, i === 0)) {
      o = !0;
      break;
    }
    if (s = e.pos, e.md.inline.skipToken(e), a === 91) {
      if (s === e.pos - 1)
        i++;
      else if (r)
        return e.pos = c, -1;
    }
  }
  return o && (l = e.pos), e.pos = c, l;
}, M4 = sn.unescapeAll, Omt = function(e, t, r) {
  var i, o, a = t, s = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(a) === 60) {
    for (a++; a < r; ) {
      if (i = e.charCodeAt(a), i === 10 || i === 60)
        return s;
      if (i === 62)
        return s.pos = a + 1, s.str = M4(e.slice(t + 1, a)), s.ok = !0, s;
      if (i === 92 && a + 1 < r) {
        a += 2;
        continue;
      }
      a++;
    }
    return s;
  }
  for (o = 0; a < r && (i = e.charCodeAt(a), !(i === 32 || i < 32 || i === 127)); ) {
    if (i === 92 && a + 1 < r) {
      if (e.charCodeAt(a + 1) === 32)
        break;
      a += 2;
      continue;
    }
    if (i === 40 && (o++, o > 32))
      return s;
    if (i === 41) {
      if (o === 0)
        break;
      o--;
    }
    a++;
  }
  return t === a || o !== 0 || (s.str = M4(e.slice(t, a)), s.pos = a, s.ok = !0), s;
}, wmt = sn.unescapeAll, xmt = function(e, t, r) {
  var i, o, a = 0, s = t, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (s >= r || (o = e.charCodeAt(s), o !== 34 && o !== 39 && o !== 40))
    return l;
  for (s++, o === 40 && (o = 41); s < r; ) {
    if (i = e.charCodeAt(s), i === o)
      return l.pos = s + 1, l.lines = a, l.str = wmt(e.slice(t + 1, s)), l.ok = !0, l;
    if (i === 40 && o === 41)
      return l;
    i === 10 ? a++ : i === 92 && s + 1 < r && (s++, e.charCodeAt(s) === 10 && a++), s++;
  }
  return l;
};
rC.parseLinkLabel = bmt;
rC.parseLinkDestination = Omt;
rC.parseLinkTitle = xmt;
var Smt = sn.assign, _mt = sn.unescapeAll, ld = sn.escapeHtml, Dl = {};
Dl.code_inline = function(n, e, t, r, i) {
  var o = n[e];
  return "<code" + i.renderAttrs(o) + ">" + ld(o.content) + "</code>";
};
Dl.code_block = function(n, e, t, r, i) {
  var o = n[e];
  return "<pre" + i.renderAttrs(o) + "><code>" + ld(n[e].content) + `</code></pre>
`;
};
Dl.fence = function(n, e, t, r, i) {
  var o = n[e], a = o.info ? _mt(o.info).trim() : "", s = "", l = "", u, c, h, f, d;
  return a && (h = a.split(/(\s+)/g), s = h[0], l = h.slice(2).join("")), t.highlight ? u = t.highlight(o.content, s, l) || ld(o.content) : u = ld(o.content), u.indexOf("<pre") === 0 ? u + `
` : a ? (c = o.attrIndex("class"), f = o.attrs ? o.attrs.slice() : [], c < 0 ? f.push(["class", t.langPrefix + s]) : (f[c] = f[c].slice(), f[c][1] += " " + t.langPrefix + s), d = {
    attrs: f
  }, "<pre><code" + i.renderAttrs(d) + ">" + u + `</code></pre>
`) : "<pre><code" + i.renderAttrs(o) + ">" + u + `</code></pre>
`;
};
Dl.image = function(n, e, t, r, i) {
  var o = n[e];
  return o.attrs[o.attrIndex("alt")][1] = i.renderInlineAsText(o.children, t, r), i.renderToken(n, e, t);
};
Dl.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
Dl.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Dl.text = function(n, e) {
  return ld(n[e].content);
};
Dl.html_block = function(n, e) {
  return n[e].content;
};
Dl.html_inline = function(n, e) {
  return n[e].content;
};
function Av() {
  this.rules = Smt({}, Dl);
}
Av.prototype.renderAttrs = function(e) {
  var t, r, i;
  if (!e.attrs)
    return "";
  for (i = "", t = 0, r = e.attrs.length; t < r; t++)
    i += " " + ld(e.attrs[t][0]) + '="' + ld(e.attrs[t][1]) + '"';
  return i;
};
Av.prototype.renderToken = function(e, t, r) {
  var i, o = "", a = !1, s = e[t];
  return s.hidden ? "" : (s.block && s.nesting !== -1 && t && e[t - 1].hidden && (o += `
`), o += (s.nesting === -1 ? "</" : "<") + s.tag, o += this.renderAttrs(s), s.nesting === 0 && r.xhtmlOut && (o += " /"), s.block && (a = !0, s.nesting === 1 && t + 1 < e.length && (i = e[t + 1], (i.type === "inline" || i.hidden || i.nesting === -1 && i.tag === s.tag) && (a = !1))), o += a ? `>
` : ">", o);
};
Av.prototype.renderInline = function(n, e, t) {
  for (var r, i = "", o = this.rules, a = 0, s = n.length; a < s; a++)
    r = n[a].type, typeof o[r] < "u" ? i += o[r](n, a, e, t, this) : i += this.renderToken(n, a, e);
  return i;
};
Av.prototype.renderInlineAsText = function(n, e, t) {
  for (var r = "", i = 0, o = n.length; i < o; i++)
    n[i].type === "text" ? r += n[i].content : n[i].type === "image" ? r += this.renderInlineAsText(n[i].children, e, t) : n[i].type === "softbreak" && (r += `
`);
  return r;
};
Av.prototype.render = function(n, e, t) {
  var r, i, o, a = "", s = this.rules;
  for (r = 0, i = n.length; r < i; r++)
    o = n[r].type, o === "inline" ? a += this.renderInline(n[r].children, e, t) : typeof s[o] < "u" ? a += s[o](n, r, e, t, this) : a += this.renderToken(n, r, e, t);
  return a;
};
var Cmt = Av;
function _s() {
  this.__rules__ = [], this.__cache__ = null;
}
_s.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
_s.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(r) {
      r.enabled && (t && r.alt.indexOf(t) < 0 || n.__cache__[t].push(r.fn));
    });
  });
};
_s.prototype.at = function(n, e, t) {
  var r = this.__find__(n), i = t || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[r].fn = e, this.__rules__[r].alt = i.alt || [], this.__cache__ = null;
};
_s.prototype.before = function(n, e, t, r) {
  var i = this.__find__(n), o = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(i, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: o.alt || []
  }), this.__cache__ = null;
};
_s.prototype.after = function(n, e, t, r) {
  var i = this.__find__(n), o = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(i + 1, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: o.alt || []
  }), this.__cache__ = null;
};
_s.prototype.push = function(n, e, t) {
  var r = t || {};
  this.__rules__.push({
    name: n,
    enabled: !0,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
_s.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var i = this.__find__(r);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !0, t.push(r);
  }, this), this.__cache__ = null, t;
};
_s.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = !1;
  }), this.enable(n, e);
};
_s.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var i = this.__find__(r);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !1, t.push(r);
  }, this), this.__cache__ = null, t;
};
_s.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var oR = _s, Amt = /\r\n?|\n/g, Tmt = /\0/g, kmt = function(e) {
  var t;
  t = e.src.replace(Amt, `
`), t = t.replace(Tmt, "�"), e.src = t;
}, Pmt = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, Emt = function(e) {
  var t = e.tokens, r, i, o;
  for (i = 0, o = t.length; i < o; i++)
    r = t[i], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
}, Mmt = sn.arrayReplaceAt;
function Dmt(n) {
  return /^<a[>\s]/i.test(n);
}
function Lmt(n) {
  return /^<\/a\s*>/i.test(n);
}
var Imt = function(e) {
  var t, r, i, o, a, s, l, u, c, h, f, d, p, g, v, m, y = e.tokens, b;
  if (e.md.options.linkify) {
    for (r = 0, i = y.length; r < i; r++)
      if (!(y[r].type !== "inline" || !e.md.linkify.pretest(y[r].content)))
        for (o = y[r].children, p = 0, t = o.length - 1; t >= 0; t--) {
          if (s = o[t], s.type === "link_close") {
            for (t--; o[t].level !== s.level && o[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (s.type === "html_inline" && (Dmt(s.content) && p > 0 && p--, Lmt(s.content) && p++), !(p > 0) && s.type === "text" && e.md.linkify.test(s.content)) {
            for (c = s.content, b = e.md.linkify.match(c), l = [], d = s.level, f = 0, b.length > 0 && b[0].index === 0 && t > 0 && o[t - 1].type === "text_special" && (b = b.slice(1)), u = 0; u < b.length; u++)
              g = b[u].url, v = e.md.normalizeLink(g), e.md.validateLink(v) && (m = b[u].text, b[u].schema ? b[u].schema === "mailto:" && !/^mailto:/i.test(m) ? m = e.md.normalizeLinkText("mailto:" + m).replace(/^mailto:/, "") : m = e.md.normalizeLinkText(m) : m = e.md.normalizeLinkText("http://" + m).replace(/^http:\/\//, ""), h = b[u].index, h > f && (a = new e.Token("text", "", 0), a.content = c.slice(f, h), a.level = d, l.push(a)), a = new e.Token("link_open", "a", 1), a.attrs = [["href", v]], a.level = d++, a.markup = "linkify", a.info = "auto", l.push(a), a = new e.Token("text", "", 0), a.content = m, a.level = d, l.push(a), a = new e.Token("link_close", "a", -1), a.level = --d, a.markup = "linkify", a.info = "auto", l.push(a), f = b[u].lastIndex);
            f < c.length && (a = new e.Token("text", "", 0), a.content = c.slice(f), a.level = d, l.push(a)), y[r].children = o = Mmt(o, t, l);
          }
        }
  }
}, tK = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, Rmt = /\((c|tm|r)\)/i, Nmt = /\((c|tm|r)\)/ig, $mt = {
  c: "©",
  r: "®",
  tm: "™"
};
function Bmt(n, e) {
  return $mt[e.toLowerCase()];
}
function Vmt(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && (t.content = t.content.replace(Nmt, Bmt)), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
function zmt(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && tK.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
var Fmt = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (Rmt.test(e.tokens[t].content) && Vmt(e.tokens[t].children), tK.test(e.tokens[t].content) && zmt(e.tokens[t].children));
}, D4 = sn.isWhiteSpace, L4 = sn.isPunctChar, I4 = sn.isMdAsciiPunct, Qmt = /['"]/, R4 = /['"]/g, N4 = "’";
function j1(n, e, t) {
  return n.slice(0, e) + t + n.slice(e + 1);
}
function Zmt(n, e) {
  var t, r, i, o, a, s, l, u, c, h, f, d, p, g, v, m, y, b, O, w, x;
  for (O = [], t = 0; t < n.length; t++) {
    for (r = n[t], l = n[t].level, y = O.length - 1; y >= 0 && !(O[y].level <= l); y--)
      ;
    if (O.length = y + 1, r.type === "text") {
      i = r.content, a = 0, s = i.length;
      e:
        for (; a < s && (R4.lastIndex = a, o = R4.exec(i), !!o); ) {
          if (v = m = !0, a = o.index + 1, b = o[0] === "'", c = 32, o.index - 1 >= 0)
            c = i.charCodeAt(o.index - 1);
          else
            for (y = t - 1; y >= 0 && !(n[y].type === "softbreak" || n[y].type === "hardbreak"); y--)
              if (n[y].content) {
                c = n[y].content.charCodeAt(n[y].content.length - 1);
                break;
              }
          if (h = 32, a < s)
            h = i.charCodeAt(a);
          else
            for (y = t + 1; y < n.length && !(n[y].type === "softbreak" || n[y].type === "hardbreak"); y++)
              if (n[y].content) {
                h = n[y].content.charCodeAt(0);
                break;
              }
          if (f = I4(c) || L4(String.fromCharCode(c)), d = I4(h) || L4(String.fromCharCode(h)), p = D4(c), g = D4(h), g ? v = !1 : d && (p || f || (v = !1)), p ? m = !1 : f && (g || d || (m = !1)), h === 34 && o[0] === '"' && c >= 48 && c <= 57 && (m = v = !1), v && m && (v = f, m = d), !v && !m) {
            b && (r.content = j1(r.content, o.index, N4));
            continue;
          }
          if (m) {
            for (y = O.length - 1; y >= 0 && (u = O[y], !(O[y].level < l)); y--)
              if (u.single === b && O[y].level === l) {
                u = O[y], b ? (w = e.md.options.quotes[2], x = e.md.options.quotes[3]) : (w = e.md.options.quotes[0], x = e.md.options.quotes[1]), r.content = j1(r.content, o.index, x), n[u.token].content = j1(
                  n[u.token].content,
                  u.pos,
                  w
                ), a += x.length - 1, u.token === t && (a += w.length - 1), i = r.content, s = i.length, O.length = y;
                continue e;
              }
          }
          v ? O.push({
            token: t,
            pos: o.index,
            single: b,
            level: l
          }) : m && b && (r.content = j1(r.content, o.index, N4));
        }
    }
  }
}
var Wmt = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !Qmt.test(e.tokens[t].content) || Zmt(e.tokens[t].children, e);
}, Gmt = function(e) {
  var t, r, i, o, a, s, l = e.tokens;
  for (t = 0, r = l.length; t < r; t++)
    if (l[t].type === "inline") {
      for (i = l[t].children, a = i.length, o = 0; o < a; o++)
        i[o].type === "text_special" && (i[o].type = "text");
      for (o = s = 0; o < a; o++)
        i[o].type === "text" && o + 1 < a && i[o + 1].type === "text" ? i[o + 1].content = i[o].content + i[o + 1].content : (o !== s && (i[s] = i[o]), s++);
      o !== s && (i.length = s);
    }
};
function Tv(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Tv.prototype.attrIndex = function(e) {
  var t, r, i;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, r = 0, i = t.length; r < i; r++)
    if (t[r][0] === e)
      return r;
  return -1;
};
Tv.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Tv.prototype.attrSet = function(e, t) {
  var r = this.attrIndex(e), i = [e, t];
  r < 0 ? this.attrPush(i) : this.attrs[r] = i;
};
Tv.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), r = null;
  return t >= 0 && (r = this.attrs[t][1]), r;
};
Tv.prototype.attrJoin = function(e, t) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, t]) : this.attrs[r][1] = this.attrs[r][1] + " " + t;
};
var aR = Tv, jmt = aR;
function nK(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
}
nK.prototype.Token = jmt;
var Hmt = nK, qmt = oR, iA = [
  ["normalize", kmt],
  ["block", Pmt],
  ["inline", Emt],
  ["linkify", Imt],
  ["replacements", Fmt],
  ["smartquotes", Wmt],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", Gmt]
];
function sR() {
  this.ruler = new qmt();
  for (var n = 0; n < iA.length; n++)
    this.ruler.push(iA[n][0], iA[n][1]);
}
sR.prototype.process = function(n) {
  var e, t, r;
  for (r = this.ruler.getRules(""), e = 0, t = r.length; e < t; e++)
    r[e](n);
};
sR.prototype.State = Hmt;
var Ymt = sR, oA = sn.isSpace;
function aA(n, e) {
  var t = n.bMarks[e] + n.tShift[e], r = n.eMarks[e];
  return n.src.slice(t, r);
}
function $4(n) {
  var e = [], t = 0, r = n.length, i, o = !1, a = 0, s = "";
  for (i = n.charCodeAt(t); t < r; )
    i === 124 && (o ? (s += n.substring(a, t - 1), a = t) : (e.push(s + n.substring(a, t)), s = "", a = t + 1)), o = i === 92, t++, i = n.charCodeAt(t);
  return e.push(s + n.substring(a)), e;
}
var Xmt = function(e, t, r, i) {
  var o, a, s, l, u, c, h, f, d, p, g, v, m, y, b, O, w, x;
  if (t + 2 > r || (c = t + 1, e.sCount[c] < e.blkIndent) || e.sCount[c] - e.blkIndent >= 4 || (s = e.bMarks[c] + e.tShift[c], s >= e.eMarks[c]) || (w = e.src.charCodeAt(s++), w !== 124 && w !== 45 && w !== 58) || s >= e.eMarks[c] || (x = e.src.charCodeAt(s++), x !== 124 && x !== 45 && x !== 58 && !oA(x)) || w === 45 && oA(x))
    return !1;
  for (; s < e.eMarks[c]; ) {
    if (o = e.src.charCodeAt(s), o !== 124 && o !== 45 && o !== 58 && !oA(o))
      return !1;
    s++;
  }
  for (a = aA(e, t + 1), h = a.split("|"), p = [], l = 0; l < h.length; l++) {
    if (g = h[l].trim(), !g) {
      if (l === 0 || l === h.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(g))
      return !1;
    g.charCodeAt(g.length - 1) === 58 ? p.push(g.charCodeAt(0) === 58 ? "center" : "right") : g.charCodeAt(0) === 58 ? p.push("left") : p.push("");
  }
  if (a = aA(e, t).trim(), a.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (h = $4(a), h.length && h[0] === "" && h.shift(), h.length && h[h.length - 1] === "" && h.pop(), f = h.length, f === 0 || f !== p.length))
    return !1;
  if (i)
    return !0;
  for (y = e.parentType, e.parentType = "table", O = e.md.block.ruler.getRules("blockquote"), d = e.push("table_open", "table", 1), d.map = v = [t, 0], d = e.push("thead_open", "thead", 1), d.map = [t, t + 1], d = e.push("tr_open", "tr", 1), d.map = [t, t + 1], l = 0; l < h.length; l++)
    d = e.push("th_open", "th", 1), p[l] && (d.attrs = [["style", "text-align:" + p[l]]]), d = e.push("inline", "", 0), d.content = h[l].trim(), d.children = [], d = e.push("th_close", "th", -1);
  for (d = e.push("tr_close", "tr", -1), d = e.push("thead_close", "thead", -1), c = t + 2; c < r && !(e.sCount[c] < e.blkIndent); c++) {
    for (b = !1, l = 0, u = O.length; l < u; l++)
      if (O[l](e, c, r, !0)) {
        b = !0;
        break;
      }
    if (b || (a = aA(e, c).trim(), !a) || e.sCount[c] - e.blkIndent >= 4)
      break;
    for (h = $4(a), h.length && h[0] === "" && h.shift(), h.length && h[h.length - 1] === "" && h.pop(), c === t + 2 && (d = e.push("tbody_open", "tbody", 1), d.map = m = [t + 2, 0]), d = e.push("tr_open", "tr", 1), d.map = [c, c + 1], l = 0; l < f; l++)
      d = e.push("td_open", "td", 1), p[l] && (d.attrs = [["style", "text-align:" + p[l]]]), d = e.push("inline", "", 0), d.content = h[l] ? h[l].trim() : "", d.children = [], d = e.push("td_close", "td", -1);
    d = e.push("tr_close", "tr", -1);
  }
  return m && (d = e.push("tbody_close", "tbody", -1), m[1] = c), d = e.push("table_close", "table", -1), v[1] = c, e.parentType = y, e.line = c, !0;
}, Umt = function(e, t, r) {
  var i, o, a;
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  for (o = i = t + 1; i < r; ) {
    if (e.isEmpty(i)) {
      i++;
      continue;
    }
    if (e.sCount[i] - e.blkIndent >= 4) {
      i++, o = i;
      continue;
    }
    break;
  }
  return e.line = o, a = e.push("code_block", "code", 0), a.content = e.getLines(t, o, 4 + e.blkIndent, !1) + `
`, a.map = [t, e.line], !0;
}, Kmt = function(e, t, r, i) {
  var o, a, s, l, u, c, h, f = !1, d = e.bMarks[t] + e.tShift[t], p = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || d + 3 > p || (o = e.src.charCodeAt(d), o !== 126 && o !== 96) || (u = d, d = e.skipChars(d, o), a = d - u, a < 3) || (h = e.src.slice(u, d), s = e.src.slice(d, p), o === 96 && s.indexOf(String.fromCharCode(o)) >= 0))
    return !1;
  if (i)
    return !0;
  for (l = t; l++, !(l >= r || (d = u = e.bMarks[l] + e.tShift[l], p = e.eMarks[l], d < p && e.sCount[l] < e.blkIndent)); )
    if (e.src.charCodeAt(d) === o && !(e.sCount[l] - e.blkIndent >= 4) && (d = e.skipChars(d, o), !(d - u < a) && (d = e.skipSpaces(d), !(d < p)))) {
      f = !0;
      break;
    }
  return a = e.sCount[t], e.line = l + (f ? 1 : 0), c = e.push("fence", "code", 0), c.info = s, c.content = e.getLines(t + 1, l, a, !0), c.markup = h, c.map = [t, e.line], !0;
}, Jmt = sn.isSpace, eyt = function(e, t, r, i) {
  var o, a, s, l, u, c, h, f, d, p, g, v, m, y, b, O, w, x, S, _, C = e.lineMax, A = e.bMarks[t] + e.tShift[t], k = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(A) !== 62)
    return !1;
  if (i)
    return !0;
  for (p = [], g = [], y = [], b = [], x = e.md.block.ruler.getRules("blockquote"), m = e.parentType, e.parentType = "blockquote", f = t; f < r && (_ = e.sCount[f] < e.blkIndent, A = e.bMarks[f] + e.tShift[f], k = e.eMarks[f], !(A >= k)); f++) {
    if (e.src.charCodeAt(A++) === 62 && !_) {
      for (l = e.sCount[f] + 1, e.src.charCodeAt(A) === 32 ? (A++, l++, o = !1, O = !0) : e.src.charCodeAt(A) === 9 ? (O = !0, (e.bsCount[f] + l) % 4 === 3 ? (A++, l++, o = !1) : o = !0) : O = !1, d = l, p.push(e.bMarks[f]), e.bMarks[f] = A; A < k && (a = e.src.charCodeAt(A), Jmt(a)); ) {
        a === 9 ? d += 4 - (d + e.bsCount[f] + (o ? 1 : 0)) % 4 : d++;
        A++;
      }
      c = A >= k, g.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (O ? 1 : 0), y.push(e.sCount[f]), e.sCount[f] = d - l, b.push(e.tShift[f]), e.tShift[f] = A - e.bMarks[f];
      continue;
    }
    if (c)
      break;
    for (w = !1, s = 0, u = x.length; s < u; s++)
      if (x[s](e, f, r, !0)) {
        w = !0;
        break;
      }
    if (w) {
      e.lineMax = f, e.blkIndent !== 0 && (p.push(e.bMarks[f]), g.push(e.bsCount[f]), b.push(e.tShift[f]), y.push(e.sCount[f]), e.sCount[f] -= e.blkIndent);
      break;
    }
    p.push(e.bMarks[f]), g.push(e.bsCount[f]), b.push(e.tShift[f]), y.push(e.sCount[f]), e.sCount[f] = -1;
  }
  for (v = e.blkIndent, e.blkIndent = 0, S = e.push("blockquote_open", "blockquote", 1), S.markup = ">", S.map = h = [t, 0], e.md.block.tokenize(e, t, f), S = e.push("blockquote_close", "blockquote", -1), S.markup = ">", e.lineMax = C, e.parentType = m, h[1] = e.line, s = 0; s < b.length; s++)
    e.bMarks[s + t] = p[s], e.tShift[s + t] = b[s], e.sCount[s + t] = y[s], e.bsCount[s + t] = g[s];
  return e.blkIndent = v, !0;
}, tyt = sn.isSpace, nyt = function(e, t, r, i) {
  var o, a, s, l, u = e.bMarks[t] + e.tShift[t], c = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (o = e.src.charCodeAt(u++), o !== 42 && o !== 45 && o !== 95))
    return !1;
  for (a = 1; u < c; ) {
    if (s = e.src.charCodeAt(u++), s !== o && !tyt(s))
      return !1;
    s === o && a++;
  }
  return a < 3 ? !1 : (i || (e.line = t + 1, l = e.push("hr", "hr", 0), l.map = [t, e.line], l.markup = Array(a + 1).join(String.fromCharCode(o))), !0);
}, rK = sn.isSpace;
function B4(n, e) {
  var t, r, i, o;
  return r = n.bMarks[e] + n.tShift[e], i = n.eMarks[e], t = n.src.charCodeAt(r++), t !== 42 && t !== 45 && t !== 43 || r < i && (o = n.src.charCodeAt(r), !rK(o)) ? -1 : r;
}
function V4(n, e) {
  var t, r = n.bMarks[e] + n.tShift[e], i = r, o = n.eMarks[e];
  if (i + 1 >= o || (t = n.src.charCodeAt(i++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (i >= o)
      return -1;
    if (t = n.src.charCodeAt(i++), t >= 48 && t <= 57) {
      if (i - r >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return i < o && (t = n.src.charCodeAt(i), !rK(t)) ? -1 : i;
}
function ryt(n, e) {
  var t, r, i = n.level + 2;
  for (t = e + 2, r = n.tokens.length - 2; t < r; t++)
    n.tokens[t].level === i && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = !0, n.tokens[t].hidden = !0, t += 2);
}
var iyt = function(e, t, r, i) {
  var o, a, s, l, u, c, h, f, d, p, g, v, m, y, b, O, w, x, S, _, C, A, k, P, L, D, E, M = t, R = !1, N = !0;
  if (e.sCount[M] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[M] - e.listIndent >= 4 && e.sCount[M] < e.blkIndent)
    return !1;
  if (i && e.parentType === "paragraph" && e.sCount[M] >= e.blkIndent && (R = !0), (A = V4(e, M)) >= 0) {
    if (h = !0, P = e.bMarks[M] + e.tShift[M], m = Number(e.src.slice(P, A - 1)), R && m !== 1)
      return !1;
  } else if ((A = B4(e, M)) >= 0)
    h = !1;
  else
    return !1;
  if (R && e.skipSpaces(A) >= e.eMarks[M])
    return !1;
  if (i)
    return !0;
  for (v = e.src.charCodeAt(A - 1), g = e.tokens.length, h ? (E = e.push("ordered_list_open", "ol", 1), m !== 1 && (E.attrs = [["start", m]])) : E = e.push("bullet_list_open", "ul", 1), E.map = p = [M, 0], E.markup = String.fromCharCode(v), k = !1, D = e.md.block.ruler.getRules("list"), w = e.parentType, e.parentType = "list"; M < r; ) {
    for (C = A, y = e.eMarks[M], c = b = e.sCount[M] + A - (e.bMarks[M] + e.tShift[M]); C < y; ) {
      if (o = e.src.charCodeAt(C), o === 9)
        b += 4 - (b + e.bsCount[M]) % 4;
      else if (o === 32)
        b++;
      else
        break;
      C++;
    }
    if (a = C, a >= y ? u = 1 : u = b - c, u > 4 && (u = 1), l = c + u, E = e.push("list_item_open", "li", 1), E.markup = String.fromCharCode(v), E.map = f = [M, 0], h && (E.info = e.src.slice(P, A - 1)), _ = e.tight, S = e.tShift[M], x = e.sCount[M], O = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = l, e.tight = !0, e.tShift[M] = a - e.bMarks[M], e.sCount[M] = b, a >= y && e.isEmpty(M + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, M, r, !0), (!e.tight || k) && (N = !1), k = e.line - M > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = O, e.tShift[M] = S, e.sCount[M] = x, e.tight = _, E = e.push("list_item_close", "li", -1), E.markup = String.fromCharCode(v), M = e.line, f[1] = M, M >= r || e.sCount[M] < e.blkIndent || e.sCount[M] - e.blkIndent >= 4)
      break;
    for (L = !1, s = 0, d = D.length; s < d; s++)
      if (D[s](e, M, r, !0)) {
        L = !0;
        break;
      }
    if (L)
      break;
    if (h) {
      if (A = V4(e, M), A < 0)
        break;
      P = e.bMarks[M] + e.tShift[M];
    } else if (A = B4(e, M), A < 0)
      break;
    if (v !== e.src.charCodeAt(A - 1))
      break;
  }
  return h ? E = e.push("ordered_list_close", "ol", -1) : E = e.push("bullet_list_close", "ul", -1), E.markup = String.fromCharCode(v), p[1] = M, e.line = M, e.parentType = w, N && ryt(e, g), !0;
}, oyt = sn.normalizeReference, H1 = sn.isSpace, ayt = function(e, t, r, i) {
  var o, a, s, l, u, c, h, f, d, p, g, v, m, y, b, O, w = 0, x = e.bMarks[t] + e.tShift[t], S = e.eMarks[t], _ = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(x) !== 91)
    return !1;
  for (; ++x < S; )
    if (e.src.charCodeAt(x) === 93 && e.src.charCodeAt(x - 1) !== 92) {
      if (x + 1 === S || e.src.charCodeAt(x + 1) !== 58)
        return !1;
      break;
    }
  for (l = e.lineMax, b = e.md.block.ruler.getRules("reference"), p = e.parentType, e.parentType = "reference"; _ < l && !e.isEmpty(_); _++)
    if (!(e.sCount[_] - e.blkIndent > 3) && !(e.sCount[_] < 0)) {
      for (y = !1, c = 0, h = b.length; c < h; c++)
        if (b[c](e, _, l, !0)) {
          y = !0;
          break;
        }
      if (y)
        break;
    }
  for (m = e.getLines(t, _, e.blkIndent, !1).trim(), S = m.length, x = 1; x < S; x++) {
    if (o = m.charCodeAt(x), o === 91)
      return !1;
    if (o === 93) {
      d = x;
      break;
    } else
      o === 10 ? w++ : o === 92 && (x++, x < S && m.charCodeAt(x) === 10 && w++);
  }
  if (d < 0 || m.charCodeAt(d + 1) !== 58)
    return !1;
  for (x = d + 2; x < S; x++)
    if (o = m.charCodeAt(x), o === 10)
      w++;
    else if (!H1(o))
      break;
  if (g = e.md.helpers.parseLinkDestination(m, x, S), !g.ok || (u = e.md.normalizeLink(g.str), !e.md.validateLink(u)))
    return !1;
  for (x = g.pos, w += g.lines, a = x, s = w, v = x; x < S; x++)
    if (o = m.charCodeAt(x), o === 10)
      w++;
    else if (!H1(o))
      break;
  for (g = e.md.helpers.parseLinkTitle(m, x, S), x < S && v !== x && g.ok ? (O = g.str, x = g.pos, w += g.lines) : (O = "", x = a, w = s); x < S && (o = m.charCodeAt(x), !!H1(o)); )
    x++;
  if (x < S && m.charCodeAt(x) !== 10 && O)
    for (O = "", x = a, w = s; x < S && (o = m.charCodeAt(x), !!H1(o)); )
      x++;
  return x < S && m.charCodeAt(x) !== 10 || (f = oyt(m.slice(1, d)), !f) ? !1 : (i || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: O, href: u }), e.parentType = p, e.line = t + w + 1), !0);
}, syt = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], iC = {}, lyt = "[a-zA-Z_:][a-zA-Z0-9:._-]*", uyt = "[^\"'=<>`\\x00-\\x20]+", cyt = "'[^']*'", hyt = '"[^"]*"', fyt = "(?:" + uyt + "|" + cyt + "|" + hyt + ")", dyt = "(?:\\s+" + lyt + "(?:\\s*=\\s*" + fyt + ")?)", iK = "<[A-Za-z][A-Za-z0-9\\-]*" + dyt + "*\\s*\\/?>", oK = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", pyt = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", gyt = "<[?][\\s\\S]*?[?]>", vyt = "<![A-Z]+\\s+[^>]*>", myt = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", yyt = new RegExp("^(?:" + iK + "|" + oK + "|" + pyt + "|" + gyt + "|" + vyt + "|" + myt + ")"), byt = new RegExp("^(?:" + iK + "|" + oK + ")");
iC.HTML_TAG_RE = yyt;
iC.HTML_OPEN_CLOSE_TAG_RE = byt;
var Oyt = syt, wyt = iC.HTML_OPEN_CLOSE_TAG_RE, qd = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + Oyt.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(wyt.source + "\\s*$"), /^$/, !1]
], xyt = function(e, t, r, i) {
  var o, a, s, l, u = e.bMarks[t] + e.tShift[t], c = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(u) !== 60)
    return !1;
  for (l = e.src.slice(u, c), o = 0; o < qd.length && !qd[o][0].test(l); o++)
    ;
  if (o === qd.length)
    return !1;
  if (i)
    return qd[o][2];
  if (a = t + 1, !qd[o][1].test(l)) {
    for (; a < r && !(e.sCount[a] < e.blkIndent); a++)
      if (u = e.bMarks[a] + e.tShift[a], c = e.eMarks[a], l = e.src.slice(u, c), qd[o][1].test(l)) {
        l.length !== 0 && a++;
        break;
      }
  }
  return e.line = a, s = e.push("html_block", "", 0), s.map = [t, a], s.content = e.getLines(t, a, e.blkIndent, !0), !0;
}, z4 = sn.isSpace, Syt = function(e, t, r, i) {
  var o, a, s, l, u = e.bMarks[t] + e.tShift[t], c = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (o = e.src.charCodeAt(u), o !== 35 || u >= c))
    return !1;
  for (a = 1, o = e.src.charCodeAt(++u); o === 35 && u < c && a <= 6; )
    a++, o = e.src.charCodeAt(++u);
  return a > 6 || u < c && !z4(o) ? !1 : (i || (c = e.skipSpacesBack(c, u), s = e.skipCharsBack(c, 35, u), s > u && z4(e.src.charCodeAt(s - 1)) && (c = s), e.line = t + 1, l = e.push("heading_open", "h" + String(a), 1), l.markup = "########".slice(0, a), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = e.src.slice(u, c).trim(), l.map = [t, e.line], l.children = [], l = e.push("heading_close", "h" + String(a), -1), l.markup = "########".slice(0, a)), !0);
}, _yt = function(e, t, r) {
  var i, o, a, s, l, u, c, h, f, d = t + 1, p, g = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  for (p = e.parentType, e.parentType = "paragraph"; d < r && !e.isEmpty(d); d++)
    if (!(e.sCount[d] - e.blkIndent > 3)) {
      if (e.sCount[d] >= e.blkIndent && (u = e.bMarks[d] + e.tShift[d], c = e.eMarks[d], u < c && (f = e.src.charCodeAt(u), (f === 45 || f === 61) && (u = e.skipChars(u, f), u = e.skipSpaces(u), u >= c)))) {
        h = f === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[d] < 0)) {
        for (o = !1, a = 0, s = g.length; a < s; a++)
          if (g[a](e, d, r, !0)) {
            o = !0;
            break;
          }
        if (o)
          break;
      }
    }
  return h ? (i = e.getLines(t, d, e.blkIndent, !1).trim(), e.line = d + 1, l = e.push("heading_open", "h" + String(h), 1), l.markup = String.fromCharCode(f), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = i, l.map = [t, e.line - 1], l.children = [], l = e.push("heading_close", "h" + String(h), -1), l.markup = String.fromCharCode(f), e.parentType = p, !0) : !1;
}, Cyt = function(e, t, r) {
  var i, o, a, s, l, u, c = t + 1, h = e.md.block.ruler.getRules("paragraph");
  for (u = e.parentType, e.parentType = "paragraph"; c < r && !e.isEmpty(c); c++)
    if (!(e.sCount[c] - e.blkIndent > 3) && !(e.sCount[c] < 0)) {
      for (o = !1, a = 0, s = h.length; a < s; a++)
        if (h[a](e, c, r, !0)) {
          o = !0;
          break;
        }
      if (o)
        break;
    }
  return i = e.getLines(t, c, e.blkIndent, !1).trim(), e.line = c, l = e.push("paragraph_open", "p", 1), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = i, l.map = [t, e.line], l.children = [], l = e.push("paragraph_close", "p", -1), e.parentType = u, !0;
}, aK = aR, oC = sn.isSpace;
function Ll(n, e, t, r) {
  var i, o, a, s, l, u, c, h;
  for (this.src = n, this.md = e, this.env = t, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", o = this.src, h = !1, a = s = u = c = 0, l = o.length; s < l; s++) {
    if (i = o.charCodeAt(s), !h)
      if (oC(i)) {
        u++, i === 9 ? c += 4 - c % 4 : c++;
        continue;
      } else
        h = !0;
    (i === 10 || s === l - 1) && (i !== 10 && s++, this.bMarks.push(a), this.eMarks.push(s), this.tShift.push(u), this.sCount.push(c), this.bsCount.push(0), h = !1, u = 0, c = 0, a = s + 1);
  }
  this.bMarks.push(o.length), this.eMarks.push(o.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
Ll.prototype.push = function(n, e, t) {
  var r = new aK(n, e, t);
  return r.block = !0, t < 0 && this.level--, r.level = this.level, t > 0 && this.level++, this.tokens.push(r), r;
};
Ll.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
Ll.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
Ll.prototype.skipSpaces = function(e) {
  for (var t, r = this.src.length; e < r && (t = this.src.charCodeAt(e), !!oC(t)); e++)
    ;
  return e;
};
Ll.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!oC(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
Ll.prototype.skipChars = function(e, t) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
Ll.prototype.skipCharsBack = function(e, t, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
Ll.prototype.getLines = function(e, t, r, i) {
  var o, a, s, l, u, c, h, f = e;
  if (e >= t)
    return "";
  for (c = new Array(t - e), o = 0; f < t; f++, o++) {
    for (a = 0, h = l = this.bMarks[f], f + 1 < t || i ? u = this.eMarks[f] + 1 : u = this.eMarks[f]; l < u && a < r; ) {
      if (s = this.src.charCodeAt(l), oC(s))
        s === 9 ? a += 4 - (a + this.bsCount[f]) % 4 : a++;
      else if (l - h < this.tShift[f])
        a++;
      else
        break;
      l++;
    }
    a > r ? c[o] = new Array(a - r + 1).join(" ") + this.src.slice(l, u) : c[o] = this.src.slice(l, u);
  }
  return c.join("");
};
Ll.prototype.Token = aK;
var Ayt = Ll, Tyt = oR, q1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", Xmt, ["paragraph", "reference"]],
  ["code", Umt],
  ["fence", Kmt, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", eyt, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", nyt, ["paragraph", "reference", "blockquote", "list"]],
  ["list", iyt, ["paragraph", "reference", "blockquote"]],
  ["reference", ayt],
  ["html_block", xyt, ["paragraph", "reference", "blockquote"]],
  ["heading", Syt, ["paragraph", "reference", "blockquote"]],
  ["lheading", _yt],
  ["paragraph", Cyt]
];
function aC() {
  this.ruler = new Tyt();
  for (var n = 0; n < q1.length; n++)
    this.ruler.push(q1[n][0], q1[n][1], { alt: (q1[n][2] || []).slice() });
}
aC.prototype.tokenize = function(n, e, t) {
  for (var r, i, o, a = this.ruler.getRules(""), s = a.length, l = e, u = !1, c = n.md.options.maxNesting; l < t && (n.line = l = n.skipEmptyLines(l), !(l >= t || n.sCount[l] < n.blkIndent)); ) {
    if (n.level >= c) {
      n.line = t;
      break;
    }
    for (o = n.line, i = 0; i < s; i++)
      if (r = a[i](n, l, t, !1), r) {
        if (o >= n.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!r)
      throw new Error("none of the block rules matched");
    n.tight = !u, n.isEmpty(n.line - 1) && (u = !0), l = n.line, l < t && n.isEmpty(l) && (u = !0, l++, n.line = l);
  }
};
aC.prototype.parse = function(n, e, t, r) {
  var i;
  n && (i = new this.State(n, e, t, r), this.tokenize(i, i.line, i.lineMax));
};
aC.prototype.State = Ayt;
var kyt = aC;
function Pyt(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var Eyt = function(e, t) {
  for (var r = e.pos; r < e.posMax && !Pyt(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, r)), e.pos = r, !0);
}, Myt = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i, Dyt = function(e, t) {
  var r, i, o, a, s, l, u, c;
  return !e.md.options.linkify || e.linkLevel > 0 || (r = e.pos, i = e.posMax, r + 3 > i) || e.src.charCodeAt(r) !== 58 || e.src.charCodeAt(r + 1) !== 47 || e.src.charCodeAt(r + 2) !== 47 || (o = e.pending.match(Myt), !o) || (a = o[1], s = e.md.linkify.matchAtStart(e.src.slice(r - a.length)), !s) || (l = s.url, l.length <= a.length) || (l = l.replace(/\*+$/, ""), u = e.md.normalizeLink(l), !e.md.validateLink(u)) ? !1 : (t || (e.pending = e.pending.slice(0, -a.length), c = e.push("link_open", "a", 1), c.attrs = [["href", u]], c.markup = "linkify", c.info = "auto", c = e.push("text", "", 0), c.content = e.md.normalizeLinkText(l), c = e.push("link_close", "a", -1), c.markup = "linkify", c.info = "auto"), e.pos += l.length - a.length, !0);
}, Lyt = sn.isSpace, Iyt = function(e, t) {
  var r, i, o, a = e.pos;
  if (e.src.charCodeAt(a) !== 10)
    return !1;
  if (r = e.pending.length - 1, i = e.posMax, !t)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (o = r - 1; o >= 1 && e.pending.charCodeAt(o - 1) === 32; )
          o--;
        e.pending = e.pending.slice(0, o), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (a++; a < i && Lyt(e.src.charCodeAt(a)); )
    a++;
  return e.pos = a, !0;
}, Ryt = sn.isSpace, lR = [];
for (var F4 = 0; F4 < 256; F4++)
  lR.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  lR[n.charCodeAt(0)] = 1;
});
var Nyt = function(e, t) {
  var r, i, o, a, s, l = e.pos, u = e.posMax;
  if (e.src.charCodeAt(l) !== 92 || (l++, l >= u))
    return !1;
  if (r = e.src.charCodeAt(l), r === 10) {
    for (t || e.push("hardbreak", "br", 0), l++; l < u && (r = e.src.charCodeAt(l), !!Ryt(r)); )
      l++;
    return e.pos = l, !0;
  }
  return a = e.src[l], r >= 55296 && r <= 56319 && l + 1 < u && (i = e.src.charCodeAt(l + 1), i >= 56320 && i <= 57343 && (a += e.src[l + 1], l++)), o = "\\" + a, t || (s = e.push("text_special", "", 0), r < 256 && lR[r] !== 0 ? s.content = a : s.content = o, s.markup = o, s.info = "escape"), e.pos = l + 1, !0;
}, $yt = function(e, t) {
  var r, i, o, a, s, l, u, c, h = e.pos, f = e.src.charCodeAt(h);
  if (f !== 96)
    return !1;
  for (r = h, h++, i = e.posMax; h < i && e.src.charCodeAt(h) === 96; )
    h++;
  if (o = e.src.slice(r, h), u = o.length, e.backticksScanned && (e.backticks[u] || 0) <= r)
    return t || (e.pending += o), e.pos += u, !0;
  for (l = h; (s = e.src.indexOf("`", l)) !== -1; ) {
    for (l = s + 1; l < i && e.src.charCodeAt(l) === 96; )
      l++;
    if (c = l - s, c === u)
      return t || (a = e.push("code_inline", "code", 0), a.markup = o, a.content = e.src.slice(h, s).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = l, !0;
    e.backticks[c] = s;
  }
  return e.backticksScanned = !0, t || (e.pending += o), e.pos += u, !0;
}, sC = {};
sC.tokenize = function(e, t) {
  var r, i, o, a, s, l = e.pos, u = e.src.charCodeAt(l);
  if (t || u !== 126 || (i = e.scanDelims(e.pos, !0), a = i.length, s = String.fromCharCode(u), a < 2))
    return !1;
  for (a % 2 && (o = e.push("text", "", 0), o.content = s, a--), r = 0; r < a; r += 2)
    o = e.push("text", "", 0), o.content = s + s, e.delimiters.push({
      marker: u,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return e.pos += i.length, !0;
};
function Q4(n, e) {
  var t, r, i, o, a, s = [], l = e.length;
  for (t = 0; t < l; t++)
    i = e[t], i.marker === 126 && i.end !== -1 && (o = e[i.end], a = n.tokens[i.token], a.type = "s_open", a.tag = "s", a.nesting = 1, a.markup = "~~", a.content = "", a = n.tokens[o.token], a.type = "s_close", a.tag = "s", a.nesting = -1, a.markup = "~~", a.content = "", n.tokens[o.token - 1].type === "text" && n.tokens[o.token - 1].content === "~" && s.push(o.token - 1));
  for (; s.length; ) {
    for (t = s.pop(), r = t + 1; r < n.tokens.length && n.tokens[r].type === "s_close"; )
      r++;
    r--, t !== r && (a = n.tokens[r], n.tokens[r] = n.tokens[t], n.tokens[t] = a);
  }
}
sC.postProcess = function(e) {
  var t, r = e.tokens_meta, i = e.tokens_meta.length;
  for (Q4(e, e.delimiters), t = 0; t < i; t++)
    r[t] && r[t].delimiters && Q4(e, r[t].delimiters);
};
var lC = {};
lC.tokenize = function(e, t) {
  var r, i, o, a = e.pos, s = e.src.charCodeAt(a);
  if (t || s !== 95 && s !== 42)
    return !1;
  for (i = e.scanDelims(e.pos, s === 42), r = 0; r < i.length; r++)
    o = e.push("text", "", 0), o.content = String.fromCharCode(s), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: s,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  return e.pos += i.length, !0;
};
function Z4(n, e) {
  var t, r, i, o, a, s, l = e.length;
  for (t = l - 1; t >= 0; t--)
    r = e[t], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (i = e[r.end], s = t > 0 && e[t - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === r.marker && e[t - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === i.token + 1, a = String.fromCharCode(r.marker), o = n.tokens[r.token], o.type = s ? "strong_open" : "em_open", o.tag = s ? "strong" : "em", o.nesting = 1, o.markup = s ? a + a : a, o.content = "", o = n.tokens[i.token], o.type = s ? "strong_close" : "em_close", o.tag = s ? "strong" : "em", o.nesting = -1, o.markup = s ? a + a : a, o.content = "", s && (n.tokens[e[t - 1].token].content = "", n.tokens[e[r.end + 1].token].content = "", t--));
}
lC.postProcess = function(e) {
  var t, r = e.tokens_meta, i = e.tokens_meta.length;
  for (Z4(e, e.delimiters), t = 0; t < i; t++)
    r[t] && r[t].delimiters && Z4(e, r[t].delimiters);
};
var Byt = sn.normalizeReference, sA = sn.isSpace, Vyt = function(e, t) {
  var r, i, o, a, s, l, u, c, h, f = "", d = "", p = e.pos, g = e.posMax, v = e.pos, m = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (s = e.pos + 1, a = e.md.helpers.parseLinkLabel(e, e.pos, !0), a < 0))
    return !1;
  if (l = a + 1, l < g && e.src.charCodeAt(l) === 40) {
    for (m = !1, l++; l < g && (i = e.src.charCodeAt(l), !(!sA(i) && i !== 10)); l++)
      ;
    if (l >= g)
      return !1;
    if (v = l, u = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), u.ok) {
      for (f = e.md.normalizeLink(u.str), e.md.validateLink(f) ? l = u.pos : f = "", v = l; l < g && (i = e.src.charCodeAt(l), !(!sA(i) && i !== 10)); l++)
        ;
      if (u = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < g && v !== l && u.ok)
        for (d = u.str, l = u.pos; l < g && (i = e.src.charCodeAt(l), !(!sA(i) && i !== 10)); l++)
          ;
    }
    (l >= g || e.src.charCodeAt(l) !== 41) && (m = !0), l++;
  }
  if (m) {
    if (typeof e.env.references > "u")
      return !1;
    if (l < g && e.src.charCodeAt(l) === 91 ? (v = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? o = e.src.slice(v, l++) : l = a + 1) : l = a + 1, o || (o = e.src.slice(s, a)), c = e.env.references[Byt(o)], !c)
      return e.pos = p, !1;
    f = c.href, d = c.title;
  }
  return t || (e.pos = s, e.posMax = a, h = e.push("link_open", "a", 1), h.attrs = r = [["href", f]], d && r.push(["title", d]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, h = e.push("link_close", "a", -1)), e.pos = l, e.posMax = g, !0;
}, zyt = sn.normalizeReference, lA = sn.isSpace, Fyt = function(e, t) {
  var r, i, o, a, s, l, u, c, h, f, d, p, g, v = "", m = e.pos, y = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (l = e.pos + 2, s = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), s < 0))
    return !1;
  if (u = s + 1, u < y && e.src.charCodeAt(u) === 40) {
    for (u++; u < y && (i = e.src.charCodeAt(u), !(!lA(i) && i !== 10)); u++)
      ;
    if (u >= y)
      return !1;
    for (g = u, h = e.md.helpers.parseLinkDestination(e.src, u, e.posMax), h.ok && (v = e.md.normalizeLink(h.str), e.md.validateLink(v) ? u = h.pos : v = ""), g = u; u < y && (i = e.src.charCodeAt(u), !(!lA(i) && i !== 10)); u++)
      ;
    if (h = e.md.helpers.parseLinkTitle(e.src, u, e.posMax), u < y && g !== u && h.ok)
      for (f = h.str, u = h.pos; u < y && (i = e.src.charCodeAt(u), !(!lA(i) && i !== 10)); u++)
        ;
    else
      f = "";
    if (u >= y || e.src.charCodeAt(u) !== 41)
      return e.pos = m, !1;
    u++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (u < y && e.src.charCodeAt(u) === 91 ? (g = u + 1, u = e.md.helpers.parseLinkLabel(e, u), u >= 0 ? a = e.src.slice(g, u++) : u = s + 1) : u = s + 1, a || (a = e.src.slice(l, s)), c = e.env.references[zyt(a)], !c)
      return e.pos = m, !1;
    v = c.href, f = c.title;
  }
  return t || (o = e.src.slice(l, s), e.md.inline.parse(
    o,
    e.md,
    e.env,
    p = []
  ), d = e.push("image", "img", 0), d.attrs = r = [["src", v], ["alt", ""]], d.children = p, d.content = o, f && r.push(["title", f])), e.pos = u, e.posMax = y, !0;
}, Qyt = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, Zyt = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, Wyt = function(e, t) {
  var r, i, o, a, s, l, u = e.pos;
  if (e.src.charCodeAt(u) !== 60)
    return !1;
  for (s = e.pos, l = e.posMax; ; ) {
    if (++u >= l || (a = e.src.charCodeAt(u), a === 60))
      return !1;
    if (a === 62)
      break;
  }
  return r = e.src.slice(s + 1, u), Zyt.test(r) ? (i = e.md.normalizeLink(r), e.md.validateLink(i) ? (t || (o = e.push("link_open", "a", 1), o.attrs = [["href", i]], o.markup = "autolink", o.info = "auto", o = e.push("text", "", 0), o.content = e.md.normalizeLinkText(r), o = e.push("link_close", "a", -1), o.markup = "autolink", o.info = "auto"), e.pos += r.length + 2, !0) : !1) : Qyt.test(r) ? (i = e.md.normalizeLink("mailto:" + r), e.md.validateLink(i) ? (t || (o = e.push("link_open", "a", 1), o.attrs = [["href", i]], o.markup = "autolink", o.info = "auto", o = e.push("text", "", 0), o.content = e.md.normalizeLinkText(r), o = e.push("link_close", "a", -1), o.markup = "autolink", o.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1;
}, Gyt = iC.HTML_TAG_RE;
function jyt(n) {
  return /^<a[>\s]/i.test(n);
}
function Hyt(n) {
  return /^<\/a\s*>/i.test(n);
}
function qyt(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var Yyt = function(e, t) {
  var r, i, o, a, s = e.pos;
  return !e.md.options.html || (o = e.posMax, e.src.charCodeAt(s) !== 60 || s + 2 >= o) || (r = e.src.charCodeAt(s + 1), r !== 33 && r !== 63 && r !== 47 && !qyt(r)) || (i = e.src.slice(s).match(Gyt), !i) ? !1 : (t || (a = e.push("html_inline", "", 0), a.content = i[0], jyt(a.content) && e.linkLevel++, Hyt(a.content) && e.linkLevel--), e.pos += i[0].length, !0);
}, W4 = UU, Xyt = sn.has, Uyt = sn.isValidEntityCode, G4 = sn.fromCodePoint, Kyt = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, Jyt = /^&([a-z][a-z0-9]{1,31});/i, e0t = function(e, t) {
  var r, i, o, a, s = e.pos, l = e.posMax;
  if (e.src.charCodeAt(s) !== 38 || s + 1 >= l)
    return !1;
  if (r = e.src.charCodeAt(s + 1), r === 35) {
    if (o = e.src.slice(s).match(Kyt), o)
      return t || (i = o[1][0].toLowerCase() === "x" ? parseInt(o[1].slice(1), 16) : parseInt(o[1], 10), a = e.push("text_special", "", 0), a.content = Uyt(i) ? G4(i) : G4(65533), a.markup = o[0], a.info = "entity"), e.pos += o[0].length, !0;
  } else if (o = e.src.slice(s).match(Jyt), o && Xyt(W4, o[1]))
    return t || (a = e.push("text_special", "", 0), a.content = W4[o[1]], a.markup = o[0], a.info = "entity"), e.pos += o[0].length, !0;
  return !1;
};
function j4(n) {
  var e, t, r, i, o, a, s, l, u = {}, c = n.length;
  if (c) {
    var h = 0, f = -2, d = [];
    for (e = 0; e < c; e++)
      if (r = n[e], d.push(0), (n[h].marker !== r.marker || f !== r.token - 1) && (h = e), f = r.token, r.length = r.length || 0, !!r.close) {
        for (u.hasOwnProperty(r.marker) || (u[r.marker] = [-1, -1, -1, -1, -1, -1]), o = u[r.marker][(r.open ? 3 : 0) + r.length % 3], t = h - d[h] - 1, a = t; t > o; t -= d[t] + 1)
          if (i = n[t], i.marker === r.marker && i.open && i.end < 0 && (s = !1, (i.close || r.open) && (i.length + r.length) % 3 === 0 && (i.length % 3 !== 0 || r.length % 3 !== 0) && (s = !0), !s)) {
            l = t > 0 && !n[t - 1].open ? d[t - 1] + 1 : 0, d[e] = e - t + l, d[t] = l, r.open = !1, i.end = e, i.close = !1, a = -1, f = -2;
            break;
          }
        a !== -1 && (u[r.marker][(r.open ? 3 : 0) + (r.length || 0) % 3] = a);
      }
  }
}
var t0t = function(e) {
  var t, r = e.tokens_meta, i = e.tokens_meta.length;
  for (j4(e.delimiters), t = 0; t < i; t++)
    r[t] && r[t].delimiters && j4(r[t].delimiters);
}, n0t = function(e) {
  var t, r, i = 0, o = e.tokens, a = e.tokens.length;
  for (t = r = 0; t < a; t++)
    o[t].nesting < 0 && i--, o[t].level = i, o[t].nesting > 0 && i++, o[t].type === "text" && t + 1 < a && o[t + 1].type === "text" ? o[t + 1].content = o[t].content + o[t + 1].content : (t !== r && (o[r] = o[t]), r++);
  t !== r && (o.length = r);
}, uR = aR, H4 = sn.isWhiteSpace, q4 = sn.isPunctChar, Y4 = sn.isMdAsciiPunct;
function Ib(n, e, t, r) {
  this.src = n, this.env = t, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Ib.prototype.pushPending = function() {
  var n = new uR("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
Ib.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var r = new uR(n, e, t), i = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(i), r;
};
Ib.prototype.scanDelims = function(n, e) {
  var t = n, r, i, o, a, s, l, u, c, h, f = !0, d = !0, p = this.posMax, g = this.src.charCodeAt(n);
  for (r = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < p && this.src.charCodeAt(t) === g; )
    t++;
  return o = t - n, i = t < p ? this.src.charCodeAt(t) : 32, u = Y4(r) || q4(String.fromCharCode(r)), h = Y4(i) || q4(String.fromCharCode(i)), l = H4(r), c = H4(i), c ? f = !1 : h && (l || u || (f = !1)), l ? d = !1 : u && (c || h || (d = !1)), e ? (a = f, s = d) : (a = f && (!d || u), s = d && (!f || h)), {
    can_open: a,
    can_close: s,
    length: o
  };
};
Ib.prototype.Token = uR;
var r0t = Ib, X4 = oR, uA = [
  ["text", Eyt],
  ["linkify", Dyt],
  ["newline", Iyt],
  ["escape", Nyt],
  ["backticks", $yt],
  ["strikethrough", sC.tokenize],
  ["emphasis", lC.tokenize],
  ["link", Vyt],
  ["image", Fyt],
  ["autolink", Wyt],
  ["html_inline", Yyt],
  ["entity", e0t]
], cA = [
  ["balance_pairs", t0t],
  ["strikethrough", sC.postProcess],
  ["emphasis", lC.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", n0t]
];
function Rb() {
  var n;
  for (this.ruler = new X4(), n = 0; n < uA.length; n++)
    this.ruler.push(uA[n][0], uA[n][1]);
  for (this.ruler2 = new X4(), n = 0; n < cA.length; n++)
    this.ruler2.push(cA[n][0], cA[n][1]);
}
Rb.prototype.skipToken = function(n) {
  var e, t, r = n.pos, i = this.ruler.getRules(""), o = i.length, a = n.md.options.maxNesting, s = n.cache;
  if (typeof s[r] < "u") {
    n.pos = s[r];
    return;
  }
  if (n.level < a) {
    for (t = 0; t < o; t++)
      if (n.level++, e = i[t](n, !0), n.level--, e) {
        if (r >= n.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    n.pos = n.posMax;
  e || n.pos++, s[r] = n.pos;
};
Rb.prototype.tokenize = function(n) {
  for (var e, t, r, i = this.ruler.getRules(""), o = i.length, a = n.posMax, s = n.md.options.maxNesting; n.pos < a; ) {
    if (r = n.pos, n.level < s) {
      for (t = 0; t < o; t++)
        if (e = i[t](n, !1), e) {
          if (r >= n.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (e) {
      if (n.pos >= a)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Rb.prototype.parse = function(n, e, t, r) {
  var i, o, a, s = new this.State(n, e, t, r);
  for (this.tokenize(s), o = this.ruler2.getRules(""), a = o.length, i = 0; i < a; i++)
    o[i](s);
};
Rb.prototype.State = r0t;
var i0t = Rb, hA, U4;
function o0t() {
  return U4 || (U4 = 1, hA = function(n) {
    var e = {};
    n = n || {}, e.src_Any = KU().source, e.src_Cc = JU().source, e.src_Z = eK().source, e.src_P = iR.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!" + (n["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), hA;
}
function XE(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(r) {
      n[r] = t[r];
    });
  }), n;
}
function uC(n) {
  return Object.prototype.toString.call(n);
}
function a0t(n) {
  return uC(n) === "[object String]";
}
function s0t(n) {
  return uC(n) === "[object Object]";
}
function l0t(n) {
  return uC(n) === "[object RegExp]";
}
function K4(n) {
  return uC(n) === "[object Function]";
}
function u0t(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var sK = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function c0t(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || sK.hasOwnProperty(t);
  }, !1);
}
var h0t = {
  "http:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(r) ? r.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(r) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : r.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(r) ? r.match(t.re.mailto)[0].length : 0;
    }
  }
}, f0t = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", d0t = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function p0t(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function g0t(n) {
  return function(e, t) {
    var r = e.slice(t);
    return n.test(r) ? r.match(n)[0].length : 0;
  };
}
function J4() {
  return function(n, e) {
    e.normalize(n);
  };
}
function nS(n) {
  var e = n.re = o0t()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(f0t), t.push(e.src_xn), e.src_tlds = t.join("|");
  function r(s) {
    return s.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var i = [];
  n.__compiled__ = {};
  function o(s, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + s + '": ' + l);
  }
  Object.keys(n.__schemas__).forEach(function(s) {
    var l = n.__schemas__[s];
    if (l !== null) {
      var u = { validate: null, link: null };
      if (n.__compiled__[s] = u, s0t(l)) {
        l0t(l.validate) ? u.validate = g0t(l.validate) : K4(l.validate) ? u.validate = l.validate : o(s, l), K4(l.normalize) ? u.normalize = l.normalize : l.normalize ? o(s, l) : u.normalize = J4();
        return;
      }
      if (a0t(l)) {
        i.push(s);
        return;
      }
      o(s, l);
    }
  }), i.forEach(function(s) {
    n.__compiled__[n.__schemas__[s]] && (n.__compiled__[s].validate = n.__compiled__[n.__schemas__[s]].validate, n.__compiled__[s].normalize = n.__compiled__[n.__schemas__[s]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: J4() };
  var a = Object.keys(n.__compiled__).filter(function(s) {
    return s.length > 0 && n.__compiled__[s];
  }).map(u0t).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + a + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + a + ")", "ig"), n.re.schema_at_start = RegExp("^" + n.re.schema_search.source, "i"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), p0t(n);
}
function v0t(n, e) {
  var t = n.__index__, r = n.__last_index__, i = n.__text_cache__.slice(t, r);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = r + e, this.raw = i, this.text = i, this.url = i;
}
function UE(n, e) {
  var t = new v0t(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function Ko(n, e) {
  if (!(this instanceof Ko))
    return new Ko(n, e);
  e || c0t(n) && (e = n, n = {}), this.__opts__ = XE({}, sK, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = XE({}, h0t, n), this.__compiled__ = {}, this.__tlds__ = d0t, this.__tlds_replaced__ = !1, this.re = {}, nS(this);
}
Ko.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, nS(this), this;
};
Ko.prototype.set = function(e) {
  return this.__opts__ = XE(this.__opts__, e), this;
};
Ko.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var t, r, i, o, a, s, l, u, c;
  if (this.re.schema_test.test(e)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (t = l.exec(e)) !== null; )
      if (o = this.testSchemaAt(e, t[2], l.lastIndex), o) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + o;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (u = e.search(this.re.host_fuzzy_test), u >= 0 && (this.__index__ < 0 || u < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (a = r.index + r[1].length, (this.__index__ < 0 || a < this.__index__) && (this.__schema__ = "", this.__index__ = a, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (c = e.indexOf("@"), c >= 0 && (i = e.match(this.re.email_fuzzy)) !== null && (a = i.index + i[1].length, s = i.index + i[0].length, (this.__index__ < 0 || a < this.__index__ || a === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = a, this.__last_index__ = s))), this.__index__ >= 0;
};
Ko.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
Ko.prototype.testSchemaAt = function(e, t, r) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, r, this) : 0;
};
Ko.prototype.match = function(e) {
  var t = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(UE(this, t)), t = this.__last_index__);
  for (var i = t ? e.slice(t) : e; this.test(i); )
    r.push(UE(this, t)), i = i.slice(this.__last_index__), t += this.__last_index__;
  return r.length ? r : null;
};
Ko.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return null;
  var t = this.re.schema_at_start.exec(e);
  if (!t)
    return null;
  var r = this.testSchemaAt(e, t[2], t[0].length);
  return r ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r, UE(this, 0)) : null;
};
Ko.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, i, o) {
    return r !== o[i - 1];
  }).reverse(), nS(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, nS(this), this);
};
Ko.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
Ko.prototype.onCompile = function() {
};
var m0t = Ko;
const Yp = 2147483647, tl = 36, cR = 1, E0 = 26, y0t = 38, b0t = 700, lK = 72, uK = 128, cK = "-", O0t = /^xn--/, w0t = /[^\0-\x7F]/, x0t = /[\x2E\u3002\uFF0E\uFF61]/g, S0t = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, fA = tl - cR, nl = Math.floor, dA = String.fromCharCode;
function Ju(n) {
  throw new RangeError(S0t[n]);
}
function _0t(n, e) {
  const t = [];
  let r = n.length;
  for (; r--; )
    t[r] = e(n[r]);
  return t;
}
function hK(n, e) {
  const t = n.split("@");
  let r = "";
  t.length > 1 && (r = t[0] + "@", n = t[1]), n = n.replace(x0t, ".");
  const i = n.split("."), o = _0t(i, e).join(".");
  return r + o;
}
function hR(n) {
  const e = [];
  let t = 0;
  const r = n.length;
  for (; t < r; ) {
    const i = n.charCodeAt(t++);
    if (i >= 55296 && i <= 56319 && t < r) {
      const o = n.charCodeAt(t++);
      (o & 64512) == 56320 ? e.push(((i & 1023) << 10) + (o & 1023) + 65536) : (e.push(i), t--);
    } else
      e.push(i);
  }
  return e;
}
const fK = (n) => String.fromCodePoint(...n), C0t = function(n) {
  return n >= 48 && n < 58 ? 26 + (n - 48) : n >= 65 && n < 91 ? n - 65 : n >= 97 && n < 123 ? n - 97 : tl;
}, ez = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
}, dK = function(n, e, t) {
  let r = 0;
  for (n = t ? nl(n / b0t) : n >> 1, n += nl(n / e); n > fA * E0 >> 1; r += tl)
    n = nl(n / fA);
  return nl(r + (fA + 1) * n / (n + y0t));
}, fR = function(n) {
  const e = [], t = n.length;
  let r = 0, i = uK, o = lK, a = n.lastIndexOf(cK);
  a < 0 && (a = 0);
  for (let s = 0; s < a; ++s)
    n.charCodeAt(s) >= 128 && Ju("not-basic"), e.push(n.charCodeAt(s));
  for (let s = a > 0 ? a + 1 : 0; s < t; ) {
    const l = r;
    for (let c = 1, h = tl; ; h += tl) {
      s >= t && Ju("invalid-input");
      const f = C0t(n.charCodeAt(s++));
      f >= tl && Ju("invalid-input"), f > nl((Yp - r) / c) && Ju("overflow"), r += f * c;
      const d = h <= o ? cR : h >= o + E0 ? E0 : h - o;
      if (f < d)
        break;
      const p = tl - d;
      c > nl(Yp / p) && Ju("overflow"), c *= p;
    }
    const u = e.length + 1;
    o = dK(r - l, u, l == 0), nl(r / u) > Yp - i && Ju("overflow"), i += nl(r / u), r %= u, e.splice(r++, 0, i);
  }
  return String.fromCodePoint(...e);
}, dR = function(n) {
  const e = [];
  n = hR(n);
  const t = n.length;
  let r = uK, i = 0, o = lK;
  for (const l of n)
    l < 128 && e.push(dA(l));
  const a = e.length;
  let s = a;
  for (a && e.push(cK); s < t; ) {
    let l = Yp;
    for (const c of n)
      c >= r && c < l && (l = c);
    const u = s + 1;
    l - r > nl((Yp - i) / u) && Ju("overflow"), i += (l - r) * u, r = l;
    for (const c of n)
      if (c < r && ++i > Yp && Ju("overflow"), c === r) {
        let h = i;
        for (let f = tl; ; f += tl) {
          const d = f <= o ? cR : f >= o + E0 ? E0 : f - o;
          if (h < d)
            break;
          const p = h - d, g = tl - d;
          e.push(
            dA(ez(d + p % g, 0))
          ), h = nl(p / g);
        }
        e.push(dA(ez(h, 0))), o = dK(i, u, s === a), i = 0, ++s;
      }
    ++i, ++r;
  }
  return e.join("");
}, pK = function(n) {
  return hK(n, function(e) {
    return O0t.test(e) ? fR(e.slice(4).toLowerCase()) : e;
  });
}, gK = function(n) {
  return hK(n, function(e) {
    return w0t.test(e) ? "xn--" + dR(e) : e;
  });
}, A0t = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: hR,
    encode: fK
  },
  decode: fR,
  encode: dR,
  toASCII: gK,
  toUnicode: pK
}, T0t = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: fR,
  default: A0t,
  encode: dR,
  toASCII: gK,
  toUnicode: pK,
  ucs2decode: hR,
  ucs2encode: fK
}, Symbol.toStringTag, { value: "Module" })), k0t = /* @__PURE__ */ Abe(T0t);
var P0t = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, E0t = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, M0t = {
  options: {
    html: !0,
    // Enable HTML tags in source
    xhtmlOut: !0,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, ky = sn, D0t = rC, L0t = Cmt, I0t = Ymt, R0t = kyt, N0t = i0t, $0t = m0t, bf = Cv, vK = k0t, B0t = {
  default: P0t,
  zero: E0t,
  commonmark: M0t
}, V0t = /^(vbscript|javascript|file|data):/, z0t = /^data:image\/(gif|png|jpeg|webp);/;
function F0t(n) {
  var e = n.trim().toLowerCase();
  return V0t.test(e) ? !!z0t.test(e) : !0;
}
var mK = ["http:", "https:", "mailto:"];
function Q0t(n) {
  var e = bf.parse(n, !0);
  if (e.hostname && (!e.protocol || mK.indexOf(e.protocol) >= 0))
    try {
      e.hostname = vK.toASCII(e.hostname);
    } catch {
    }
  return bf.encode(bf.format(e));
}
function Z0t(n) {
  var e = bf.parse(n, !0);
  if (e.hostname && (!e.protocol || mK.indexOf(e.protocol) >= 0))
    try {
      e.hostname = vK.toUnicode(e.hostname);
    } catch {
    }
  return bf.decode(bf.format(e), bf.decode.defaultChars + "%");
}
function La(n, e) {
  if (!(this instanceof La))
    return new La(n, e);
  e || ky.isString(n) || (e = n || {}, n = "default"), this.inline = new N0t(), this.block = new R0t(), this.core = new I0t(), this.renderer = new L0t(), this.linkify = new $0t(), this.validateLink = F0t, this.normalizeLink = Q0t, this.normalizeLinkText = Z0t, this.utils = ky, this.helpers = ky.assign({}, D0t), this.options = {}, this.configure(n), e && this.set(e);
}
La.prototype.set = function(n) {
  return ky.assign(this.options, n), this;
};
La.prototype.configure = function(n) {
  var e = this, t;
  if (ky.isString(n) && (t = n, n = B0t[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(r) {
    n.components[r].rules && e[r].ruler.enableOnly(n.components[r].rules), n.components[r].rules2 && e[r].ruler2.enableOnly(n.components[r].rules2);
  }), this;
};
La.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(i) {
    t = t.concat(this[i].ruler.enable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.enable(n, !0));
  var r = n.filter(function(i) {
    return t.indexOf(i) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
La.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(i) {
    t = t.concat(this[i].ruler.disable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.disable(n, !0));
  var r = n.filter(function(i) {
    return t.indexOf(i) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
La.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
La.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
La.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
La.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = !0, this.core.process(t), t.tokens;
};
La.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var W0t = La, G0t = W0t;
const j0t = /* @__PURE__ */ wb(G0t), tz = /* @__PURE__ */ new Set([!0, !1, "alt", "title"]);
function yK(n, e) {
  return (Array.isArray(n) ? n : []).filter(([t]) => t !== e);
}
function bK(n, e) {
  n && n.attrs && (n.attrs = yK(n.attrs, e));
}
function H0t(n, e) {
  if (!tz.has(n))
    throw new TypeError(`figcaption must be one of: ${[...tz]}.`);
  if (n === "alt")
    return e.content;
  const t = e.attrs.find(([r]) => r === "title");
  return Array.isArray(t) && t[1] ? (bK(e, "title"), t[1]) : void 0;
}
function q0t(n, e) {
  e = e || {}, n.core.ruler.before("linkify", "image_figures", function(t) {
    let r = 1;
    for (let i = 1, o = t.tokens.length; i < o - 1; ++i) {
      const a = t.tokens[i];
      if (a.type !== "inline" || !a.children || a.children.length !== 1 && a.children.length !== 3 || a.children.length === 1 && a.children[0].type !== "image")
        continue;
      if (a.children.length === 3) {
        const [u, c, h] = a.children;
        if (u.type !== "link_open" || c.type !== "image" || h.type !== "link_close")
          continue;
      }
      if (i !== 0 && t.tokens[i - 1].type !== "paragraph_open" || i !== o - 1 && t.tokens[i + 1].type !== "paragraph_close")
        continue;
      const s = t.tokens[i - 1];
      let l;
      if (s.type = "figure_open", s.tag = "figure", t.tokens[i + 1].type = "figure_close", t.tokens[i + 1].tag = "figure", e.dataType && t.tokens[i - 1].attrPush(["data-type", "image"]), e.link && a.children.length === 1) {
        [l] = a.children;
        const u = new t.Token("link_open", "a", 1);
        u.attrPush(["href", l.attrGet("src")]), a.children.unshift(u), a.children.push(new t.Token("link_close", "a", -1));
      }
      if (l = a.children.length === 1 ? a.children[0] : a.children[1], e.figcaption) {
        const u = H0t(e.figcaption, l);
        if (u) {
          const [c] = n.parseInline(u, t.env);
          a.children.push(new t.Token("figcaption_open", "figcaption", 1)), a.children.push(...c.children), a.children.push(new t.Token("figcaption_close", "figcaption", -1)), l.attrs && (l.attrs = yK(l.attrs, "title"));
        }
      }
      if (e.copyAttrs && l.attrs) {
        const u = e.copyAttrs === !0 ? "" : e.copyAttrs;
        s.attrs = l.attrs.filter(([c]) => c.match(u)).map((c) => Array.from(c));
      }
      if (e.tabindex && (t.tokens[i - 1].attrPush(["tabindex", r]), r++), e.lazy && (l.attrs.some(([u]) => u === "loading") || l.attrs.push(["loading", "lazy"])), e.async && (l.attrs.some(([u]) => u === "decoding") || l.attrs.push(["decoding", "async"])), e.classes && typeof e.classes == "string") {
        let u = !1;
        for (let c = 0, h = l.attrs.length; c < h && !u; c++) {
          const f = l.attrs[c];
          f[0] === "class" && (f[1] = `${f[1]} ${e.classes}`, u = !0);
        }
        u || l.attrs.push(["class", e.classes]);
      }
      if (e.removeSrc) {
        const u = l.attrs.find(([c]) => c === "src");
        l.attrs.push(["data-src", u[1]]), bK(l, "src");
      }
    }
  });
}
var KE = !0, OK = !1, wK = !1, Y0t = function(n, e) {
  e && (KE = !e.enabled, OK = !!e.label, wK = !!e.labelAfter), n.core.ruler.after("inline", "github-task-lists", function(t) {
    for (var r = t.tokens, i = 2; i < r.length; i++)
      U0t(r, i) && (K0t(r[i], t.Token), nz(r[i - 2], "class", "task-list-item" + (KE ? "" : " enabled")), nz(r[X0t(r, i - 2)], "class", "contains-task-list"));
  });
};
function nz(n, e, t) {
  var r = n.attrIndex(e), i = [e, t];
  r < 0 ? n.attrPush(i) : n.attrs[r] = i;
}
function X0t(n, e) {
  for (var t = n[e].level - 1, r = e - 1; r >= 0; r--)
    if (n[r].level === t)
      return r;
  return -1;
}
function U0t(n, e) {
  return rbt(n[e]) && ibt(n[e - 1]) && obt(n[e - 2]) && abt(n[e]);
}
function K0t(n, e) {
  if (n.children.unshift(J0t(n, e)), n.children[1].content = n.children[1].content.slice(3), n.content = n.content.slice(3), OK)
    if (wK) {
      n.children.pop();
      var t = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
      n.children[0].content = n.children[0].content.slice(0, -1) + ' id="' + t + '">', n.children.push(nbt(n.content, t, e));
    } else
      n.children.unshift(ebt(e)), n.children.push(tbt(e));
}
function J0t(n, e) {
  var t = new e("html_inline", "", 0), r = KE ? ' disabled="" ' : "";
  return n.content.indexOf("[ ] ") === 0 ? t.content = '<input class="task-list-item-checkbox"' + r + 'type="checkbox">' : (n.content.indexOf("[x] ") === 0 || n.content.indexOf("[X] ") === 0) && (t.content = '<input class="task-list-item-checkbox" checked=""' + r + 'type="checkbox">'), t;
}
function ebt(n) {
  var e = new n("html_inline", "", 0);
  return e.content = "<label>", e;
}
function tbt(n) {
  var e = new n("html_inline", "", 0);
  return e.content = "</label>", e;
}
function nbt(n, e, t) {
  var r = new t("html_inline", "", 0);
  return r.content = '<label class="task-list-item-label" for="' + e + '">' + n + "</label>", r.attrs = [{ for: e }], r;
}
function rbt(n) {
  return n.type === "inline";
}
function ibt(n) {
  return n.type === "paragraph_open";
}
function obt(n) {
  return n.type === "list_item_open";
}
function abt(n) {
  return n.content.indexOf("[ ] ") === 0 || n.content.indexOf("[x] ") === 0 || n.content.indexOf("[X] ") === 0;
}
const sbt = /* @__PURE__ */ wb(Y0t);
var JE = { exports: {} }, Xn = {}, eM = { exports: {} }, Pd = {};
function xK() {
  var n = {};
  return n["align-content"] = !1, n["align-items"] = !1, n["align-self"] = !1, n["alignment-adjust"] = !1, n["alignment-baseline"] = !1, n.all = !1, n["anchor-point"] = !1, n.animation = !1, n["animation-delay"] = !1, n["animation-direction"] = !1, n["animation-duration"] = !1, n["animation-fill-mode"] = !1, n["animation-iteration-count"] = !1, n["animation-name"] = !1, n["animation-play-state"] = !1, n["animation-timing-function"] = !1, n.azimuth = !1, n["backface-visibility"] = !1, n.background = !0, n["background-attachment"] = !0, n["background-clip"] = !0, n["background-color"] = !0, n["background-image"] = !0, n["background-origin"] = !0, n["background-position"] = !0, n["background-repeat"] = !0, n["background-size"] = !0, n["baseline-shift"] = !1, n.binding = !1, n.bleed = !1, n["bookmark-label"] = !1, n["bookmark-level"] = !1, n["bookmark-state"] = !1, n.border = !0, n["border-bottom"] = !0, n["border-bottom-color"] = !0, n["border-bottom-left-radius"] = !0, n["border-bottom-right-radius"] = !0, n["border-bottom-style"] = !0, n["border-bottom-width"] = !0, n["border-collapse"] = !0, n["border-color"] = !0, n["border-image"] = !0, n["border-image-outset"] = !0, n["border-image-repeat"] = !0, n["border-image-slice"] = !0, n["border-image-source"] = !0, n["border-image-width"] = !0, n["border-left"] = !0, n["border-left-color"] = !0, n["border-left-style"] = !0, n["border-left-width"] = !0, n["border-radius"] = !0, n["border-right"] = !0, n["border-right-color"] = !0, n["border-right-style"] = !0, n["border-right-width"] = !0, n["border-spacing"] = !0, n["border-style"] = !0, n["border-top"] = !0, n["border-top-color"] = !0, n["border-top-left-radius"] = !0, n["border-top-right-radius"] = !0, n["border-top-style"] = !0, n["border-top-width"] = !0, n["border-width"] = !0, n.bottom = !1, n["box-decoration-break"] = !0, n["box-shadow"] = !0, n["box-sizing"] = !0, n["box-snap"] = !0, n["box-suppress"] = !0, n["break-after"] = !0, n["break-before"] = !0, n["break-inside"] = !0, n["caption-side"] = !1, n.chains = !1, n.clear = !0, n.clip = !1, n["clip-path"] = !1, n["clip-rule"] = !1, n.color = !0, n["color-interpolation-filters"] = !0, n["column-count"] = !1, n["column-fill"] = !1, n["column-gap"] = !1, n["column-rule"] = !1, n["column-rule-color"] = !1, n["column-rule-style"] = !1, n["column-rule-width"] = !1, n["column-span"] = !1, n["column-width"] = !1, n.columns = !1, n.contain = !1, n.content = !1, n["counter-increment"] = !1, n["counter-reset"] = !1, n["counter-set"] = !1, n.crop = !1, n.cue = !1, n["cue-after"] = !1, n["cue-before"] = !1, n.cursor = !1, n.direction = !1, n.display = !0, n["display-inside"] = !0, n["display-list"] = !0, n["display-outside"] = !0, n["dominant-baseline"] = !1, n.elevation = !1, n["empty-cells"] = !1, n.filter = !1, n.flex = !1, n["flex-basis"] = !1, n["flex-direction"] = !1, n["flex-flow"] = !1, n["flex-grow"] = !1, n["flex-shrink"] = !1, n["flex-wrap"] = !1, n.float = !1, n["float-offset"] = !1, n["flood-color"] = !1, n["flood-opacity"] = !1, n["flow-from"] = !1, n["flow-into"] = !1, n.font = !0, n["font-family"] = !0, n["font-feature-settings"] = !0, n["font-kerning"] = !0, n["font-language-override"] = !0, n["font-size"] = !0, n["font-size-adjust"] = !0, n["font-stretch"] = !0, n["font-style"] = !0, n["font-synthesis"] = !0, n["font-variant"] = !0, n["font-variant-alternates"] = !0, n["font-variant-caps"] = !0, n["font-variant-east-asian"] = !0, n["font-variant-ligatures"] = !0, n["font-variant-numeric"] = !0, n["font-variant-position"] = !0, n["font-weight"] = !0, n.grid = !1, n["grid-area"] = !1, n["grid-auto-columns"] = !1, n["grid-auto-flow"] = !1, n["grid-auto-rows"] = !1, n["grid-column"] = !1, n["grid-column-end"] = !1, n["grid-column-start"] = !1, n["grid-row"] = !1, n["grid-row-end"] = !1, n["grid-row-start"] = !1, n["grid-template"] = !1, n["grid-template-areas"] = !1, n["grid-template-columns"] = !1, n["grid-template-rows"] = !1, n["hanging-punctuation"] = !1, n.height = !0, n.hyphens = !1, n.icon = !1, n["image-orientation"] = !1, n["image-resolution"] = !1, n["ime-mode"] = !1, n["initial-letters"] = !1, n["inline-box-align"] = !1, n["justify-content"] = !1, n["justify-items"] = !1, n["justify-self"] = !1, n.left = !1, n["letter-spacing"] = !0, n["lighting-color"] = !0, n["line-box-contain"] = !1, n["line-break"] = !1, n["line-grid"] = !1, n["line-height"] = !1, n["line-snap"] = !1, n["line-stacking"] = !1, n["line-stacking-ruby"] = !1, n["line-stacking-shift"] = !1, n["line-stacking-strategy"] = !1, n["list-style"] = !0, n["list-style-image"] = !0, n["list-style-position"] = !0, n["list-style-type"] = !0, n.margin = !0, n["margin-bottom"] = !0, n["margin-left"] = !0, n["margin-right"] = !0, n["margin-top"] = !0, n["marker-offset"] = !1, n["marker-side"] = !1, n.marks = !1, n.mask = !1, n["mask-box"] = !1, n["mask-box-outset"] = !1, n["mask-box-repeat"] = !1, n["mask-box-slice"] = !1, n["mask-box-source"] = !1, n["mask-box-width"] = !1, n["mask-clip"] = !1, n["mask-image"] = !1, n["mask-origin"] = !1, n["mask-position"] = !1, n["mask-repeat"] = !1, n["mask-size"] = !1, n["mask-source-type"] = !1, n["mask-type"] = !1, n["max-height"] = !0, n["max-lines"] = !1, n["max-width"] = !0, n["min-height"] = !0, n["min-width"] = !0, n["move-to"] = !1, n["nav-down"] = !1, n["nav-index"] = !1, n["nav-left"] = !1, n["nav-right"] = !1, n["nav-up"] = !1, n["object-fit"] = !1, n["object-position"] = !1, n.opacity = !1, n.order = !1, n.orphans = !1, n.outline = !1, n["outline-color"] = !1, n["outline-offset"] = !1, n["outline-style"] = !1, n["outline-width"] = !1, n.overflow = !1, n["overflow-wrap"] = !1, n["overflow-x"] = !1, n["overflow-y"] = !1, n.padding = !0, n["padding-bottom"] = !0, n["padding-left"] = !0, n["padding-right"] = !0, n["padding-top"] = !0, n.page = !1, n["page-break-after"] = !1, n["page-break-before"] = !1, n["page-break-inside"] = !1, n["page-policy"] = !1, n.pause = !1, n["pause-after"] = !1, n["pause-before"] = !1, n.perspective = !1, n["perspective-origin"] = !1, n.pitch = !1, n["pitch-range"] = !1, n["play-during"] = !1, n.position = !1, n["presentation-level"] = !1, n.quotes = !1, n["region-fragment"] = !1, n.resize = !1, n.rest = !1, n["rest-after"] = !1, n["rest-before"] = !1, n.richness = !1, n.right = !1, n.rotation = !1, n["rotation-point"] = !1, n["ruby-align"] = !1, n["ruby-merge"] = !1, n["ruby-position"] = !1, n["shape-image-threshold"] = !1, n["shape-outside"] = !1, n["shape-margin"] = !1, n.size = !1, n.speak = !1, n["speak-as"] = !1, n["speak-header"] = !1, n["speak-numeral"] = !1, n["speak-punctuation"] = !1, n["speech-rate"] = !1, n.stress = !1, n["string-set"] = !1, n["tab-size"] = !1, n["table-layout"] = !1, n["text-align"] = !0, n["text-align-last"] = !0, n["text-combine-upright"] = !0, n["text-decoration"] = !0, n["text-decoration-color"] = !0, n["text-decoration-line"] = !0, n["text-decoration-skip"] = !0, n["text-decoration-style"] = !0, n["text-emphasis"] = !0, n["text-emphasis-color"] = !0, n["text-emphasis-position"] = !0, n["text-emphasis-style"] = !0, n["text-height"] = !0, n["text-indent"] = !0, n["text-justify"] = !0, n["text-orientation"] = !0, n["text-overflow"] = !0, n["text-shadow"] = !0, n["text-space-collapse"] = !0, n["text-transform"] = !0, n["text-underline-position"] = !0, n["text-wrap"] = !0, n.top = !1, n.transform = !1, n["transform-origin"] = !1, n["transform-style"] = !1, n.transition = !1, n["transition-delay"] = !1, n["transition-duration"] = !1, n["transition-property"] = !1, n["transition-timing-function"] = !1, n["unicode-bidi"] = !1, n["vertical-align"] = !1, n.visibility = !1, n["voice-balance"] = !1, n["voice-duration"] = !1, n["voice-family"] = !1, n["voice-pitch"] = !1, n["voice-range"] = !1, n["voice-rate"] = !1, n["voice-stress"] = !1, n["voice-volume"] = !1, n.volume = !1, n["white-space"] = !1, n.widows = !1, n.width = !0, n["will-change"] = !1, n["word-break"] = !0, n["word-spacing"] = !0, n["word-wrap"] = !0, n["wrap-flow"] = !1, n["wrap-through"] = !1, n["writing-mode"] = !1, n["z-index"] = !1, n;
}
function lbt(n, e, t) {
}
function ubt(n, e, t) {
}
var cbt = /javascript\s*\:/img;
function hbt(n, e) {
  return cbt.test(e) ? "" : e;
}
Pd.whiteList = xK();
Pd.getDefaultWhiteList = xK;
Pd.onAttr = lbt;
Pd.onIgnoreAttr = ubt;
Pd.safeAttrValue = hbt;
var fbt = {
  indexOf: function(n, e) {
    var t, r;
    if (Array.prototype.indexOf)
      return n.indexOf(e);
    for (t = 0, r = n.length; t < r; t++)
      if (n[t] === e)
        return t;
    return -1;
  },
  forEach: function(n, e, t) {
    var r, i;
    if (Array.prototype.forEach)
      return n.forEach(e, t);
    for (r = 0, i = n.length; r < i; r++)
      e.call(t, n[r], r, n);
  },
  trim: function(n) {
    return String.prototype.trim ? n.trim() : n.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(n) {
    return String.prototype.trimRight ? n.trimRight() : n.replace(/(\s*$)/g, "");
  }
}, rm = fbt;
function dbt(n, e) {
  n = rm.trimRight(n), n[n.length - 1] !== ";" && (n += ";");
  var t = n.length, r = !1, i = 0, o = 0, a = "";
  function s() {
    if (!r) {
      var c = rm.trim(n.slice(i, o)), h = c.indexOf(":");
      if (h !== -1) {
        var f = rm.trim(c.slice(0, h)), d = rm.trim(c.slice(h + 1));
        if (f) {
          var p = e(i, a.length, f, d, c);
          p && (a += p + "; ");
        }
      }
    }
    i = o + 1;
  }
  for (; o < t; o++) {
    var l = n[o];
    if (l === "/" && n[o + 1] === "*") {
      var u = n.indexOf("*/", o + 2);
      if (u === -1)
        break;
      o = u + 1, i = o + 1, r = !1;
    } else
      l === "(" ? r = !0 : l === ")" ? r = !1 : l === ";" ? r || s() : l === `
` && s();
  }
  return rm.trim(a);
}
var pbt = dbt, Y1 = Pd, gbt = pbt;
function rz(n) {
  return n == null;
}
function vbt(n) {
  var e = {};
  for (var t in n)
    e[t] = n[t];
  return e;
}
function SK(n) {
  n = vbt(n || {}), n.whiteList = n.whiteList || Y1.whiteList, n.onAttr = n.onAttr || Y1.onAttr, n.onIgnoreAttr = n.onIgnoreAttr || Y1.onIgnoreAttr, n.safeAttrValue = n.safeAttrValue || Y1.safeAttrValue, this.options = n;
}
SK.prototype.process = function(n) {
  if (n = n || "", n = n.toString(), !n)
    return "";
  var e = this, t = e.options, r = t.whiteList, i = t.onAttr, o = t.onIgnoreAttr, a = t.safeAttrValue, s = gbt(n, function(l, u, c, h, f) {
    var d = r[c], p = !1;
    if (d === !0 ? p = d : typeof d == "function" ? p = d(h) : d instanceof RegExp && (p = d.test(h)), p !== !0 && (p = !1), h = a(c, h), !!h) {
      var g = {
        position: u,
        sourcePosition: l,
        source: f,
        isWhite: p
      };
      if (p) {
        var v = i(c, h, g);
        return rz(v) ? c + ":" + h : v;
      } else {
        var v = o(c, h, g);
        if (!rz(v))
          return v;
      }
    }
  });
  return s;
};
var mbt = SK;
(function(n, e) {
  var t = Pd, r = mbt;
  function i(a, s) {
    var l = new r(s);
    return l.process(a);
  }
  e = n.exports = i, e.FilterCSS = r;
  for (var o in t)
    e[o] = t[o];
  typeof window < "u" && (window.filterCSS = n.exports);
})(eM, eM.exports);
var pR = eM.exports, gR = {
  indexOf: function(n, e) {
    var t, r;
    if (Array.prototype.indexOf)
      return n.indexOf(e);
    for (t = 0, r = n.length; t < r; t++)
      if (n[t] === e)
        return t;
    return -1;
  },
  forEach: function(n, e, t) {
    var r, i;
    if (Array.prototype.forEach)
      return n.forEach(e, t);
    for (r = 0, i = n.length; r < i; r++)
      e.call(t, n[r], r, n);
  },
  trim: function(n) {
    return String.prototype.trim ? n.trim() : n.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(n) {
    var e = /\s|\n|\t/, t = e.exec(n);
    return t ? t.index : -1;
  }
}, ybt = pR.FilterCSS, bbt = pR.getDefaultWhiteList, rS = gR;
function _K() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var CK = new ybt();
function Obt(n, e, t) {
}
function wbt(n, e, t) {
}
function xbt(n, e, t) {
}
function Sbt(n, e, t) {
}
function AK(n) {
  return n.replace(Cbt, "&lt;").replace(Abt, "&gt;");
}
function _bt(n, e, t, r) {
  if (t = DK(t), e === "href" || e === "src") {
    if (t = rS.trim(t), t === "#")
      return "#";
    if (!(t.substr(0, 7) === "http://" || t.substr(0, 8) === "https://" || t.substr(0, 7) === "mailto:" || t.substr(0, 4) === "tel:" || t.substr(0, 11) === "data:image/" || t.substr(0, 6) === "ftp://" || t.substr(0, 2) === "./" || t.substr(0, 3) === "../" || t[0] === "#" || t[0] === "/"))
      return "";
  } else if (e === "background") {
    if (X1.lastIndex = 0, X1.test(t))
      return "";
  } else if (e === "style") {
    if (iz.lastIndex = 0, iz.test(t) || (oz.lastIndex = 0, oz.test(t) && (X1.lastIndex = 0, X1.test(t))))
      return "";
    r !== !1 && (r = r || CK, t = r.process(t));
  }
  return t = LK(t), t;
}
var Cbt = /</g, Abt = />/g, Tbt = /"/g, kbt = /&quot;/g, Pbt = /&#([a-zA-Z0-9]*);?/gim, Ebt = /&colon;?/gim, Mbt = /&newline;?/gim, X1 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi, iz = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, oz = /u\s*r\s*l\s*\(.*/gi;
function TK(n) {
  return n.replace(Tbt, "&quot;");
}
function kK(n) {
  return n.replace(kbt, '"');
}
function PK(n) {
  return n.replace(Pbt, function(t, r) {
    return r[0] === "x" || r[0] === "X" ? String.fromCharCode(parseInt(r.substr(1), 16)) : String.fromCharCode(parseInt(r, 10));
  });
}
function EK(n) {
  return n.replace(Ebt, ":").replace(Mbt, " ");
}
function MK(n) {
  for (var e = "", t = 0, r = n.length; t < r; t++)
    e += n.charCodeAt(t) < 32 ? " " : n.charAt(t);
  return rS.trim(e);
}
function DK(n) {
  return n = kK(n), n = PK(n), n = EK(n), n = MK(n), n;
}
function LK(n) {
  return n = TK(n), n = AK(n), n;
}
function Dbt() {
  return "";
}
function Lbt(n, e) {
  typeof e != "function" && (e = function() {
  });
  var t = !Array.isArray(n);
  function r(a) {
    return t ? !0 : rS.indexOf(n, a) !== -1;
  }
  var i = [], o = !1;
  return {
    onIgnoreTag: function(a, s, l) {
      if (r(a))
        if (l.isClosing) {
          var u = "[/removed]", c = l.position + u.length;
          return i.push([
            o !== !1 ? o : l.position,
            c
          ]), o = !1, u;
        } else
          return o || (o = l.position), "[removed]";
      else
        return e(a, s, l);
    },
    remove: function(a) {
      var s = "", l = 0;
      return rS.forEach(i, function(u) {
        s += a.slice(l, u[0]), l = u[1];
      }), s += a.slice(l), s;
    }
  };
}
function Ibt(n) {
  for (var e = "", t = 0; t < n.length; ) {
    var r = n.indexOf("<!--", t);
    if (r === -1) {
      e += n.slice(t);
      break;
    }
    e += n.slice(t, r);
    var i = n.indexOf("-->", r);
    if (i === -1)
      break;
    t = i + 3;
  }
  return e;
}
function Rbt(n) {
  var e = n.split("");
  return e = e.filter(function(t) {
    var r = t.charCodeAt(0);
    return r === 127 ? !1 : r <= 31 ? r === 10 || r === 13 : !0;
  }), e.join("");
}
Xn.whiteList = _K();
Xn.getDefaultWhiteList = _K;
Xn.onTag = Obt;
Xn.onIgnoreTag = wbt;
Xn.onTagAttr = xbt;
Xn.onIgnoreTagAttr = Sbt;
Xn.safeAttrValue = _bt;
Xn.escapeHtml = AK;
Xn.escapeQuote = TK;
Xn.unescapeQuote = kK;
Xn.escapeHtmlEntities = PK;
Xn.escapeDangerHtml5Entities = EK;
Xn.clearNonPrintableCharacter = MK;
Xn.friendlyAttrValue = DK;
Xn.escapeAttrValue = LK;
Xn.onIgnoreTagStripAll = Dbt;
Xn.StripTagBody = Lbt;
Xn.stripCommentTag = Ibt;
Xn.stripBlankChar = Rbt;
Xn.cssFilter = CK;
Xn.getDefaultCSSWhiteList = bbt;
var cC = {}, ec = gR;
function Nbt(n) {
  var e = ec.spaceIndex(n), t;
  return e === -1 ? t = n.slice(1, -1) : t = n.slice(1, e + 1), t = ec.trim(t).toLowerCase(), t.slice(0, 1) === "/" && (t = t.slice(1)), t.slice(-1) === "/" && (t = t.slice(0, -1)), t;
}
function $bt(n) {
  return n.slice(0, 2) === "</";
}
function Bbt(n, e, t) {
  var r = "", i = 0, o = !1, a = !1, s = 0, l = n.length, u = "", c = "";
  e:
    for (s = 0; s < l; s++) {
      var h = n.charAt(s);
      if (o === !1) {
        if (h === "<") {
          o = s;
          continue;
        }
      } else if (a === !1) {
        if (h === "<") {
          r += t(n.slice(i, s)), o = s, i = s;
          continue;
        }
        if (h === ">" || s === l - 1) {
          r += t(n.slice(i, o)), c = n.slice(o, s + 1), u = Nbt(c), r += e(
            o,
            r.length,
            u,
            c,
            $bt(c)
          ), i = s + 1, o = !1;
          continue;
        }
        if (h === '"' || h === "'")
          for (var f = 1, d = n.charAt(s - f); d.trim() === "" || d === "="; ) {
            if (d === "=") {
              a = h;
              continue e;
            }
            d = n.charAt(s - ++f);
          }
      } else if (h === a) {
        a = !1;
        continue;
      }
    }
  return i < l && (r += t(n.substr(i))), r;
}
var Vbt = /[^a-zA-Z0-9\\_:.-]/gim;
function zbt(n, e) {
  var t = 0, r = 0, i = [], o = !1, a = n.length;
  function s(f, d) {
    if (f = ec.trim(f), f = f.replace(Vbt, "").toLowerCase(), !(f.length < 1)) {
      var p = e(f, d || "");
      p && i.push(p);
    }
  }
  for (var l = 0; l < a; l++) {
    var u = n.charAt(l), c, h;
    if (o === !1 && u === "=") {
      o = n.slice(t, l), t = l + 1, r = n.charAt(t) === '"' || n.charAt(t) === "'" ? t : Qbt(n, l + 1);
      continue;
    }
    if (o !== !1 && l === r) {
      if (h = n.indexOf(u, l + 1), h === -1)
        break;
      c = ec.trim(n.slice(r + 1, h)), s(o, c), o = !1, l = h, t = l + 1;
      continue;
    }
    if (/\s|\n|\t/.test(u))
      if (n = n.replace(/\s|\n|\t/g, " "), o === !1)
        if (h = Fbt(n, l), h === -1) {
          c = ec.trim(n.slice(t, l)), s(c), o = !1, t = l + 1;
          continue;
        } else {
          l = h - 1;
          continue;
        }
      else if (h = Zbt(n, l - 1), h === -1) {
        c = ec.trim(n.slice(t, l)), c = az(c), s(o, c), o = !1, t = l + 1;
        continue;
      } else
        continue;
  }
  return t < n.length && (o === !1 ? s(n.slice(t)) : s(o, az(ec.trim(n.slice(t))))), ec.trim(i.join(" "));
}
function Fbt(n, e) {
  for (; e < n.length; e++) {
    var t = n[e];
    if (t !== " ")
      return t === "=" ? e : -1;
  }
}
function Qbt(n, e) {
  for (; e < n.length; e++) {
    var t = n[e];
    if (t !== " ")
      return t === "'" || t === '"' ? e : -1;
  }
}
function Zbt(n, e) {
  for (; e > 0; e--) {
    var t = n[e];
    if (t !== " ")
      return t === "=" ? e : -1;
  }
}
function Wbt(n) {
  return n[0] === '"' && n[n.length - 1] === '"' || n[0] === "'" && n[n.length - 1] === "'";
}
function az(n) {
  return Wbt(n) ? n.substr(1, n.length - 2) : n;
}
cC.parseTag = Bbt;
cC.parseAttr = zbt;
var Gbt = pR.FilterCSS, qa = Xn, IK = cC, jbt = IK.parseTag, Hbt = IK.parseAttr, Iw = gR;
function U1(n) {
  return n == null;
}
function qbt(n) {
  var e = Iw.spaceIndex(n);
  if (e === -1)
    return {
      html: "",
      closing: n[n.length - 2] === "/"
    };
  n = Iw.trim(n.slice(e + 1, -1));
  var t = n[n.length - 1] === "/";
  return t && (n = Iw.trim(n.slice(0, -1))), {
    html: n,
    closing: t
  };
}
function Ybt(n) {
  var e = {};
  for (var t in n)
    e[t] = n[t];
  return e;
}
function Xbt(n) {
  var e = {};
  for (var t in n)
    Array.isArray(n[t]) ? e[t.toLowerCase()] = n[t].map(function(r) {
      return r.toLowerCase();
    }) : e[t.toLowerCase()] = n[t];
  return e;
}
function RK(n) {
  n = Ybt(n || {}), n.stripIgnoreTag && (n.onIgnoreTag && console.error(
    'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
  ), n.onIgnoreTag = qa.onIgnoreTagStripAll), n.whiteList || n.allowList ? n.whiteList = Xbt(n.whiteList || n.allowList) : n.whiteList = qa.whiteList, n.onTag = n.onTag || qa.onTag, n.onTagAttr = n.onTagAttr || qa.onTagAttr, n.onIgnoreTag = n.onIgnoreTag || qa.onIgnoreTag, n.onIgnoreTagAttr = n.onIgnoreTagAttr || qa.onIgnoreTagAttr, n.safeAttrValue = n.safeAttrValue || qa.safeAttrValue, n.escapeHtml = n.escapeHtml || qa.escapeHtml, this.options = n, n.css === !1 ? this.cssFilter = !1 : (n.css = n.css || {}, this.cssFilter = new Gbt(n.css));
}
RK.prototype.process = function(n) {
  if (n = n || "", n = n.toString(), !n)
    return "";
  var e = this, t = e.options, r = t.whiteList, i = t.onTag, o = t.onIgnoreTag, a = t.onTagAttr, s = t.onIgnoreTagAttr, l = t.safeAttrValue, u = t.escapeHtml, c = e.cssFilter;
  t.stripBlankChar && (n = qa.stripBlankChar(n)), t.allowCommentTag || (n = qa.stripCommentTag(n));
  var h = !1;
  t.stripIgnoreTagBody && (h = qa.StripTagBody(
    t.stripIgnoreTagBody,
    o
  ), o = h.onIgnoreTag);
  var f = jbt(
    n,
    function(d, p, g, v, m) {
      var y = {
        sourcePosition: d,
        position: p,
        isClosing: m,
        isWhite: Object.prototype.hasOwnProperty.call(r, g)
      }, b = i(g, v, y);
      if (!U1(b))
        return b;
      if (y.isWhite) {
        if (y.isClosing)
          return "</" + g + ">";
        var O = qbt(v), w = r[g], x = Hbt(O.html, function(S, _) {
          var C = Iw.indexOf(w, S) !== -1, A = a(g, S, _, C);
          return U1(A) ? C ? (_ = l(g, S, _, c), _ ? S + '="' + _ + '"' : S) : (A = s(g, S, _, C), U1(A) ? void 0 : A) : A;
        });
        return v = "<" + g, x && (v += " " + x), O.closing && (v += " /"), v += ">", v;
      } else
        return b = o(g, v, y), U1(b) ? u(v) : b;
    },
    u
  );
  return h && (f = h.remove(f)), f;
};
var Ubt = RK;
(function(n, e) {
  var t = Xn, r = cC, i = Ubt;
  function o(s, l) {
    var u = new i(l);
    return u.process(s);
  }
  e = n.exports = o, e.filterXSS = o, e.FilterXSS = i, function() {
    for (var s in t)
      e[s] = t[s];
    for (var l in r)
      e[l] = r[l];
  }(), typeof window < "u" && (window.filterXSS = n.exports);
  function a() {
    return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
  }
  a() && (self.filterXSS = n.exports);
})(JE, JE.exports);
var Kbt = JE.exports;
const sz = Kbt;
var Jbt = function(e, { xss: t } = {}) {
  const r = new sz.FilterXSS(typeof t == "function" ? t(sz) : t);
  function i(a) {
    return a = r.process(a), a;
  }
  function o(a) {
    for (let s = 0; s < a.tokens.length; s++) {
      let l = a.tokens[s];
      if (l.type === "html_block" && (l.content = i(l.content)), l.type === "inline") {
        let u = l.children;
        for (let c = 0; c < u.length; c++)
          u[c].type === "html_inline" && (u[c].content = i(u[c].content));
      }
    }
  }
  e.core.ruler.after("linkify", "xss", o);
};
const e1t = /* @__PURE__ */ wb(Jbt), im = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, NK = /* @__PURE__ */ new Set(), t1t = (n, e, t, r) => {
  typeof process == "object" && process && typeof process.emitWarning == "function" ? process.emitWarning(n, e, t, r) : console.error(`[${t}] ${e}: ${n}`);
}, n1t = (n) => !NK.has(n), Gu = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), $K = (n) => Gu(n) ? n <= Math.pow(2, 8) ? Uint8Array : n <= Math.pow(2, 16) ? Uint16Array : n <= Math.pow(2, 32) ? Uint32Array : n <= Number.MAX_SAFE_INTEGER ? Rw : null : null;
class Rw extends Array {
  constructor(e) {
    super(e), this.fill(0);
  }
}
var ng;
const cf = class cf {
  constructor(e, t) {
    Zr(this, "heap");
    Zr(this, "length");
    if (!Z(cf, ng))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new t(e), this.length = 0;
  }
  static create(e) {
    const t = $K(e);
    if (!t)
      return [];
    ut(cf, ng, !0);
    const r = new cf(e, t);
    return ut(cf, ng, !1), r;
  }
  push(e) {
    this.heap[this.length++] = e;
  }
  pop() {
    return this.heap[--this.length];
  }
};
ng = new WeakMap(), // private constructor
Mt(cf, ng, !1);
let tM = cf;
var Xa, $o, zs, Ua, rg, Pr, Ka, Er, In, Tt, Zi, Bo, Ti, Gr, Ja, ei, Gl, jl, es, Fs, oc, fo, ib, rM, kf, Hl, ob, Vo, i_, BK, Pf, ig, ab, Qs, ju, Zs, Hu, sb, iM, og, Nw, ag, $w, kn, Qn, lb, oM, Ef, jm;
const M$ = class M$ {
  constructor(e) {
    Mt(this, ib);
    Mt(this, i_);
    Mt(this, Qs);
    Mt(this, Zs);
    Mt(this, sb);
    Mt(this, og);
    Mt(this, ag);
    Mt(this, kn);
    Mt(this, lb);
    Mt(this, Ef);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    Mt(this, Xa, void 0);
    Mt(this, $o, void 0);
    Mt(this, zs, void 0);
    Mt(this, Ua, void 0);
    Mt(this, rg, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    Zr(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    Zr(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    Zr(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    Zr(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    Zr(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    Zr(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    Zr(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    Zr(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    Zr(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    Zr(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    Zr(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    Zr(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    Zr(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    Zr(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    Zr(this, "ignoreFetchAbort");
    // computed properties
    Mt(this, Pr, void 0);
    Mt(this, Ka, void 0);
    Mt(this, Er, void 0);
    Mt(this, In, void 0);
    Mt(this, Tt, void 0);
    Mt(this, Zi, void 0);
    Mt(this, Bo, void 0);
    Mt(this, Ti, void 0);
    Mt(this, Gr, void 0);
    Mt(this, Ja, void 0);
    Mt(this, ei, void 0);
    Mt(this, Gl, void 0);
    Mt(this, jl, void 0);
    Mt(this, es, void 0);
    Mt(this, Fs, void 0);
    Mt(this, oc, void 0);
    Mt(this, fo, void 0);
    // conditionally set private methods related to TTL
    Mt(this, kf, () => {
    });
    Mt(this, Hl, () => {
    });
    Mt(this, ob, () => {
    });
    /* c8 ignore stop */
    Mt(this, Vo, () => !1);
    Mt(this, Pf, (e) => {
    });
    Mt(this, ig, (e, t, r) => {
    });
    Mt(this, ab, (e, t, r, i) => {
      if (r || i)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    });
    const { max: t = 0, ttl: r, ttlResolution: i = 1, ttlAutopurge: o, updateAgeOnGet: a, updateAgeOnHas: s, allowStale: l, dispose: u, disposeAfter: c, noDisposeOnSet: h, noUpdateTTL: f, maxSize: d = 0, maxEntrySize: p = 0, sizeCalculation: g, fetchMethod: v, noDeleteOnFetchRejection: m, noDeleteOnStaleGet: y, allowStaleOnFetchRejection: b, allowStaleOnFetchAbort: O, ignoreFetchAbort: w } = e;
    if (t !== 0 && !Gu(t))
      throw new TypeError("max option must be a nonnegative integer");
    const x = t ? $K(t) : Array;
    if (!x)
      throw new Error("invalid max value: " + t);
    if (ut(this, Xa, t), ut(this, $o, d), this.maxEntrySize = p || Z(this, $o), this.sizeCalculation = g, this.sizeCalculation) {
      if (!Z(this, $o) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (v !== void 0 && typeof v != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (ut(this, rg, v), ut(this, oc, !!v), ut(this, Er, /* @__PURE__ */ new Map()), ut(this, In, new Array(t).fill(void 0)), ut(this, Tt, new Array(t).fill(void 0)), ut(this, Zi, new x(t)), ut(this, Bo, new x(t)), ut(this, Ti, 0), ut(this, Gr, 0), ut(this, Ja, tM.create(t)), ut(this, Pr, 0), ut(this, Ka, 0), typeof u == "function" && ut(this, zs, u), typeof c == "function" ? (ut(this, Ua, c), ut(this, ei, [])) : (ut(this, Ua, void 0), ut(this, ei, void 0)), ut(this, Fs, !!Z(this, zs)), ut(this, fo, !!Z(this, Ua)), this.noDisposeOnSet = !!h, this.noUpdateTTL = !!f, this.noDeleteOnFetchRejection = !!m, this.allowStaleOnFetchRejection = !!b, this.allowStaleOnFetchAbort = !!O, this.ignoreFetchAbort = !!w, this.maxEntrySize !== 0) {
      if (Z(this, $o) !== 0 && !Gu(Z(this, $o)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!Gu(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      tt(this, i_, BK).call(this);
    }
    if (this.allowStale = !!l, this.noDeleteOnStaleGet = !!y, this.updateAgeOnGet = !!a, this.updateAgeOnHas = !!s, this.ttlResolution = Gu(i) || i === 0 ? i : 1, this.ttlAutopurge = !!o, this.ttl = r || 0, this.ttl) {
      if (!Gu(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      tt(this, ib, rM).call(this);
    }
    if (Z(this, Xa) === 0 && this.ttl === 0 && Z(this, $o) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !Z(this, Xa) && !Z(this, $o)) {
      const S = "LRU_CACHE_UNBOUNDED";
      n1t(S) && (NK.add(S), t1t("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", S, M$));
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(e) {
    return {
      // properties
      starts: Z(e, jl),
      ttls: Z(e, es),
      sizes: Z(e, Gl),
      keyMap: Z(e, Er),
      keyList: Z(e, In),
      valList: Z(e, Tt),
      next: Z(e, Zi),
      prev: Z(e, Bo),
      get head() {
        return Z(e, Ti);
      },
      get tail() {
        return Z(e, Gr);
      },
      free: Z(e, Ja),
      // methods
      isBackgroundFetch: (t) => {
        var r;
        return tt(r = e, kn, Qn).call(r, t);
      },
      backgroundFetch: (t, r, i, o) => {
        var a;
        return tt(a = e, ag, $w).call(a, t, r, i, o);
      },
      moveToTail: (t) => {
        var r;
        return tt(r = e, Ef, jm).call(r, t);
      },
      indexes: (t) => {
        var r;
        return tt(r = e, Qs, ju).call(r, t);
      },
      rindexes: (t) => {
        var r;
        return tt(r = e, Zs, Hu).call(r, t);
      },
      isStale: (t) => {
        var r;
        return Z(r = e, Vo).call(r, t);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return Z(this, Xa);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return Z(this, $o);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return Z(this, Ka);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return Z(this, Pr);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return Z(this, rg);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return Z(this, zs);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return Z(this, Ua);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(e) {
    return Z(this, Er).has(e) ? 1 / 0 : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const e of tt(this, Qs, ju).call(this))
      Z(this, Tt)[e] !== void 0 && Z(this, In)[e] !== void 0 && !tt(this, kn, Qn).call(this, Z(this, Tt)[e]) && (yield [Z(this, In)[e], Z(this, Tt)[e]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const e of tt(this, Zs, Hu).call(this))
      Z(this, Tt)[e] !== void 0 && Z(this, In)[e] !== void 0 && !tt(this, kn, Qn).call(this, Z(this, Tt)[e]) && (yield [Z(this, In)[e], Z(this, Tt)[e]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const e of tt(this, Qs, ju).call(this)) {
      const t = Z(this, In)[e];
      t !== void 0 && !tt(this, kn, Qn).call(this, Z(this, Tt)[e]) && (yield t);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const e of tt(this, Zs, Hu).call(this)) {
      const t = Z(this, In)[e];
      t !== void 0 && !tt(this, kn, Qn).call(this, Z(this, Tt)[e]) && (yield t);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const e of tt(this, Qs, ju).call(this))
      Z(this, Tt)[e] !== void 0 && !tt(this, kn, Qn).call(this, Z(this, Tt)[e]) && (yield Z(this, Tt)[e]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const e of tt(this, Zs, Hu).call(this))
      Z(this, Tt)[e] !== void 0 && !tt(this, kn, Qn).call(this, Z(this, Tt)[e]) && (yield Z(this, Tt)[e]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(e, t = {}) {
    for (const r of tt(this, Qs, ju).call(this)) {
      const i = Z(this, Tt)[r], o = tt(this, kn, Qn).call(this, i) ? i.__staleWhileFetching : i;
      if (o !== void 0 && e(o, Z(this, In)[r], this))
        return this.get(Z(this, In)[r], t);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(e, t = this) {
    for (const r of tt(this, Qs, ju).call(this)) {
      const i = Z(this, Tt)[r], o = tt(this, kn, Qn).call(this, i) ? i.__staleWhileFetching : i;
      o !== void 0 && e.call(t, o, Z(this, In)[r], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(e, t = this) {
    for (const r of tt(this, Zs, Hu).call(this)) {
      const i = Z(this, Tt)[r], o = tt(this, kn, Qn).call(this, i) ? i.__staleWhileFetching : i;
      o !== void 0 && e.call(t, o, Z(this, In)[r], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let e = !1;
    for (const t of tt(this, Zs, Hu).call(this, { allowStale: !0 }))
      Z(this, Vo).call(this, t) && (this.delete(Z(this, In)[t]), e = !0);
    return e;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const e = [];
    for (const t of tt(this, Qs, ju).call(this, { allowStale: !0 })) {
      const r = Z(this, In)[t], i = Z(this, Tt)[t], o = tt(this, kn, Qn).call(this, i) ? i.__staleWhileFetching : i;
      if (o === void 0 || r === void 0)
        continue;
      const a = { value: o };
      if (Z(this, es) && Z(this, jl)) {
        a.ttl = Z(this, es)[t];
        const s = im.now() - Z(this, jl)[t];
        a.start = Math.floor(Date.now() - s);
      }
      Z(this, Gl) && (a.size = Z(this, Gl)[t]), e.unshift([r, a]);
    }
    return e;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(e) {
    this.clear();
    for (const [t, r] of e) {
      if (r.start) {
        const i = Date.now() - r.start;
        r.start = im.now() - i;
      }
      this.set(t, r.value, r);
    }
  }
  /**
   * Add a value to the cache.
   */
  set(e, t, r = {}) {
    var f, d, p;
    const { ttl: i = this.ttl, start: o, noDisposeOnSet: a = this.noDisposeOnSet, sizeCalculation: s = this.sizeCalculation, status: l } = r;
    let { noUpdateTTL: u = this.noUpdateTTL } = r;
    const c = Z(this, ab).call(this, e, t, r.size || 0, s);
    if (this.maxEntrySize && c > this.maxEntrySize)
      return l && (l.set = "miss", l.maxEntrySizeExceeded = !0), this.delete(e), this;
    let h = Z(this, Pr) === 0 ? void 0 : Z(this, Er).get(e);
    if (h === void 0)
      h = Z(this, Pr) === 0 ? Z(this, Gr) : Z(this, Ja).length !== 0 ? Z(this, Ja).pop() : Z(this, Pr) === Z(this, Xa) ? tt(this, og, Nw).call(this, !1) : Z(this, Pr), Z(this, In)[h] = e, Z(this, Tt)[h] = t, Z(this, Er).set(e, h), Z(this, Zi)[Z(this, Gr)] = h, Z(this, Bo)[h] = Z(this, Gr), ut(this, Gr, h), r1(this, Pr)._++, Z(this, ig).call(this, h, c, l), l && (l.set = "add"), u = !1;
    else {
      tt(this, Ef, jm).call(this, h);
      const g = Z(this, Tt)[h];
      if (t !== g) {
        if (Z(this, oc) && tt(this, kn, Qn).call(this, g) ? g.__abortController.abort(new Error("replaced")) : a || (Z(this, Fs) && ((f = Z(this, zs)) == null || f.call(this, g, e, "set")), Z(this, fo) && ((d = Z(this, ei)) == null || d.push([g, e, "set"]))), Z(this, Pf).call(this, h), Z(this, ig).call(this, h, c, l), Z(this, Tt)[h] = t, l) {
          l.set = "replace";
          const v = g && tt(this, kn, Qn).call(this, g) ? g.__staleWhileFetching : g;
          v !== void 0 && (l.oldValue = v);
        }
      } else
        l && (l.set = "update");
    }
    if (i !== 0 && !Z(this, es) && tt(this, ib, rM).call(this), Z(this, es) && (u || Z(this, ob).call(this, h, i, o), l && Z(this, Hl).call(this, l, h)), !a && Z(this, fo) && Z(this, ei)) {
      const g = Z(this, ei);
      let v;
      for (; v = g == null ? void 0 : g.shift(); )
        (p = Z(this, Ua)) == null || p.call(this, ...v);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var e;
    try {
      for (; Z(this, Pr); ) {
        const t = Z(this, Tt)[Z(this, Ti)];
        if (tt(this, og, Nw).call(this, !0), tt(this, kn, Qn).call(this, t)) {
          if (t.__staleWhileFetching)
            return t.__staleWhileFetching;
        } else if (t !== void 0)
          return t;
      }
    } finally {
      if (Z(this, fo) && Z(this, ei)) {
        const t = Z(this, ei);
        let r;
        for (; r = t == null ? void 0 : t.shift(); )
          (e = Z(this, Ua)) == null || e.call(this, ...r);
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(e, t = {}) {
    const { updateAgeOnHas: r = this.updateAgeOnHas, status: i } = t, o = Z(this, Er).get(e);
    if (o !== void 0) {
      const a = Z(this, Tt)[o];
      if (tt(this, kn, Qn).call(this, a) && a.__staleWhileFetching === void 0)
        return !1;
      if (Z(this, Vo).call(this, o))
        i && (i.has = "stale", Z(this, Hl).call(this, i, o));
      else
        return r && Z(this, kf).call(this, o), i && (i.has = "hit", Z(this, Hl).call(this, i, o)), !0;
    } else
      i && (i.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(e, t = {}) {
    const { allowStale: r = this.allowStale } = t, i = Z(this, Er).get(e);
    if (i !== void 0 && (r || !Z(this, Vo).call(this, i))) {
      const o = Z(this, Tt)[i];
      return tt(this, kn, Qn).call(this, o) ? o.__staleWhileFetching : o;
    }
  }
  async fetch(e, t = {}) {
    const {
      // get options
      allowStale: r = this.allowStale,
      updateAgeOnGet: i = this.updateAgeOnGet,
      noDeleteOnStaleGet: o = this.noDeleteOnStaleGet,
      // set options
      ttl: a = this.ttl,
      noDisposeOnSet: s = this.noDisposeOnSet,
      size: l = 0,
      sizeCalculation: u = this.sizeCalculation,
      noUpdateTTL: c = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: h = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: f = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: d = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: p = this.allowStaleOnFetchAbort,
      context: g,
      forceRefresh: v = !1,
      status: m,
      signal: y
    } = t;
    if (!Z(this, oc))
      return m && (m.fetch = "get"), this.get(e, {
        allowStale: r,
        updateAgeOnGet: i,
        noDeleteOnStaleGet: o,
        status: m
      });
    const b = {
      allowStale: r,
      updateAgeOnGet: i,
      noDeleteOnStaleGet: o,
      ttl: a,
      noDisposeOnSet: s,
      size: l,
      sizeCalculation: u,
      noUpdateTTL: c,
      noDeleteOnFetchRejection: h,
      allowStaleOnFetchRejection: f,
      allowStaleOnFetchAbort: p,
      ignoreFetchAbort: d,
      status: m,
      signal: y
    };
    let O = Z(this, Er).get(e);
    if (O === void 0) {
      m && (m.fetch = "miss");
      const w = tt(this, ag, $w).call(this, e, O, b, g);
      return w.__returned = w;
    } else {
      const w = Z(this, Tt)[O];
      if (tt(this, kn, Qn).call(this, w)) {
        const A = r && w.__staleWhileFetching !== void 0;
        return m && (m.fetch = "inflight", A && (m.returnedStale = !0)), A ? w.__staleWhileFetching : w.__returned = w;
      }
      const x = Z(this, Vo).call(this, O);
      if (!v && !x)
        return m && (m.fetch = "hit"), tt(this, Ef, jm).call(this, O), i && Z(this, kf).call(this, O), m && Z(this, Hl).call(this, m, O), w;
      const S = tt(this, ag, $w).call(this, e, O, b, g), C = S.__staleWhileFetching !== void 0 && r;
      return m && (m.fetch = x ? "stale" : "refresh", C && x && (m.returnedStale = !0)), C ? S.__staleWhileFetching : S.__returned = S;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(e, t = {}) {
    const { allowStale: r = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: o = this.noDeleteOnStaleGet, status: a } = t, s = Z(this, Er).get(e);
    if (s !== void 0) {
      const l = Z(this, Tt)[s], u = tt(this, kn, Qn).call(this, l);
      return a && Z(this, Hl).call(this, a, s), Z(this, Vo).call(this, s) ? (a && (a.get = "stale"), u ? (a && r && l.__staleWhileFetching !== void 0 && (a.returnedStale = !0), r ? l.__staleWhileFetching : void 0) : (o || this.delete(e), a && r && (a.returnedStale = !0), r ? l : void 0)) : (a && (a.get = "hit"), u ? l.__staleWhileFetching : (tt(this, Ef, jm).call(this, s), i && Z(this, kf).call(this, s), l));
    } else
      a && (a.get = "miss");
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(e) {
    var r, i, o, a;
    let t = !1;
    if (Z(this, Pr) !== 0) {
      const s = Z(this, Er).get(e);
      if (s !== void 0)
        if (t = !0, Z(this, Pr) === 1)
          this.clear();
        else {
          Z(this, Pf).call(this, s);
          const l = Z(this, Tt)[s];
          tt(this, kn, Qn).call(this, l) ? l.__abortController.abort(new Error("deleted")) : (Z(this, Fs) || Z(this, fo)) && (Z(this, Fs) && ((r = Z(this, zs)) == null || r.call(this, l, e, "delete")), Z(this, fo) && ((i = Z(this, ei)) == null || i.push([l, e, "delete"]))), Z(this, Er).delete(e), Z(this, In)[s] = void 0, Z(this, Tt)[s] = void 0, s === Z(this, Gr) ? ut(this, Gr, Z(this, Bo)[s]) : s === Z(this, Ti) ? ut(this, Ti, Z(this, Zi)[s]) : (Z(this, Zi)[Z(this, Bo)[s]] = Z(this, Zi)[s], Z(this, Bo)[Z(this, Zi)[s]] = Z(this, Bo)[s]), r1(this, Pr)._--, Z(this, Ja).push(s);
        }
    }
    if (Z(this, fo) && ((o = Z(this, ei)) != null && o.length)) {
      const s = Z(this, ei);
      let l;
      for (; l = s == null ? void 0 : s.shift(); )
        (a = Z(this, Ua)) == null || a.call(this, ...l);
    }
    return t;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var e, t, r;
    for (const i of tt(this, Zs, Hu).call(this, { allowStale: !0 })) {
      const o = Z(this, Tt)[i];
      if (tt(this, kn, Qn).call(this, o))
        o.__abortController.abort(new Error("deleted"));
      else {
        const a = Z(this, In)[i];
        Z(this, Fs) && ((e = Z(this, zs)) == null || e.call(this, o, a, "delete")), Z(this, fo) && ((t = Z(this, ei)) == null || t.push([o, a, "delete"]));
      }
    }
    if (Z(this, Er).clear(), Z(this, Tt).fill(void 0), Z(this, In).fill(void 0), Z(this, es) && Z(this, jl) && (Z(this, es).fill(0), Z(this, jl).fill(0)), Z(this, Gl) && Z(this, Gl).fill(0), ut(this, Ti, 0), ut(this, Gr, 0), Z(this, Ja).length = 0, ut(this, Ka, 0), ut(this, Pr, 0), Z(this, fo) && Z(this, ei)) {
      const i = Z(this, ei);
      let o;
      for (; o = i == null ? void 0 : i.shift(); )
        (r = Z(this, Ua)) == null || r.call(this, ...o);
    }
  }
};
Xa = new WeakMap(), $o = new WeakMap(), zs = new WeakMap(), Ua = new WeakMap(), rg = new WeakMap(), Pr = new WeakMap(), Ka = new WeakMap(), Er = new WeakMap(), In = new WeakMap(), Tt = new WeakMap(), Zi = new WeakMap(), Bo = new WeakMap(), Ti = new WeakMap(), Gr = new WeakMap(), Ja = new WeakMap(), ei = new WeakMap(), Gl = new WeakMap(), jl = new WeakMap(), es = new WeakMap(), Fs = new WeakMap(), oc = new WeakMap(), fo = new WeakMap(), ib = new WeakSet(), rM = function() {
  const e = new Rw(Z(this, Xa)), t = new Rw(Z(this, Xa));
  ut(this, es, e), ut(this, jl, t), ut(this, ob, (o, a, s = im.now()) => {
    if (t[o] = a !== 0 ? s : 0, e[o] = a, a !== 0 && this.ttlAutopurge) {
      const l = setTimeout(() => {
        Z(this, Vo).call(this, o) && this.delete(Z(this, In)[o]);
      }, a + 1);
      l.unref && l.unref();
    }
  }), ut(this, kf, (o) => {
    t[o] = e[o] !== 0 ? im.now() : 0;
  }), ut(this, Hl, (o, a) => {
    if (e[a]) {
      const s = e[a], l = t[a];
      o.ttl = s, o.start = l, o.now = r || i(), o.remainingTTL = o.now + s - l;
    }
  });
  let r = 0;
  const i = () => {
    const o = im.now();
    if (this.ttlResolution > 0) {
      r = o;
      const a = setTimeout(() => r = 0, this.ttlResolution);
      a.unref && a.unref();
    }
    return o;
  };
  this.getRemainingTTL = (o) => {
    const a = Z(this, Er).get(o);
    return a === void 0 ? 0 : e[a] === 0 || t[a] === 0 ? 1 / 0 : t[a] + e[a] - (r || i());
  }, ut(this, Vo, (o) => e[o] !== 0 && t[o] !== 0 && (r || i()) - t[o] > e[o]);
}, kf = new WeakMap(), Hl = new WeakMap(), ob = new WeakMap(), Vo = new WeakMap(), i_ = new WeakSet(), BK = function() {
  const e = new Rw(Z(this, Xa));
  ut(this, Ka, 0), ut(this, Gl, e), ut(this, Pf, (t) => {
    ut(this, Ka, Z(this, Ka) - e[t]), e[t] = 0;
  }), ut(this, ab, (t, r, i, o) => {
    if (tt(this, kn, Qn).call(this, r))
      return 0;
    if (!Gu(i))
      if (o) {
        if (typeof o != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (i = o(r, t), !Gu(i))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return i;
  }), ut(this, ig, (t, r, i) => {
    if (e[t] = r, Z(this, $o)) {
      const o = Z(this, $o) - e[t];
      for (; Z(this, Ka) > o; )
        tt(this, og, Nw).call(this, !0);
    }
    ut(this, Ka, Z(this, Ka) + e[t]), i && (i.entrySize = r, i.totalCalculatedSize = Z(this, Ka));
  });
}, Pf = new WeakMap(), ig = new WeakMap(), ab = new WeakMap(), Qs = new WeakSet(), ju = function* ({ allowStale: e = this.allowStale } = {}) {
  if (Z(this, Pr))
    for (let t = Z(this, Gr); !(!tt(this, sb, iM).call(this, t) || ((e || !Z(this, Vo).call(this, t)) && (yield t), t === Z(this, Ti))); )
      t = Z(this, Bo)[t];
}, Zs = new WeakSet(), Hu = function* ({ allowStale: e = this.allowStale } = {}) {
  if (Z(this, Pr))
    for (let t = Z(this, Ti); !(!tt(this, sb, iM).call(this, t) || ((e || !Z(this, Vo).call(this, t)) && (yield t), t === Z(this, Gr))); )
      t = Z(this, Zi)[t];
}, sb = new WeakSet(), iM = function(e) {
  return e !== void 0 && Z(this, Er).get(Z(this, In)[e]) === e;
}, og = new WeakSet(), Nw = function(e) {
  var o, a;
  const t = Z(this, Ti), r = Z(this, In)[t], i = Z(this, Tt)[t];
  return Z(this, oc) && tt(this, kn, Qn).call(this, i) ? i.__abortController.abort(new Error("evicted")) : (Z(this, Fs) || Z(this, fo)) && (Z(this, Fs) && ((o = Z(this, zs)) == null || o.call(this, i, r, "evict")), Z(this, fo) && ((a = Z(this, ei)) == null || a.push([i, r, "evict"]))), Z(this, Pf).call(this, t), e && (Z(this, In)[t] = void 0, Z(this, Tt)[t] = void 0, Z(this, Ja).push(t)), Z(this, Pr) === 1 ? (ut(this, Ti, ut(this, Gr, 0)), Z(this, Ja).length = 0) : ut(this, Ti, Z(this, Zi)[t]), Z(this, Er).delete(r), r1(this, Pr)._--, t;
}, ag = new WeakSet(), $w = function(e, t, r, i) {
  const o = t === void 0 ? void 0 : Z(this, Tt)[t];
  if (tt(this, kn, Qn).call(this, o))
    return o;
  const a = new AbortController(), { signal: s } = r;
  s == null || s.addEventListener("abort", () => a.abort(s.reason), {
    signal: a.signal
  });
  const l = {
    signal: a.signal,
    options: r,
    context: i
  }, u = (g, v = !1) => {
    const { aborted: m } = a.signal, y = r.ignoreFetchAbort && g !== void 0;
    if (r.status && (m && !v ? (r.status.fetchAborted = !0, r.status.fetchError = a.signal.reason, y && (r.status.fetchAbortIgnored = !0)) : r.status.fetchResolved = !0), m && !y && !v)
      return h(a.signal.reason);
    const b = d;
    return Z(this, Tt)[t] === d && (g === void 0 ? b.__staleWhileFetching ? Z(this, Tt)[t] = b.__staleWhileFetching : this.delete(e) : (r.status && (r.status.fetchUpdated = !0), this.set(e, g, l.options))), g;
  }, c = (g) => (r.status && (r.status.fetchRejected = !0, r.status.fetchError = g), h(g)), h = (g) => {
    const { aborted: v } = a.signal, m = v && r.allowStaleOnFetchAbort, y = m || r.allowStaleOnFetchRejection, b = y || r.noDeleteOnFetchRejection, O = d;
    if (Z(this, Tt)[t] === d && (!b || O.__staleWhileFetching === void 0 ? this.delete(e) : m || (Z(this, Tt)[t] = O.__staleWhileFetching)), y)
      return r.status && O.__staleWhileFetching !== void 0 && (r.status.returnedStale = !0), O.__staleWhileFetching;
    if (O.__returned === O)
      throw g;
  }, f = (g, v) => {
    var y;
    const m = (y = Z(this, rg)) == null ? void 0 : y.call(this, e, o, l);
    m && m instanceof Promise && m.then((b) => g(b), v), a.signal.addEventListener("abort", () => {
      (!r.ignoreFetchAbort || r.allowStaleOnFetchAbort) && (g(), r.allowStaleOnFetchAbort && (g = (b) => u(b, !0)));
    });
  };
  r.status && (r.status.fetchDispatched = !0);
  const d = new Promise(f).then(u, c), p = Object.assign(d, {
    __abortController: a,
    __staleWhileFetching: o,
    __returned: void 0
  });
  return t === void 0 ? (this.set(e, p, { ...l.options, status: void 0 }), t = Z(this, Er).get(e)) : Z(this, Tt)[t] = p, p;
}, kn = new WeakSet(), Qn = function(e) {
  if (!Z(this, oc))
    return !1;
  const t = e;
  return !!t && t instanceof Promise && t.hasOwnProperty("__staleWhileFetching") && t.__abortController instanceof AbortController;
}, lb = new WeakSet(), oM = function(e, t) {
  Z(this, Bo)[t] = e, Z(this, Zi)[e] = t;
}, Ef = new WeakSet(), jm = function(e) {
  e !== Z(this, Gr) && (e === Z(this, Ti) ? ut(this, Ti, Z(this, Zi)[e]) : tt(this, lb, oM).call(this, Z(this, Bo)[e], Z(this, Zi)[e]), tt(this, lb, oM).call(this, Z(this, Gr), e), ut(this, Gr, e));
};
let nM = M$;
const r1t = (n, e) => {
  const t = Re("editorId"), { noImgZoomIn: r } = n, i = xI(() => {
    const o = document.querySelectorAll(`#${t}-preview img`);
    o.length !== 0 && k3e(o, {
      background: "#00000073"
    });
  });
  ht(() => {
    !r && n.setting.preview && i();
  }), he([e], () => {
    !r && i();
  });
}, i1t = r1t, o1t = (n, e) => {
  if (typeof e[n] == "string")
    return e[n];
  const t = `<i class="${hn}-iconfont ${hn}-icon-${n}"></i>`;
  switch (fl.iconfontType) {
    case "svg":
      return `<svg class="${hn}-icon" aria-hidden="true"><use xlink:href="#${hn}-icon-${n}"></use></svg>`;
    default:
      return t;
  }
}, a1t = (n, e, t) => {
  const r = Re("editorId"), i = Re("usedLanguageText"), o = Re("customIcon"), a = () => {
    document.querySelectorAll(`#${r}-preview pre`).forEach((u) => {
      var c, h;
      let f = -1;
      (c = u.querySelector(".copy-button")) == null || c.remove();
      const d = ((h = i.value.copyCode) == null ? void 0 : h.text) || "复制代码", p = document.createElement("span");
      p.setAttribute("class", "copy-button"), p.dataset.tips = d, p.innerHTML = o1t("copy", o.value), p.addEventListener("click", () => {
        var g, v;
        clearTimeout(f);
        const m = u.querySelector("code").innerText, y = R3e(n.formatCopiedText(m)), b = ((g = i.value.copyCode) == null ? void 0 : g.successTips) || "已复制！", O = ((v = i.value.copyCode) == null ? void 0 : v.failTips) || "已复制！";
        p.dataset.tips = y ? b : O, f = window.setTimeout(() => {
          p.dataset.tips = d;
        }, 1500);
      }), u.appendChild(p);
    });
  }, s = () => {
    Ke(a);
  }, l = (u) => {
    u && Ke(a);
  };
  he([e, t], s), he(() => n.setting.preview, l), he(() => n.setting.htmlPreview, l), he(() => i.value, a), ht(a);
}, s1t = a1t, l1t = (n) => {
  var e;
  const t = (e = fl.editorExtensions) == null ? void 0 : e.highlight, r = t == null ? void 0 : t.instance, i = Re("highlight"), o = di(r);
  return ht(() => {
    if (!n.noHighlight && !o.value) {
      const a = document.createElement("script");
      a.src = i.value.js, a.onload = () => {
        o.value = window.hljs;
      }, a.id = `${hn}-hljs`, rd(a, "hljs");
      const s = document.createElement("link");
      s.rel = "stylesheet", s.href = i.value.css, s.id = `${hn}-hlCss`, rd(s);
    }
  }), he(
    () => i.value.css,
    (a) => {
      FEe(`${hn}-hlCss`, "href", a);
    }
  ), o;
}, u1t = l1t, c1t = (n) => {
  const e = Re("theme"), { editorExtensions: t, mermaidConfig: r } = fl, i = t == null ? void 0 : t.mermaid, o = di(i == null ? void 0 : i.instance), a = di(-1), s = new nM({
    max: 1e3,
    // 缓存10分钟
    ttl: 6e5
  }), l = () => {
    const u = o.value;
    !n.noMermaid && u && (u.initialize(
      r({
        startOnLoad: !1,
        theme: e.value === "dark" ? "dark" : "default"
      })
    ), a.value = a.value + 1);
  };
  return he(
    () => e.value,
    () => {
      s.clear(), l();
    }
  ), ht(() => {
    if (!n.noMermaid && !(i != null && i.instance)) {
      const u = (i == null ? void 0 : i.js) || LEe;
      if (/\.mjs/.test(u))
        import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          u
        ).then((c) => {
          o.value = c.default, l();
        });
      else {
        const c = document.createElement("script");
        c.id = `${hn}-mermaid`, c.src = u, c.onload = () => {
          o.value = window.mermaid, l();
        }, rd(c, "mermaid");
      }
    }
  }), { mermaidRef: o, reRenderRef: a, replaceMermaid: () => {
    Ke(() => {
      if (!n.noMermaid && o.value) {
        const u = document.querySelectorAll(
          `div.${hn}-mermaid`
        ), c = document.createElement("div");
        c.style.width = document.body.offsetWidth + "px", c.style.height = document.body.offsetHeight + "px", c.style.position = "fixed", c.style.zIndex = "-10000", c.style.top = "-10000";
        let h = u.length;
        h > 0 && document.body.appendChild(c), u.forEach(async (f) => {
          let d = s.get(f.innerText);
          if (!d) {
            const g = YP(), v = o.value.renderAsync || o.value.render;
            let m = "";
            try {
              m = await v(g, f.innerText, c);
            } catch {
            }
            d = await n.sanitizeMermaid(
              typeof m == "string" ? m : m.svg
            ), s.set(f.innerText, d);
          }
          const p = document.createElement("p");
          p.className = `${hn}-mermaid`, p.setAttribute("data-processed", ""), p.innerHTML = d, f.dataset.line !== void 0 && (p.dataset.line = f.dataset.line), f.replaceWith(p), --h === 0 && c.remove();
        });
      }
    });
  } };
}, h1t = c1t, f1t = (n) => {
  var e;
  const t = (e = fl.editorExtensions) == null ? void 0 : e.katex, r = t == null ? void 0 : t.instance, i = di(r);
  return ht(() => {
    if (!n.noKatex && !i.value) {
      const o = document.createElement("script");
      o.src = (t == null ? void 0 : t.js) || w5.js, o.onload = () => {
        i.value = window.katex;
      }, o.id = `${hn}-katex`;
      const a = document.createElement("link");
      a.rel = "stylesheet", a.href = (t == null ? void 0 : t.css) || w5.css, a.id = `${hn}-katexCss`, rd(o, "katex"), rd(a);
    }
  }), i;
}, d1t = f1t, p1t = (n, e) => {
  const t = n.renderer.rules.fence.bind(n.renderer.rules);
  n.renderer.rules.fence = (r, i, o, a, s) => {
    const l = r[i], u = l.content.trim();
    if (l.info === "mermaid") {
      let c;
      return r[i].map && r[i].level === 0 && (c = r[i].map[0], r[i].attrSet("data-line", String(c))), `<div class="${hn}-mermaid" ${c !== void 0 ? "data-line=" + c : ""} data-mermaid-theme=${e.themeRef.value}>${u}</div>`;
    }
    return t(r, i, o, a, s);
  };
}, g1t = p1t, lz = (n, e) => {
  let t = !0, r = !0;
  const i = n.posMax, o = e > 0 ? n.src.charCodeAt(e - 1) : -1, a = e + 1 <= i ? n.src.charCodeAt(e + 1) : -1;
  return (o === 32 || o === 9 || a >= 48 && a <= 57) && (r = !1), (a === 32 || a === 9) && (t = !1), {
    can_open: t,
    can_close: r
  };
}, v1t = (n, e) => {
  let t, r, i, o;
  if (n.src[n.pos] !== "$")
    return !1;
  if (i = lz(n, n.pos), !i.can_open)
    return e || (n.pending += "$"), n.pos += 1, !0;
  const a = n.pos + 1;
  for (t = a; (t = n.src.indexOf("$", t)) !== -1; ) {
    for (o = t - 1; n.src[o] === "\\"; )
      o -= 1;
    if ((t - o) % 2 == 1)
      break;
    t += 1;
  }
  return t === -1 ? (e || (n.pending += "$"), n.pos = a, !0) : t - a === 0 ? (e || (n.pending += "$$"), n.pos = a + 1, !0) : (i = lz(n, t), i.can_close ? (e || (r = n.push("math_inline", "math", 0), r.markup = "$", r.content = n.src.slice(a, t)), n.pos = t + 1, !0) : (e || (n.pending += "$"), n.pos = a, !0));
}, m1t = (n, e, t, r) => {
  let i, o, a, s, l = !1, u = n.bMarks[e] + n.tShift[e], c = n.eMarks[e];
  if (u + 2 > c || n.src.slice(u, u + 2) !== "$$")
    return !1;
  if (u += 2, i = n.src.slice(u, c), r)
    return !0;
  for (i.trim().slice(-2) === "$$" && (i = i.trim().slice(0, -2), l = !0), a = e; !l && (a++, !(a >= t || (u = n.bMarks[a] + n.tShift[a], c = n.eMarks[a], u < c && n.tShift[a] < n.blkIndent))); )
    n.src.slice(u, c).trim().slice(-2) === "$$" && (s = n.src.slice(0, c).lastIndexOf("$$"), o = n.src.slice(u, s), l = !0);
  n.line = a + 1;
  const h = n.push("math_block", "math", 0);
  return h.block = !0, h.content = (i && i.trim() ? i + `
` : "") + n.getLines(e + 1, a, n.tShift[e], !0) + (o && o.trim() ? o : ""), h.map = [e, n.line], h.markup = "$$", !0;
}, y1t = (n, e) => {
  const t = (i) => {
    if (e.katexRef.value) {
      const o = e.katexRef.value.renderToString(i, {
        throwOnError: !1
      });
      return `<span class="${hn}-katex-inline" data-processed>${o}</span>`;
    } else
      return `<span class="${hn}-katex-inline">${i}</span>`;
  }, r = (i, o) => {
    if (e.katexRef.value) {
      const a = e.katexRef.value.renderToString(i, {
        throwOnError: !1,
        displayMode: !0
      });
      return `<p class="${hn}-katex-block" data-line=${o} data-processed>${a}</p>`;
    } else
      return `<p class="${hn}-katex-block" data-line=${o}>${i}</p>`;
  };
  n.inline.ruler.after("escape", "math_inline", v1t), n.block.ruler.after("blockquote", "math_block", m1t, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), n.renderer.rules.math_inline = (i, o) => t(i[o].content), n.renderer.rules.math_block = (i, o) => r(i[o].content, i[o].map[0]) + `
`;
}, b1t = y1t, O1t = (n, e) => {
  e = e || {};
  const t = 3, r = e.marker || "!", i = r.charCodeAt(0), o = r.length;
  let a = "", s = "";
  const l = (c, h, f, d, p) => {
    const g = c[h];
    return g.type === "admonition_open" ? (c[h].attrPush([
      "class",
      `${hn}-admonition ${hn}-admonition-${g.info}`
    ]), c[h].attrSet("data-line", String(c[h].map[0]))) : g.type === "admonition_title_open" && c[h].attrPush(["class", `${hn}-admonition-title`]), p.renderToken(c, h, f);
  }, u = (c) => {
    const h = c.trim().split(" ", 2);
    s = "", a = h[0], h.length > 1 && (s = c.substring(a.length + 2)), (s === "" || !s) && (s = a);
  };
  n.block.ruler.before(
    "code",
    "admonition",
    (c, h, f, d) => {
      let p, g, v, m = !1, y = c.bMarks[h] + c.tShift[h], b = c.eMarks[h];
      if (i !== c.src.charCodeAt(y))
        return !1;
      for (p = y + 1; p <= b && r[(p - y) % o] === c.src[p]; p++)
        ;
      const O = Math.floor((p - y) / o);
      if (O !== t)
        return !1;
      p -= (p - y) % o;
      const w = c.src.slice(y, p), x = c.src.slice(p, b);
      if (u(x), d)
        return !0;
      for (g = h; g++, !(g >= f || (y = c.bMarks[g] + c.tShift[g], b = c.eMarks[g], y < b && c.sCount[g] < c.blkIndent)); )
        if (i === c.src.charCodeAt(y) && !(c.sCount[g] - c.blkIndent >= 4)) {
          for (p = y + 1; p <= b && r[(p - y) % o] === c.src[p]; p++)
            ;
          if (!(Math.floor((p - y) / o) < O) && (p -= (p - y) % o, p = c.skipSpaces(p), !(p < b))) {
            m = !0;
            break;
          }
        }
      const S = c.parentType, _ = c.lineMax;
      return c.parentType = "root", c.lineMax = g, v = c.push("admonition_open", "div", 1), v.markup = w, v.block = !0, v.info = a, v.map = [h, g], v = c.push("admonition_title_open", "p", 1), v.markup = w + " " + a, v.map = [h, g], v = c.push("inline", "", 0), v.content = s, v.map = [h, c.line - 1], v.children = [], v = c.push("admonition_title_close", "p", -1), v.markup = w + " " + a, c.md.block.tokenize(c, h + 1, g), v = c.push("admonition_close", "div", -1), v.markup = c.src.slice(y, p), v.block = !0, c.parentType = S, c.lineMax = _, c.line = g + (m ? 1 : 0), !0;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  ), n.renderer.rules.admonition_open = l, n.renderer.rules.admonition_title_open = l, n.renderer.rules.admonition_title_close = l, n.renderer.rules.admonition_close = l;
}, w1t = O1t, x1t = (n, e) => {
  n.renderer.rules.heading_open = (t, r) => {
    var i;
    const o = t[r], a = ((i = t[r + 1].children) == null ? void 0 : i.reduce((l, u) => l + (u.content || ""), "")) || "", s = o.markup.length;
    return e.headsRef.value.push({
      text: a,
      level: s
    }), o.map && o.level === 0 && (o.attrSet("data-line", String(o.map[0])), o.attrSet(
      "id",
      e.mdHeadingId(a, s, e.headsRef.value.length)
    )), n.renderer.renderToken(t, r, e);
  }, n.renderer.rules.heading_close = (t, r, i, o, a) => a.renderToken(t, r, i);
}, S1t = x1t, _1t = (n, e) => {
  const t = n.renderer.rules.fence, r = n.utils.unescapeAll, i = /\[(\w*)(?::([\w ]*))?\]/;
  function o(u) {
    return u.info ? r(u.info).trim() : "";
  }
  function a(u) {
    const c = o(u), [h = null, f = ""] = (i.exec(c) || []).slice(1);
    return [h, f];
  }
  function s(u) {
    const c = o(u);
    return c ? c.split(/(\s+)/g)[0] : "";
  }
  const l = (u, c, h, f, d) => {
    if (u[c].hidden)
      return "";
    const [p, g] = a(u[c]);
    if (p === null)
      return t(u, c, h, f, d);
    let v, m, y, b, O = "", w = "";
    for (let x = c; x < u.length && (v = u[x], [m, y] = a(v), m === p); x++)
      v.info = v.info.replace(i, ""), v.hidden = !0, b = x - c > 0 ? "" : " checked", O += `<li><input type="radio" name="label-group-${e.editorId}-${c}"${b}><label for="group-${e.editorId}-${c}-tab-${x - c}" onclick="this.previousElementSibling.click()">${y || s(v)}</label></li>
`, w += `<input type="radio" id="group-${e.editorId}-${c}-tab-${x - c}" name="group-${e.editorId}-${c}"${b}>
` + t(u, x, h, f, d);
    return `<div class="code-tabs">
<ul>
` + O + `</ul>
` + w + "</div>";
  };
  n.renderer.rules.fence = l;
}, C1t = _1t, A1t = (n) => {
  [
    "paragraph_open",
    "table_open",
    "ordered_list_open",
    "bullet_list_open",
    "blockquote_open",
    "hr",
    "html_block",
    "fence"
  ].forEach((e) => {
    const t = n.renderer.rules[e];
    t ? n.renderer.rules[e] = (r, i, o, a, s) => {
      let l;
      const u = t(r, i, o, a, s);
      return r[i].map && r[i].level === 0 && !/^<!--/.test(u) ? (l = r[i].map[0], u.replace(/^(<[^>]*)/, `$1 data-line="${l}"`)) : u;
    } : n.renderer.rules[e] = (r, i, o, a, s) => {
      let l;
      return r[i].map && r[i].level === 0 && (l = r[i].map[0], r[i].attrSet("data-line", String(l))), s.renderToken(r, i, o);
    };
  });
}, T1t = (n, e) => {
  const { editorConfig: t, markdownItConfig: r, markdownItPlugins: i } = fl, o = Re("editorId"), a = Re("showCodeRowNumber"), s = Re("theme"), l = z([]), u = u1t(n), c = d1t(n), { reRenderRef: h, replaceMermaid: f } = h1t(n), d = j0t({
    html: !0,
    breaks: !0
  });
  r(d, {
    editorId: o
  });
  const p = [
    {
      type: "katex",
      plugin: b1t,
      options: { katexRef: c }
    },
    {
      type: "image",
      plugin: q0t,
      options: { figcaption: !0, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: w1t,
      options: {}
    },
    {
      type: "taskList",
      plugin: sbt,
      options: {}
    },
    {
      type: "heading",
      plugin: S1t,
      options: { mdHeadingId: n.mdHeadingId, headsRef: l }
    },
    {
      type: "codeTabs",
      plugin: C1t,
      options: { editorId: o }
    },
    {
      type: "xss",
      plugin: e1t,
      options: {
        // https://github.com/leizongmin/js-xss/blob/master/README.zh.md
        xss(w) {
          return {
            whiteList: Object.assign({}, w.getDefaultWhiteList(), {
              input: ["class", "disabled", "type", "checked"]
            })
          };
        }
      }
    }
  ];
  n.noMermaid || p.push({
    type: "mermaid",
    plugin: g1t,
    options: { themeRef: s }
  }), i(p, {
    editorId: o
  }).forEach((w) => {
    d.use(w.plugin, w.options);
  });
  const g = d.options.highlight;
  d.set({
    highlight: (w, x, S) => {
      if (g) {
        const A = g(w, x, S);
        if (A)
          return A;
      }
      let _;
      !n.noHighlight && u.value ? u.value.getLanguage(x) ? _ = u.value.highlight(w, {
        language: x,
        ignoreIllegals: !0
      }).value : _ = u.value.highlightAuto(w).value : _ = d.utils.escapeHtml(w);
      const C = a ? zEe(_.replace(/^\n+|\n+$/g, "")) : `<span class="code-block">${_.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${x}" language=${x}>${C}</code></pre>`;
    }
  }), A1t(d);
  const v = z(`_article-key_${YP()}`), m = z(n.sanitize(d.render(n.modelValue))), y = () => {
    nf.emit(o, BEe, m.value), n.onHtmlChanged(m.value), n.onGetCatalog(l.value), nf.emit(o, S5, l.value), f();
  };
  ht(y);
  const b = () => {
    l.value = [], m.value = n.sanitize(d.render(n.modelValue)), y();
  }, O = B(() => (n.noKatex || c.value) && (n.noHighlight || u.value));
  return he(
    [ba(n, "modelValue"), O, h],
    xI(
      b,
      (t == null ? void 0 : t.renderDelay) !== void 0 ? t == null ? void 0 : t.renderDelay : e ? 0 : 500
    )
  ), ht(() => {
    nf.on(o, {
      name: VEe,
      callback() {
        nf.emit(o, S5, l.value);
      }
    }), nf.on(o, {
      name: Z9,
      callback: () => {
        b(), v.value = `_article-key_${YP()}`;
      }
    });
  }), { html: m, key: v };
}, k1t = T1t, VK = {
  modelValue: {
    type: String,
    default: ""
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: !1
  },
  sanitize: {
    type: Function,
    default: (n) => n
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: !1
  },
  formatCopiedText: {
    type: Function,
    default: (n) => n
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  previewOnly: {
    type: Boolean,
    default: !1
  },
  noImgZoomIn: {
    type: Boolean
  },
  sanitizeMermaid: {
    type: Function
  }
};
({
  ...VK
});
const P1t = /* @__PURE__ */ U({
  name: "ContentPreview",
  props: VK,
  setup(n) {
    const e = Re("editorId"), t = Re("previewTheme"), r = Re("showCodeRowNumber"), {
      html: i,
      key: o
    } = k1t(n, n.previewOnly);
    return s1t(n, i, o), i1t(n, i), () => de(yn, null, [de("div", {
      id: `${e}-preview-wrapper`,
      class: `${hn}-preview-wrapper`,
      "data-show": n.setting.preview,
      key: "content-preview-wrapper"
    }, [de("div", {
      key: o.value,
      id: `${e}-preview`,
      class: [`${hn}-preview`, `${t == null ? void 0 : t.value}-theme`, r && `${hn}-scrn`],
      innerHTML: i.value
    }, null)]), !n.previewOnly && de("div", {
      id: `${e}-html-wrapper`,
      class: `${hn}-preview-wrapper`,
      "data-show": n.setting.htmlPreview,
      key: "html-preview-wrapper"
    }, [de("div", {
      class: `${hn}-html`
    }, [i.value])])]);
  }
}), E1t = (n) => {
  var e, t;
  const { editorId: r } = n, i = (t = (e = fl) == null ? void 0 : e.editorExtensions) == null ? void 0 : t.highlight;
  Wt("editorId", r), Wt(
    "theme",
    B(() => n.theme)
  ), Wt(
    "language",
    B(() => n.language)
  ), Wt(
    "highlight",
    B(() => {
      const a = {
        ...x5,
        ...i == null ? void 0 : i.css
      }, s = n.codeStyleReverse && n.codeStyleReverseList.includes(n.previewTheme) ? "dark" : n.theme;
      return {
        js: (i == null ? void 0 : i.js) || EEe,
        css: a[n.codeTheme] ? a[n.codeTheme][s] : x5.atom[s]
      };
    })
  ), Wt("showCodeRowNumber", n.showCodeRowNumber);
  const o = B(() => {
    var a, s;
    const l = {
      ...O5,
      ...(s = (a = fl) == null ? void 0 : a.editorConfig) == null ? void 0 : s.languageUserDefined
    };
    return l[n.language] ? l[n.language] : O5["zh-CN"];
  });
  Wt("usedLanguageText", o), Wt(
    "previewTheme",
    B(() => n.previewTheme)
  ), Wt(
    "customIcon",
    B(() => n.customIcon)
  );
}, M1t = (n) => {
  ht(() => {
    var e, t;
    if (!n.noIconfont)
      if (fl.iconfontType === "svg") {
        const r = document.createElement("script");
        r.src = ((e = fl.editorExtensions) == null ? void 0 : e.iconfont) || kEe, r.id = `${hn}-icon`, rd(r);
      } else {
        const r = document.createElement("link");
        r.rel = "stylesheet", r.href = ((t = fl.editorExtensions) == null ? void 0 : t.iconfontClass) || PEe, r.id = `${hn}-icon-class`, rd(r);
      }
  });
}, D1t = (n) => n, zK = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: TEe
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default false
   */
  showCodeRowNumber: {
    type: Boolean,
    default: !1
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: D1t
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (n) => n
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: !1
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: !1
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (n) => n
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: !0
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: !1
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  },
  sanitizeMermaid: {
    type: Function,
    default: (n) => Promise.resolve(n)
  }
};
({
  ...zK
});
const FK = ["onHtmlChanged", "onGetCatalog"];
[
  ...FK
];
const L1t = (n, e) => {
  const { editorId: t } = n, r = {
    rerender() {
      nf.emit(t, Z9);
    }
  };
  e.expose(r);
}, I1t = /* @__PURE__ */ U({
  name: "MdPreview",
  props: zK,
  emits: FK,
  setup(n, e) {
    const {
      editorId: t,
      noKatex: r,
      noMermaid: i,
      noHighlight: o
    } = n;
    return E1t(n), M1t(n), L1t(n, e), xi(() => {
      nf.clear(t);
    }), () => de("div", {
      id: t,
      class: [hn, n.class, n.theme === "dark" && `${hn}-dark`, `${hn}-previewOnly`],
      style: n.style
    }, [de(P1t, {
      modelValue: n.modelValue,
      onHtmlChanged: (a) => {
        n.onHtmlChanged ? n.onHtmlChanged(a) : e.emit("onHtmlChanged", a);
      },
      onGetCatalog: (a) => {
        n.onGetCatalog ? n.onGetCatalog(a) : e.emit("onGetCatalog", a);
      },
      mdHeadingId: n.mdHeadingId,
      noMermaid: i,
      sanitize: n.sanitize,
      noKatex: r,
      formatCopiedText: n.formatCopiedText,
      noHighlight: o,
      noImgZoomIn: n.noImgZoomIn,
      previewOnly: !0,
      sanitizeMermaid: n.sanitizeMermaid
    }, null)]);
  }
}), pA = I1t;
pA.install = (n) => (n.component(pA.name, pA), n);
const R1t = Q_({
  String: K.string,
  Number: K.number,
  "True False": K.bool,
  PropertyName: K.propertyName,
  Null: K.null,
  ",": K.separator,
  "[ ]": K.squareBracket,
  "{ }": K.brace
}), N1t = Hg.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [R1t],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), $1t = /* @__PURE__ */ Zg.define({
  name: "json",
  parser: /* @__PURE__ */ N1t.configure({
    props: [
      /* @__PURE__ */ G_.add({
        Object: /* @__PURE__ */ Gp({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ Gp({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ j_.add({
        "Object Array": CX
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function W6t() {
  return new FI($1t);
}
const B1t = 36, uz = 1, V1t = 2, om = 3, gA = 4, z1t = 5, F1t = 6, Q1t = 7, Z1t = 8, W1t = 9, G1t = 10, j1t = 11, H1t = 12, q1t = 13, Y1t = 14, X1t = 15, U1t = 16, K1t = 17, cz = 18, J1t = 19, QK = 20, ZK = 21, hz = 22, eOt = 23, tOt = 24;
function aM(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n >= 48 && n <= 57;
}
function nOt(n) {
  return n >= 48 && n <= 57 || n >= 97 && n <= 102 || n >= 65 && n <= 70;
}
function Hh(n, e, t) {
  for (let r = !1; ; ) {
    if (n.next < 0)
      return;
    if (n.next == e && !r) {
      n.advance();
      return;
    }
    r = t && !r && n.next == 92, n.advance();
  }
}
function rOt(n) {
  for (; ; ) {
    if (n.next < 0 || n.peek(1) < 0)
      return;
    if (n.next == 36 && n.peek(1) == 36) {
      n.advance(2);
      return;
    }
    n.advance();
  }
}
function iOt(n, e) {
  let t = "[{<(".indexOf(String.fromCharCode(e)), r = t < 0 ? e : "]}>)".charCodeAt(t);
  for (; ; ) {
    if (n.next < 0)
      return;
    if (n.next == r && n.peek(1) == 39) {
      n.advance(2);
      return;
    }
    n.advance();
  }
}
function WK(n, e) {
  for (; !(n.next != 95 && !aM(n.next)); )
    e != null && (e += String.fromCharCode(n.next)), n.advance();
  return e;
}
function oOt(n) {
  if (n.next == 39 || n.next == 34 || n.next == 96) {
    let e = n.next;
    n.advance(), Hh(n, e, !1);
  } else
    WK(n);
}
function fz(n, e) {
  for (; n.next == 48 || n.next == 49; )
    n.advance();
  e && n.next == e && n.advance();
}
function dz(n, e) {
  for (; ; ) {
    if (n.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (n.next < 48 || n.next > 57)
      break;
    n.advance();
  }
  if (n.next == 69 || n.next == 101)
    for (n.advance(), (n.next == 43 || n.next == 45) && n.advance(); n.next >= 48 && n.next <= 57; )
      n.advance();
}
function pz(n) {
  for (; !(n.next < 0 || n.next == 10); )
    n.advance();
}
function Oh(n, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == n)
      return !0;
  return !1;
}
const vA = ` 	\r
`;
function GK(n, e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  r.true = r.false = z1t, r.null = r.unknown = F1t;
  for (let i of n.split(" "))
    i && (r[i] = QK);
  for (let i of e.split(" "))
    i && (r[i] = ZK);
  for (let i of (t || "").split(" "))
    i && (r[i] = tOt);
  return r;
}
const aOt = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", sOt = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", sM = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: /* @__PURE__ */ GK(sOt, aOt)
};
function lOt(n, e, t, r) {
  let i = {};
  for (let o in sM)
    i[o] = (n.hasOwnProperty(o) ? n : sM)[o];
  return e && (i.words = GK(e, t || "", r)), i;
}
function jK(n) {
  return new Lb((e) => {
    var t;
    let { next: r } = e;
    if (e.advance(), Oh(r, vA)) {
      for (; Oh(e.next, vA); )
        e.advance();
      e.acceptToken(B1t);
    } else if (r == 36 && e.next == 36 && n.doubleDollarQuotedStrings)
      rOt(e), e.acceptToken(om);
    else if (r == 39 || r == 34 && n.doubleQuotedStrings)
      Hh(e, r, n.backslashEscapes), e.acceptToken(om);
    else if (r == 35 && n.hashComments || r == 47 && e.next == 47 && n.slashComments)
      pz(e), e.acceptToken(uz);
    else if (r == 45 && e.next == 45 && (!n.spaceAfterDashes || e.peek(1) == 32))
      pz(e), e.acceptToken(uz);
    else if (r == 47 && e.next == 42) {
      e.advance();
      for (let i = 1; ; ) {
        let o = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), o == 42 && e.next == 47) {
          if (i--, e.advance(), !i)
            break;
        } else
          o == 47 && e.next == 42 && (i++, e.advance());
      }
      e.acceptToken(V1t);
    } else if ((r == 101 || r == 69) && e.next == 39)
      e.advance(), Hh(e, 39, !0);
    else if ((r == 110 || r == 78) && e.next == 39 && n.charSetCasts)
      e.advance(), Hh(e, 39, n.backslashEscapes), e.acceptToken(om);
    else if (r == 95 && n.charSetCasts)
      for (let i = 0; ; i++) {
        if (e.next == 39 && i > 1) {
          e.advance(), Hh(e, 39, n.backslashEscapes), e.acceptToken(om);
          break;
        }
        if (!aM(e.next))
          break;
        e.advance();
      }
    else if (n.plsqlQuotingMechanism && (r == 113 || r == 81) && e.next == 39 && e.peek(1) > 0 && !Oh(e.peek(1), vA)) {
      let i = e.peek(1);
      e.advance(2), iOt(e, i), e.acceptToken(om);
    } else if (r == 40)
      e.acceptToken(Q1t);
    else if (r == 41)
      e.acceptToken(Z1t);
    else if (r == 123)
      e.acceptToken(W1t);
    else if (r == 125)
      e.acceptToken(G1t);
    else if (r == 91)
      e.acceptToken(j1t);
    else if (r == 93)
      e.acceptToken(H1t);
    else if (r == 59)
      e.acceptToken(q1t);
    else if (n.unquotedBitLiterals && r == 48 && e.next == 98)
      e.advance(), fz(e), e.acceptToken(hz);
    else if ((r == 98 || r == 66) && (e.next == 39 || e.next == 34)) {
      const i = e.next;
      e.advance(), n.treatBitsAsBytes ? (Hh(e, i, n.backslashEscapes), e.acceptToken(eOt)) : (fz(e, i), e.acceptToken(hz));
    } else if (r == 48 && (e.next == 120 || e.next == 88) || (r == 120 || r == 88) && e.next == 39) {
      let i = e.next == 39;
      for (e.advance(); nOt(e.next); )
        e.advance();
      i && e.next == 39 && e.advance(), e.acceptToken(gA);
    } else if (r == 46 && e.next >= 48 && e.next <= 57)
      dz(e, !0), e.acceptToken(gA);
    else if (r == 46)
      e.acceptToken(Y1t);
    else if (r >= 48 && r <= 57)
      dz(e, !1), e.acceptToken(gA);
    else if (Oh(r, n.operatorChars)) {
      for (; Oh(e.next, n.operatorChars); )
        e.advance();
      e.acceptToken(X1t);
    } else if (Oh(r, n.specialVar))
      e.next == r && e.advance(), oOt(e), e.acceptToken(K1t);
    else if (Oh(r, n.identifierQuotes))
      Hh(e, r, !1), e.acceptToken(J1t);
    else if (r == 58 || r == 44)
      e.acceptToken(U1t);
    else if (aM(r)) {
      let i = WK(e, String.fromCharCode(r));
      e.acceptToken(e.next == 46 || e.peek(-i.length - 1) == 46 ? cz : (t = n.words[i.toLowerCase()]) !== null && t !== void 0 ? t : cz);
    }
  });
}
const HK = /* @__PURE__ */ jK(sM), uOt = /* @__PURE__ */ Hg.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, HK],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function lM(n) {
  let e = n.cursor().moveTo(n.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function M0(n, e) {
  let t = n.sliceString(e.from, e.to), r = /^([`'"])(.*)\1$/.exec(t);
  return r ? r[2] : t;
}
function iS(n) {
  return n && (n.name == "Identifier" || n.name == "QuotedIdentifier");
}
function cOt(n, e) {
  if (e.name == "CompositeIdentifier") {
    let t = [];
    for (let r = e.firstChild; r; r = r.nextSibling)
      iS(r) && t.push(M0(n, r));
    return t;
  }
  return [M0(n, e)];
}
function gz(n, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let r = lM(e);
    if (!iS(r))
      return t;
    t.unshift(M0(n, r)), e = lM(r);
  }
}
function hOt(n, e) {
  let t = _r(n).resolveInner(e, -1), r = dOt(n.doc, t);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" || t.name == "Keyword" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? n.doc.sliceString(t.from, t.from + 1) : null,
    parents: gz(n.doc, lM(t)),
    aliases: r
  } : t.name == "." ? { from: e, quoted: null, parents: gz(n.doc, t), aliases: r } : { from: e, quoted: null, parents: [], empty: !0, aliases: r };
}
const fOt = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function dOt(n, e) {
  let t;
  for (let i = e; !t; i = i.parent) {
    if (!i)
      return null;
    i.name == "Statement" && (t = i);
  }
  let r = null;
  for (let i = t.firstChild, o = !1, a = null; i; i = i.nextSibling) {
    let s = i.name == "Keyword" ? n.sliceString(i.from, i.to).toLowerCase() : null, l = null;
    if (!o)
      o = s == "from";
    else if (s == "as" && a && iS(i.nextSibling))
      l = M0(n, i.nextSibling);
    else {
      if (s && fOt.has(s))
        break;
      a && iS(i) && (l = M0(n, i));
    }
    l && (r || (r = /* @__PURE__ */ Object.create(null)), r[l] = cOt(n, a)), a = /Identifier$/.test(i.name) ? i : null;
  }
  return r;
}
function pOt(n, e) {
  return n ? e.map((t) => Object.assign(Object.assign({}, t), { label: t.label[0] == n ? t.label : n + t.label + n, apply: void 0 })) : e;
}
const gOt = /^\w*$/, vOt = /^[`'"]?\w*[`'"]?$/;
function vz(n) {
  return n.self && typeof n.self.label == "string";
}
class vR {
  constructor(e) {
    this.idQuote = e, this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null)), r = t[e];
    return r || (e && !this.list.some((i) => i.label == e) && this.list.push(mz(e, "type", this.idQuote)), t[e] = new vR(this.idQuote));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let t = this.list.findIndex((r) => r.label == e.label);
    t > -1 ? this.list[t] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let t of e)
      this.addCompletion(typeof t == "string" ? mz(t, "property", this.idQuote) : t);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : vz(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let t of Object.keys(e)) {
      let r = e[t], i = null, o = t.replace(/\\?\./g, (s) => s == "." ? "\0" : s).split("\0"), a = this;
      vz(r) && (i = r.self, r = r.children);
      for (let s = 0; s < o.length; s++)
        i && s == o.length - 1 && a.addCompletion(i), a = a.child(o[s].replace(/\\\./g, "."));
      a.addNamespace(r);
    }
  }
}
function mz(n, e, t) {
  return /^[a-z_][a-z_\d]*$/.test(n) ? { label: n, type: e } : { label: n, type: e, apply: t + n + t };
}
function mOt(n, e, t, r, i, o) {
  var a;
  let s = ((a = o == null ? void 0 : o.spec.identifierQuotes) === null || a === void 0 ? void 0 : a[0]) || '"', l = new vR(s), u = i ? l.child(i) : null;
  return l.addNamespace(n), e && (u || l).addCompletions(e), t && l.addCompletions(t), u && l.addCompletions(u.list), r && l.addCompletions((u || l).child(r).list), (c) => {
    let { parents: h, from: f, quoted: d, empty: p, aliases: g } = hOt(c.state, c.pos);
    if (p && !c.explicit)
      return null;
    g && h.length == 1 && (h = g[h[0]] || h);
    let v = l;
    for (let b of h) {
      for (; !v.children || !v.children[b]; )
        if (v == l)
          v = u;
        else if (v == u && r)
          v = v.child(r);
        else
          return null;
      let O = v.maybeChild(b);
      if (!O)
        return null;
      v = O;
    }
    let m = d && c.state.sliceDoc(c.pos, c.pos + 1) == d, y = v.list;
    return v == l && g && (y = y.concat(Object.keys(g).map((b) => ({ label: b, type: "constant" })))), {
      from: f,
      to: m ? c.pos + 1 : void 0,
      options: pOt(d, y),
      validFor: d ? vOt : gOt
    };
  };
}
function yOt(n, e) {
  let t = Object.keys(n).map((r) => ({
    label: e ? r.toUpperCase() : r,
    type: n[r] == ZK ? "type" : n[r] == QK ? "keyword" : "variable",
    boost: -1
  }));
  return _U(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], KI(t));
}
let bOt = /* @__PURE__ */ uOt.configure({
  props: [
    /* @__PURE__ */ G_.add({
      Statement: /* @__PURE__ */ Gp()
    }),
    /* @__PURE__ */ j_.add({
      Statement(n) {
        return { from: n.firstChild.to, to: n.to };
      },
      BlockComment(n) {
        return { from: n.from + 2, to: n.to - 2 };
      }
    }),
    /* @__PURE__ */ Q_({
      Keyword: K.keyword,
      Type: K.typeName,
      Builtin: /* @__PURE__ */ K.standard(K.name),
      Bits: K.number,
      Bytes: K.string,
      Bool: K.bool,
      Null: K.null,
      Number: K.number,
      String: K.string,
      Identifier: K.name,
      QuotedIdentifier: /* @__PURE__ */ K.special(K.string),
      SpecialVar: /* @__PURE__ */ K.special(K.name),
      LineComment: K.lineComment,
      BlockComment: K.blockComment,
      Operator: K.operator,
      "Semi Punctuation": K.punctuation,
      "( )": K.paren,
      "{ }": K.brace,
      "[ ]": K.squareBracket
    })
  ]
});
class mR {
  constructor(e, t, r) {
    this.dialect = e, this.language = t, this.spec = r;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = lOt(e, e.keywords, e.types, e.builtin), r = Zg.define({
      name: "sql",
      parser: bOt.configure({
        tokenizers: [{ from: HK, to: jK(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new mR(t, r, e);
  }
}
function OOt(n, e = !1) {
  return yOt(n.dialect.words, e);
}
function wOt(n, e = !1) {
  return n.language.data.of({
    autocomplete: OOt(n, e)
  });
}
function xOt(n) {
  return n.schema ? mOt(n.schema, n.tables, n.schemas, n.defaultTable, n.defaultSchema, n.dialect || yR) : () => null;
}
function SOt(n) {
  return n.schema ? (n.dialect || yR).language.data.of({
    autocomplete: xOt(n)
  }) : [];
}
function G6t(n = {}) {
  let e = n.dialect || yR;
  return new FI(e.language, [SOt(n), wOt(e, !!n.upperCaseKeywords)]);
}
const yR = /* @__PURE__ */ mR.define({});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var uM = function(n, e) {
  return uM = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
  }, uM(n, e);
};
function H(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  uM(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var _Ot = /* @__PURE__ */ function() {
  function n() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return n;
}(), COt = /* @__PURE__ */ function() {
  function n() {
    this.browser = new _Ot(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return n;
}(), mt = new COt();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (mt.wxa = !0, mt.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? mt.worker = !0 : typeof navigator > "u" || navigator.userAgent.indexOf("Node.js") === 0 ? (mt.node = !0, mt.svgSupported = !0) : AOt(navigator.userAgent, mt);
function AOt(n, e) {
  var t = e.browser, r = n.match(/Firefox\/([\d.]+)/), i = n.match(/MSIE\s([\d.]+)/) || n.match(/Trident\/.+?rv:(([\d.]+))/), o = n.match(/Edge?\/([\d.]+)/), a = /micromessenger/i.test(n);
  r && (t.firefox = !0, t.version = r[1]), i && (t.ie = !0, t.version = i[1]), o && (t.edge = !0, t.version = o[1], t.newEdge = +o[1].split(".")[0] > 18), a && (t.weChat = !0), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u";
  var s = document.documentElement.style;
  e.transform3dSupported = (t.ie && "transition" in s || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9;
}
var bR = 12, qK = "sans-serif", Gc = bR + "px " + qK, TOt = 20, kOt = 100, POt = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function EOt(n) {
  var e = {};
  if (typeof JSON > "u")
    return e;
  for (var t = 0; t < n.length; t++) {
    var r = String.fromCharCode(t + 32), i = (n.charCodeAt(t) - TOt) / kOt;
    e[r] = i;
  }
  return e;
}
var MOt = EOt(POt), jc = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    var n, e;
    return function(t, r) {
      if (!n) {
        var i = jc.createCanvas();
        n = i && i.getContext("2d");
      }
      if (n)
        return e !== r && (e = n.font = r || Gc), n.measureText(t);
      t = t || "", r = r || Gc;
      var o = /(\d+)px/.exec(r), a = o && +o[1] || bR, s = 0;
      if (r.indexOf("mono") >= 0)
        s = a * t.length;
      else
        for (var l = 0; l < t.length; l++) {
          var u = MOt[t[l]];
          s += u == null ? a : u * a;
        }
      return { width: s };
    };
  }(),
  loadImage: function(n, e, t) {
    var r = new Image();
    return r.onload = e, r.onerror = t, r.src = n, r;
  }
}, YK = xl([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(n, e) {
  return n["[object " + e + "]"] = !0, n;
}, {}), XK = xl([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(n, e) {
  return n["[object " + e + "Array]"] = !0, n;
}, {}), kv = Object.prototype.toString, hC = Array.prototype, DOt = hC.forEach, LOt = hC.filter, OR = hC.slice, IOt = hC.map, yz = (function() {
}).constructor, K1 = yz ? yz.prototype : null, wR = "__proto__", ROt = 2311;
function UK() {
  return ROt++;
}
function ls() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  typeof console < "u" && console.error.apply(console, n);
}
function Fe(n) {
  if (n == null || typeof n != "object")
    return n;
  var e = n, t = kv.call(n);
  if (t === "[object Array]") {
    if (!Py(n)) {
      e = [];
      for (var r = 0, i = n.length; r < i; r++)
        e[r] = Fe(n[r]);
    }
  } else if (XK[t]) {
    if (!Py(n)) {
      var o = n.constructor;
      if (o.from)
        e = o.from(n);
      else {
        e = new o(n.length);
        for (var r = 0, i = n.length; r < i; r++)
          e[r] = n[r];
      }
    }
  } else if (!YK[t] && !Py(n) && !ud(n)) {
    e = {};
    for (var a in n)
      n.hasOwnProperty(a) && a !== wR && (e[a] = Fe(n[a]));
  }
  return e;
}
function it(n, e, t) {
  if (!Ne(e) || !Ne(n))
    return t ? Fe(e) : n;
  for (var r in e)
    if (e.hasOwnProperty(r) && r !== wR) {
      var i = n[r], o = e[r];
      Ne(o) && Ne(i) && !se(o) && !se(i) && !ud(o) && !ud(i) && !bz(o) && !bz(i) && !Py(o) && !Py(i) ? it(i, o, t) : (t || !(r in n)) && (n[r] = Fe(e[r]));
    }
  return n;
}
function xR(n, e) {
  for (var t = n[0], r = 1, i = n.length; r < i; r++)
    t = it(t, n[r], e);
  return t;
}
function re(n, e) {
  if (Object.assign)
    Object.assign(n, e);
  else
    for (var t in e)
      e.hasOwnProperty(t) && t !== wR && (n[t] = e[t]);
  return n;
}
function Be(n, e, t) {
  for (var r = Ot(e), i = 0; i < r.length; i++) {
    var o = r[i];
    (t ? e[o] != null : n[o] == null) && (n[o] = e[o]);
  }
  return n;
}
function ct(n, e) {
  if (n) {
    if (n.indexOf)
      return n.indexOf(e);
    for (var t = 0, r = n.length; t < r; t++)
      if (n[t] === e)
        return t;
  }
  return -1;
}
function NOt(n, e) {
  var t = n.prototype;
  function r() {
  }
  r.prototype = e.prototype, n.prototype = new r();
  for (var i in t)
    t.hasOwnProperty(i) && (n.prototype[i] = t[i]);
  n.prototype.constructor = n, n.superClass = e;
}
function mr(n, e, t) {
  if (n = "prototype" in n ? n.prototype : n, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames)
    for (var r = Object.getOwnPropertyNames(e), i = 0; i < r.length; i++) {
      var o = r[i];
      o !== "constructor" && (t ? e[o] != null : n[o] == null) && (n[o] = e[o]);
    }
  else
    Be(n, e, t);
}
function Ni(n) {
  return !n || typeof n == "string" ? !1 : typeof n.length == "number";
}
function I(n, e, t) {
  if (n && e)
    if (n.forEach && n.forEach === DOt)
      n.forEach(e, t);
    else if (n.length === +n.length)
      for (var r = 0, i = n.length; r < i; r++)
        e.call(t, n[r], r, n);
    else
      for (var o in n)
        n.hasOwnProperty(o) && e.call(t, n[o], o, n);
}
function le(n, e, t) {
  if (!n)
    return [];
  if (!e)
    return SR(n);
  if (n.map && n.map === IOt)
    return n.map(e, t);
  for (var r = [], i = 0, o = n.length; i < o; i++)
    r.push(e.call(t, n[i], i, n));
  return r;
}
function xl(n, e, t, r) {
  if (n && e) {
    for (var i = 0, o = n.length; i < o; i++)
      t = e.call(r, t, n[i], i, n);
    return t;
  }
}
function en(n, e, t) {
  if (!n)
    return [];
  if (!e)
    return SR(n);
  if (n.filter && n.filter === LOt)
    return n.filter(e, t);
  for (var r = [], i = 0, o = n.length; i < o; i++)
    e.call(t, n[i], i, n) && r.push(n[i]);
  return r;
}
function $Ot(n, e, t) {
  if (n && e) {
    for (var r = 0, i = n.length; r < i; r++)
      if (e.call(t, n[r], r, n))
        return n[r];
  }
}
function Ot(n) {
  if (!n)
    return [];
  if (Object.keys)
    return Object.keys(n);
  var e = [];
  for (var t in n)
    n.hasOwnProperty(t) && e.push(t);
  return e;
}
function BOt(n, e) {
  for (var t = [], r = 2; r < arguments.length; r++)
    t[r - 2] = arguments[r];
  return function() {
    return n.apply(e, t.concat(OR.call(arguments)));
  };
}
var _e = K1 && Le(K1.bind) ? K1.call.bind(K1.bind) : BOt;
function Je(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return function() {
    return n.apply(this, e.concat(OR.call(arguments)));
  };
}
function se(n) {
  return Array.isArray ? Array.isArray(n) : kv.call(n) === "[object Array]";
}
function Le(n) {
  return typeof n == "function";
}
function we(n) {
  return typeof n == "string";
}
function oS(n) {
  return kv.call(n) === "[object String]";
}
function $t(n) {
  return typeof n == "number";
}
function Ne(n) {
  var e = typeof n;
  return e === "function" || !!n && e === "object";
}
function bz(n) {
  return !!YK[kv.call(n)];
}
function eo(n) {
  return !!XK[kv.call(n)];
}
function ud(n) {
  return typeof n == "object" && typeof n.nodeType == "number" && typeof n.ownerDocument == "object";
}
function fC(n) {
  return n.colorStops != null;
}
function VOt(n) {
  return n.image != null;
}
function KK(n) {
  return kv.call(n) === "[object RegExp]";
}
function cd(n) {
  return n !== n;
}
function ur() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  for (var t = 0, r = n.length; t < r; t++)
    if (n[t] != null)
      return n[t];
}
function qe(n, e) {
  return n ?? e;
}
function Aa(n, e, t) {
  return n ?? e ?? t;
}
function SR(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return OR.apply(n, e);
}
function _R(n) {
  if (typeof n == "number")
    return [n, n, n, n];
  var e = n.length;
  return e === 2 ? [n[0], n[1], n[0], n[1]] : e === 3 ? [n[0], n[1], n[2], n[1]] : n;
}
function $e(n, e) {
  if (!n)
    throw new Error(e);
}
function is(n) {
  return n == null ? null : typeof n.trim == "function" ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var JK = "__ec_primitive__";
function aS(n) {
  n[JK] = !0;
}
function Py(n) {
  return n[JK];
}
var zOt = function() {
  function n() {
    this.data = {};
  }
  return n.prototype.delete = function(e) {
    var t = this.has(e);
    return t && delete this.data[e], t;
  }, n.prototype.has = function(e) {
    return this.data.hasOwnProperty(e);
  }, n.prototype.get = function(e) {
    return this.data[e];
  }, n.prototype.set = function(e, t) {
    return this.data[e] = t, this;
  }, n.prototype.keys = function() {
    return Ot(this.data);
  }, n.prototype.forEach = function(e) {
    var t = this.data;
    for (var r in t)
      t.hasOwnProperty(r) && e(t[r], r);
  }, n;
}(), eJ = typeof Map == "function";
function FOt() {
  return eJ ? /* @__PURE__ */ new Map() : new zOt();
}
var QOt = function() {
  function n(e) {
    var t = se(e);
    this.data = FOt();
    var r = this;
    e instanceof n ? e.each(i) : e && I(e, i);
    function i(o, a) {
      t ? r.set(o, a) : r.set(a, o);
    }
  }
  return n.prototype.hasKey = function(e) {
    return this.data.has(e);
  }, n.prototype.get = function(e) {
    return this.data.get(e);
  }, n.prototype.set = function(e, t) {
    return this.data.set(e, t), t;
  }, n.prototype.each = function(e, t) {
    this.data.forEach(function(r, i) {
      e.call(t, r, i);
    });
  }, n.prototype.keys = function() {
    var e = this.data.keys();
    return eJ ? Array.from(e) : e;
  }, n.prototype.removeKey = function(e) {
    this.data.delete(e);
  }, n;
}();
function Ee(n) {
  return new QOt(n);
}
function sS(n, e) {
  for (var t = new n.constructor(n.length + e.length), r = 0; r < n.length; r++)
    t[r] = n[r];
  for (var i = n.length, r = 0; r < e.length; r++)
    t[r + i] = e[r];
  return t;
}
function dC(n, e) {
  var t;
  if (Object.create)
    t = Object.create(n);
  else {
    var r = function() {
    };
    r.prototype = n, t = new r();
  }
  return e && re(t, e), t;
}
function tJ(n) {
  var e = n.style;
  e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
}
function Ce(n, e) {
  return n.hasOwnProperty(e);
}
function nr() {
}
var Bw = 180 / Math.PI;
function Ed(n, e) {
  return n == null && (n = 0), e == null && (e = 0), [n, e];
}
function Gi(n, e) {
  return n[0] = e[0], n[1] = e[1], n;
}
function Jl(n) {
  return [n[0], n[1]];
}
function ZOt(n, e, t) {
  return n[0] = e, n[1] = t, n;
}
function Oz(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
}
function cM(n, e, t, r) {
  return n[0] = e[0] + t[0] * r, n[1] = e[1] + t[1] * r, n;
}
function Of(n, e, t) {
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n;
}
function hM(n) {
  return Math.sqrt(WOt(n));
}
function WOt(n) {
  return n[0] * n[0] + n[1] * n[1];
}
function Vw(n, e, t) {
  return n[0] = e[0] * t, n[1] = e[1] * t, n;
}
function Pv(n, e) {
  var t = hM(e);
  return t === 0 ? (n[0] = 0, n[1] = 0) : (n[0] = e[0] / t, n[1] = e[1] / t), n;
}
function fM(n, e) {
  return Math.sqrt((n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1]));
}
var fc = fM;
function GOt(n, e) {
  return (n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1]);
}
var Vf = GOt;
function zw(n, e, t, r) {
  return n[0] = e[0] + r * (t[0] - e[0]), n[1] = e[1] + r * (t[1] - e[1]), n;
}
function vi(n, e, t) {
  var r = e[0], i = e[1];
  return n[0] = t[0] * r + t[2] * i + t[4], n[1] = t[1] * r + t[3] * i + t[5], n;
}
function dc(n, e, t) {
  return n[0] = Math.min(e[0], t[0]), n[1] = Math.min(e[1], t[1]), n;
}
function pc(n, e, t) {
  return n[0] = Math.max(e[0], t[0]), n[1] = Math.max(e[1], t[1]), n;
}
var Yd = /* @__PURE__ */ function() {
  function n(e, t) {
    this.target = e, this.topTarget = t && t.topTarget;
  }
  return n;
}(), jOt = function() {
  function n(e) {
    this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
  }
  return n.prototype._dragStart = function(e) {
    for (var t = e.target; t && !t.draggable; )
      t = t.parent || t.__hostTarget;
    t && (this._draggingTarget = t, t.dragging = !0, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new Yd(t, e), "dragstart", e.event));
  }, n.prototype._drag = function(e) {
    var t = this._draggingTarget;
    if (t) {
      var r = e.offsetX, i = e.offsetY, o = r - this._x, a = i - this._y;
      this._x = r, this._y = i, t.drift(o, a, e), this.handler.dispatchToElement(new Yd(t, e), "drag", e.event);
      var s = this.handler.findHover(r, i, t).target, l = this._dropTarget;
      this._dropTarget = s, t !== s && (l && s !== l && this.handler.dispatchToElement(new Yd(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new Yd(s, e), "dragenter", e.event));
    }
  }, n.prototype._dragEnd = function(e) {
    var t = this._draggingTarget;
    t && (t.dragging = !1), this.handler.dispatchToElement(new Yd(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new Yd(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
  }, n;
}(), HOt = function() {
  function n(e) {
    e && (this._$eventProcessor = e);
  }
  return n.prototype.on = function(e, t, r, i) {
    this._$handlers || (this._$handlers = {});
    var o = this._$handlers;
    if (typeof t == "function" && (i = r, r = t, t = null), !r || !e)
      return this;
    var a = this._$eventProcessor;
    t != null && a && a.normalizeQuery && (t = a.normalizeQuery(t)), o[e] || (o[e] = []);
    for (var s = 0; s < o[e].length; s++)
      if (o[e][s].h === r)
        return this;
    var l = {
      h: r,
      query: t,
      ctx: i || this,
      callAtLast: r.zrEventfulCallAtLast
    }, u = o[e].length - 1, c = o[e][u];
    return c && c.callAtLast ? o[e].splice(u, 0, l) : o[e].push(l), this;
  }, n.prototype.isSilent = function(e) {
    var t = this._$handlers;
    return !t || !t[e] || !t[e].length;
  }, n.prototype.off = function(e, t) {
    var r = this._$handlers;
    if (!r)
      return this;
    if (!e)
      return this._$handlers = {}, this;
    if (t) {
      if (r[e]) {
        for (var i = [], o = 0, a = r[e].length; o < a; o++)
          r[e][o].h !== t && i.push(r[e][o]);
        r[e] = i;
      }
      r[e] && r[e].length === 0 && delete r[e];
    } else
      delete r[e];
    return this;
  }, n.prototype.trigger = function(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[e], o = this._$eventProcessor;
    if (i)
      for (var a = t.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(o && o.filter && u.query != null && !o.filter(e, u.query)))
          switch (a) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, t[0]);
              break;
            case 2:
              u.h.call(u.ctx, t[0], t[1]);
              break;
            default:
              u.h.apply(u.ctx, t);
              break;
          }
      }
    return o && o.afterTrigger && o.afterTrigger(e), this;
  }, n.prototype.triggerWithContext = function(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[e], o = this._$eventProcessor;
    if (i)
      for (var a = t.length, s = t[a - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(o && o.filter && c.query != null && !o.filter(e, c.query)))
          switch (a) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, t[0]);
              break;
            case 2:
              c.h.call(s, t[0], t[1]);
              break;
            default:
              c.h.apply(s, t.slice(1, a - 1));
              break;
          }
      }
    return o && o.afterTrigger && o.afterTrigger(e), this;
  }, n;
}();
const Ba = HOt;
var qOt = Math.log(2);
function dM(n, e, t, r, i, o) {
  var a = r + "-" + i, s = n.length;
  if (o.hasOwnProperty(a))
    return o[a];
  if (e === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~i) / qOt);
    return n[t][l];
  }
  for (var u = r | 1 << t, c = t + 1; r & 1 << c; )
    c++;
  for (var h = 0, f = 0, d = 0; f < s; f++) {
    var p = 1 << f;
    p & i || (h += (d % 2 ? -1 : 1) * n[t][f] * dM(n, e - 1, c, u, i | p, o), d++);
  }
  return o[a] = h, h;
}
function wz(n, e) {
  var t = [
    [n[0], n[1], 1, 0, 0, 0, -e[0] * n[0], -e[0] * n[1]],
    [0, 0, 0, n[0], n[1], 1, -e[1] * n[0], -e[1] * n[1]],
    [n[2], n[3], 1, 0, 0, 0, -e[2] * n[2], -e[2] * n[3]],
    [0, 0, 0, n[2], n[3], 1, -e[3] * n[2], -e[3] * n[3]],
    [n[4], n[5], 1, 0, 0, 0, -e[4] * n[4], -e[4] * n[5]],
    [0, 0, 0, n[4], n[5], 1, -e[5] * n[4], -e[5] * n[5]],
    [n[6], n[7], 1, 0, 0, 0, -e[6] * n[6], -e[6] * n[7]],
    [0, 0, 0, n[6], n[7], 1, -e[7] * n[6], -e[7] * n[7]]
  ], r = {}, i = dM(t, 8, 0, 0, 0, r);
  if (i !== 0) {
    for (var o = [], a = 0; a < 8; a++)
      for (var s = 0; s < 8; s++)
        o[s] == null && (o[s] = 0), o[s] += ((a + s) % 2 ? -1 : 1) * dM(t, 7, a === 0 ? 1 : 0, 1 << a, 1 << s, r) / i * e[a];
    return function(l, u, c) {
      var h = u * o[6] + c * o[7] + 1;
      l[0] = (u * o[0] + c * o[1] + o[2]) / h, l[1] = (u * o[3] + c * o[4] + o[5]) / h;
    };
  }
}
var xz = "___zrEVENTSAVED", mA = [];
function YOt(n, e, t, r, i) {
  return pM(mA, e, r, i, !0) && pM(n, t, mA[0], mA[1]);
}
function pM(n, e, t, r, i) {
  if (e.getBoundingClientRect && mt.domSupported && !nJ(e)) {
    var o = e[xz] || (e[xz] = {}), a = XOt(e, o), s = UOt(a, o, i);
    if (s)
      return s(n, t, r), !0;
  }
  return !1;
}
function XOt(n, e) {
  var t = e.markers;
  if (t)
    return t;
  t = e.markers = [];
  for (var r = ["left", "right"], i = ["top", "bottom"], o = 0; o < 4; o++) {
    var a = document.createElement("div"), s = a.style, l = o % 2, u = (o >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      r[l] + ":0",
      i[u] + ":0",
      r[1 - l] + ":auto",
      i[1 - u] + ":auto",
      ""
    ].join("!important;"), n.appendChild(a), t.push(a);
  }
  return t;
}
function UOt(n, e, t) {
  for (var r = t ? "invTrans" : "trans", i = e[r], o = e.srcCoords, a = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = n[u].getBoundingClientRect(), h = 2 * u, f = c.left, d = c.top;
    a.push(f, d), l = l && o && f === o[h] && d === o[h + 1], s.push(n[u].offsetLeft, n[u].offsetTop);
  }
  return l && i ? i : (e.srcCoords = a, e[r] = t ? wz(s, a) : wz(a, s));
}
function nJ(n) {
  return n.nodeName.toUpperCase() === "CANVAS";
}
var KOt = /([&<>"'])/g, JOt = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function mo(n) {
  return n == null ? "" : (n + "").replace(KOt, function(e, t) {
    return JOt[t];
  });
}
var ewt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, yA = [], twt = mt.browser.firefox && +mt.browser.version.split(".")[0] < 39;
function gM(n, e, t, r) {
  return t = t || {}, r ? Sz(n, e, t) : twt && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : Sz(n, e, t), t;
}
function Sz(n, e, t) {
  if (mt.domSupported && n.getBoundingClientRect) {
    var r = e.clientX, i = e.clientY;
    if (nJ(n)) {
      var o = n.getBoundingClientRect();
      t.zrX = r - o.left, t.zrY = i - o.top;
      return;
    } else if (pM(yA, n, r, i)) {
      t.zrX = yA[0], t.zrY = yA[1];
      return;
    }
  }
  t.zrX = t.zrY = 0;
}
function CR(n) {
  return n || window.event;
}
function sa(n, e, t) {
  if (e = CR(e), e.zrX != null)
    return e;
  var r = e.type, i = r && r.indexOf("touch") >= 0;
  if (i) {
    var a = r !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
    a && gM(n, a, e, t);
  } else {
    gM(n, e, e, t);
    var o = nwt(e);
    e.zrDelta = o ? o / 120 : -(e.detail || 0) / 3;
  }
  var s = e.button;
  return e.which == null && s !== void 0 && ewt.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e;
}
function nwt(n) {
  var e = n.wheelDelta;
  if (e)
    return e;
  var t = n.deltaX, r = n.deltaY;
  if (t == null || r == null)
    return e;
  var i = Math.abs(r !== 0 ? r : t), o = r > 0 ? -1 : r < 0 ? 1 : t > 0 ? -1 : 1;
  return 3 * i * o;
}
function vM(n, e, t, r) {
  n.addEventListener(e, t, r);
}
function rwt(n, e, t, r) {
  n.removeEventListener(e, t, r);
}
var du = function(n) {
  n.preventDefault(), n.stopPropagation(), n.cancelBubble = !0;
};
function _z(n) {
  return n.which === 2 || n.which === 3;
}
var iwt = function() {
  function n() {
    this._track = [];
  }
  return n.prototype.recognize = function(e, t, r) {
    return this._doTrack(e, t, r), this._recognize(e);
  }, n.prototype.clear = function() {
    return this._track.length = 0, this;
  }, n.prototype._doTrack = function(e, t, r) {
    var i = e.touches;
    if (i) {
      for (var o = {
        points: [],
        touches: [],
        target: t,
        event: e
      }, a = 0, s = i.length; a < s; a++) {
        var l = i[a], u = gM(r, l, {});
        o.points.push([u.zrX, u.zrY]), o.touches.push(l);
      }
      this._track.push(o);
    }
  }, n.prototype._recognize = function(e) {
    for (var t in bA)
      if (bA.hasOwnProperty(t)) {
        var r = bA[t](this._track, e);
        if (r)
          return r;
      }
  }, n;
}();
function Cz(n) {
  var e = n[1][0] - n[0][0], t = n[1][1] - n[0][1];
  return Math.sqrt(e * e + t * t);
}
function owt(n) {
  return [
    (n[0][0] + n[1][0]) / 2,
    (n[0][1] + n[1][1]) / 2
  ];
}
var bA = {
  pinch: function(n, e) {
    var t = n.length;
    if (t) {
      var r = (n[t - 1] || {}).points, i = (n[t - 2] || {}).points || r;
      if (i && i.length > 1 && r && r.length > 1) {
        var o = Cz(r) / Cz(i);
        !isFinite(o) && (o = 1), e.pinchScale = o;
        var a = owt(r);
        return e.pinchX = a[0], e.pinchY = a[1], {
          type: "pinch",
          target: n[0].target,
          event: e
        };
      }
    }
  }
};
function Ho() {
  return [1, 0, 0, 1, 0, 0];
}
function pC(n) {
  return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
}
function AR(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n;
}
function eu(n, e, t) {
  var r = e[0] * t[0] + e[2] * t[1], i = e[1] * t[0] + e[3] * t[1], o = e[0] * t[2] + e[2] * t[3], a = e[1] * t[2] + e[3] * t[3], s = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5];
  return n[0] = r, n[1] = i, n[2] = o, n[3] = a, n[4] = s, n[5] = l, n;
}
function Sl(n, e, t) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4] + t[0], n[5] = e[5] + t[1], n;
}
function Md(n, e, t, r) {
  r === void 0 && (r = [0, 0]);
  var i = e[0], o = e[2], a = e[4], s = e[1], l = e[3], u = e[5], c = Math.sin(t), h = Math.cos(t);
  return n[0] = i * h + s * c, n[1] = -i * c + s * h, n[2] = o * h + l * c, n[3] = -o * c + h * l, n[4] = h * (a - r[0]) + c * (u - r[1]) + r[0], n[5] = h * (u - r[1]) - c * (a - r[0]) + r[1], n;
}
function TR(n, e, t) {
  var r = t[0], i = t[1];
  return n[0] = e[0] * r, n[1] = e[1] * i, n[2] = e[2] * r, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * i, n;
}
function Ev(n, e) {
  var t = e[0], r = e[2], i = e[4], o = e[1], a = e[3], s = e[5], l = t * a - o * r;
  return l ? (l = 1 / l, n[0] = a * l, n[1] = -o * l, n[2] = -r * l, n[3] = t * l, n[4] = (r * s - a * i) * l, n[5] = (o * i - t * s) * l, n) : null;
}
function awt(n) {
  var e = Ho();
  return AR(e, n), e;
}
var nt = function() {
  function n(e, t) {
    this.x = e || 0, this.y = t || 0;
  }
  return n.prototype.copy = function(e) {
    return this.x = e.x, this.y = e.y, this;
  }, n.prototype.clone = function() {
    return new n(this.x, this.y);
  }, n.prototype.set = function(e, t) {
    return this.x = e, this.y = t, this;
  }, n.prototype.equal = function(e) {
    return e.x === this.x && e.y === this.y;
  }, n.prototype.add = function(e) {
    return this.x += e.x, this.y += e.y, this;
  }, n.prototype.scale = function(e) {
    this.x *= e, this.y *= e;
  }, n.prototype.scaleAndAdd = function(e, t) {
    this.x += e.x * t, this.y += e.y * t;
  }, n.prototype.sub = function(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }, n.prototype.dot = function(e) {
    return this.x * e.x + this.y * e.y;
  }, n.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, n.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, n.prototype.normalize = function() {
    var e = this.len();
    return this.x /= e, this.y /= e, this;
  }, n.prototype.distance = function(e) {
    var t = this.x - e.x, r = this.y - e.y;
    return Math.sqrt(t * t + r * r);
  }, n.prototype.distanceSquare = function(e) {
    var t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }, n.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, n.prototype.transform = function(e) {
    if (e) {
      var t = this.x, r = this.y;
      return this.x = e[0] * t + e[2] * r + e[4], this.y = e[1] * t + e[3] * r + e[5], this;
    }
  }, n.prototype.toArray = function(e) {
    return e[0] = this.x, e[1] = this.y, e;
  }, n.prototype.fromArray = function(e) {
    this.x = e[0], this.y = e[1];
  }, n.set = function(e, t, r) {
    e.x = t, e.y = r;
  }, n.copy = function(e, t) {
    e.x = t.x, e.y = t.y;
  }, n.len = function(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }, n.lenSquare = function(e) {
    return e.x * e.x + e.y * e.y;
  }, n.dot = function(e, t) {
    return e.x * t.x + e.y * t.y;
  }, n.add = function(e, t, r) {
    e.x = t.x + r.x, e.y = t.y + r.y;
  }, n.sub = function(e, t, r) {
    e.x = t.x - r.x, e.y = t.y - r.y;
  }, n.scale = function(e, t, r) {
    e.x = t.x * r, e.y = t.y * r;
  }, n.scaleAndAdd = function(e, t, r, i) {
    e.x = t.x + r.x * i, e.y = t.y + r.y * i;
  }, n.lerp = function(e, t, r, i) {
    var o = 1 - i;
    e.x = o * t.x + i * r.x, e.y = o * t.y + i * r.y;
  }, n;
}(), J1 = Math.min, eO = Math.max, wh = new nt(), xh = new nt(), Sh = new nt(), _h = new nt(), am = new nt(), sm = new nt(), swt = function() {
  function n(e, t, r, i) {
    r < 0 && (e = e + r, r = -r), i < 0 && (t = t + i, i = -i), this.x = e, this.y = t, this.width = r, this.height = i;
  }
  return n.prototype.union = function(e) {
    var t = J1(e.x, this.x), r = J1(e.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = eO(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = eO(e.y + e.height, this.y + this.height) - r : this.height = e.height, this.x = t, this.y = r;
  }, n.prototype.applyTransform = function(e) {
    n.applyTransform(this, this, e);
  }, n.prototype.calculateTransform = function(e) {
    var t = this, r = e.width / t.width, i = e.height / t.height, o = Ho();
    return Sl(o, o, [-t.x, -t.y]), TR(o, o, [r, i]), Sl(o, o, [e.x, e.y]), o;
  }, n.prototype.intersect = function(e, t) {
    if (!e)
      return !1;
    e instanceof n || (e = n.create(e));
    var r = this, i = r.x, o = r.x + r.width, a = r.y, s = r.y + r.height, l = e.x, u = e.x + e.width, c = e.y, h = e.y + e.height, f = !(o < l || u < i || s < c || h < a);
    if (t) {
      var d = 1 / 0, p = 0, g = Math.abs(o - l), v = Math.abs(u - i), m = Math.abs(s - c), y = Math.abs(h - a), b = Math.min(g, v), O = Math.min(m, y);
      o < l || u < i ? b > p && (p = b, g < v ? nt.set(sm, -g, 0) : nt.set(sm, v, 0)) : b < d && (d = b, g < v ? nt.set(am, g, 0) : nt.set(am, -v, 0)), s < c || h < a ? O > p && (p = O, m < y ? nt.set(sm, 0, -m) : nt.set(sm, 0, y)) : b < d && (d = b, m < y ? nt.set(am, 0, m) : nt.set(am, 0, -y));
    }
    return t && nt.copy(t, f ? am : sm), f;
  }, n.prototype.contain = function(e, t) {
    var r = this;
    return e >= r.x && e <= r.x + r.width && t >= r.y && t <= r.y + r.height;
  }, n.prototype.clone = function() {
    return new n(this.x, this.y, this.width, this.height);
  }, n.prototype.copy = function(e) {
    n.copy(this, e);
  }, n.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, n.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, n.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, n.create = function(e) {
    return new n(e.x, e.y, e.width, e.height);
  }, n.copy = function(e, t) {
    e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height;
  }, n.applyTransform = function(e, t, r) {
    if (!r) {
      e !== t && n.copy(e, t);
      return;
    }
    if (r[1] < 1e-5 && r[1] > -1e-5 && r[2] < 1e-5 && r[2] > -1e-5) {
      var i = r[0], o = r[3], a = r[4], s = r[5];
      e.x = t.x * i + a, e.y = t.y * o + s, e.width = t.width * i, e.height = t.height * o, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
      return;
    }
    wh.x = Sh.x = t.x, wh.y = _h.y = t.y, xh.x = _h.x = t.x + t.width, xh.y = Sh.y = t.y + t.height, wh.transform(r), _h.transform(r), xh.transform(r), Sh.transform(r), e.x = J1(wh.x, xh.x, Sh.x, _h.x), e.y = J1(wh.y, xh.y, Sh.y, _h.y);
    var l = eO(wh.x, xh.x, Sh.x, _h.x), u = eO(wh.y, xh.y, Sh.y, _h.y);
    e.width = l - e.x, e.height = u - e.y;
  }, n;
}();
const ot = swt;
var rJ = "silent";
function lwt(n, e, t) {
  return {
    type: n,
    event: t,
    target: e.target,
    topTarget: e.topTarget,
    cancelBubble: !1,
    offsetX: t.zrX,
    offsetY: t.zrY,
    gestureEvent: t.gestureEvent,
    pinchX: t.pinchX,
    pinchY: t.pinchY,
    pinchScale: t.pinchScale,
    wheelDelta: t.zrDelta,
    zrByTouch: t.zrByTouch,
    which: t.which,
    stop: uwt
  };
}
function uwt() {
  du(this.event);
}
var cwt = function(n) {
  H(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.handler = null, t;
  }
  return e.prototype.dispose = function() {
  }, e.prototype.setCursor = function() {
  }, e;
}(Ba), lm = /* @__PURE__ */ function() {
  function n(e, t) {
    this.x = e, this.y = t;
  }
  return n;
}(), hwt = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], OA = new ot(0, 0, 0, 0), iJ = function(n) {
  H(e, n);
  function e(t, r, i, o, a) {
    var s = n.call(this) || this;
    return s._hovered = new lm(0, 0), s.storage = t, s.painter = r, s.painterRoot = o, s._pointerSize = a, i = i || new cwt(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new jOt(s), s;
  }
  return e.prototype.setHandlerProxy = function(t) {
    this.proxy && this.proxy.dispose(), t && (I(hwt, function(r) {
      t.on && t.on(r, this[r], this);
    }, this), t.handler = this), this.proxy = t;
  }, e.prototype.mousemove = function(t) {
    var r = t.zrX, i = t.zrY, o = oJ(this, r, i), a = this._hovered, s = a.target;
    s && !s.__zr && (a = this.findHover(a.x, a.y), s = a.target);
    var l = this._hovered = o ? new lm(r, i) : this.findHover(r, i), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(a, "mouseout", t), this.dispatchToElement(l, "mousemove", t), u && u !== s && this.dispatchToElement(l, "mouseover", t);
  }, e.prototype.mouseout = function(t) {
    var r = t.zrEventControl;
    r !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), r !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: t });
  }, e.prototype.resize = function() {
    this._hovered = new lm(0, 0);
  }, e.prototype.dispatch = function(t, r) {
    var i = this[t];
    i && i.call(this, r);
  }, e.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, e.prototype.setCursorStyle = function(t) {
    var r = this.proxy;
    r.setCursor && r.setCursor(t);
  }, e.prototype.dispatchToElement = function(t, r, i) {
    t = t || {};
    var o = t.target;
    if (!(o && o.silent)) {
      for (var a = "on" + r, s = lwt(r, t, i); o && (o[a] && (s.cancelBubble = !!o[a].call(o, s)), o.trigger(r, s), o = o.__hostTarget ? o.__hostTarget : o.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(r, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[a] == "function" && l[a].call(l, s), l.trigger && l.trigger(r, s);
      }));
    }
  }, e.prototype.findHover = function(t, r, i) {
    var o = this.storage.getDisplayList(), a = new lm(t, r);
    if (Az(o, a, t, r, i), this._pointerSize && !a.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new ot(t - u, r - u, l, l), h = o.length - 1; h >= 0; h--) {
        var f = o[h];
        f !== i && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (OA.copy(f.getBoundingRect()), f.transform && OA.applyTransform(f.transform), OA.intersect(c) && s.push(f));
      }
      if (s.length)
        for (var d = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += d)
          for (var m = 0; m < g; m += p) {
            var y = t + v * Math.cos(m), b = r + v * Math.sin(m);
            if (Az(s, a, y, b, i), a.target)
              return a;
          }
    }
    return a;
  }, e.prototype.processGesture = function(t, r) {
    this._gestureMgr || (this._gestureMgr = new iwt());
    var i = this._gestureMgr;
    r === "start" && i.clear();
    var o = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
    if (r === "end" && i.clear(), o) {
      var a = o.type;
      t.gestureEvent = a;
      var s = new lm();
      s.target = o.target, this.dispatchToElement(s, a, o.event);
    }
  }, e;
}(Ba);
I(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(n) {
  iJ.prototype[n] = function(e) {
    var t = e.zrX, r = e.zrY, i = oJ(this, t, r), o, a;
    if ((n !== "mouseup" || !i) && (o = this.findHover(t, r), a = o.target), n === "mousedown")
      this._downEl = a, this._downPoint = [e.zrX, e.zrY], this._upEl = a;
    else if (n === "mouseup")
      this._upEl = a;
    else if (n === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || fc(this._downPoint, [e.zrX, e.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(o, n, e);
  };
});
function fwt(n, e, t) {
  if (n[n.rectHover ? "rectContain" : "contain"](e, t)) {
    for (var r = n, i = void 0, o = !1; r; ) {
      if (r.ignoreClip && (o = !0), !o) {
        var a = r.getClipPath();
        if (a && !a.contain(e, t))
          return !1;
      }
      r.silent && (i = !0);
      var s = r.__hostTarget;
      r = s || r.parent;
    }
    return i ? rJ : !0;
  }
  return !1;
}
function Az(n, e, t, r, i) {
  for (var o = n.length - 1; o >= 0; o--) {
    var a = n[o], s = void 0;
    if (a !== i && !a.ignore && (s = fwt(a, t, r)) && (!e.topTarget && (e.topTarget = a), s !== rJ)) {
      e.target = a;
      break;
    }
  }
}
function oJ(n, e, t) {
  var r = n.painter;
  return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight();
}
const dwt = iJ;
var aJ = 32, um = 7;
function pwt(n) {
  for (var e = 0; n >= aJ; )
    e |= n & 1, n >>= 1;
  return n + e;
}
function Tz(n, e, t, r) {
  var i = e + 1;
  if (i === t)
    return 1;
  if (r(n[i++], n[e]) < 0) {
    for (; i < t && r(n[i], n[i - 1]) < 0; )
      i++;
    gwt(n, e, i);
  } else
    for (; i < t && r(n[i], n[i - 1]) >= 0; )
      i++;
  return i - e;
}
function gwt(n, e, t) {
  for (t--; e < t; ) {
    var r = n[e];
    n[e++] = n[t], n[t--] = r;
  }
}
function kz(n, e, t, r, i) {
  for (r === e && r++; r < t; r++) {
    for (var o = n[r], a = e, s = r, l; a < s; )
      l = a + s >>> 1, i(o, n[l]) < 0 ? s = l : a = l + 1;
    var u = r - a;
    switch (u) {
      case 3:
        n[a + 3] = n[a + 2];
      case 2:
        n[a + 2] = n[a + 1];
      case 1:
        n[a + 1] = n[a];
        break;
      default:
        for (; u > 0; )
          n[a + u] = n[a + u - 1], u--;
    }
    n[a] = o;
  }
}
function wA(n, e, t, r, i, o) {
  var a = 0, s = 0, l = 1;
  if (o(n, e[t + i]) > 0) {
    for (s = r - i; l < s && o(n, e[t + i + l]) > 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), a += i, l += i;
  } else {
    for (s = i + 1; l < s && o(n, e[t + i - l]) <= 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = a;
    a = i - l, l = i - u;
  }
  for (a++; a < l; ) {
    var c = a + (l - a >>> 1);
    o(n, e[t + c]) > 0 ? a = c + 1 : l = c;
  }
  return l;
}
function xA(n, e, t, r, i, o) {
  var a = 0, s = 0, l = 1;
  if (o(n, e[t + i]) < 0) {
    for (s = i + 1; l < s && o(n, e[t + i - l]) < 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = a;
    a = i - l, l = i - u;
  } else {
    for (s = r - i; l < s && o(n, e[t + i + l]) >= 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), a += i, l += i;
  }
  for (a++; a < l; ) {
    var c = a + (l - a >>> 1);
    o(n, e[t + c]) < 0 ? l = c : a = c + 1;
  }
  return l;
}
function vwt(n, e) {
  var t = um, r, i, o = 0, a = [];
  r = [], i = [];
  function s(d, p) {
    r[o] = d, i[o] = p, o += 1;
  }
  function l() {
    for (; o > 1; ) {
      var d = o - 2;
      if (d >= 1 && i[d - 1] <= i[d] + i[d + 1] || d >= 2 && i[d - 2] <= i[d] + i[d - 1])
        i[d - 1] < i[d + 1] && d--;
      else if (i[d] > i[d + 1])
        break;
      c(d);
    }
  }
  function u() {
    for (; o > 1; ) {
      var d = o - 2;
      d > 0 && i[d - 1] < i[d + 1] && d--, c(d);
    }
  }
  function c(d) {
    var p = r[d], g = i[d], v = r[d + 1], m = i[d + 1];
    i[d] = g + m, d === o - 3 && (r[d + 1] = r[d + 2], i[d + 1] = i[d + 2]), o--;
    var y = xA(n[v], n, p, g, 0, e);
    p += y, g -= y, g !== 0 && (m = wA(n[p + g - 1], n, v, m, m - 1, e), m !== 0 && (g <= m ? h(p, g, v, m) : f(p, g, v, m)));
  }
  function h(d, p, g, v) {
    var m = 0;
    for (m = 0; m < p; m++)
      a[m] = n[d + m];
    var y = 0, b = g, O = d;
    if (n[O++] = n[b++], --v === 0) {
      for (m = 0; m < p; m++)
        n[O + m] = a[y + m];
      return;
    }
    if (p === 1) {
      for (m = 0; m < v; m++)
        n[O + m] = n[b + m];
      n[O + v] = a[y];
      return;
    }
    for (var w = t, x, S, _; ; ) {
      x = 0, S = 0, _ = !1;
      do
        if (e(n[b], a[y]) < 0) {
          if (n[O++] = n[b++], S++, x = 0, --v === 0) {
            _ = !0;
            break;
          }
        } else if (n[O++] = a[y++], x++, S = 0, --p === 1) {
          _ = !0;
          break;
        }
      while ((x | S) < w);
      if (_)
        break;
      do {
        if (x = xA(n[b], a, y, p, 0, e), x !== 0) {
          for (m = 0; m < x; m++)
            n[O + m] = a[y + m];
          if (O += x, y += x, p -= x, p <= 1) {
            _ = !0;
            break;
          }
        }
        if (n[O++] = n[b++], --v === 0) {
          _ = !0;
          break;
        }
        if (S = wA(a[y], n, b, v, 0, e), S !== 0) {
          for (m = 0; m < S; m++)
            n[O + m] = n[b + m];
          if (O += S, b += S, v -= S, v === 0) {
            _ = !0;
            break;
          }
        }
        if (n[O++] = a[y++], --p === 1) {
          _ = !0;
          break;
        }
        w--;
      } while (x >= um || S >= um);
      if (_)
        break;
      w < 0 && (w = 0), w += 2;
    }
    if (t = w, t < 1 && (t = 1), p === 1) {
      for (m = 0; m < v; m++)
        n[O + m] = n[b + m];
      n[O + v] = a[y];
    } else {
      if (p === 0)
        throw new Error();
      for (m = 0; m < p; m++)
        n[O + m] = a[y + m];
    }
  }
  function f(d, p, g, v) {
    var m = 0;
    for (m = 0; m < v; m++)
      a[m] = n[g + m];
    var y = d + p - 1, b = v - 1, O = g + v - 1, w = 0, x = 0;
    if (n[O--] = n[y--], --p === 0) {
      for (w = O - (v - 1), m = 0; m < v; m++)
        n[w + m] = a[m];
      return;
    }
    if (v === 1) {
      for (O -= p, y -= p, x = O + 1, w = y + 1, m = p - 1; m >= 0; m--)
        n[x + m] = n[w + m];
      n[O] = a[b];
      return;
    }
    for (var S = t; ; ) {
      var _ = 0, C = 0, A = !1;
      do
        if (e(a[b], n[y]) < 0) {
          if (n[O--] = n[y--], _++, C = 0, --p === 0) {
            A = !0;
            break;
          }
        } else if (n[O--] = a[b--], C++, _ = 0, --v === 1) {
          A = !0;
          break;
        }
      while ((_ | C) < S);
      if (A)
        break;
      do {
        if (_ = p - xA(a[b], n, d, p, p - 1, e), _ !== 0) {
          for (O -= _, y -= _, p -= _, x = O + 1, w = y + 1, m = _ - 1; m >= 0; m--)
            n[x + m] = n[w + m];
          if (p === 0) {
            A = !0;
            break;
          }
        }
        if (n[O--] = a[b--], --v === 1) {
          A = !0;
          break;
        }
        if (C = v - wA(n[y], a, 0, v, v - 1, e), C !== 0) {
          for (O -= C, b -= C, v -= C, x = O + 1, w = b + 1, m = 0; m < C; m++)
            n[x + m] = a[w + m];
          if (v <= 1) {
            A = !0;
            break;
          }
        }
        if (n[O--] = n[y--], --p === 0) {
          A = !0;
          break;
        }
        S--;
      } while (_ >= um || C >= um);
      if (A)
        break;
      S < 0 && (S = 0), S += 2;
    }
    if (t = S, t < 1 && (t = 1), v === 1) {
      for (O -= p, y -= p, x = O + 1, w = y + 1, m = p - 1; m >= 0; m--)
        n[x + m] = n[w + m];
      n[O] = a[b];
    } else {
      if (v === 0)
        throw new Error();
      for (w = O - (v - 1), m = 0; m < v; m++)
        n[w + m] = a[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function Fw(n, e, t, r) {
  t || (t = 0), r || (r = n.length);
  var i = r - t;
  if (!(i < 2)) {
    var o = 0;
    if (i < aJ) {
      o = Tz(n, t, r, e), kz(n, t, r, t + o, e);
      return;
    }
    var a = vwt(n, e), s = pwt(i);
    do {
      if (o = Tz(n, t, r, e), o < s) {
        var l = i;
        l > s && (l = s), kz(n, t, t + l, t + o, e), o = l;
      }
      a.pushRun(t, o), a.mergeRuns(), i -= o, t += o;
    } while (i !== 0);
    a.forceMergeRuns();
  }
}
var Zo = 1, Hm = 2, Sp = 4, Pz = !1;
function SA() {
  Pz || (Pz = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function Ez(n, e) {
  return n.zlevel === e.zlevel ? n.z === e.z ? n.z2 - e.z2 : n.z - e.z : n.zlevel - e.zlevel;
}
var mwt = function() {
  function n() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = Ez;
  }
  return n.prototype.traverse = function(e, t) {
    for (var r = 0; r < this._roots.length; r++)
      this._roots[r].traverse(e, t);
  }, n.prototype.getDisplayList = function(e, t) {
    t = t || !1;
    var r = this._displayList;
    return (e || !r.length) && this.updateDisplayList(t), r;
  }, n.prototype.updateDisplayList = function(e) {
    this._displayListLen = 0;
    for (var t = this._roots, r = this._displayList, i = 0, o = t.length; i < o; i++)
      this._updateAndAddDisplayable(t[i], null, e);
    r.length = this._displayListLen, Fw(r, Ez);
  }, n.prototype._updateAndAddDisplayable = function(e, t, r) {
    if (!(e.ignore && !r)) {
      e.beforeUpdate(), e.update(), e.afterUpdate();
      var i = e.getClipPath();
      if (e.ignoreClip)
        t = null;
      else if (i) {
        t ? t = t.slice() : t = [];
        for (var o = i, a = e; o; )
          o.parent = a, o.updateTransform(), t.push(o), a = o, o = o.getClipPath();
      }
      if (e.childrenRef) {
        for (var s = e.childrenRef(), l = 0; l < s.length; l++) {
          var u = s[l];
          e.__dirty && (u.__dirty |= Zo), this._updateAndAddDisplayable(u, t, r);
        }
        e.__dirty = 0;
      } else {
        var c = e;
        t && t.length ? c.__clipPaths = t : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (SA(), c.z = 0), isNaN(c.z2) && (SA(), c.z2 = 0), isNaN(c.zlevel) && (SA(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
      }
      var h = e.getDecalElement && e.getDecalElement();
      h && this._updateAndAddDisplayable(h, t, r);
      var f = e.getTextGuideLine();
      f && this._updateAndAddDisplayable(f, t, r);
      var d = e.getTextContent();
      d && this._updateAndAddDisplayable(d, t, r);
    }
  }, n.prototype.addRoot = function(e) {
    e.__zr && e.__zr.storage === this || this._roots.push(e);
  }, n.prototype.delRoot = function(e) {
    if (e instanceof Array) {
      for (var t = 0, r = e.length; t < r; t++)
        this.delRoot(e[t]);
      return;
    }
    var i = ct(this._roots, e);
    i >= 0 && this._roots.splice(i, 1);
  }, n.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, n.prototype.getRoots = function() {
    return this._roots;
  }, n.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, n;
}(), sJ;
sJ = mt.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(n) {
  return setTimeout(n, 16);
};
const mM = sJ;
var Ey = {
  linear: function(n) {
    return n;
  },
  quadraticIn: function(n) {
    return n * n;
  },
  quadraticOut: function(n) {
    return n * (2 - n);
  },
  quadraticInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
  },
  cubicIn: function(n) {
    return n * n * n;
  },
  cubicOut: function(n) {
    return --n * n * n + 1;
  },
  cubicInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
  },
  quarticIn: function(n) {
    return n * n * n * n;
  },
  quarticOut: function(n) {
    return 1 - --n * n * n * n;
  },
  quarticInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);
  },
  quinticIn: function(n) {
    return n * n * n * n * n;
  },
  quinticOut: function(n) {
    return --n * n * n * n * n + 1;
  },
  quinticInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);
  },
  sinusoidalIn: function(n) {
    return 1 - Math.cos(n * Math.PI / 2);
  },
  sinusoidalOut: function(n) {
    return Math.sin(n * Math.PI / 2);
  },
  sinusoidalInOut: function(n) {
    return 0.5 * (1 - Math.cos(Math.PI * n));
  },
  exponentialIn: function(n) {
    return n === 0 ? 0 : Math.pow(1024, n - 1);
  },
  exponentialOut: function(n) {
    return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
  },
  exponentialInOut: function(n) {
    return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
  },
  circularIn: function(n) {
    return 1 - Math.sqrt(1 - n * n);
  },
  circularOut: function(n) {
    return Math.sqrt(1 - --n * n);
  },
  circularInOut: function(n) {
    return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
  },
  elasticIn: function(n) {
    var e, t = 0.1, r = 0.4;
    return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r)));
  },
  elasticOut: function(n) {
    var e, t = 0.1, r = 0.4;
    return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * n) * Math.sin((n - e) * (2 * Math.PI) / r) + 1);
  },
  elasticInOut: function(n) {
    var e, t = 0.1, r = 0.4;
    return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), (n *= 2) < 1 ? -0.5 * (t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r)) : t * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r) * 0.5 + 1);
  },
  backIn: function(n) {
    var e = 1.70158;
    return n * n * ((e + 1) * n - e);
  },
  backOut: function(n) {
    var e = 1.70158;
    return --n * n * ((e + 1) * n + e) + 1;
  },
  backInOut: function(n) {
    var e = 2.5949095;
    return (n *= 2) < 1 ? 0.5 * (n * n * ((e + 1) * n - e)) : 0.5 * ((n -= 2) * n * ((e + 1) * n + e) + 2);
  },
  bounceIn: function(n) {
    return 1 - Ey.bounceOut(1 - n);
  },
  bounceOut: function(n) {
    return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
  },
  bounceInOut: function(n) {
    return n < 0.5 ? Ey.bounceIn(n * 2) * 0.5 : Ey.bounceOut(n * 2 - 1) * 0.5 + 0.5;
  }
}, tO = Math.pow, _c = Math.sqrt, lS = 1e-8, lJ = 1e-4, Mz = _c(3), nO = 1 / 3, Ys = Ed(), da = Ed(), Xp = Ed();
function gc(n) {
  return n > -lS && n < lS;
}
function uJ(n) {
  return n > lS || n < -lS;
}
function Dr(n, e, t, r, i) {
  var o = 1 - i;
  return o * o * (o * n + 3 * i * e) + i * i * (i * r + 3 * o * t);
}
function Dz(n, e, t, r, i) {
  var o = 1 - i;
  return 3 * (((e - n) * o + 2 * (t - e) * i) * o + (r - t) * i * i);
}
function uS(n, e, t, r, i, o) {
  var a = r + 3 * (e - t) - n, s = 3 * (t - e * 2 + n), l = 3 * (e - n), u = n - i, c = s * s - 3 * a * l, h = s * l - 9 * a * u, f = l * l - 3 * s * u, d = 0;
  if (gc(c) && gc(h))
    if (gc(s))
      o[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (o[d++] = p);
    }
  else {
    var g = h * h - 4 * c * f;
    if (gc(g)) {
      var v = h / c, p = -s / a + v, m = -v / 2;
      p >= 0 && p <= 1 && (o[d++] = p), m >= 0 && m <= 1 && (o[d++] = m);
    } else if (g > 0) {
      var y = _c(g), b = c * s + 1.5 * a * (-h + y), O = c * s + 1.5 * a * (-h - y);
      b < 0 ? b = -tO(-b, nO) : b = tO(b, nO), O < 0 ? O = -tO(-O, nO) : O = tO(O, nO);
      var p = (-s - (b + O)) / (3 * a);
      p >= 0 && p <= 1 && (o[d++] = p);
    } else {
      var w = (2 * c * s - 3 * a * h) / (2 * _c(c * c * c)), x = Math.acos(w) / 3, S = _c(c), _ = Math.cos(x), p = (-s - 2 * S * _) / (3 * a), m = (-s + S * (_ + Mz * Math.sin(x))) / (3 * a), C = (-s + S * (_ - Mz * Math.sin(x))) / (3 * a);
      p >= 0 && p <= 1 && (o[d++] = p), m >= 0 && m <= 1 && (o[d++] = m), C >= 0 && C <= 1 && (o[d++] = C);
    }
  }
  return d;
}
function cJ(n, e, t, r, i) {
  var o = 6 * t - 12 * e + 6 * n, a = 9 * e + 3 * r - 3 * n - 9 * t, s = 3 * e - 3 * n, l = 0;
  if (gc(a)) {
    if (uJ(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (gc(c))
      i[0] = -o / (2 * a);
    else if (c > 0) {
      var h = _c(c), u = (-o + h) / (2 * a), f = (-o - h) / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
    }
  }
  return l;
}
function Hc(n, e, t, r, i, o) {
  var a = (e - n) * i + n, s = (t - e) * i + e, l = (r - t) * i + t, u = (s - a) * i + a, c = (l - s) * i + s, h = (c - u) * i + u;
  o[0] = n, o[1] = a, o[2] = u, o[3] = h, o[4] = h, o[5] = c, o[6] = l, o[7] = r;
}
function hJ(n, e, t, r, i, o, a, s, l, u, c) {
  var h, f = 5e-3, d = 1 / 0, p, g, v, m;
  Ys[0] = l, Ys[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    da[0] = Dr(n, t, i, a, y), da[1] = Dr(e, r, o, s, y), v = Vf(Ys, da), v < d && (h = y, d = v);
  d = 1 / 0;
  for (var b = 0; b < 32 && !(f < lJ); b++)
    p = h - f, g = h + f, da[0] = Dr(n, t, i, a, p), da[1] = Dr(e, r, o, s, p), v = Vf(da, Ys), p >= 0 && v < d ? (h = p, d = v) : (Xp[0] = Dr(n, t, i, a, g), Xp[1] = Dr(e, r, o, s, g), m = Vf(Xp, Ys), g <= 1 && m < d ? (h = g, d = m) : f *= 0.5);
  return c && (c[0] = Dr(n, t, i, a, h), c[1] = Dr(e, r, o, s, h)), _c(d);
}
function ywt(n, e, t, r, i, o, a, s, l) {
  for (var u = n, c = e, h = 0, f = 1 / l, d = 1; d <= l; d++) {
    var p = d * f, g = Dr(n, t, i, a, p), v = Dr(e, r, o, s, p), m = g - u, y = v - c;
    h += Math.sqrt(m * m + y * y), u = g, c = v;
  }
  return h;
}
function jr(n, e, t, r) {
  var i = 1 - r;
  return i * (i * n + 2 * r * e) + r * r * t;
}
function yM(n, e, t, r) {
  return 2 * ((1 - r) * (e - n) + r * (t - e));
}
function bwt(n, e, t, r, i) {
  var o = n - 2 * e + t, a = 2 * (e - n), s = n - r, l = 0;
  if (gc(o)) {
    if (uJ(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (gc(c)) {
      var u = -a / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u);
    } else if (c > 0) {
      var h = _c(c), u = (-a + h) / (2 * o), f = (-a - h) / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
    }
  }
  return l;
}
function fJ(n, e, t) {
  var r = n + t - 2 * e;
  return r === 0 ? 0.5 : (n - e) / r;
}
function D0(n, e, t, r, i) {
  var o = (e - n) * r + n, a = (t - e) * r + e, s = (a - o) * r + o;
  i[0] = n, i[1] = o, i[2] = s, i[3] = s, i[4] = a, i[5] = t;
}
function dJ(n, e, t, r, i, o, a, s, l) {
  var u, c = 5e-3, h = 1 / 0;
  Ys[0] = a, Ys[1] = s;
  for (var f = 0; f < 1; f += 0.05) {
    da[0] = jr(n, t, i, f), da[1] = jr(e, r, o, f);
    var d = Vf(Ys, da);
    d < h && (u = f, h = d);
  }
  h = 1 / 0;
  for (var p = 0; p < 32 && !(c < lJ); p++) {
    var g = u - c, v = u + c;
    da[0] = jr(n, t, i, g), da[1] = jr(e, r, o, g);
    var d = Vf(da, Ys);
    if (g >= 0 && d < h)
      u = g, h = d;
    else {
      Xp[0] = jr(n, t, i, v), Xp[1] = jr(e, r, o, v);
      var m = Vf(Xp, Ys);
      v <= 1 && m < h ? (u = v, h = m) : c *= 0.5;
    }
  }
  return l && (l[0] = jr(n, t, i, u), l[1] = jr(e, r, o, u)), _c(h);
}
function Owt(n, e, t, r, i, o, a) {
  for (var s = n, l = e, u = 0, c = 1 / a, h = 1; h <= a; h++) {
    var f = h * c, d = jr(n, t, i, f), p = jr(e, r, o, f), g = d - s, v = p - l;
    u += Math.sqrt(g * g + v * v), s = d, l = p;
  }
  return u;
}
var wwt = /cubic-bezier\(([0-9,\.e ]+)\)/;
function kR(n) {
  var e = n && wwt.exec(n);
  if (e) {
    var t = e[1].split(","), r = +is(t[0]), i = +is(t[1]), o = +is(t[2]), a = +is(t[3]);
    if (isNaN(r + i + o + a))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : uS(0, r, o, 1, l, s) && Dr(0, i, a, 1, s[0]);
    };
  }
}
var xwt = function() {
  function n(e) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || !1, this.onframe = e.onframe || nr, this.ondestroy = e.ondestroy || nr, this.onrestart = e.onrestart || nr, e.easing && this.setEasing(e.easing);
  }
  return n.prototype.step = function(e, t) {
    if (this._inited || (this._startTime = e + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += t;
      return;
    }
    var r = this._life, i = e - this._startTime - this._pausedTime, o = i / r;
    o < 0 && (o = 0), o = Math.min(o, 1);
    var a = this.easingFunc, s = a ? a(o) : o;
    if (this.onframe(s), o === 1)
      if (this.loop) {
        var l = i % r;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, n.prototype.pause = function() {
    this._paused = !0;
  }, n.prototype.resume = function() {
    this._paused = !1;
  }, n.prototype.setEasing = function(e) {
    this.easing = e, this.easingFunc = Le(e) ? e : Ey[e] || kR(e);
  }, n;
}();
const Swt = xwt;
var pJ = /* @__PURE__ */ function() {
  function n(e) {
    this.value = e;
  }
  return n;
}(), _wt = function() {
  function n() {
    this._len = 0;
  }
  return n.prototype.insert = function(e) {
    var t = new pJ(e);
    return this.insertEntry(t), t;
  }, n.prototype.insertEntry = function(e) {
    this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
  }, n.prototype.remove = function(e) {
    var t = e.prev, r = e.next;
    t ? t.next = r : this.head = r, r ? r.prev = t : this.tail = t, e.next = e.prev = null, this._len--;
  }, n.prototype.len = function() {
    return this._len;
  }, n.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, n;
}(), Nb = function() {
  function n(e) {
    this._list = new _wt(), this._maxSize = 10, this._map = {}, this._maxSize = e;
  }
  return n.prototype.put = function(e, t) {
    var r = this._list, i = this._map, o = null;
    if (i[e] == null) {
      var a = r.len(), s = this._lastRemovedEntry;
      if (a >= this._maxSize && a > 0) {
        var l = r.head;
        r.remove(l), delete i[l.key], o = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = t : s = new pJ(t), s.key = e, r.insertEntry(s), i[e] = s;
    }
    return o;
  }, n.prototype.get = function(e) {
    var t = this._map[e], r = this._list;
    if (t != null)
      return t !== r.tail && (r.remove(t), r.insertEntry(t)), t.value;
  }, n.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, n.prototype.len = function() {
    return this._list.len();
  }, n;
}(), Lz = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function us(n) {
  return n = Math.round(n), n < 0 ? 0 : n > 255 ? 255 : n;
}
function Cwt(n) {
  return n = Math.round(n), n < 0 ? 0 : n > 360 ? 360 : n;
}
function L0(n) {
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function _A(n) {
  var e = n;
  return e.length && e.charAt(e.length - 1) === "%" ? us(parseFloat(e) / 100 * 255) : us(parseInt(e, 10));
}
function zf(n) {
  var e = n;
  return e.length && e.charAt(e.length - 1) === "%" ? L0(parseFloat(e) / 100) : L0(parseFloat(e));
}
function CA(n, e, t) {
  return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? n + (e - n) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function vc(n, e, t) {
  return n + (e - n) * t;
}
function oa(n, e, t, r, i) {
  return n[0] = e, n[1] = t, n[2] = r, n[3] = i, n;
}
function bM(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n;
}
var gJ = new Nb(20), rO = null;
function Xd(n, e) {
  rO && bM(rO, e), rO = gJ.put(n, rO || e.slice());
}
function qo(n, e) {
  if (n) {
    e = e || [];
    var t = gJ.get(n);
    if (t)
      return bM(e, t);
    n = n + "";
    var r = n.replace(/ /g, "").toLowerCase();
    if (r in Lz)
      return bM(e, Lz[r]), Xd(n, e), e;
    var i = r.length;
    if (r.charAt(0) === "#") {
      if (i === 4 || i === 5) {
        var o = parseInt(r.slice(1, 4), 16);
        if (!(o >= 0 && o <= 4095)) {
          oa(e, 0, 0, 0, 1);
          return;
        }
        return oa(e, (o & 3840) >> 4 | (o & 3840) >> 8, o & 240 | (o & 240) >> 4, o & 15 | (o & 15) << 4, i === 5 ? parseInt(r.slice(4), 16) / 15 : 1), Xd(n, e), e;
      } else if (i === 7 || i === 9) {
        var o = parseInt(r.slice(1, 7), 16);
        if (!(o >= 0 && o <= 16777215)) {
          oa(e, 0, 0, 0, 1);
          return;
        }
        return oa(e, (o & 16711680) >> 16, (o & 65280) >> 8, o & 255, i === 9 ? parseInt(r.slice(7), 16) / 255 : 1), Xd(n, e), e;
      }
      return;
    }
    var a = r.indexOf("("), s = r.indexOf(")");
    if (a !== -1 && s + 1 === i) {
      var l = r.substr(0, a), u = r.substr(a + 1, s - (a + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? oa(e, +u[0], +u[1], +u[2], 1) : oa(e, 0, 0, 0, 1);
          c = zf(u.pop());
        case "rgb":
          if (u.length >= 3)
            return oa(e, _A(u[0]), _A(u[1]), _A(u[2]), u.length === 3 ? c : zf(u[3])), Xd(n, e), e;
          oa(e, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            oa(e, 0, 0, 0, 1);
            return;
          }
          return u[3] = zf(u[3]), OM(u, e), Xd(n, e), e;
        case "hsl":
          if (u.length !== 3) {
            oa(e, 0, 0, 0, 1);
            return;
          }
          return OM(u, e), Xd(n, e), e;
        default:
          return;
      }
    }
    oa(e, 0, 0, 0, 1);
  }
}
function OM(n, e) {
  var t = (parseFloat(n[0]) % 360 + 360) % 360 / 360, r = zf(n[1]), i = zf(n[2]), o = i <= 0.5 ? i * (r + 1) : i + r - i * r, a = i * 2 - o;
  return e = e || [], oa(e, us(CA(a, o, t + 1 / 3) * 255), us(CA(a, o, t) * 255), us(CA(a, o, t - 1 / 3) * 255), 1), n.length === 4 && (e[3] = n[3]), e;
}
function Awt(n) {
  if (n) {
    var e = n[0] / 255, t = n[1] / 255, r = n[2] / 255, i = Math.min(e, t, r), o = Math.max(e, t, r), a = o - i, s = (o + i) / 2, l, u;
    if (a === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = a / (o + i) : u = a / (2 - o - i);
      var c = ((o - e) / 6 + a / 2) / a, h = ((o - t) / 6 + a / 2) / a, f = ((o - r) / 6 + a / 2) / a;
      e === o ? l = f - h : t === o ? l = 1 / 3 + c - f : r === o && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var d = [l * 360, u, s];
    return n[3] != null && d.push(n[3]), d;
  }
}
function wM(n, e) {
  var t = qo(n);
  if (t) {
    for (var r = 0; r < 3; r++)
      e < 0 ? t[r] = t[r] * (1 - e) | 0 : t[r] = (255 - t[r]) * e + t[r] | 0, t[r] > 255 ? t[r] = 255 : t[r] < 0 && (t[r] = 0);
    return tu(t, t.length === 4 ? "rgba" : "rgb");
  }
}
function AA(n, e, t) {
  if (!(!(e && e.length) || !(n >= 0 && n <= 1))) {
    t = t || [];
    var r = n * (e.length - 1), i = Math.floor(r), o = Math.ceil(r), a = e[i], s = e[o], l = r - i;
    return t[0] = us(vc(a[0], s[0], l)), t[1] = us(vc(a[1], s[1], l)), t[2] = us(vc(a[2], s[2], l)), t[3] = L0(vc(a[3], s[3], l)), t;
  }
}
function Twt(n, e, t) {
  if (!(!(e && e.length) || !(n >= 0 && n <= 1))) {
    var r = n * (e.length - 1), i = Math.floor(r), o = Math.ceil(r), a = qo(e[i]), s = qo(e[o]), l = r - i, u = tu([
      us(vc(a[0], s[0], l)),
      us(vc(a[1], s[1], l)),
      us(vc(a[2], s[2], l)),
      L0(vc(a[3], s[3], l))
    ], "rgba");
    return t ? {
      color: u,
      leftIndex: i,
      rightIndex: o,
      value: r
    } : u;
  }
}
function My(n, e, t, r) {
  var i = qo(n);
  if (n)
    return i = Awt(i), e != null && (i[0] = Cwt(e)), t != null && (i[1] = zf(t)), r != null && (i[2] = zf(r)), tu(OM(i), "rgba");
}
function cS(n, e) {
  var t = qo(n);
  if (t && e != null)
    return t[3] = L0(e), tu(t, "rgba");
}
function tu(n, e) {
  if (!(!n || !n.length)) {
    var t = n[0] + "," + n[1] + "," + n[2];
    return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + n[3]), e + "(" + t + ")";
  }
}
function hS(n, e) {
  var t = qo(n);
  return t ? (0.299 * t[0] + 0.587 * t[1] + 0.114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0;
}
var Iz = new Nb(100);
function xM(n) {
  if (we(n)) {
    var e = Iz.get(n);
    return e || (e = wM(n, -0.1), Iz.put(n, e)), e;
  } else if (fC(n)) {
    var t = re({}, n);
    return t.colorStops = le(n.colorStops, function(r) {
      return {
        offset: r.offset,
        color: wM(r.color, -0.1)
      };
    }), t;
  }
  return n;
}
var fS = Math.round;
function I0(n) {
  var e;
  if (!n || n === "transparent")
    n = "none";
  else if (typeof n == "string" && n.indexOf("rgba") > -1) {
    var t = qo(n);
    t && (n = "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")", e = t[3]);
  }
  return {
    color: n,
    opacity: e ?? 1
  };
}
var Rz = 1e-4;
function mc(n) {
  return n < Rz && n > -Rz;
}
function iO(n) {
  return fS(n * 1e3) / 1e3;
}
function SM(n) {
  return fS(n * 1e4) / 1e4;
}
function kwt(n) {
  return "matrix(" + iO(n[0]) + "," + iO(n[1]) + "," + iO(n[2]) + "," + iO(n[3]) + "," + SM(n[4]) + "," + SM(n[5]) + ")";
}
var Pwt = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function Ewt(n, e, t) {
  return t === "top" ? n += e / 2 : t === "bottom" && (n -= e / 2), n;
}
function Mwt(n) {
  return n && (n.shadowBlur || n.shadowOffsetX || n.shadowOffsetY);
}
function Dwt(n) {
  var e = n.style, t = n.getGlobalScale();
  return [
    e.shadowColor,
    (e.shadowBlur || 0).toFixed(2),
    (e.shadowOffsetX || 0).toFixed(2),
    (e.shadowOffsetY || 0).toFixed(2),
    t[0],
    t[1]
  ].join(",");
}
function vJ(n) {
  return n && !!n.image;
}
function Lwt(n) {
  return n && !!n.svgElement;
}
function PR(n) {
  return vJ(n) || Lwt(n);
}
function mJ(n) {
  return n.type === "linear";
}
function yJ(n) {
  return n.type === "radial";
}
function bJ(n) {
  return n && (n.type === "linear" || n.type === "radial");
}
function gC(n) {
  return "url(#" + n + ")";
}
function OJ(n) {
  var e = n.getGlobalScale(), t = Math.max(e[0], e[1]);
  return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1);
}
function wJ(n) {
  var e = n.x || 0, t = n.y || 0, r = (n.rotation || 0) * Bw, i = qe(n.scaleX, 1), o = qe(n.scaleY, 1), a = n.skewX || 0, s = n.skewY || 0, l = [];
  return (e || t) && l.push("translate(" + e + "px," + t + "px)"), r && l.push("rotate(" + r + ")"), (i !== 1 || o !== 1) && l.push("scale(" + i + "," + o + ")"), (a || s) && l.push("skew(" + fS(a * Bw) + "deg, " + fS(s * Bw) + "deg)"), l.join(" ");
}
var Iwt = function() {
  return mt.hasGlobalWindow && Le(window.btoa) ? function(n) {
    return window.btoa(unescape(encodeURIComponent(n)));
  } : typeof Buffer < "u" ? function(n) {
    return Buffer.from(n).toString("base64");
  } : function(n) {
    return process.env.NODE_ENV !== "production" && ls("Base64 isn't natively supported in the current environment."), null;
  };
}(), _M = Array.prototype.slice;
function Fl(n, e, t) {
  return (e - n) * t + n;
}
function TA(n, e, t, r) {
  for (var i = e.length, o = 0; o < i; o++)
    n[o] = Fl(e[o], t[o], r);
  return n;
}
function Rwt(n, e, t, r) {
  for (var i = e.length, o = i && e[0].length, a = 0; a < i; a++) {
    n[a] || (n[a] = []);
    for (var s = 0; s < o; s++)
      n[a][s] = Fl(e[a][s], t[a][s], r);
  }
  return n;
}
function oO(n, e, t, r) {
  for (var i = e.length, o = 0; o < i; o++)
    n[o] = e[o] + t[o] * r;
  return n;
}
function Nz(n, e, t, r) {
  for (var i = e.length, o = i && e[0].length, a = 0; a < i; a++) {
    n[a] || (n[a] = []);
    for (var s = 0; s < o; s++)
      n[a][s] = e[a][s] + t[a][s] * r;
  }
  return n;
}
function Nwt(n, e) {
  for (var t = n.length, r = e.length, i = t > r ? e : n, o = Math.min(t, r), a = i[o - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = o; s < Math.max(t, r); s++)
    i.push({
      offset: a.offset,
      color: a.color.slice()
    });
}
function $wt(n, e, t) {
  var r = n, i = e;
  if (!(!r.push || !i.push)) {
    var o = r.length, a = i.length;
    if (o !== a) {
      var s = o > a;
      if (s)
        r.length = a;
      else
        for (var l = o; l < a; l++)
          r.push(t === 1 ? i[l] : _M.call(i[l]));
    }
    for (var u = r[0] && r[0].length, l = 0; l < r.length; l++)
      if (t === 1)
        isNaN(r[l]) && (r[l] = i[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(r[l][c]) && (r[l][c] = i[l][c]);
  }
}
function Dy(n) {
  if (Ni(n)) {
    var e = n.length;
    if (Ni(n[0])) {
      for (var t = [], r = 0; r < e; r++)
        t.push(_M.call(n[r]));
      return t;
    }
    return _M.call(n);
  }
  return n;
}
function Qw(n) {
  return n[0] = Math.floor(n[0]) || 0, n[1] = Math.floor(n[1]) || 0, n[2] = Math.floor(n[2]) || 0, n[3] = n[3] == null ? 1 : n[3], "rgba(" + n.join(",") + ")";
}
function Bwt(n) {
  return Ni(n && n[0]) ? 2 : 1;
}
var aO = 0, Zw = 1, xJ = 2, qm = 3, CM = 4, AM = 5, $z = 6;
function Bz(n) {
  return n === CM || n === AM;
}
function sO(n) {
  return n === Zw || n === xJ;
}
var cm = [0, 0, 0, 0], Vwt = function() {
  function n(e) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
  }
  return n.prototype.isFinished = function() {
    return this._finished;
  }, n.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, n.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, n.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, n.prototype.addKeyframe = function(e, t, r) {
    this._needsSort = !0;
    var i = this.keyframes, o = i.length, a = !1, s = $z, l = t;
    if (Ni(t)) {
      var u = Bwt(t);
      s = u, (u === 1 && !$t(t[0]) || u === 2 && !$t(t[0][0])) && (a = !0);
    } else if ($t(t) && !cd(t))
      s = aO;
    else if (we(t))
      if (!isNaN(+t))
        s = aO;
      else {
        var c = qo(t);
        c && (l = c, s = qm);
      }
    else if (fC(t)) {
      var h = re({}, l);
      h.colorStops = le(t.colorStops, function(d) {
        return {
          offset: d.offset,
          color: qo(d.color)
        };
      }), mJ(t) ? s = CM : yJ(t) && (s = AM), l = h;
    }
    o === 0 ? this.valType = s : (s !== this.valType || s === $z) && (a = !0), this.discrete = this.discrete || a;
    var f = {
      time: e,
      value: l,
      rawValue: t,
      percent: 0
    };
    return r && (f.easing = r, f.easingFunc = Le(r) ? r : Ey[r] || kR(r)), i.push(f), f;
  }, n.prototype.prepare = function(e, t) {
    var r = this.keyframes;
    this._needsSort && r.sort(function(g, v) {
      return g.time - v.time;
    });
    for (var i = this.valType, o = r.length, a = r[o - 1], s = this.discrete, l = sO(i), u = Bz(i), c = 0; c < o; c++) {
      var h = r[c], f = h.value, d = a.value;
      h.percent = h.time / e, s || (l && c !== o - 1 ? $wt(f, d, i) : u && Nwt(f.colorStops, d.colorStops));
    }
    if (!s && i !== AM && t && this.needsAnimate() && t.needsAnimate() && i === t.valType && !t._finished) {
      this._additiveTrack = t;
      for (var p = r[0].value, c = 0; c < o; c++)
        i === aO ? r[c].additiveValue = r[c].value - p : i === qm ? r[c].additiveValue = oO([], r[c].value, p, -1) : sO(i) && (r[c].additiveValue = i === Zw ? oO([], r[c].value, p, -1) : Nz([], r[c].value, p, -1));
    }
  }, n.prototype.step = function(e, t) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var r = this._additiveTrack != null, i = r ? "additiveValue" : "value", o = this.valType, a = this.keyframes, s = a.length, l = this.propName, u = o === qm, c, h = this._lastFr, f = Math.min, d, p;
      if (s === 1)
        d = p = a[0];
      else {
        if (t < 0)
          c = 0;
        else if (t < this._lastFrP) {
          var g = f(h + 1, s - 1);
          for (c = g; c >= 0 && !(a[c].percent <= t); c--)
            ;
          c = f(c, s - 2);
        } else {
          for (c = h; c < s && !(a[c].percent > t); c++)
            ;
          c = f(c - 1, s - 2);
        }
        p = a[c + 1], d = a[c];
      }
      if (d && p) {
        this._lastFr = c, this._lastFrP = t;
        var v = p.percent - d.percent, m = v === 0 ? 1 : f((t - d.percent) / v, 1);
        p.easingFunc && (m = p.easingFunc(m));
        var y = r ? this._additiveValue : u ? cm : e[l];
        if ((sO(o) || u) && !y && (y = this._additiveValue = []), this.discrete)
          e[l] = m < 1 ? d.rawValue : p.rawValue;
        else if (sO(o))
          o === Zw ? TA(y, d[i], p[i], m) : Rwt(y, d[i], p[i], m);
        else if (Bz(o)) {
          var b = d[i], O = p[i], w = o === CM;
          e[l] = {
            type: w ? "linear" : "radial",
            x: Fl(b.x, O.x, m),
            y: Fl(b.y, O.y, m),
            colorStops: le(b.colorStops, function(S, _) {
              var C = O.colorStops[_];
              return {
                offset: Fl(S.offset, C.offset, m),
                color: Qw(TA([], S.color, C.color, m))
              };
            }),
            global: O.global
          }, w ? (e[l].x2 = Fl(b.x2, O.x2, m), e[l].y2 = Fl(b.y2, O.y2, m)) : e[l].r = Fl(b.r, O.r, m);
        } else if (u)
          TA(y, d[i], p[i], m), r || (e[l] = Qw(y));
        else {
          var x = Fl(d[i], p[i], m);
          r ? this._additiveValue = x : e[l] = x;
        }
        r && this._addToTarget(e);
      }
    }
  }, n.prototype._addToTarget = function(e) {
    var t = this.valType, r = this.propName, i = this._additiveValue;
    t === aO ? e[r] = e[r] + i : t === qm ? (qo(e[r], cm), oO(cm, cm, i, 1), e[r] = Qw(cm)) : t === Zw ? oO(e[r], e[r], i, 1) : t === xJ && Nz(e[r], e[r], i, 1);
  }, n;
}(), ER = function() {
  function n(e, t, r, i) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && i) {
      ls("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = i, this._allowDiscrete = r;
  }
  return n.prototype.getMaxTime = function() {
    return this._maxTime;
  }, n.prototype.getDelay = function() {
    return this._delay;
  }, n.prototype.getLoop = function() {
    return this._loop;
  }, n.prototype.getTarget = function() {
    return this._target;
  }, n.prototype.changeTarget = function(e) {
    this._target = e;
  }, n.prototype.when = function(e, t, r) {
    return this.whenWithKeys(e, t, Ot(t), r);
  }, n.prototype.whenWithKeys = function(e, t, r, i) {
    for (var o = this._tracks, a = 0; a < r.length; a++) {
      var s = r[a], l = o[s];
      if (!l) {
        l = o[s] = new Vwt(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var h = c.keyframes, f = h[h.length - 1];
          u = f && f.value, c.valType === qm && u && (u = Qw(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        e > 0 && l.addKeyframe(0, Dy(u), i), this._trackKeys.push(s);
      }
      l.addKeyframe(e, Dy(t[s]), i);
    }
    return this._maxTime = Math.max(this._maxTime, e), this;
  }, n.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, n.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, n.prototype.isPaused = function() {
    return !!this._paused;
  }, n.prototype.duration = function(e) {
    return this._maxTime = e, this._force = !0, this;
  }, n.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var e = this._doneCbs;
    if (e)
      for (var t = e.length, r = 0; r < t; r++)
        e[r].call(this);
  }, n.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var e = this.animation, t = this._abortedCbs;
    if (e && e.removeClip(this._clip), this._clip = null, t)
      for (var r = 0; r < t.length; r++)
        t[r].call(this);
  }, n.prototype._setTracksFinished = function() {
    for (var e = this._tracks, t = this._trackKeys, r = 0; r < t.length; r++)
      e[t[r]].setFinished();
  }, n.prototype._getAdditiveTrack = function(e) {
    var t, r = this._additiveAnimators;
    if (r)
      for (var i = 0; i < r.length; i++) {
        var o = r[i].getTrack(e);
        o && (t = o);
      }
    return t;
  }, n.prototype.start = function(e) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var t = this, r = [], i = this._maxTime || 0, o = 0; o < this._trackKeys.length; o++) {
        var a = this._trackKeys[o], s = this._tracks[a], l = this._getAdditiveTrack(a), u = s.keyframes, c = u.length;
        if (s.prepare(i, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var h = u[c - 1];
            h && (t._target[s.propName] = h.rawValue), s.setFinished();
          } else
            r.push(s);
      }
      if (r.length || this._force) {
        var f = new Swt({
          life: i,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(d) {
            t._started = 2;
            var p = t._additiveAnimators;
            if (p) {
              for (var g = !1, v = 0; v < p.length; v++)
                if (p[v]._clip) {
                  g = !0;
                  break;
                }
              g || (t._additiveAnimators = null);
            }
            for (var v = 0; v < r.length; v++)
              r[v].step(t._target, d);
            var m = t._onframeCbs;
            if (m)
              for (var v = 0; v < m.length; v++)
                m[v](t._target, d);
          },
          ondestroy: function() {
            t._doneCallback();
          }
        });
        this._clip = f, this.animation && this.animation.addClip(f), e && f.setEasing(e);
      } else
        this._doneCallback();
      return this;
    }
  }, n.prototype.stop = function(e) {
    if (this._clip) {
      var t = this._clip;
      e && t.onframe(1), this._abortedCallback();
    }
  }, n.prototype.delay = function(e) {
    return this._delay = e, this;
  }, n.prototype.during = function(e) {
    return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
  }, n.prototype.done = function(e) {
    return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
  }, n.prototype.aborted = function(e) {
    return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
  }, n.prototype.getClip = function() {
    return this._clip;
  }, n.prototype.getTrack = function(e) {
    return this._tracks[e];
  }, n.prototype.getTracks = function() {
    var e = this;
    return le(this._trackKeys, function(t) {
      return e._tracks[t];
    });
  }, n.prototype.stopTracks = function(e, t) {
    if (!e.length || !this._clip)
      return !0;
    for (var r = this._tracks, i = this._trackKeys, o = 0; o < e.length; o++) {
      var a = r[e[o]];
      a && !a.isFinished() && (t ? a.step(this._target, 1) : this._started === 1 && a.step(this._target, 0), a.setFinished());
    }
    for (var s = !0, o = 0; o < i.length; o++)
      if (!r[i[o]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, n.prototype.saveTo = function(e, t, r) {
    if (e) {
      t = t || this._trackKeys;
      for (var i = 0; i < t.length; i++) {
        var o = t[i], a = this._tracks[o];
        if (!(!a || a.isFinished())) {
          var s = a.keyframes, l = s[r ? 0 : s.length - 1];
          l && (e[o] = Dy(l.rawValue));
        }
      }
    }
  }, n.prototype.__changeFinalValue = function(e, t) {
    t = t || Ot(e);
    for (var r = 0; r < t.length; r++) {
      var i = t[r], o = this._tracks[i];
      if (o) {
        var a = o.keyframes;
        if (a.length > 1) {
          var s = a.pop();
          o.addKeyframe(s.time, e[i]), o.prepare(this._maxTime, o.getAdditiveTrack());
        }
      }
    }
  }, n;
}();
function Mp() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var zwt = function(n) {
  H(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r._running = !1, r._time = 0, r._pausedTime = 0, r._pauseStart = 0, r._paused = !1, t = t || {}, r.stage = t.stage || {}, r;
  }
  return e.prototype.addClip = function(t) {
    t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
  }, e.prototype.addAnimator = function(t) {
    t.animation = this;
    var r = t.getClip();
    r && this.addClip(r);
  }, e.prototype.removeClip = function(t) {
    if (t.animation) {
      var r = t.prev, i = t.next;
      r ? r.next = i : this._head = i, i ? i.prev = r : this._tail = r, t.next = t.prev = t.animation = null;
    }
  }, e.prototype.removeAnimator = function(t) {
    var r = t.getClip();
    r && this.removeClip(r), t.animation = null;
  }, e.prototype.update = function(t) {
    for (var r = Mp() - this._pausedTime, i = r - this._time, o = this._head; o; ) {
      var a = o.next, s = o.step(r, i);
      s && (o.ondestroy(), this.removeClip(o)), o = a;
    }
    this._time = r, t || (this.trigger("frame", i), this.stage.update && this.stage.update());
  }, e.prototype._startLoop = function() {
    var t = this;
    this._running = !0;
    function r() {
      t._running && (mM(r), !t._paused && t.update());
    }
    mM(r);
  }, e.prototype.start = function() {
    this._running || (this._time = Mp(), this._pausedTime = 0, this._startLoop());
  }, e.prototype.stop = function() {
    this._running = !1;
  }, e.prototype.pause = function() {
    this._paused || (this._pauseStart = Mp(), this._paused = !0);
  }, e.prototype.resume = function() {
    this._paused && (this._pausedTime += Mp() - this._pauseStart, this._paused = !1);
  }, e.prototype.clear = function() {
    for (var t = this._head; t; ) {
      var r = t.next;
      t.prev = t.next = t.animation = null, t = r;
    }
    this._head = this._tail = null;
  }, e.prototype.isFinished = function() {
    return this._head == null;
  }, e.prototype.animate = function(t, r) {
    r = r || {}, this.start();
    var i = new ER(t, r.loop);
    return this.addAnimator(i), i;
  }, e;
}(Ba), Fwt = 300, kA = mt.domSupported, PA = function() {
  var n = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], e = [
    "touchstart",
    "touchend",
    "touchmove"
  ], t = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, r = le(n, function(i) {
    var o = i.replace("mouse", "pointer");
    return t.hasOwnProperty(o) ? o : i;
  });
  return {
    mouse: n,
    touch: e,
    pointer: r
  };
}(), Vz = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, zz = !1;
function TM(n) {
  var e = n.pointerType;
  return e === "pen" || e === "touch";
}
function Qwt(n) {
  n.touching = !0, n.touchTimer != null && (clearTimeout(n.touchTimer), n.touchTimer = null), n.touchTimer = setTimeout(function() {
    n.touching = !1, n.touchTimer = null;
  }, 700);
}
function EA(n) {
  n && (n.zrByTouch = !0);
}
function Zwt(n, e) {
  return sa(n.dom, new Wwt(n, e), !0);
}
function SJ(n, e) {
  for (var t = e, r = !1; t && t.nodeType !== 9 && !(r = t.domBelongToZr || t !== e && t === n.painterRoot); )
    t = t.parentNode;
  return r;
}
var Wwt = /* @__PURE__ */ function() {
  function n(e, t) {
    this.stopPropagation = nr, this.stopImmediatePropagation = nr, this.preventDefault = nr, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY;
  }
  return n;
}(), ja = {
  mousedown: function(n) {
    n = sa(this.dom, n), this.__mayPointerCapture = [n.zrX, n.zrY], this.trigger("mousedown", n);
  },
  mousemove: function(n) {
    n = sa(this.dom, n);
    var e = this.__mayPointerCapture;
    e && (n.zrX !== e[0] || n.zrY !== e[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", n);
  },
  mouseup: function(n) {
    n = sa(this.dom, n), this.__togglePointerCapture(!1), this.trigger("mouseup", n);
  },
  mouseout: function(n) {
    n = sa(this.dom, n);
    var e = n.toElement || n.relatedTarget;
    SJ(this, e) || (this.__pointerCapturing && (n.zrEventControl = "no_globalout"), this.trigger("mouseout", n));
  },
  wheel: function(n) {
    zz = !0, n = sa(this.dom, n), this.trigger("mousewheel", n);
  },
  mousewheel: function(n) {
    zz || (n = sa(this.dom, n), this.trigger("mousewheel", n));
  },
  touchstart: function(n) {
    n = sa(this.dom, n), EA(n), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(n, "start"), ja.mousemove.call(this, n), ja.mousedown.call(this, n);
  },
  touchmove: function(n) {
    n = sa(this.dom, n), EA(n), this.handler.processGesture(n, "change"), ja.mousemove.call(this, n);
  },
  touchend: function(n) {
    n = sa(this.dom, n), EA(n), this.handler.processGesture(n, "end"), ja.mouseup.call(this, n), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < Fwt && ja.click.call(this, n);
  },
  pointerdown: function(n) {
    ja.mousedown.call(this, n);
  },
  pointermove: function(n) {
    TM(n) || ja.mousemove.call(this, n);
  },
  pointerup: function(n) {
    ja.mouseup.call(this, n);
  },
  pointerout: function(n) {
    TM(n) || ja.mouseout.call(this, n);
  }
};
I(["click", "dblclick", "contextmenu"], function(n) {
  ja[n] = function(e) {
    e = sa(this.dom, e), this.trigger(n, e);
  };
});
var kM = {
  pointermove: function(n) {
    TM(n) || kM.mousemove.call(this, n);
  },
  pointerup: function(n) {
    kM.mouseup.call(this, n);
  },
  mousemove: function(n) {
    this.trigger("mousemove", n);
  },
  mouseup: function(n) {
    var e = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", n), e && (n.zrEventControl = "only_globalout", this.trigger("mouseout", n));
  }
};
function Gwt(n, e) {
  var t = e.domHandlers;
  mt.pointerEventsSupported ? I(PA.pointer, function(r) {
    Ww(e, r, function(i) {
      t[r].call(n, i);
    });
  }) : (mt.touchEventsSupported && I(PA.touch, function(r) {
    Ww(e, r, function(i) {
      t[r].call(n, i), Qwt(e);
    });
  }), I(PA.mouse, function(r) {
    Ww(e, r, function(i) {
      i = CR(i), e.touching || t[r].call(n, i);
    });
  }));
}
function jwt(n, e) {
  mt.pointerEventsSupported ? I(Vz.pointer, t) : mt.touchEventsSupported || I(Vz.mouse, t);
  function t(r) {
    function i(o) {
      o = CR(o), SJ(n, o.target) || (o = Zwt(n, o), e.domHandlers[r].call(n, o));
    }
    Ww(e, r, i, { capture: !0 });
  }
}
function Ww(n, e, t, r) {
  n.mounted[e] = t, n.listenerOpts[e] = r, vM(n.domTarget, e, t, r);
}
function MA(n) {
  var e = n.mounted;
  for (var t in e)
    e.hasOwnProperty(t) && rwt(n.domTarget, t, e[t], n.listenerOpts[t]);
  n.mounted = {};
}
var Fz = /* @__PURE__ */ function() {
  function n(e, t) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = e, this.domHandlers = t;
  }
  return n;
}(), Hwt = function(n) {
  H(e, n);
  function e(t, r) {
    var i = n.call(this) || this;
    return i.__pointerCapturing = !1, i.dom = t, i.painterRoot = r, i._localHandlerScope = new Fz(t, ja), kA && (i._globalHandlerScope = new Fz(document, kM)), Gwt(i, i._localHandlerScope), i;
  }
  return e.prototype.dispose = function() {
    MA(this._localHandlerScope), kA && MA(this._globalHandlerScope);
  }, e.prototype.setCursor = function(t) {
    this.dom.style && (this.dom.style.cursor = t || "default");
  }, e.prototype.__togglePointerCapture = function(t) {
    if (this.__mayPointerCapture = null, kA && +this.__pointerCapturing ^ +t) {
      this.__pointerCapturing = t;
      var r = this._globalHandlerScope;
      t ? jwt(this, r) : MA(r);
    }
  }, e;
}(Ba);
const qwt = Hwt;
var _J = 1;
mt.hasGlobalWindow && (_J = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var dS = _J, PM = 0.4, EM = "#333", MM = "#ccc", Ywt = "#eee", Qz = pC, Zz = 5e-5;
function Ch(n) {
  return n > Zz || n < -Zz;
}
var Ah = [], Ud = [], DA = Ho(), LA = Math.abs, Yl = function() {
  function n() {
  }
  return n.prototype.getLocalTransform = function(e) {
    return n.getLocalTransform(this, e);
  }, n.prototype.setPosition = function(e) {
    this.x = e[0], this.y = e[1];
  }, n.prototype.setScale = function(e) {
    this.scaleX = e[0], this.scaleY = e[1];
  }, n.prototype.setSkew = function(e) {
    this.skewX = e[0], this.skewY = e[1];
  }, n.prototype.setOrigin = function(e) {
    this.originX = e[0], this.originY = e[1];
  }, n.prototype.needLocalTransform = function() {
    return Ch(this.rotation) || Ch(this.x) || Ch(this.y) || Ch(this.scaleX - 1) || Ch(this.scaleY - 1) || Ch(this.skewX) || Ch(this.skewY);
  }, n.prototype.updateTransform = function() {
    var e = this.parent && this.parent.transform, t = this.needLocalTransform(), r = this.transform;
    if (!(t || e)) {
      r && (Qz(r), this.invTransform = null);
      return;
    }
    r = r || Ho(), t ? this.getLocalTransform(r) : Qz(r), e && (t ? eu(r, e, r) : AR(r, e)), this.transform = r, this._resolveGlobalScaleRatio(r);
  }, n.prototype._resolveGlobalScaleRatio = function(e) {
    var t = this.globalScaleRatio;
    if (t != null && t !== 1) {
      this.getGlobalScale(Ah);
      var r = Ah[0] < 0 ? -1 : 1, i = Ah[1] < 0 ? -1 : 1, o = ((Ah[0] - r) * t + r) / Ah[0] || 0, a = ((Ah[1] - i) * t + i) / Ah[1] || 0;
      e[0] *= o, e[1] *= o, e[2] *= a, e[3] *= a;
    }
    this.invTransform = this.invTransform || Ho(), Ev(this.invTransform, e);
  }, n.prototype.getComputedTransform = function() {
    for (var e = this, t = []; e; )
      t.push(e), e = e.parent;
    for (; e = t.pop(); )
      e.updateTransform();
    return this.transform;
  }, n.prototype.setLocalTransform = function(e) {
    if (e) {
      var t = e[0] * e[0] + e[1] * e[1], r = e[2] * e[2] + e[3] * e[3], i = Math.atan2(e[1], e[0]), o = Math.PI / 2 + i - Math.atan2(e[3], e[2]);
      r = Math.sqrt(r) * Math.cos(o), t = Math.sqrt(t), this.skewX = o, this.skewY = 0, this.rotation = -i, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = r, this.originX = 0, this.originY = 0;
    }
  }, n.prototype.decomposeTransform = function() {
    if (this.transform) {
      var e = this.parent, t = this.transform;
      e && e.transform && (e.invTransform = e.invTransform || Ho(), eu(Ud, e.invTransform, t), t = Ud);
      var r = this.originX, i = this.originY;
      (r || i) && (DA[4] = r, DA[5] = i, eu(Ud, t, DA), Ud[4] -= r, Ud[5] -= i, t = Ud), this.setLocalTransform(t);
    }
  }, n.prototype.getGlobalScale = function(e) {
    var t = this.transform;
    return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
  }, n.prototype.transformCoordToLocal = function(e, t) {
    var r = [e, t], i = this.invTransform;
    return i && vi(r, r, i), r;
  }, n.prototype.transformCoordToGlobal = function(e, t) {
    var r = [e, t], i = this.transform;
    return i && vi(r, r, i), r;
  }, n.prototype.getLineScale = function() {
    var e = this.transform;
    return e && LA(e[0] - 1) > 1e-10 && LA(e[3] - 1) > 1e-10 ? Math.sqrt(LA(e[0] * e[3] - e[2] * e[1])) : 1;
  }, n.prototype.copyTransform = function(e) {
    CJ(this, e);
  }, n.getLocalTransform = function(e, t) {
    t = t || [];
    var r = e.originX || 0, i = e.originY || 0, o = e.scaleX, a = e.scaleY, s = e.anchorX, l = e.anchorY, u = e.rotation || 0, c = e.x, h = e.y, f = e.skewX ? Math.tan(e.skewX) : 0, d = e.skewY ? Math.tan(-e.skewY) : 0;
    if (r || i || s || l) {
      var p = r + s, g = i + l;
      t[4] = -p * o - f * g * a, t[5] = -g * a - d * p * o;
    } else
      t[4] = t[5] = 0;
    return t[0] = o, t[3] = a, t[1] = d * o, t[2] = f * a, u && Md(t, t, u), t[4] += r + c, t[5] += i + h, t;
  }, n.initDefaultProps = function() {
    var e = n.prototype;
    e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
  }(), n;
}(), _l = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function CJ(n, e) {
  for (var t = 0; t < _l.length; t++) {
    var r = _l[t];
    n[r] = e[r];
  }
}
var Wz = {};
function Yo(n, e) {
  e = e || Gc;
  var t = Wz[e];
  t || (t = Wz[e] = new Nb(500));
  var r = t.get(n);
  return r == null && (r = jc.measureText(n, e).width, t.put(n, r)), r;
}
function Gz(n, e, t, r) {
  var i = Yo(n, e), o = vC(e), a = Ym(0, i, t), s = _p(0, o, r), l = new ot(a, s, i, o);
  return l;
}
function $b(n, e, t, r) {
  var i = ((n || "") + "").split(`
`), o = i.length;
  if (o === 1)
    return Gz(i[0], e, t, r);
  for (var a = new ot(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = Gz(i[s], e, t, r);
    s === 0 ? a.copy(l) : a.union(l);
  }
  return a;
}
function Ym(n, e, t) {
  return t === "right" ? n -= e : t === "center" && (n -= e / 2), n;
}
function _p(n, e, t) {
  return t === "middle" ? n -= e / 2 : t === "bottom" && (n -= e), n;
}
function vC(n) {
  return Yo("国", n);
}
function gs(n, e) {
  return typeof n == "string" ? n.lastIndexOf("%") >= 0 ? parseFloat(n) / 100 * e : parseFloat(n) : n;
}
function pS(n, e, t) {
  var r = e.position || "inside", i = e.distance != null ? e.distance : 5, o = t.height, a = t.width, s = o / 2, l = t.x, u = t.y, c = "left", h = "top";
  if (r instanceof Array)
    l += gs(r[0], t.width), u += gs(r[1], t.height), c = null, h = null;
  else
    switch (r) {
      case "left":
        l -= i, u += s, c = "right", h = "middle";
        break;
      case "right":
        l += i + a, u += s, h = "middle";
        break;
      case "top":
        l += a / 2, u -= i, c = "center", h = "bottom";
        break;
      case "bottom":
        l += a / 2, u += o + i, c = "center";
        break;
      case "inside":
        l += a / 2, u += s, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += i, u += s, h = "middle";
        break;
      case "insideRight":
        l += a - i, u += s, c = "right", h = "middle";
        break;
      case "insideTop":
        l += a / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += a / 2, u += o - i, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += a - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += o - i, h = "bottom";
        break;
      case "insideBottomRight":
        l += a - i, u += o - i, c = "right", h = "bottom";
        break;
    }
  return n = n || {}, n.x = l, n.y = u, n.align = c, n.verticalAlign = h, n;
}
var IA = "__zr_normal__", RA = _l.concat(["ignore"]), Xwt = xl(_l, function(n, e) {
  return n[e] = !0, n;
}, { ignore: !1 }), Kd = {}, Uwt = new ot(0, 0, 0, 0), MR = function() {
  function n(e) {
    this.id = UK(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
  }
  return n.prototype._init = function(e) {
    this.attr(e);
  }, n.prototype.drift = function(e, t, r) {
    switch (this.draggable) {
      case "horizontal":
        t = 0;
        break;
      case "vertical":
        e = 0;
        break;
    }
    var i = this.transform;
    i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += e, i[5] += t, this.decomposeTransform(), this.markRedraw();
  }, n.prototype.beforeUpdate = function() {
  }, n.prototype.afterUpdate = function() {
  }, n.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, n.prototype.updateInnerText = function(e) {
    var t = this._textContent;
    if (t && (!t.ignore || e)) {
      this.textConfig || (this.textConfig = {});
      var r = this.textConfig, i = r.local, o = t.innerTransformable, a = void 0, s = void 0, l = !1;
      o.parent = i ? this : null;
      var u = !1;
      if (o.copyTransform(t), r.position != null) {
        var c = Uwt;
        r.layoutRect ? c.copy(r.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Kd, r, c) : pS(Kd, r, c), o.x = Kd.x, o.y = Kd.y, a = Kd.align, s = Kd.verticalAlign;
        var h = r.origin;
        if (h && r.rotation != null) {
          var f = void 0, d = void 0;
          h === "center" ? (f = c.width * 0.5, d = c.height * 0.5) : (f = gs(h[0], c.width), d = gs(h[1], c.height)), u = !0, o.originX = -o.x + f + (i ? 0 : c.x), o.originY = -o.y + d + (i ? 0 : c.y);
        }
      }
      r.rotation != null && (o.rotation = r.rotation);
      var p = r.offset;
      p && (o.x += p[0], o.y += p[1], u || (o.originX = -p[0], o.originY = -p[1]));
      var g = r.inside == null ? typeof r.position == "string" && r.position.indexOf("inside") >= 0 : r.inside, v = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), m = void 0, y = void 0, b = void 0;
      g && this.canBeInsideText() ? (m = r.insideFill, y = r.insideStroke, (m == null || m === "auto") && (m = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(m), b = !0)) : (m = r.outsideFill, y = r.outsideStroke, (m == null || m === "auto") && (m = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(m), b = !0)), m = m || "#000", (m !== v.fill || y !== v.stroke || b !== v.autoStroke || a !== v.align || s !== v.verticalAlign) && (l = !0, v.fill = m, v.stroke = y, v.autoStroke = b, v.align = a, v.verticalAlign = s, t.setDefaultTextStyle(v)), t.__dirty |= Zo, l && t.dirtyStyle(!0);
    }
  }, n.prototype.canBeInsideText = function() {
    return !0;
  }, n.prototype.getInsideTextFill = function() {
    return "#fff";
  }, n.prototype.getInsideTextStroke = function(e) {
    return "#000";
  }, n.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? MM : EM;
  }, n.prototype.getOutsideStroke = function(e) {
    var t = this.__zr && this.__zr.getBackgroundColor(), r = typeof t == "string" && qo(t);
    r || (r = [255, 255, 255, 1]);
    for (var i = r[3], o = this.__zr.isDarkMode(), a = 0; a < 3; a++)
      r[a] = r[a] * i + (o ? 0 : 255) * (1 - i);
    return r[3] = 1, tu(r, "rgba");
  }, n.prototype.traverse = function(e, t) {
  }, n.prototype.attrKV = function(e, t) {
    e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, re(this.extra, t)) : this[e] = t;
  }, n.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, n.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, n.prototype.attr = function(e, t) {
    if (typeof e == "string")
      this.attrKV(e, t);
    else if (Ne(e))
      for (var r = e, i = Ot(r), o = 0; o < i.length; o++) {
        var a = i[o];
        this.attrKV(a, e[a]);
      }
    return this.markRedraw(), this;
  }, n.prototype.saveCurrentToNormalState = function(e) {
    this._innerSaveToNormal(e);
    for (var t = this._normalState, r = 0; r < this.animators.length; r++) {
      var i = this.animators[r], o = i.__fromStateTransition;
      if (!(i.getLoop() || o && o !== IA)) {
        var a = i.targetName, s = a ? t[a] : t;
        i.saveTo(s);
      }
    }
  }, n.prototype._innerSaveToNormal = function(e) {
    var t = this._normalState;
    t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, RA);
  }, n.prototype._savePrimaryToNormal = function(e, t, r) {
    for (var i = 0; i < r.length; i++) {
      var o = r[i];
      e[o] != null && !(o in t) && (t[o] = this[o]);
    }
  }, n.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, n.prototype.getState = function(e) {
    return this.states[e];
  }, n.prototype.ensureState = function(e) {
    var t = this.states;
    return t[e] || (t[e] = {}), t[e];
  }, n.prototype.clearStates = function(e) {
    this.useState(IA, !1, e);
  }, n.prototype.useState = function(e, t, r, i) {
    var o = e === IA, a = this.hasState();
    if (!(!a && o)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(ct(s, e) >= 0 && (t || s.length === 1))) {
        var u;
        if (this.stateProxy && !o && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !o) {
          ls("State " + e + " not exists.");
          return;
        }
        o || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || i);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(e, u, this._normalState, t, !r && !this.__inHover && l && l.duration > 0, l);
        var h = this._textContent, f = this._textGuide;
        return h && h.useState(e, t, r, c), f && f.useState(e, t, r, c), o ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [e], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Zo), u;
      }
    }
  }, n.prototype.useStates = function(e, t, r) {
    if (!e.length)
      this.clearStates();
    else {
      var i = [], o = this.currentStates, a = e.length, s = a === o.length;
      if (s) {
        for (var l = 0; l < a; l++)
          if (e[l] !== o[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < a; l++) {
        var u = e[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, e)), c || (c = this.states[u]), c && i.push(c);
      }
      var h = i[a - 1], f = !!(h && h.hoverLayer || r);
      f && this._toggleHoverLayerFlag(!0);
      var d = this._mergeStates(i), p = this.stateTransition;
      this.saveCurrentToNormalState(d), this._applyStateObj(e.join(","), d, this._normalState, !1, !t && !this.__inHover && p && p.duration > 0, p);
      var g = this._textContent, v = this._textGuide;
      g && g.useStates(e, t, f), v && v.useStates(e, t, f), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Zo);
    }
  }, n.prototype.isSilent = function() {
    for (var e = this.silent, t = this.parent; !e && t; ) {
      if (t.silent) {
        e = !0;
        break;
      }
      t = t.parent;
    }
    return e;
  }, n.prototype._updateAnimationTargets = function() {
    for (var e = 0; e < this.animators.length; e++) {
      var t = this.animators[e];
      t.targetName && t.changeTarget(this[t.targetName]);
    }
  }, n.prototype.removeState = function(e) {
    var t = ct(this.currentStates, e);
    if (t >= 0) {
      var r = this.currentStates.slice();
      r.splice(t, 1), this.useStates(r);
    }
  }, n.prototype.replaceState = function(e, t, r) {
    var i = this.currentStates.slice(), o = ct(i, e), a = ct(i, t) >= 0;
    o >= 0 ? a ? i.splice(o, 1) : i[o] = t : r && !a && i.push(t), this.useStates(i);
  }, n.prototype.toggleState = function(e, t) {
    t ? this.useState(e, !0) : this.removeState(e);
  }, n.prototype._mergeStates = function(e) {
    for (var t = {}, r, i = 0; i < e.length; i++) {
      var o = e[i];
      re(t, o), o.textConfig && (r = r || {}, re(r, o.textConfig));
    }
    return r && (t.textConfig = r), t;
  }, n.prototype._applyStateObj = function(e, t, r, i, o, a) {
    var s = !(t && i);
    t && t.textConfig ? (this.textConfig = re({}, i ? this.textConfig : r.textConfig), re(this.textConfig, t.textConfig)) : s && r.textConfig && (this.textConfig = r.textConfig);
    for (var l = {}, u = !1, c = 0; c < RA.length; c++) {
      var h = RA[c], f = o && Xwt[h];
      t && t[h] != null ? f ? (u = !0, l[h] = t[h]) : this[h] = t[h] : s && r[h] != null && (f ? (u = !0, l[h] = r[h]) : this[h] = r[h]);
    }
    if (!o)
      for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (t || r)[p] : t || r);
      }
    u && this._transitionState(e, l, a);
  }, n.prototype._attachComponent = function(e) {
    if (e.__zr && !e.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (e === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var t = this.__zr;
    t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this;
  }, n.prototype._detachComponent = function(e) {
    e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
  }, n.prototype.getClipPath = function() {
    return this._clipPath;
  }, n.prototype.setClipPath = function(e) {
    this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
  }, n.prototype.removeClipPath = function() {
    var e = this._clipPath;
    e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
  }, n.prototype.getTextContent = function() {
    return this._textContent;
  }, n.prototype.setTextContent = function(e) {
    var t = this._textContent;
    if (t !== e) {
      if (t && t !== e && this.removeTextContent(), process.env.NODE_ENV !== "production" && e.__zr && !e.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      e.innerTransformable = new Yl(), this._attachComponent(e), this._textContent = e, this.markRedraw();
    }
  }, n.prototype.setTextConfig = function(e) {
    this.textConfig || (this.textConfig = {}), re(this.textConfig, e), this.markRedraw();
  }, n.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, n.prototype.removeTextContent = function() {
    var e = this._textContent;
    e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, n.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, n.prototype.setTextGuideLine = function(e) {
    this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
  }, n.prototype.removeTextGuideLine = function() {
    var e = this._textGuide;
    e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
  }, n.prototype.markRedraw = function() {
    this.__dirty |= Zo;
    var e = this.__zr;
    e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, n.prototype.dirty = function() {
    this.markRedraw();
  }, n.prototype._toggleHoverLayerFlag = function(e) {
    this.__inHover = e;
    var t = this._textContent, r = this._textGuide;
    t && (t.__inHover = e), r && (r.__inHover = e);
  }, n.prototype.addSelfToZr = function(e) {
    if (this.__zr !== e) {
      this.__zr = e;
      var t = this.animators;
      if (t)
        for (var r = 0; r < t.length; r++)
          e.animation.addAnimator(t[r]);
      this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
    }
  }, n.prototype.removeSelfFromZr = function(e) {
    if (this.__zr) {
      this.__zr = null;
      var t = this.animators;
      if (t)
        for (var r = 0; r < t.length; r++)
          e.animation.removeAnimator(t[r]);
      this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
    }
  }, n.prototype.animate = function(e, t, r) {
    var i = e ? this[e] : this;
    if (process.env.NODE_ENV !== "production" && !i) {
      ls('Property "' + e + '" is not existed in element ' + this.id);
      return;
    }
    var o = new ER(i, t, r);
    return e && (o.targetName = e), this.addAnimator(o, e), o;
  }, n.prototype.addAnimator = function(e, t) {
    var r = this.__zr, i = this;
    e.during(function() {
      i.updateDuringAnimation(t);
    }).done(function() {
      var o = i.animators, a = ct(o, e);
      a >= 0 && o.splice(a, 1);
    }), this.animators.push(e), r && r.animation.addAnimator(e), r && r.wakeUp();
  }, n.prototype.updateDuringAnimation = function(e) {
    this.markRedraw();
  }, n.prototype.stopAnimation = function(e, t) {
    for (var r = this.animators, i = r.length, o = [], a = 0; a < i; a++) {
      var s = r[a];
      !e || e === s.scope ? s.stop(t) : o.push(s);
    }
    return this.animators = o, this;
  }, n.prototype.animateTo = function(e, t, r) {
    NA(this, e, t, r);
  }, n.prototype.animateFrom = function(e, t, r) {
    NA(this, e, t, r, !0);
  }, n.prototype._transitionState = function(e, t, r, i) {
    for (var o = NA(this, t, r, i), a = 0; a < o.length; a++)
      o[a].__fromStateTransition = e;
  }, n.prototype.getBoundingRect = function() {
    return null;
  }, n.prototype.getPaintRect = function() {
    return null;
  }, n.initDefaultProps = function() {
    var e = n.prototype;
    e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = !1, e.__dirty = Zo;
    var t = {};
    function r(o, a, s) {
      t[o + a + s] || (console.warn("DEPRECATED: '" + o + "' has been deprecated. use '" + a + "', '" + s + "' instead"), t[o + a + s] = !0);
    }
    function i(o, a, s, l) {
      Object.defineProperty(e, o, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && r(o, s, l), !this[a]) {
            var c = this[a] = [];
            u(this, c);
          }
          return this[a];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && r(o, s, l), this[s] = c[0], this[l] = c[1], this[a] = c, u(this, c);
        }
      });
      function u(c, h) {
        Object.defineProperty(h, 0, {
          get: function() {
            return c[s];
          },
          set: function(f) {
            c[s] = f;
          }
        }), Object.defineProperty(h, 1, {
          get: function() {
            return c[l];
          },
          set: function(f) {
            c[l] = f;
          }
        });
      }
    }
    Object.defineProperty && (i("position", "_legacyPos", "x", "y"), i("scale", "_legacyScale", "scaleX", "scaleY"), i("origin", "_legacyOrigin", "originX", "originY"));
  }(), n;
}();
mr(MR, Ba);
mr(MR, Yl);
function NA(n, e, t, r, i) {
  t = t || {};
  var o = [];
  AJ(n, "", n, e, t, r, o, i);
  var a = o.length, s = !1, l = t.done, u = t.aborted, c = function() {
    s = !0, a--, a <= 0 && (s ? l && l() : u && u());
  }, h = function() {
    a--, a <= 0 && (s ? l && l() : u && u());
  };
  a || l && l(), o.length > 0 && t.during && o[0].during(function(p, g) {
    t.during(g);
  });
  for (var f = 0; f < o.length; f++) {
    var d = o[f];
    c && d.done(c), h && d.aborted(h), t.force && d.duration(t.duration), d.start(t.easing);
  }
  return o;
}
function $A(n, e, t) {
  for (var r = 0; r < t; r++)
    n[r] = e[r];
}
function Kwt(n) {
  return Ni(n[0]);
}
function Jwt(n, e, t) {
  if (Ni(e[t]))
    if (Ni(n[t]) || (n[t] = []), eo(e[t])) {
      var r = e[t].length;
      n[t].length !== r && (n[t] = new e[t].constructor(r), $A(n[t], e[t], r));
    } else {
      var i = e[t], o = n[t], a = i.length;
      if (Kwt(i))
        for (var s = i[0].length, l = 0; l < a; l++)
          o[l] ? $A(o[l], i[l], s) : o[l] = Array.prototype.slice.call(i[l]);
      else
        $A(o, i, a);
      o.length = i.length;
    }
  else
    n[t] = e[t];
}
function ext(n, e) {
  return n === e || Ni(n) && Ni(e) && txt(n, e);
}
function txt(n, e) {
  var t = n.length;
  if (t !== e.length)
    return !1;
  for (var r = 0; r < t; r++)
    if (n[r] !== e[r])
      return !1;
  return !0;
}
function AJ(n, e, t, r, i, o, a, s) {
  for (var l = Ot(r), u = i.duration, c = i.delay, h = i.additive, f = i.setToFinal, d = !Ne(o), p = n.animators, g = [], v = 0; v < l.length; v++) {
    var m = l[v], y = r[m];
    if (y != null && t[m] != null && (d || o[m]))
      if (Ne(y) && !Ni(y) && !fC(y)) {
        if (e) {
          s || (t[m] = y, n.updateDuringAnimation(e));
          continue;
        }
        AJ(n, m, t[m], y, i, o && o[m], a, s);
      } else
        g.push(m);
    else
      s || (t[m] = y, n.updateDuringAnimation(e), g.push(m));
  }
  var b = g.length;
  if (!h && b)
    for (var O = 0; O < p.length; O++) {
      var w = p[O];
      if (w.targetName === e) {
        var x = w.stopTracks(g);
        if (x) {
          var S = ct(p, w);
          p.splice(S, 1);
        }
      }
    }
  if (i.force || (g = en(g, function(k) {
    return !ext(r[k], t[k]);
  }), b = g.length), b > 0 || i.force && !a.length) {
    var _ = void 0, C = void 0, A = void 0;
    if (s) {
      C = {}, f && (_ = {});
      for (var O = 0; O < b; O++) {
        var m = g[O];
        C[m] = t[m], f ? _[m] = r[m] : t[m] = r[m];
      }
    } else if (f) {
      A = {};
      for (var O = 0; O < b; O++) {
        var m = g[O];
        A[m] = Dy(t[m]), Jwt(t, r, m);
      }
    }
    var w = new ER(t, !1, !1, h ? en(p, function(P) {
      return P.targetName === e;
    }) : null);
    w.targetName = e, i.scope && (w.scope = i.scope), f && _ && w.whenWithKeys(0, _, g), A && w.whenWithKeys(0, A, g), w.whenWithKeys(u ?? 500, s ? C : r, g).delay(c || 0), n.addAnimator(w, e), a.push(w);
  }
}
const TJ = MR;
var We = function(n) {
  H(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r.isGroup = !0, r._children = [], r.attr(t), r;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.children = function() {
    return this._children.slice();
  }, e.prototype.childAt = function(t) {
    return this._children[t];
  }, e.prototype.childOfName = function(t) {
    for (var r = this._children, i = 0; i < r.length; i++)
      if (r[i].name === t)
        return r[i];
  }, e.prototype.childCount = function() {
    return this._children.length;
  }, e.prototype.add = function(t) {
    if (t && (t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), process.env.NODE_ENV !== "production" && t.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, e.prototype.addBefore = function(t, r) {
    if (t && t !== this && t.parent !== this && r && r.parent === this) {
      var i = this._children, o = i.indexOf(r);
      o >= 0 && (i.splice(o, 0, t), this._doAdd(t));
    }
    return this;
  }, e.prototype.replace = function(t, r) {
    var i = ct(this._children, t);
    return i >= 0 && this.replaceAt(r, i), this;
  }, e.prototype.replaceAt = function(t, r) {
    var i = this._children, o = i[r];
    if (t && t !== this && t.parent !== this && t !== o) {
      i[r] = t, o.parent = null;
      var a = this.__zr;
      a && o.removeSelfFromZr(a), this._doAdd(t);
    }
    return this;
  }, e.prototype._doAdd = function(t) {
    t.parent && t.parent.remove(t), t.parent = this;
    var r = this.__zr;
    r && r !== t.__zr && t.addSelfToZr(r), r && r.refresh();
  }, e.prototype.remove = function(t) {
    var r = this.__zr, i = this._children, o = ct(i, t);
    return o < 0 ? this : (i.splice(o, 1), t.parent = null, r && t.removeSelfFromZr(r), r && r.refresh(), this);
  }, e.prototype.removeAll = function() {
    for (var t = this._children, r = this.__zr, i = 0; i < t.length; i++) {
      var o = t[i];
      r && o.removeSelfFromZr(r), o.parent = null;
    }
    return t.length = 0, this;
  }, e.prototype.eachChild = function(t, r) {
    for (var i = this._children, o = 0; o < i.length; o++) {
      var a = i[o];
      t.call(r, a, o);
    }
    return this;
  }, e.prototype.traverse = function(t, r) {
    for (var i = 0; i < this._children.length; i++) {
      var o = this._children[i], a = t.call(r, o);
      o.isGroup && !a && o.traverse(t, r);
    }
    return this;
  }, e.prototype.addSelfToZr = function(t) {
    n.prototype.addSelfToZr.call(this, t);
    for (var r = 0; r < this._children.length; r++) {
      var i = this._children[r];
      i.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    n.prototype.removeSelfFromZr.call(this, t);
    for (var r = 0; r < this._children.length; r++) {
      var i = this._children[r];
      i.removeSelfFromZr(t);
    }
  }, e.prototype.getBoundingRect = function(t) {
    for (var r = new ot(0, 0, 0, 0), i = t || this._children, o = [], a = null, s = 0; s < i.length; s++) {
      var l = i[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(o);
        c ? (ot.applyTransform(r, u, c), a = a || r.clone(), a.union(r)) : (a = a || u.clone(), a.union(u));
      }
    }
    return a || r;
  }, e;
}(TJ);
We.prototype.type = "group";
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var Xm = {}, kJ = {};
function nxt(n) {
  delete kJ[n];
}
function rxt(n) {
  if (!n)
    return !1;
  if (typeof n == "string")
    return hS(n, 1) < PM;
  if (n.colorStops) {
    for (var e = n.colorStops, t = 0, r = e.length, i = 0; i < r; i++)
      t += hS(e[i].color, 1);
    return t /= r, t < PM;
  }
  return !1;
}
var ixt = function() {
  function n(e, t, r) {
    var i = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, r = r || {}, this.dom = t, this.id = e;
    var o = new mwt(), a = r.renderer || "canvas";
    if (Xm[a] || (a = Ot(Xm)[0]), process.env.NODE_ENV !== "production" && !Xm[a])
      throw new Error("Renderer '" + a + "' is not imported. Please import it first.");
    r.useDirtyRect = r.useDirtyRect == null ? !1 : r.useDirtyRect;
    var s = new Xm[a](t, o, r, e), l = r.ssr || s.ssrOnly;
    this.storage = o, this.painter = s;
    var u = !mt.node && !mt.worker && !l ? new qwt(s.getViewportRoot(), s.root) : null, c = r.useCoarsePointer, h = c == null || c === "auto" ? mt.touchEventsSupported : !!c, f = 44, d;
    h && (d = qe(r.pointerSize, f)), this.handler = new dwt(o, s, u, s.root, d), this.animation = new zwt({
      stage: {
        update: l ? null : function() {
          return i._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return n.prototype.add = function(e) {
    this._disposed || !e || (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
  }, n.prototype.remove = function(e) {
    this._disposed || !e || (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
  }, n.prototype.configLayer = function(e, t) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(e, t), this.refresh());
  }, n.prototype.setBackgroundColor = function(e) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = rxt(e));
  }, n.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, n.prototype.setDarkMode = function(e) {
    this._darkMode = e;
  }, n.prototype.isDarkMode = function() {
    return this._darkMode;
  }, n.prototype.refreshImmediately = function(e) {
    this._disposed || (e || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, n.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, n.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, n.prototype._flush = function(e) {
    var t, r = Mp();
    this._needsRefresh && (t = !0, this.refreshImmediately(e)), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately());
    var i = Mp();
    t ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: i - r
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, n.prototype.setSleepAfterStill = function(e) {
    this._sleepAfterStill = e;
  }, n.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, n.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, n.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, n.prototype.resize = function(e) {
    this._disposed || (e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize());
  }, n.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, n.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, n.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, n.prototype.setCursorStyle = function(e) {
    this._disposed || this.handler.setCursorStyle(e);
  }, n.prototype.findHover = function(e, t) {
    if (!this._disposed)
      return this.handler.findHover(e, t);
  }, n.prototype.on = function(e, t, r) {
    return this._disposed || this.handler.on(e, t, r), this;
  }, n.prototype.off = function(e, t) {
    this._disposed || this.handler.off(e, t);
  }, n.prototype.trigger = function(e, t) {
    this._disposed || this.handler.trigger(e, t);
  }, n.prototype.clear = function() {
    if (!this._disposed) {
      for (var e = this.storage.getRoots(), t = 0; t < e.length; t++)
        e[t] instanceof We && e[t].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, n.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, nxt(this.id));
  }, n;
}();
function jz(n, e) {
  var t = new ixt(UK(), n, e);
  return kJ[t.id] = t, t;
}
function oxt(n, e) {
  Xm[n] = e;
}
var DM;
function axt(n) {
  if (typeof DM == "function")
    return DM(n);
}
function sxt(n) {
  DM = n;
}
var Hz = 1e-4, PJ = 20;
function lxt(n) {
  return n.replace(/^\s+|\s+$/g, "");
}
function Yt(n, e, t, r) {
  var i = e[0], o = e[1], a = t[0], s = t[1], l = o - i, u = s - a;
  if (l === 0)
    return u === 0 ? a : (a + s) / 2;
  if (r)
    if (l > 0) {
      if (n <= i)
        return a;
      if (n >= o)
        return s;
    } else {
      if (n >= i)
        return a;
      if (n <= o)
        return s;
    }
  else {
    if (n === i)
      return a;
    if (n === o)
      return s;
  }
  return (n - i) / l * u + a;
}
function be(n, e) {
  switch (n) {
    case "center":
    case "middle":
      n = "50%";
      break;
    case "left":
    case "top":
      n = "0%";
      break;
    case "right":
    case "bottom":
      n = "100%";
      break;
  }
  return we(n) ? lxt(n).match(/%$/) ? parseFloat(n) / 100 * e : parseFloat(n) : n == null ? NaN : +n;
}
function qn(n, e, t) {
  return e == null && (e = 10), e = Math.min(Math.max(0, e), PJ), n = (+n).toFixed(e), t ? n : +n;
}
function wa(n) {
  return n.sort(function(e, t) {
    return e - t;
  }), n;
}
function rl(n) {
  if (n = +n, isNaN(n))
    return 0;
  if (n > 1e-14) {
    for (var e = 1, t = 0; t < 15; t++, e *= 10)
      if (Math.round(n * e) / e === n)
        return t;
  }
  return LM(n);
}
function LM(n) {
  var e = n.toString().toLowerCase(), t = e.indexOf("e"), r = t > 0 ? +e.slice(t + 1) : 0, i = t > 0 ? t : e.length, o = e.indexOf("."), a = o < 0 ? 0 : i - 1 - o;
  return Math.max(0, a - r);
}
function EJ(n, e) {
  var t = Math.log, r = Math.LN10, i = Math.floor(t(n[1] - n[0]) / r), o = Math.round(t(Math.abs(e[1] - e[0])) / r), a = Math.min(Math.max(-i + o, 0), 20);
  return isFinite(a) ? a : 20;
}
function uxt(n, e) {
  var t = xl(n, function(d, p) {
    return d + (isNaN(p) ? 0 : p);
  }, 0);
  if (t === 0)
    return [];
  for (var r = Math.pow(10, e), i = le(n, function(d) {
    return (isNaN(d) ? 0 : d) / t * r * 100;
  }), o = r * 100, a = le(i, function(d) {
    return Math.floor(d);
  }), s = xl(a, function(d, p) {
    return d + p;
  }, 0), l = le(i, function(d, p) {
    return d - a[p];
  }); s < o; ) {
    for (var u = Number.NEGATIVE_INFINITY, c = null, h = 0, f = l.length; h < f; ++h)
      l[h] > u && (u = l[h], c = h);
    ++a[c], l[c] = 0, ++s;
  }
  return le(a, function(d) {
    return d / r;
  });
}
function cxt(n, e) {
  var t = Math.max(rl(n), rl(e)), r = n + e;
  return t > PJ ? r : qn(r, t);
}
var qz = 9007199254740991;
function MJ(n) {
  var e = Math.PI * 2;
  return (n % e + e) % e;
}
function R0(n) {
  return n > -Hz && n < Hz;
}
var hxt = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Cl(n) {
  if (n instanceof Date)
    return n;
  if (we(n)) {
    var e = hxt.exec(n);
    if (!e)
      return /* @__PURE__ */ new Date(NaN);
    if (e[8]) {
      var t = +e[4] || 0;
      return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
    } else
      return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
  } else if (n == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(n));
}
function fxt(n) {
  return Math.pow(10, mC(n));
}
function mC(n) {
  if (n === 0)
    return 0;
  var e = Math.floor(Math.log(n) / Math.LN10);
  return n / Math.pow(10, e) >= 10 && e++, e;
}
function DJ(n, e) {
  var t = mC(n), r = Math.pow(10, t), i = n / r, o;
  return e ? i < 1.5 ? o = 1 : i < 2.5 ? o = 2 : i < 4 ? o = 3 : i < 7 ? o = 5 : o = 10 : i < 1 ? o = 1 : i < 2 ? o = 2 : i < 3 ? o = 3 : i < 5 ? o = 5 : o = 10, n = o * r, t >= -20 ? +n.toFixed(t < 0 ? -t : 0) : n;
}
function BA(n, e) {
  var t = (n.length - 1) * e + 1, r = Math.floor(t), i = +n[r - 1], o = t - r;
  return o ? i + o * (n[r] - i) : i;
}
function Yz(n) {
  n.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var e = -1 / 0, t = 1, r = 0; r < n.length; ) {
    for (var i = n[r].interval, o = n[r].close, a = 0; a < 2; a++)
      i[a] <= e && (i[a] = e, o[a] = a ? 1 : 1 - t), e = i[a], t = o[a];
    i[0] === i[1] && o[0] * o[1] !== 1 ? n.splice(r, 1) : r++;
  }
  return n;
  function s(l, u, c) {
    return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
  }
}
function pu(n) {
  var e = parseFloat(n);
  return e == n && (e !== 0 || !we(n) || n.indexOf("x") <= 0) ? e : NaN;
}
function DR(n) {
  return !isNaN(pu(n));
}
function LJ() {
  return Math.round(Math.random() * 9);
}
function IJ(n, e) {
  return e === 0 ? n : IJ(e, n % e);
}
function Xz(n, e) {
  return n == null ? e : e == null ? n : n * e / IJ(n, e);
}
var dxt = "[ECharts] ", Uz = {}, pxt = typeof console < "u" && console.warn && console.log;
function yC(n, e, t) {
  if (pxt) {
    if (t) {
      if (Uz[e])
        return;
      Uz[e] = !0;
    }
    console[n](dxt + e);
  }
}
function gxt(n, e) {
  yC("log", n, e);
}
function $n(n, e) {
  yC("warn", n, e);
}
function bi(n, e) {
  yC("error", n, e);
}
function vs(n) {
  process.env.NODE_ENV !== "production" && yC("warn", "DEPRECATED: " + n, !0);
}
function lr(n, e, t) {
  process.env.NODE_ENV !== "production" && vs((t ? "[" + t + "]" : "") + (n + " is deprecated, use " + e + " instead."));
}
function to() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  var t = "";
  if (process.env.NODE_ENV !== "production") {
    var r = function(i) {
      return i === void 0 ? "undefined" : i === 1 / 0 ? "Infinity" : i === -1 / 0 ? "-Infinity" : cd(i) ? "NaN" : i instanceof Date ? "Date(" + i.toISOString() + ")" : Le(i) ? "function () { ... }" : KK(i) ? i + "" : null;
    };
    t = le(n, function(i) {
      if (we(i))
        return i;
      var o = r(i);
      if (o != null)
        return o;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(i, function(a, s) {
            var l = r(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return t;
}
function Gt(n) {
  throw new Error(n);
}
function Kz(n, e, t) {
  return (e - n) * t + n;
}
var RJ = "series\0", NJ = "\0_ec_\0";
function an(n) {
  return n instanceof Array ? n : n == null ? [] : [n];
}
function hd(n, e, t) {
  if (n) {
    n[e] = n[e] || {}, n.emphasis = n.emphasis || {}, n.emphasis[e] = n.emphasis[e] || {};
    for (var r = 0, i = t.length; r < i; r++) {
      var o = t[r];
      !n.emphasis[e].hasOwnProperty(o) && n[e].hasOwnProperty(o) && (n.emphasis[e][o] = n[e][o]);
    }
  }
}
var Jz = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function Mv(n) {
  return Ne(n) && !se(n) && !(n instanceof Date) ? n.value : n;
}
function vxt(n) {
  return Ne(n) && !(n instanceof Array);
}
function $J(n, e, t) {
  var r = t === "normalMerge", i = t === "replaceMerge", o = t === "replaceAll";
  n = n || [], e = (e || []).slice();
  var a = Ee();
  I(e, function(l, u) {
    if (!Ne(l)) {
      e[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !tF(l.id) && eF(l.id), l.name != null && !tF(l.name) && eF(l.name));
  });
  var s = mxt(n, a, t);
  return (r || i) && yxt(s, n, a, e), r && bxt(s, e), r || i ? Oxt(s, e, i) : o && wxt(s, e), xxt(s), s;
}
function mxt(n, e, t) {
  var r = [];
  if (t === "replaceAll")
    return r;
  for (var i = 0; i < n.length; i++) {
    var o = n[i];
    o && o.id != null && e.set(o.id, i), r.push({
      existing: t === "replaceMerge" || qg(o) ? null : o,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return r;
}
function yxt(n, e, t, r) {
  I(r, function(i, o) {
    if (!(!i || i.id == null)) {
      var a = Ly(i.id), s = t.get(a);
      if (s != null) {
        var l = n[s];
        $e(!l.newOption, 'Duplicated option on id "' + a + '".'), l.newOption = i, l.existing = e[s], r[o] = null;
      }
    }
  });
}
function bxt(n, e) {
  I(e, function(t, r) {
    if (!(!t || t.name == null))
      for (var i = 0; i < n.length; i++) {
        var o = n[i].existing;
        if (!n[i].newOption && o && (o.id == null || t.id == null) && !qg(t) && !qg(o) && BJ("name", o, t)) {
          n[i].newOption = t, e[r] = null;
          return;
        }
      }
  });
}
function Oxt(n, e, t) {
  I(e, function(r) {
    if (r) {
      for (
        var i, o = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (i = n[o]) && (i.newOption || qg(i.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        i.existing && r.id != null && !BJ("id", r, i.existing));
      )
        o++;
      i ? (i.newOption = r, i.brandNew = t) : n.push({
        newOption: r,
        brandNew: t,
        existing: null,
        keyInfo: null
      }), o++;
    }
  });
}
function wxt(n, e) {
  I(e, function(t) {
    n.push({
      newOption: t,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function xxt(n) {
  var e = Ee();
  I(n, function(t) {
    var r = t.existing;
    r && e.set(r.id, t);
  }), I(n, function(t) {
    var r = t.newOption;
    $e(!r || r.id == null || !e.get(r.id) || e.get(r.id) === t, "id duplicates: " + (r && r.id)), r && r.id != null && e.set(r.id, t), !t.keyInfo && (t.keyInfo = {});
  }), I(n, function(t, r) {
    var i = t.existing, o = t.newOption, a = t.keyInfo;
    if (Ne(o)) {
      if (a.name = o.name != null ? Ly(o.name) : i ? i.name : RJ + r, i)
        a.id = Ly(i.id);
      else if (o.id != null)
        a.id = Ly(o.id);
      else {
        var s = 0;
        do
          a.id = "\0" + a.name + "\0" + s++;
        while (e.get(a.id));
      }
      e.set(a.id, t);
    }
  });
}
function BJ(n, e, t) {
  var r = wr(e[n], null), i = wr(t[n], null);
  return r != null && i != null && r === i;
}
function Ly(n) {
  if (process.env.NODE_ENV !== "production" && n == null)
    throw new Error();
  return wr(n, "");
}
function wr(n, e) {
  return n == null ? e : we(n) ? n : $t(n) || oS(n) ? n + "" : e;
}
function eF(n) {
  process.env.NODE_ENV !== "production" && $n("`" + n + "` is invalid id or name. Must be a string or number.");
}
function tF(n) {
  return oS(n) || DR(n);
}
function LR(n) {
  var e = n.name;
  return !!(e && e.indexOf(RJ));
}
function qg(n) {
  return n && n.id != null && Ly(n.id).indexOf(NJ) === 0;
}
function Sxt(n) {
  return NJ + n;
}
function _xt(n, e, t) {
  I(n, function(r) {
    var i = r.newOption;
    Ne(i) && (r.keyInfo.mainType = e, r.keyInfo.subType = Cxt(e, i, r.existing, t));
  });
}
function Cxt(n, e, t, r) {
  var i = e.type ? e.type : t ? t.subType : r.determineSubType(n, e);
  return i;
}
function Axt(n, e) {
  var t = {}, r = {};
  return i(n || [], t), i(e || [], r, t), [o(t), o(r)];
  function i(a, s, l) {
    for (var u = 0, c = a.length; u < c; u++) {
      var h = wr(a[u].seriesId, null);
      if (h == null)
        return;
      for (var f = an(a[u].dataIndex), d = l && l[h], p = 0, g = f.length; p < g; p++) {
        var v = f[p];
        d && d[v] ? d[v] = null : (s[h] || (s[h] = {}))[v] = 1;
      }
    }
  }
  function o(a, s) {
    var l = [];
    for (var u in a)
      if (a.hasOwnProperty(u) && a[u] != null)
        if (s)
          l.push(+u);
        else {
          var c = o(a[u], !0);
          c.length && l.push({
            seriesId: u,
            dataIndex: c
          });
        }
    return l;
  }
}
function fd(n, e) {
  if (e.dataIndexInside != null)
    return e.dataIndexInside;
  if (e.dataIndex != null)
    return se(e.dataIndex) ? le(e.dataIndex, function(t) {
      return n.indexOfRawIndex(t);
    }) : n.indexOfRawIndex(e.dataIndex);
  if (e.name != null)
    return se(e.name) ? le(e.name, function(t) {
      return n.indexOfName(t);
    }) : n.indexOfName(e.name);
}
function It() {
  var n = "__ec_inner_" + Txt++;
  return function(e) {
    return e[n] || (e[n] = {});
  };
}
var Txt = LJ();
function Iy(n, e, t) {
  var r = IR(e, t), i = r.mainTypeSpecified, o = r.queryOptionMap, a = r.others, s = a, l = t ? t.defaultMainType : null;
  return !i && l && o.set(l, {}), o.each(function(u, c) {
    var h = Bb(n, c, u, {
      useDefault: l === c,
      enableAll: t && t.enableAll != null ? t.enableAll : !0,
      enableNone: t && t.enableNone != null ? t.enableNone : !0
    });
    s[c + "Models"] = h.models, s[c + "Model"] = h.models[0];
  }), s;
}
function IR(n, e) {
  var t;
  if (we(n)) {
    var r = {};
    r[n + "Index"] = 0, t = r;
  } else
    t = n;
  var i = Ee(), o = {}, a = !1;
  return I(t, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      o[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
    if (!(!c || !h || e && e.includeMainTypes && ct(e.includeMainTypes, c) < 0)) {
      a = a || !!c;
      var f = i.get(c) || i.set(c, {});
      f[h] = s;
    }
  }), {
    mainTypeSpecified: a,
    queryOptionMap: i,
    others: o
  };
}
var cr = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, kxt = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Bb(n, e, t, r) {
  r = r || cr;
  var i = t.index, o = t.id, a = t.name, s = {
    models: null,
    specified: i != null || o != null || a != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = r.useDefault && (l = n.getComponent(e)) ? [l] : [], s;
  }
  return i === "none" || i === !1 ? ($e(r.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && ($e(r.enableAll, '`"all"` is not a valid value on index option.'), i = o = a = null), s.models = n.queryComponents({
    mainType: e,
    index: i,
    id: o,
    name: a
  }), s);
}
function VJ(n, e, t) {
  n.setAttribute ? n.setAttribute(e, t) : n[e] = t;
}
function Pxt(n, e) {
  return n.getAttribute ? n.getAttribute(e) : n[e];
}
function Ext(n) {
  return n === "auto" ? mt.domSupported ? "html" : "richText" : n || "html";
}
function IM(n, e) {
  var t = Ee(), r = [];
  return I(n, function(i) {
    var o = e(i);
    (t.get(o) || (r.push(o), t.set(o, []))).push(i);
  }), {
    keys: r,
    buckets: t
  };
}
function zJ(n, e, t, r, i) {
  var o = e == null || e === "auto";
  if (r == null)
    return r;
  if ($t(r)) {
    var a = Kz(t || 0, r, i);
    return qn(a, o ? Math.max(rl(t || 0), rl(r)) : e);
  } else {
    if (we(r))
      return i < 1 ? t : r;
    for (var s = [], l = t, u = r, c = Math.max(l ? l.length : 0, u.length), h = 0; h < c; ++h) {
      var f = n.getDimensionInfo(h);
      if (f && f.type === "ordinal")
        s[h] = (i < 1 && l ? l : u)[h];
      else {
        var d = l && l[h] ? l[h] : 0, p = u[h], a = Kz(d, p, i);
        s[h] = qn(a, o ? Math.max(rl(d), rl(p)) : e);
      }
    }
    return s;
  }
}
var Mxt = ".", Th = "___EC__COMPONENT__CONTAINER___", FJ = "___EC__EXTENDED_CLASS___";
function il(n) {
  var e = {
    main: "",
    sub: ""
  };
  if (n) {
    var t = n.split(Mxt);
    e.main = t[0] || "", e.sub = t[1] || "";
  }
  return e;
}
function Dxt(n) {
  $e(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n), 'componentType "' + n + '" illegal');
}
function Lxt(n) {
  return !!(n && n[FJ]);
}
function RR(n, e) {
  n.$constructor = n, n.extend = function(t) {
    process.env.NODE_ENV !== "production" && I(e, function(o) {
      t[o] || console.warn("Method `" + o + "` should be implemented" + (t.type ? " in " + t.type : "") + ".");
    });
    var r = this, i;
    return Ixt(r) ? i = /** @class */
    function(o) {
      H(a, o);
      function a() {
        return o.apply(this, arguments) || this;
      }
      return a;
    }(r) : (i = function() {
      (t.$constructor || r).apply(this, arguments);
    }, NOt(i, this)), re(i.prototype, t), i[FJ] = !0, i.extend = this.extend, i.superCall = $xt, i.superApply = Bxt, i.superClass = r, i;
  };
}
function Ixt(n) {
  return Le(n) && /^class\s/.test(Function.prototype.toString.call(n));
}
function QJ(n, e) {
  n.extend = e.extend;
}
var Rxt = Math.round(Math.random() * 10);
function Nxt(n) {
  var e = ["__\0is_clz", Rxt++].join("_");
  n.prototype[e] = !0, process.env.NODE_ENV !== "production" && $e(!n.isInstance, 'The method "is" can not be defined.'), n.isInstance = function(t) {
    return !!(t && t[e]);
  };
}
function $xt(n, e) {
  for (var t = [], r = 2; r < arguments.length; r++)
    t[r - 2] = arguments[r];
  return this.superClass.prototype[e].apply(n, t);
}
function Bxt(n, e, t) {
  return this.superClass.prototype[e].apply(n, t);
}
function bC(n) {
  var e = {};
  n.registerClass = function(r) {
    var i = r.type || r.prototype.type;
    if (i) {
      Dxt(i), r.prototype.type = i;
      var o = il(i);
      if (!o.sub)
        process.env.NODE_ENV !== "production" && e[o.main] && console.warn(o.main + " exists."), e[o.main] = r;
      else if (o.sub !== Th) {
        var a = t(o);
        a[o.sub] = r;
      }
    }
    return r;
  }, n.getClass = function(r, i, o) {
    var a = e[r];
    if (a && a[Th] && (a = i ? a[i] : null), o && !a)
      throw new Error(i ? "Component " + r + "." + (i || "") + " is used but not imported." : r + ".type should be specified.");
    return a;
  }, n.getClassesByMainType = function(r) {
    var i = il(r), o = [], a = e[i.main];
    return a && a[Th] ? I(a, function(s, l) {
      l !== Th && o.push(s);
    }) : o.push(a), o;
  }, n.hasClass = function(r) {
    var i = il(r);
    return !!e[i.main];
  }, n.getAllClassMainTypes = function() {
    var r = [];
    return I(e, function(i, o) {
      r.push(o);
    }), r;
  }, n.hasSubTypes = function(r) {
    var i = il(r), o = e[i.main];
    return o && o[Th];
  };
  function t(r) {
    var i = e[r.main];
    return (!i || !i[Th]) && (i = e[r.main] = {}, i[Th] = !0), i;
  }
}
function dd(n, e) {
  for (var t = 0; t < n.length; t++)
    n[t][1] || (n[t][1] = n[t][0]);
  return e = e || !1, function(r, i, o) {
    for (var a = {}, s = 0; s < n.length; s++) {
      var l = n[s][1];
      if (!(i && ct(i, l) >= 0 || o && ct(o, l) < 0)) {
        var u = r.getShallow(l, e);
        u != null && (a[n[s][0]] = u);
      }
    }
    return a;
  };
}
var Vxt = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], zxt = dd(Vxt), Fxt = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getAreaStyle = function(e, t) {
      return zxt(this, e, t);
    }, n;
  }()
), RM = new Nb(50);
function Qxt(n) {
  if (typeof n == "string") {
    var e = RM.get(n);
    return e && e.image;
  } else
    return n;
}
function NR(n, e, t, r, i) {
  if (n)
    if (typeof n == "string") {
      if (e && e.__zrImageSrc === n || !t)
        return e;
      var o = RM.get(n), a = { hostEl: t, cb: r, cbPayload: i };
      return o ? (e = o.image, !OC(e) && o.pending.push(a)) : (e = jc.loadImage(n, nF, nF), e.__zrImageSrc = n, RM.put(n, e.__cachedImgObj = {
        image: e,
        pending: [a]
      })), e;
    } else
      return n;
  else
    return e;
}
function nF() {
  var n = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var e = 0; e < n.pending.length; e++) {
    var t = n.pending[e], r = t.cb;
    r && r(this, t.cbPayload), t.hostEl.dirty();
  }
  n.pending.length = 0;
}
function OC(n) {
  return n && n.width && n.height;
}
var VA = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function Zxt(n, e, t, r, i) {
  if (!e)
    return "";
  var o = (n + "").split(`
`);
  i = ZJ(e, t, r, i);
  for (var a = 0, s = o.length; a < s; a++)
    o[a] = WJ(o[a], i);
  return o.join(`
`);
}
function ZJ(n, e, t, r) {
  r = r || {};
  var i = re({}, r);
  i.font = e, t = qe(t, "..."), i.maxIterations = qe(r.maxIterations, 2);
  var o = i.minChar = qe(r.minChar, 0);
  i.cnCharWidth = Yo("国", e);
  var a = i.ascCharWidth = Yo("a", e);
  i.placeholder = qe(r.placeholder, "");
  for (var s = n = Math.max(0, n - 1), l = 0; l < o && s >= a; l++)
    s -= a;
  var u = Yo(t, e);
  return u > s && (t = "", u = 0), s = n - u, i.ellipsis = t, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = n, i;
}
function WJ(n, e) {
  var t = e.containerWidth, r = e.font, i = e.contentWidth;
  if (!t)
    return "";
  var o = Yo(n, r);
  if (o <= t)
    return n;
  for (var a = 0; ; a++) {
    if (o <= i || a >= e.maxIterations) {
      n += e.ellipsis;
      break;
    }
    var s = a === 0 ? Wxt(n, i, e.ascCharWidth, e.cnCharWidth) : o > 0 ? Math.floor(n.length * i / o) : 0;
    n = n.substr(0, s), o = Yo(n, r);
  }
  return n === "" && (n = e.placeholder), n;
}
function Wxt(n, e, t, r) {
  for (var i = 0, o = 0, a = n.length; o < a && i < e; o++) {
    var s = n.charCodeAt(o);
    i += 0 <= s && s <= 127 ? t : r;
  }
  return o;
}
function Gxt(n, e) {
  n != null && (n += "");
  var t = e.overflow, r = e.padding, i = e.font, o = t === "truncate", a = vC(i), s = qe(e.lineHeight, a), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", c = e.width, h;
  c != null && (t === "break" || t === "breakAll") ? h = n ? GJ(n, e.font, c, t === "breakAll", 0).lines : [] : h = n ? n.split(`
`) : [];
  var f = h.length * s, d = qe(e.height, f);
  if (f > d && u) {
    var p = Math.floor(d / s);
    h = h.slice(0, p);
  }
  if (n && o && c != null)
    for (var g = ZJ(c, i, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), v = 0; v < h.length; v++)
      h[v] = WJ(h[v], g);
  for (var m = d, y = 0, v = 0; v < h.length; v++)
    y = Math.max(Yo(h[v], i), y);
  c == null && (c = y);
  var b = y;
  return r && (m += r[0] + r[2], b += r[1] + r[3], c += r[1] + r[3]), l && (b = c), {
    lines: h,
    height: d,
    outerWidth: b,
    outerHeight: m,
    lineHeight: s,
    calculatedLineHeight: a,
    contentWidth: y,
    contentHeight: f,
    width: c
  };
}
var jxt = /* @__PURE__ */ function() {
  function n() {
  }
  return n;
}(), rF = /* @__PURE__ */ function() {
  function n(e) {
    this.tokens = [], e && (this.tokens = e);
  }
  return n;
}(), Hxt = /* @__PURE__ */ function() {
  function n() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
  }
  return n;
}();
function qxt(n, e) {
  var t = new Hxt();
  if (n != null && (n += ""), !n)
    return t;
  for (var r = e.width, i = e.height, o = e.overflow, a = (o === "break" || o === "breakAll") && r != null ? { width: r, accumWidth: 0, breakAll: o === "breakAll" } : null, s = VA.lastIndex = 0, l; (l = VA.exec(n)) != null; ) {
    var u = l.index;
    u > s && zA(t, n.substring(s, u), e, a), zA(t, l[2], e, a, l[1]), s = VA.lastIndex;
  }
  s < n.length && zA(t, n.substring(s, n.length), e, a);
  var c = [], h = 0, f = 0, d = e.padding, p = o === "truncate", g = e.lineOverflow === "truncate";
  function v(N, $, F) {
    N.width = $, N.lineHeight = F, h += F, f = Math.max(f, $);
  }
  e:
    for (var m = 0; m < t.lines.length; m++) {
      for (var y = t.lines[m], b = 0, O = 0, w = 0; w < y.tokens.length; w++) {
        var x = y.tokens[w], S = x.styleName && e.rich[x.styleName] || {}, _ = x.textPadding = S.padding, C = _ ? _[1] + _[3] : 0, A = x.font = S.font || e.font;
        x.contentHeight = vC(A);
        var k = qe(S.height, x.contentHeight);
        if (x.innerHeight = k, _ && (k += _[0] + _[2]), x.height = k, x.lineHeight = Aa(S.lineHeight, e.lineHeight, k), x.align = S && S.align || e.align, x.verticalAlign = S && S.verticalAlign || "middle", g && i != null && h + x.lineHeight > i) {
          w > 0 ? (y.tokens = y.tokens.slice(0, w), v(y, O, b), t.lines = t.lines.slice(0, m + 1)) : t.lines = t.lines.slice(0, m);
          break e;
        }
        var P = S.width, L = P == null || P === "auto";
        if (typeof P == "string" && P.charAt(P.length - 1) === "%")
          x.percentWidth = P, c.push(x), x.contentWidth = Yo(x.text, A);
        else {
          if (L) {
            var D = S.backgroundColor, E = D && D.image;
            E && (E = Qxt(E), OC(E) && (x.width = Math.max(x.width, E.width * k / E.height)));
          }
          var M = p && r != null ? r - O : null;
          M != null && M < x.width ? !L || M < C ? (x.text = "", x.width = x.contentWidth = 0) : (x.text = Zxt(x.text, M - C, A, e.ellipsis, { minChar: e.truncateMinChar }), x.width = x.contentWidth = Yo(x.text, A)) : x.contentWidth = Yo(x.text, A);
        }
        x.width += C, O += x.width, S && (b = Math.max(b, x.lineHeight));
      }
      v(y, O, b);
    }
  t.outerWidth = t.width = qe(r, f), t.outerHeight = t.height = qe(i, h), t.contentHeight = h, t.contentWidth = f, d && (t.outerWidth += d[1] + d[3], t.outerHeight += d[0] + d[2]);
  for (var m = 0; m < c.length; m++) {
    var x = c[m], R = x.percentWidth;
    x.width = parseInt(R, 10) / 100 * t.width;
  }
  return t;
}
function zA(n, e, t, r, i) {
  var o = e === "", a = i && t.rich[i] || {}, s = n.lines, l = a.font || t.font, u = !1, c, h;
  if (r) {
    var f = a.padding, d = f ? f[1] + f[3] : 0;
    if (a.width != null && a.width !== "auto") {
      var p = gs(a.width, r.width) + d;
      s.length > 0 && p + r.accumWidth > r.width && (c = e.split(`
`), u = !0), r.accumWidth = p;
    } else {
      var g = GJ(e, l, r.width, r.breakAll, r.accumWidth);
      r.accumWidth = g.accumWidth + d, h = g.linesWidths, c = g.lines;
    }
  } else
    c = e.split(`
`);
  for (var v = 0; v < c.length; v++) {
    var m = c[v], y = new jxt();
    if (y.styleName = i, y.text = m, y.isLineHolder = !m && !o, typeof a.width == "number" ? y.width = a.width : y.width = h ? h[v] : Yo(m, l), !v && !u) {
      var b = (s[s.length - 1] || (s[0] = new rF())).tokens, O = b.length;
      O === 1 && b[0].isLineHolder ? b[0] = y : (m || !O || o) && b.push(y);
    } else
      s.push(new rF([y]));
  }
}
function Yxt(n) {
  var e = n.charCodeAt(0);
  return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
}
var Xxt = xl(",&?/;] ".split(""), function(n, e) {
  return n[e] = !0, n;
}, {});
function Uxt(n) {
  return Yxt(n) ? !!Xxt[n] : !0;
}
function GJ(n, e, t, r, i) {
  for (var o = [], a = [], s = "", l = "", u = 0, c = 0, h = 0; h < n.length; h++) {
    var f = n.charAt(h);
    if (f === `
`) {
      l && (s += l, c += u), o.push(s), a.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var d = Yo(f, e), p = r ? !1 : !Uxt(f);
    if (o.length ? c + d > t : i + c + d > t) {
      c ? (s || l) && (p ? (s || (s = l, l = "", u = 0, c = u), o.push(s), a.push(c - u), l += f, u += d, s = "", c = u) : (l && (s += l, l = "", u = 0), o.push(s), a.push(c), s = f, c = d)) : p ? (o.push(l), a.push(u), l = f, u = d) : (o.push(f), a.push(d));
      continue;
    }
    c += d, p ? (l += f, u += d) : (l && (s += l, l = "", u = 0), s += f);
  }
  return !o.length && !s && (s = n, l = "", u = 0), l && (s += l), s && (o.push(s), a.push(c)), o.length === 1 && (c += i), {
    accumWidth: c,
    lines: o,
    linesWidths: a
  };
}
var NM = "__zr_style_" + Math.round(Math.random() * 10), Ff = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, wC = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
Ff[NM] = !0;
var iF = ["z", "z2", "invisible"], Kxt = ["invisible"], Ia = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype._init = function(t) {
    for (var r = Ot(t), i = 0; i < r.length; i++) {
      var o = r[i];
      o === "style" ? this.useStyle(t[o]) : n.prototype.attrKV.call(this, o, t[o]);
    }
    this.style || this.useStyle({});
  }, e.prototype.beforeBrush = function() {
  }, e.prototype.afterBrush = function() {
  }, e.prototype.innerBeforeBrush = function() {
  }, e.prototype.innerAfterBrush = function() {
  }, e.prototype.shouldBePainted = function(t, r, i, o) {
    var a = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && Jxt(this, t, r) || a && !a[0] && !a[3])
      return !1;
    if (i && this.__clipPaths) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (o && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, e.prototype.contain = function(t, r) {
    return this.rectContain(t, r);
  }, e.prototype.traverse = function(t, r) {
    t.call(r, this);
  }, e.prototype.rectContain = function(t, r) {
    var i = this.transformCoordToLocal(t, r), o = this.getBoundingRect();
    return o.contain(i[0], i[1]);
  }, e.prototype.getPaintRect = function() {
    var t = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var r = this.transform, i = this.getBoundingRect(), o = this.style, a = o.shadowBlur || 0, s = o.shadowOffsetX || 0, l = o.shadowOffsetY || 0;
      t = this._paintRect || (this._paintRect = new ot(0, 0, 0, 0)), r ? ot.applyTransform(t, i, r) : t.copy(i), (a || s || l) && (t.width += a * 2 + Math.abs(s), t.height += a * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + s - a), t.y = Math.min(t.y, t.y + l - a));
      var u = this.dirtyRectTolerance;
      t.isZero() || (t.x = Math.floor(t.x - u), t.y = Math.floor(t.y - u), t.width = Math.ceil(t.width + 1 + u * 2), t.height = Math.ceil(t.height + 1 + u * 2));
    }
    return t;
  }, e.prototype.setPrevPaintRect = function(t) {
    t ? (this._prevPaintRect = this._prevPaintRect || new ot(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
  }, e.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, e.prototype.animateStyle = function(t) {
    return this.animate("style", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : this.markRedraw();
  }, e.prototype.attrKV = function(t, r) {
    t !== "style" ? n.prototype.attrKV.call(this, t, r) : this.style ? this.setStyle(r) : this.useStyle(r);
  }, e.prototype.setStyle = function(t, r) {
    return typeof t == "string" ? this.style[t] = r : re(this.style, t), this.dirtyStyle(), this;
  }, e.prototype.dirtyStyle = function(t) {
    t || this.markRedraw(), this.__dirty |= Hm, this._rect && (this._rect = null);
  }, e.prototype.dirty = function() {
    this.dirtyStyle();
  }, e.prototype.styleChanged = function() {
    return !!(this.__dirty & Hm);
  }, e.prototype.styleUpdated = function() {
    this.__dirty &= ~Hm;
  }, e.prototype.createStyle = function(t) {
    return dC(Ff, t);
  }, e.prototype.useStyle = function(t) {
    t[NM] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
  }, e.prototype.isStyleObject = function(t) {
    return t[NM];
  }, e.prototype._innerSaveToNormal = function(t) {
    n.prototype._innerSaveToNormal.call(this, t);
    var r = this._normalState;
    t.style && !r.style && (r.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, r, iF);
  }, e.prototype._applyStateObj = function(t, r, i, o, a, s) {
    n.prototype._applyStateObj.call(this, t, r, i, o, a, s);
    var l = !(r && o), u;
    if (r && r.style ? a ? o ? u = r.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, r.style)) : (u = this._mergeStyle(this.createStyle(), o ? this.style : i.style), this._mergeStyle(u, r.style)) : l && (u = i.style), u)
      if (a) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var h = Ot(c), f = 0; f < h.length; f++) {
            var d = h[f];
            d in u && (u[d] = u[d], this.style[d] = c[d]);
          }
        for (var p = Ot(u), f = 0; f < p.length; f++) {
          var d = p[f];
          this.style[d] = this.style[d];
        }
        this._transitionState(t, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? Kxt : iF, f = 0; f < g.length; f++) {
      var d = g[f];
      r && r[d] != null ? this[d] = r[d] : l && i[d] != null && (this[d] = i[d]);
    }
  }, e.prototype._mergeStates = function(t) {
    for (var r = n.prototype._mergeStates.call(this, t), i, o = 0; o < t.length; o++) {
      var a = t[o];
      a.style && (i = i || {}, this._mergeStyle(i, a.style));
    }
    return i && (r.style = i), r;
  }, e.prototype._mergeStyle = function(t, r) {
    return re(t, r), t;
  }, e.prototype.getAnimationStyleProps = function() {
    return wC;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "displayable", t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = "pointer", t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = Zo | Hm;
  }(), e;
}(TJ), FA = new ot(0, 0, 0, 0), QA = new ot(0, 0, 0, 0);
function Jxt(n, e, t) {
  return FA.copy(n.getBoundingRect()), n.transform && FA.applyTransform(n.transform), QA.width = e, QA.height = t, !FA.intersect(QA);
}
var yo = Math.min, bo = Math.max, ZA = Math.sin, WA = Math.cos, kh = Math.PI * 2, lO = Ed(), uO = Ed(), cO = Ed();
function xC(n, e, t) {
  if (n.length !== 0) {
    for (var r = n[0], i = r[0], o = r[0], a = r[1], s = r[1], l = 1; l < n.length; l++)
      r = n[l], i = yo(i, r[0]), o = bo(o, r[0]), a = yo(a, r[1]), s = bo(s, r[1]);
    e[0] = i, e[1] = a, t[0] = o, t[1] = s;
  }
}
function oF(n, e, t, r, i, o) {
  i[0] = yo(n, t), i[1] = yo(e, r), o[0] = bo(n, t), o[1] = bo(e, r);
}
var aF = [], sF = [];
function eSt(n, e, t, r, i, o, a, s, l, u) {
  var c = cJ, h = Dr, f = c(n, t, i, a, aF);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var d = 0; d < f; d++) {
    var p = h(n, t, i, a, aF[d]);
    l[0] = yo(p, l[0]), u[0] = bo(p, u[0]);
  }
  f = c(e, r, o, s, sF);
  for (var d = 0; d < f; d++) {
    var g = h(e, r, o, s, sF[d]);
    l[1] = yo(g, l[1]), u[1] = bo(g, u[1]);
  }
  l[0] = yo(n, l[0]), u[0] = bo(n, u[0]), l[0] = yo(a, l[0]), u[0] = bo(a, u[0]), l[1] = yo(e, l[1]), u[1] = bo(e, u[1]), l[1] = yo(s, l[1]), u[1] = bo(s, u[1]);
}
function tSt(n, e, t, r, i, o, a, s) {
  var l = fJ, u = jr, c = bo(yo(l(n, t, i), 1), 0), h = bo(yo(l(e, r, o), 1), 0), f = u(n, t, i, c), d = u(e, r, o, h);
  a[0] = yo(n, i, f), a[1] = yo(e, o, d), s[0] = bo(n, i, f), s[1] = bo(e, o, d);
}
function nSt(n, e, t, r, i, o, a, s, l) {
  var u = dc, c = pc, h = Math.abs(i - o);
  if (h % kh < 1e-4 && h > 1e-4) {
    s[0] = n - t, s[1] = e - r, l[0] = n + t, l[1] = e + r;
    return;
  }
  if (lO[0] = WA(i) * t + n, lO[1] = ZA(i) * r + e, uO[0] = WA(o) * t + n, uO[1] = ZA(o) * r + e, u(s, lO, uO), c(l, lO, uO), i = i % kh, i < 0 && (i = i + kh), o = o % kh, o < 0 && (o = o + kh), i > o && !a ? o += kh : i < o && a && (i += kh), a) {
    var f = o;
    o = i, i = f;
  }
  for (var d = 0; d < o; d += Math.PI / 2)
    d > i && (cO[0] = WA(d) * t + n, cO[1] = ZA(d) * r + e, u(s, cO, s), c(l, cO, l));
}
var ln = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, Ph = [], Eh = [], Ms = [], Lu = [], Ds = [], Ls = [], GA = Math.min, jA = Math.max, Mh = Math.cos, Dh = Math.sin, $l = Math.abs, $M = Math.PI, qu = $M * 2, HA = typeof Float32Array < "u", hm = [];
function qA(n) {
  var e = Math.round(n / $M * 1e8) / 1e8;
  return e % 2 * $M;
}
function $R(n, e) {
  var t = qA(n[0]);
  t < 0 && (t += qu);
  var r = t - n[0], i = n[1];
  i += r, !e && i - t >= qu ? i = t + qu : e && t - i >= qu ? i = t - qu : !e && t > i ? i = t + (qu - qA(t - i)) : e && t < i && (i = t - (qu - qA(i - t))), n[0] = t, n[1] = i;
}
var Al = function() {
  function n(e) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return n.prototype.increaseVersion = function() {
    this._version++;
  }, n.prototype.getVersion = function() {
    return this._version;
  }, n.prototype.setScale = function(e, t, r) {
    r = r || 0, r > 0 && (this._ux = $l(r / dS / e) || 0, this._uy = $l(r / dS / t) || 0);
  }, n.prototype.setDPR = function(e) {
    this.dpr = e;
  }, n.prototype.setContext = function(e) {
    this._ctx = e;
  }, n.prototype.getContext = function() {
    return this._ctx;
  }, n.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, n.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, n.prototype.moveTo = function(e, t) {
    return this._drawPendingPt(), this.addData(ln.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this;
  }, n.prototype.lineTo = function(e, t) {
    var r = $l(e - this._xi), i = $l(t - this._yi), o = r > this._ux || i > this._uy;
    if (this.addData(ln.L, e, t), this._ctx && o && this._ctx.lineTo(e, t), o)
      this._xi = e, this._yi = t, this._pendingPtDist = 0;
    else {
      var a = r * r + i * i;
      a > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = a);
    }
    return this;
  }, n.prototype.bezierCurveTo = function(e, t, r, i, o, a) {
    return this._drawPendingPt(), this.addData(ln.C, e, t, r, i, o, a), this._ctx && this._ctx.bezierCurveTo(e, t, r, i, o, a), this._xi = o, this._yi = a, this;
  }, n.prototype.quadraticCurveTo = function(e, t, r, i) {
    return this._drawPendingPt(), this.addData(ln.Q, e, t, r, i), this._ctx && this._ctx.quadraticCurveTo(e, t, r, i), this._xi = r, this._yi = i, this;
  }, n.prototype.arc = function(e, t, r, i, o, a) {
    this._drawPendingPt(), hm[0] = i, hm[1] = o, $R(hm, a), i = hm[0], o = hm[1];
    var s = o - i;
    return this.addData(ln.A, e, t, r, r, i, s, 0, a ? 0 : 1), this._ctx && this._ctx.arc(e, t, r, i, o, a), this._xi = Mh(o) * r + e, this._yi = Dh(o) * r + t, this;
  }, n.prototype.arcTo = function(e, t, r, i, o) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, r, i, o), this;
  }, n.prototype.rect = function(e, t, r, i) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, r, i), this.addData(ln.R, e, t, r, i), this;
  }, n.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(ln.Z);
    var e = this._ctx, t = this._x0, r = this._y0;
    return e && e.closePath(), this._xi = t, this._yi = r, this;
  }, n.prototype.fill = function(e) {
    e && e.fill(), this.toStatic();
  }, n.prototype.stroke = function(e) {
    e && e.stroke(), this.toStatic();
  }, n.prototype.len = function() {
    return this._len;
  }, n.prototype.setData = function(e) {
    var t = e.length;
    !(this.data && this.data.length === t) && HA && (this.data = new Float32Array(t));
    for (var r = 0; r < t; r++)
      this.data[r] = e[r];
    this._len = t;
  }, n.prototype.appendPath = function(e) {
    e instanceof Array || (e = [e]);
    for (var t = e.length, r = 0, i = this._len, o = 0; o < t; o++)
      r += e[o].len();
    HA && this.data instanceof Float32Array && (this.data = new Float32Array(i + r));
    for (var o = 0; o < t; o++)
      for (var a = e[o].data, s = 0; s < a.length; s++)
        this.data[i++] = a[s];
    this._len = i;
  }, n.prototype.addData = function(e, t, r, i, o, a, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var h = 0; h < arguments.length; h++)
        c[this._len++] = arguments[h];
    }
  }, n.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, n.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var e = [], t = 0; t < this._len; t++)
        e[t] = this.data[t];
      this.data = e;
    }
  }, n.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var e = this.data;
      e instanceof Array && (e.length = this._len, HA && this._len > 11 && (this.data = new Float32Array(e)));
    }
  }, n.prototype.getBoundingRect = function() {
    Ms[0] = Ms[1] = Ds[0] = Ds[1] = Number.MAX_VALUE, Lu[0] = Lu[1] = Ls[0] = Ls[1] = -Number.MAX_VALUE;
    var e = this.data, t = 0, r = 0, i = 0, o = 0, a;
    for (a = 0; a < this._len; ) {
      var s = e[a++], l = a === 1;
      switch (l && (t = e[a], r = e[a + 1], i = t, o = r), s) {
        case ln.M:
          t = i = e[a++], r = o = e[a++], Ds[0] = i, Ds[1] = o, Ls[0] = i, Ls[1] = o;
          break;
        case ln.L:
          oF(t, r, e[a], e[a + 1], Ds, Ls), t = e[a++], r = e[a++];
          break;
        case ln.C:
          eSt(t, r, e[a++], e[a++], e[a++], e[a++], e[a], e[a + 1], Ds, Ls), t = e[a++], r = e[a++];
          break;
        case ln.Q:
          tSt(t, r, e[a++], e[a++], e[a], e[a + 1], Ds, Ls), t = e[a++], r = e[a++];
          break;
        case ln.A:
          var u = e[a++], c = e[a++], h = e[a++], f = e[a++], d = e[a++], p = e[a++] + d;
          a += 1;
          var g = !e[a++];
          l && (i = Mh(d) * h + u, o = Dh(d) * f + c), nSt(u, c, h, f, d, p, g, Ds, Ls), t = Mh(p) * h + u, r = Dh(p) * f + c;
          break;
        case ln.R:
          i = t = e[a++], o = r = e[a++];
          var v = e[a++], m = e[a++];
          oF(i, o, i + v, o + m, Ds, Ls);
          break;
        case ln.Z:
          t = i, r = o;
          break;
      }
      dc(Ms, Ms, Ds), pc(Lu, Lu, Ls);
    }
    return a === 0 && (Ms[0] = Ms[1] = Lu[0] = Lu[1] = 0), new ot(Ms[0], Ms[1], Lu[0] - Ms[0], Lu[1] - Ms[1]);
  }, n.prototype._calculateLength = function() {
    var e = this.data, t = this._len, r = this._ux, i = this._uy, o = 0, a = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, h = 0, f = 0; f < t; ) {
      var d = e[f++], p = f === 1;
      p && (o = e[f], a = e[f + 1], s = o, l = a);
      var g = -1;
      switch (d) {
        case ln.M:
          o = s = e[f++], a = l = e[f++];
          break;
        case ln.L: {
          var v = e[f++], m = e[f++], y = v - o, b = m - a;
          ($l(y) > r || $l(b) > i || f === t - 1) && (g = Math.sqrt(y * y + b * b), o = v, a = m);
          break;
        }
        case ln.C: {
          var O = e[f++], w = e[f++], v = e[f++], m = e[f++], x = e[f++], S = e[f++];
          g = ywt(o, a, O, w, v, m, x, S, 10), o = x, a = S;
          break;
        }
        case ln.Q: {
          var O = e[f++], w = e[f++], v = e[f++], m = e[f++];
          g = Owt(o, a, O, w, v, m, 10), o = v, a = m;
          break;
        }
        case ln.A:
          var _ = e[f++], C = e[f++], A = e[f++], k = e[f++], P = e[f++], L = e[f++], D = L + P;
          f += 1, p && (s = Mh(P) * A + _, l = Dh(P) * k + C), g = jA(A, k) * GA(qu, Math.abs(L)), o = Mh(D) * A + _, a = Dh(D) * k + C;
          break;
        case ln.R: {
          s = o = e[f++], l = a = e[f++];
          var E = e[f++], M = e[f++];
          g = E * 2 + M * 2;
          break;
        }
        case ln.Z: {
          var y = s - o, b = l - a;
          g = Math.sqrt(y * y + b * b), o = s, a = l;
          break;
        }
      }
      g >= 0 && (u[h++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, n.prototype.rebuildPath = function(e, t) {
    var r = this.data, i = this._ux, o = this._uy, a = this._len, s, l, u, c, h, f, d = t < 1, p, g, v = 0, m = 0, y, b = 0, O, w;
    if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, y = t * g, !y)))
      e:
        for (var x = 0; x < a; ) {
          var S = r[x++], _ = x === 1;
          switch (_ && (u = r[x], c = r[x + 1], s = u, l = c), S !== ln.L && b > 0 && (e.lineTo(O, w), b = 0), S) {
            case ln.M:
              s = u = r[x++], l = c = r[x++], e.moveTo(u, c);
              break;
            case ln.L: {
              h = r[x++], f = r[x++];
              var C = $l(h - u), A = $l(f - c);
              if (C > i || A > o) {
                if (d) {
                  var k = p[m++];
                  if (v + k > y) {
                    var P = (y - v) / k;
                    e.lineTo(u * (1 - P) + h * P, c * (1 - P) + f * P);
                    break e;
                  }
                  v += k;
                }
                e.lineTo(h, f), u = h, c = f, b = 0;
              } else {
                var L = C * C + A * A;
                L > b && (O = h, w = f, b = L);
              }
              break;
            }
            case ln.C: {
              var D = r[x++], E = r[x++], M = r[x++], R = r[x++], N = r[x++], $ = r[x++];
              if (d) {
                var k = p[m++];
                if (v + k > y) {
                  var P = (y - v) / k;
                  Hc(u, D, M, N, P, Ph), Hc(c, E, R, $, P, Eh), e.bezierCurveTo(Ph[1], Eh[1], Ph[2], Eh[2], Ph[3], Eh[3]);
                  break e;
                }
                v += k;
              }
              e.bezierCurveTo(D, E, M, R, N, $), u = N, c = $;
              break;
            }
            case ln.Q: {
              var D = r[x++], E = r[x++], M = r[x++], R = r[x++];
              if (d) {
                var k = p[m++];
                if (v + k > y) {
                  var P = (y - v) / k;
                  D0(u, D, M, P, Ph), D0(c, E, R, P, Eh), e.quadraticCurveTo(Ph[1], Eh[1], Ph[2], Eh[2]);
                  break e;
                }
                v += k;
              }
              e.quadraticCurveTo(D, E, M, R), u = M, c = R;
              break;
            }
            case ln.A:
              var F = r[x++], W = r[x++], j = r[x++], Y = r[x++], X = r[x++], ie = r[x++], ae = r[x++], ee = !r[x++], ne = j > Y ? j : Y, ye = $l(j - Y) > 1e-3, te = X + ie, ue = !1;
              if (d) {
                var k = p[m++];
                v + k > y && (te = X + ie * (y - v) / k, ue = !0), v += k;
              }
              if (ye && e.ellipse ? e.ellipse(F, W, j, Y, ae, X, te, ee) : e.arc(F, W, ne, X, te, ee), ue)
                break e;
              _ && (s = Mh(X) * j + F, l = Dh(X) * Y + W), u = Mh(te) * j + F, c = Dh(te) * Y + W;
              break;
            case ln.R:
              s = u = r[x], l = c = r[x + 1], h = r[x++], f = r[x++];
              var xe = r[x++], dt = r[x++];
              if (d) {
                var k = p[m++];
                if (v + k > y) {
                  var Ue = y - v;
                  e.moveTo(h, f), e.lineTo(h + GA(Ue, xe), f), Ue -= xe, Ue > 0 && e.lineTo(h + xe, f + GA(Ue, dt)), Ue -= dt, Ue > 0 && e.lineTo(h + jA(xe - Ue, 0), f + dt), Ue -= xe, Ue > 0 && e.lineTo(h, f + jA(dt - Ue, 0));
                  break e;
                }
                v += k;
              }
              e.rect(h, f, xe, dt);
              break;
            case ln.Z:
              if (d) {
                var k = p[m++];
                if (v + k > y) {
                  var P = (y - v) / k;
                  e.lineTo(u * (1 - P) + s * P, c * (1 - P) + l * P);
                  break e;
                }
                v += k;
              }
              e.closePath(), u = s, c = l;
          }
        }
  }, n.prototype.clone = function() {
    var e = new n(), t = this.data;
    return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e;
  }, n.CMD = ln, n.initDefaultProps = function() {
    var e = n.prototype;
    e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
  }(), n;
}();
function tc(n, e, t, r, i, o, a) {
  if (i === 0)
    return !1;
  var s = i, l = 0, u = n;
  if (a > e + s && a > r + s || a < e - s && a < r - s || o > n + s && o > t + s || o < n - s && o < t - s)
    return !1;
  if (n !== t)
    l = (e - r) / (n - t), u = (n * r - t * e) / (n - t);
  else
    return Math.abs(o - n) <= s / 2;
  var c = l * o - a + u, h = c * c / (l * l + 1);
  return h <= s / 2 * s / 2;
}
function rSt(n, e, t, r, i, o, a, s, l, u, c) {
  if (l === 0)
    return !1;
  var h = l;
  if (c > e + h && c > r + h && c > o + h && c > s + h || c < e - h && c < r - h && c < o - h && c < s - h || u > n + h && u > t + h && u > i + h && u > a + h || u < n - h && u < t - h && u < i - h && u < a - h)
    return !1;
  var f = hJ(n, e, t, r, i, o, a, s, u, c, null);
  return f <= h / 2;
}
function jJ(n, e, t, r, i, o, a, s, l) {
  if (a === 0)
    return !1;
  var u = a;
  if (l > e + u && l > r + u && l > o + u || l < e - u && l < r - u && l < o - u || s > n + u && s > t + u && s > i + u || s < n - u && s < t - u && s < i - u)
    return !1;
  var c = dJ(n, e, t, r, i, o, s, l, null);
  return c <= u / 2;
}
var lF = Math.PI * 2;
function jo(n) {
  return n %= lF, n < 0 && (n += lF), n;
}
var fm = Math.PI * 2;
function iSt(n, e, t, r, i, o, a, s, l) {
  if (a === 0)
    return !1;
  var u = a;
  s -= n, l -= e;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > t || c + u < t)
    return !1;
  if (Math.abs(r - i) % fm < 1e-4)
    return !0;
  if (o) {
    var h = r;
    r = jo(i), i = jo(h);
  } else
    r = jo(r), i = jo(i);
  r > i && (i += fm);
  var f = Math.atan2(l, s);
  return f < 0 && (f += fm), f >= r && f <= i || f + fm >= r && f + fm <= i;
}
function Ql(n, e, t, r, i, o) {
  if (o > e && o > r || o < e && o < r || r === e)
    return 0;
  var a = (o - e) / (r - e), s = r < e ? 1 : -1;
  (a === 1 || a === 0) && (s = r < e ? 0.5 : -0.5);
  var l = a * (t - n) + n;
  return l === i ? 1 / 0 : l > i ? s : 0;
}
var Iu = Al.CMD, Lh = Math.PI * 2, oSt = 1e-4;
function aSt(n, e) {
  return Math.abs(n - e) < oSt;
}
var ji = [-1, -1, -1], ua = [-1, -1];
function sSt() {
  var n = ua[0];
  ua[0] = ua[1], ua[1] = n;
}
function lSt(n, e, t, r, i, o, a, s, l, u) {
  if (u > e && u > r && u > o && u > s || u < e && u < r && u < o && u < s)
    return 0;
  var c = uS(e, r, o, s, u, ji);
  if (c === 0)
    return 0;
  for (var h = 0, f = -1, d = void 0, p = void 0, g = 0; g < c; g++) {
    var v = ji[g], m = v === 0 || v === 1 ? 0.5 : 1, y = Dr(n, t, i, a, v);
    y < l || (f < 0 && (f = cJ(e, r, o, s, ua), ua[1] < ua[0] && f > 1 && sSt(), d = Dr(e, r, o, s, ua[0]), f > 1 && (p = Dr(e, r, o, s, ua[1]))), f === 2 ? v < ua[0] ? h += d < e ? m : -m : v < ua[1] ? h += p < d ? m : -m : h += s < p ? m : -m : v < ua[0] ? h += d < e ? m : -m : h += s < d ? m : -m);
  }
  return h;
}
function uSt(n, e, t, r, i, o, a, s) {
  if (s > e && s > r && s > o || s < e && s < r && s < o)
    return 0;
  var l = bwt(e, r, o, s, ji);
  if (l === 0)
    return 0;
  var u = fJ(e, r, o);
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = jr(e, r, o, u), f = 0; f < l; f++) {
      var d = ji[f] === 0 || ji[f] === 1 ? 0.5 : 1, p = jr(n, t, i, ji[f]);
      p < a || (ji[f] < u ? c += h < e ? d : -d : c += o < h ? d : -d);
    }
    return c;
  } else {
    var d = ji[0] === 0 || ji[0] === 1 ? 0.5 : 1, p = jr(n, t, i, ji[0]);
    return p < a ? 0 : o < e ? d : -d;
  }
}
function cSt(n, e, t, r, i, o, a, s) {
  if (s -= e, s > t || s < -t)
    return 0;
  var l = Math.sqrt(t * t - s * s);
  ji[0] = -l, ji[1] = l;
  var u = Math.abs(r - i);
  if (u < 1e-4)
    return 0;
  if (u >= Lh - 1e-4) {
    r = 0, i = Lh;
    var c = o ? 1 : -1;
    return a >= ji[0] + n && a <= ji[1] + n ? c : 0;
  }
  if (r > i) {
    var h = r;
    r = i, i = h;
  }
  r < 0 && (r += Lh, i += Lh);
  for (var f = 0, d = 0; d < 2; d++) {
    var p = ji[d];
    if (p + n > a) {
      var g = Math.atan2(s, p), c = o ? 1 : -1;
      g < 0 && (g = Lh + g), (g >= r && g <= i || g + Lh >= r && g + Lh <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), f += c);
    }
  }
  return f;
}
function HJ(n, e, t, r, i) {
  for (var o = n.data, a = n.len(), s = 0, l = 0, u = 0, c = 0, h = 0, f, d, p = 0; p < a; ) {
    var g = o[p++], v = p === 1;
    switch (g === Iu.M && p > 1 && (t || (s += Ql(l, u, c, h, r, i))), v && (l = o[p], u = o[p + 1], c = l, h = u), g) {
      case Iu.M:
        c = o[p++], h = o[p++], l = c, u = h;
        break;
      case Iu.L:
        if (t) {
          if (tc(l, u, o[p], o[p + 1], e, r, i))
            return !0;
        } else
          s += Ql(l, u, o[p], o[p + 1], r, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case Iu.C:
        if (t) {
          if (rSt(l, u, o[p++], o[p++], o[p++], o[p++], o[p], o[p + 1], e, r, i))
            return !0;
        } else
          s += lSt(l, u, o[p++], o[p++], o[p++], o[p++], o[p], o[p + 1], r, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case Iu.Q:
        if (t) {
          if (jJ(l, u, o[p++], o[p++], o[p], o[p + 1], e, r, i))
            return !0;
        } else
          s += uSt(l, u, o[p++], o[p++], o[p], o[p + 1], r, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case Iu.A:
        var m = o[p++], y = o[p++], b = o[p++], O = o[p++], w = o[p++], x = o[p++];
        p += 1;
        var S = !!(1 - o[p++]);
        f = Math.cos(w) * b + m, d = Math.sin(w) * O + y, v ? (c = f, h = d) : s += Ql(l, u, f, d, r, i);
        var _ = (r - m) * O / b + m;
        if (t) {
          if (iSt(m, y, O, w, w + x, S, e, _, i))
            return !0;
        } else
          s += cSt(m, y, O, w, w + x, S, _, i);
        l = Math.cos(w + x) * b + m, u = Math.sin(w + x) * O + y;
        break;
      case Iu.R:
        c = l = o[p++], h = u = o[p++];
        var C = o[p++], A = o[p++];
        if (f = c + C, d = h + A, t) {
          if (tc(c, h, f, h, e, r, i) || tc(f, h, f, d, e, r, i) || tc(f, d, c, d, e, r, i) || tc(c, d, c, h, e, r, i))
            return !0;
        } else
          s += Ql(f, h, f, d, r, i), s += Ql(c, d, c, h, r, i);
        break;
      case Iu.Z:
        if (t) {
          if (tc(l, u, c, h, e, r, i))
            return !0;
        } else
          s += Ql(l, u, c, h, r, i);
        l = c, u = h;
        break;
    }
  }
  return !t && !aSt(u, h) && (s += Ql(l, u, c, h, r, i) || 0), s !== 0;
}
function hSt(n, e, t) {
  return HJ(n, 0, !1, e, t);
}
function fSt(n, e, t, r) {
  return HJ(n, e, !0, t, r);
}
var gS = Be({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, Ff), dSt = {
  style: Be({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, wC.style)
}, YA = _l.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), pSt = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.update = function() {
    var t = this;
    n.prototype.update.call(this);
    var r = this.style;
    if (r.decal) {
      var i = this._decalEl = this._decalEl || new e();
      i.buildPath === e.prototype.buildPath && (i.buildPath = function(l) {
        t.buildPath(l, t.shape);
      }), i.silent = !0;
      var o = i.style;
      for (var a in r)
        o[a] !== r[a] && (o[a] = r[a]);
      o.fill = r.fill ? r.decal : null, o.decal = null, o.shadowColor = null, r.strokeFirst && (o.stroke = null);
      for (var s = 0; s < YA.length; ++s)
        i[YA[s]] = this[YA[s]];
      i.__dirty |= Zo;
    } else
      this._decalEl && (this._decalEl = null);
  }, e.prototype.getDecalElement = function() {
    return this._decalEl;
  }, e.prototype._init = function(t) {
    var r = Ot(t);
    this.shape = this.getDefaultShape();
    var i = this.getDefaultStyle();
    i && this.useStyle(i);
    for (var o = 0; o < r.length; o++) {
      var a = r[o], s = t[a];
      a === "style" ? this.style ? re(this.style, s) : this.useStyle(s) : a === "shape" ? re(this.shape, s) : n.prototype.attrKV.call(this, a, s);
    }
    this.style || this.useStyle({});
  }, e.prototype.getDefaultStyle = function() {
    return null;
  }, e.prototype.getDefaultShape = function() {
    return {};
  }, e.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, e.prototype.getInsideTextFill = function() {
    var t = this.style.fill;
    if (t !== "none") {
      if (we(t)) {
        var r = hS(t, 0);
        return r > 0.5 ? EM : r > 0.2 ? Ywt : MM;
      } else if (t)
        return MM;
    }
    return EM;
  }, e.prototype.getInsideTextStroke = function(t) {
    var r = this.style.fill;
    if (we(r)) {
      var i = this.__zr, o = !!(i && i.isDarkMode()), a = hS(t, 0) < PM;
      if (o === a)
        return r;
    }
  }, e.prototype.buildPath = function(t, r, i) {
  }, e.prototype.pathUpdated = function() {
    this.__dirty &= ~Sp;
  }, e.prototype.getUpdatedPathProxy = function(t) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
  }, e.prototype.createPathProxy = function() {
    this.path = new Al(!1);
  }, e.prototype.hasStroke = function() {
    var t = this.style, r = t.stroke;
    return !(r == null || r === "none" || !(t.lineWidth > 0));
  }, e.prototype.hasFill = function() {
    var t = this.style, r = t.fill;
    return r != null && r !== "none";
  }, e.prototype.getBoundingRect = function() {
    var t = this._rect, r = this.style, i = !t;
    if (i) {
      var o = !1;
      this.path || (o = !0, this.createPathProxy());
      var a = this.path;
      (o || this.__dirty & Sp) && (a.beginPath(), this.buildPath(a, this.shape, !1), this.pathUpdated()), t = a.getBoundingRect();
    }
    if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = t.clone());
      if (this.__dirty || i) {
        s.copy(t);
        var l = r.strokeNoScale ? this.getLineScale() : 1, u = r.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return t;
  }, e.prototype.contain = function(t, r) {
    var i = this.transformCoordToLocal(t, r), o = this.getBoundingRect(), a = this.style;
    if (t = i[0], r = i[1], o.contain(t, r)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = a.lineWidth, u = a.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), fSt(s, l / u, t, r)))
          return !0;
      }
      if (this.hasFill())
        return hSt(s, t, r);
    }
    return !1;
  }, e.prototype.dirtyShape = function() {
    this.__dirty |= Sp, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, e.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, e.prototype.animateShape = function(t) {
    return this.animate("shape", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
  }, e.prototype.attrKV = function(t, r) {
    t === "shape" ? this.setShape(r) : n.prototype.attrKV.call(this, t, r);
  }, e.prototype.setShape = function(t, r) {
    var i = this.shape;
    return i || (i = this.shape = {}), typeof t == "string" ? i[t] = r : re(i, t), this.dirtyShape(), this;
  }, e.prototype.shapeChanged = function() {
    return !!(this.__dirty & Sp);
  }, e.prototype.createStyle = function(t) {
    return dC(gS, t);
  }, e.prototype._innerSaveToNormal = function(t) {
    n.prototype._innerSaveToNormal.call(this, t);
    var r = this._normalState;
    t.shape && !r.shape && (r.shape = re({}, this.shape));
  }, e.prototype._applyStateObj = function(t, r, i, o, a, s) {
    n.prototype._applyStateObj.call(this, t, r, i, o, a, s);
    var l = !(r && o), u;
    if (r && r.shape ? a ? o ? u = r.shape : (u = re({}, i.shape), re(u, r.shape)) : (u = re({}, o ? this.shape : i.shape), re(u, r.shape)) : l && (u = i.shape), u)
      if (a) {
        this.shape = re({}, this.shape);
        for (var c = {}, h = Ot(u), f = 0; f < h.length; f++) {
          var d = h[f];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(t, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, e.prototype._mergeStates = function(t) {
    for (var r = n.prototype._mergeStates.call(this, t), i, o = 0; o < t.length; o++) {
      var a = t[o];
      a.shape && (i = i || {}, this._mergeStyle(i, a.shape));
    }
    return i && (r.shape = i), r;
  }, e.prototype.getAnimationStyleProps = function() {
    return dSt;
  }, e.prototype.isZeroArea = function() {
    return !1;
  }, e.extend = function(t) {
    var r = function(o) {
      H(a, o);
      function a(s) {
        var l = o.call(this, s) || this;
        return t.init && t.init.call(l, s), l;
      }
      return a.prototype.getDefaultStyle = function() {
        return Fe(t.style);
      }, a.prototype.getDefaultShape = function() {
        return Fe(t.shape);
      }, a;
    }(e);
    for (var i in t)
      typeof t[i] == "function" && (r.prototype[i] = t[i]);
    return r;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = Zo | Hm | Sp;
  }(), e;
}(Ia);
const gt = pSt;
var gSt = Be({
  strokeFirst: !0,
  font: Gc,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, gS), qJ = function(n) {
  H(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.hasStroke = function() {
    var t = this.style, r = t.stroke;
    return r != null && r !== "none" && t.lineWidth > 0;
  }, e.prototype.hasFill = function() {
    var t = this.style, r = t.fill;
    return r != null && r !== "none";
  }, e.prototype.createStyle = function(t) {
    return dC(gSt, t);
  }, e.prototype.setBoundingRect = function(t) {
    this._rect = t;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    if (!this._rect) {
      var r = t.text;
      r != null ? r += "" : r = "";
      var i = $b(r, t.font, t.textAlign, t.textBaseline);
      if (i.x += t.x || 0, i.y += t.y || 0, this.hasStroke()) {
        var o = t.lineWidth;
        i.x -= o / 2, i.y -= o / 2, i.width += o, i.height += o;
      }
      this._rect = i;
    }
    return this._rect;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.dirtyRectTolerance = 10;
  }(), e;
}(Ia);
qJ.prototype.type = "tspan";
const N0 = qJ;
var vSt = Be({
  x: 0,
  y: 0
}, Ff), mSt = {
  style: Be({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, wC.style)
};
function ySt(n) {
  return !!(n && typeof n != "string" && n.width && n.height);
}
var YJ = function(n) {
  H(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.createStyle = function(t) {
    return dC(vSt, t);
  }, e.prototype._getSize = function(t) {
    var r = this.style, i = r[t];
    if (i != null)
      return i;
    var o = ySt(r.image) ? r.image : this.__image;
    if (!o)
      return 0;
    var a = t === "width" ? "height" : "width", s = r[a];
    return s == null ? o[t] : o[t] / o[a] * s;
  }, e.prototype.getWidth = function() {
    return this._getSize("width");
  }, e.prototype.getHeight = function() {
    return this._getSize("height");
  }, e.prototype.getAnimationStyleProps = function() {
    return mSt;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    return this._rect || (this._rect = new ot(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, e;
}(Ia);
YJ.prototype.type = "image";
const Si = YJ;
function bSt(n, e) {
  var t = e.x, r = e.y, i = e.width, o = e.height, a = e.r, s, l, u, c;
  i < 0 && (t = t + i, i = -i), o < 0 && (r = r + o, o = -o), typeof a == "number" ? s = l = u = c = a : a instanceof Array ? a.length === 1 ? s = l = u = c = a[0] : a.length === 2 ? (s = u = a[0], l = c = a[1]) : a.length === 3 ? (s = a[0], l = c = a[1], u = a[2]) : (s = a[0], l = a[1], u = a[2], c = a[3]) : s = l = u = c = 0;
  var h;
  s + l > i && (h = s + l, s *= i / h, l *= i / h), u + c > i && (h = u + c, u *= i / h, c *= i / h), l + u > o && (h = l + u, l *= o / h, u *= o / h), s + c > o && (h = s + c, s *= o / h, c *= o / h), n.moveTo(t + s, r), n.lineTo(t + i - l, r), l !== 0 && n.arc(t + i - l, r + l, l, -Math.PI / 2, 0), n.lineTo(t + i, r + o - u), u !== 0 && n.arc(t + i - u, r + o - u, u, 0, Math.PI / 2), n.lineTo(t + c, r + o), c !== 0 && n.arc(t + c, r + o - c, c, Math.PI / 2, Math.PI), n.lineTo(t, r + s), s !== 0 && n.arc(t + s, r + s, s, Math.PI, Math.PI * 1.5);
}
var Dp = Math.round;
function XJ(n, e, t) {
  if (e) {
    var r = e.x1, i = e.x2, o = e.y1, a = e.y2;
    n.x1 = r, n.x2 = i, n.y1 = o, n.y2 = a;
    var s = t && t.lineWidth;
    return s && (Dp(r * 2) === Dp(i * 2) && (n.x1 = n.x2 = wf(r, s, !0)), Dp(o * 2) === Dp(a * 2) && (n.y1 = n.y2 = wf(o, s, !0))), n;
  }
}
function UJ(n, e, t) {
  if (e) {
    var r = e.x, i = e.y, o = e.width, a = e.height;
    n.x = r, n.y = i, n.width = o, n.height = a;
    var s = t && t.lineWidth;
    return s && (n.x = wf(r, s, !0), n.y = wf(i, s, !0), n.width = Math.max(wf(r + o, s, !1) - n.x, o === 0 ? 0 : 1), n.height = Math.max(wf(i + a, s, !1) - n.y, a === 0 ? 0 : 1)), n;
  }
}
function wf(n, e, t) {
  if (!e)
    return n;
  var r = Dp(n * 2);
  return (r + Dp(e)) % 2 === 0 ? r / 2 : (r + (t ? 1 : -1)) / 2;
}
var OSt = /* @__PURE__ */ function() {
  function n() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return n;
}(), wSt = {}, KJ = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new OSt();
  }, e.prototype.buildPath = function(t, r) {
    var i, o, a, s;
    if (this.subPixelOptimize) {
      var l = UJ(wSt, r, this.style);
      i = l.x, o = l.y, a = l.width, s = l.height, l.r = r.r, r = l;
    } else
      i = r.x, o = r.y, a = r.width, s = r.height;
    r.r ? bSt(t, r) : t.rect(i, o, a, s);
  }, e.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, e;
}(gt);
KJ.prototype.type = "rect";
const Lt = KJ;
var uF = {
  fill: "#000"
}, cF = 2, xSt = {
  style: Be({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, wC.style)
}, JJ = function(n) {
  H(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r.type = "text", r._children = [], r._defaultStyle = uF, r.attr(t), r;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.update = function() {
    n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var t = 0; t < this._children.length; t++) {
      var r = this._children[t];
      r.zlevel = this.zlevel, r.z = this.z, r.z2 = this.z2, r.culling = this.culling, r.cursor = this.cursor, r.invisible = this.invisible;
    }
  }, e.prototype.updateTransform = function() {
    var t = this.innerTransformable;
    t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : n.prototype.updateTransform.call(this);
  }, e.prototype.getLocalTransform = function(t) {
    var r = this.innerTransformable;
    return r ? r.getLocalTransform(t) : n.prototype.getLocalTransform.call(this, t);
  }, e.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), n.prototype.getComputedTransform.call(this);
  }, e.prototype._updateSubTexts = function() {
    this._childCursor = 0, CSt(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, e.prototype.addSelfToZr = function(t) {
    n.prototype.addSelfToZr.call(this, t);
    for (var r = 0; r < this._children.length; r++)
      this._children[r].__zr = t;
  }, e.prototype.removeSelfFromZr = function(t) {
    n.prototype.removeSelfFromZr.call(this, t);
    for (var r = 0; r < this._children.length; r++)
      this._children[r].__zr = null;
  }, e.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var t = new ot(0, 0, 0, 0), r = this._children, i = [], o = null, a = 0; a < r.length; a++) {
        var s = r[a], l = s.getBoundingRect(), u = s.getLocalTransform(i);
        u ? (t.copy(l), t.applyTransform(u), o = o || t.clone(), o.union(t)) : (o = o || l.clone(), o.union(l));
      }
      this._rect = o || t;
    }
    return this._rect;
  }, e.prototype.setDefaultTextStyle = function(t) {
    this._defaultStyle = t || uF;
  }, e.prototype.setTextContent = function(t) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, e.prototype._mergeStyle = function(t, r) {
    if (!r)
      return t;
    var i = r.rich, o = t.rich || i && {};
    return re(t, r), i && o ? (this._mergeRich(o, i), t.rich = o) : o && (t.rich = o), t;
  }, e.prototype._mergeRich = function(t, r) {
    for (var i = Ot(r), o = 0; o < i.length; o++) {
      var a = i[o];
      t[a] = t[a] || {}, re(t[a], r[a]);
    }
  }, e.prototype.getAnimationStyleProps = function() {
    return xSt;
  }, e.prototype._getOrCreateChild = function(t) {
    var r = this._children[this._childCursor];
    return (!r || !(r instanceof t)) && (r = new t()), this._children[this._childCursor++] = r, r.__zr = this.__zr, r.parent = this, r;
  }, e.prototype._updatePlainTexts = function() {
    var t = this.style, r = t.font || Gc, i = t.padding, o = mF(t), a = Gxt(o, t), s = XA(t), l = !!t.backgroundColor, u = a.outerHeight, c = a.outerWidth, h = a.contentWidth, f = a.lines, d = a.lineHeight, p = this._defaultStyle, g = t.x || 0, v = t.y || 0, m = t.align || p.align || "left", y = t.verticalAlign || p.verticalAlign || "top", b = g, O = _p(v, a.contentHeight, y);
    if (s || i) {
      var w = Ym(g, c, m), x = _p(v, u, y);
      s && this._renderBackground(t, t, w, x, c, u);
    }
    O += d / 2, i && (b = vF(g, m, i), y === "top" ? O += i[0] : y === "bottom" && (O -= i[2]));
    for (var S = 0, _ = !1, C = gF("fill" in t ? t.fill : (_ = !0, p.fill)), A = pF("stroke" in t ? t.stroke : !l && (!p.autoStroke || _) ? (S = cF, p.stroke) : null), k = t.textShadowBlur > 0, P = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), L = a.calculatedLineHeight, D = 0; D < f.length; D++) {
      var E = this._getOrCreateChild(N0), M = E.createStyle();
      E.useStyle(M), M.text = f[D], M.x = b, M.y = O, m && (M.textAlign = m), M.textBaseline = "middle", M.opacity = t.opacity, M.strokeFirst = !0, k && (M.shadowBlur = t.textShadowBlur || 0, M.shadowColor = t.textShadowColor || "transparent", M.shadowOffsetX = t.textShadowOffsetX || 0, M.shadowOffsetY = t.textShadowOffsetY || 0), M.stroke = A, M.fill = C, A && (M.lineWidth = t.lineWidth || S, M.lineDash = t.lineDash, M.lineDashOffset = t.lineDashOffset || 0), M.font = r, fF(M, t), O += d, P && E.setBoundingRect(new ot(Ym(M.x, t.width, M.textAlign), _p(M.y, L, M.textBaseline), h, L));
    }
  }, e.prototype._updateRichTexts = function() {
    var t = this.style, r = mF(t), i = qxt(r, t), o = i.width, a = i.outerWidth, s = i.outerHeight, l = t.padding, u = t.x || 0, c = t.y || 0, h = this._defaultStyle, f = t.align || h.align, d = t.verticalAlign || h.verticalAlign, p = Ym(u, a, f), g = _p(c, s, d), v = p, m = g;
    l && (v += l[3], m += l[0]);
    var y = v + o;
    XA(t) && this._renderBackground(t, t, p, g, a, s);
    for (var b = !!t.backgroundColor, O = 0; O < i.lines.length; O++) {
      for (var w = i.lines[O], x = w.tokens, S = x.length, _ = w.lineHeight, C = w.width, A = 0, k = v, P = y, L = S - 1, D = void 0; A < S && (D = x[A], !D.align || D.align === "left"); )
        this._placeToken(D, t, _, m, k, "left", b), C -= D.width, k += D.width, A++;
      for (; L >= 0 && (D = x[L], D.align === "right"); )
        this._placeToken(D, t, _, m, P, "right", b), C -= D.width, P -= D.width, L--;
      for (k += (o - (k - v) - (y - P) - C) / 2; A <= L; )
        D = x[A], this._placeToken(D, t, _, m, k + D.width / 2, "center", b), k += D.width, A++;
      m += _;
    }
  }, e.prototype._placeToken = function(t, r, i, o, a, s, l) {
    var u = r.rich[t.styleName] || {};
    u.text = t.text;
    var c = t.verticalAlign, h = o + i / 2;
    c === "top" ? h = o + t.height / 2 : c === "bottom" && (h = o + i - t.height / 2);
    var f = !t.isLineHolder && XA(u);
    f && this._renderBackground(u, r, s === "right" ? a - t.width : s === "center" ? a - t.width / 2 : a, h - t.height / 2, t.width, t.height);
    var d = !!u.backgroundColor, p = t.textPadding;
    p && (a = vF(a, s, p), h -= t.height / 2 - p[0] - t.innerHeight / 2);
    var g = this._getOrCreateChild(N0), v = g.createStyle();
    g.useStyle(v);
    var m = this._defaultStyle, y = !1, b = 0, O = gF("fill" in u ? u.fill : "fill" in r ? r.fill : (y = !0, m.fill)), w = pF("stroke" in u ? u.stroke : "stroke" in r ? r.stroke : !d && !l && (!m.autoStroke || y) ? (b = cF, m.stroke) : null), x = u.textShadowBlur > 0 || r.textShadowBlur > 0;
    v.text = t.text, v.x = a, v.y = h, x && (v.shadowBlur = u.textShadowBlur || r.textShadowBlur || 0, v.shadowColor = u.textShadowColor || r.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || r.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || r.textShadowOffsetY || 0), v.textAlign = s, v.textBaseline = "middle", v.font = t.font || Gc, v.opacity = Aa(u.opacity, r.opacity, 1), fF(v, u), w && (v.lineWidth = Aa(u.lineWidth, r.lineWidth, b), v.lineDash = qe(u.lineDash, r.lineDash), v.lineDashOffset = r.lineDashOffset || 0, v.stroke = w), O && (v.fill = O);
    var S = t.contentWidth, _ = t.contentHeight;
    g.setBoundingRect(new ot(Ym(v.x, S, v.textAlign), _p(v.y, _, v.textBaseline), S, _));
  }, e.prototype._renderBackground = function(t, r, i, o, a, s) {
    var l = t.backgroundColor, u = t.borderWidth, c = t.borderColor, h = l && l.image, f = l && !h, d = t.borderRadius, p = this, g, v;
    if (f || t.lineHeight || u && c) {
      g = this._getOrCreateChild(Lt), g.useStyle(g.createStyle()), g.style.fill = null;
      var m = g.shape;
      m.x = i, m.y = o, m.width = a, m.height = s, m.r = d, g.dirtyShape();
    }
    if (f) {
      var y = g.style;
      y.fill = l || null, y.fillOpacity = qe(t.fillOpacity, 1);
    } else if (h) {
      v = this._getOrCreateChild(Si), v.onload = function() {
        p.dirtyStyle();
      };
      var b = v.style;
      b.image = l.image, b.x = i, b.y = o, b.width = a, b.height = s;
    }
    if (u && c) {
      var y = g.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = qe(t.strokeOpacity, 1), y.lineDash = t.borderDash, y.lineDashOffset = t.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var O = (g || v).style;
    O.shadowBlur = t.shadowBlur || 0, O.shadowColor = t.shadowColor || "transparent", O.shadowOffsetX = t.shadowOffsetX || 0, O.shadowOffsetY = t.shadowOffsetY || 0, O.opacity = Aa(t.opacity, r.opacity, 1);
  }, e.makeFont = function(t) {
    var r = "";
    return tee(t) && (r = [
      t.fontStyle,
      t.fontWeight,
      eee(t.fontSize),
      t.fontFamily || "sans-serif"
    ].join(" ")), r && is(r) || t.textFont || t.font;
  }, e;
}(Ia), SSt = { left: !0, right: 1, center: 1 }, _St = { top: 1, bottom: 1, middle: 1 }, hF = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function eee(n) {
  return typeof n == "string" && (n.indexOf("px") !== -1 || n.indexOf("rem") !== -1 || n.indexOf("em") !== -1) ? n : isNaN(+n) ? bR + "px" : n + "px";
}
function fF(n, e) {
  for (var t = 0; t < hF.length; t++) {
    var r = hF[t], i = e[r];
    i != null && (n[r] = i);
  }
}
function tee(n) {
  return n.fontSize != null || n.fontFamily || n.fontWeight;
}
function CSt(n) {
  return dF(n), I(n.rich, dF), n;
}
function dF(n) {
  if (n) {
    n.font = JJ.makeFont(n);
    var e = n.align;
    e === "middle" && (e = "center"), n.align = e == null || SSt[e] ? e : "left";
    var t = n.verticalAlign;
    t === "center" && (t = "middle"), n.verticalAlign = t == null || _St[t] ? t : "top";
    var r = n.padding;
    r && (n.padding = _R(n.padding));
  }
}
function pF(n, e) {
  return n == null || e <= 0 || n === "transparent" || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
}
function gF(n) {
  return n == null || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
}
function vF(n, e, t) {
  return e === "right" ? n - t[1] : e === "center" ? n + t[3] / 2 - t[1] / 2 : n + t[3];
}
function mF(n) {
  var e = n.text;
  return e != null && (e += ""), e;
}
function XA(n) {
  return !!(n.backgroundColor || n.lineHeight || n.borderWidth && n.borderColor);
}
const Nt = JJ;
var He = It(), BM = function(n, e, t, r) {
  if (r) {
    var i = He(r);
    i.dataIndex = t, i.dataType = e, i.seriesIndex = n, i.ssrType = "chart", r.type === "group" && r.traverse(function(o) {
      var a = He(o);
      a.seriesIndex = n, a.dataIndex = t, a.dataType = e, a.ssrType = "chart";
    });
  }
}, yF = 1, bF = {}, nee = It(), BR = It(), VR = 0, Vb = 1, SC = 2, no = ["emphasis", "blur", "select"], $0 = ["normal", "emphasis", "blur", "select"], Dv = 10, ASt = 9, Qf = "highlight", Gw = "downplay", Ry = "select", jw = "unselect", Ny = "toggleSelect";
function Jd(n) {
  return n != null && n !== "none";
}
function _C(n, e, t) {
  n.onHoverStateChange && (n.hoverState || 0) !== t && n.onHoverStateChange(e), n.hoverState = t;
}
function ree(n) {
  _C(n, "emphasis", SC);
}
function iee(n) {
  n.hoverState === SC && _C(n, "normal", VR);
}
function zR(n) {
  _C(n, "blur", Vb);
}
function oee(n) {
  n.hoverState === Vb && _C(n, "normal", VR);
}
function TSt(n) {
  n.selected = !0;
}
function kSt(n) {
  n.selected = !1;
}
function OF(n, e, t) {
  e(n, t);
}
function Tu(n, e, t) {
  OF(n, e, t), n.isGroup && n.traverse(function(r) {
    OF(r, e, t);
  });
}
function vS(n, e) {
  switch (e) {
    case "emphasis":
      n.hoverState = SC;
      break;
    case "normal":
      n.hoverState = VR;
      break;
    case "blur":
      n.hoverState = Vb;
      break;
    case "select":
      n.selected = !0;
  }
}
function PSt(n, e, t, r) {
  for (var i = n.style, o = {}, a = 0; a < e.length; a++) {
    var s = e[a], l = i[s];
    o[s] = l ?? (r && r[s]);
  }
  for (var a = 0; a < n.animators.length; a++) {
    var u = n.animators[a];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(t) < 0 && u.targetName === "style" && u.saveTo(o, e);
  }
  return o;
}
function ESt(n, e, t, r) {
  var i = t && ct(t, "select") >= 0, o = !1;
  if (n instanceof gt) {
    var a = nee(n), s = i && a.selectFill || a.normalFill, l = i && a.selectStroke || a.normalStroke;
    if (Jd(s) || Jd(l)) {
      r = r || {};
      var u = r.style || {};
      u.fill === "inherit" ? (o = !0, r = re({}, r), u = re({}, u), u.fill = s) : !Jd(u.fill) && Jd(s) ? (o = !0, r = re({}, r), u = re({}, u), u.fill = xM(s)) : !Jd(u.stroke) && Jd(l) && (o || (r = re({}, r), u = re({}, u)), u.stroke = xM(l)), r.style = u;
    }
  }
  if (r && r.z2 == null) {
    o || (r = re({}, r));
    var c = n.z2EmphasisLift;
    r.z2 = n.z2 + (c ?? Dv);
  }
  return r;
}
function MSt(n, e, t) {
  if (t && t.z2 == null) {
    t = re({}, t);
    var r = n.z2SelectLift;
    t.z2 = n.z2 + (r ?? ASt);
  }
  return t;
}
function DSt(n, e, t) {
  var r = ct(n.currentStates, e) >= 0, i = n.style.opacity, o = r ? null : PSt(n, ["opacity"], e, {
    opacity: 1
  });
  t = t || {};
  var a = t.style || {};
  return a.opacity == null && (t = re({}, t), a = re({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: r ? i : o.opacity * 0.1
  }, a), t.style = a), t;
}
function UA(n, e) {
  var t = this.states[n];
  if (this.style) {
    if (n === "emphasis")
      return ESt(this, n, e, t);
    if (n === "blur")
      return DSt(this, n, t);
    if (n === "select")
      return MSt(this, n, t);
  }
  return t;
}
function pd(n) {
  n.stateProxy = UA;
  var e = n.getTextContent(), t = n.getTextGuideLine();
  e && (e.stateProxy = UA), t && (t.stateProxy = UA);
}
function wF(n, e) {
  !uee(n, e) && !n.__highByOuter && Tu(n, ree);
}
function xF(n, e) {
  !uee(n, e) && !n.__highByOuter && Tu(n, iee);
}
function gu(n, e) {
  n.__highByOuter |= 1 << (e || 0), Tu(n, ree);
}
function vu(n, e) {
  !(n.__highByOuter &= ~(1 << (e || 0))) && Tu(n, iee);
}
function aee(n) {
  Tu(n, zR);
}
function FR(n) {
  Tu(n, oee);
}
function see(n) {
  Tu(n, TSt);
}
function lee(n) {
  Tu(n, kSt);
}
function uee(n, e) {
  return n.__highDownSilentOnTouch && e.zrByTouch;
}
function cee(n) {
  var e = n.getModel(), t = [], r = [];
  e.eachComponent(function(i, o) {
    var a = BR(o), s = i === "series", l = s ? n.getViewOfSeriesModel(o) : n.getViewOfComponentModel(o);
    !s && r.push(l), a.isBlured && (l.group.traverse(function(u) {
      oee(u);
    }), s && t.push(o)), a.isBlured = !1;
  }), I(r, function(i) {
    i && i.toggleBlurSeries && i.toggleBlurSeries(t, !1, e);
  });
}
function VM(n, e, t, r) {
  var i = r.getModel();
  t = t || "coordinateSystem";
  function o(u, c) {
    for (var h = 0; h < c.length; h++) {
      var f = u.getItemGraphicEl(c[h]);
      f && FR(f);
    }
  }
  if (n != null && !(!e || e === "none")) {
    var a = i.getSeriesByIndex(n), s = a.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    i.eachSeries(function(u) {
      var c = a === u, h = u.coordinateSystem;
      h && h.master && (h = h.master);
      var f = h && s ? h === s : c;
      if (!// Not blur other series if blurScope series
      (t === "series" && !c || t === "coordinateSystem" && !f || e === "series" && c)) {
        var d = r.getViewOfSeriesModel(u);
        if (d.group.traverse(function(v) {
          v.__highByOuter && c && e === "self" || zR(v);
        }), Ni(e))
          o(u.getData(), e);
        else if (Ne(e))
          for (var p = Ot(e), g = 0; g < p.length; g++)
            o(u.getData(p[g]), e[p[g]]);
        l.push(u), BR(u).isBlured = !0;
      }
    }), i.eachComponent(function(u, c) {
      if (u !== "series") {
        var h = r.getViewOfComponentModel(c);
        h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, i);
      }
    });
  }
}
function zM(n, e, t) {
  if (!(n == null || e == null)) {
    var r = t.getModel().getComponent(n, e);
    if (r) {
      BR(r).isBlured = !0;
      var i = t.getViewOfComponentModel(r);
      !i || !i.focusBlurEnabled || i.group.traverse(function(o) {
        zR(o);
      });
    }
  }
}
function LSt(n, e, t) {
  var r = n.seriesIndex, i = n.getData(e.dataType);
  if (!i) {
    process.env.NODE_ENV !== "production" && bi("Unknown dataType " + e.dataType);
    return;
  }
  var o = fd(i, e);
  o = (se(o) ? o[0] : o) || 0;
  var a = i.getItemGraphicEl(o);
  if (!a)
    for (var s = i.count(), l = 0; !a && l < s; )
      a = i.getItemGraphicEl(l++);
  if (a) {
    var u = He(a);
    VM(r, u.focus, u.blurScope, t);
  } else {
    var c = n.get(["emphasis", "focus"]), h = n.get(["emphasis", "blurScope"]);
    c != null && VM(r, c, h, t);
  }
}
function QR(n, e, t, r) {
  var i = {
    focusSelf: !1,
    dispatchers: null
  };
  if (n == null || n === "series" || e == null || t == null)
    return i;
  var o = r.getModel().getComponent(n, e);
  if (!o)
    return i;
  var a = r.getViewOfComponentModel(o);
  if (!a || !a.findHighDownDispatchers)
    return i;
  for (var s = a.findHighDownDispatchers(t), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !qc(s[u]) && bi("param should be highDownDispatcher"), He(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function ISt(n, e, t) {
  process.env.NODE_ENV !== "production" && !qc(n) && bi("param should be highDownDispatcher");
  var r = He(n), i = QR(r.componentMainType, r.componentIndex, r.componentHighDownName, t), o = i.dispatchers, a = i.focusSelf;
  o ? (a && zM(r.componentMainType, r.componentIndex, t), I(o, function(s) {
    return wF(s, e);
  })) : (VM(r.seriesIndex, r.focus, r.blurScope, t), r.focus === "self" && zM(r.componentMainType, r.componentIndex, t), wF(n, e));
}
function RSt(n, e, t) {
  process.env.NODE_ENV !== "production" && !qc(n) && bi("param should be highDownDispatcher"), cee(t);
  var r = He(n), i = QR(r.componentMainType, r.componentIndex, r.componentHighDownName, t).dispatchers;
  i ? I(i, function(o) {
    return xF(o, e);
  }) : xF(n, e);
}
function NSt(n, e, t) {
  if (QM(e)) {
    var r = e.dataType, i = n.getData(r), o = fd(i, e);
    se(o) || (o = [o]), n[e.type === Ny ? "toggleSelect" : e.type === Ry ? "select" : "unselect"](o, r);
  }
}
function SF(n) {
  var e = n.getAllData();
  I(e, function(t) {
    var r = t.data, i = t.type;
    r.eachItemGraphicEl(function(o, a) {
      n.isSelected(a, i) ? see(o) : lee(o);
    });
  });
}
function $St(n) {
  var e = [];
  return n.eachSeries(function(t) {
    var r = t.getAllData();
    I(r, function(i) {
      i.data;
      var o = i.type, a = t.getSelectedDataIndices();
      if (a.length > 0) {
        var s = {
          dataIndex: a,
          seriesIndex: t.seriesIndex
        };
        o != null && (s.dataType = o), e.push(s);
      }
    });
  }), e;
}
function Zf(n, e, t) {
  xf(n, !0), Tu(n, pd), FM(n, e, t);
}
function BSt(n) {
  xf(n, !1);
}
function Wn(n, e, t, r) {
  r ? BSt(n) : Zf(n, e, t);
}
function FM(n, e, t) {
  var r = He(n);
  e != null ? (r.focus = e, r.blurScope = t) : r.focus && (r.focus = null);
}
var _F = ["emphasis", "blur", "select"], VSt = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function Oi(n, e, t, r) {
  t = t || "itemStyle";
  for (var i = 0; i < _F.length; i++) {
    var o = _F[i], a = e.getModel([o, t]), s = n.ensureState(o);
    s.style = r ? r(a) : a[VSt[t]]();
  }
}
function xf(n, e) {
  var t = e === !1, r = n;
  n.highDownSilentOnTouch && (r.__highDownSilentOnTouch = n.highDownSilentOnTouch), (!t || r.__highDownDispatcher) && (r.__highByOuter = r.__highByOuter || 0, r.__highDownDispatcher = !t);
}
function qc(n) {
  return !!(n && n.__highDownDispatcher);
}
function zSt(n, e, t) {
  var r = He(n);
  r.componentMainType = e.mainType, r.componentIndex = e.componentIndex, r.componentHighDownName = t;
}
function FSt(n) {
  var e = bF[n];
  return e == null && yF <= 32 && (e = bF[n] = yF++), e;
}
function QM(n) {
  var e = n.type;
  return e === Ry || e === jw || e === Ny;
}
function CF(n) {
  var e = n.type;
  return e === Qf || e === Gw;
}
function QSt(n) {
  var e = nee(n);
  e.normalFill = n.style.fill, e.normalStroke = n.style.stroke;
  var t = n.states.select || {};
  e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null;
}
var ep = Al.CMD, ZSt = [[], [], []], AF = Math.sqrt, WSt = Math.atan2;
function hee(n, e) {
  if (e) {
    var t = n.data, r = n.len(), i, o, a, s, l, u, c = ep.M, h = ep.C, f = ep.L, d = ep.R, p = ep.A, g = ep.Q;
    for (a = 0, s = 0; a < r; ) {
      switch (i = t[a++], s = a, o = 0, i) {
        case c:
          o = 1;
          break;
        case f:
          o = 1;
          break;
        case h:
          o = 3;
          break;
        case g:
          o = 2;
          break;
        case p:
          var v = e[4], m = e[5], y = AF(e[0] * e[0] + e[1] * e[1]), b = AF(e[2] * e[2] + e[3] * e[3]), O = WSt(-e[1] / b, e[0] / y);
          t[a] *= y, t[a++] += v, t[a] *= b, t[a++] += m, t[a++] *= y, t[a++] *= b, t[a++] += O, t[a++] += O, a += 2, s = a;
          break;
        case d:
          u[0] = t[a++], u[1] = t[a++], vi(u, u, e), t[s++] = u[0], t[s++] = u[1], u[0] += t[a++], u[1] += t[a++], vi(u, u, e), t[s++] = u[0], t[s++] = u[1];
      }
      for (l = 0; l < o; l++) {
        var w = ZSt[l];
        w[0] = t[a++], w[1] = t[a++], vi(w, w, e), t[s++] = w[0], t[s++] = w[1];
      }
    }
    n.increaseVersion();
  }
}
var KA = Math.sqrt, hO = Math.sin, fO = Math.cos, dm = Math.PI;
function TF(n) {
  return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
}
function ZM(n, e) {
  return (n[0] * e[0] + n[1] * e[1]) / (TF(n) * TF(e));
}
function kF(n, e) {
  return (n[0] * e[1] < n[1] * e[0] ? -1 : 1) * Math.acos(ZM(n, e));
}
function PF(n, e, t, r, i, o, a, s, l, u, c) {
  var h = l * (dm / 180), f = fO(h) * (n - t) / 2 + hO(h) * (e - r) / 2, d = -1 * hO(h) * (n - t) / 2 + fO(h) * (e - r) / 2, p = f * f / (a * a) + d * d / (s * s);
  p > 1 && (a *= KA(p), s *= KA(p));
  var g = (i === o ? -1 : 1) * KA((a * a * (s * s) - a * a * (d * d) - s * s * (f * f)) / (a * a * (d * d) + s * s * (f * f))) || 0, v = g * a * d / s, m = g * -s * f / a, y = (n + t) / 2 + fO(h) * v - hO(h) * m, b = (e + r) / 2 + hO(h) * v + fO(h) * m, O = kF([1, 0], [(f - v) / a, (d - m) / s]), w = [(f - v) / a, (d - m) / s], x = [(-1 * f - v) / a, (-1 * d - m) / s], S = kF(w, x);
  if (ZM(w, x) <= -1 && (S = dm), ZM(w, x) >= 1 && (S = 0), S < 0) {
    var _ = Math.round(S / dm * 1e6) / 1e6;
    S = dm * 2 + _ % 2 * dm;
  }
  c.addData(u, y, b, a, s, O, S, h, o);
}
var GSt = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, jSt = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function HSt(n) {
  var e = new Al();
  if (!n)
    return e;
  var t = 0, r = 0, i = t, o = r, a, s = Al.CMD, l = n.match(GSt);
  if (!l)
    return e;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], h = c.charAt(0), f = void 0, d = c.match(jSt) || [], p = d.length, g = 0; g < p; g++)
      d[g] = parseFloat(d[g]);
    for (var v = 0; v < p; ) {
      var m = void 0, y = void 0, b = void 0, O = void 0, w = void 0, x = void 0, S = void 0, _ = t, C = r, A = void 0, k = void 0;
      switch (h) {
        case "l":
          t += d[v++], r += d[v++], f = s.L, e.addData(f, t, r);
          break;
        case "L":
          t = d[v++], r = d[v++], f = s.L, e.addData(f, t, r);
          break;
        case "m":
          t += d[v++], r += d[v++], f = s.M, e.addData(f, t, r), i = t, o = r, h = "l";
          break;
        case "M":
          t = d[v++], r = d[v++], f = s.M, e.addData(f, t, r), i = t, o = r, h = "L";
          break;
        case "h":
          t += d[v++], f = s.L, e.addData(f, t, r);
          break;
        case "H":
          t = d[v++], f = s.L, e.addData(f, t, r);
          break;
        case "v":
          r += d[v++], f = s.L, e.addData(f, t, r);
          break;
        case "V":
          r = d[v++], f = s.L, e.addData(f, t, r);
          break;
        case "C":
          f = s.C, e.addData(f, d[v++], d[v++], d[v++], d[v++], d[v++], d[v++]), t = d[v - 2], r = d[v - 1];
          break;
        case "c":
          f = s.C, e.addData(f, d[v++] + t, d[v++] + r, d[v++] + t, d[v++] + r, d[v++] + t, d[v++] + r), t += d[v - 2], r += d[v - 1];
          break;
        case "S":
          m = t, y = r, A = e.len(), k = e.data, a === s.C && (m += t - k[A - 4], y += r - k[A - 3]), f = s.C, _ = d[v++], C = d[v++], t = d[v++], r = d[v++], e.addData(f, m, y, _, C, t, r);
          break;
        case "s":
          m = t, y = r, A = e.len(), k = e.data, a === s.C && (m += t - k[A - 4], y += r - k[A - 3]), f = s.C, _ = t + d[v++], C = r + d[v++], t += d[v++], r += d[v++], e.addData(f, m, y, _, C, t, r);
          break;
        case "Q":
          _ = d[v++], C = d[v++], t = d[v++], r = d[v++], f = s.Q, e.addData(f, _, C, t, r);
          break;
        case "q":
          _ = d[v++] + t, C = d[v++] + r, t += d[v++], r += d[v++], f = s.Q, e.addData(f, _, C, t, r);
          break;
        case "T":
          m = t, y = r, A = e.len(), k = e.data, a === s.Q && (m += t - k[A - 4], y += r - k[A - 3]), t = d[v++], r = d[v++], f = s.Q, e.addData(f, m, y, t, r);
          break;
        case "t":
          m = t, y = r, A = e.len(), k = e.data, a === s.Q && (m += t - k[A - 4], y += r - k[A - 3]), t += d[v++], r += d[v++], f = s.Q, e.addData(f, m, y, t, r);
          break;
        case "A":
          b = d[v++], O = d[v++], w = d[v++], x = d[v++], S = d[v++], _ = t, C = r, t = d[v++], r = d[v++], f = s.A, PF(_, C, t, r, x, S, b, O, w, f, e);
          break;
        case "a":
          b = d[v++], O = d[v++], w = d[v++], x = d[v++], S = d[v++], _ = t, C = r, t += d[v++], r += d[v++], f = s.A, PF(_, C, t, r, x, S, b, O, w, f, e);
          break;
      }
    }
    (h === "z" || h === "Z") && (f = s.Z, e.addData(f), t = i, r = o), a = f;
  }
  return e.toStatic(), e;
}
var fee = function(n) {
  H(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.applyTransform = function(t) {
  }, e;
}(gt);
function dee(n) {
  return n.setData != null;
}
function pee(n, e) {
  var t = HSt(n), r = re({}, e);
  return r.buildPath = function(i) {
    if (dee(i)) {
      i.setData(t.data);
      var o = i.getContext();
      o && i.rebuildPath(o, 1);
    } else {
      var o = i;
      t.rebuildPath(o, 1);
    }
  }, r.applyTransform = function(i) {
    hee(t, i), this.dirtyShape();
  }, r;
}
function gee(n, e) {
  return new fee(pee(n, e));
}
function qSt(n, e) {
  var t = pee(n, e), r = function(i) {
    H(o, i);
    function o(a) {
      var s = i.call(this, a) || this;
      return s.applyTransform = t.applyTransform, s.buildPath = t.buildPath, s;
    }
    return o;
  }(fee);
  return r;
}
function YSt(n, e) {
  for (var t = [], r = n.length, i = 0; i < r; i++) {
    var o = n[i];
    t.push(o.getUpdatedPathProxy(!0));
  }
  var a = new gt(e);
  return a.createPathProxy(), a.buildPath = function(s) {
    if (dee(s)) {
      s.appendPath(t);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, a;
}
function ZR(n, e) {
  e = e || {};
  var t = new gt();
  return n.shape && t.setShape(n.shape), t.setStyle(n.style), e.bakeTransform ? hee(t.path, n.getComputedTransform()) : e.toLocal ? t.setLocalTransform(n.getComputedTransform()) : t.copyTransform(n), t.buildPath = n.buildPath, t.applyTransform = t.applyTransform, t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel, t;
}
var XSt = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return n;
}(), vee = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new XSt();
  }, e.prototype.buildPath = function(t, r) {
    t.moveTo(r.cx + r.r, r.cy), t.arc(r.cx, r.cy, r.r, 0, Math.PI * 2);
  }, e;
}(gt);
vee.prototype.type = "circle";
const fh = vee;
var USt = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return n;
}(), mee = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new USt();
  }, e.prototype.buildPath = function(t, r) {
    var i = 0.5522848, o = r.cx, a = r.cy, s = r.rx, l = r.ry, u = s * i, c = l * i;
    t.moveTo(o - s, a), t.bezierCurveTo(o - s, a - c, o - u, a - l, o, a - l), t.bezierCurveTo(o + u, a - l, o + s, a - c, o + s, a), t.bezierCurveTo(o + s, a + c, o + u, a + l, o, a + l), t.bezierCurveTo(o - u, a + l, o - s, a + c, o - s, a), t.closePath();
  }, e;
}(gt);
mee.prototype.type = "ellipse";
const WR = mee;
var yee = Math.PI, JA = yee * 2, Ih = Math.sin, tp = Math.cos, KSt = Math.acos, Ci = Math.atan2, EF = Math.abs, $y = Math.sqrt, Um = Math.max, Is = Math.min, Ga = 1e-4;
function JSt(n, e, t, r, i, o, a, s) {
  var l = t - n, u = r - e, c = a - i, h = s - o, f = h * l - c * u;
  if (!(f * f < Ga))
    return f = (c * (e - o) - h * (n - i)) / f, [n + f * l, e + f * u];
}
function dO(n, e, t, r, i, o, a) {
  var s = n - t, l = e - r, u = (a ? o : -o) / $y(s * s + l * l), c = u * l, h = -u * s, f = n + c, d = e + h, p = t + c, g = r + h, v = (f + p) / 2, m = (d + g) / 2, y = p - f, b = g - d, O = y * y + b * b, w = i - o, x = f * g - p * d, S = (b < 0 ? -1 : 1) * $y(Um(0, w * w * O - x * x)), _ = (x * b - y * S) / O, C = (-x * y - b * S) / O, A = (x * b + y * S) / O, k = (-x * y + b * S) / O, P = _ - v, L = C - m, D = A - v, E = k - m;
  return P * P + L * L > D * D + E * E && (_ = A, C = k), {
    cx: _,
    cy: C,
    x0: -c,
    y0: -h,
    x1: _ * (i / w - 1),
    y1: C * (i / w - 1)
  };
}
function e_t(n) {
  var e;
  if (se(n)) {
    var t = n.length;
    if (!t)
      return n;
    t === 1 ? e = [n[0], n[0], 0, 0] : t === 2 ? e = [n[0], n[0], n[1], n[1]] : t === 3 ? e = n.concat(n[2]) : e = n;
  } else
    e = [n, n, n, n];
  return e;
}
function t_t(n, e) {
  var t, r = Um(e.r, 0), i = Um(e.r0 || 0, 0), o = r > 0, a = i > 0;
  if (!(!o && !a)) {
    if (o || (r = i, i = 0), i > r) {
      var s = r;
      r = i, i = s;
    }
    var l = e.startAngle, u = e.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = e.cx, h = e.cy, f = !!e.clockwise, d = EF(u - l), p = d > JA && d % JA;
      if (p > Ga && (d = p), !(r > Ga))
        n.moveTo(c, h);
      else if (d > JA - Ga)
        n.moveTo(c + r * tp(l), h + r * Ih(l)), n.arc(c, h, r, l, u, !f), i > Ga && (n.moveTo(c + i * tp(u), h + i * Ih(u)), n.arc(c, h, i, u, l, f));
      else {
        var g = void 0, v = void 0, m = void 0, y = void 0, b = void 0, O = void 0, w = void 0, x = void 0, S = void 0, _ = void 0, C = void 0, A = void 0, k = void 0, P = void 0, L = void 0, D = void 0, E = r * tp(l), M = r * Ih(l), R = i * tp(u), N = i * Ih(u), $ = d > Ga;
        if ($) {
          var F = e.cornerRadius;
          F && (t = e_t(F), g = t[0], v = t[1], m = t[2], y = t[3]);
          var W = EF(r - i) / 2;
          if (b = Is(W, m), O = Is(W, y), w = Is(W, g), x = Is(W, v), C = S = Um(b, O), A = _ = Um(w, x), (S > Ga || _ > Ga) && (k = r * tp(u), P = r * Ih(u), L = i * tp(l), D = i * Ih(l), d < yee)) {
            var j = JSt(E, M, L, D, k, P, R, N);
            if (j) {
              var Y = E - j[0], X = M - j[1], ie = k - j[0], ae = P - j[1], ee = 1 / Ih(KSt((Y * ie + X * ae) / ($y(Y * Y + X * X) * $y(ie * ie + ae * ae))) / 2), ne = $y(j[0] * j[0] + j[1] * j[1]);
              C = Is(S, (r - ne) / (ee + 1)), A = Is(_, (i - ne) / (ee - 1));
            }
          }
        }
        if (!$)
          n.moveTo(c + E, h + M);
        else if (C > Ga) {
          var ye = Is(m, C), te = Is(y, C), ue = dO(L, D, E, M, r, ye, f), xe = dO(k, P, R, N, r, te, f);
          n.moveTo(c + ue.cx + ue.x0, h + ue.cy + ue.y0), C < S && ye === te ? n.arc(c + ue.cx, h + ue.cy, C, Ci(ue.y0, ue.x0), Ci(xe.y0, xe.x0), !f) : (ye > 0 && n.arc(c + ue.cx, h + ue.cy, ye, Ci(ue.y0, ue.x0), Ci(ue.y1, ue.x1), !f), n.arc(c, h, r, Ci(ue.cy + ue.y1, ue.cx + ue.x1), Ci(xe.cy + xe.y1, xe.cx + xe.x1), !f), te > 0 && n.arc(c + xe.cx, h + xe.cy, te, Ci(xe.y1, xe.x1), Ci(xe.y0, xe.x0), !f));
        } else
          n.moveTo(c + E, h + M), n.arc(c, h, r, l, u, !f);
        if (!(i > Ga) || !$)
          n.lineTo(c + R, h + N);
        else if (A > Ga) {
          var ye = Is(g, A), te = Is(v, A), ue = dO(R, N, k, P, i, -te, f), xe = dO(E, M, L, D, i, -ye, f);
          n.lineTo(c + ue.cx + ue.x0, h + ue.cy + ue.y0), A < _ && ye === te ? n.arc(c + ue.cx, h + ue.cy, A, Ci(ue.y0, ue.x0), Ci(xe.y0, xe.x0), !f) : (te > 0 && n.arc(c + ue.cx, h + ue.cy, te, Ci(ue.y0, ue.x0), Ci(ue.y1, ue.x1), !f), n.arc(c, h, i, Ci(ue.cy + ue.y1, ue.cx + ue.x1), Ci(xe.cy + xe.y1, xe.cx + xe.x1), f), ye > 0 && n.arc(c + xe.cx, h + xe.cy, ye, Ci(xe.y1, xe.x1), Ci(xe.y0, xe.x0), !f));
        } else
          n.lineTo(c + R, h + N), n.arc(c, h, i, u, l, f);
      }
      n.closePath();
    }
  }
}
var n_t = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return n;
}(), bee = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new n_t();
  }, e.prototype.buildPath = function(t, r) {
    t_t(t, r);
  }, e.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, e;
}(gt);
bee.prototype.type = "sector";
const Eo = bee;
var r_t = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return n;
}(), Oee = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new r_t();
  }, e.prototype.buildPath = function(t, r) {
    var i = r.cx, o = r.cy, a = Math.PI * 2;
    t.moveTo(i + r.r, o), t.arc(i, o, r.r, 0, a, !1), t.moveTo(i + r.r0, o), t.arc(i, o, r.r0, 0, a, !0);
  }, e;
}(gt);
Oee.prototype.type = "ring";
const CC = Oee;
function i_t(n, e, t, r) {
  var i = [], o = [], a = [], s = [], l, u, c, h;
  if (r) {
    c = [1 / 0, 1 / 0], h = [-1 / 0, -1 / 0];
    for (var f = 0, d = n.length; f < d; f++)
      dc(c, c, n[f]), pc(h, h, n[f]);
    dc(c, c, r[0]), pc(h, h, r[1]);
  }
  for (var f = 0, d = n.length; f < d; f++) {
    var p = n[f];
    if (t)
      l = n[f ? f - 1 : d - 1], u = n[(f + 1) % d];
    else if (f === 0 || f === d - 1) {
      i.push(Jl(n[f]));
      continue;
    } else
      l = n[f - 1], u = n[f + 1];
    Of(o, u, l), Vw(o, o, e);
    var g = fM(p, l), v = fM(p, u), m = g + v;
    m !== 0 && (g /= m, v /= m), Vw(a, o, -g), Vw(s, o, v);
    var y = Oz([], p, a), b = Oz([], p, s);
    r && (pc(y, y, c), dc(y, y, h), pc(b, b, c), dc(b, b, h)), i.push(y), i.push(b);
  }
  return t && i.push(i.shift()), i;
}
function wee(n, e, t) {
  var r = e.smooth, i = e.points;
  if (i && i.length >= 2) {
    if (r) {
      var o = i_t(i, r, t, e.smoothConstraint);
      n.moveTo(i[0][0], i[0][1]);
      for (var a = i.length, s = 0; s < (t ? a : a - 1); s++) {
        var l = o[s * 2], u = o[s * 2 + 1], c = i[(s + 1) % a];
        n.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      n.moveTo(i[0][0], i[0][1]);
      for (var s = 1, h = i.length; s < h; s++)
        n.lineTo(i[s][0], i[s][1]);
    }
    t && n.closePath();
  }
}
var o_t = /* @__PURE__ */ function() {
  function n() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return n;
}(), ro = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new o_t();
  }, e.prototype.buildPath = function(t, r) {
    wee(t, r, !0);
  }, e;
}(gt);
ro.prototype.type = "polygon";
var a_t = /* @__PURE__ */ function() {
  function n() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return n;
}(), io = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new a_t();
  }, e.prototype.buildPath = function(t, r) {
    wee(t, r, !1);
  }, e;
}(gt);
io.prototype.type = "polyline";
var s_t = {}, l_t = /* @__PURE__ */ function() {
  function n() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return n;
}(), Br = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new l_t();
  }, e.prototype.buildPath = function(t, r) {
    var i, o, a, s;
    if (this.subPixelOptimize) {
      var l = XJ(s_t, r, this.style);
      i = l.x1, o = l.y1, a = l.x2, s = l.y2;
    } else
      i = r.x1, o = r.y1, a = r.x2, s = r.y2;
    var u = r.percent;
    u !== 0 && (t.moveTo(i, o), u < 1 && (a = i * (1 - u) + a * u, s = o * (1 - u) + s * u), t.lineTo(a, s));
  }, e.prototype.pointAt = function(t) {
    var r = this.shape;
    return [
      r.x1 * (1 - t) + r.x2 * t,
      r.y1 * (1 - t) + r.y2 * t
    ];
  }, e;
}(gt);
Br.prototype.type = "line";
var so = [], u_t = /* @__PURE__ */ function() {
  function n() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return n;
}();
function MF(n, e, t) {
  var r = n.cpx2, i = n.cpy2;
  return r != null || i != null ? [
    (t ? Dz : Dr)(n.x1, n.cpx1, n.cpx2, n.x2, e),
    (t ? Dz : Dr)(n.y1, n.cpy1, n.cpy2, n.y2, e)
  ] : [
    (t ? yM : jr)(n.x1, n.cpx1, n.x2, e),
    (t ? yM : jr)(n.y1, n.cpy1, n.y2, e)
  ];
}
var xee = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new u_t();
  }, e.prototype.buildPath = function(t, r) {
    var i = r.x1, o = r.y1, a = r.x2, s = r.y2, l = r.cpx1, u = r.cpy1, c = r.cpx2, h = r.cpy2, f = r.percent;
    f !== 0 && (t.moveTo(i, o), c == null || h == null ? (f < 1 && (D0(i, l, a, f, so), l = so[1], a = so[2], D0(o, u, s, f, so), u = so[1], s = so[2]), t.quadraticCurveTo(l, u, a, s)) : (f < 1 && (Hc(i, l, c, a, f, so), l = so[1], c = so[2], a = so[3], Hc(o, u, h, s, f, so), u = so[1], h = so[2], s = so[3]), t.bezierCurveTo(l, u, c, h, a, s)));
  }, e.prototype.pointAt = function(t) {
    return MF(this.shape, t, !1);
  }, e.prototype.tangentAt = function(t) {
    var r = MF(this.shape, t, !0);
    return Pv(r, r);
  }, e;
}(gt);
xee.prototype.type = "bezier-curve";
const AC = xee;
var c_t = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return n;
}(), See = function(n) {
  H(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new c_t();
  }, e.prototype.buildPath = function(t, r) {
    var i = r.cx, o = r.cy, a = Math.max(r.r, 0), s = r.startAngle, l = r.endAngle, u = r.clockwise, c = Math.cos(s), h = Math.sin(s);
    t.moveTo(c * a + i, h * a + o), t.arc(i, o, a, s, l, !u);
  }, e;
}(gt);
See.prototype.type = "arc";
const GR = See;
var h_t = function(n) {
  H(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.type = "compound", t;
  }
  return e.prototype._updatePathDirty = function() {
    for (var t = this.shape.paths, r = this.shapeChanged(), i = 0; i < t.length; i++)
      r = r || t[i].shapeChanged();
    r && this.dirtyShape();
  }, e.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var t = this.shape.paths || [], r = this.getGlobalScale(), i = 0; i < t.length; i++)
      t[i].path || t[i].createPathProxy(), t[i].path.setScale(r[0], r[1], t[i].segmentIgnoreThreshold);
  }, e.prototype.buildPath = function(t, r) {
    for (var i = r.paths || [], o = 0; o < i.length; o++)
      i[o].buildPath(t, i[o].shape, !0);
  }, e.prototype.afterBrush = function() {
    for (var t = this.shape.paths || [], r = 0; r < t.length; r++)
      t[r].pathUpdated();
  }, e.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), gt.prototype.getBoundingRect.call(this);
  }, e;
}(gt);
const jR = h_t;
var f_t = function() {
  function n(e) {
    this.colorStops = e || [];
  }
  return n.prototype.addColorStop = function(e, t) {
    this.colorStops.push({
      offset: e,
      color: t
    });
  }, n;
}();
const _ee = f_t;
var zb = function(n) {
  H(e, n);
  function e(t, r, i, o, a, s) {
    var l = n.call(this, a) || this;
    return l.x = t ?? 0, l.y = r ?? 0, l.x2 = i ?? 1, l.y2 = o ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return e;
}(_ee), d_t = function(n) {
  H(e, n);
  function e(t, r, i, o, a) {
    var s = n.call(this, o) || this;
    return s.x = t ?? 0.5, s.y = r ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = a || !1, s;
  }
  return e;
}(_ee);
const Cee = d_t;
var Rh = [0, 0], Nh = [0, 0], pO = new nt(), gO = new nt(), p_t = function() {
  function n(e, t) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var r = 0; r < 4; r++)
      this._corners[r] = new nt();
    for (var r = 0; r < 2; r++)
      this._axes[r] = new nt();
    e && this.fromBoundingRect(e, t);
  }
  return n.prototype.fromBoundingRect = function(e, t) {
    var r = this._corners, i = this._axes, o = e.x, a = e.y, s = o + e.width, l = a + e.height;
    if (r[0].set(o, a), r[1].set(s, a), r[2].set(s, l), r[3].set(o, l), t)
      for (var u = 0; u < 4; u++)
        r[u].transform(t);
    nt.sub(i[0], r[1], r[0]), nt.sub(i[1], r[3], r[0]), i[0].normalize(), i[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = i[u].dot(r[0]);
  }, n.prototype.intersect = function(e, t) {
    var r = !0, i = !t;
    return pO.set(1 / 0, 1 / 0), gO.set(0, 0), !this._intersectCheckOneSide(this, e, pO, gO, i, 1) && (r = !1, i) || !this._intersectCheckOneSide(e, this, pO, gO, i, -1) && (r = !1, i) || i || nt.copy(t, r ? pO : gO), r;
  }, n.prototype._intersectCheckOneSide = function(e, t, r, i, o, a) {
    for (var s = !0, l = 0; l < 2; l++) {
      var u = this._axes[l];
      if (this._getProjMinMaxOnAxis(l, e._corners, Rh), this._getProjMinMaxOnAxis(l, t._corners, Nh), Rh[1] < Nh[0] || Rh[0] > Nh[1]) {
        if (s = !1, o)
          return s;
        var c = Math.abs(Nh[0] - Rh[1]), h = Math.abs(Rh[0] - Nh[1]);
        Math.min(c, h) > i.len() && (c < h ? nt.scale(i, u, -c * a) : nt.scale(i, u, h * a));
      } else if (r) {
        var c = Math.abs(Nh[0] - Rh[1]), h = Math.abs(Rh[0] - Nh[1]);
        Math.min(c, h) < r.len() && (c < h ? nt.scale(r, u, c * a) : nt.scale(r, u, -h * a));
      }
    }
    return s;
  }, n.prototype._getProjMinMaxOnAxis = function(e, t, r) {
    for (var i = this._axes[e], o = this._origin, a = t[0].dot(i) + o[e], s = a, l = a, u = 1; u < t.length; u++) {
      var c = t[u].dot(i) + o[e];
      s = Math.min(c, s), l = Math.max(c, l);
    }
    r[0] = s, r[1] = l;
  }, n;
}();
const mS = p_t;
var g_t = [], v_t = function(n) {
  H(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.notClear = !0, t.incremental = !0, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t;
  }
  return e.prototype.traverse = function(t, r) {
    t.call(r, this);
  }, e.prototype.useStyle = function() {
    this.style = {};
  }, e.prototype.getCursor = function() {
    return this._cursor;
  }, e.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, e.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, e.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, e.prototype.addDisplayable = function(t, r) {
    r ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
  }, e.prototype.addDisplayables = function(t, r) {
    r = r || !1;
    for (var i = 0; i < t.length; i++)
      this.addDisplayable(t[i], r);
  }, e.prototype.getDisplayables = function() {
    return this._displayables;
  }, e.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, e.prototype.eachPendingDisplayable = function(t) {
    for (var r = this._cursor; r < this._displayables.length; r++)
      t && t(this._displayables[r]);
    for (var r = 0; r < this._temporaryDisplayables.length; r++)
      t && t(this._temporaryDisplayables[r]);
  }, e.prototype.update = function() {
    this.updateTransform();
    for (var t = this._cursor; t < this._displayables.length; t++) {
      var r = this._displayables[t];
      r.parent = this, r.update(), r.parent = null;
    }
    for (var t = 0; t < this._temporaryDisplayables.length; t++) {
      var r = this._temporaryDisplayables[t];
      r.parent = this, r.update(), r.parent = null;
    }
  }, e.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var t = new ot(1 / 0, 1 / 0, -1 / 0, -1 / 0), r = 0; r < this._displayables.length; r++) {
        var i = this._displayables[r], o = i.getBoundingRect().clone();
        i.needLocalTransform() && o.applyTransform(i.getLocalTransform(g_t)), t.union(o);
      }
      this._rect = t;
    }
    return this._rect;
  }, e.prototype.contain = function(t, r) {
    var i = this.transformCoordToLocal(t, r), o = this.getBoundingRect();
    if (o.contain(i[0], i[1]))
      for (var a = 0; a < this._displayables.length; a++) {
        var s = this._displayables[a];
        if (s.contain(t, r))
          return !0;
      }
    return !1;
  }, e;
}(Ia);
const m_t = v_t;
var Aee = It();
function Lv(n, e, t, r, i) {
  var o;
  if (e && e.ecModel) {
    var a = e.ecModel.getUpdatePayload();
    o = a && a.animation;
  }
  var s = e && e.isAnimationEnabled(), l = n === "update";
  if (s) {
    var u = void 0, c = void 0, h = void 0;
    r ? (u = qe(r.duration, 200), c = qe(r.easing, "cubicOut"), h = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), o && (o.duration != null && (u = o.duration), o.easing != null && (c = o.easing), o.delay != null && (h = o.delay)), Le(h) && (h = h(t, i)), Le(u) && (u = u(t));
    var f = {
      duration: u || 0,
      delay: h,
      easing: c
    };
    return f;
  } else
    return null;
}
function HR(n, e, t, r, i, o, a) {
  var s = !1, l;
  Le(i) ? (a = o, o = i, i = null) : Ne(i) && (o = i.cb, a = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
  var u = n === "leave";
  u || e.stopAnimation("leave");
  var c = Lv(n, r, i, u ? l || {} : null, r && r.getAnimationDelayParams ? r.getAnimationDelayParams(e, i) : null);
  if (c && c.duration > 0) {
    var h = c.duration, f = c.delay, d = c.easing, p = {
      duration: h,
      delay: f || 0,
      easing: d,
      done: o,
      force: !!o || !!a,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: n,
      during: a
    };
    s ? e.animateFrom(t, p) : e.animateTo(t, p);
  } else
    e.stopAnimation(), !s && e.attr(t), a && a(1), o && o();
}
function Vt(n, e, t, r, i, o) {
  HR("update", n, e, t, r, i, o);
}
function Cn(n, e, t, r, i, o) {
  HR("enter", n, e, t, r, i, o);
}
function Up(n) {
  if (!n.__zr)
    return !0;
  for (var e = 0; e < n.animators.length; e++) {
    var t = n.animators[e];
    if (t.scope === "leave")
      return !0;
  }
  return !1;
}
function Yc(n, e, t, r, i, o) {
  Up(n) || HR("leave", n, e, t, r, i, o);
}
function DF(n, e, t, r) {
  n.removeTextContent(), n.removeTextGuideLine(), Yc(n, {
    style: {
      opacity: 0
    }
  }, e, t, r);
}
function B0(n, e, t) {
  function r() {
    n.parent && n.parent.remove(n);
  }
  n.isGroup ? n.traverse(function(i) {
    i.isGroup || DF(i, e, t, r);
  }) : DF(n, e, t, r);
}
function ms(n) {
  Aee(n).oldStyle = n.style;
}
function y_t(n) {
  return Aee(n).oldStyle;
}
var yS = Math.max, bS = Math.min, WM = {};
function b_t(n) {
  return gt.extend(n);
}
var O_t = qSt;
function w_t(n, e) {
  return O_t(n, e);
}
function Cs(n, e) {
  WM[n] = e;
}
function qR(n) {
  if (WM.hasOwnProperty(n))
    return WM[n];
}
function TC(n, e, t, r) {
  var i = gee(n, e);
  return t && (r === "center" && (t = kee(t, i.getBoundingRect())), Pee(i, t)), i;
}
function Tee(n, e, t) {
  var r = new Si({
    style: {
      image: n,
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    onload: function(i) {
      if (t === "center") {
        var o = {
          width: i.width,
          height: i.height
        };
        r.setStyle(kee(e, o));
      }
    }
  });
  return r;
}
function kee(n, e) {
  var t = e.width / e.height, r = n.height * t, i;
  r <= n.width ? i = n.height : (r = n.width, i = r / t);
  var o = n.x + n.width / 2, a = n.y + n.height / 2;
  return {
    x: o - r / 2,
    y: a - i / 2,
    width: r,
    height: i
  };
}
var ma = YSt;
function Pee(n, e) {
  if (n.applyTransform) {
    var t = n.getBoundingRect(), r = t.calculateTransform(e);
    n.applyTransform(r);
  }
}
function Yg(n, e) {
  return XJ(n, n, {
    lineWidth: e
  }), n;
}
function x_t(n) {
  return UJ(n.shape, n.shape, n.style), n;
}
var Hw = wf;
function Wf(n, e) {
  for (var t = pC([]); n && n !== e; )
    eu(t, n.getLocalTransform(), t), n = n.parent;
  return t;
}
function cs(n, e, t) {
  return e && !Ni(e) && (e = Yl.getLocalTransform(e)), t && (e = Ev([], e)), vi([], n, e);
}
function kC(n, e, t) {
  var r = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), o = [n === "left" ? -r : n === "right" ? r : 0, n === "top" ? -i : n === "bottom" ? i : 0];
  return o = cs(o, e, t), Math.abs(o[0]) > Math.abs(o[1]) ? o[0] > 0 ? "right" : "left" : o[1] > 0 ? "bottom" : "top";
}
function LF(n) {
  return !n.isGroup;
}
function S_t(n) {
  return n.shape != null;
}
function Fb(n, e, t) {
  if (!n || !e)
    return;
  function r(a) {
    var s = {};
    return a.traverse(function(l) {
      LF(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function i(a) {
    var s = {
      x: a.x,
      y: a.y,
      rotation: a.rotation
    };
    return S_t(a) && (s.shape = re({}, a.shape)), s;
  }
  var o = r(n);
  e.traverse(function(a) {
    if (LF(a) && a.anid) {
      var s = o[a.anid];
      if (s) {
        var l = i(a);
        a.attr(i(s)), Vt(a, l, t, He(a).dataIndex);
      }
    }
  });
}
function Eee(n, e) {
  return le(n, function(t) {
    var r = t[0];
    r = yS(r, e.x), r = bS(r, e.x + e.width);
    var i = t[1];
    return i = yS(i, e.y), i = bS(i, e.y + e.height), [r, i];
  });
}
function __t(n, e) {
  var t = yS(n.x, e.x), r = bS(n.x + n.width, e.x + e.width), i = yS(n.y, e.y), o = bS(n.y + n.height, e.y + e.height);
  if (r >= t && o >= i)
    return {
      x: t,
      y: i,
      width: r - t,
      height: o - i
    };
}
function Qb(n, e, t) {
  var r = re({
    rectHover: !0
  }, e), i = r.style = {
    strokeNoScale: !0
  };
  if (t = t || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, n)
    return n.indexOf("image://") === 0 ? (i.image = n.slice(8), Be(i, t), new Si(r)) : TC(n.replace("path://", ""), r, t, "center");
}
function Km(n, e, t, r, i) {
  for (var o = 0, a = i[i.length - 1]; o < i.length; o++) {
    var s = i[o];
    if (Mee(n, e, t, r, s[0], s[1], a[0], a[1]))
      return !0;
    a = s;
  }
}
function Mee(n, e, t, r, i, o, a, s) {
  var l = t - n, u = r - e, c = a - i, h = s - o, f = eT(c, h, l, u);
  if (C_t(f))
    return !1;
  var d = n - i, p = e - o, g = eT(d, p, l, u) / f;
  if (g < 0 || g > 1)
    return !1;
  var v = eT(d, p, c, h) / f;
  return !(v < 0 || v > 1);
}
function eT(n, e, t, r) {
  return n * r - t * e;
}
function C_t(n) {
  return n <= 1e-6 && n >= -1e-6;
}
function Iv(n) {
  var e = n.itemTooltipOption, t = n.componentModel, r = n.itemName, i = we(e) ? {
    formatter: e
  } : e, o = t.mainType, a = t.componentIndex, s = {
    componentType: o,
    name: r,
    $vars: ["name"]
  };
  s[o + "Index"] = a;
  var l = n.formatterParamsExtra;
  l && I(Ot(l), function(c) {
    Ce(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = He(n.el);
  u.componentMainType = o, u.componentIndex = a, u.tooltipConfig = {
    name: r,
    option: Be({
      content: r,
      formatterParams: s
    }, i)
  };
}
function IF(n, e) {
  var t;
  n.isGroup && (t = e(n)), t || n.traverse(e);
}
function dh(n, e) {
  if (n)
    if (se(n))
      for (var t = 0; t < n.length; t++)
        IF(n[t], e);
    else
      IF(n, e);
}
Cs("circle", fh);
Cs("ellipse", WR);
Cs("sector", Eo);
Cs("ring", CC);
Cs("polygon", ro);
Cs("polyline", io);
Cs("rect", Lt);
Cs("line", Br);
Cs("bezierCurve", AC);
Cs("arc", GR);
const Dd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: GR,
  BezierCurve: AC,
  BoundingRect: ot,
  Circle: fh,
  CompoundPath: jR,
  Ellipse: WR,
  Group: We,
  Image: Si,
  IncrementalDisplayable: m_t,
  Line: Br,
  LinearGradient: zb,
  OrientedBoundingRect: mS,
  Path: gt,
  Point: nt,
  Polygon: ro,
  Polyline: io,
  RadialGradient: Cee,
  Rect: Lt,
  Ring: CC,
  Sector: Eo,
  Text: Nt,
  applyTransform: cs,
  clipPointsByRect: Eee,
  clipRectByRect: __t,
  createIcon: Qb,
  extendPath: w_t,
  extendShape: b_t,
  getShapeClass: qR,
  getTransform: Wf,
  groupTransition: Fb,
  initProps: Cn,
  isElementRemoved: Up,
  lineLineIntersect: Mee,
  linePolygonIntersect: Km,
  makeImage: Tee,
  makePath: TC,
  mergePath: ma,
  registerShape: Cs,
  removeElement: Yc,
  removeElementWithFadeOut: B0,
  resizePath: Pee,
  setTooltipConfig: Iv,
  subPixelOptimize: Hw,
  subPixelOptimizeLine: Yg,
  subPixelOptimizeRect: x_t,
  transformDirection: kC,
  traverseElements: dh,
  updateProps: Vt
}, Symbol.toStringTag, { value: "Module" }));
var PC = {};
function Dee(n, e) {
  for (var t = 0; t < no.length; t++) {
    var r = no[t], i = e[r], o = n.ensureState(r);
    o.style = o.style || {}, o.style.text = i;
  }
  var a = n.currentStates.slice();
  n.clearStates(!0), n.setStyle({
    text: e.normal
  }), n.useStates(a, !0);
}
function GM(n, e, t) {
  var r = n.labelFetcher, i = n.labelDataIndex, o = n.labelDimIndex, a = e.normal, s;
  r && (s = r.getFormattedLabel(i, "normal", null, o, a && a.get("formatter"), t != null ? {
    interpolatedValue: t
  } : null)), s == null && (s = Le(n.defaultText) ? n.defaultText(i, n, t) : n.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < no.length; u++) {
    var c = no[u], h = e[c];
    l[c] = qe(r ? r.getFormattedLabel(i, c, null, o, h && h.get("formatter")) : null, s);
  }
  return l;
}
function wi(n, e, t, r) {
  t = t || PC;
  for (var i = n instanceof Nt, o = !1, a = 0; a < $0.length; a++) {
    var s = e[$0[a]];
    if (s && s.getShallow("show")) {
      o = !0;
      break;
    }
  }
  var l = i ? n : n.getTextContent();
  if (o) {
    i || (l || (l = new Nt(), n.setTextContent(l)), n.stateProxy && (l.stateProxy = n.stateProxy));
    var u = GM(t, e), c = e.normal, h = !!c.getShallow("show"), f = vn(c, r && r.normal, t, !1, !i);
    f.text = u.normal, i || n.setTextConfig(OS(c, t, !1));
    for (var a = 0; a < no.length; a++) {
      var d = no[a], s = e[d];
      if (s) {
        var p = l.ensureState(d), g = !!qe(s.getShallow("show"), h);
        if (g !== h && (p.ignore = !g), p.style = vn(s, r && r[d], t, !0, !i), p.style.text = u[d], !i) {
          var v = n.ensureState(d);
          v.textConfig = OS(s, t, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !h, l.useStyle(f), l.dirty(), t.enableTextSetter && (Rv(l).setLabelText = function(m) {
      var y = GM(t, e, m);
      Dee(l, y);
    });
  } else
    l && (l.ignore = !0);
  n.dirty();
}
function Fr(n, e) {
  e = e || "label";
  for (var t = {
    normal: n.getModel(e)
  }, r = 0; r < no.length; r++) {
    var i = no[r];
    t[i] = n.getModel([i, e]);
  }
  return t;
}
function vn(n, e, t, r, i) {
  var o = {};
  return A_t(o, n, t, r, i), e && re(o, e), o;
}
function OS(n, e, t) {
  e = e || {};
  var r = {}, i, o = n.getShallow("rotate"), a = qe(n.getShallow("distance"), t ? null : 5), s = n.getShallow("offset");
  return i = n.getShallow("position") || (t ? null : "inside"), i === "outside" && (i = e.defaultOutsidePosition || "top"), i != null && (r.position = i), s != null && (r.offset = s), o != null && (o *= Math.PI / 180, r.rotation = o), a != null && (r.distance = a), r.outsideFill = n.get("color") === "inherit" ? e.inheritColor || null : "auto", r;
}
function A_t(n, e, t, r, i) {
  t = t || PC;
  var o = e.ecModel, a = o && o.option.textStyle, s = T_t(e), l;
  if (s) {
    l = {};
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var c = e.getModel(["rich", u]);
        BF(l[u] = {}, c, a, t, r, i, !1, !0);
      }
  }
  l && (n.rich = l);
  var h = e.get("overflow");
  h && (n.overflow = h);
  var f = e.get("minMargin");
  f != null && (n.margin = f), BF(n, e, a, t, r, i, !0, !1);
}
function T_t(n) {
  for (var e; n && n !== n.ecModel; ) {
    var t = (n.option || PC).rich;
    if (t) {
      e = e || {};
      for (var r = Ot(t), i = 0; i < r.length; i++) {
        var o = r[i];
        e[o] = 1;
      }
    }
    n = n.parentModel;
  }
  return e;
}
var RF = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], NF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], $F = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function BF(n, e, t, r, i, o, a, s) {
  t = !i && t || PC;
  var l = r && r.inheritColor, u = e.getShallow("color"), c = e.getShallow("textBorderColor"), h = qe(e.getShallow("opacity"), t.opacity);
  (u === "inherit" || u === "auto") && (process.env.NODE_ENV !== "production" && u === "auto" && lr("color: 'auto'", "color: 'inherit'"), l ? u = l : u = null), (c === "inherit" || c === "auto") && (process.env.NODE_ENV !== "production" && c === "auto" && lr("color: 'auto'", "color: 'inherit'"), l ? c = l : c = null), o || (u = u || t.color, c = c || t.textBorderColor), u != null && (n.fill = u), c != null && (n.stroke = c);
  var f = qe(e.getShallow("textBorderWidth"), t.textBorderWidth);
  f != null && (n.lineWidth = f);
  var d = qe(e.getShallow("textBorderType"), t.textBorderType);
  d != null && (n.lineDash = d);
  var p = qe(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset);
  p != null && (n.lineDashOffset = p), !i && h == null && !s && (h = r && r.defaultOpacity), h != null && (n.opacity = h), !i && !o && n.fill == null && r.inheritColor && (n.fill = r.inheritColor);
  for (var g = 0; g < RF.length; g++) {
    var v = RF[g], m = qe(e.getShallow(v), t[v]);
    m != null && (n[v] = m);
  }
  for (var g = 0; g < NF.length; g++) {
    var v = NF[g], m = e.getShallow(v);
    m != null && (n[v] = m);
  }
  if (n.verticalAlign == null) {
    var y = e.getShallow("baseline");
    y != null && (n.verticalAlign = y);
  }
  if (!a || !r.disableBox) {
    for (var g = 0; g < $F.length; g++) {
      var v = $F[g], m = e.getShallow(v);
      m != null && (n[v] = m);
    }
    var b = e.getShallow("borderType");
    b != null && (n.borderDash = b), (n.backgroundColor === "auto" || n.backgroundColor === "inherit") && l && (process.env.NODE_ENV !== "production" && n.backgroundColor === "auto" && lr("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), n.backgroundColor = l), (n.borderColor === "auto" || n.borderColor === "inherit") && l && (process.env.NODE_ENV !== "production" && n.borderColor === "auto" && lr("borderColor: 'auto'", "borderColor: 'inherit'"), n.borderColor = l);
  }
}
function YR(n, e) {
  var t = e && e.getModel("textStyle");
  return is([
    // FIXME in node-canvas fontWeight is before fontStyle
    n.fontStyle || t && t.getShallow("fontStyle") || "",
    n.fontWeight || t && t.getShallow("fontWeight") || "",
    (n.fontSize || t && t.getShallow("fontSize") || 12) + "px",
    n.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var Rv = It();
function Lee(n, e, t, r) {
  if (n) {
    var i = Rv(n);
    i.prevValue = i.value, i.value = t;
    var o = e.normal;
    i.valueAnimation = o.get("valueAnimation"), i.valueAnimation && (i.precision = o.get("precision"), i.defaultInterpolatedText = r, i.statesModels = e);
  }
}
function Iee(n, e, t, r, i) {
  var o = Rv(n);
  if (!o.valueAnimation || o.prevValue === o.value)
    return;
  var a = o.defaultInterpolatedText, s = qe(o.interpolatedValue, o.prevValue), l = o.value;
  function u(c) {
    var h = zJ(t, o.precision, s, l, c);
    o.interpolatedValue = c === 1 ? null : h;
    var f = GM({
      labelDataIndex: e,
      labelFetcher: i,
      defaultText: a ? a(h) : h + ""
    }, o.statesModels, h);
    Dee(n, f);
  }
  n.percent = 0, (o.prevValue == null ? Cn : Vt)(n, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, r, e, null, u);
}
var k_t = ["textStyle", "color"], tT = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], nT = new Nt(), P_t = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getTextColor = function(e) {
      var t = this.ecModel;
      return this.getShallow("color") || (!e && t ? t.get(k_t) : null);
    }, n.prototype.getFont = function() {
      return YR({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, n.prototype.getTextRect = function(e) {
      for (var t = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, r = 0; r < tT.length; r++)
        t[tT[r]] = this.getShallow(tT[r]);
      return nT.useStyle(t), nT.update(), nT.getBoundingRect();
    }, n;
  }()
);
const E_t = P_t;
var Ree = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], M_t = dd(Ree), D_t = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getLineStyle = function(e) {
      return M_t(this, e);
    }, n;
  }()
), Nee = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], L_t = dd(Nee), I_t = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getItemStyle = function(e, t) {
      return L_t(this, e, t);
    }, n;
  }()
), Ld = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.parentModel = t, this.ecModel = r, this.option = e;
    }
    return n.prototype.init = function(e, t, r) {
    }, n.prototype.mergeOption = function(e, t) {
      it(this.option, e, !0);
    }, n.prototype.get = function(e, t) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel);
    }, n.prototype.getShallow = function(e, t) {
      var r = this.option, i = r == null ? r : r[e];
      if (i == null && !t) {
        var o = this.parentModel;
        o && (i = o.getShallow(e));
      }
      return i;
    }, n.prototype.getModel = function(e, t) {
      var r = e != null, i = r ? this.parsePath(e) : null, o = r ? this._doGet(i) : this.option;
      return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new n(o, t, this.ecModel);
    }, n.prototype.isEmpty = function() {
      return this.option == null;
    }, n.prototype.restoreData = function() {
    }, n.prototype.clone = function() {
      var e = this.constructor;
      return new e(Fe(this.option));
    }, n.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, n.prototype.resolveParentPath = function(e) {
      return e;
    }, n.prototype.isAnimationEnabled = function() {
      if (!mt.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, n.prototype._doGet = function(e, t) {
      var r = this.option;
      if (!e)
        return r;
      for (var i = 0; i < e.length && !(e[i] && (r = r && typeof r == "object" ? r[e[i]] : null, r == null)); i++)
        ;
      return r == null && t && (r = t._doGet(this.resolveParentPath(e), t.parentModel)), r;
    }, n;
  }()
);
RR(Ld);
Nxt(Ld);
mr(Ld, D_t);
mr(Ld, I_t);
mr(Ld, Fxt);
mr(Ld, E_t);
const mn = Ld;
var R_t = Math.round(Math.random() * 10);
function Nv(n) {
  return [n || "", R_t++].join("_");
}
function N_t(n) {
  var e = {};
  n.registerSubTypeDefaulter = function(t, r) {
    var i = il(t);
    e[i.main] = r;
  }, n.determineSubType = function(t, r) {
    var i = r.type;
    if (!i) {
      var o = il(t).main;
      n.hasSubTypes(t) && e[o] && (i = e[o](r));
    }
    return i;
  };
}
function $_t(n, e) {
  n.topologicalTravel = function(o, a, s, l) {
    if (!o.length)
      return;
    var u = t(a), c = u.graph, h = u.noEntryList, f = {};
    for (I(o, function(y) {
      f[y] = !0;
    }); h.length; ) {
      var d = h.pop(), p = c[d], g = !!f[d];
      g && (s.call(l, d, p.originalDeps.slice()), delete f[d]), I(p.successor, g ? m : v);
    }
    I(f, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = to("Circular dependency may exists: ", f, o, a)), new Error(y);
    });
    function v(y) {
      c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
    }
    function m(y) {
      f[y] = !0, v(y);
    }
  };
  function t(o) {
    var a = {}, s = [];
    return I(o, function(l) {
      var u = r(a, l), c = u.originalDeps = e(l), h = i(c, o);
      u.entryCount = h.length, u.entryCount === 0 && s.push(l), I(h, function(f) {
        ct(u.predecessor, f) < 0 && u.predecessor.push(f);
        var d = r(a, f);
        ct(d.successor, f) < 0 && d.successor.push(l);
      });
    }), {
      graph: a,
      noEntryList: s
    };
  }
  function r(o, a) {
    return o[a] || (o[a] = {
      predecessor: [],
      successor: []
    }), o[a];
  }
  function i(o, a) {
    var s = [];
    return I(o, function(l) {
      ct(a, l) >= 0 && s.push(l);
    }), s;
  }
}
function ph(n, e) {
  return it(it({}, n, !0), e, !0);
}
const B_t = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, V_t = {
  time: {
    month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
    dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
  },
  legend: {
    selector: {
      all: "全选",
      inverse: "反选"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "矩形选择",
        polygon: "圈选",
        lineX: "横向选择",
        lineY: "纵向选择",
        keep: "保持选择",
        clear: "清除选择"
      }
    },
    dataView: {
      title: "数据视图",
      lang: ["数据视图", "关闭", "刷新"]
    },
    dataZoom: {
      title: {
        zoom: "区域缩放",
        back: "区域缩放还原"
      }
    },
    magicType: {
      title: {
        line: "切换为折线图",
        bar: "切换为柱状图",
        stack: "切换为堆叠",
        tiled: "切换为平铺"
      }
    },
    restore: {
      title: "还原"
    },
    saveAsImage: {
      title: "保存为图片",
      lang: ["右键另存为图片"]
    }
  },
  series: {
    typeNames: {
      pie: "饼图",
      bar: "柱状图",
      line: "折线图",
      scatter: "散点图",
      effectScatter: "涟漪散点图",
      radar: "雷达图",
      tree: "树图",
      treemap: "矩形树图",
      boxplot: "箱型图",
      candlestick: "K线图",
      k: "K线图",
      heatmap: "热力图",
      map: "地图",
      parallel: "平行坐标图",
      lines: "线图",
      graph: "关系图",
      sankey: "桑基图",
      funnel: "漏斗图",
      gauge: "仪表盘图",
      pictorialBar: "象形柱图",
      themeRiver: "主题河流图",
      sunburst: "旭日图",
      custom: "自定义图表",
      chart: "图表"
    }
  },
  aria: {
    general: {
      withTitle: "这是一个关于“{title}”的图表。",
      withoutTitle: "这是一个图表，"
    },
    series: {
      single: {
        prefix: "",
        withName: "图表类型是{seriesType}，表示{seriesName}。",
        withoutName: "图表类型是{seriesType}。"
      },
      multiple: {
        prefix: "它由{seriesCount}个图表系列组成。",
        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
        withoutName: "第{seriesId}个系列是一个{seriesType}，",
        separator: {
          middle: "；",
          end: "。"
        }
      }
    },
    data: {
      allData: "其数据是——",
      partialData: "其中，前{displayCnt}项是——",
      withName: "{name}的数据是{value}",
      withoutName: "{value}",
      separator: {
        middle: "，",
        end: ""
      }
    }
  }
};
var wS = "ZH", XR = "EN", Kp = XR, qw = {}, UR = {}, $ee = mt.domSupported ? function() {
  var n = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Kp).toUpperCase()
  );
  return n.indexOf(wS) > -1 ? wS : Kp;
}() : Kp;
function Bee(n, e) {
  n = n.toUpperCase(), UR[n] = new mn(e), qw[n] = e;
}
function z_t(n) {
  if (we(n)) {
    var e = qw[n.toUpperCase()] || {};
    return n === wS || n === XR ? Fe(e) : it(Fe(e), Fe(qw[Kp]), !1);
  } else
    return it(Fe(n), Fe(qw[Kp]), !1);
}
function jM(n) {
  return UR[n];
}
function F_t() {
  return UR[Kp];
}
Bee(XR, B_t);
Bee(wS, V_t);
var KR = 1e3, JR = KR * 60, By = JR * 60, ya = By * 24, VF = ya * 365, Jm = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, vO = "{yyyy}-{MM}-{dd}", zF = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: vO,
  hour: vO + " " + Jm.hour,
  minute: vO + " " + Jm.minute,
  second: vO + " " + Jm.second,
  millisecond: Jm.none
}, rT = ["year", "month", "day", "hour", "minute", "second", "millisecond"], Vee = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function Ru(n, e) {
  return n += "", "0000".substr(0, e - n.length) + n;
}
function Jp(n) {
  switch (n) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return n;
  }
}
function Q_t(n) {
  return n === Jp(n);
}
function Z_t(n) {
  switch (n) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function EC(n, e, t, r) {
  var i = Cl(n), o = i[eN(t)](), a = i[eg(t)]() + 1, s = Math.floor((a - 1) / 3) + 1, l = i[MC(t)](), u = i["get" + (t ? "UTC" : "") + "Day"](), c = i[V0(t)](), h = (c - 1) % 12 + 1, f = i[DC(t)](), d = i[LC(t)](), p = i[IC(t)](), g = r instanceof mn ? r : jM(r || $ee) || F_t(), v = g.getModel("time"), m = v.get("month"), y = v.get("monthAbbr"), b = v.get("dayOfWeek"), O = v.get("dayOfWeekAbbr");
  return (e || "").replace(/{yyyy}/g, o + "").replace(/{yy}/g, Ru(o % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, m[a - 1]).replace(/{MMM}/g, y[a - 1]).replace(/{MM}/g, Ru(a, 2)).replace(/{M}/g, a + "").replace(/{dd}/g, Ru(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, b[u]).replace(/{ee}/g, O[u]).replace(/{e}/g, u + "").replace(/{HH}/g, Ru(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, Ru(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, Ru(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, Ru(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, Ru(p, 3)).replace(/{S}/g, p + "");
}
function W_t(n, e, t, r, i) {
  var o = null;
  if (we(t))
    o = t;
  else if (Le(t))
    o = t(n.value, e, {
      level: n.level
    });
  else {
    var a = re({}, Jm);
    if (n.level > 0)
      for (var s = 0; s < rT.length; ++s)
        a[rT[s]] = "{primary|" + a[rT[s]] + "}";
    var l = t ? t.inherit === !1 ? t : Be(t, a) : a, u = zee(n.value, i);
    if (l[u])
      o = l[u];
    else if (l.inherit) {
      for (var c = Vee.indexOf(u), s = c - 1; s >= 0; --s)
        if (l[u]) {
          o = l[u];
          break;
        }
      o = o || a.none;
    }
    if (se(o)) {
      var h = n.level == null ? 0 : n.level >= 0 ? n.level : o.length + n.level;
      h = Math.min(h, o.length - 1), o = o[h];
    }
  }
  return EC(new Date(n.value), o, i, r);
}
function zee(n, e) {
  var t = Cl(n), r = t[eg(e)]() + 1, i = t[MC(e)](), o = t[V0(e)](), a = t[DC(e)](), s = t[LC(e)](), l = t[IC(e)](), u = l === 0, c = u && s === 0, h = c && a === 0, f = h && o === 0, d = f && i === 1, p = d && r === 1;
  return p ? "year" : d ? "month" : f ? "day" : h ? "hour" : c ? "minute" : u ? "second" : "millisecond";
}
function FF(n, e, t) {
  var r = $t(n) ? Cl(n) : n;
  switch (e = e || zee(n, t), e) {
    case "year":
      return r[eN(t)]();
    case "half-year":
      return r[eg(t)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((r[eg(t)]() + 1) / 4);
    case "month":
      return r[eg(t)]();
    case "day":
      return r[MC(t)]();
    case "half-day":
      return r[V0(t)]() / 24;
    case "hour":
      return r[V0(t)]();
    case "minute":
      return r[DC(t)]();
    case "second":
      return r[LC(t)]();
    case "millisecond":
      return r[IC(t)]();
  }
}
function eN(n) {
  return n ? "getUTCFullYear" : "getFullYear";
}
function eg(n) {
  return n ? "getUTCMonth" : "getMonth";
}
function MC(n) {
  return n ? "getUTCDate" : "getDate";
}
function V0(n) {
  return n ? "getUTCHours" : "getHours";
}
function DC(n) {
  return n ? "getUTCMinutes" : "getMinutes";
}
function LC(n) {
  return n ? "getUTCSeconds" : "getSeconds";
}
function IC(n) {
  return n ? "getUTCMilliseconds" : "getMilliseconds";
}
function G_t(n) {
  return n ? "setUTCFullYear" : "setFullYear";
}
function Fee(n) {
  return n ? "setUTCMonth" : "setMonth";
}
function Qee(n) {
  return n ? "setUTCDate" : "setDate";
}
function Zee(n) {
  return n ? "setUTCHours" : "setHours";
}
function Wee(n) {
  return n ? "setUTCMinutes" : "setMinutes";
}
function Gee(n) {
  return n ? "setUTCSeconds" : "setSeconds";
}
function jee(n) {
  return n ? "setUTCMilliseconds" : "setMilliseconds";
}
function Hee(n) {
  if (!DR(n))
    return we(n) ? n : "-";
  var e = (n + "").split(".");
  return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
}
function qee(n, e) {
  return n = (n || "").toLowerCase().replace(/-(.)/g, function(t, r) {
    return r.toUpperCase();
  }), e && n && (n = n.charAt(0).toUpperCase() + n.slice(1)), n;
}
var $v = _R;
function HM(n, e, t) {
  var r = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function i(c) {
    return c && is(c) ? c : "-";
  }
  function o(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var a = e === "time", s = n instanceof Date;
  if (a || s) {
    var l = a ? Cl(n) : n;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else
      return EC(l, r, t);
  }
  if (e === "ordinal")
    return oS(n) ? i(n) : $t(n) && o(n) ? n + "" : "-";
  var u = pu(n);
  return o(u) ? Hee(u) : oS(n) ? i(n) : typeof n == "boolean" ? n + "" : "-";
}
var QF = ["a", "b", "c", "d", "e", "f", "g"], iT = function(n, e) {
  return "{" + n + (e ?? "") + "}";
};
function Yee(n, e, t) {
  se(e) || (e = [e]);
  var r = e.length;
  if (!r)
    return "";
  for (var i = e[0].$vars || [], o = 0; o < i.length; o++) {
    var a = QF[o];
    n = n.replace(iT(a), iT(a, 0));
  }
  for (var s = 0; s < r; s++)
    for (var l = 0; l < i.length; l++) {
      var u = e[s][i[l]];
      n = n.replace(iT(QF[l], s), t ? mo(u) : u);
    }
  return n;
}
function j_t(n, e, t) {
  return I(e, function(r, i) {
    n = n.replace("{" + i + "}", t ? mo(r) : r);
  }), n;
}
function H_t(n, e) {
  var t = we(n) ? {
    color: n,
    extraCssText: e
  } : n || {}, r = t.color, i = t.type;
  e = t.extraCssText;
  var o = t.renderMode || "html";
  if (!r)
    return "";
  if (o === "html")
    return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + mo(r) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + mo(r) + ";" + (e || "") + '"></span>';
  var a = t.markerId || "markerX";
  return {
    renderMode: o,
    content: "{" + a + "|}  ",
    style: i === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: r
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: r
    }
  };
}
function gd(n, e) {
  return e = e || "transparent", we(n) ? n : Ne(n) && n.colorStops && (n.colorStops[0] || {}).color || e;
}
function xS(n, e) {
  if (e === "_blank" || e === "blank") {
    var t = window.open();
    t.opener = null, t.location.href = n;
  } else
    window.open(n, e);
}
var Yw = I, Xee = ["left", "right", "top", "bottom", "width", "height"], Sf = [["width", "left", "right"], ["height", "top", "bottom"]];
function tN(n, e, t, r, i) {
  var o = 0, a = 0;
  r == null && (r = 1 / 0), i == null && (i = 1 / 0);
  var s = 0;
  e.eachChild(function(l, u) {
    var c = l.getBoundingRect(), h = e.childAt(u + 1), f = h && h.getBoundingRect(), d, p;
    if (n === "horizontal") {
      var g = c.width + (f ? -f.x + c.x : 0);
      d = o + g, d > r || l.newline ? (o = 0, d = g, a += s + t, s = c.height) : s = Math.max(s, c.height);
    } else {
      var v = c.height + (f ? -f.y + c.y : 0);
      p = a + v, p > i || l.newline ? (o += s + t, a = 0, p = v, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = o, l.y = a, l.markRedraw(), n === "horizontal" ? o = d + t : a = p + t);
  });
}
var Gf = tN;
Je(tN, "vertical");
Je(tN, "horizontal");
function q_t(n, e, t) {
  var r = e.width, i = e.height, o = be(n.left, r), a = be(n.top, i), s = be(n.right, r), l = be(n.bottom, i);
  return (isNaN(o) || isNaN(parseFloat(n.left))) && (o = 0), (isNaN(s) || isNaN(parseFloat(n.right))) && (s = r), (isNaN(a) || isNaN(parseFloat(n.top))) && (a = 0), (isNaN(l) || isNaN(parseFloat(n.bottom))) && (l = i), t = $v(t || 0), {
    width: Math.max(s - o - t[1] - t[3], 0),
    height: Math.max(l - a - t[0] - t[2], 0)
  };
}
function Cr(n, e, t) {
  t = $v(t || 0);
  var r = e.width, i = e.height, o = be(n.left, r), a = be(n.top, i), s = be(n.right, r), l = be(n.bottom, i), u = be(n.width, r), c = be(n.height, i), h = t[2] + t[0], f = t[1] + t[3], d = n.aspect;
  switch (isNaN(u) && (u = r - s - f - o), isNaN(c) && (c = i - l - h - a), d != null && (isNaN(u) && isNaN(c) && (d > r / i ? u = r * 0.8 : c = i * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(o) && (o = r - s - u - f), isNaN(a) && (a = i - l - c - h), n.left || n.right) {
    case "center":
      o = r / 2 - u / 2 - t[3];
      break;
    case "right":
      o = r - u - f;
      break;
  }
  switch (n.top || n.bottom) {
    case "middle":
    case "center":
      a = i / 2 - c / 2 - t[0];
      break;
    case "bottom":
      a = i - c - h;
      break;
  }
  o = o || 0, a = a || 0, isNaN(u) && (u = r - f - o - (s || 0)), isNaN(c) && (c = i - h - a - (l || 0));
  var p = new ot(o + t[3], a + t[0], u, c);
  return p.margin = t, p;
}
function RC(n, e, t, r, i, o) {
  var a = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
  if (o = o || n, o.x = n.x, o.y = n.y, !a && !s)
    return !1;
  var u;
  if (l === "raw")
    u = n.type === "group" ? new ot(0, 0, +e.width || 0, +e.height || 0) : n.getBoundingRect();
  else if (u = n.getBoundingRect(), n.needLocalTransform()) {
    var c = n.getLocalTransform();
    u = u.clone(), u.applyTransform(c);
  }
  var h = Cr(Be({
    width: u.width,
    height: u.height
  }, e), t, r), f = a ? h.x - u.x : 0, d = s ? h.y - u.y : 0;
  return l === "raw" ? (o.x = f, o.y = d) : (o.x += f, o.y += d), o === n && n.markRedraw(), !0;
}
function Y_t(n, e) {
  return n[Sf[e][0]] != null || n[Sf[e][1]] != null && n[Sf[e][2]] != null;
}
function z0(n) {
  var e = n.layoutMode || n.constructor.layoutMode;
  return Ne(e) ? e : e ? {
    type: e
  } : null;
}
function Xc(n, e, t) {
  var r = t && t.ignoreSize;
  !se(r) && (r = [r, r]);
  var i = a(Sf[0], 0), o = a(Sf[1], 1);
  u(Sf[0], n, i), u(Sf[1], n, o);
  function a(c, h) {
    var f = {}, d = 0, p = {}, g = 0, v = 2;
    if (Yw(c, function(b) {
      p[b] = n[b];
    }), Yw(c, function(b) {
      s(e, b) && (f[b] = p[b] = e[b]), l(f, b) && d++, l(p, b) && g++;
    }), r[h])
      return l(e, c[1]) ? p[c[2]] = null : l(e, c[2]) && (p[c[1]] = null), p;
    if (g === v || !d)
      return p;
    if (d >= v)
      return f;
    for (var m = 0; m < c.length; m++) {
      var y = c[m];
      if (!s(f, y) && s(n, y)) {
        f[y] = n[y];
        break;
      }
    }
    return f;
  }
  function s(c, h) {
    return c.hasOwnProperty(h);
  }
  function l(c, h) {
    return c[h] != null && c[h] !== "auto";
  }
  function u(c, h, f) {
    Yw(c, function(d) {
      h[d] = f[d];
    });
  }
}
function Bv(n) {
  return Uee({}, n);
}
function Uee(n, e) {
  return e && n && Yw(Xee, function(t) {
    e.hasOwnProperty(t) && (n[t] = e[t]);
  }), n;
}
var X_t = It(), Vv = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this, t, r, i) || this;
      return o.uid = Nv("ec_cpt_model"), o;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.mergeDefaultAndTheme = function(t, r) {
      var i = z0(this), o = i ? Bv(t) : {}, a = r.getTheme();
      it(t, a.get(this.mainType)), it(t, this.getDefaultOption()), i && Xc(t, o, i);
    }, e.prototype.mergeOption = function(t, r) {
      it(this.option, t, !0);
      var i = z0(this);
      i && Xc(this.option, t, i);
    }, e.prototype.optionUpdated = function(t, r) {
    }, e.prototype.getDefaultOption = function() {
      var t = this.constructor;
      if (!Lxt(t))
        return t.defaultOption;
      var r = X_t(this);
      if (!r.defaultOption) {
        for (var i = [], o = t; o; ) {
          var a = o.prototype.defaultOption;
          a && i.push(a), o = o.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--)
          s = it(s, i[l], !0);
        r.defaultOption = s;
      }
      return r.defaultOption;
    }, e.prototype.getReferringComponents = function(t, r) {
      var i = t + "Index", o = t + "Id";
      return Bb(this.ecModel, t, {
        index: this.get(i, !0),
        id: this.get(o, !0)
      }, r);
    }, e.prototype.getBoxLayoutParams = function() {
      var t = this;
      return {
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(t) {
      this.option.zlevel = t;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
    }(), e;
  }(mn)
);
QJ(Vv, mn);
bC(Vv);
N_t(Vv);
$_t(Vv, U_t);
function U_t(n) {
  var e = [];
  return I(Vv.getClassesByMainType(n), function(t) {
    e = e.concat(t.dependencies || t.prototype.dependencies || []);
  }), e = le(e, function(t) {
    return il(t).main;
  }), n !== "dataset" && ct(e, "dataset") <= 0 && e.unshift("dataset"), e;
}
const Pt = Vv;
var Kee = "";
typeof navigator < "u" && (Kee = navigator.platform || "");
var np = "rgba(0, 0, 0, 0.2)";
const K_t = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: np,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: np,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: np,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: np,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: np,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: np,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: Kee.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var qM = Ee(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Va = "original", $i = "arrayRows", za = "objectRows", Il = "keyedColumns", nu = "typedArray", Jee = "unknown", pl = "column", zv = "row", ti = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, ete = It();
function J_t(n) {
  ete(n).datasetMap = Ee();
}
function tte(n, e, t) {
  var r = {}, i = rN(e);
  if (!i || !n)
    return r;
  var o = [], a = [], s = e.ecModel, l = ete(s).datasetMap, u = i.uid + "_" + t.seriesLayoutBy, c, h;
  n = n.slice(), I(n, function(g, v) {
    var m = Ne(g) ? g : n[v] = {
      name: g
    };
    m.type === "ordinal" && c == null && (c = v, h = p(m)), r[m.name] = [];
  });
  var f = l.get(u) || l.set(u, {
    categoryWayDim: h,
    valueWayDim: 0
  });
  I(n, function(g, v) {
    var m = g.name, y = p(g);
    if (c == null) {
      var b = f.valueWayDim;
      d(r[m], b, y), d(a, b, y), f.valueWayDim += y;
    } else if (c === v)
      d(r[m], 0, y), d(o, 0, y);
    else {
      var b = f.categoryWayDim;
      d(r[m], b, y), d(a, b, y), f.categoryWayDim += y;
    }
  });
  function d(g, v, m) {
    for (var y = 0; y < m; y++)
      g.push(v + y);
  }
  function p(g) {
    var v = g.dimsDef;
    return v ? v.length : 1;
  }
  return o.length && (r.itemName = o), a.length && (r.seriesName = a), r;
}
function nN(n, e, t) {
  var r = {}, i = rN(n);
  if (!i)
    return r;
  var o = e.sourceFormat, a = e.dimensionsDefine, s;
  (o === za || o === Il) && I(a, function(c, h) {
    (Ne(c) ? c.name : c) === "name" && (s = h);
  });
  var l = function() {
    for (var c = {}, h = {}, f = [], d = 0, p = Math.min(5, t); d < p; d++) {
      var g = rte(e.data, o, e.seriesLayoutBy, a, e.startIndex, d);
      f.push(g);
      var v = g === ti.Not;
      if (v && c.v == null && d !== s && (c.v = d), (c.n == null || c.n === c.v || !v && f[c.n] === ti.Not) && (c.n = d), m(c) && f[c.n] !== ti.Not)
        return c;
      v || (g === ti.Might && h.v == null && d !== s && (h.v = d), (h.n == null || h.n === h.v) && (h.n = d));
    }
    function m(y) {
      return y.v != null && y.n != null;
    }
    return m(c) ? c : m(h) ? h : null;
  }();
  if (l) {
    r.value = [l.v];
    var u = s ?? l.n;
    r.itemName = [u], r.seriesName = [u];
  }
  return r;
}
function rN(n) {
  var e = n.get("data", !0);
  if (!e)
    return Bb(n.ecModel, "dataset", {
      index: n.get("datasetIndex", !0),
      id: n.get("datasetId", !0)
    }, cr).models[0];
}
function eCt(n) {
  return !n.get("transform", !0) && !n.get("fromTransformResult", !0) ? [] : Bb(n.ecModel, "dataset", {
    index: n.get("fromDatasetIndex", !0),
    id: n.get("fromDatasetId", !0)
  }, cr).models;
}
function nte(n, e) {
  return rte(n.data, n.sourceFormat, n.seriesLayoutBy, n.dimensionsDefine, n.startIndex, e);
}
function rte(n, e, t, r, i, o) {
  var a, s = 5;
  if (eo(n))
    return ti.Not;
  var l, u;
  if (r) {
    var c = r[o];
    Ne(c) ? (l = c.name, u = c.type) : we(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? ti.Must : ti.Not;
  if (e === $i) {
    var h = n;
    if (t === zv) {
      for (var f = h[o], d = 0; d < (f || []).length && d < s; d++)
        if ((a = O(f[i + d])) != null)
          return a;
    } else
      for (var d = 0; d < h.length && d < s; d++) {
        var p = h[i + d];
        if (p && (a = O(p[o])) != null)
          return a;
      }
  } else if (e === za) {
    var g = n;
    if (!l)
      return ti.Not;
    for (var d = 0; d < g.length && d < s; d++) {
      var v = g[d];
      if (v && (a = O(v[l])) != null)
        return a;
    }
  } else if (e === Il) {
    var m = n;
    if (!l)
      return ti.Not;
    var f = m[l];
    if (!f || eo(f))
      return ti.Not;
    for (var d = 0; d < f.length && d < s; d++)
      if ((a = O(f[d])) != null)
        return a;
  } else if (e === Va)
    for (var y = n, d = 0; d < y.length && d < s; d++) {
      var v = y[d], b = Mv(v);
      if (!se(b))
        return ti.Not;
      if ((a = O(b[o])) != null)
        return a;
    }
  function O(w) {
    var x = we(w);
    if (w != null && isFinite(w) && w !== "")
      return x ? ti.Might : ti.Not;
    if (x && w !== "-")
      return ti.Must;
  }
  return ti.Not;
}
var YM = Ee();
function tCt(n, e) {
  $e(YM.get(n) == null && e), YM.set(n, e);
}
function nCt(n, e, t) {
  var r = YM.get(e);
  if (!r)
    return t;
  var i = r(n);
  if (!i)
    return t;
  if (process.env.NODE_ENV !== "production")
    for (var o = 0; o < i.length; o++)
      $e(qg(i[o]));
  return t.concat(i);
}
var ZF = It(), rCt = It(), iN = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getColorFromPalette = function(e, t, r) {
      var i = an(this.get("color", !0)), o = this.get("colorLayer", !0);
      return ite(this, ZF, i, o, e, t, r);
    }, n.prototype.clearColorPalette = function() {
      oCt(this, ZF);
    }, n;
  }()
);
function XM(n, e, t, r) {
  var i = an(n.get(["aria", "decal", "decals"]));
  return ite(n, rCt, i, null, e, t, r);
}
function iCt(n, e) {
  for (var t = n.length, r = 0; r < t; r++)
    if (n[r].length > e)
      return n[r];
  return n[t - 1];
}
function ite(n, e, t, r, i, o, a) {
  o = o || n;
  var s = e(o), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(i))
    return u[i];
  var c = a == null || !r ? t : iCt(r, a);
  if (c = c || t, !(!c || !c.length)) {
    var h = c[l];
    return i && (u[i] = h), s.paletteIdx = (l + 1) % c.length, h;
  }
}
function oCt(n, e) {
  e(n).paletteIdx = 0, e(n).paletteNameMap = {};
}
var mO, pm, WF, oT = "\0_ec_inner", GF = 1, aCt = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, sCt = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, SS = {};
function lCt(n) {
  I(n, function(e, t) {
    if (!Pt.hasClass(t)) {
      var r = aCt[t];
      r && !SS[r] && (bi("Component " + t + ` is used but not imported.
import { ` + r + ` } from 'echarts/components';
echarts.use([` + r + "]);"), SS[r] = !0);
    }
  });
}
var oN = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, r, i, o, a, s) {
      o = o || {}, this.option = null, this._theme = new mn(o), this._locale = new mn(a), this._optionManager = s;
    }, e.prototype.setOption = function(t, r, i) {
      process.env.NODE_ENV !== "production" && ($e(t != null, "option is null/undefined"), $e(t[oT] !== GF, "please use chart.getOption()"));
      var o = qF(r);
      this._optionManager.setOption(t, i, o), this._resetOption(null, o);
    }, e.prototype.resetOption = function(t, r) {
      return this._resetOption(t, qF(r));
    }, e.prototype._resetOption = function(t, r) {
      var i = !1, o = this._optionManager;
      if (!t || t === "recreate") {
        var a = o.mountOption(t === "recreate");
        process.env.NODE_ENV !== "production" && lCt(a), !this.option || t === "recreate" ? WF(this, a) : (this.restoreData(), this._mergeOption(a, r)), i = !0;
      }
      if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
        var s = o.getTimelineOption(this);
        s && (i = !0, this._mergeOption(s, r));
      }
      if (!t || t === "recreate" || t === "media") {
        var l = o.getMediaOption(this);
        l.length && I(l, function(u) {
          i = !0, this._mergeOption(u, r);
        }, this);
      }
      return i;
    }, e.prototype.mergeOption = function(t) {
      this._mergeOption(t, null);
    }, e.prototype._mergeOption = function(t, r) {
      var i = this.option, o = this._componentsMap, a = this._componentsCount, s = [], l = Ee(), u = r && r.replaceMergeMainTypeMap;
      J_t(this), I(t, function(h, f) {
        h != null && (Pt.hasClass(f) ? f && (s.push(f), l.set(f, !0)) : i[f] = i[f] == null ? Fe(h) : it(i[f], h, !0));
      }), u && u.each(function(h, f) {
        Pt.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, !0));
      }), Pt.topologicalTravel(s, Pt.getAllClassMainTypes(), c, this);
      function c(h) {
        var f = nCt(this, h, an(t[h])), d = o.get(h), p = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          d ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = $J(d, f, p);
        _xt(g, h, Pt), i[h] = null, o.set(h, null), a.set(h, 0);
        var v = [], m = [], y = 0, b, O;
        I(g, function(w, x) {
          var S = w.existing, _ = w.newOption;
          if (!_)
            S && (S.mergeOption({}, this), S.optionUpdated({}, !1));
          else {
            var C = h === "series", A = Pt.getClass(
              h,
              w.keyInfo.subType,
              !C
              // Give a more detailed warn later if series don't exists
            );
            if (!A) {
              if (process.env.NODE_ENV !== "production") {
                var k = w.keyInfo.subType, P = sCt[k];
                SS[k] || (SS[k] = !0, bi(P ? "Series " + k + ` is used but not imported.
import { ` + P + ` } from 'echarts/charts';
echarts.use([` + P + "]);" : "Unknown series " + k));
              }
              return;
            }
            if (h === "tooltip") {
              if (b) {
                process.env.NODE_ENV !== "production" && (O || ($n("Currently only one tooltip component is allowed."), O = !0));
                return;
              }
              b = !0;
            }
            if (S && S.constructor === A)
              S.name = w.keyInfo.name, S.mergeOption(_, this), S.optionUpdated(_, !1);
            else {
              var L = re({
                componentIndex: x
              }, w.keyInfo);
              S = new A(_, this, this, L), re(S, L), w.brandNew && (S.__requireNewView = !0), S.init(_, this, this), S.optionUpdated(null, !0);
            }
          }
          S ? (v.push(S.option), m.push(S), y++) : (v.push(void 0), m.push(void 0));
        }, this), i[h] = v, o.set(h, m), a.set(h, y), h === "series" && mO(this);
      }
      this._seriesIndices || mO(this);
    }, e.prototype.getOption = function() {
      var t = Fe(this.option);
      return I(t, function(r, i) {
        if (Pt.hasClass(i)) {
          for (var o = an(r), a = o.length, s = !1, l = a - 1; l >= 0; l--)
            o[l] && !qg(o[l]) ? s = !0 : (o[l] = null, !s && a--);
          o.length = a, t[i] = o;
        }
      }), delete t[oT], t;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(t) {
      this._payload = t;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(t, r) {
      var i = this._componentsMap.get(t);
      if (i) {
        var o = i[r || 0];
        if (o)
          return o;
        if (r == null) {
          for (var a = 0; a < i.length; a++)
            if (i[a])
              return i[a];
        }
      }
    }, e.prototype.queryComponents = function(t) {
      var r = t.mainType;
      if (!r)
        return [];
      var i = t.index, o = t.id, a = t.name, s = this._componentsMap.get(r);
      if (!s || !s.length)
        return [];
      var l;
      return i != null ? (l = [], I(an(i), function(u) {
        s[u] && l.push(s[u]);
      })) : o != null ? l = jF("id", o, s) : a != null ? l = jF("name", a, s) : l = en(s, function(u) {
        return !!u;
      }), HF(l, t);
    }, e.prototype.findComponents = function(t) {
      var r = t.query, i = t.mainType, o = s(r), a = o ? this.queryComponents(o) : en(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(HF(a, t));
      function s(u) {
        var c = i + "Index", h = i + "Id", f = i + "Name";
        return u && (u[c] != null || u[h] != null || u[f] != null) ? {
          mainType: i,
          // subType will be filtered finally.
          index: u[c],
          id: u[h],
          name: u[f]
        } : null;
      }
      function l(u) {
        return t.filter ? en(u, t.filter) : u;
      }
    }, e.prototype.eachComponent = function(t, r, i) {
      var o = this._componentsMap;
      if (Le(t)) {
        var a = r, s = t;
        o.each(function(h, f) {
          for (var d = 0; h && d < h.length; d++) {
            var p = h[d];
            p && s.call(a, f, p, p.componentIndex);
          }
        });
      } else
        for (var l = we(t) ? o.get(t) : Ne(t) ? this.findComponents(t) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && r.call(i, c, c.componentIndex);
        }
    }, e.prototype.getSeriesByName = function(t) {
      var r = wr(t, null);
      return en(this._componentsMap.get("series"), function(i) {
        return !!i && r != null && i.name === r;
      });
    }, e.prototype.getSeriesByIndex = function(t) {
      return this._componentsMap.get("series")[t];
    }, e.prototype.getSeriesByType = function(t) {
      return en(this._componentsMap.get("series"), function(r) {
        return !!r && r.subType === t;
      });
    }, e.prototype.getSeries = function() {
      return en(this._componentsMap.get("series"), function(t) {
        return !!t;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(t, r) {
      pm(this), I(this._seriesIndices, function(i) {
        var o = this._componentsMap.get("series")[i];
        t.call(r, o, i);
      }, this);
    }, e.prototype.eachRawSeries = function(t, r) {
      I(this._componentsMap.get("series"), function(i) {
        i && t.call(r, i, i.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(t, r, i) {
      pm(this), I(this._seriesIndices, function(o) {
        var a = this._componentsMap.get("series")[o];
        a.subType === t && r.call(i, a, o);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(t, r, i) {
      return I(this.getSeriesByType(t), r, i);
    }, e.prototype.isSeriesFiltered = function(t) {
      return pm(this), this._seriesIndicesMap.get(t.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(t, r) {
      pm(this);
      var i = [];
      I(this._seriesIndices, function(o) {
        var a = this._componentsMap.get("series")[o];
        t.call(r, a, o) && i.push(o);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = Ee(i);
    }, e.prototype.restoreData = function(t) {
      mO(this);
      var r = this._componentsMap, i = [];
      r.each(function(o, a) {
        Pt.hasClass(a) && i.push(a);
      }), Pt.topologicalTravel(i, Pt.getAllClassMainTypes(), function(o) {
        I(r.get(o), function(a) {
          a && (o !== "series" || !uCt(a, t)) && a.restoreData();
        });
      });
    }, e.internalField = function() {
      mO = function(t) {
        var r = t._seriesIndices = [];
        I(t._componentsMap.get("series"), function(i) {
          i && r.push(i.componentIndex);
        }), t._seriesIndicesMap = Ee(r);
      }, pm = function(t) {
        if (process.env.NODE_ENV !== "production" && !t._seriesIndices)
          throw new Error("Option should contains series.");
      }, WF = function(t, r) {
        t.option = {}, t.option[oT] = GF, t._componentsMap = Ee({
          series: []
        }), t._componentsCount = Ee();
        var i = r.aria;
        Ne(i) && i.enabled == null && (i.enabled = !0), cCt(r, t._theme.option), it(r, K_t, !1), t._mergeOption(r, null);
      };
    }(), e;
  }(mn)
);
function uCt(n, e) {
  if (e) {
    var t = e.seriesIndex, r = e.seriesId, i = e.seriesName;
    return t != null && n.componentIndex !== t || r != null && n.id !== r || i != null && n.name !== i;
  }
}
function cCt(n, e) {
  var t = n.color && !n.colorLayer;
  I(e, function(r, i) {
    i === "colorLayer" && t || Pt.hasClass(i) || (typeof r == "object" ? n[i] = n[i] ? it(n[i], r, !1) : Fe(r) : n[i] == null && (n[i] = r));
  });
}
function jF(n, e, t) {
  if (se(e)) {
    var r = Ee();
    return I(e, function(o) {
      if (o != null) {
        var a = wr(o, null);
        a != null && r.set(o, !0);
      }
    }), en(t, function(o) {
      return o && r.get(o[n]);
    });
  } else {
    var i = wr(e, null);
    return en(t, function(o) {
      return o && i != null && o[n] === i;
    });
  }
}
function HF(n, e) {
  return e.hasOwnProperty("subType") ? en(n, function(t) {
    return t && t.subType === e.subType;
  }) : n;
}
function qF(n) {
  var e = Ee();
  return n && I(an(n.replaceMerge), function(t) {
    process.env.NODE_ENV !== "production" && $e(Pt.hasClass(t), '"' + t + '" is not valid component main type in "replaceMerge"'), e.set(t, !0);
  }), {
    replaceMergeMainTypeMap: e
  };
}
mr(oN, iN);
var hCt = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], fCt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      I(hCt, function(t) {
        this[t] = _e(e[t], e);
      }, this);
    }
    return n;
  }()
);
const ote = fCt;
var aT = {}, Fv = (
  /** @class */
  function() {
    function n() {
      this._coordinateSystems = [];
    }
    return n.prototype.create = function(e, t) {
      var r = [];
      I(aT, function(i, o) {
        var a = i.create(e, t);
        r = r.concat(a || []);
      }), this._coordinateSystems = r;
    }, n.prototype.update = function(e, t) {
      I(this._coordinateSystems, function(r) {
        r.update && r.update(e, t);
      });
    }, n.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, n.register = function(e, t) {
      aT[e] = t;
    }, n.get = function(e) {
      return aT[e];
    }, n;
  }()
), dCt = /^(min|max)?(.+)$/, pCt = (
  /** @class */
  function() {
    function n(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return n.prototype.setOption = function(e, t, r) {
      e && (I(an(e.series), function(a) {
        a && a.data && eo(a.data) && aS(a.data);
      }), I(an(e.dataset), function(a) {
        a && a.source && eo(a.source) && aS(a.source);
      })), e = Fe(e);
      var i = this._optionBackup, o = gCt(e, t, !i);
      this._newBaseOption = o.baseOption, i ? (o.timelineOptions.length && (i.timelineOptions = o.timelineOptions), o.mediaList.length && (i.mediaList = o.mediaList), o.mediaDefault && (i.mediaDefault = o.mediaDefault)) : this._optionBackup = o;
    }, n.prototype.mountOption = function(e) {
      var t = this._optionBackup;
      return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], Fe(e ? t.baseOption : this._newBaseOption);
    }, n.prototype.getTimelineOption = function(e) {
      var t, r = this._timelineOptions;
      if (r.length) {
        var i = e.getComponent("timeline");
        i && (t = Fe(
          // FIXME:TS as TimelineModel or quivlant interface
          r[i.getCurrentIndex()]
        ));
      }
      return t;
    }, n.prototype.getMediaOption = function(e) {
      var t = this._api.getWidth(), r = this._api.getHeight(), i = this._mediaList, o = this._mediaDefault, a = [], s = [];
      if (!i.length && !o)
        return s;
      for (var l = 0, u = i.length; l < u; l++)
        vCt(i[l].query, t, r) && a.push(l);
      return !a.length && o && (a = [-1]), a.length && !yCt(a, this._currentMediaIndices) && (s = le(a, function(c) {
        return Fe(c === -1 ? o.option : i[c].option);
      })), this._currentMediaIndices = a, s;
    }, n;
  }()
);
function gCt(n, e, t) {
  var r = [], i, o, a = n.baseOption, s = n.timeline, l = n.options, u = n.media, c = !!n.media, h = !!(l || s || a && a.timeline);
  a ? (o = a, o.timeline || (o.timeline = s)) : ((h || c) && (n.options = n.media = null), o = n), c && (se(u) ? I(u, function(d) {
    process.env.NODE_ENV !== "production" && d && !d.option && Ne(d.query) && Ne(d.query.option) && bi("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), d && d.option && (d.query ? r.push(d) : i || (i = d));
  }) : process.env.NODE_ENV !== "production" && bi("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), f(o), I(l, function(d) {
    return f(d);
  }), I(r, function(d) {
    return f(d.option);
  });
  function f(d) {
    I(e, function(p) {
      p(d, t);
    });
  }
  return {
    baseOption: o,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: r
  };
}
function vCt(n, e, t) {
  var r = {
    width: e,
    height: t,
    aspectratio: e / t
    // lower case for convenience.
  }, i = !0;
  return I(n, function(o, a) {
    var s = a.match(dCt);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      mCt(r[u], o, l) || (i = !1);
    }
  }), i;
}
function mCt(n, e, t) {
  return t === "min" ? n >= e : t === "max" ? n <= e : n === e;
}
function yCt(n, e) {
  return n.join(",") === e.join(",");
}
const bCt = pCt;
var Jo = I, F0 = Ne, YF = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function sT(n) {
  var e = n && n.itemStyle;
  if (e)
    for (var t = 0, r = YF.length; t < r; t++) {
      var i = YF[t], o = e.normal, a = e.emphasis;
      o && o[i] && (process.env.NODE_ENV !== "production" && lr("itemStyle.normal." + i, i), n[i] = n[i] || {}, n[i].normal ? it(n[i].normal, o[i]) : n[i].normal = o[i], o[i] = null), a && a[i] && (process.env.NODE_ENV !== "production" && lr("itemStyle.emphasis." + i, "emphasis." + i), n[i] = n[i] || {}, n[i].emphasis ? it(n[i].emphasis, a[i]) : n[i].emphasis = a[i], a[i] = null);
    }
}
function ki(n, e, t) {
  if (n && n[e] && (n[e].normal || n[e].emphasis)) {
    var r = n[e].normal, i = n[e].emphasis;
    r && (process.env.NODE_ENV !== "production" && vs("'normal' hierarchy in " + e + " has been removed since 4.0. All style properties are configured in " + e + " directly now."), t ? (n[e].normal = n[e].emphasis = null, Be(n[e], r)) : n[e] = r), i && (process.env.NODE_ENV !== "production" && vs(e + ".emphasis has been changed to emphasis." + e + " since 4.0"), n.emphasis = n.emphasis || {}, n.emphasis[e] = i, i.focus && (n.emphasis.focus = i.focus), i.blurScope && (n.emphasis.blurScope = i.blurScope));
  }
}
function ey(n) {
  ki(n, "itemStyle"), ki(n, "lineStyle"), ki(n, "areaStyle"), ki(n, "label"), ki(n, "labelLine"), ki(n, "upperLabel"), ki(n, "edgeLabel");
}
function ar(n, e) {
  var t = F0(n) && n[e], r = F0(t) && t.textStyle;
  if (r) {
    process.env.NODE_ENV !== "production" && vs("textStyle hierarchy in " + e + " has been removed since 4.0. All textStyle properties are configured in " + e + " directly now.");
    for (var i = 0, o = Jz.length; i < o; i++) {
      var a = Jz[i];
      r.hasOwnProperty(a) && (t[a] = r[a]);
    }
  }
}
function la(n) {
  n && (ey(n), ar(n, "label"), n.emphasis && ar(n.emphasis, "label"));
}
function OCt(n) {
  if (F0(n)) {
    sT(n), ey(n), ar(n, "label"), ar(n, "upperLabel"), ar(n, "edgeLabel"), n.emphasis && (ar(n.emphasis, "label"), ar(n.emphasis, "upperLabel"), ar(n.emphasis, "edgeLabel"));
    var e = n.markPoint;
    e && (sT(e), la(e));
    var t = n.markLine;
    t && (sT(t), la(t));
    var r = n.markArea;
    r && la(r);
    var i = n.data;
    if (n.type === "graph") {
      i = i || n.nodes;
      var o = n.links || n.edges;
      if (o && !eo(o))
        for (var a = 0; a < o.length; a++)
          la(o[a]);
      I(n.categories, function(u) {
        ey(u);
      });
    }
    if (i && !eo(i))
      for (var a = 0; a < i.length; a++)
        la(i[a]);
    if (e = n.markPoint, e && e.data)
      for (var s = e.data, a = 0; a < s.length; a++)
        la(s[a]);
    if (t = n.markLine, t && t.data)
      for (var l = t.data, a = 0; a < l.length; a++)
        se(l[a]) ? (la(l[a][0]), la(l[a][1])) : la(l[a]);
    n.type === "gauge" ? (ar(n, "axisLabel"), ar(n, "title"), ar(n, "detail")) : n.type === "treemap" ? (ki(n.breadcrumb, "itemStyle"), I(n.levels, function(u) {
      ey(u);
    })) : n.type === "tree" && ey(n.leaves);
  }
}
function Bl(n) {
  return se(n) ? n : n ? [n] : [];
}
function XF(n) {
  return (se(n) ? n[0] : n) || {};
}
function wCt(n, e) {
  Jo(Bl(n.series), function(r) {
    F0(r) && OCt(r);
  });
  var t = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Jo(t, function(r) {
    Jo(Bl(n[r]), function(i) {
      i && (ar(i, "axisLabel"), ar(i.axisPointer, "label"));
    });
  }), Jo(Bl(n.parallel), function(r) {
    var i = r && r.parallelAxisDefault;
    ar(i, "axisLabel"), ar(i && i.axisPointer, "label");
  }), Jo(Bl(n.calendar), function(r) {
    ki(r, "itemStyle"), ar(r, "dayLabel"), ar(r, "monthLabel"), ar(r, "yearLabel");
  }), Jo(Bl(n.radar), function(r) {
    ar(r, "name"), r.name && r.axisName == null && (r.axisName = r.name, delete r.name, process.env.NODE_ENV !== "production" && vs("name property in radar component has been changed to axisName")), r.nameGap != null && r.axisNameGap == null && (r.axisNameGap = r.nameGap, delete r.nameGap, process.env.NODE_ENV !== "production" && vs("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && Jo(r.indicator, function(i) {
      i.text && lr("text", "name", "radar.indicator");
    });
  }), Jo(Bl(n.geo), function(r) {
    F0(r) && (la(r), Jo(Bl(r.regions), function(i) {
      la(i);
    }));
  }), Jo(Bl(n.timeline), function(r) {
    la(r), ki(r, "label"), ki(r, "itemStyle"), ki(r, "controlStyle", !0);
    var i = r.data;
    se(i) && I(i, function(o) {
      Ne(o) && (ki(o, "label"), ki(o, "itemStyle"));
    });
  }), Jo(Bl(n.toolbox), function(r) {
    ki(r, "iconStyle"), Jo(r.feature, function(i) {
      ki(i, "iconStyle");
    });
  }), ar(XF(n.axisPointer), "label"), ar(XF(n.tooltip).axisPointer, "label");
}
function xCt(n, e) {
  for (var t = e.split(","), r = n, i = 0; i < t.length && (r = r && r[t[i]], r != null); i++)
    ;
  return r;
}
function SCt(n, e, t, r) {
  for (var i = e.split(","), o = n, a, s = 0; s < i.length - 1; s++)
    a = i[s], o[a] == null && (o[a] = {}), o = o[a];
  (r || o[i[s]] == null) && (o[i[s]] = t);
}
function UF(n) {
  n && I(_Ct, function(e) {
    e[0] in n && !(e[1] in n) && (n[e[1]] = n[e[0]]);
  });
}
var _Ct = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], CCt = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], lT = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function gm(n) {
  var e = n && n.itemStyle;
  if (e)
    for (var t = 0; t < lT.length; t++) {
      var r = lT[t][1], i = lT[t][0];
      e[r] != null && (e[i] = e[r], process.env.NODE_ENV !== "production" && lr(r, i));
    }
}
function KF(n) {
  n && n.alignTo === "edge" && n.margin != null && n.edgeDistance == null && (process.env.NODE_ENV !== "production" && lr("label.margin", "label.edgeDistance", "pie"), n.edgeDistance = n.margin);
}
function JF(n) {
  n && n.downplay && !n.blur && (n.blur = n.downplay, process.env.NODE_ENV !== "production" && lr("downplay", "blur", "sunburst"));
}
function ACt(n) {
  n && n.focusNodeAdjacency != null && (n.emphasis = n.emphasis || {}, n.emphasis.focus == null && (process.env.NODE_ENV !== "production" && lr("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), n.emphasis.focus = "adjacency"));
}
function ate(n, e) {
  if (n)
    for (var t = 0; t < n.length; t++)
      e(n[t]), n[t] && ate(n[t].children, e);
}
function ste(n, e) {
  wCt(n, e), n.series = an(n.series), I(n.series, function(t) {
    if (Ne(t)) {
      var r = t.type;
      if (r === "line")
        t.clipOverflow != null && (t.clip = t.clipOverflow, process.env.NODE_ENV !== "production" && lr("clipOverflow", "clip", "line"));
      else if (r === "pie" || r === "gauge") {
        t.clockWise != null && (t.clockwise = t.clockWise, process.env.NODE_ENV !== "production" && lr("clockWise", "clockwise")), KF(t.label);
        var i = t.data;
        if (i && !eo(i))
          for (var o = 0; o < i.length; o++)
            KF(i[o]);
        t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && lr("hoverOffset", "emphasis.scaleSize"), t.emphasis.scaleSize = t.hoverOffset));
      } else if (r === "gauge") {
        var a = xCt(t, "pointer.color");
        a != null && SCt(t, "itemStyle.color", a);
      } else if (r === "bar") {
        gm(t), gm(t.backgroundStyle), gm(t.emphasis);
        var i = t.data;
        if (i && !eo(i))
          for (var o = 0; o < i.length; o++)
            typeof i[o] == "object" && (gm(i[o]), gm(i[o] && i[o].emphasis));
      } else if (r === "sunburst") {
        var s = t.highlightPolicy;
        s && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = s, process.env.NODE_ENV !== "production" && lr("highlightPolicy", "emphasis.focus", "sunburst"))), JF(t), ate(t.data, JF);
      } else
        r === "graph" || r === "sankey" ? ACt(t) : r === "map" && (t.mapType && !t.map && (process.env.NODE_ENV !== "production" && lr("mapType", "map", "map"), t.map = t.mapType), t.mapLocation && (process.env.NODE_ENV !== "production" && vs("`mapLocation` is not used anymore."), Be(t, t.mapLocation)));
      t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (process.env.NODE_ENV !== "production" && lr("hoverAnimation", "emphasis.scale"), t.emphasis.scale = t.hoverAnimation)), UF(t);
    }
  }), n.dataRange && (n.visualMap = n.dataRange), I(CCt, function(t) {
    var r = n[t];
    r && (se(r) || (r = [r]), I(r, function(i) {
      UF(i);
    }));
  });
}
function TCt(n) {
  var e = Ee();
  n.eachSeries(function(t) {
    var r = t.get("stack");
    if (r) {
      var i = e.get(r) || e.set(r, []), o = t.getData(), a = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: o.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: o.getCalculationInfo("stackedOverDimension"),
        stackedDimension: o.getCalculationInfo("stackedDimension"),
        stackedByDimension: o.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: o.getCalculationInfo("isStackedByIndex"),
        data: o,
        seriesModel: t
      };
      if (!a.stackedDimension || !(a.isStackedByIndex || a.stackedByDimension))
        return;
      i.length && o.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(a);
    }
  }), e.each(kCt);
}
function kCt(n) {
  I(n, function(e, t) {
    var r = [], i = [NaN, NaN], o = [e.stackResultDimension, e.stackedOverDimension], a = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
    a.modify(o, function(u, c, h) {
      var f = a.get(e.stackedDimension, h);
      if (isNaN(f))
        return i;
      var d, p;
      s ? p = a.getRawIndex(h) : d = a.get(e.stackedByDimension, h);
      for (var g = NaN, v = t - 1; v >= 0; v--) {
        var m = n[v];
        if (s || (p = m.data.rawIndexOf(m.stackedByDimension, d)), p >= 0) {
          var y = m.data.getByRawIndex(m.stackResultDimension, p);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
            f = cxt(f, y), g = y;
            break;
          }
        }
      }
      return r[0] = f, r[1] = g, r;
    });
  });
}
var NC = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.data = e.data || (e.sourceFormat === Il ? {} : []), this.sourceFormat = e.sourceFormat || Jee, this.seriesLayoutBy = e.seriesLayoutBy || pl, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var t = this.dimensionsDefine = e.dimensionsDefine;
      if (t)
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.type == null && nte(this, r) === ti.Must && (i.type = "ordinal");
        }
    }
    return n;
  }()
);
function aN(n) {
  return n instanceof NC;
}
function UM(n, e, t) {
  t = t || lte(n);
  var r = e.seriesLayoutBy, i = ECt(n, t, r, e.sourceHeader, e.dimensions), o = new NC({
    data: n,
    sourceFormat: t,
    seriesLayoutBy: r,
    dimensionsDefine: i.dimensionsDefine,
    startIndex: i.startIndex,
    dimensionsDetectedCount: i.dimensionsDetectedCount,
    metaRawOption: Fe(e)
  });
  return o;
}
function sN(n) {
  return new NC({
    data: n,
    sourceFormat: eo(n) ? nu : Va
  });
}
function PCt(n) {
  return new NC({
    data: n.data,
    sourceFormat: n.sourceFormat,
    seriesLayoutBy: n.seriesLayoutBy,
    dimensionsDefine: Fe(n.dimensionsDefine),
    startIndex: n.startIndex,
    dimensionsDetectedCount: n.dimensionsDetectedCount
  });
}
function lte(n) {
  var e = Jee;
  if (eo(n))
    e = nu;
  else if (se(n)) {
    n.length === 0 && (e = $i);
    for (var t = 0, r = n.length; t < r; t++) {
      var i = n[t];
      if (i != null) {
        if (se(i) || eo(i)) {
          e = $i;
          break;
        } else if (Ne(i)) {
          e = za;
          break;
        }
      }
    }
  } else if (Ne(n)) {
    for (var o in n)
      if (Ce(n, o) && Ni(n[o])) {
        e = Il;
        break;
      }
  }
  return e;
}
function ECt(n, e, t, r, i) {
  var o, a;
  if (!n)
    return {
      dimensionsDefine: e6(i),
      startIndex: a,
      dimensionsDetectedCount: o
    };
  if (e === $i) {
    var s = n;
    r === "auto" || r == null ? t6(function(u) {
      u != null && u !== "-" && (we(u) ? a == null && (a = 1) : a = 0);
    }, t, s, 10) : a = $t(r) ? r : r ? 1 : 0, !i && a === 1 && (i = [], t6(function(u, c) {
      i[c] = u != null ? u + "" : "";
    }, t, s, 1 / 0)), o = i ? i.length : t === zv ? s.length : s[0] ? s[0].length : null;
  } else if (e === za)
    i || (i = MCt(n));
  else if (e === Il)
    i || (i = [], I(n, function(u, c) {
      i.push(c);
    }));
  else if (e === Va) {
    var l = Mv(n[0]);
    o = se(l) && l.length || 1;
  } else
    e === nu && process.env.NODE_ENV !== "production" && $e(!!i, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: a,
    dimensionsDefine: e6(i),
    dimensionsDetectedCount: o
  };
}
function MCt(n) {
  for (var e = 0, t; e < n.length && !(t = n[e++]); )
    ;
  if (t)
    return Ot(t);
}
function e6(n) {
  if (n) {
    var e = Ee();
    return le(n, function(t, r) {
      t = Ne(t) ? t : {
        name: t
      };
      var i = {
        name: t.name,
        displayName: t.displayName,
        type: t.type
      };
      if (i.name == null)
        return i;
      i.name += "", i.displayName == null && (i.displayName = i.name);
      var o = e.get(i.name);
      return o ? i.name += "-" + o.count++ : e.set(i.name, {
        count: 1
      }), i;
    });
  }
}
function t6(n, e, t, r) {
  if (e === zv)
    for (var i = 0; i < t.length && i < r; i++)
      n(t[i] ? t[i][0] : null, i);
  else
    for (var o = t[0] || [], i = 0; i < o.length && i < r; i++)
      n(o[i], i);
}
function ute(n) {
  var e = n.sourceFormat;
  return e === za || e === Il;
}
var $h, Bh, Vh, n6, r6, cte = (
  /** @class */
  function() {
    function n(e, t) {
      var r = aN(e) ? e : sN(e);
      this._source = r;
      var i = this._data = r.data;
      if (r.sourceFormat === nu) {
        if (process.env.NODE_ENV !== "production" && t == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = t, this._data = i;
      }
      r6(this, i, r);
    }
    return n.prototype.getSource = function() {
      return this._source;
    }, n.prototype.count = function() {
      return 0;
    }, n.prototype.getItem = function(e, t) {
    }, n.prototype.appendData = function(e) {
    }, n.prototype.clean = function() {
    }, n.protoInitialize = function() {
      var e = n.prototype;
      e.pure = !1, e.persistent = !0;
    }(), n.internalField = function() {
      var e;
      r6 = function(a, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, f = l.dimensionsDefine, d = n6[lN(u, c)];
        if (process.env.NODE_ENV !== "production" && $e(d, "Invalide sourceFormat: " + u), re(a, d), u === nu)
          a.getItem = t, a.count = i, a.fillStorage = r;
        else {
          var p = hte(u, c);
          a.getItem = _e(p, null, s, h, f);
          var g = fte(u, c);
          a.count = _e(g, null, s, h, f);
        }
      };
      var t = function(a, s) {
        a = a - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * a, h = 0; h < u; h++)
          s[h] = l[c + h];
        return s;
      }, r = function(a, s, l, u) {
        for (var c = this._data, h = this._dimSize, f = 0; f < h; f++) {
          for (var d = u[f], p = d[0] == null ? 1 / 0 : d[0], g = d[1] == null ? -1 / 0 : d[1], v = s - a, m = l[f], y = 0; y < v; y++) {
            var b = c[y * h + f];
            m[a + y] = b, b < p && (p = b), b > g && (g = b);
          }
          d[0] = p, d[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      n6 = (e = {}, e[$i + "_" + pl] = {
        pure: !0,
        appendData: o
      }, e[$i + "_" + zv] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[za] = {
        pure: !0,
        appendData: o
      }, e[Il] = {
        pure: !0,
        appendData: function(a) {
          var s = this._data;
          I(a, function(l, u) {
            for (var c = s[u] || (s[u] = []), h = 0; h < (l || []).length; h++)
              c.push(l[h]);
          });
        }
      }, e[Va] = {
        appendData: o
      }, e[nu] = {
        persistent: !1,
        pure: !0,
        appendData: function(a) {
          process.env.NODE_ENV !== "production" && $e(eo(a), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = a;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function o(a) {
        for (var s = 0; s < a.length; s++)
          this._data.push(a[s]);
      }
    }(), n;
  }()
), i6 = function(n, e, t, r) {
  return n[r];
}, DCt = ($h = {}, $h[$i + "_" + pl] = function(n, e, t, r) {
  return n[r + e];
}, $h[$i + "_" + zv] = function(n, e, t, r, i) {
  r += e;
  for (var o = i || [], a = n, s = 0; s < a.length; s++) {
    var l = a[s];
    o[s] = l ? l[r] : null;
  }
  return o;
}, $h[za] = i6, $h[Il] = function(n, e, t, r, i) {
  for (var o = i || [], a = 0; a < t.length; a++) {
    var s = t[a].name;
    if (process.env.NODE_ENV !== "production" && s == null)
      throw new Error();
    var l = n[s];
    o[a] = l ? l[r] : null;
  }
  return o;
}, $h[Va] = i6, $h);
function hte(n, e) {
  var t = DCt[lN(n, e)];
  return process.env.NODE_ENV !== "production" && $e(t, 'Do not support get item on "' + n + '", "' + e + '".'), t;
}
var o6 = function(n, e, t) {
  return n.length;
}, LCt = (Bh = {}, Bh[$i + "_" + pl] = function(n, e, t) {
  return Math.max(0, n.length - e);
}, Bh[$i + "_" + zv] = function(n, e, t) {
  var r = n[0];
  return r ? Math.max(0, r.length - e) : 0;
}, Bh[za] = o6, Bh[Il] = function(n, e, t) {
  var r = t[0].name;
  if (process.env.NODE_ENV !== "production" && r == null)
    throw new Error();
  var i = n[r];
  return i ? i.length : 0;
}, Bh[Va] = o6, Bh);
function fte(n, e) {
  var t = LCt[lN(n, e)];
  return process.env.NODE_ENV !== "production" && $e(t, 'Do not support count on "' + n + '", "' + e + '".'), t;
}
var uT = function(n, e, t) {
  return n[e];
}, ICt = (Vh = {}, Vh[$i] = uT, Vh[za] = function(n, e, t) {
  return n[t];
}, Vh[Il] = uT, Vh[Va] = function(n, e, t) {
  var r = Mv(n);
  return r instanceof Array ? r[e] : r;
}, Vh[nu] = uT, Vh);
function dte(n) {
  var e = ICt[n];
  return process.env.NODE_ENV !== "production" && $e(e, 'Do not support get value on "' + n + '".'), e;
}
function lN(n, e) {
  return n === $i ? n + "_" + e : n;
}
function Xg(n, e, t) {
  if (n) {
    var r = n.getRawDataItem(e);
    if (r != null) {
      var i = n.getStore(), o = i.getSource().sourceFormat;
      if (t != null) {
        var a = n.getDimensionIndex(t), s = i.getDimensionProperty(a);
        return dte(o)(r, a, s);
      } else {
        var l = r;
        return o === Va && (l = Mv(r)), l;
      }
    }
  }
}
var RCt = /\{@(.+?)\}/g, uN = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getDataParams = function(e, t) {
      var r = this.getData(t), i = this.getRawValue(e, t), o = r.getRawIndex(e), a = r.getName(e), s = r.getRawDataItem(e), l = r.getItemVisual(e, "style"), u = l && l[r.getItemVisual(e, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, f = h === "series", d = r.userOutput && r.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: a,
        dataIndex: o,
        data: s,
        dataType: t,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, n.prototype.getFormattedLabel = function(e, t, r, i, o, a) {
      t = t || "normal";
      var s = this.getData(r), l = this.getDataParams(e, r);
      if (a && (l.value = a.interpolatedValue), i != null && se(l.value) && (l.value = l.value[i]), !o) {
        var u = s.getItemModel(e);
        o = u.get(t === "normal" ? ["label", "formatter"] : [t, "label", "formatter"]);
      }
      if (Le(o))
        return l.status = t, l.dimensionIndex = i, o(l);
      if (we(o)) {
        var c = Yee(o, l);
        return c.replace(RCt, function(h, f) {
          var d = f.length, p = f;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1), process.env.NODE_ENV !== "production" && isNaN(p) && bi("Invalide label formatter: @" + f + ", only support @[0], @[1], @[2], ..."));
          var g = Xg(s, e, p);
          if (a && se(a.interpolatedValue)) {
            var v = s.getDimensionIndex(p);
            v >= 0 && (g = a.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, n.prototype.getRawValue = function(e, t) {
      return Xg(this.getData(t), e);
    }, n.prototype.formatTooltip = function(e, t, r) {
    }, n;
  }()
);
function a6(n) {
  var e, t;
  return Ne(n) ? n.type ? t = n : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + to(n)) : e = n, {
    text: e,
    // markers: markers || markersExisting,
    frag: t
  };
}
function Vy(n) {
  return new NCt(n);
}
var NCt = (
  /** @class */
  function() {
    function n(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = !0;
    }
    return n.prototype.perform = function(e) {
      var t = this._upstream, r = e && e.skip;
      if (this._dirty && t) {
        var i = this.context;
        i.data = i.outputData = t.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var o;
      this._plan && !r && (o = this._plan(this.context));
      var a = c(this._modBy), s = this._modDataCount || 0, l = c(e && e.modBy), u = e && e.modDataCount || 0;
      (a !== l || s !== u) && (o = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || o === "reset") && (this._dirty = !1, h = this._doReset(r)), this._modBy = l, this._modDataCount = u;
      var f = e && e.step;
      if (t ? (process.env.NODE_ENV !== "production" && $e(t._outputDueEnd != null), this._dueEnd = t._outputDueEnd) : (process.env.NODE_ENV !== "production" && $e(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var d = this._dueIndex, p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!r && (h || d < p)) {
          var g = this._progress;
          if (se(g))
            for (var v = 0; v < g.length; v++)
              this._doProgress(g[v], d, p, l, u);
          else
            this._doProgress(g, d, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        process.env.NODE_ENV !== "production" && $e(m >= this._outputDueEnd), this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, n.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, n.prototype._doProgress = function(e, t, r, i, o) {
      s6.reset(t, r, i, o), this._callingProgress = e, this._callingProgress({
        start: t,
        end: r,
        count: r - t,
        next: s6.next
      }, this.context);
    }, n.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var t, r;
      !e && this._reset && (t = this._reset(this.context), t && t.progress && (r = t.forceFirstProgress, t = t.progress), se(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), r;
    }, n.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, n.prototype.pipe = function(e) {
      process.env.NODE_ENV !== "production" && $e(e && !e._disposed && e !== this), (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, n.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, n.prototype.getUpstream = function() {
      return this._upstream;
    }, n.prototype.getDownstream = function() {
      return this._downstream;
    }, n.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, n;
  }()
), s6 = /* @__PURE__ */ function() {
  var n, e, t, r, i, o = {
    reset: function(l, u, c, h) {
      e = l, n = u, t = c, r = h, i = Math.ceil(r / t), o.next = t > 1 && r > 0 ? s : a;
    }
  };
  return o;
  function a() {
    return e < n ? e++ : null;
  }
  function s() {
    var l = e % i * t + Math.ceil(e / i), u = e >= n ? null : l < r ? l : e;
    return e++, u;
  }
}();
function Cc(n, e) {
  var t = e && e.type;
  return t === "ordinal" ? n : (t === "time" && !$t(n) && n != null && n !== "-" && (n = +Cl(n)), n == null || n === "" ? NaN : +n);
}
var $Ct = Ee({
  number: function(n) {
    return parseFloat(n);
  },
  time: function(n) {
    return +Cl(n);
  },
  trim: function(n) {
    return we(n) ? is(n) : n;
  }
});
function pte(n) {
  return $Ct.get(n);
}
var gte = {
  lt: function(n, e) {
    return n < e;
  },
  lte: function(n, e) {
    return n <= e;
  },
  gt: function(n, e) {
    return n > e;
  },
  gte: function(n, e) {
    return n >= e;
  }
}, BCt = (
  /** @class */
  function() {
    function n(e, t) {
      if (!$t(t)) {
        var r = "";
        process.env.NODE_ENV !== "production" && (r = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), Gt(r);
      }
      this._opFn = gte[e], this._rvalFloat = pu(t);
    }
    return n.prototype.evaluate = function(e) {
      return $t(e) ? this._opFn(e, this._rvalFloat) : this._opFn(pu(e), this._rvalFloat);
    }, n;
  }()
), vte = (
  /** @class */
  function() {
    function n(e, t) {
      var r = e === "desc";
      this._resultLT = r ? 1 : -1, t == null && (t = r ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0;
    }
    return n.prototype.evaluate = function(e, t) {
      var r = $t(e) ? e : pu(e), i = $t(t) ? t : pu(t), o = isNaN(r), a = isNaN(i);
      if (o && (r = this._incomparable), a && (i = this._incomparable), o && a) {
        var s = we(e), l = we(t);
        s && (r = l ? e : 0), l && (i = s ? t : 0);
      }
      return r < i ? this._resultLT : r > i ? -this._resultLT : 0;
    }, n;
  }()
), VCt = (
  /** @class */
  function() {
    function n(e, t) {
      this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = pu(t);
    }
    return n.prototype.evaluate = function(e) {
      var t = e === this._rval;
      if (!t) {
        var r = typeof e;
        r !== this._rvalTypeof && (r === "number" || this._rvalTypeof === "number") && (t = pu(e) === this._rvalFloat);
      }
      return this._isEQ ? t : !t;
    }, n;
  }()
);
function zCt(n, e) {
  return n === "eq" || n === "ne" ? new VCt(n === "eq", e) : Ce(gte, n) ? new BCt(n, e) : null;
}
var FCt = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getRawData = function() {
      throw new Error("not supported");
    }, n.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, n.prototype.cloneRawData = function() {
    }, n.prototype.getDimensionInfo = function(e) {
    }, n.prototype.cloneAllDimensionInfo = function() {
    }, n.prototype.count = function() {
    }, n.prototype.retrieveValue = function(e, t) {
    }, n.prototype.retrieveValueFromItem = function(e, t) {
    }, n.prototype.convertValue = function(e, t) {
      return Cc(e, t);
    }, n;
  }()
);
function QCt(n, e) {
  var t = new FCt(), r = n.data, i = t.sourceFormat = n.sourceFormat, o = n.startIndex, a = "";
  n.seriesLayoutBy !== pl && (process.env.NODE_ENV !== "production" && (a = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), Gt(a));
  var s = [], l = {}, u = n.dimensionsDefine;
  if (u)
    I(u, function(g, v) {
      var m = g.name, y = {
        index: v,
        name: m,
        displayName: g.displayName
      };
      if (s.push(y), m != null) {
        var b = "";
        Ce(l, m) && (process.env.NODE_ENV !== "production" && (b = 'dimension name "' + m + '" duplicated.'), Gt(b)), l[m] = y;
      }
    });
  else
    for (var c = 0; c < n.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var h = hte(i, pl);
  e.__isBuiltIn && (t.getRawDataItem = function(g) {
    return h(r, o, s, g);
  }, t.getRawData = _e(ZCt, null, n)), t.cloneRawData = _e(WCt, null, n);
  var f = fte(i, pl);
  t.count = _e(f, null, r, o, s);
  var d = dte(i);
  t.retrieveValue = function(g, v) {
    var m = h(r, o, s, g);
    return p(m, v);
  };
  var p = t.retrieveValueFromItem = function(g, v) {
    if (g != null) {
      var m = s[v];
      if (m)
        return d(g, v, m.name);
    }
  };
  return t.getDimensionInfo = _e(GCt, null, s, l), t.cloneAllDimensionInfo = _e(jCt, null, s), t;
}
function ZCt(n) {
  var e = n.sourceFormat;
  if (!cN(e)) {
    var t = "";
    process.env.NODE_ENV !== "production" && (t = "`getRawData` is not supported in source format " + e), Gt(t);
  }
  return n.data;
}
function WCt(n) {
  var e = n.sourceFormat, t = n.data;
  if (!cN(e)) {
    var r = "";
    process.env.NODE_ENV !== "production" && (r = "`cloneRawData` is not supported in source format " + e), Gt(r);
  }
  if (e === $i) {
    for (var i = [], o = 0, a = t.length; o < a; o++)
      i.push(t[o].slice());
    return i;
  } else if (e === za) {
    for (var i = [], o = 0, a = t.length; o < a; o++)
      i.push(re({}, t[o]));
    return i;
  }
}
function GCt(n, e, t) {
  if (t != null) {
    if ($t(t) || !isNaN(t) && !Ce(e, t))
      return n[t];
    if (Ce(e, t))
      return e[t];
  }
}
function jCt(n) {
  return Fe(n);
}
var mte = Ee();
function HCt(n) {
  n = Fe(n);
  var e = n.type, t = "";
  e || (process.env.NODE_ENV !== "production" && (t = "Must have a `type` when `registerTransform`."), Gt(t));
  var r = e.split(":");
  r.length !== 2 && (process.env.NODE_ENV !== "production" && (t = 'Name must include namespace like "ns:regression".'), Gt(t));
  var i = !1;
  r[0] === "echarts" && (e = r[1], i = !0), n.__isBuiltIn = i, mte.set(e, n);
}
function qCt(n, e, t) {
  var r = an(n), i = r.length, o = "";
  i || (process.env.NODE_ENV !== "production" && (o = "If `transform` declared, it should at least contain one transform."), Gt(o));
  for (var a = 0, s = i; a < s; a++) {
    var l = r[a];
    e = YCt(l, e, t, i === 1 ? null : a), a !== s - 1 && (e.length = Math.max(e.length, 1));
  }
  return e;
}
function YCt(n, e, t, r) {
  var i = "";
  e.length || (process.env.NODE_ENV !== "production" && (i = "Must have at least one upstream dataset."), Gt(i)), Ne(n) || (process.env.NODE_ENV !== "production" && (i = "transform declaration must be an object rather than " + typeof n + "."), Gt(i));
  var o = n.type, a = mte.get(o);
  a || (process.env.NODE_ENV !== "production" && (i = 'Can not find transform on type "' + o + '".'), Gt(i));
  var s = le(e, function(c) {
    return QCt(c, a);
  }), l = an(a.transform({
    upstream: s[0],
    upstreamList: s,
    config: Fe(n.config)
  }));
  if (process.env.NODE_ENV !== "production" && n.print) {
    var u = le(l, function(c) {
      var h = r != null ? " === pipe index: " + r : "";
      return ["=== dataset index: " + t.datasetIndex + h + " ===", "- transform result data:", to(c.data), "- transform result dimensions:", to(c.dimensions)].join(`
`);
    }).join(`
`);
    gxt(u);
  }
  return le(l, function(c, h) {
    var f = "";
    Ne(c) || (process.env.NODE_ENV !== "production" && (f = "A transform should not return some empty results."), Gt(f)), c.data || (process.env.NODE_ENV !== "production" && (f = "Transform result data should be not be null or undefined"), Gt(f));
    var d = lte(c.data);
    cN(d) || (process.env.NODE_ENV !== "production" && (f = "Transform result data should be array rows or object rows."), Gt(f));
    var p, g = e[0];
    if (g && h === 0 && !c.dimensions) {
      var v = g.startIndex;
      v && (c.data = g.data.slice(0, v).concat(c.data)), p = {
        seriesLayoutBy: pl,
        sourceHeader: v,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      p = {
        seriesLayoutBy: pl,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return UM(c.data, p, null);
  });
}
function cN(n) {
  return n === $i || n === za;
}
var $C = "undefined", XCt = typeof Uint32Array === $C ? Array : Uint32Array, UCt = typeof Uint16Array === $C ? Array : Uint16Array, yte = typeof Int32Array === $C ? Array : Int32Array, l6 = typeof Float64Array === $C ? Array : Float64Array, bte = {
  float: l6,
  int: yte,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: l6
}, cT;
function vm(n) {
  return n > 65535 ? XCt : UCt;
}
function rp() {
  return [1 / 0, -1 / 0];
}
function KCt(n) {
  var e = n.constructor;
  return e === Array ? n.slice() : new e(n);
}
function u6(n, e, t, r, i) {
  var o = bte[t || "float"];
  if (i) {
    var a = n[e], s = a && a.length;
    if (s !== r) {
      for (var l = new o(r), u = 0; u < s; u++)
        l[u] = a[u];
      n[e] = l;
    }
  } else
    n[e] = new o(r);
}
var KM = (
  /** @class */
  function() {
    function n() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = Ee();
    }
    return n.prototype.initData = function(e, t, r) {
      process.env.NODE_ENV !== "production" && $e(Le(e.getItem) && Le(e.count), "Invalid data provider."), this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = e.getSource(), o = this.defaultDimValueGetter = cT[i.sourceFormat];
      this._dimValueGetter = r || o, this._rawExtent = [];
      var a = ute(i);
      this._dimensions = le(t, function(s) {
        return process.env.NODE_ENV !== "production" && a && $e(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, n.prototype.getProvider = function() {
      return this._provider;
    }, n.prototype.getSource = function() {
      return this._provider.getSource();
    }, n.prototype.ensureCalculationDimension = function(e, t) {
      var r = this._calcDimNameToIdx, i = this._dimensions, o = r.get(e);
      if (o != null) {
        if (i[o].type === t)
          return o;
      } else
        o = i.length;
      return i[o] = {
        type: t
      }, r.set(e, o), this._chunks[o] = new bte[t || "float"](this._rawCount), this._rawExtent[o] = rp(), o;
    }, n.prototype.collectOrdinalMeta = function(e, t) {
      var r = this._chunks[e], i = this._dimensions[e], o = this._rawExtent, a = i.ordinalOffset || 0, s = r.length;
      a === 0 && (o[e] = rp());
      for (var l = o[e], u = a; u < s; u++) {
        var c = r[u] = t.parseAndCollect(r[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = t, i.ordinalOffset = s, i.type = "ordinal";
    }, n.prototype.getOrdinalMeta = function(e) {
      var t = this._dimensions[e], r = t.ordinalMeta;
      return r;
    }, n.prototype.getDimensionProperty = function(e) {
      var t = this._dimensions[e];
      return t && t.property;
    }, n.prototype.appendData = function(e) {
      process.env.NODE_ENV !== "production" && $e(!this._indices, "appendData can only be called on raw data.");
      var t = this._provider, r = this.count();
      t.appendData(e);
      var i = t.count();
      return t.persistent || (i += r), r < i && this._initDataFromProvider(r, i, !0), [r, i];
    }, n.prototype.appendValues = function(e, t) {
      for (var r = this._chunks, i = this._dimensions, o = i.length, a = this._rawExtent, s = this.count(), l = s + Math.max(e.length, t || 0), u = 0; u < o; u++) {
        var c = i[u];
        u6(r, u, c.type, l, !0);
      }
      for (var h = [], f = s; f < l; f++)
        for (var d = f - s, p = 0; p < o; p++) {
          var c = i[p], g = cT.arrayRows.call(this, e[d] || h, c.property, d, p);
          r[p][f] = g;
          var v = a[p];
          g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, n.prototype._initDataFromProvider = function(e, t, r) {
      for (var i = this._provider, o = this._chunks, a = this._dimensions, s = a.length, l = this._rawExtent, u = le(a, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var h = a[c];
        l[c] || (l[c] = rp()), u6(o, c, h.type, t, r);
      }
      if (i.fillStorage)
        i.fillStorage(e, t, o, l);
      else
        for (var f = [], d = e; d < t; d++) {
          f = i.getItem(d, f);
          for (var p = 0; p < s; p++) {
            var g = o[p], v = this._dimValueGetter(f, u[p], d, p);
            g[d] = v;
            var m = l[p];
            v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = t, this._extent = [];
    }, n.prototype.count = function() {
      return this._count;
    }, n.prototype.get = function(e, t) {
      if (!(t >= 0 && t < this._count))
        return NaN;
      var r = this._chunks[e];
      return r ? r[this.getRawIndex(t)] : NaN;
    }, n.prototype.getValues = function(e, t) {
      var r = [], i = [];
      if (t == null) {
        t = e, e = [];
        for (var o = 0; o < this._dimensions.length; o++)
          i.push(o);
      } else
        i = e;
      for (var o = 0, a = i.length; o < a; o++)
        r.push(this.get(i[o], t));
      return r;
    }, n.prototype.getByRawIndex = function(e, t) {
      if (!(t >= 0 && t < this._rawCount))
        return NaN;
      var r = this._chunks[e];
      return r ? r[t] : NaN;
    }, n.prototype.getSum = function(e) {
      var t = this._chunks[e], r = 0;
      if (t)
        for (var i = 0, o = this.count(); i < o; i++) {
          var a = this.get(e, i);
          isNaN(a) || (r += a);
        }
      return r;
    }, n.prototype.getMedian = function(e) {
      var t = [];
      this.each([e], function(o) {
        isNaN(o) || t.push(o);
      });
      var r = t.sort(function(o, a) {
        return o - a;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? r[(i - 1) / 2] : (r[i / 2] + r[i / 2 - 1]) / 2;
    }, n.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0)
        return -1;
      if (!this._indices)
        return e;
      var t = this._indices, r = t[e];
      if (r != null && r < this._count && r === e)
        return e;
      for (var i = 0, o = this._count - 1; i <= o; ) {
        var a = (i + o) / 2 | 0;
        if (t[a] < e)
          i = a + 1;
        else if (t[a] > e)
          o = a - 1;
        else
          return a;
      }
      return -1;
    }, n.prototype.indicesOfNearest = function(e, t, r) {
      var i = this._chunks, o = i[e], a = [];
      if (!o)
        return a;
      r == null && (r = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, c = 0, h = this.count(); c < h; c++) {
        var f = this.getRawIndex(c), d = t - o[f], p = Math.abs(d);
        p <= r && ((p < s || p === s && d >= 0 && l < 0) && (s = p, l = d, u = 0), d === l && (a[u++] = c));
      }
      return a.length = u, a;
    }, n.prototype.getIndices = function() {
      var e, t = this._indices;
      if (t) {
        var r = t.constructor, i = this._count;
        if (r === Array) {
          e = new r(i);
          for (var o = 0; o < i; o++)
            e[o] = t[o];
        } else
          e = new r(t.buffer, 0, i);
      } else {
        var r = vm(this._rawCount);
        e = new r(this.count());
        for (var o = 0; o < e.length; o++)
          e[o] = o;
      }
      return e;
    }, n.prototype.filter = function(e, t) {
      if (!this._count)
        return this;
      for (var r = this.clone(), i = r.count(), o = vm(r._rawCount), a = new o(i), s = [], l = e.length, u = 0, c = e[0], h = r._chunks, f = 0; f < i; f++) {
        var d = void 0, p = r.getRawIndex(f);
        if (l === 0)
          d = t(f);
        else if (l === 1) {
          var g = h[c][p];
          d = t(g, f);
        } else {
          for (var v = 0; v < l; v++)
            s[v] = h[e[v]][p];
          s[v] = f, d = t.apply(null, s);
        }
        d && (a[u++] = p);
      }
      return u < i && (r._indices = a), r._count = u, r._extent = [], r._updateGetRawIdx(), r;
    }, n.prototype.selectRange = function(e) {
      var t = this.clone(), r = t._count;
      if (!r)
        return this;
      var i = Ot(e), o = i.length;
      if (!o)
        return this;
      var a = t.count(), s = vm(t._rawCount), l = new s(a), u = 0, c = i[0], h = e[c][0], f = e[c][1], d = t._chunks, p = !1;
      if (!t._indices) {
        var g = 0;
        if (o === 1) {
          for (var v = d[i[0]], m = 0; m < r; m++) {
            var y = v[m];
            (y >= h && y <= f || isNaN(y)) && (l[u++] = g), g++;
          }
          p = !0;
        } else if (o === 2) {
          for (var v = d[i[0]], b = d[i[1]], O = e[i[1]][0], w = e[i[1]][1], m = 0; m < r; m++) {
            var y = v[m], x = b[m];
            (y >= h && y <= f || isNaN(y)) && (x >= O && x <= w || isNaN(x)) && (l[u++] = g), g++;
          }
          p = !0;
        }
      }
      if (!p)
        if (o === 1)
          for (var m = 0; m < a; m++) {
            var S = t.getRawIndex(m), y = d[i[0]][S];
            (y >= h && y <= f || isNaN(y)) && (l[u++] = S);
          }
        else
          for (var m = 0; m < a; m++) {
            for (var _ = !0, S = t.getRawIndex(m), C = 0; C < o; C++) {
              var A = i[C], y = d[A][S];
              (y < e[A][0] || y > e[A][1]) && (_ = !1);
            }
            _ && (l[u++] = t.getRawIndex(m));
          }
      return u < a && (t._indices = l), t._count = u, t._extent = [], t._updateGetRawIdx(), t;
    }, n.prototype.map = function(e, t) {
      var r = this.clone(e);
      return this._updateDims(r, e, t), r;
    }, n.prototype.modify = function(e, t) {
      this._updateDims(this, e, t);
    }, n.prototype._updateDims = function(e, t, r) {
      for (var i = e._chunks, o = [], a = t.length, s = e.count(), l = [], u = e._rawExtent, c = 0; c < t.length; c++)
        u[t[c]] = rp();
      for (var h = 0; h < s; h++) {
        for (var f = e.getRawIndex(h), d = 0; d < a; d++)
          l[d] = i[t[d]][f];
        l[a] = h;
        var p = r && r.apply(null, l);
        if (p != null) {
          typeof p != "object" && (o[0] = p, p = o);
          for (var c = 0; c < p.length; c++) {
            var g = t[c], v = p[c], m = u[g], y = i[g];
            y && (y[f] = v), v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      }
    }, n.prototype.lttbDownSample = function(e, t) {
      var r = this.clone([e], !0), i = r._chunks, o = i[e], a = this.count(), s = 0, l = Math.floor(1 / t), u = this.getRawIndex(0), c, h, f, d = new (vm(this._rawCount))(Math.min((Math.ceil(a / l) + 2) * 2, a));
      d[s++] = u;
      for (var p = 1; p < a - 1; p += l) {
        for (var g = Math.min(p + l, a - 1), v = Math.min(p + l * 2, a), m = (v + g) / 2, y = 0, b = g; b < v; b++) {
          var O = this.getRawIndex(b), w = o[O];
          isNaN(w) || (y += w);
        }
        y /= v - g;
        var x = p, S = Math.min(p + l, a), _ = p - 1, C = o[u];
        c = -1, f = x;
        for (var A = -1, k = 0, b = x; b < S; b++) {
          var O = this.getRawIndex(b), w = o[O];
          if (isNaN(w)) {
            k++, A < 0 && (A = O);
            continue;
          }
          h = Math.abs((_ - m) * (w - C) - (_ - b) * (y - C)), h > c && (c = h, f = O);
        }
        k > 0 && k < S - x && (d[s++] = Math.min(A, f), f = Math.max(A, f)), d[s++] = f, u = f;
      }
      return d[s++] = this.getRawIndex(a - 1), r._count = s, r._indices = d, r.getRawIndex = this._getRawIdx, r;
    }, n.prototype.downSample = function(e, t, r, i) {
      for (var o = this.clone([e], !0), a = o._chunks, s = [], l = Math.floor(1 / t), u = a[e], c = this.count(), h = o._rawExtent[e] = rp(), f = new (vm(this._rawCount))(Math.ceil(c / l)), d = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          s[g] = u[v];
        }
        var m = r(s), y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1));
        u[y] = m, m < h[0] && (h[0] = m), m > h[1] && (h[1] = m), f[d++] = y;
      }
      return o._count = d, o._indices = f, o._updateGetRawIdx(), o;
    }, n.prototype.each = function(e, t) {
      if (this._count)
        for (var r = e.length, i = this._chunks, o = 0, a = this.count(); o < a; o++) {
          var s = this.getRawIndex(o);
          switch (r) {
            case 0:
              t(o);
              break;
            case 1:
              t(i[e[0]][s], o);
              break;
            case 2:
              t(i[e[0]][s], i[e[1]][s], o);
              break;
            default:
              for (var l = 0, u = []; l < r; l++)
                u[l] = i[e[l]][s];
              u[l] = o, t.apply(null, u);
          }
        }
    }, n.prototype.getDataExtent = function(e) {
      var t = this._chunks[e], r = rp();
      if (!t)
        return r;
      var i = this.count(), o = !this._indices, a;
      if (o)
        return this._rawExtent[e].slice();
      if (a = this._extent[e], a)
        return a.slice();
      a = r;
      for (var s = a[0], l = a[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), h = t[c];
        h < s && (s = h), h > l && (l = h);
      }
      return a = [s, l], this._extent[e] = a, a;
    }, n.prototype.getRawDataItem = function(e) {
      var t = this.getRawIndex(e);
      if (this._provider.persistent)
        return this._provider.getItem(t);
      for (var r = [], i = this._chunks, o = 0; o < i.length; o++)
        r.push(i[o][t]);
      return r;
    }, n.prototype.clone = function(e, t) {
      var r = new n(), i = this._chunks, o = e && xl(e, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (o)
        for (var a = 0; a < i.length; a++)
          r._chunks[a] = o[a] ? KCt(i[a]) : i[a];
      else
        r._chunks = i;
      return this._copyCommonProps(r), t || (r._indices = this._cloneIndices()), r._updateGetRawIdx(), r;
    }, n.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = Fe(this._extent), e._rawExtent = Fe(this._rawExtent);
    }, n.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, t = void 0;
        if (e === Array) {
          var r = this._indices.length;
          t = new e(r);
          for (var i = 0; i < r; i++)
            t[i] = this._indices[i];
        } else
          t = new e(this._indices);
        return t;
      }
      return null;
    }, n.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, n.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, n.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, n.internalField = function() {
      function e(t, r, i, o) {
        return Cc(t[o], this._dimensions[o]);
      }
      cT = {
        arrayRows: e,
        objectRows: function(t, r, i, o) {
          return Cc(t[r], this._dimensions[o]);
        },
        keyedColumns: e,
        original: function(t, r, i, o) {
          var a = t && (t.value == null ? t : t.value);
          return Cc(a instanceof Array ? a[o] : a, this._dimensions[o]);
        },
        typedArray: function(t, r, i, o) {
          return t[o];
        }
      };
    }(), n;
  }()
), Ote = (
  /** @class */
  function() {
    function n(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = e;
    }
    return n.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, n.prototype._setLocalSource = function(e, t) {
      this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, n.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, n.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, n.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, t = this._getUpstreamSourceManagers(), r = !!t.length, i, o;
      if (mm(e)) {
        var a = e, s = void 0, l = void 0, u = void 0;
        if (r) {
          var c = t[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, o = [c._getVersionSign()];
        } else
          s = a.get("data", !0), l = eo(s) ? nu : Va, o = [];
        var h = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, d = qe(h.seriesLayoutBy, f.seriesLayoutBy) || null, p = qe(h.sourceHeader, f.sourceHeader), g = qe(h.dimensions, f.dimensions), v = d !== f.seriesLayoutBy || !!p != !!f.sourceHeader || g;
        i = v ? [UM(s, {
          seriesLayoutBy: d,
          sourceHeader: p,
          dimensions: g
        }, l)] : [];
      } else {
        var m = e;
        if (r) {
          var y = this._applyTransform(t);
          i = y.sourceList, o = y.upstreamSignList;
        } else {
          var b = m.get("source", !0);
          i = [UM(b, this._getSourceMetaRawOption(), null)], o = [];
        }
      }
      process.env.NODE_ENV !== "production" && $e(i && o), this._setLocalSource(i, o);
    }, n.prototype._applyTransform = function(e) {
      var t = this._sourceHost, r = t.get("transform", !0), i = t.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && $e(i != null || r != null), i != null) {
        var o = "";
        e.length !== 1 && (process.env.NODE_ENV !== "production" && (o = "When using `fromTransformResult`, there should be only one upstream dataset"), h6(o));
      }
      var a, s = [], l = [];
      return I(e, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), h = "";
        i != null && !c && (process.env.NODE_ENV !== "production" && (h = "Can not retrieve result by `fromTransformResult`: " + i), h6(h)), s.push(c), l.push(u._getVersionSign());
      }), r ? a = qCt(r, s, {
        datasetIndex: t.componentIndex
      }) : i != null && (a = [PCt(s[0])]), {
        sourceList: a,
        upstreamSignList: l
      };
    }, n.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var r = e[t];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          r._isDirty() || this._upstreamSignList[t] !== r._getVersionSign()
        )
          return !0;
      }
    }, n.prototype.getSource = function(e) {
      e = e || 0;
      var t = this._sourceList[e];
      if (!t) {
        var r = this._getUpstreamSourceManagers();
        return r[0] && r[0].getSource(e);
      }
      return t;
    }, n.prototype.getSharedDataStore = function(e) {
      process.env.NODE_ENV !== "production" && $e(mm(this._sourceHost), "Can only call getDataStore on series source manager.");
      var t = e.makeStoreSchema();
      return this._innerGetDataStore(t.dimensions, e.source, t.hash);
    }, n.prototype._innerGetDataStore = function(e, t, r) {
      var i = 0, o = this._storeList, a = o[i];
      a || (a = o[i] = {});
      var s = a[r];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        mm(this._sourceHost) && l ? s = l._innerGetDataStore(e, t, r) : (s = new KM(), s.initData(new cte(t, e.length), e)), a[r] = s;
      }
      return s;
    }, n.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if (mm(e)) {
        var t = rN(e);
        return t ? [t.getSourceManager()] : [];
      } else
        return le(eCt(e), function(r) {
          return r.getSourceManager();
        });
    }, n.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, t, r, i;
      if (mm(e))
        t = e.get("seriesLayoutBy", !0), r = e.get("sourceHeader", !0), i = e.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var o = e;
        t = o.get("seriesLayoutBy", !0), r = o.get("sourceHeader", !0), i = o.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: t,
        sourceHeader: r,
        dimensions: i
      };
    }, n;
  }()
);
function c6(n) {
  var e = n.option.transform;
  e && aS(n.option.transform);
}
function mm(n) {
  return n.mainType === "series";
}
function h6(n) {
  throw new Error(n);
}
var wte = "line-height:1";
function xte(n, e) {
  var t = n.color || "#6e7079", r = n.fontSize || 12, i = n.fontWeight || "400", o = n.color || "#464646", a = n.fontSize || 14, s = n.fontWeight || "900";
  return e === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + mo(r + "") + "px;color:" + mo(t) + ";font-weight:" + mo(i + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + mo(a + "") + "px;color:" + mo(o) + ";font-weight:" + mo(s + "")
  } : {
    nameStyle: {
      fontSize: r,
      fill: t,
      fontWeight: i
    },
    valueStyle: {
      fontSize: a,
      fill: o,
      fontWeight: s
    }
  };
}
var JCt = [0, 10, 20, 30], e2t = ["", `
`, `

`, `


`];
function Qr(n, e) {
  return e.type = n, e;
}
function JM(n) {
  return n.type === "section";
}
function Ste(n) {
  return JM(n) ? t2t : n2t;
}
function _te(n) {
  if (JM(n)) {
    var e = 0, t = n.blocks.length, r = t > 1 || t > 0 && !n.noHeader;
    return I(n.blocks, function(i) {
      var o = _te(i);
      o >= e && (e = o + +(r && // 0 always can not be readable gap level.
      (!o || JM(i) && !i.noHeader)));
    }), e;
  }
  return 0;
}
function t2t(n, e, t, r) {
  var i = e.noHeader, o = r2t(_te(e)), a = [], s = e.blocks || [];
  $e(!s || se(s)), s = s || [];
  var l = n.orderMode;
  if (e.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Ce(u, l)) {
      var c = new vte(u[l], null);
      s.sort(function(p, g) {
        return c.evaluate(p.sortParam, g.sortParam);
      });
    } else
      l === "seriesDesc" && s.reverse();
  }
  I(s, function(p, g) {
    var v = e.valueFormatter, m = Ste(p)(
      // Inherit valueFormatter
      v ? re(re({}, n), {
        valueFormatter: v
      }) : n,
      p,
      g > 0 ? o.html : 0,
      r
    );
    m != null && a.push(m);
  });
  var h = n.renderMode === "richText" ? a.join(o.richText) : eD(a.join(""), i ? t : o.html);
  if (i)
    return h;
  var f = HM(e.header, "ordinal", n.useUTC), d = xte(r, n.renderMode).nameStyle;
  return n.renderMode === "richText" ? Cte(n, f, d) + o.richText + h : eD('<div style="' + d + ";" + wte + ';">' + mo(f) + "</div>" + h, t);
}
function n2t(n, e, t, r) {
  var i = n.renderMode, o = e.noName, a = e.noValue, s = !e.markerType, l = e.name, u = n.useUTC, c = e.valueFormatter || n.valueFormatter || function(O) {
    return O = se(O) ? O : [O], le(O, function(w, x) {
      return HM(w, se(d) ? d[x] : d, u);
    });
  };
  if (!(o && a)) {
    var h = s ? "" : n.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", i), f = o ? "" : HM(l, "ordinal", u), d = e.valueType, p = a ? [] : c(e.value, e.dataIndex), g = !s || !o, v = !s && o, m = xte(r, i), y = m.nameStyle, b = m.valueStyle;
    return i === "richText" ? (s ? "" : h) + (o ? "" : Cte(n, f, y)) + (a ? "" : a2t(n, p, g, v, b)) : eD((s ? "" : h) + (o ? "" : i2t(f, !s, y)) + (a ? "" : o2t(p, g, v, b)), t);
  }
}
function f6(n, e, t, r, i, o) {
  if (n) {
    var a = Ste(n), s = {
      useUTC: i,
      renderMode: t,
      orderMode: r,
      markupStyleCreator: e,
      valueFormatter: n.valueFormatter
    };
    return a(s, n, 0, o);
  }
}
function r2t(n) {
  return {
    html: JCt[n],
    richText: e2t[n]
  };
}
function eD(n, e) {
  var t = '<div style="clear:both"></div>', r = "margin: " + e + "px 0 0";
  return '<div style="' + r + ";" + wte + ';">' + n + t + "</div>";
}
function i2t(n, e, t) {
  var r = e ? "margin-left:2px" : "";
  return '<span style="' + t + ";" + r + '">' + mo(n) + "</span>";
}
function o2t(n, e, t, r) {
  var i = t ? "10px" : "20px", o = e ? "float:right;margin-left:" + i : "";
  return n = se(n) ? n : [n], '<span style="' + o + ";" + r + '">' + le(n, function(a) {
    return mo(a);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function Cte(n, e, t) {
  return n.markupStyleCreator.wrapRichTextStyle(e, t);
}
function a2t(n, e, t, r, i) {
  var o = [i], a = r ? 10 : 20;
  return t && o.push({
    padding: [0, 0, 0, a],
    align: "right"
  }), n.markupStyleCreator.wrapRichTextStyle(se(e) ? e.join("  ") : e, o);
}
function Ate(n, e) {
  var t = n.getData().getItemVisual(e, "style"), r = t[n.visualDrawType];
  return gd(r);
}
function Tte(n, e) {
  var t = n.get("padding");
  return t ?? (e === "richText" ? [8, 10] : 10);
}
var hT = (
  /** @class */
  function() {
    function n() {
      this.richTextStyles = {}, this._nextStyleNameId = LJ();
    }
    return n.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, n.prototype.makeTooltipMarker = function(e, t, r) {
      var i = r === "richText" ? this._generateStyleName() : null, o = H_t({
        color: t,
        type: e,
        renderMode: r,
        markerId: i
      });
      return we(o) ? o : (process.env.NODE_ENV !== "production" && $e(i), this.richTextStyles[i] = o.style, o.content);
    }, n.prototype.wrapRichTextStyle = function(e, t) {
      var r = {};
      se(t) ? I(t, function(o) {
        return re(r, o);
      }) : re(r, t);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = r, "{" + i + "|" + e + "}";
    }, n;
  }()
);
function kte(n) {
  var e = n.series, t = n.dataIndex, r = n.multipleSeries, i = e.getData(), o = i.mapDimensionsAll("defaultedTooltip"), a = o.length, s = e.getRawValue(t), l = se(s), u = Ate(e, t), c, h, f, d;
  if (a > 1 || l && !a) {
    var p = s2t(s, e, t, o, u);
    c = p.inlineValues, h = p.inlineValueTypes, f = p.blocks, d = p.inlineValues[0];
  } else if (a) {
    var g = i.getDimensionInfo(o[0]);
    d = c = Xg(i, t, o[0]), h = g.type;
  } else
    d = c = l ? s[0] : s;
  var v = LR(e), m = v && e.name || "", y = i.getName(t), b = r ? m : y;
  return Qr("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: r || !v,
    sortParam: d,
    blocks: [Qr("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: b,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !is(b),
      value: c,
      valueType: h,
      dataIndex: t
    })].concat(f || [])
  });
}
function s2t(n, e, t, r, i) {
  var o = e.getData(), a = xl(n, function(h, f, d) {
    var p = o.getDimensionInfo(d);
    return h = h || p && p.tooltip !== !1 && p.displayName != null;
  }, !1), s = [], l = [], u = [];
  r.length ? I(r, function(h) {
    c(Xg(o, t, h), h);
  }) : I(n, c);
  function c(h, f) {
    var d = o.getDimensionInfo(f);
    !d || d.otherDims.tooltip === !1 || (a ? u.push(Qr("nameValue", {
      markerType: "subItem",
      markerColor: i,
      name: d.displayName,
      value: h,
      valueType: d.type
    })) : (s.push(h), l.push(d.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var Nu = It();
function yO(n, e) {
  return n.getName(e) || n.getId(e);
}
var Xw = "__universalTransitionEnabled", BC = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t._selectedDataIndicesMap = {}, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = Vy({
        count: u2t,
        reset: c2t
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(t, i);
      var o = Nu(this).sourceManager = new Ote(this);
      o.prepareSource();
      var a = this.getInitialData(t, i);
      p6(a, this), this.dataTask.context.data = a, process.env.NODE_ENV !== "production" && $e(a, "getInitialData returned invalid data."), Nu(this).dataBeforeProcessed = a, d6(this), this._initSelectedMapFromData(a);
    }, e.prototype.mergeDefaultAndTheme = function(t, r) {
      var i = z0(this), o = i ? Bv(t) : {}, a = this.subType;
      Pt.hasClass(a) && (a += "Series"), it(t, r.getTheme().get(this.subType)), it(t, this.getDefaultOption()), hd(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && Xc(t, o, i);
    }, e.prototype.mergeOption = function(t, r) {
      t = it(this.option, t, !0), this.fillDataTextStyle(t.data);
      var i = z0(this);
      i && Xc(this.option, t, i);
      var o = Nu(this).sourceManager;
      o.dirty(), o.prepareSource();
      var a = this.getInitialData(t, r);
      p6(a, this), this.dataTask.dirty(), this.dataTask.context.data = a, Nu(this).dataBeforeProcessed = a, d6(this), this._initSelectedMapFromData(a);
    }, e.prototype.fillDataTextStyle = function(t) {
      if (t && !eo(t))
        for (var r = ["show"], i = 0; i < t.length; i++)
          t[i] && t[i].label && hd(t[i], "label", r);
    }, e.prototype.getInitialData = function(t, r) {
    }, e.prototype.appendData = function(t) {
      var r = this.getRawData();
      r.appendData(t.data);
    }, e.prototype.getData = function(t) {
      var r = tD(this);
      if (r) {
        var i = r.context.data;
        return t == null ? i : i.getLinkedData(t);
      } else
        return Nu(this).data;
    }, e.prototype.getAllData = function() {
      var t = this.getData();
      return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{
        data: t
      }];
    }, e.prototype.setData = function(t) {
      var r = tD(this);
      if (r) {
        var i = r.context;
        i.outputData = t, r !== this.dataTask && (i.data = t);
      }
      Nu(this).data = t;
    }, e.prototype.getEncode = function() {
      var t = this.get("encode", !0);
      if (t)
        return Ee(t);
    }, e.prototype.getSourceManager = function() {
      return Nu(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return Nu(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var t = this.get("colorBy");
      return t || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var t = this.coordinateSystem;
      return t && t.getBaseAxis && t.getBaseAxis();
    }, e.prototype.formatTooltip = function(t, r, i) {
      return kte({
        series: this,
        dataIndex: t,
        multipleSeries: r
      });
    }, e.prototype.isAnimationEnabled = function() {
      var t = this.ecModel;
      if (mt.node && !(t && t.ssr))
        return !1;
      var r = this.getShallow("animation");
      return r && this.getData().count() > this.getShallow("animationThreshold") && (r = !1), !!r;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(t, r, i) {
      var o = this.ecModel, a = iN.prototype.getColorFromPalette.call(this, t, r, i);
      return a || (a = o.getColorFromPalette(t, r, i)), a;
    }, e.prototype.coordDimToDataDim = function(t) {
      return this.getRawData().mapDimensionsAll(t);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(t, r) {
      this._innerSelect(this.getData(r), t);
    }, e.prototype.unselect = function(t, r) {
      var i = this.option.selectedMap;
      if (i) {
        var o = this.option.selectedMode, a = this.getData(r);
        if (o === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < t.length; s++) {
          var l = t[s], u = yO(a, l);
          i[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(t, r) {
      for (var i = [], o = 0; o < t.length; o++)
        i[0] = t[o], this.isSelected(t[o], r) ? this.unselect(i, r) : this.select(i, r);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var t = this._selectedDataIndicesMap, r = Ot(t), i = [], o = 0; o < r.length; o++) {
        var a = t[r[o]];
        a >= 0 && i.push(a);
      }
      return i;
    }, e.prototype.isSelected = function(t, r) {
      var i = this.option.selectedMap;
      if (!i)
        return !1;
      var o = this.getData(r);
      return (i === "all" || i[yO(o, t)]) && !o.getItemModel(t).get(["select", "disabled"]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[Xw])
        return !0;
      var t = this.option.universalTransition;
      return t ? t === !0 ? !0 : t && t.enabled : !1;
    }, e.prototype._innerSelect = function(t, r) {
      var i, o, a = this.option, s = a.selectedMode, l = r.length;
      if (!(!s || !l)) {
        if (s === "series")
          a.selectedMap = "all";
        else if (s === "multiple") {
          Ne(a.selectedMap) || (a.selectedMap = {});
          for (var u = a.selectedMap, c = 0; c < l; c++) {
            var h = r[c], f = yO(t, h);
            u[f] = !0, this._selectedDataIndicesMap[f] = t.getRawIndex(h);
          }
        } else if (s === "single" || s === !0) {
          var d = r[l - 1], f = yO(t, d);
          a.selectedMap = (i = {}, i[f] = !0, i), this._selectedDataIndicesMap = (o = {}, o[f] = t.getRawIndex(d), o);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(t) {
      if (!this.option.selectedMap) {
        var r = [];
        t.hasItemOption && t.each(function(i) {
          var o = t.getRawDataItem(i);
          o && o.selected && r.push(i);
        }), r.length > 0 && this._innerSelect(t, r);
      }
    }, e.registerClass = function(t) {
      return Pt.registerClass(t);
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
    }(), e;
  }(Pt)
);
mr(BC, uN);
mr(BC, iN);
QJ(BC, Pt);
function d6(n) {
  var e = n.name;
  LR(n) || (n.name = l2t(n) || e);
}
function l2t(n) {
  var e = n.getRawData(), t = e.mapDimensionsAll("seriesName"), r = [];
  return I(t, function(i) {
    var o = e.getDimensionInfo(i);
    o.displayName && r.push(o.displayName);
  }), r.join(" ");
}
function u2t(n) {
  return n.model.getRawData().count();
}
function c2t(n) {
  var e = n.model;
  return e.setData(e.getRawData().cloneShallow()), h2t;
}
function h2t(n, e) {
  e.outputData && n.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
}
function p6(n, e) {
  I(sS(n.CHANGABLE_METHODS, n.DOWNSAMPLE_METHODS), function(t) {
    n.wrapMethod(t, Je(f2t, e));
  });
}
function f2t(n, e) {
  var t = tD(n);
  return t && t.setOutputEnd((e || this).count()), e;
}
function tD(n) {
  var e = (n.ecModel || {}).scheduler, t = e && e.getPipeline(n.uid);
  if (t) {
    var r = t.currentTask;
    if (r) {
      var i = r.agentStubMap;
      i && (r = i.get(n.uid));
    }
    return r;
  }
}
const Ln = BC;
var hN = (
  /** @class */
  function() {
    function n() {
      this.group = new We(), this.uid = Nv("viewComponent");
    }
    return n.prototype.init = function(e, t) {
    }, n.prototype.render = function(e, t, r, i) {
    }, n.prototype.dispose = function(e, t) {
    }, n.prototype.updateView = function(e, t, r, i) {
    }, n.prototype.updateLayout = function(e, t, r, i) {
    }, n.prototype.updateVisual = function(e, t, r, i) {
    }, n.prototype.toggleBlurSeries = function(e, t, r) {
    }, n.prototype.eachRendered = function(e) {
      var t = this.group;
      t && t.traverse(e);
    }, n;
  }()
);
RR(hN);
bC(hN);
const Gn = hN;
function Qv() {
  var n = It();
  return function(e) {
    var t = n(e), r = e.pipelineContext, i = !!t.large, o = !!t.progressiveRender, a = t.large = !!(r && r.large), s = t.progressiveRender = !!(r && r.progressiveRender);
    return (i !== a || o !== s) && "reset";
  };
}
var Pte = It(), d2t = Qv(), fN = (
  /** @class */
  function() {
    function n() {
      this.group = new We(), this.uid = Nv("viewChart"), this.renderTask = Vy({
        plan: p2t,
        reset: g2t
      }), this.renderTask.context = {
        view: this
      };
    }
    return n.prototype.init = function(e, t) {
    }, n.prototype.render = function(e, t, r, i) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, n.prototype.highlight = function(e, t, r, i) {
      var o = e.getData(i && i.dataType);
      if (!o) {
        process.env.NODE_ENV !== "production" && bi("Unknown dataType " + i.dataType);
        return;
      }
      v6(o, i, "emphasis");
    }, n.prototype.downplay = function(e, t, r, i) {
      var o = e.getData(i && i.dataType);
      if (!o) {
        process.env.NODE_ENV !== "production" && bi("Unknown dataType " + i.dataType);
        return;
      }
      v6(o, i, "normal");
    }, n.prototype.remove = function(e, t) {
      this.group.removeAll();
    }, n.prototype.dispose = function(e, t) {
    }, n.prototype.updateView = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.updateLayout = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.updateVisual = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.eachRendered = function(e) {
      dh(this.group, e);
    }, n.markUpdateMethod = function(e, t) {
      Pte(e).updateMethod = t;
    }, n.protoInitialize = function() {
      var e = n.prototype;
      e.type = "chart";
    }(), n;
  }()
);
function g6(n, e, t) {
  n && qc(n) && (e === "emphasis" ? gu : vu)(n, t);
}
function v6(n, e, t) {
  var r = fd(n, e), i = e && e.highlightKey != null ? FSt(e.highlightKey) : null;
  r != null ? I(an(r), function(o) {
    g6(n.getItemGraphicEl(o), t, i);
  }) : n.eachItemGraphicEl(function(o) {
    g6(o, t, i);
  });
}
RR(fN, ["dispose"]);
bC(fN);
function p2t(n) {
  return d2t(n.model);
}
function g2t(n) {
  var e = n.model, t = n.ecModel, r = n.api, i = n.payload, o = e.pipelineContext.progressiveRender, a = n.view, s = i && Pte(i).updateMethod, l = o ? "incrementalPrepareRender" : s && a[s] ? s : "render";
  return l !== "render" && a[l](e, t, r, i), v2t[l];
}
var v2t = {
  incrementalPrepareRender: {
    progress: function(n, e) {
      e.view.incrementalRender(n, e.model, e.ecModel, e.api, e.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(n, e) {
      e.view.render(e.model, e.ecModel, e.api, e.payload);
    }
  }
};
const bn = fN;
var _S = "\0__throttleOriginMethod", m6 = "\0__throttleRate", y6 = "\0__throttleType";
function dN(n, e, t) {
  var r, i = 0, o = 0, a = null, s, l, u, c;
  e = e || 0;
  function h() {
    o = (/* @__PURE__ */ new Date()).getTime(), a = null, n.apply(l, u || []);
  }
  var f = function() {
    for (var d = [], p = 0; p < arguments.length; p++)
      d[p] = arguments[p];
    r = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
    var g = c || e, v = c || t;
    c = null, s = r - (v ? i : o) - g, clearTimeout(a), v ? a = setTimeout(h, g) : s >= 0 ? h() : a = setTimeout(h, -s), i = r;
  };
  return f.clear = function() {
    a && (clearTimeout(a), a = null);
  }, f.debounceNextCall = function(d) {
    c = d;
  }, f;
}
function Zv(n, e, t, r) {
  var i = n[e];
  if (i) {
    var o = i[_S] || i, a = i[y6], s = i[m6];
    if (s !== t || a !== r) {
      if (t == null || !r)
        return n[e] = o;
      i = n[e] = dN(o, t, r === "debounce"), i[_S] = o, i[y6] = r, i[m6] = t;
    }
    return i;
  }
}
function Q0(n, e) {
  var t = n[e];
  t && t[_S] && (t.clear && t.clear(), n[e] = t[_S]);
}
var b6 = It(), O6 = {
  itemStyle: dd(Nee, !0),
  lineStyle: dd(Ree, !0)
}, m2t = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function Ete(n, e) {
  var t = n.visualStyleMapper || O6[e];
  return t || (console.warn("Unknown style type '" + e + "'."), O6.itemStyle);
}
function Mte(n, e) {
  var t = n.visualDrawType || m2t[e];
  return t || (console.warn("Unknown style type '" + e + "'."), "fill");
}
var y2t = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(n, e) {
    var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = n.getModel(r), o = Ete(n, r), a = o(i), s = i.getShallow("decal");
    s && (t.setVisual("decal", s), s.dirty = !0);
    var l = Mte(n, r), u = a[l], c = Le(u) ? u : null, h = a.fill === "auto" || a.stroke === "auto";
    if (!a[l] || c || h) {
      var f = n.getColorFromPalette(
        // TODO series count changed.
        n.name,
        null,
        e.getSeriesCount()
      );
      a[l] || (a[l] = f, t.setVisual("colorFromPalette", !0)), a.fill = a.fill === "auto" || Le(a.fill) ? f : a.fill, a.stroke = a.stroke === "auto" || Le(a.stroke) ? f : a.stroke;
    }
    if (t.setVisual("style", a), t.setVisual("drawType", l), !e.isSeriesFiltered(n) && c)
      return t.setVisual("colorFromPalette", !1), {
        dataEach: function(d, p) {
          var g = n.getDataParams(p), v = re({}, a);
          v[l] = c(g), d.setItemVisual(p, "style", v);
        }
      };
  }
}, ym = new mn(), b2t = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(n, e) {
    if (!(n.ignoreStyleOnData || e.isSeriesFiltered(n))) {
      var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = Ete(n, r), o = t.getVisual("drawType");
      return {
        dataEach: t.hasItemOption ? function(a, s) {
          var l = a.getRawDataItem(s);
          if (l && l[r]) {
            ym.option = l[r];
            var u = i(ym), c = a.ensureUniqueItemVisual(s, "style");
            re(c, u), ym.option.decal && (a.setItemVisual(s, "decal", ym.option.decal), ym.option.decal.dirty = !0), o in u && a.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, O2t = {
  performRawSeries: !0,
  overallReset: function(n) {
    var e = Ee();
    n.eachSeries(function(t) {
      var r = t.getColorBy();
      if (!t.isColorBySeries()) {
        var i = t.type + "-" + r, o = e.get(i);
        o || (o = {}, e.set(i, o)), b6(t).scope = o;
      }
    }), n.eachSeries(function(t) {
      if (!(t.isColorBySeries() || n.isSeriesFiltered(t))) {
        var r = t.getRawData(), i = {}, o = t.getData(), a = b6(t).scope, s = t.visualStyleAccessPath || "itemStyle", l = Mte(t, s);
        o.each(function(u) {
          var c = o.getRawIndex(u);
          i[c] = u;
        }), r.each(function(u) {
          var c = i[u], h = o.getItemVisual(c, "colorFromPalette");
          if (h) {
            var f = o.ensureUniqueItemVisual(c, "style"), d = r.getName(u) || u + "", p = r.count();
            f[l] = t.getColorFromPalette(d, a, p);
          }
        });
      }
    });
  }
}, bO = Math.PI;
function w2t(n, e) {
  e = e || {}, Be(e, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var t = new We(), r = new Lt({
    style: {
      fill: e.maskColor
    },
    zlevel: e.zlevel,
    z: 1e4
  });
  t.add(r);
  var i = new Nt({
    style: {
      text: e.text,
      fill: e.textColor,
      fontSize: e.fontSize,
      fontWeight: e.fontWeight,
      fontStyle: e.fontStyle,
      fontFamily: e.fontFamily
    },
    zlevel: e.zlevel,
    z: 10001
  }), o = new Lt({
    style: {
      fill: "none"
    },
    textContent: i,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: e.zlevel,
    z: 10001
  });
  t.add(o);
  var a;
  return e.showSpinner && (a = new GR({
    shape: {
      startAngle: -bO / 2,
      endAngle: -bO / 2 + 0.1,
      r: e.spinnerRadius
    },
    style: {
      stroke: e.color,
      lineCap: "round",
      lineWidth: e.lineWidth
    },
    zlevel: e.zlevel,
    z: 10001
  }), a.animateShape(!0).when(1e3, {
    endAngle: bO * 3 / 2
  }).start("circularInOut"), a.animateShape(!0).when(1e3, {
    startAngle: bO * 3 / 2
  }).delay(300).start("circularInOut"), t.add(a)), t.resize = function() {
    var s = i.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (n.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = n.getHeight() / 2;
    e.showSpinner && a.setShape({
      cx: u,
      cy: c
    }), o.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), r.setShape({
      x: 0,
      y: 0,
      width: n.getWidth(),
      height: n.getHeight()
    });
  }, t.resize(), t;
}
var Dte = (
  /** @class */
  function() {
    function n(e, t, r, i) {
      this._stageTaskMap = Ee(), this.ecInstance = e, this.api = t, r = this._dataProcessorHandlers = r.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = r.concat(i);
    }
    return n.prototype.restoreData = function(e, t) {
      e.restoreData(t), this._stageTaskMap.each(function(r) {
        var i = r.overallTask;
        i && i.dirty();
      });
    }, n.prototype.getPerformArgs = function(e, t) {
      if (e.__pipeline) {
        var r = this._pipelineMap.get(e.__pipeline.id), i = r.context, o = !t && r.progressiveEnabled && (!i || i.progressiveRender) && e.__idxInPipeline > r.blockIndex, a = o ? r.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / a) : null;
        return {
          step: a,
          modBy: l,
          modDataCount: s
        };
      }
    }, n.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, n.prototype.updateStreamModes = function(e, t) {
      var r = this._pipelineMap.get(e.uid), i = e.getData(), o = i.count(), a = r.progressiveEnabled && t.incrementalPrepareRender && o >= r.threshold, s = e.get("large") && o >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? o : null;
      e.pipelineContext = r.context = {
        progressiveRender: a,
        modDataCount: l,
        large: s
      };
    }, n.prototype.restorePipelines = function(e) {
      var t = this, r = t._pipelineMap = Ee();
      e.eachSeries(function(i) {
        var o = i.getProgressive(), a = i.uid;
        r.set(a, {
          id: a,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: o && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(o || 700),
          count: 0
        }), t._pipe(i, i.dataTask);
      });
    }, n.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, t = this.api.getModel(), r = this.api;
      I(this._allHandlers, function(i) {
        var o = e.get(i.uid) || e.set(i.uid, {}), a = "";
        process.env.NODE_ENV !== "production" && (a = '"reset" and "overallReset" must not be both specified.'), $e(!(i.reset && i.overallReset), a), i.reset && this._createSeriesStageTask(i, o, t, r), i.overallReset && this._createOverallStageTask(i, o, t, r);
      }, this);
    }, n.prototype.prepareView = function(e, t, r, i) {
      var o = e.renderTask, a = o.context;
      a.model = t, a.ecModel = r, a.api = i, o.__block = !e.incrementalPrepareRender, this._pipe(t, o);
    }, n.prototype.performDataProcessorTasks = function(e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, {
        block: !0
      });
    }, n.prototype.performVisualTasks = function(e, t, r) {
      this._performStageTasks(this._visualHandlers, e, t, r);
    }, n.prototype._performStageTasks = function(e, t, r, i) {
      i = i || {};
      var o = !1, a = this;
      I(e, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = a._stageTaskMap.get(l.uid), h = c.seriesTaskMap, f = c.overallTask;
          if (f) {
            var d, p = f.agentStubMap;
            p.each(function(v) {
              s(i, v) && (v.dirty(), d = !0);
            }), d && f.dirty(), a.updatePayload(f, r);
            var g = a.getPerformArgs(f, i.block);
            p.each(function(v) {
              v.perform(g);
            }), f.perform(g) && (o = !0);
          } else
            h && h.each(function(v, m) {
              s(i, v) && v.dirty();
              var y = a.getPerformArgs(v, i.block);
              y.skip = !l.performRawSeries && t.isSeriesFiltered(v.context.model), a.updatePayload(v, r), v.perform(y) && (o = !0);
            });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = o || this.unfinished;
    }, n.prototype.performSeriesTasks = function(e) {
      var t;
      e.eachSeries(function(r) {
        t = r.dataTask.perform() || t;
      }), this.unfinished = t || this.unfinished;
    }, n.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var t = e.tail;
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline;
            break;
          }
          t = t.getUpstream();
        } while (t);
      });
    }, n.prototype.updatePayload = function(e, t) {
      t !== "remain" && (e.context.payload = t);
    }, n.prototype._createSeriesStageTask = function(e, t, r, i) {
      var o = this, a = t.seriesTaskMap, s = t.seriesTaskMap = Ee(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? r.eachRawSeries(c) : l ? r.eachRawSeriesByType(l, c) : u && u(r, i).each(c);
      function c(h) {
        var f = h.uid, d = s.set(f, a && a.get(f) || Vy({
          plan: A2t,
          reset: T2t,
          count: P2t
        }));
        d.context = {
          model: h,
          ecModel: r,
          api: i,
          // PENDING: `useClearVisual` not used?
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: o
        }, o._pipe(h, d);
      }
    }, n.prototype._createOverallStageTask = function(e, t, r, i) {
      var o = this, a = t.overallTask = t.overallTask || Vy({
        reset: x2t
      });
      a.context = {
        ecModel: r,
        api: i,
        overallReset: e.overallReset,
        scheduler: o
      };
      var s = a.agentStubMap, l = a.agentStubMap = Ee(), u = e.seriesType, c = e.getTargetSeries, h = !0, f = !1, d = "";
      process.env.NODE_ENV !== "production" && (d = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), $e(!e.createOnAllSeries, d), u ? r.eachRawSeriesByType(u, p) : c ? c(r, i).each(p) : (h = !1, I(r.getSeries(), p));
      function p(g) {
        var v = g.uid, m = l.set(v, s && s.get(v) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (f = !0, Vy({
          reset: S2t,
          onDirty: C2t
        })));
        m.context = {
          model: g,
          overallProgress: h
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = a, m.__block = h, o._pipe(g, m);
      }
      f && a.dirty();
    }, n.prototype._pipe = function(e, t) {
      var r = e.uid, i = this._pipelineMap.get(r);
      !i.head && (i.head = t), i.tail && i.tail.pipe(t), i.tail = t, t.__idxInPipeline = i.count++, t.__pipeline = i;
    }, n.wrapStageHandler = function(e, t) {
      return Le(e) && (e = {
        overallReset: e,
        seriesType: E2t(e)
      }), e.uid = Nv("stageHandler"), t && (e.visualType = t), e;
    }, n;
  }()
);
function x2t(n) {
  n.overallReset(n.ecModel, n.api, n.payload);
}
function S2t(n) {
  return n.overallProgress && _2t;
}
function _2t() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function C2t() {
  this.agent && this.agent.dirty();
}
function A2t(n) {
  return n.plan ? n.plan(n.model, n.ecModel, n.api, n.payload) : null;
}
function T2t(n) {
  n.useClearVisual && n.data.clearAllVisual();
  var e = n.resetDefines = an(n.reset(n.model, n.ecModel, n.api, n.payload));
  return e.length > 1 ? le(e, function(t, r) {
    return Lte(r);
  }) : k2t;
}
var k2t = Lte(0);
function Lte(n) {
  return function(e, t) {
    var r = t.data, i = t.resetDefines[n];
    if (i && i.dataEach)
      for (var o = e.start; o < e.end; o++)
        i.dataEach(r, o);
    else
      i && i.progress && i.progress(e, r);
  };
}
function P2t(n) {
  return n.data.count();
}
function E2t(n) {
  CS = null;
  try {
    n(Z0, Ite);
  } catch {
  }
  return CS;
}
var Z0 = {}, Ite = {}, CS;
Rte(Z0, oN);
Rte(Ite, ote);
Z0.eachSeriesByType = Z0.eachRawSeriesByType = function(n) {
  CS = n;
};
Z0.eachComponent = function(n) {
  n.mainType === "series" && n.subType && (CS = n.subType);
};
function Rte(n, e) {
  for (var t in e.prototype)
    n[t] = nr;
}
var w6 = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const M2t = {
  color: w6,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], w6]
};
var Qi = "#B9B8CE", x6 = "#100C2A", OO = function() {
  return {
    axisLine: {
      lineStyle: {
        color: Qi
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, S6 = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], Nte = {
  darkMode: !0,
  color: S6,
  backgroundColor: x6,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: Qi
    }
  },
  textStyle: {
    color: Qi
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: Qi
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: Qi
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: Qi
    }
  },
  timeline: {
    lineStyle: {
      color: Qi
    },
    label: {
      color: Qi
    },
    controlStyle: {
      color: Qi,
      borderColor: Qi
    }
  },
  calendar: {
    itemStyle: {
      color: x6
    },
    dayLabel: {
      color: Qi
    },
    monthLabel: {
      color: Qi
    },
    yearLabel: {
      color: Qi
    }
  },
  timeAxis: OO(),
  logAxis: OO(),
  valueAxis: OO(),
  categoryAxis: OO(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: S6
  },
  gauge: {
    title: {
      color: Qi
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: Qi
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
Nte.categoryAxis.splitLine.show = !1;
const D2t = Nte;
var L2t = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.normalizeQuery = function(e) {
      var t = {}, r = {}, i = {};
      if (we(e)) {
        var o = il(e);
        t.mainType = o.main || null, t.subType = o.sub || null;
      } else {
        var a = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        I(e, function(l, u) {
          for (var c = !1, h = 0; h < a.length; h++) {
            var f = a[h], d = u.lastIndexOf(f);
            if (d > 0 && d === u.length - f.length) {
              var p = u.slice(0, d);
              p !== "data" && (t.mainType = p, t[f.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (r[u] = l, c = !0), c || (i[u] = l);
        });
      }
      return {
        cptQuery: t,
        dataQuery: r,
        otherQuery: i
      };
    }, n.prototype.filter = function(e, t) {
      var r = this.eventInfo;
      if (!r)
        return !0;
      var i = r.targetEl, o = r.packedEvent, a = r.model, s = r.view;
      if (!a || !s)
        return !0;
      var l = t.cptQuery, u = t.dataQuery;
      return c(l, a, "mainType") && c(l, a, "subType") && c(l, a, "index", "componentIndex") && c(l, a, "name") && c(l, a, "id") && c(u, o, "name") && c(u, o, "dataIndex") && c(u, o, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, t.otherQuery, i, o));
      function c(h, f, d, p) {
        return h[d] == null || f[p || d] === h[d];
      }
    }, n.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, n;
  }()
), nD = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], _6 = nD.concat(["symbolKeepAspect"]), I2t = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(n, e) {
    var t = n.getData();
    if (n.legendIcon && t.setVisual("legendIcon", n.legendIcon), !n.hasSymbolVisual)
      return;
    for (var r = {}, i = {}, o = !1, a = 0; a < nD.length; a++) {
      var s = nD[a], l = n.get(s);
      Le(l) ? (o = !0, i[s] = l) : r[s] = l;
    }
    if (r.symbol = r.symbol || n.defaultSymbol, t.setVisual(re({
      legendIcon: n.legendIcon || r.symbol,
      symbolKeepAspect: n.get("symbolKeepAspect")
    }, r)), e.isSeriesFiltered(n))
      return;
    var u = Ot(i);
    function c(h, f) {
      for (var d = n.getRawValue(f), p = n.getDataParams(f), g = 0; g < u.length; g++) {
        var v = u[g];
        h.setItemVisual(f, v, i[v](d, p));
      }
    }
    return {
      dataEach: o ? c : null
    };
  }
}, R2t = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(n, e) {
    if (!n.hasSymbolVisual || e.isSeriesFiltered(n))
      return;
    var t = n.getData();
    function r(i, o) {
      for (var a = i.getItemModel(o), s = 0; s < _6.length; s++) {
        var l = _6[s], u = a.getShallow(l, !0);
        u != null && i.setItemVisual(o, l, u);
      }
    }
    return {
      dataEach: t.hasItemOption ? r : null
    };
  }
};
function pN(n, e, t) {
  switch (t) {
    case "color":
      var r = n.getItemVisual(e, "style");
      return r[n.getVisual("drawType")];
    case "opacity":
      return n.getItemVisual(e, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return n.getItemVisual(e, t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Zb(n, e) {
  switch (e) {
    case "color":
      var t = n.getVisual("style");
      return t[n.getVisual("drawType")];
    case "opacity":
      return n.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return n.getVisual(e);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + e);
  }
}
function $te(n, e, t, r) {
  switch (t) {
    case "color":
      var i = n.ensureUniqueItemVisual(e, "style");
      i[n.getVisual("drawType")] = r, n.setItemVisual(e, "colorFromPalette", !1);
      break;
    case "opacity":
      n.ensureUniqueItemVisual(e, "style").opacity = r;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      n.setItemVisual(e, t, r);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Bte(n, e) {
  function t(r, i) {
    var o = [];
    return r.eachComponent({
      mainType: "series",
      subType: n,
      query: i
    }, function(a) {
      o.push(a.seriesIndex);
    }), o;
  }
  I([[n + "ToggleSelect", "toggleSelect"], [n + "Select", "select"], [n + "UnSelect", "unselect"]], function(r) {
    e(r[0], function(i, o, a) {
      i = re({}, i), process.env.NODE_ENV !== "production" && lr(i.type, r[1]), a.dispatchAction(re(i, {
        type: r[1],
        seriesIndex: t(o, i)
      }));
    });
  });
}
function ip(n, e, t, r, i) {
  var o = n + e;
  t.isSilent(o) || (process.env.NODE_ENV !== "production" && vs("event " + o + " is deprecated."), r.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(a) {
    for (var s = a.seriesIndex, l = a.option.selectedMap, u = i.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var h = a.getData(), f = fd(h, i.fromActionPayload);
        t.trigger(o, {
          type: o,
          seriesId: a.id,
          name: se(f) ? h.getName(f[0]) : h.getName(f),
          selected: we(l) ? l : re({}, l)
        });
      }
  }));
}
function N2t(n, e, t) {
  n.on("selectchanged", function(r) {
    var i = t.getModel();
    r.isFromClick ? (ip("map", "selectchanged", e, i, r), ip("pie", "selectchanged", e, i, r)) : r.fromAction === "select" ? (ip("map", "selected", e, i, r), ip("pie", "selected", e, i, r)) : r.fromAction === "unselect" && (ip("map", "unselected", e, i, r), ip("pie", "unselected", e, i, r));
  });
}
function _f(n, e, t) {
  for (var r; n && !(e(n) && (r = n, t)); )
    n = n.__hostTarget || n.parent;
  return r;
}
var $2t = Math.round(Math.random() * 9), B2t = typeof Object.defineProperty == "function", V2t = function() {
  function n() {
    this._id = "__ec_inner_" + $2t++;
  }
  return n.prototype.get = function(e) {
    return this._guard(e)[this._id];
  }, n.prototype.set = function(e, t) {
    var r = this._guard(e);
    return B2t ? Object.defineProperty(r, this._id, {
      value: t,
      enumerable: !1,
      configurable: !0
    }) : r[this._id] = t, this;
  }, n.prototype.delete = function(e) {
    return this.has(e) ? (delete this._guard(e)[this._id], !0) : !1;
  }, n.prototype.has = function(e) {
    return !!this._guard(e)[this._id];
  }, n.prototype._guard = function(e) {
    if (e !== Object(e))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return e;
  }, n;
}(), z2t = gt.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.cx, r = e.cy, i = e.width / 2, o = e.height / 2;
    n.moveTo(t, r - o), n.lineTo(t + i, r + o), n.lineTo(t - i, r + o), n.closePath();
  }
}), F2t = gt.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.cx, r = e.cy, i = e.width / 2, o = e.height / 2;
    n.moveTo(t, r - o), n.lineTo(t + i, r), n.lineTo(t, r + o), n.lineTo(t - i, r), n.closePath();
  }
}), Q2t = gt.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.x, r = e.y, i = e.width / 5 * 3, o = Math.max(i, e.height), a = i / 2, s = a * a / (o - a), l = r - o + a + s, u = Math.asin(s / a), c = Math.cos(u) * a, h = Math.sin(u), f = Math.cos(u), d = a * 0.6, p = a * 0.7;
    n.moveTo(t - c, l + s), n.arc(t, l, a, Math.PI - u, Math.PI * 2 + u), n.bezierCurveTo(t + c - h * d, l + s + f * d, t, r - p, t, r), n.bezierCurveTo(t, r - p, t - c + h * d, l + s + f * d, t - c, l + s), n.closePath();
  }
}), Z2t = gt.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.height, r = e.width, i = e.x, o = e.y, a = r / 3 * 2;
    n.moveTo(i, o), n.lineTo(i + a, o + t), n.lineTo(i, o + t / 4 * 3), n.lineTo(i - a, o + t), n.lineTo(i, o), n.closePath();
  }
}), W2t = {
  line: Br,
  rect: Lt,
  roundRect: Lt,
  square: Lt,
  circle: fh,
  diamond: F2t,
  pin: Q2t,
  arrow: Z2t,
  triangle: z2t
}, G2t = {
  line: function(n, e, t, r, i) {
    i.x1 = n, i.y1 = e + r / 2, i.x2 = n + t, i.y2 = e + r / 2;
  },
  rect: function(n, e, t, r, i) {
    i.x = n, i.y = e, i.width = t, i.height = r;
  },
  roundRect: function(n, e, t, r, i) {
    i.x = n, i.y = e, i.width = t, i.height = r, i.r = Math.min(t, r) / 4;
  },
  square: function(n, e, t, r, i) {
    var o = Math.min(t, r);
    i.x = n, i.y = e, i.width = o, i.height = o;
  },
  circle: function(n, e, t, r, i) {
    i.cx = n + t / 2, i.cy = e + r / 2, i.r = Math.min(t, r) / 2;
  },
  diamond: function(n, e, t, r, i) {
    i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r;
  },
  pin: function(n, e, t, r, i) {
    i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r;
  },
  arrow: function(n, e, t, r, i) {
    i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r;
  },
  triangle: function(n, e, t, r, i) {
    i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r;
  }
}, AS = {};
I(W2t, function(n, e) {
  AS[e] = new n();
});
var j2t = gt.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(n, e, t) {
    var r = pS(n, e, t), i = this.shape;
    return i && i.symbolType === "pin" && e.position === "inside" && (r.y = t.y + t.height * 0.4), r;
  },
  buildPath: function(n, e, t) {
    var r = e.symbolType;
    if (r !== "none") {
      var i = AS[r];
      i || (r = "rect", i = AS[r]), G2t[r](e.x, e.y, e.width, e.height, i.shape), i.buildPath(n, i.shape, t);
    }
  }
});
function H2t(n, e) {
  if (this.type !== "image") {
    var t = this.style;
    this.__isEmptyBrush ? (t.stroke = n, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = n : t.fill = n, this.markRedraw();
  }
}
function vr(n, e, t, r, i, o, a) {
  var s = n.indexOf("empty") === 0;
  s && (n = n.substr(5, 1).toLowerCase() + n.substr(6));
  var l;
  return n.indexOf("image://") === 0 ? l = Tee(n.slice(8), new ot(e, t, r, i), a ? "center" : "cover") : n.indexOf("path://") === 0 ? l = TC(n.slice(7), {}, new ot(e, t, r, i), a ? "center" : "cover") : l = new j2t({
    shape: {
      symbolType: n,
      x: e,
      y: t,
      width: r,
      height: i
    }
  }), l.__isEmptyBrush = s, l.setColor = H2t, o && l.setColor(o), l;
}
function Wv(n) {
  return se(n) || (n = [+n, +n]), [n[0] || 0, n[1] || 0];
}
function Id(n, e) {
  if (n != null)
    return se(n) || (n = [n, n]), [be(n[0], e[0]) || 0, be(qe(n[1], n[0]), e[1]) || 0];
}
function Cf(n) {
  return isFinite(n);
}
function q2t(n, e, t) {
  var r = e.x == null ? 0 : e.x, i = e.x2 == null ? 1 : e.x2, o = e.y == null ? 0 : e.y, a = e.y2 == null ? 0 : e.y2;
  e.global || (r = r * t.width + t.x, i = i * t.width + t.x, o = o * t.height + t.y, a = a * t.height + t.y), r = Cf(r) ? r : 0, i = Cf(i) ? i : 1, o = Cf(o) ? o : 0, a = Cf(a) ? a : 0;
  var s = n.createLinearGradient(r, o, i, a);
  return s;
}
function Y2t(n, e, t) {
  var r = t.width, i = t.height, o = Math.min(r, i), a = e.x == null ? 0.5 : e.x, s = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
  e.global || (a = a * r + t.x, s = s * i + t.y, l = l * o), a = Cf(a) ? a : 0.5, s = Cf(s) ? s : 0.5, l = l >= 0 && Cf(l) ? l : 0.5;
  var u = n.createRadialGradient(a, s, 0, a, s, l);
  return u;
}
function rD(n, e, t) {
  for (var r = e.type === "radial" ? Y2t(n, e, t) : q2t(n, e, t), i = e.colorStops, o = 0; o < i.length; o++)
    r.addColorStop(i[o].offset, i[o].color);
  return r;
}
function X2t(n, e) {
  if (n === e || !n && !e)
    return !1;
  if (!n || !e || n.length !== e.length)
    return !0;
  for (var t = 0; t < n.length; t++)
    if (n[t] !== e[t])
      return !0;
  return !1;
}
function wO(n) {
  return parseInt(n, 10);
}
function Lp(n, e, t) {
  var r = ["width", "height"][e], i = ["clientWidth", "clientHeight"][e], o = ["paddingLeft", "paddingTop"][e], a = ["paddingRight", "paddingBottom"][e];
  if (t[r] != null && t[r] !== "auto")
    return parseFloat(t[r]);
  var s = document.defaultView.getComputedStyle(n);
  return (n[i] || wO(s[r]) || wO(n.style[r])) - (wO(s[o]) || 0) - (wO(s[a]) || 0) | 0;
}
function U2t(n, e) {
  return !n || n === "solid" || !(e > 0) ? null : n === "dashed" ? [4 * e, 2 * e] : n === "dotted" ? [e] : $t(n) ? [n] : se(n) ? n : null;
}
function gN(n) {
  var e = n.style, t = e.lineDash && e.lineWidth > 0 && U2t(e.lineDash, e.lineWidth), r = e.lineDashOffset;
  if (t) {
    var i = e.strokeNoScale && n.getLineScale ? n.getLineScale() : 1;
    i && i !== 1 && (t = le(t, function(o) {
      return o / i;
    }), r /= i);
  }
  return [t, r];
}
var K2t = new Al(!0);
function TS(n) {
  var e = n.stroke;
  return !(e == null || e === "none" || !(n.lineWidth > 0));
}
function C6(n) {
  return typeof n == "string" && n !== "none";
}
function kS(n) {
  var e = n.fill;
  return e != null && e !== "none";
}
function A6(n, e) {
  if (e.fillOpacity != null && e.fillOpacity !== 1) {
    var t = n.globalAlpha;
    n.globalAlpha = e.fillOpacity * e.opacity, n.fill(), n.globalAlpha = t;
  } else
    n.fill();
}
function T6(n, e) {
  if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
    var t = n.globalAlpha;
    n.globalAlpha = e.strokeOpacity * e.opacity, n.stroke(), n.globalAlpha = t;
  } else
    n.stroke();
}
function iD(n, e, t) {
  var r = NR(e.image, e.__image, t);
  if (OC(r)) {
    var i = n.createPattern(r, e.repeat || "repeat");
    if (typeof DOMMatrix == "function" && i && i.setTransform) {
      var o = new DOMMatrix();
      o.translateSelf(e.x || 0, e.y || 0), o.rotateSelf(0, 0, (e.rotation || 0) * Bw), o.scaleSelf(e.scaleX || 1, e.scaleY || 1), i.setTransform(o);
    }
    return i;
  }
}
function J2t(n, e, t, r) {
  var i, o = TS(t), a = kS(t), s = t.strokePercent, l = s < 1, u = !e.path;
  (!e.silent || l) && u && e.createPathProxy();
  var c = e.path || K2t, h = e.__dirty;
  if (!r) {
    var f = t.fill, d = t.stroke, p = a && !!f.colorStops, g = o && !!d.colorStops, v = a && !!f.image, m = o && !!d.image, y = void 0, b = void 0, O = void 0, w = void 0, x = void 0;
    (p || g) && (x = e.getBoundingRect()), p && (y = h ? rD(n, f, x) : e.__canvasFillGradient, e.__canvasFillGradient = y), g && (b = h ? rD(n, d, x) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = b), v && (O = h || !e.__canvasFillPattern ? iD(n, f, e) : e.__canvasFillPattern, e.__canvasFillPattern = O), m && (w = h || !e.__canvasStrokePattern ? iD(n, d, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = O), p ? n.fillStyle = y : v && (O ? n.fillStyle = O : a = !1), g ? n.strokeStyle = b : m && (w ? n.strokeStyle = w : o = !1);
  }
  var S = e.getGlobalScale();
  c.setScale(S[0], S[1], e.segmentIgnoreThreshold);
  var _, C;
  n.setLineDash && t.lineDash && (i = gN(e), _ = i[0], C = i[1]);
  var A = !0;
  (u || h & Sp) && (c.setDPR(n.dpr), l ? c.setContext(null) : (c.setContext(n), A = !1), c.reset(), e.buildPath(c, e.shape, r), c.toStatic(), e.pathUpdated()), A && c.rebuildPath(n, l ? s : 1), _ && (n.setLineDash(_), n.lineDashOffset = C), r || (t.strokeFirst ? (o && T6(n, t), a && A6(n, t)) : (a && A6(n, t), o && T6(n, t))), _ && n.setLineDash([]);
}
function eAt(n, e, t) {
  var r = e.__image = NR(t.image, e.__image, e, e.onload);
  if (!(!r || !OC(r))) {
    var i = t.x || 0, o = t.y || 0, a = e.getWidth(), s = e.getHeight(), l = r.width / r.height;
    if (a == null && s != null ? a = s * l : s == null && a != null ? s = a / l : a == null && s == null && (a = r.width, s = r.height), t.sWidth && t.sHeight) {
      var u = t.sx || 0, c = t.sy || 0;
      n.drawImage(r, u, c, t.sWidth, t.sHeight, i, o, a, s);
    } else if (t.sx && t.sy) {
      var u = t.sx, c = t.sy, h = a - u, f = s - c;
      n.drawImage(r, u, c, h, f, i, o, a, s);
    } else
      n.drawImage(r, i, o, a, s);
  }
}
function tAt(n, e, t) {
  var r, i = t.text;
  if (i != null && (i += ""), i) {
    n.font = t.font || Gc, n.textAlign = t.textAlign, n.textBaseline = t.textBaseline;
    var o = void 0, a = void 0;
    n.setLineDash && t.lineDash && (r = gN(e), o = r[0], a = r[1]), o && (n.setLineDash(o), n.lineDashOffset = a), t.strokeFirst ? (TS(t) && n.strokeText(i, t.x, t.y), kS(t) && n.fillText(i, t.x, t.y)) : (kS(t) && n.fillText(i, t.x, t.y), TS(t) && n.strokeText(i, t.x, t.y)), o && n.setLineDash([]);
  }
}
var k6 = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], P6 = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function Vte(n, e, t, r, i) {
  var o = !1;
  if (!r && (t = t || {}, e === t))
    return !1;
  if (r || e.opacity !== t.opacity) {
    Oo(n, i), o = !0;
    var a = Math.max(Math.min(e.opacity, 1), 0);
    n.globalAlpha = isNaN(a) ? Ff.opacity : a;
  }
  (r || e.blend !== t.blend) && (o || (Oo(n, i), o = !0), n.globalCompositeOperation = e.blend || Ff.blend);
  for (var s = 0; s < k6.length; s++) {
    var l = k6[s];
    (r || e[l] !== t[l]) && (o || (Oo(n, i), o = !0), n[l] = n.dpr * (e[l] || 0));
  }
  return (r || e.shadowColor !== t.shadowColor) && (o || (Oo(n, i), o = !0), n.shadowColor = e.shadowColor || Ff.shadowColor), o;
}
function E6(n, e, t, r, i) {
  var o = W0(e, i.inHover), a = r ? null : t && W0(t, i.inHover) || {};
  if (o === a)
    return !1;
  var s = Vte(n, o, a, r, i);
  if ((r || o.fill !== a.fill) && (s || (Oo(n, i), s = !0), C6(o.fill) && (n.fillStyle = o.fill)), (r || o.stroke !== a.stroke) && (s || (Oo(n, i), s = !0), C6(o.stroke) && (n.strokeStyle = o.stroke)), (r || o.opacity !== a.opacity) && (s || (Oo(n, i), s = !0), n.globalAlpha = o.opacity == null ? 1 : o.opacity), e.hasStroke()) {
    var l = o.lineWidth, u = l / (o.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
    n.lineWidth !== u && (s || (Oo(n, i), s = !0), n.lineWidth = u);
  }
  for (var c = 0; c < P6.length; c++) {
    var h = P6[c], f = h[0];
    (r || o[f] !== a[f]) && (s || (Oo(n, i), s = !0), n[f] = o[f] || h[1]);
  }
  return s;
}
function nAt(n, e, t, r, i) {
  return Vte(n, W0(e, i.inHover), t && W0(t, i.inHover), r, i);
}
function zte(n, e) {
  var t = e.transform, r = n.dpr || 1;
  t ? n.setTransform(r * t[0], r * t[1], r * t[2], r * t[3], r * t[4], r * t[5]) : n.setTransform(r, 0, 0, r, 0, 0);
}
function rAt(n, e, t) {
  for (var r = !1, i = 0; i < n.length; i++) {
    var o = n[i];
    r = r || o.isZeroArea(), zte(e, o), e.beginPath(), o.buildPath(e, o.shape), e.clip();
  }
  t.allClipped = r;
}
function iAt(n, e) {
  return n && e ? n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] || n[4] !== e[4] || n[5] !== e[5] : !(!n && !e);
}
var M6 = 1, D6 = 2, L6 = 3, I6 = 4;
function oAt(n) {
  var e = kS(n), t = TS(n);
  return !(n.lineDash || !(+e ^ +t) || e && typeof n.fill != "string" || t && typeof n.stroke != "string" || n.strokePercent < 1 || n.strokeOpacity < 1 || n.fillOpacity < 1);
}
function Oo(n, e) {
  e.batchFill && n.fill(), e.batchStroke && n.stroke(), e.batchFill = "", e.batchStroke = "";
}
function W0(n, e) {
  return e && n.__hoverStyle || n.style;
}
function Fte(n, e) {
  Af(n, e, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Af(n, e, t, r) {
  var i = e.transform;
  if (!e.shouldBePainted(t.viewWidth, t.viewHeight, !1, !1)) {
    e.__dirty &= ~Zo, e.__isRendered = !1;
    return;
  }
  var o = e.__clipPaths, a = t.prevElClipPaths, s = !1, l = !1;
  if ((!a || X2t(o, a)) && (a && a.length && (Oo(n, t), n.restore(), l = s = !0, t.prevElClipPaths = null, t.allClipped = !1, t.prevEl = null), o && o.length && (Oo(n, t), n.save(), rAt(o, n, t), s = !0), t.prevElClipPaths = o), t.allClipped) {
    e.__isRendered = !1;
    return;
  }
  e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
  var u = t.prevEl;
  u || (l = s = !0);
  var c = e instanceof gt && e.autoBatch && oAt(e.style);
  s || iAt(i, u.transform) ? (Oo(n, t), zte(n, e)) : c || Oo(n, t);
  var h = W0(e, t.inHover);
  e instanceof gt ? (t.lastDrawType !== M6 && (l = !0, t.lastDrawType = M6), E6(n, e, u, l, t), (!c || !t.batchFill && !t.batchStroke) && n.beginPath(), J2t(n, e, h, c), c && (t.batchFill = h.fill || "", t.batchStroke = h.stroke || "")) : e instanceof N0 ? (t.lastDrawType !== L6 && (l = !0, t.lastDrawType = L6), E6(n, e, u, l, t), tAt(n, e, h)) : e instanceof Si ? (t.lastDrawType !== D6 && (l = !0, t.lastDrawType = D6), nAt(n, e, u, l, t), eAt(n, e, h)) : e.getTemporalDisplayables && (t.lastDrawType !== I6 && (l = !0, t.lastDrawType = I6), aAt(n, e, t)), c && r && Oo(n, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = !0;
}
function aAt(n, e, t) {
  var r = e.getDisplayables(), i = e.getTemporalDisplayables();
  n.save();
  var o = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: t.viewWidth,
    viewHeight: t.viewHeight,
    inHover: t.inHover
  }, a, s;
  for (a = e.getCursor(), s = r.length; a < s; a++) {
    var l = r[a];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Af(n, l, o, a === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), o.prevEl = l;
  }
  for (var u = 0, c = i.length; u < c; u++) {
    var l = i[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Af(n, l, o, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), o.prevEl = l;
  }
  e.clearTemporalDisplayables(), e.notClear = !0, n.restore();
}
var fT = new V2t(), R6 = new Nb(100), N6 = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Ug(n, e) {
  if (n === "none")
    return null;
  var t = e.getDevicePixelRatio(), r = e.getZr(), i = r.painter.type === "svg";
  n.dirty && fT.delete(n);
  var o = fT.get(n);
  if (o)
    return o;
  var a = Be(n, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  a.backgroundColor === "none" && (a.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = a.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / t, fT.set(n, s), n.dirty = !1, s;
  function l(u) {
    for (var c = [t], h = !0, f = 0; f < N6.length; ++f) {
      var d = a[N6[f]];
      if (d != null && !se(d) && !we(d) && !$t(d) && typeof d != "boolean") {
        h = !1;
        break;
      }
      c.push(d);
    }
    var p;
    if (h) {
      p = c.join(",") + (i ? "-svg" : "");
      var g = R6.get(p);
      g && (i ? u.svgElement = g : u.image = g);
    }
    var v = Zte(a.dashArrayX), m = sAt(a.dashArrayY), y = Qte(a.symbol), b = lAt(v), O = Wte(m), w = !i && jc.createCanvas(), x = i && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, S = C(), _;
    w && (w.width = S.width * t, w.height = S.height * t, _ = w.getContext("2d")), A(), h && R6.put(p, w || x), u.image = w, u.svgElement = x, u.svgWidth = S.width, u.svgHeight = S.height;
    function C() {
      for (var k = 1, P = 0, L = b.length; P < L; ++P)
        k = Xz(k, b[P]);
      for (var D = 1, P = 0, L = y.length; P < L; ++P)
        D = Xz(D, y[P].length);
      k *= D;
      var E = O * b.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var M = function(R) {
          console.warn("Calculated decal size is greater than " + R + " due to decal option settings so " + R + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + R + " to be larger to avoid incontinuity.");
        };
        k > a.maxTileWidth && M("maxTileWidth"), E > a.maxTileHeight && M("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(k, a.maxTileWidth)),
        height: Math.max(1, Math.min(E, a.maxTileHeight))
      };
    }
    function A() {
      _ && (_.clearRect(0, 0, w.width, w.height), a.backgroundColor && (_.fillStyle = a.backgroundColor, _.fillRect(0, 0, w.width, w.height)));
      for (var k = 0, P = 0; P < m.length; ++P)
        k += m[P];
      if (k <= 0)
        return;
      for (var L = -O, D = 0, E = 0, M = 0; L < S.height; ) {
        if (D % 2 === 0) {
          for (var R = E / 2 % y.length, N = 0, $ = 0, F = 0; N < S.width * 2; ) {
            for (var W = 0, P = 0; P < v[M].length; ++P)
              W += v[M][P];
            if (W <= 0)
              break;
            if ($ % 2 === 0) {
              var j = (1 - a.symbolSize) * 0.5, Y = N + v[M][$] * j, X = L + m[D] * j, ie = v[M][$] * a.symbolSize, ae = m[D] * a.symbolSize, ee = F / 2 % y[R].length;
              ne(Y, X, ie, ae, y[R][ee]);
            }
            N += v[M][$], ++F, ++$, $ === v[M].length && ($ = 0);
          }
          ++M, M === v.length && (M = 0);
        }
        L += m[D], ++E, ++D, D === m.length && (D = 0);
      }
      function ne(ye, te, ue, xe, dt) {
        var Ue = i ? 1 : t, Rt = vr(dt, ye * Ue, te * Ue, ue * Ue, xe * Ue, a.color, a.symbolKeepAspect);
        if (i) {
          var zt = r.painter.renderOneToVNode(Rt);
          zt && x.children.push(zt);
        } else
          Fte(_, Rt);
      }
    }
  }
}
function Qte(n) {
  if (!n || n.length === 0)
    return [["rect"]];
  if (we(n))
    return [[n]];
  for (var e = !0, t = 0; t < n.length; ++t)
    if (!we(n[t])) {
      e = !1;
      break;
    }
  if (e)
    return Qte([n]);
  for (var r = [], t = 0; t < n.length; ++t)
    we(n[t]) ? r.push([n[t]]) : r.push(n[t]);
  return r;
}
function Zte(n) {
  if (!n || n.length === 0)
    return [[0, 0]];
  if ($t(n)) {
    var e = Math.ceil(n);
    return [[e, e]];
  }
  for (var t = !0, r = 0; r < n.length; ++r)
    if (!$t(n[r])) {
      t = !1;
      break;
    }
  if (t)
    return Zte([n]);
  for (var i = [], r = 0; r < n.length; ++r)
    if ($t(n[r])) {
      var e = Math.ceil(n[r]);
      i.push([e, e]);
    } else {
      var e = le(n[r], function(s) {
        return Math.ceil(s);
      });
      e.length % 2 === 1 ? i.push(e.concat(e)) : i.push(e);
    }
  return i;
}
function sAt(n) {
  if (!n || typeof n == "object" && n.length === 0)
    return [0, 0];
  if ($t(n)) {
    var e = Math.ceil(n);
    return [e, e];
  }
  var t = le(n, function(r) {
    return Math.ceil(r);
  });
  return n.length % 2 ? t.concat(t) : t;
}
function lAt(n) {
  return le(n, function(e) {
    return Wte(e);
  });
}
function Wte(n) {
  for (var e = 0, t = 0; t < n.length; ++t)
    e += n[t];
  return n.length % 2 === 1 ? e * 2 : e;
}
function uAt(n, e) {
  n.eachRawSeries(function(t) {
    if (!n.isSeriesFiltered(t)) {
      var r = t.getData();
      r.hasItemVisual() && r.each(function(a) {
        var s = r.getItemVisual(a, "decal");
        if (s) {
          var l = r.ensureUniqueItemVisual(a, "style");
          l.decal = Ug(s, e);
        }
      });
      var i = r.getVisual("decal");
      if (i) {
        var o = r.getVisual("style");
        o.decal = Ug(i, e);
      }
    }
  });
}
var cAt = new Ba();
const Ha = cAt;
var PS = {};
function hAt(n, e) {
  process.env.NODE_ENV !== "production" && PS[n] && bi("Already has an implementation of " + n + "."), PS[n] = e;
}
function fAt(n) {
  return process.env.NODE_ENV !== "production" && (PS[n] || bi("Implementation of " + n + " doesn't exists.")), PS[n];
}
var dAt = 1, pAt = 800, gAt = 900, vAt = 1e3, mAt = 2e3, yAt = 5e3, Gte = 1e3, bAt = 1100, vN = 2e3, jte = 3e3, OAt = 4e3, VC = 4500, wAt = 4600, xAt = 5e3, SAt = 6e3, Hte = 7e3, _At = {
  PROCESSOR: {
    FILTER: vAt,
    SERIES_FILTER: pAt,
    STATISTIC: yAt
  },
  VISUAL: {
    LAYOUT: Gte,
    PROGRESSIVE_LAYOUT: bAt,
    GLOBAL: vN,
    CHART: jte,
    POST_CHART_LAYOUT: wAt,
    COMPONENT: OAt,
    BRUSH: xAt,
    CHART_ITEM: VC,
    ARIA: SAt,
    DECAL: Hte
  }
}, Ai = "__flagInMainProcess", lo = "__pendingUpdate", dT = "__needsUpdateStatus", $6 = /^[a-zA-Z0-9_]+$/, pT = "__connectUpdateStatus", B6 = 0, CAt = 1, AAt = 2;
function qte(n) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    if (this.isDisposed()) {
      No(this.id);
      return;
    }
    return Xte(this, n, e);
  };
}
function Yte(n) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return Xte(this, n, e);
  };
}
function Xte(n, e, t) {
  return t[0] = t[0] && t[0].toLowerCase(), Ba.prototype[e].apply(n, t);
}
var Ute = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e;
  }(Ba)
), Kte = Ute.prototype;
Kte.on = Yte("on");
Kte.off = Yte("off");
var op, gT, xO, $u, vT, mT, yT, bm, Om, V6, z6, bT, F6, SO, Q6, Jte, ea, Z6, ene = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this, new L2t()) || this;
      o._chartsViews = [], o._chartsMap = {}, o._componentsViews = [], o._componentsMap = {}, o._pendingActions = [], i = i || {}, we(r) && (r = tne[r]), o._dom = t;
      var a = "canvas", s = "auto", l = !1;
      if (process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          mt.hasGlobalWindow ? window : global
        );
        u && (a = qe(u.__ECHARTS__DEFAULT__RENDERER__, a), s = qe(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = qe(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      i.ssr && sxt(function(d) {
        var p = He(d), g = p.dataIndex;
        if (g != null) {
          var v = Ee();
          return v.set("series_index", p.seriesIndex), v.set("data_index", g), p.ssrType && v.set("ssr_type", p.ssrType), v;
        }
      });
      var c = o._zr = jz(t, {
        renderer: i.renderer || a,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: qe(i.useDirtyRect, l),
        useCoarsePointer: qe(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      o._ssr = i.ssr, o._throttledZrFlush = dN(_e(c.flush, c), 17), r = Fe(r), r && ste(r, !0), o._theme = r, o._locale = z_t(i.locale || $ee), o._coordSysMgr = new Fv();
      var h = o._api = Q6(o);
      function f(d, p) {
        return d.__prio - p.__prio;
      }
      return Fw(MS, f), Fw(oD, f), o._scheduler = new Dte(o, h, oD, MS), o._messageCenter = new Ute(), o._initEvents(), o.resize = _e(o.resize, o), c.animation.on("frame", o._onframe, o), V6(c, o), z6(c, o), aS(o), o;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        Z6(this);
        var t = this._scheduler;
        if (this[lo]) {
          var r = this[lo].silent;
          this[Ai] = !0;
          try {
            op(this), $u.update.call(this, null, this[lo].updateParams);
          } catch (l) {
            throw this[Ai] = !1, this[lo] = null, l;
          }
          this._zr.flush(), this[Ai] = !1, this[lo] = null, bm.call(this, r), Om.call(this, r);
        } else if (t.unfinished) {
          var i = dAt, o = this._model, a = this._api;
          t.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            t.performSeriesTasks(o), t.performDataProcessorTasks(o), mT(this, o), t.performVisualTasks(o), SO(this, this._model, a, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && t.unfinished);
          t.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(t, r, i) {
      if (this[Ai]) {
        process.env.NODE_ENV !== "production" && bi("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        No(this.id);
        return;
      }
      var o, a, s;
      if (Ne(r) && (i = r.lazyUpdate, o = r.silent, a = r.replaceMerge, s = r.transition, r = r.notMerge), this[Ai] = !0, !this._model || r) {
        var l = new bCt(this._api), u = this._theme, c = this._model = new oN();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(t, {
        replaceMerge: a
      }, aD);
      var h = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (i)
        this[lo] = {
          silent: o,
          updateParams: h
        }, this[Ai] = !1, this.getZr().wakeUp();
      else {
        try {
          op(this), $u.update.call(this, null, h);
        } catch (f) {
          throw this[lo] = null, this[Ai] = !1, f;
        }
        this._ssr || this._zr.flush(), this[lo] = null, this[Ai] = !1, bm.call(this, o), Om.call(this, o);
      }
    }, e.prototype.setTheme = function() {
      vs("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || mt.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(t) {
      return process.env.NODE_ENV !== "production" && lr("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(t);
    }, e.prototype.renderToCanvas = function(t) {
      t = t || {};
      var r = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && r.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return r.getRenderedCanvas({
        backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(t) {
      t = t || {};
      var r = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && r.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return r.renderToString({
        useViewBox: t.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (mt.svgSupported) {
        var t = this._zr, r = t.storage.getDisplayList();
        return I(r, function(i) {
          i.stopAnimation(null, !0);
        }), t.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(t) {
      if (this._disposed) {
        No(this.id);
        return;
      }
      t = t || {};
      var r = t.excludeComponents, i = this._model, o = [], a = this;
      I(r, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = a._componentsMap[u.__viewId];
          c.group.ignore || (o.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return I(o, function(l) {
        l.group.ignore = !1;
      }), s;
    }, e.prototype.getConnectedDataURL = function(t) {
      if (this._disposed) {
        No(this.id);
        return;
      }
      var r = t.type === "svg", i = this.group, o = Math.min, a = Math.max, s = 1 / 0;
      if (W6[i]) {
        var l = s, u = s, c = -s, h = -s, f = [], d = t && t.pixelRatio || this.getDevicePixelRatio();
        I(Fy, function(b, O) {
          if (b.group === i) {
            var w = r ? b.getZr().painter.getSvgDom().innerHTML : b.renderToCanvas(Fe(t)), x = b.getDom().getBoundingClientRect();
            l = o(x.left, l), u = o(x.top, u), c = a(x.right, c), h = a(x.bottom, h), f.push({
              dom: w,
              left: x.left,
              top: x.top
            });
          }
        }), l *= d, u *= d, c *= d, h *= d;
        var p = c - l, g = h - u, v = jc.createCanvas(), m = jz(v, {
          renderer: r ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: g
        }), r) {
          var y = "";
          return I(f, function(b) {
            var O = b.left - l, w = b.top - u;
            y += '<g transform="translate(' + O + "," + w + ')">' + b.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && m.painter.setBackgroundColor(t.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return t.connectedBackgroundColor && m.add(new Lt({
            shape: {
              x: 0,
              y: 0,
              width: p,
              height: g
            },
            style: {
              fill: t.connectedBackgroundColor
            }
          })), I(f, function(b) {
            var O = new Si({
              style: {
                x: b.left * d - l,
                y: b.top * d - u,
                image: b.dom
              }
            });
            m.add(O);
          }), m.refreshImmediately(), v.toDataURL("image/" + (t && t.type || "png"));
      } else
        return this.getDataURL(t);
    }, e.prototype.convertToPixel = function(t, r) {
      return vT(this, "convertToPixel", t, r);
    }, e.prototype.convertFromPixel = function(t, r) {
      return vT(this, "convertFromPixel", t, r);
    }, e.prototype.containPixel = function(t, r) {
      if (this._disposed) {
        No(this.id);
        return;
      }
      var i = this._model, o, a = Iy(i, t);
      return I(a, function(s, l) {
        l.indexOf("Models") >= 0 && I(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            o = o || !!c.containPoint(r);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint ? o = o || h.containPoint(r, u) : process.env.NODE_ENV !== "production" && $n(l + ": " + (h ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && $n(l + ": containPoint is not supported");
        }, this);
      }, this), !!o;
    }, e.prototype.getVisual = function(t, r) {
      var i = this._model, o = Iy(i, t, {
        defaultMainType: "series"
      }), a = o.seriesModel;
      process.env.NODE_ENV !== "production" && (a || $n("There is no specified series model"));
      var s = a.getData(), l = o.hasOwnProperty("dataIndexInside") ? o.dataIndexInside : o.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(o.dataIndex) : null;
      return l != null ? pN(s, l, r) : Zb(s, r);
    }, e.prototype.getViewOfComponentModel = function(t) {
      return this._componentsMap[t.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(t) {
      return this._chartsMap[t.__viewId];
    }, e.prototype._initEvents = function() {
      var t = this;
      I(TAt, function(r) {
        var i = function(o) {
          var a = t.getModel(), s = o.target, l, u = r === "globalout";
          if (u ? l = {} : s && _f(s, function(p) {
            var g = He(p);
            if (g && g.dataIndex != null) {
              var v = g.dataModel || a.getSeriesByIndex(g.seriesIndex);
              return l = v && v.getDataParams(g.dataIndex, g.dataType, s) || {}, !0;
            } else if (g.eventData)
              return l = re({}, g.eventData), !0;
          }, !0), l) {
            var c = l.componentType, h = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", h = l.seriesIndex);
            var f = c && h != null && a.getComponent(c, h), d = f && t[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            process.env.NODE_ENV !== "production" && !u && !(f && d) && $n("model or view can not be found by params"), l.event = o, l.type = r, t._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: f,
              view: d
            }, t.trigger(r, l);
          }
        };
        i.zrEventfulCallAtLast = !0, t._zr.on(r, i, t);
      }), I(zy, function(r, i) {
        t._messageCenter.on(i, function(o) {
          this.trigger(i, o);
        }, t);
      }), I(["selectchanged"], function(r) {
        t._messageCenter.on(r, function(i) {
          this.trigger(r, i);
        }, t);
      }), N2t(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        No(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        No(this.id);
        return;
      }
      this._disposed = !0;
      var t = this.getDom();
      t && VJ(this.getDom(), yN, "");
      var r = this, i = r._api, o = r._model;
      I(r._componentsViews, function(a) {
        a.dispose(o, i);
      }), I(r._chartsViews, function(a) {
        a.dispose(o, i);
      }), r._zr.dispose(), r._dom = r._model = r._chartsMap = r._componentsMap = r._chartsViews = r._componentsViews = r._scheduler = r._api = r._zr = r._throttledZrFlush = r._theme = r._coordSysMgr = r._messageCenter = null, delete Fy[r.id];
    }, e.prototype.resize = function(t) {
      if (this[Ai]) {
        process.env.NODE_ENV !== "production" && bi("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        No(this.id);
        return;
      }
      this._zr.resize(t);
      var r = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!r) {
        var i = r.resetOption("media"), o = t && t.silent;
        this[lo] && (o == null && (o = this[lo].silent), i = !0, this[lo] = null), this[Ai] = !0;
        try {
          i && op(this), $u.update.call(this, {
            type: "resize",
            animation: re({
              // Disable animation
              duration: 0
            }, t && t.animation)
          });
        } catch (a) {
          throw this[Ai] = !1, a;
        }
        this[Ai] = !1, bm.call(this, o), Om.call(this, o);
      }
    }, e.prototype.showLoading = function(t, r) {
      if (this._disposed) {
        No(this.id);
        return;
      }
      if (Ne(t) && (r = t, t = ""), t = t || "default", this.hideLoading(), !sD[t]) {
        process.env.NODE_ENV !== "production" && $n("Loading effects " + t + " not exists.");
        return;
      }
      var i = sD[t](this._api, r), o = this._zr;
      this._loadingFX = i, o.add(i);
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        No(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(t) {
      var r = re({}, t);
      return r.type = zy[t.type], r;
    }, e.prototype.dispatchAction = function(t, r) {
      if (this._disposed) {
        No(this.id);
        return;
      }
      if (Ne(r) || (r = {
        silent: !!r
      }), !!ES[t.type] && this._model) {
        if (this[Ai]) {
          this._pendingActions.push(t);
          return;
        }
        var i = r.silent;
        yT.call(this, t, i);
        var o = r.flush;
        o ? this._zr.flush() : o !== !1 && mt.browser.weChat && this._throttledZrFlush(), bm.call(this, i), Om.call(this, i);
      }
    }, e.prototype.updateLabelLayout = function() {
      Ha.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, e.prototype.appendData = function(t) {
      if (this._disposed) {
        No(this.id);
        return;
      }
      var r = t.seriesIndex, i = this.getModel(), o = i.getSeriesByIndex(r);
      process.env.NODE_ENV !== "production" && $e(t.data && o), o.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, e.internalField = function() {
      op = function(h) {
        var f = h._scheduler;
        f.restorePipelines(h._model), f.prepareStageTasks(), gT(h, !0), gT(h, !1), f.plan();
      }, gT = function(h, f) {
        for (var d = h._model, p = h._scheduler, g = f ? h._componentsViews : h._chartsViews, v = f ? h._componentsMap : h._chartsMap, m = h._zr, y = h._api, b = 0; b < g.length; b++)
          g[b].__alive = !1;
        f ? d.eachComponent(function(x, S) {
          x !== "series" && O(S);
        }) : d.eachSeries(O);
        function O(x) {
          var S = x.__requireNewView;
          x.__requireNewView = !1;
          var _ = "_ec_" + x.id + "_" + x.type, C = !S && v[_];
          if (!C) {
            var A = il(x.type), k = f ? Gn.getClass(A.main, A.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              bn.getClass(A.sub)
            );
            process.env.NODE_ENV !== "production" && $e(k, A.sub + " does not exist."), C = new k(), C.init(d, y), v[_] = C, g.push(C), m.add(C.group);
          }
          x.__viewId = C.__id = _, C.__alive = !0, C.__model = x, C.group.__ecComponentInfo = {
            mainType: x.mainType,
            index: x.componentIndex
          }, !f && p.prepareView(C, x, d, y);
        }
        for (var b = 0; b < g.length; ) {
          var w = g[b];
          w.__alive ? b++ : (!f && w.renderTask.dispose(), m.remove(w.group), w.dispose(d, y), g.splice(b, 1), v[w.__id] === w && delete v[w.__id], w.__id = w.group.__ecComponentInfo = null);
        }
      }, xO = function(h, f, d, p, g) {
        var v = h._model;
        if (v.setUpdatePayload(d), !p) {
          I([].concat(h._componentsViews).concat(h._chartsViews), w);
          return;
        }
        var m = {};
        m[p + "Id"] = d[p + "Id"], m[p + "Index"] = d[p + "Index"], m[p + "Name"] = d[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        g && (y.subType = g);
        var b = d.excludeSeriesId, O;
        b != null && (O = Ee(), I(an(b), function(x) {
          var S = wr(x, null);
          S != null && O.set(S, !0);
        })), v && v.eachComponent(y, function(x) {
          var S = O && O.get(x.id) != null;
          if (!S)
            if (CF(d))
              if (x instanceof Ln)
                d.type === Qf && !d.notBlur && !x.get(["emphasis", "disabled"]) && LSt(x, d, h._api);
              else {
                var _ = QR(x.mainType, x.componentIndex, d.name, h._api), C = _.focusSelf, A = _.dispatchers;
                d.type === Qf && C && !d.notBlur && zM(x.mainType, x.componentIndex, h._api), A && I(A, function(k) {
                  d.type === Qf ? gu(k) : vu(k);
                });
              }
            else
              QM(d) && x instanceof Ln && (NSt(x, d, h._api), SF(x), ea(h));
        }, h), v && v.eachComponent(y, function(x) {
          var S = O && O.get(x.id) != null;
          S || w(h[p === "series" ? "_chartsMap" : "_componentsMap"][x.__viewId]);
        }, h);
        function w(x) {
          x && x.__alive && x[f] && x[f](x.__model, v, h._api, d);
        }
      }, $u = {
        prepareAndUpdate: function(h) {
          op(this), $u.update.call(this, h, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: h.newOption != null
          });
        },
        update: function(h, f) {
          var d = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, m = this._scheduler;
          if (d) {
            d.setUpdatePayload(h), m.restoreData(d, h), m.performSeriesTasks(d), v.create(d, p), m.performDataProcessorTasks(d, h), mT(this, d), v.update(d, p), t(d), m.performVisualTasks(d, h), bT(this, d, p, h, f);
            var y = d.get("backgroundColor") || "transparent", b = d.get("darkMode");
            g.setBackgroundColor(y), b != null && b !== "auto" && g.setDarkMode(b), Ha.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(h) {
          var f = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(h);
            var g = [];
            d.eachComponent(function(m, y) {
              if (m !== "series") {
                var b = f.getViewOfComponentModel(y);
                if (b && b.__alive)
                  if (b.updateTransform) {
                    var O = b.updateTransform(y, d, p, h);
                    O && O.update && g.push(b);
                  } else
                    g.push(b);
              }
            });
            var v = Ee();
            d.eachSeries(function(m) {
              var y = f._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var b = y.updateTransform(m, d, p, h);
                b && b.update && v.set(m.uid, 1);
              } else
                v.set(m.uid, 1);
            }), t(d), this._scheduler.performVisualTasks(d, h, {
              setDirty: !0,
              dirtyMap: v
            }), SO(this, d, p, h, {}, v), Ha.trigger("afterupdate", d, p);
          }
        },
        updateView: function(h) {
          var f = this._model;
          f && (f.setUpdatePayload(h), bn.markUpdateMethod(h, "updateView"), t(f), this._scheduler.performVisualTasks(f, h, {
            setDirty: !0
          }), bT(this, f, this._api, h, {}), Ha.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(h) {
          var f = this, d = this._model;
          d && (d.setUpdatePayload(h), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), bn.markUpdateMethod(h, "updateVisual"), t(d), this._scheduler.performVisualTasks(d, h, {
            visualType: "visual",
            setDirty: !0
          }), d.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = f.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, d, f._api, h);
            }
          }), d.eachSeries(function(p) {
            var g = f._chartsMap[p.__viewId];
            g.updateVisual(p, d, f._api, h);
          }), Ha.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(h) {
          $u.update.call(this, h);
        }
      }, vT = function(h, f, d, p) {
        if (h._disposed) {
          No(h.id);
          return;
        }
        for (var g = h._model, v = h._coordSysMgr.getCoordinateSystems(), m, y = Iy(g, d), b = 0; b < v.length; b++) {
          var O = v[b];
          if (O[f] && (m = O[f](g, y, p)) != null)
            return m;
        }
        process.env.NODE_ENV !== "production" && $n("No coordinate system that supports " + f + " found by the given finder.");
      }, mT = function(h, f) {
        var d = h._chartsMap, p = h._scheduler;
        f.eachSeries(function(g) {
          p.updateStreamModes(g, d[g.__viewId]);
        });
      }, yT = function(h, f) {
        var d = this, p = this.getModel(), g = h.type, v = h.escapeConnect, m = ES[g], y = m.actionInfo, b = (y.update || "update").split(":"), O = b.pop(), w = b[0] != null && il(b[0]);
        this[Ai] = !0;
        var x = [h], S = !1;
        h.batch && (S = !0, x = le(h.batch, function(D) {
          return D = Be(re({}, D), h), D.batch = null, D;
        }));
        var _ = [], C, A = QM(h), k = CF(h);
        if (k && cee(this._api), I(x, function(D) {
          if (C = m.action(D, d._model, d._api), C = C || re({}, D), C.type = y.event || C.type, _.push(C), k) {
            var E = IR(h), M = E.queryOptionMap, R = E.mainTypeSpecified, N = R ? M.keys()[0] : "series";
            xO(d, O, D, N), ea(d);
          } else
            A ? (xO(d, O, D, "series"), ea(d)) : w && xO(d, O, D, w.main, w.sub);
        }), O !== "none" && !k && !A && !w)
          try {
            this[lo] ? (op(this), $u.update.call(this, h), this[lo] = null) : $u[O].call(this, h);
          } catch (D) {
            throw this[Ai] = !1, D;
          }
        if (S ? C = {
          type: y.event || g,
          escapeConnect: v,
          batch: _
        } : C = _[0], this[Ai] = !1, !f) {
          var P = this._messageCenter;
          if (P.trigger(C.type, C), A) {
            var L = {
              type: "selectchanged",
              escapeConnect: v,
              selected: $St(p),
              isFromClick: h.isFromClick || !1,
              fromAction: h.type,
              fromActionPayload: h
            };
            P.trigger(L.type, L);
          }
        }
      }, bm = function(h) {
        for (var f = this._pendingActions; f.length; ) {
          var d = f.shift();
          yT.call(this, d, h);
        }
      }, Om = function(h) {
        !h && this.trigger("updated");
      }, V6 = function(h, f) {
        h.on("rendered", function(d) {
          f.trigger("rendered", d), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          h.animation.isFinished() && !f[lo] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, z6 = function(h, f) {
        h.on("mouseover", function(d) {
          var p = d.target, g = _f(p, qc);
          g && (ISt(g, d, f._api), ea(f));
        }).on("mouseout", function(d) {
          var p = d.target, g = _f(p, qc);
          g && (RSt(g, d, f._api), ea(f));
        }).on("click", function(d) {
          var p = d.target, g = _f(p, function(y) {
            return He(y).dataIndex != null;
          }, !0);
          if (g) {
            var v = g.selected ? "unselect" : "select", m = He(g);
            f._api.dispatchAction({
              type: v,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function t(h) {
        h.clearColorPalette(), h.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function r(h) {
        var f = [], d = [], p = !1;
        if (h.eachComponent(function(y, b) {
          var O = b.get("zlevel") || 0, w = b.get("z") || 0, x = b.getZLevelKey();
          p = p || !!x, (y === "series" ? d : f).push({
            zlevel: O,
            z: w,
            idx: b.componentIndex,
            type: y,
            key: x
          });
        }), p) {
          var g = f.concat(d), v, m;
          Fw(g, function(y, b) {
            return y.zlevel === b.zlevel ? y.z - b.z : y.zlevel - b.zlevel;
          }), I(g, function(y) {
            var b = h.getComponent(y.type, y.idx), O = y.zlevel, w = y.key;
            v != null && (O = Math.max(v, O)), w ? (O === v && w !== m && O++, m = w) : m && (O === v && O++, m = ""), v = O, b.setZLevel(O);
          });
        }
      }
      bT = function(h, f, d, p, g) {
        r(f), F6(h, f, d, p, g), I(h._chartsViews, function(v) {
          v.__alive = !1;
        }), SO(h, f, d, p, g), I(h._chartsViews, function(v) {
          v.__alive || v.remove(f, d);
        });
      }, F6 = function(h, f, d, p, g, v) {
        I(v || h._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, f, d, p), s(y, m), c(y, m);
        });
      }, SO = function(h, f, d, p, g, v) {
        var m = h._scheduler;
        g = re(g || {}, {
          updatedSeries: f.getSeries()
        }), Ha.trigger("series:beforeupdate", f, d, g);
        var y = !1;
        f.eachSeries(function(b) {
          var O = h._chartsMap[b.__viewId];
          O.__alive = !0;
          var w = O.renderTask;
          m.updatePayload(w, p), u(b, O), v && v.get(b.uid) && w.dirty(), w.perform(m.getPerformArgs(w)) && (y = !0), O.group.silent = !!b.get("silent"), a(b, O), SF(b);
        }), m.unfinished = y || m.unfinished, Ha.trigger("series:layoutlabels", f, d, g), Ha.trigger("series:transition", f, d, g), f.eachSeries(function(b) {
          var O = h._chartsMap[b.__viewId];
          s(b, O), c(b, O);
        }), o(h, f), Ha.trigger("series:afterupdate", f, d, g);
      }, ea = function(h) {
        h[dT] = !0, h.getZr().wakeUp();
      }, Z6 = function(h) {
        h[dT] && (h.getZr().storage.traverse(function(f) {
          Up(f) || i(f);
        }), h[dT] = !1);
      };
      function i(h) {
        for (var f = [], d = h.currentStates, p = 0; p < d.length; p++) {
          var g = d[p];
          g === "emphasis" || g === "blur" || g === "select" || f.push(g);
        }
        h.selected && h.states.select && f.push("select"), h.hoverState === SC && h.states.emphasis ? f.push("emphasis") : h.hoverState === Vb && h.states.blur && f.push("blur"), h.useStates(f);
      }
      function o(h, f) {
        var d = h._zr, p = d.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > f.get("hoverLayerThreshold") && !mt.node && !mt.worker && f.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var m = h._chartsMap[v.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function a(h, f) {
        var d = h.get("blendMode") || null;
        f.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function s(h, f) {
        if (!h.preventAutoZ) {
          var d = h.get("z") || 0, p = h.get("zlevel") || 0;
          f.eachRendered(function(g) {
            return l(g, d, p, -1 / 0), !0;
          });
        }
      }
      function l(h, f, d, p) {
        var g = h.getTextContent(), v = h.getTextGuideLine(), m = h.isGroup;
        if (m)
          for (var y = h.childrenRef(), b = 0; b < y.length; b++)
            p = Math.max(l(y[b], f, d, p), p);
        else
          h.z = f, h.zlevel = d, p = Math.max(h.z2, p);
        if (g && (g.z = f, g.zlevel = d, isFinite(p) && (g.z2 = p + 2)), v) {
          var O = h.textGuideLineConfig;
          v.z = f, v.zlevel = d, isFinite(p) && (v.z2 = p + (O && O.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(h, f) {
        f.eachRendered(function(d) {
          if (!Up(d)) {
            var p = d.getTextContent(), g = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(h, f) {
        var d = h.getModel("stateAnimation"), p = h.isAnimationEnabled(), g = d.get("duration"), v = g > 0 ? {
          duration: g,
          delay: d.get("delay"),
          easing: d.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        f.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (Up(m))
              return;
            if (m instanceof gt && QSt(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = v;
              var b = m.getTextContent(), O = m.getTextGuideLine();
              b && (b.stateTransition = v), O && (O.stateTransition = v);
            }
            m.__dirty && i(m);
          }
        });
      }
      Q6 = function(h) {
        return new /** @class */
        (function(f) {
          H(d, f);
          function d() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null)
                return h._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, g) {
            gu(p, g), ea(h);
          }, d.prototype.leaveEmphasis = function(p, g) {
            vu(p, g), ea(h);
          }, d.prototype.enterBlur = function(p) {
            aee(p), ea(h);
          }, d.prototype.leaveBlur = function(p) {
            FR(p), ea(h);
          }, d.prototype.enterSelect = function(p) {
            see(p), ea(h);
          }, d.prototype.leaveSelect = function(p) {
            lee(p), ea(h);
          }, d.prototype.getModel = function() {
            return h.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return h.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return h.getViewOfSeriesModel(p);
          }, d;
        }(ote))(h);
      }, Jte = function(h) {
        function f(d, p) {
          for (var g = 0; g < d.length; g++) {
            var v = d[g];
            v[pT] = p;
          }
        }
        I(zy, function(d, p) {
          h._messageCenter.on(p, function(g) {
            if (W6[h.group] && h[pT] !== B6) {
              if (g && g.escapeConnect)
                return;
              var v = h.makeActionFromEvent(g), m = [];
              I(Fy, function(y) {
                y !== h && y.group === h.group && m.push(y);
              }), f(m, B6), I(m, function(y) {
                y[pT] !== CAt && y.dispatchAction(v);
              }), f(m, AAt);
            }
          });
        });
      };
    }(), e;
  }(Ba)
), mN = ene.prototype;
mN.on = qte("on");
mN.off = qte("off");
mN.one = function(n, e, t) {
  var r = this;
  vs("ECharts#one is deprecated.");
  function i() {
    for (var o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    e && e.apply && e.apply(this, o), r.off(n, i);
  }
  this.on.call(this, n, i, t);
};
var TAt = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function No(n) {
  process.env.NODE_ENV !== "production" && $n("Instance " + n + " has been disposed");
}
var ES = {}, zy = {}, oD = [], aD = [], MS = [], tne = {}, sD = {}, Fy = {}, W6 = {}, kAt = +/* @__PURE__ */ new Date() - 0, yN = "_echarts_instance_";
function j6t(n, e, t) {
  var r = !(t && t.ssr);
  if (r) {
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error("Initialize failed: invalid dom.");
    var i = PAt(n);
    if (i)
      return process.env.NODE_ENV !== "production" && $n("There is a chart instance already initialized on the dom."), i;
    process.env.NODE_ENV !== "production" && ud(n) && n.nodeName.toUpperCase() !== "CANVAS" && (!n.clientWidth && (!t || t.width == null) || !n.clientHeight && (!t || t.height == null)) && $n("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var o = new ene(n, e, t);
  return o.id = "ec_" + kAt++, Fy[o.id] = o, r && VJ(n, yN, o.id), Jte(o), Ha.trigger("afterinit", o), o;
}
function PAt(n) {
  return Fy[Pxt(n, yN)];
}
function nne(n, e) {
  tne[n] = e;
}
function rne(n) {
  ct(aD, n) < 0 && aD.push(n);
}
function ine(n, e) {
  ON(oD, n, e, mAt);
}
function EAt(n) {
  bN("afterinit", n);
}
function MAt(n) {
  bN("afterupdate", n);
}
function bN(n, e) {
  Ha.on(n, e);
}
function Rl(n, e, t) {
  Le(e) && (t = e, e = "");
  var r = Ne(n) ? n.type : [n, n = {
    event: e
  }][0];
  n.event = (n.event || r).toLowerCase(), e = n.event, !zy[e] && ($e($6.test(r) && $6.test(e)), ES[r] || (ES[r] = {
    action: t,
    actionInfo: n
  }), zy[e] = r);
}
function DAt(n, e) {
  Fv.register(n, e);
}
function LAt(n, e) {
  ON(MS, n, e, Gte, "layout");
}
function Rd(n, e) {
  ON(MS, n, e, jte, "visual");
}
var G6 = [];
function ON(n, e, t, r, i) {
  if ((Le(e) || Ne(e)) && (t = e, e = r), process.env.NODE_ENV !== "production") {
    if (isNaN(e) || e == null)
      throw new Error("Illegal priority");
    I(n, function(a) {
      $e(a.__raw !== t);
    });
  }
  if (!(ct(G6, t) >= 0)) {
    G6.push(t);
    var o = Dte.wrapStageHandler(t, i);
    o.__prio = e, o.__raw = t, n.push(o);
  }
}
function one(n, e) {
  sD[n] = e;
}
function IAt(n, e, t) {
  var r = fAt("registerMap");
  r && r(n, e, t);
}
var RAt = HCt;
Rd(vN, y2t);
Rd(VC, b2t);
Rd(VC, O2t);
Rd(vN, I2t);
Rd(VC, R2t);
Rd(Hte, uAt);
rne(ste);
ine(gAt, TCt);
one("default", w2t);
Rl({
  type: Qf,
  event: Qf,
  update: Qf
}, nr);
Rl({
  type: Gw,
  event: Gw,
  update: Gw
}, nr);
Rl({
  type: Ry,
  event: Ry,
  update: Ry
}, nr);
Rl({
  type: jw,
  event: jw,
  update: jw
}, nr);
Rl({
  type: Ny,
  event: Ny,
  update: Ny
}, nr);
nne("light", M2t);
nne("dark", D2t);
var j6 = [], NAt = {
  registerPreprocessor: rne,
  registerProcessor: ine,
  registerPostInit: EAt,
  registerPostUpdate: MAt,
  registerUpdateLifecycle: bN,
  registerAction: Rl,
  registerCoordinateSystem: DAt,
  registerLayout: LAt,
  registerVisual: Rd,
  registerTransform: RAt,
  registerLoading: one,
  registerMap: IAt,
  registerImpl: hAt,
  PRIORITY: _At,
  ComponentModel: Pt,
  ComponentView: Gn,
  SeriesModel: Ln,
  ChartView: bn,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(n) {
    Pt.registerClass(n);
  },
  registerComponentView: function(n) {
    Gn.registerClass(n);
  },
  registerSeriesModel: function(n) {
    Ln.registerClass(n);
  },
  registerChartView: function(n) {
    bn.registerClass(n);
  },
  registerSubTypeDefaulter: function(n, e) {
    Pt.registerSubTypeDefaulter(n, e);
  },
  registerPainter: function(n, e) {
    oxt(n, e);
  }
};
function ft(n) {
  if (se(n)) {
    I(n, function(e) {
      ft(e);
    });
    return;
  }
  ct(j6, n) >= 0 || (j6.push(n), Le(n) && (n = {
    install: n
  }), n.install(NAt));
}
function wm(n) {
  return n == null ? 0 : n.length || 1;
}
function H6(n) {
  return n;
}
var $At = (
  /** @class */
  function() {
    function n(e, t, r, i, o, a) {
      this._old = e, this._new = t, this._oldKeyGetter = r || H6, this._newKeyGetter = i || H6, this.context = o, this._diffModeMultiple = a === "multiple";
    }
    return n.prototype.add = function(e) {
      return this._add = e, this;
    }, n.prototype.update = function(e) {
      return this._update = e, this;
    }, n.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, n.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, n.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, n.prototype.remove = function(e) {
      return this._remove = e, this;
    }, n.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, n.prototype._executeOneToOne = function() {
      var e = this._old, t = this._new, r = {}, i = new Array(e.length), o = new Array(t.length);
      this._initIndexMap(e, null, i, "_oldKeyGetter"), this._initIndexMap(t, r, o, "_newKeyGetter");
      for (var a = 0; a < e.length; a++) {
        var s = i[a], l = r[s], u = wm(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (r[s] = l[0]), this._update && this._update(c, a);
        } else
          u === 1 ? (r[s] = null, this._update && this._update(l, a)) : this._remove && this._remove(a);
      }
      this._performRestAdd(o, r);
    }, n.prototype._executeMultiple = function() {
      var e = this._old, t = this._new, r = {}, i = {}, o = [], a = [];
      this._initIndexMap(e, r, o, "_oldKeyGetter"), this._initIndexMap(t, i, a, "_newKeyGetter");
      for (var s = 0; s < o.length; s++) {
        var l = o[s], u = r[l], c = i[l], h = wm(u), f = wm(c);
        if (h > 1 && f === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (h === 1 && f > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (h === 1 && f === 1)
          this._update && this._update(c, u), i[l] = null;
        else if (h > 1 && f > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (h > 1)
          for (var d = 0; d < h; d++)
            this._remove && this._remove(u[d]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(a, i);
    }, n.prototype._performRestAdd = function(e, t) {
      for (var r = 0; r < e.length; r++) {
        var i = e[r], o = t[i], a = wm(o);
        if (a > 1)
          for (var s = 0; s < a; s++)
            this._add && this._add(o[s]);
        else
          a === 1 && this._add && this._add(o);
        t[i] = null;
      }
    }, n.prototype._initIndexMap = function(e, t, r, i) {
      for (var o = this._diffModeMultiple, a = 0; a < e.length; a++) {
        var s = "_ec_" + this[i](e[a], a);
        if (o || (r[a] = s), !!t) {
          var l = t[s], u = wm(l);
          u === 0 ? (t[s] = a, o && r.push(s)) : u === 1 ? t[s] = [l, a] : l.push(a);
        }
      }
    }, n;
  }()
);
const mu = $At;
var BAt = (
  /** @class */
  function() {
    function n(e, t) {
      this._encode = e, this._schema = t;
    }
    return n.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, n.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, n;
  }()
);
function VAt(n, e) {
  var t = {}, r = t.encode = {}, i = Ee(), o = [], a = [], s = {};
  I(n.dimensions, function(f) {
    var d = n.getDimensionInfo(f), p = d.coordDim;
    if (p) {
      process.env.NODE_ENV !== "production" && $e(qM.get(p) == null);
      var g = d.coordDimIndex;
      OT(r, p)[g] = f, d.isExtraCoord || (i.set(p, 1), zAt(d.type) && (o[0] = f), OT(s, p)[g] = n.getDimensionIndex(d.name)), d.defaultTooltip && a.push(f);
    }
    qM.each(function(v, m) {
      var y = OT(r, m), b = d.otherDims[m];
      b != null && b !== !1 && (y[b] = d.name);
    });
  });
  var l = [], u = {};
  i.each(function(f, d) {
    var p = r[d];
    u[d] = p[0], l = l.concat(p);
  }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = le(l, function(f) {
    return n.getDimensionInfo(f).storeDimIndex;
  }), t.encodeFirstDimNotExtra = u;
  var c = r.label;
  c && c.length && (o = c.slice());
  var h = r.tooltip;
  return h && h.length ? a = h.slice() : a.length || (a = o.slice()), r.defaultedLabel = o, r.defaultedTooltip = a, t.userOutput = new BAt(s, e), t;
}
function OT(n, e) {
  return n.hasOwnProperty(e) || (n[e] = []), n[e];
}
function DS(n) {
  return n === "category" ? "ordinal" : n === "time" ? "time" : "float";
}
function zAt(n) {
  return !(n === "ordinal" || n === "time");
}
var Uw = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.otherDims = {}, e != null && re(this, e);
    }
    return n;
  }()
), FAt = It(), QAt = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, ane = (
  /** @class */
  function() {
    function n(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return n.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, n.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = une(this.source)));
    }, n.prototype.getSourceDimensionIndex = function(e) {
      return qe(this._dimNameMap.get(e), -1);
    }, n.prototype.getSourceDimension = function(e) {
      var t = this.source.dimensionsDefine;
      if (t)
        return t[e];
    }, n.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, t = ute(this.source), r = !cne(e), i = "", o = [], a = 0, s = 0; a < e; a++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[s];
        if (h && h.storeDimIndex === a)
          l = t ? h.name : null, u = h.type, c = h.ordinalMeta, s++;
        else {
          var f = this.getSourceDimension(a);
          f && (l = t ? f.name : null, u = f.type);
        }
        o.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), t && l != null && (!h || !h.isCalculationCoord) && (i += r ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += QAt[u] || "f", c && (i += c.uid), i += "$";
      }
      var d = this.source, p = [d.seriesLayoutBy, d.startIndex, i].join("$$");
      return {
        dimensions: o,
        hash: p
      };
    }, n.prototype.makeOutputDimensionNames = function() {
      for (var e = [], t = 0, r = 0; t < this._fullDimCount; t++) {
        var i = void 0, o = this.dimensions[r];
        if (o && o.storeDimIndex === t)
          o.isCalculationCoord || (i = o.name), r++;
        else {
          var a = this.getSourceDimension(t);
          a && (i = a.name);
        }
        e.push(i);
      }
      return e;
    }, n.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, n;
  }()
);
function sne(n) {
  return n instanceof ane;
}
function lne(n) {
  for (var e = Ee(), t = 0; t < (n || []).length; t++) {
    var r = n[t], i = Ne(r) ? r.name : r;
    i != null && e.get(i) == null && e.set(i, t);
  }
  return e;
}
function une(n) {
  var e = FAt(n);
  return e.dimNameMap || (e.dimNameMap = lne(n.dimensionsDefine));
}
function cne(n) {
  return n > 30;
}
var xm = Ne, Bu = le, ZAt = typeof Int32Array > "u" ? Array : Int32Array, WAt = "e\0\0", q6 = -1, GAt = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], jAt = ["_approximateExtent"], Y6, _O, Sm, ap, wT, CO, xT, Ki = (
  /** @class */
  function() {
    function n(e, t) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var r, i = !1;
      sne(e) ? (r = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (i = !0, r = e), r = r || ["x", "y"];
      for (var o = {}, a = [], s = {}, l = !1, u = {}, c = 0; c < r.length; c++) {
        var h = r[c], f = we(h) ? new Uw({
          name: h
        }) : h instanceof Uw ? h : new Uw(h), d = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = d, f.coordDimIndex = 0);
        var p = f.otherDims = f.otherDims || {};
        a.push(d), o[d] = f, u[d] != null && (l = !0), f.createInvertedIndices && (s[d] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), process.env.NODE_ENV !== "production" && $e(i || f.storeDimIndex >= 0), i && (f.storeDimIndex = c);
      }
      if (this.dimensions = a, this._dimInfos = o, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = s, this._dimOmitted) {
        var g = this._dimIdxToName = Ee();
        I(a, function(v) {
          g.set(o[v].storeDimIndex, v);
        });
      }
    }
    return n.prototype.getDimension = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t == null)
        return e;
      if (t = e, !this._dimOmitted)
        return this.dimensions[t];
      var r = this._dimIdxToName.get(t);
      if (r != null)
        return r;
      var i = this._schema.getSourceDimension(t);
      if (i)
        return i.name;
    }, n.prototype.getDimensionIndex = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t != null)
        return t;
      if (e == null)
        return -1;
      var r = this._getDimInfo(e);
      return r ? r.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, n.prototype._recognizeDimIndex = function(e) {
      if ($t(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0))
        return +e;
    }, n.prototype._getStoreDimIndex = function(e) {
      var t = this.getDimensionIndex(e);
      if (process.env.NODE_ENV !== "production" && t == null)
        throw new Error("Unknown dimension " + e);
      return t;
    }, n.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, n.prototype._initGetDimensionInfo = function(e) {
      var t = this._dimInfos;
      this._getDimInfo = e ? function(r) {
        return t.hasOwnProperty(r) ? t[r] : void 0;
      } : function(r) {
        return t[r];
      };
    }, n.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, n.prototype.mapDimension = function(e, t) {
      var r = this._dimSummary;
      if (t == null)
        return r.encodeFirstDimNotExtra[e];
      var i = r.encode[e];
      return i ? i[t] : null;
    }, n.prototype.mapDimensionsAll = function(e) {
      var t = this._dimSummary, r = t.encode[e];
      return (r || []).slice();
    }, n.prototype.getStore = function() {
      return this._store;
    }, n.prototype.initData = function(e, t, r) {
      var i = this, o;
      if (e instanceof KM && (o = e), !o) {
        var a = this.dimensions, s = aN(e) || Ni(e) ? new cte(e, a.length) : e;
        o = new KM();
        var l = Bu(a, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        o.initData(s, l, r);
      }
      this._store = o, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, o.count()), this._dimSummary = VAt(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, n.prototype.appendData = function(e) {
      var t = this._store.appendData(e);
      this._doInit(t[0], t[1]);
    }, n.prototype.appendValues = function(e, t) {
      var r = this._store.appendValues(e, t.length), i = r.start, o = r.end, a = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), t)
        for (var s = i; s < o; s++) {
          var l = s - i;
          this._nameList[s] = t[l], a && xT(this, s);
        }
    }, n.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, t = this.dimensions, r = 0; r < t.length; r++) {
        var i = this._dimInfos[t[r]];
        i.ordinalMeta && e.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, n.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== nu && !e.fillStorage;
    }, n.prototype._doInit = function(e, t) {
      if (!(e >= t)) {
        var r = this._store, i = r.getProvider();
        this._updateOrdinalMeta();
        var o = this._nameList, a = this._idList, s = i.getSource().sourceFormat, l = s === Va;
        if (l && !i.pure)
          for (var u = [], c = e; c < t; c++) {
            var h = i.getItem(c, u);
            if (!this.hasItemOption && vxt(h) && (this.hasItemOption = !0), h) {
              var f = h.name;
              o[c] == null && f != null && (o[c] = wr(f, null));
              var d = h.id;
              a[c] == null && d != null && (a[c] = wr(d, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = e; c < t; c++)
            xT(this, c);
        Y6(this);
      }
    }, n.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, n.prototype.setApproximateExtent = function(e, t) {
      t = this.getDimension(t), this._approximateExtent[t] = e.slice();
    }, n.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, n.prototype.setCalculationInfo = function(e, t) {
      xm(e) ? re(this._calculationInfo, e) : this._calculationInfo[e] = t;
    }, n.prototype.getName = function(e) {
      var t = this.getRawIndex(e), r = this._nameList[t];
      return r == null && this._nameDimIdx != null && (r = Sm(this, this._nameDimIdx, t)), r == null && (r = ""), r;
    }, n.prototype._getCategory = function(e, t) {
      var r = this._store.get(e, t), i = this._store.getOrdinalMeta(e);
      return i ? i.categories[r] : r;
    }, n.prototype.getId = function(e) {
      return _O(this, this.getRawIndex(e));
    }, n.prototype.count = function() {
      return this._store.count();
    }, n.prototype.get = function(e, t) {
      var r = this._store, i = this._dimInfos[e];
      if (i)
        return r.get(i.storeDimIndex, t);
    }, n.prototype.getByRawIndex = function(e, t) {
      var r = this._store, i = this._dimInfos[e];
      if (i)
        return r.getByRawIndex(i.storeDimIndex, t);
    }, n.prototype.getIndices = function() {
      return this._store.getIndices();
    }, n.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, n.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, n.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, n.prototype.getValues = function(e, t) {
      var r = this, i = this._store;
      return se(e) ? i.getValues(Bu(e, function(o) {
        return r._getStoreDimIndex(o);
      }), t) : i.getValues(e);
    }, n.prototype.hasValue = function(e) {
      for (var t = this._dimSummary.dataDimIndicesOnCoord, r = 0, i = t.length; r < i; r++)
        if (isNaN(this._store.get(t[r], e)))
          return !1;
      return !0;
    }, n.prototype.indexOfName = function(e) {
      for (var t = 0, r = this._store.count(); t < r; t++)
        if (this.getName(t) === e)
          return t;
      return -1;
    }, n.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, n.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, n.prototype.rawIndexOf = function(e, t) {
      var r = e && this._invertedIndicesMap[e];
      if (process.env.NODE_ENV !== "production" && !r)
        throw new Error("Do not supported yet");
      var i = r[t];
      return i == null || isNaN(i) ? q6 : i;
    }, n.prototype.indicesOfNearest = function(e, t, r) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, r);
    }, n.prototype.each = function(e, t, r) {
      Le(e) && (r = t, t = e, e = []);
      var i = r || this, o = Bu(ap(e), this._getStoreDimIndex, this);
      this._store.each(o, i ? _e(t, i) : t);
    }, n.prototype.filterSelf = function(e, t, r) {
      Le(e) && (r = t, t = e, e = []);
      var i = r || this, o = Bu(ap(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(o, i ? _e(t, i) : t), this;
    }, n.prototype.selectRange = function(e) {
      var t = this, r = {}, i = Ot(e);
      return I(i, function(o) {
        var a = t._getStoreDimIndex(o);
        r[a] = e[o];
      }), this._store = this._store.selectRange(r), this;
    }, n.prototype.mapArray = function(e, t, r) {
      Le(e) && (r = t, t = e, e = []), r = r || this;
      var i = [];
      return this.each(e, function() {
        i.push(t && t.apply(this, arguments));
      }, r), i;
    }, n.prototype.map = function(e, t, r, i) {
      var o = r || i || this, a = Bu(ap(e), this._getStoreDimIndex, this), s = CO(this);
      return s._store = this._store.map(a, o ? _e(t, o) : t), s;
    }, n.prototype.modify = function(e, t, r, i) {
      var o = this, a = r || i || this;
      process.env.NODE_ENV !== "production" && I(ap(e), function(l) {
        var u = o.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = Bu(ap(e), this._getStoreDimIndex, this);
      this._store.modify(s, a ? _e(t, a) : t);
    }, n.prototype.downSample = function(e, t, r, i) {
      var o = CO(this);
      return o._store = this._store.downSample(this._getStoreDimIndex(e), t, r, i), o;
    }, n.prototype.lttbDownSample = function(e, t) {
      var r = CO(this);
      return r._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), r;
    }, n.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, n.prototype.getItemModel = function(e) {
      var t = this.hostModel, r = this.getRawDataItem(e);
      return new mn(r, t, t && t.ecModel);
    }, n.prototype.diff = function(e) {
      var t = this;
      return new mu(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(r) {
        return _O(e, r);
      }, function(r) {
        return _O(t, r);
      });
    }, n.prototype.getVisual = function(e) {
      var t = this._visual;
      return t && t[e];
    }, n.prototype.setVisual = function(e, t) {
      this._visual = this._visual || {}, xm(e) ? re(this._visual, e) : this._visual[e] = t;
    }, n.prototype.getItemVisual = function(e, t) {
      var r = this._itemVisuals[e], i = r && r[t];
      return i ?? this.getVisual(t);
    }, n.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, n.prototype.ensureUniqueItemVisual = function(e, t) {
      var r = this._itemVisuals, i = r[e];
      i || (i = r[e] = {});
      var o = i[t];
      return o == null && (o = this.getVisual(t), se(o) ? o = o.slice() : xm(o) && (o = re({}, o)), i[t] = o), o;
    }, n.prototype.setItemVisual = function(e, t, r) {
      var i = this._itemVisuals[e] || {};
      this._itemVisuals[e] = i, xm(t) ? re(i, t) : i[t] = r;
    }, n.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, n.prototype.setLayout = function(e, t) {
      xm(e) ? re(this._layout, e) : this._layout[e] = t;
    }, n.prototype.getLayout = function(e) {
      return this._layout[e];
    }, n.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, n.prototype.setItemLayout = function(e, t, r) {
      this._itemLayouts[e] = r ? re(this._itemLayouts[e] || {}, t) : t;
    }, n.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, n.prototype.setItemGraphicEl = function(e, t) {
      var r = this.hostModel && this.hostModel.seriesIndex;
      BM(r, this.dataType, e, t), this._graphicEls[e] = t;
    }, n.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, n.prototype.eachItemGraphicEl = function(e, t) {
      I(this._graphicEls, function(r, i) {
        r && e && e.call(t, r, i);
      });
    }, n.prototype.cloneShallow = function(e) {
      return e || (e = new n(this._schema ? this._schema : Bu(this.dimensions, this._getDimInfo, this), this.hostModel)), wT(e, this), e._store = this._store, e;
    }, n.prototype.wrapMethod = function(e, t) {
      var r = this[e];
      Le(r) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var i = r.apply(this, arguments);
        return t.apply(this, [i].concat(SR(arguments)));
      });
    }, n.internalField = function() {
      Y6 = function(e) {
        var t = e._invertedIndicesMap;
        I(t, function(r, i) {
          var o = e._dimInfos[i], a = o.ordinalMeta, s = e._store;
          if (a) {
            r = t[i] = new ZAt(a.categories.length);
            for (var l = 0; l < r.length; l++)
              r[l] = q6;
            for (var l = 0; l < s.count(); l++)
              r[s.get(o.storeDimIndex, l)] = l;
          }
        });
      }, Sm = function(e, t, r) {
        return wr(e._getCategory(t, r), null);
      }, _O = function(e, t) {
        var r = e._idList[t];
        return r == null && e._idDimIdx != null && (r = Sm(e, e._idDimIdx, t)), r == null && (r = WAt + t), r;
      }, ap = function(e) {
        return se(e) || (e = e != null ? [e] : []), e;
      }, CO = function(e) {
        var t = new n(e._schema ? e._schema : Bu(e.dimensions, e._getDimInfo, e), e.hostModel);
        return wT(t, e), t;
      }, wT = function(e, t) {
        I(GAt.concat(t.__wrappedMethods || []), function(r) {
          t.hasOwnProperty(r) && (e[r] = t[r]);
        }), e.__wrappedMethods = t.__wrappedMethods, I(jAt, function(r) {
          e[r] = Fe(t[r]);
        }), e._calculationInfo = re({}, t._calculationInfo);
      }, xT = function(e, t) {
        var r = e._nameList, i = e._idList, o = e._nameDimIdx, a = e._idDimIdx, s = r[t], l = i[t];
        if (s == null && o != null && (r[t] = s = Sm(e, o, t)), l == null && a != null && (i[t] = l = Sm(e, a, t)), l == null && s != null) {
          var u = e._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[t] = l;
        }
      };
    }(), n;
  }()
);
function Wb(n, e) {
  aN(n) || (n = sN(n)), e = e || {};
  var t = e.coordDimensions || [], r = e.dimensionsDefine || n.dimensionsDefine || [], i = Ee(), o = [], a = qAt(n, t, r, e.dimensionsCount), s = e.canOmitUnusedDimensions && cne(a), l = r === n.dimensionsDefine, u = l ? une(n) : lne(r), c = e.encodeDefine;
  !c && e.encodeDefaulter && (c = e.encodeDefaulter(n, a));
  for (var h = Ee(c), f = new yte(a), d = 0; d < f.length; d++)
    f[d] = -1;
  function p(C) {
    var A = f[C];
    if (A < 0) {
      var k = r[C], P = Ne(k) ? k : {
        name: k
      }, L = new Uw(), D = P.name;
      D != null && u.get(D) != null && (L.name = L.displayName = D), P.type != null && (L.type = P.type), P.displayName != null && (L.displayName = P.displayName);
      var E = o.length;
      return f[C] = E, L.storeDimIndex = C, o.push(L), L;
    }
    return o[A];
  }
  if (!s)
    for (var d = 0; d < a; d++)
      p(d);
  h.each(function(C, A) {
    var k = an(C).slice();
    if (k.length === 1 && !we(k[0]) && k[0] < 0) {
      h.set(A, !1);
      return;
    }
    var P = h.set(A, []);
    I(k, function(L, D) {
      var E = we(L) ? u.get(L) : L;
      E != null && E < a && (P[D] = E, v(p(E), A, D));
    });
  });
  var g = 0;
  I(t, function(C) {
    var A, k, P, L;
    if (we(C))
      A = C, L = {};
    else {
      L = C, A = L.name;
      var D = L.ordinalMeta;
      L.ordinalMeta = null, L = re({}, L), L.ordinalMeta = D, k = L.dimsDef, P = L.otherDims, L.name = L.coordDim = L.coordDimIndex = L.dimsDef = L.otherDims = null;
    }
    var E = h.get(A);
    if (E !== !1) {
      if (E = an(E), !E.length)
        for (var M = 0; M < (k && k.length || 1); M++) {
          for (; g < a && p(g).coordDim != null; )
            g++;
          g < a && E.push(g++);
        }
      I(E, function(R, N) {
        var $ = p(R);
        if (l && L.type != null && ($.type = L.type), v(Be($, L), A, N), $.name == null && k) {
          var F = k[N];
          !Ne(F) && (F = {
            name: F
          }), $.name = $.displayName = F.name, $.defaultTooltip = F.defaultTooltip;
        }
        P && Be($.otherDims, P);
      });
    }
  });
  function v(C, A, k) {
    qM.get(A) != null ? C.otherDims[A] = k : (C.coordDim = A, C.coordDimIndex = k, i.set(A, !0));
  }
  var m = e.generateCoord, y = e.generateCoordCount, b = y != null;
  y = m ? y || 1 : 0;
  var O = m || "value";
  function w(C) {
    C.name == null && (C.name = C.coordDim);
  }
  if (s)
    I(o, function(C) {
      w(C);
    }), o.sort(function(C, A) {
      return C.storeDimIndex - A.storeDimIndex;
    });
  else
    for (var x = 0; x < a; x++) {
      var S = p(x), _ = S.coordDim;
      _ == null && (S.coordDim = YAt(O, i, b), S.coordDimIndex = 0, (!m || y <= 0) && (S.isExtraCoord = !0), y--), w(S), S.type == null && (nte(n, x) === ti.Must || S.isExtraCoord && (S.otherDims.itemName != null || S.otherDims.seriesName != null)) && (S.type = "ordinal");
    }
  return HAt(o), new ane({
    source: n,
    dimensions: o,
    fullDimensionCount: a,
    dimensionOmitted: s
  });
}
function HAt(n) {
  for (var e = Ee(), t = 0; t < n.length; t++) {
    var r = n[t], i = r.name, o = e.get(i) || 0;
    o > 0 && (r.name = i + (o - 1)), o++, e.set(i, o);
  }
}
function qAt(n, e, t, r) {
  var i = Math.max(n.dimensionsDetectedCount || 1, e.length, t.length, r || 0);
  return I(e, function(o) {
    var a;
    Ne(o) && (a = o.dimsDef) && (i = Math.max(i, a.length));
  }), i;
}
function YAt(n, e, t) {
  if (t || e.hasKey(n)) {
    for (var r = 0; e.hasKey(n + r); )
      r++;
    n += r;
  }
  return e.set(n, !0), n;
}
var XAt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.coordSysDims = [], this.axisMap = Ee(), this.categoryAxisMap = Ee(), this.coordSysName = e;
    }
    return n;
  }()
);
function UAt(n) {
  var e = n.get("coordinateSystem"), t = new XAt(e), r = KAt[e];
  if (r)
    return r(n, t, t.axisMap, t.categoryAxisMap), t;
}
var KAt = {
  cartesian2d: function(n, e, t, r) {
    var i = n.getReferringComponents("xAxis", cr).models[0], o = n.getReferringComponents("yAxis", cr).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!i)
        throw new Error('xAxis "' + ur(n.get("xAxisIndex"), n.get("xAxisId"), 0) + '" not found');
      if (!o)
        throw new Error('yAxis "' + ur(n.get("xAxisIndex"), n.get("yAxisId"), 0) + '" not found');
    }
    e.coordSysDims = ["x", "y"], t.set("x", i), t.set("y", o), sp(i) && (r.set("x", i), e.firstCategoryDimIndex = 0), sp(o) && (r.set("y", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  singleAxis: function(n, e, t, r) {
    var i = n.getReferringComponents("singleAxis", cr).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("singleAxis should be specified.");
    e.coordSysDims = ["single"], t.set("single", i), sp(i) && (r.set("single", i), e.firstCategoryDimIndex = 0);
  },
  polar: function(n, e, t, r) {
    var i = n.getReferringComponents("polar", cr).models[0], o = i.findAxisModel("radiusAxis"), a = i.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!a)
        throw new Error("angleAxis option not found");
      if (!o)
        throw new Error("radiusAxis option not found");
    }
    e.coordSysDims = ["radius", "angle"], t.set("radius", o), t.set("angle", a), sp(o) && (r.set("radius", o), e.firstCategoryDimIndex = 0), sp(a) && (r.set("angle", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  geo: function(n, e, t, r) {
    e.coordSysDims = ["lng", "lat"];
  },
  parallel: function(n, e, t, r) {
    var i = n.ecModel, o = i.getComponent("parallel", n.get("parallelIndex")), a = e.coordSysDims = o.dimensions.slice();
    I(o.parallelAxisIndex, function(s, l) {
      var u = i.getComponent("parallelAxis", s), c = a[l];
      t.set(c, u), sp(u) && (r.set(c, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
    });
  }
};
function sp(n) {
  return n.get("type") === "category";
}
function JAt(n, e, t) {
  t = t || {};
  var r = t.byIndex, i = t.stackedCoordDimension, o, a, s;
  eTt(e) ? o = e : (a = e.schema, o = a.dimensions, s = e.store);
  var l = !!(n && n.get("stack")), u, c, h, f;
  if (I(o, function(y, b) {
    we(y) && (o[b] = y = {
      name: y
    }), l && !y.isExtraCoord && (!r && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
  }), c && !r && !u && (r = !0), c) {
    h = "__\0ecstackresult_" + n.id, f = "__\0ecstackedover_" + n.id, u && (u.createInvertedIndices = !0);
    var d = c.coordDim, p = c.type, g = 0;
    I(o, function(y) {
      y.coordDim === d && g++;
    });
    var v = {
      name: h,
      coordDim: d,
      coordDimIndex: g,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: o.length
    }, m = {
      name: f,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: f,
      coordDimIndex: g + 1,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: o.length + 1
    };
    a ? (s && (v.storeDimIndex = s.ensureCalculationDimension(f, p), m.storeDimIndex = s.ensureCalculationDimension(h, p)), a.appendCalculationDimension(v), a.appendCalculationDimension(m)) : (o.push(v), o.push(m));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: r,
    stackedOverDimension: f,
    stackResultDimension: h
  };
}
function eTt(n) {
  return !sne(n.schema);
}
function Uc(n, e) {
  return !!e && e === n.getCalculationInfo("stackedDimension");
}
function hne(n, e) {
  return Uc(n, e) ? n.getCalculationInfo("stackResultDimension") : e;
}
function tTt(n, e) {
  var t = n.get("coordinateSystem"), r = Fv.get(t), i;
  return e && e.coordSysDims && (i = le(e.coordSysDims, function(o) {
    var a = {
      name: o
    }, s = e.axisMap.get(o);
    if (s) {
      var l = s.get("type");
      a.type = DS(l);
    }
    return a;
  })), i || (i = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || ["x", "y"]), i;
}
function nTt(n, e, t) {
  var r, i;
  return t && I(n, function(o, a) {
    var s = o.coordDim, l = t.categoryAxisMap.get(s);
    l && (r == null && (r = a), o.ordinalMeta = l.getOrdinalMeta(), e && (o.createInvertedIndices = !0)), o.otherDims.itemName != null && (i = !0);
  }), !i && r != null && (n[r].otherDims.itemName = 0), r;
}
function ku(n, e, t) {
  t = t || {};
  var r = e.getSourceManager(), i, o = !1;
  n ? (o = !0, i = sN(n)) : (i = r.getSource(), o = i.sourceFormat === Va);
  var a = UAt(e), s = tTt(e, a), l = t.useEncodeDefaulter, u = Le(l) ? l : l ? Je(tte, s, e) : null, c = {
    coordDimensions: s,
    generateCoord: t.generateCoord,
    encodeDefine: e.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !o
  }, h = Wb(i, c), f = nTt(h.dimensions, t.createInvertedIndices, a), d = o ? null : r.getSharedDataStore(h), p = JAt(e, {
    schema: h,
    store: d
  }), g = new Ki(h, e);
  g.setCalculationInfo(p);
  var v = f != null && rTt(i) ? function(m, y, b, O) {
    return O === f ? b : this.defaultDimValueGetter(m, y, b, O);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    o ? i : d,
    null,
    v
  ), g;
}
function rTt(n) {
  if (n.sourceFormat === Va) {
    var e = iTt(n.data || []);
    return !se(Mv(e));
  }
}
function iTt(n) {
  for (var e = 0; e < n.length && n[e] == null; )
    e++;
  return n[e];
}
var fne = (
  /** @class */
  function() {
    function n(e) {
      this._setting = e || {}, this._extent = [1 / 0, -1 / 0];
    }
    return n.prototype.getSetting = function(e) {
      return this._setting[e];
    }, n.prototype.unionExtent = function(e) {
      var t = this._extent;
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]);
    }, n.prototype.unionExtentFromData = function(e, t) {
      this.unionExtent(e.getApproximateExtent(t));
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.setExtent = function(e, t) {
      var r = this._extent;
      isNaN(e) || (r[0] = e), isNaN(t) || (r[1] = t);
    }, n.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, n.prototype.isBlank = function() {
      return this._isBlank;
    }, n.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, n;
  }()
);
bC(fne);
const Pu = fne;
var oTt = 0, lD = (
  /** @class */
  function() {
    function n(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++oTt;
    }
    return n.createByAxisModel = function(e) {
      var t = e.option, r = t.data, i = r && le(r, aTt);
      return new n({
        categories: i,
        needCollect: !i,
        // deduplication is default in axis.
        deduplication: t.dedplication !== !1
      });
    }, n.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, n.prototype.parseAndCollect = function(e) {
      var t, r = this._needCollect;
      if (!we(e) && !r)
        return e;
      if (r && !this._deduplication)
        return t = this.categories.length, this.categories[t] = e, t;
      var i = this._getOrCreateMap();
      return t = i.get(e), t == null && (r ? (t = this.categories.length, this.categories[t] = e, i.set(e, t)) : t = NaN), t;
    }, n.prototype._getOrCreateMap = function() {
      return this._map || (this._map = Ee(this.categories));
    }, n;
  }()
);
function aTt(n) {
  return Ne(n) && n.value != null ? n.value : n + "";
}
function sTt(n) {
  var e = Math.pow(10, mC(Math.abs(n))), t = Math.abs(n / e);
  return t === 0 || t === 1 || t === 2 || t === 3 || t === 5;
}
function uD(n) {
  return n.type === "interval" || n.type === "log";
}
function lTt(n, e, t, r) {
  var i = {}, o = n[1] - n[0], a = i.interval = DJ(o / e, !0);
  t != null && a < t && (a = i.interval = t), r != null && a > r && (a = i.interval = r);
  var s = i.intervalPrecision = dne(a), l = i.niceTickExtent = [qn(Math.ceil(n[0] / a) * a, s), qn(Math.floor(n[1] / a) * a, s)];
  return uTt(l, n), i;
}
function ST(n) {
  var e = Math.pow(10, mC(n)), t = n / e;
  return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, qn(t * e);
}
function dne(n) {
  return rl(n) + 2;
}
function X6(n, e, t) {
  n[e] = Math.max(Math.min(n[e], t[1]), t[0]);
}
function uTt(n, e) {
  !isFinite(n[0]) && (n[0] = e[0]), !isFinite(n[1]) && (n[1] = e[1]), X6(n, 0, e), X6(n, 1, e), n[0] > n[1] && (n[0] = n[1]);
}
function zC(n, e) {
  return n >= e[0] && n <= e[1];
}
function FC(n, e) {
  return e[1] === e[0] ? 0.5 : (n - e[0]) / (e[1] - e[0]);
}
function QC(n, e) {
  return n * (e[1] - e[0]) + e[0];
}
var pne = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      r.type = "ordinal";
      var i = r.getSetting("ordinalMeta");
      return i || (i = new lD({})), se(i) && (i = new lD({
        categories: le(i, function(o) {
          return Ne(o) ? o.value : o;
        })
      })), r._ordinalMeta = i, r._extent = r.getSetting("extent") || [0, i.categories.length - 1], r;
    }
    return e.prototype.parse = function(t) {
      return t == null ? NaN : we(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
    }, e.prototype.contain = function(t) {
      return t = this.parse(t), zC(t, this._extent) && this._ordinalMeta.categories[t] != null;
    }, e.prototype.normalize = function(t) {
      return t = this._getTickNumber(this.parse(t)), FC(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Math.round(QC(t, this._extent)), this.getRawOrdinalNumber(t);
    }, e.prototype.getTicks = function() {
      for (var t = [], r = this._extent, i = r[0]; i <= r[1]; )
        t.push({
          value: i
        }), i++;
      return t;
    }, e.prototype.getMinorTicks = function(t) {
    }, e.prototype.setSortInfo = function(t) {
      if (t == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var r = t.ordinalNumbers, i = this._ordinalNumbersByTick = [], o = this._ticksByOrdinalNumber = [], a = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, r.length); a < l; ++a) {
        var u = r[a];
        i[a] = u, o[u] = a;
      }
      for (var c = 0; a < s; ++a) {
        for (; o[c] != null; )
          c++;
        i.push(c), o[c] = a;
      }
    }, e.prototype._getTickNumber = function(t) {
      var r = this._ticksByOrdinalNumber;
      return r && t >= 0 && t < r.length ? r[t] : t;
    }, e.prototype.getRawOrdinalNumber = function(t) {
      var r = this._ordinalNumbersByTick;
      return r && t >= 0 && t < r.length ? r[t] : t;
    }, e.prototype.getLabel = function(t) {
      if (!this.isBlank()) {
        var r = this.getRawOrdinalNumber(t.value), i = this._ordinalMeta.categories[r];
        return i == null ? "" : i + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.isInExtentRange = function(t) {
      return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(Pu)
);
Pu.registerClass(pne);
const wN = pne;
var zh = qn, gne = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t;
    }
    return e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return zC(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return FC(t, this._extent);
    }, e.prototype.scale = function(t) {
      return QC(t, this._extent);
    }, e.prototype.setExtent = function(t, r) {
      var i = this._extent;
      isNaN(t) || (i[0] = parseFloat(t)), isNaN(r) || (i[1] = parseFloat(r));
    }, e.prototype.unionExtent = function(t) {
      var r = this._extent;
      t[0] < r[0] && (r[0] = t[0]), t[1] > r[1] && (r[1] = t[1]), this.setExtent(r[0], r[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(t) {
      this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = dne(t);
    }, e.prototype.getTicks = function(t) {
      var r = this._interval, i = this._extent, o = this._niceExtent, a = this._intervalPrecision, s = [];
      if (!r)
        return s;
      var l = 1e4;
      i[0] < o[0] && (t ? s.push({
        value: zh(o[0] - r, a)
      }) : s.push({
        value: i[0]
      }));
      for (var u = o[0]; u <= o[1] && (s.push({
        value: u
      }), u = zh(u + r, a), u !== s[s.length - 1].value); )
        if (s.length > l)
          return [];
      var c = s.length ? s[s.length - 1].value : o[1];
      return i[1] > c && (t ? s.push({
        value: zh(c + r, a)
      }) : s.push({
        value: i[1]
      })), s;
    }, e.prototype.getMinorTicks = function(t) {
      for (var r = this.getTicks(!0), i = [], o = this.getExtent(), a = 1; a < r.length; a++) {
        for (var s = r[a], l = r[a - 1], u = 0, c = [], h = s.value - l.value, f = h / t; u < t - 1; ) {
          var d = zh(l.value + (u + 1) * f);
          d > o[0] && d < o[1] && c.push(d), u++;
        }
        i.push(c);
      }
      return i;
    }, e.prototype.getLabel = function(t, r) {
      if (t == null)
        return "";
      var i = r && r.precision;
      i == null ? i = rl(t.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var o = zh(t.value, i, !0);
      return Hee(o);
    }, e.prototype.calcNiceTicks = function(t, r, i) {
      t = t || 5;
      var o = this._extent, a = o[1] - o[0];
      if (isFinite(a)) {
        a < 0 && (a = -a, o.reverse());
        var s = lTt(o, t, r, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      var r = this._extent;
      if (r[0] === r[1])
        if (r[0] !== 0) {
          var i = Math.abs(r[0]);
          t.fixMax || (r[1] += i / 2), r[0] -= i / 2;
        } else
          r[1] = 1;
      var o = r[1] - r[0];
      isFinite(o) || (r[0] = 0, r[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
      var a = this._interval;
      t.fixMin || (r[0] = zh(Math.floor(r[0] / a) * a)), t.fixMax || (r[1] = zh(Math.ceil(r[1] / a) * a));
    }, e.prototype.setNiceExtent = function(t, r) {
      this._niceExtent = [t, r];
    }, e.type = "interval", e;
  }(Pu)
);
Pu.registerClass(gne);
const Kc = gne;
var vne = typeof Float32Array < "u", cTt = vne ? Float32Array : Array;
function ol(n) {
  return se(n) ? vne ? new Float32Array(n) : n : new cTt(n);
}
var cD = "__ec_stack_";
function xN(n) {
  return n.get("stack") || cD + n.seriesIndex;
}
function SN(n) {
  return n.dim + n.index;
}
function hTt(n) {
  var e = [], t = n.axis, r = "axis0";
  if (t.type === "category") {
    for (var i = t.getBandWidth(), o = 0; o < n.count; o++)
      e.push(Be({
        bandWidth: i,
        axisKey: r,
        stackId: cD + o
      }, n));
    for (var a = bne(e), s = [], o = 0; o < n.count; o++) {
      var l = a[r][cD + o];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function mne(n, e) {
  var t = [];
  return e.eachSeriesByType(n, function(r) {
    xne(r) && t.push(r);
  }), t;
}
function fTt(n) {
  var e = {};
  I(n, function(l) {
    var u = l.coordinateSystem, c = u.getBaseAxis();
    if (!(c.type !== "time" && c.type !== "value"))
      for (var h = l.getData(), f = c.dim + "_" + c.index, d = h.getDimensionIndex(h.mapDimension(c.dim)), p = h.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var m = p.get(d, g);
        e[f] ? e[f].push(m) : e[f] = [m];
      }
  });
  var t = {};
  for (var r in e)
    if (e.hasOwnProperty(r)) {
      var i = e[r];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var o = null, a = 1; a < i.length; ++a) {
          var s = i[a] - i[a - 1];
          s > 0 && (o = o === null ? s : Math.min(o, s));
        }
        t[r] = o;
      }
    }
  return t;
}
function yne(n) {
  var e = fTt(n), t = [];
  return I(n, function(r) {
    var i = r.coordinateSystem, o = i.getBaseAxis(), a = o.getExtent(), s;
    if (o.type === "category")
      s = o.getBandWidth();
    else if (o.type === "value" || o.type === "time") {
      var l = o.dim + "_" + o.index, u = e[l], c = Math.abs(a[1] - a[0]), h = o.scale.getExtent(), f = Math.abs(h[1] - h[0]);
      s = u ? c / f * u : c;
    } else {
      var d = r.getData();
      s = Math.abs(a[1] - a[0]) / d.count();
    }
    var p = be(r.get("barWidth"), s), g = be(r.get("barMaxWidth"), s), v = be(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      r.get("barMinWidth") || (Sne(r) ? 0.5 : 1),
      s
    ), m = r.get("barGap"), y = r.get("barCategoryGap");
    t.push({
      bandWidth: s,
      barWidth: p,
      barMaxWidth: g,
      barMinWidth: v,
      barGap: m,
      barCategoryGap: y,
      axisKey: SN(o),
      stackId: xN(r)
    });
  }), bne(t);
}
function bne(n) {
  var e = {};
  I(n, function(r, i) {
    var o = r.axisKey, a = r.bandWidth, s = e[o] || {
      bandWidth: a,
      remainedWidth: a,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, l = s.stacks;
    e[o] = s;
    var u = r.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var c = r.barWidth;
    c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
    var h = r.barMaxWidth;
    h && (l[u].maxWidth = h);
    var f = r.barMinWidth;
    f && (l[u].minWidth = f);
    var d = r.barGap;
    d != null && (s.gap = d);
    var p = r.barCategoryGap;
    p != null && (s.categoryGap = p);
  });
  var t = {};
  return I(e, function(r, i) {
    t[i] = {};
    var o = r.stacks, a = r.bandWidth, s = r.categoryGap;
    if (s == null) {
      var l = Ot(o).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = be(s, a), c = be(r.gap, 1), h = r.remainedWidth, f = r.autoWidthCount, d = (h - u) / (f + (f - 1) * c);
    d = Math.max(d, 0), I(o, function(m) {
      var y = m.maxWidth, b = m.minWidth;
      if (m.width) {
        var O = m.width;
        y && (O = Math.min(O, y)), b && (O = Math.max(O, b)), m.width = O, h -= O + c * O, f--;
      } else {
        var O = d;
        y && y < O && (O = Math.min(y, h)), b && b > O && (O = b), O !== d && (m.width = O, h -= O + c * O, f--);
      }
    }), d = (h - u) / (f + (f - 1) * c), d = Math.max(d, 0);
    var p = 0, g;
    I(o, function(m, y) {
      m.width || (m.width = d), g = m, p += m.width * (1 + c);
    }), g && (p -= g.width * c);
    var v = -p / 2;
    I(o, function(m, y) {
      t[i][y] = t[i][y] || {
        bandWidth: a,
        offset: v,
        width: m.width
      }, v += m.width * (1 + c);
    });
  }), t;
}
function dTt(n, e, t) {
  if (n && e) {
    var r = n[SN(e)];
    return r != null && t != null ? r[xN(t)] : r;
  }
}
function One(n, e) {
  var t = mne(n, e), r = yne(t);
  I(t, function(i) {
    var o = i.getData(), a = i.coordinateSystem, s = a.getBaseAxis(), l = xN(i), u = r[SN(s)][l], c = u.offset, h = u.width;
    o.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: h
    });
  });
}
function wne(n) {
  return {
    seriesType: n,
    plan: Qv(),
    reset: function(e) {
      if (xne(e)) {
        var t = e.getData(), r = e.coordinateSystem, i = r.getBaseAxis(), o = r.getOtherAxis(i), a = t.getDimensionIndex(t.mapDimension(o.dim)), s = t.getDimensionIndex(t.mapDimension(i.dim)), l = e.get("showBackground", !0), u = t.mapDimension(o.dim), c = t.getCalculationInfo("stackResultDimension"), h = Uc(t, u) && !!t.getCalculationInfo("stackedOnSeries"), f = o.isHorizontal(), d = pTt(i, o), p = Sne(e), g = e.get("barMinHeight") || 0, v = c && t.getDimensionIndex(c), m = t.getLayout("size"), y = t.getLayout("offset");
        return {
          progress: function(b, O) {
            for (var w = b.count, x = p && ol(w * 3), S = p && l && ol(w * 3), _ = p && ol(w), C = r.master.getRect(), A = f ? C.width : C.height, k, P = O.getStore(), L = 0; (k = b.next()) != null; ) {
              var D = P.get(h ? v : a, k), E = P.get(s, k), M = d, R = void 0;
              h && (R = +D - P.get(a, k));
              var N = void 0, $ = void 0, F = void 0, W = void 0;
              if (f) {
                var j = r.dataToPoint([D, E]);
                if (h) {
                  var Y = r.dataToPoint([R, E]);
                  M = Y[0];
                }
                N = M, $ = j[1] + y, F = j[0] - M, W = m, Math.abs(F) < g && (F = (F < 0 ? -1 : 1) * g);
              } else {
                var j = r.dataToPoint([E, D]);
                if (h) {
                  var Y = r.dataToPoint([E, R]);
                  M = Y[1];
                }
                N = j[0] + y, $ = M, F = m, W = j[1] - M, Math.abs(W) < g && (W = (W <= 0 ? -1 : 1) * g);
              }
              p ? (x[L] = N, x[L + 1] = $, x[L + 2] = f ? F : W, S && (S[L] = f ? C.x : N, S[L + 1] = f ? $ : C.y, S[L + 2] = A), _[k] = k) : O.setItemLayout(k, {
                x: N,
                y: $,
                width: F,
                height: W
              }), L += 3;
            }
            p && O.setLayout({
              largePoints: x,
              largeDataIndices: _,
              largeBackgroundPoints: S,
              valueAxisHorizontal: f
            });
          }
        };
      }
    }
  };
}
function xne(n) {
  return n.coordinateSystem && n.coordinateSystem.type === "cartesian2d";
}
function Sne(n) {
  return n.pipelineContext && n.pipelineContext.large;
}
function pTt(n, e) {
  return e.toGlobalCoord(e.dataToCoord(e.type === "log" ? 1 : 0));
}
var gTt = function(n, e, t, r) {
  for (; t < r; ) {
    var i = t + r >>> 1;
    n[i][1] < e ? t = i + 1 : r = i;
  }
  return t;
}, _ne = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "time", r;
    }
    return e.prototype.getLabel = function(t) {
      var r = this.getSetting("useUTC");
      return EC(t.value, zF[Z_t(Jp(this._minLevelUnit))] || zF.second, r, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(t, r, i) {
      var o = this.getSetting("useUTC"), a = this.getSetting("locale");
      return W_t(t, r, i, a, o);
    }, e.prototype.getTicks = function() {
      var t = this._interval, r = this._extent, i = [];
      if (!t)
        return i;
      i.push({
        value: r[0],
        level: 0
      });
      var o = this.getSetting("useUTC"), a = xTt(this._minLevelUnit, this._approxInterval, o, r);
      return i = i.concat(a), i.push({
        value: r[1],
        level: 0
      }), i;
    }, e.prototype.calcNiceExtent = function(t) {
      var r = this._extent;
      if (r[0] === r[1] && (r[0] -= ya, r[1] += ya), r[1] === -1 / 0 && r[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        r[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), r[0] = r[1] - ya;
      }
      this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
    }, e.prototype.calcNiceTicks = function(t, r, i) {
      t = t || 10;
      var o = this._extent, a = o[1] - o[0];
      this._approxInterval = a / t, r != null && this._approxInterval < r && (this._approxInterval = r), i != null && this._approxInterval > i && (this._approxInterval = i);
      var s = AO.length, l = Math.min(gTt(AO, this._approxInterval, 0, s), s - 1);
      this._interval = AO[l][1], this._minLevelUnit = AO[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(t) {
      return $t(t) ? t : +Cl(t);
    }, e.prototype.contain = function(t) {
      return zC(this.parse(t), this._extent);
    }, e.prototype.normalize = function(t) {
      return FC(this.parse(t), this._extent);
    }, e.prototype.scale = function(t) {
      return QC(t, this._extent);
    }, e.type = "time", e;
  }(Kc)
), AO = [
  // Format                           interval
  ["second", KR],
  ["minute", JR],
  ["hour", By],
  ["quarter-day", By * 6],
  ["half-day", By * 12],
  ["day", ya * 1.2],
  ["half-week", ya * 3.5],
  ["week", ya * 7],
  ["month", ya * 31],
  ["quarter", ya * 95],
  ["half-year", VF / 2],
  ["year", VF]
  // 1Y
];
function vTt(n, e, t, r) {
  var i = Cl(e), o = Cl(t), a = function(p) {
    return FF(i, p, r) === FF(o, p, r);
  }, s = function() {
    return a("year");
  }, l = function() {
    return s() && a("month");
  }, u = function() {
    return l() && a("day");
  }, c = function() {
    return u() && a("hour");
  }, h = function() {
    return c() && a("minute");
  }, f = function() {
    return h() && a("second");
  }, d = function() {
    return f() && a("millisecond");
  };
  switch (n) {
    case "year":
      return s();
    case "month":
      return l();
    case "day":
      return u();
    case "hour":
      return c();
    case "minute":
      return h();
    case "second":
      return f();
    case "millisecond":
      return d();
  }
}
function mTt(n, e) {
  return n /= ya, n > 16 ? 16 : n > 7.5 ? 7 : n > 3.5 ? 4 : n > 1.5 ? 2 : 1;
}
function yTt(n) {
  var e = 30 * ya;
  return n /= e, n > 6 ? 6 : n > 3 ? 3 : n > 2 ? 2 : 1;
}
function bTt(n) {
  return n /= By, n > 12 ? 12 : n > 6 ? 6 : n > 3.5 ? 4 : n > 2 ? 2 : 1;
}
function U6(n, e) {
  return n /= e ? JR : KR, n > 30 ? 30 : n > 20 ? 20 : n > 15 ? 15 : n > 10 ? 10 : n > 5 ? 5 : n > 2 ? 2 : 1;
}
function OTt(n) {
  return DJ(n, !0);
}
function wTt(n, e, t) {
  var r = new Date(n);
  switch (Jp(e)) {
    case "year":
    case "month":
      r[Fee(t)](0);
    case "day":
      r[Qee(t)](1);
    case "hour":
      r[Zee(t)](0);
    case "minute":
      r[Wee(t)](0);
    case "second":
      r[Gee(t)](0), r[jee(t)](0);
  }
  return r.getTime();
}
function xTt(n, e, t, r) {
  var i = 1e4, o = Vee, a = 0;
  function s(A, k, P, L, D, E, M) {
    for (var R = new Date(k), N = k, $ = R[L](); N < P && N <= r[1]; )
      M.push({
        value: N
      }), $ += A, R[D]($), N = R.getTime();
    M.push({
      value: N,
      notAdd: !0
    });
  }
  function l(A, k, P) {
    var L = [], D = !k.length;
    if (!vTt(Jp(A), r[0], r[1], t)) {
      D && (k = [{
        // TODO Optimize. Not include so may ticks.
        value: wTt(new Date(r[0]), A, t)
      }, {
        value: r[1]
      }]);
      for (var E = 0; E < k.length - 1; E++) {
        var M = k[E].value, R = k[E + 1].value;
        if (M !== R) {
          var N = void 0, $ = void 0, F = void 0, W = !1;
          switch (A) {
            case "year":
              N = Math.max(1, Math.round(e / ya / 365)), $ = eN(t), F = G_t(t);
              break;
            case "half-year":
            case "quarter":
            case "month":
              N = yTt(e), $ = eg(t), F = Fee(t);
              break;
            case "week":
            case "half-week":
            case "day":
              N = mTt(e), $ = MC(t), F = Qee(t), W = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              N = bTt(e), $ = V0(t), F = Zee(t);
              break;
            case "minute":
              N = U6(e, !0), $ = DC(t), F = Wee(t);
              break;
            case "second":
              N = U6(e, !1), $ = LC(t), F = Gee(t);
              break;
            case "millisecond":
              N = OTt(e), $ = IC(t), F = jee(t);
              break;
          }
          s(N, M, R, $, F, W, L), A === "year" && P.length > 1 && E === 0 && P.unshift({
            value: P[0].value - N
          });
        }
      }
      for (var E = 0; E < L.length; E++)
        P.push(L[E]);
      return L;
    }
  }
  for (var u = [], c = [], h = 0, f = 0, d = 0; d < o.length && a++ < i; ++d) {
    var p = Jp(o[d]);
    if (Q_t(o[d])) {
      l(o[d], u[u.length - 1] || [], c);
      var g = o[d + 1] ? Jp(o[d + 1]) : null;
      if (p !== g) {
        if (c.length) {
          f = h, c.sort(function(A, k) {
            return A.value - k.value;
          });
          for (var v = [], m = 0; m < c.length; ++m) {
            var y = c[m].value;
            (m === 0 || c[m - 1].value !== y) && (v.push(c[m]), y >= r[0] && y <= r[1] && h++);
          }
          var b = (r[1] - r[0]) / e;
          if (h > b * 1.5 && f > b / 1.5 || (u.push(v), h > b || n === o[d]))
            break;
        }
        c = [];
      }
    }
  }
  process.env.NODE_ENV !== "production" && a >= i && $n("Exceed safe limit.");
  for (var O = en(le(u, function(A) {
    return en(A, function(k) {
      return k.value >= r[0] && k.value <= r[1] && !k.notAdd;
    });
  }), function(A) {
    return A.length > 0;
  }), w = [], x = O.length - 1, d = 0; d < O.length; ++d)
    for (var S = O[d], _ = 0; _ < S.length; ++_)
      w.push({
        value: S[_].value,
        level: x - d
      });
  w.sort(function(A, k) {
    return A.value - k.value;
  });
  for (var C = [], d = 0; d < w.length; ++d)
    (d === 0 || w[d].value !== w[d - 1].value) && C.push(w[d]);
  return C;
}
Pu.registerClass(_ne);
const Cne = _ne;
var K6 = Pu.prototype, Qy = Kc.prototype, STt = qn, _Tt = Math.floor, CTt = Math.ceil, TO = Math.pow, Qa = Math.log, _N = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "log", t.base = 10, t._originalScale = new Kc(), t._interval = 0, t;
    }
    return e.prototype.getTicks = function(t) {
      var r = this._originalScale, i = this._extent, o = r.getExtent(), a = Qy.getTicks.call(this, t);
      return le(a, function(s) {
        var l = s.value, u = qn(TO(this.base, l));
        return u = l === i[0] && this._fixMin ? kO(u, o[0]) : u, u = l === i[1] && this._fixMax ? kO(u, o[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(t, r) {
      var i = Qa(this.base);
      t = Qa(Math.max(0, t)) / i, r = Qa(Math.max(0, r)) / i, Qy.setExtent.call(this, t, r);
    }, e.prototype.getExtent = function() {
      var t = this.base, r = K6.getExtent.call(this);
      r[0] = TO(t, r[0]), r[1] = TO(t, r[1]);
      var i = this._originalScale, o = i.getExtent();
      return this._fixMin && (r[0] = kO(r[0], o[0])), this._fixMax && (r[1] = kO(r[1], o[1])), r;
    }, e.prototype.unionExtent = function(t) {
      this._originalScale.unionExtent(t);
      var r = this.base;
      t[0] = Qa(t[0]) / Qa(r), t[1] = Qa(t[1]) / Qa(r), K6.unionExtent.call(this, t);
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.calcNiceTicks = function(t) {
      t = t || 10;
      var r = this._extent, i = r[1] - r[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var o = fxt(i), a = t / i * o;
        for (a <= 0.5 && (o *= 10); !isNaN(o) && Math.abs(o) < 1 && Math.abs(o) > 0; )
          o *= 10;
        var s = [qn(CTt(r[0] / o) * o), qn(_Tt(r[1] / o) * o)];
        this._interval = o, this._niceExtent = s;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      Qy.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
    }, e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return t = Qa(t) / Qa(this.base), zC(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return t = Qa(t) / Qa(this.base), FC(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = QC(t, this._extent), TO(this.base, t);
    }, e.type = "log", e;
  }(Pu)
), Ane = _N.prototype;
Ane.getMinorTicks = Qy.getMinorTicks;
Ane.getLabel = Qy.getLabel;
function kO(n, e) {
  return STt(n, rl(e));
}
Pu.registerClass(_N);
const ATt = _N;
var TTt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this._prepareParams(e, t, r);
    }
    return n.prototype._prepareParams = function(e, t, r) {
      r[1] < r[0] && (r = [NaN, NaN]), this._dataMin = r[0], this._dataMax = r[1];
      var i = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero();
      var o = this._modelMinRaw = t.get("min", !0);
      Le(o) ? this._modelMinNum = PO(e, o({
        min: r[0],
        max: r[1]
      })) : o !== "dataMin" && (this._modelMinNum = PO(e, o));
      var a = this._modelMaxRaw = t.get("max", !0);
      if (Le(a) ? this._modelMaxNum = PO(e, a({
        min: r[0],
        max: r[1]
      })) : a !== "dataMax" && (this._modelMaxNum = PO(e, a)), i)
        this._axisDataLen = t.getCategories().length;
      else {
        var s = t.get("boundaryGap"), l = se(s) ? s : [s || 0, s || 0];
        typeof l[0] == "boolean" || typeof l[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [gs(l[0], 1), gs(l[1], 1)];
      }
    }, n.prototype.calculate = function() {
      var e = this._isOrdinal, t = this._dataMin, r = this._dataMax, i = this._axisDataLen, o = this._boundaryGapInner, a = e ? null : r - t || Math.abs(t), s = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? r : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = e ? i ? 0 : NaN : t - o[0] * a), l == null && (l = e ? i ? i - 1 : NaN : r + o[1] * a), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var h = cd(s) || cd(l) || e && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var f = this._determinedMin, d = this._determinedMax;
      return f != null && (s = f, u = !0), d != null && (l = d, c = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: h
      };
    }, n.prototype.modifyDataMinMax = function(e, t) {
      process.env.NODE_ENV !== "production" && $e(!this.frozen), this[PTt[e]] = t;
    }, n.prototype.setDeterminedMinMax = function(e, t) {
      var r = kTt[e];
      process.env.NODE_ENV !== "production" && $e(!this.frozen && this[r] == null), this[r] = t;
    }, n.prototype.freeze = function() {
      this.frozen = !0;
    }, n;
  }()
), kTt = {
  min: "_determinedMin",
  max: "_determinedMax"
}, PTt = {
  min: "_dataMin",
  max: "_dataMax"
};
function Tne(n, e, t) {
  var r = n.rawExtentInfo;
  return r || (r = new TTt(n, e, t), n.rawExtentInfo = r, r);
}
function PO(n, e) {
  return e == null ? null : cd(e) ? NaN : n.parse(e);
}
function kne(n, e) {
  var t = n.type, r = Tne(n, e, n.getExtent()).calculate();
  n.setBlank(r.isBlank);
  var i = r.min, o = r.max, a = e.ecModel;
  if (a && t === "time") {
    var s = mne("bar", a), l = !1;
    if (I(s, function(h) {
      l = l || h.getBaseAxis() === e.axis;
    }), l) {
      var u = yne(s), c = ETt(i, o, e, u);
      i = c.min, o = c.max;
    }
  }
  return {
    extent: [i, o],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: r.minFixed,
    fixMax: r.maxFixed
  };
}
function ETt(n, e, t, r) {
  var i = t.axis.getExtent(), o = i[1] - i[0], a = dTt(r, t.axis);
  if (a === void 0)
    return {
      min: n,
      max: e
    };
  var s = 1 / 0;
  I(a, function(d) {
    s = Math.min(d.offset, s);
  });
  var l = -1 / 0;
  I(a, function(d) {
    l = Math.max(d.offset + d.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, c = e - n, h = 1 - (s + l) / o, f = c / h - c;
  return e += f * (l / u), n -= f * (s / u), {
    min: n,
    max: e
  };
}
function Kg(n, e) {
  var t = e, r = kne(n, t), i = r.extent, o = t.get("splitNumber");
  n instanceof ATt && (n.base = t.get("logBase"));
  var a = n.type, s = t.get("interval"), l = a === "interval" || a === "time";
  n.setExtent(i[0], i[1]), n.calcNiceExtent({
    splitNumber: o,
    fixMin: r.fixMin,
    fixMax: r.fixMax,
    minInterval: l ? t.get("minInterval") : null,
    maxInterval: l ? t.get("maxInterval") : null
  }), s != null && n.setInterval && n.setInterval(s);
}
function ZC(n, e) {
  if (e = e || n.get("type"), e)
    switch (e) {
      case "category":
        return new wN({
          ordinalMeta: n.getOrdinalMeta ? n.getOrdinalMeta() : n.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new Cne({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new (Pu.getClass(e) || Kc)();
    }
}
function MTt(n) {
  var e = n.scale.getExtent(), t = e[0], r = e[1];
  return !(t > 0 && r > 0 || t < 0 && r < 0);
}
function Gb(n) {
  var e = n.getLabelModel().get("formatter"), t = n.type === "category" ? n.scale.getExtent()[0] : null;
  return n.scale.type === "time" ? /* @__PURE__ */ function(r) {
    return function(i, o) {
      return n.scale.getFormattedLabel(i, o, r);
    };
  }(e) : we(e) ? /* @__PURE__ */ function(r) {
    return function(i) {
      var o = n.scale.getLabel(i), a = r.replace("{value}", o ?? "");
      return a;
    };
  }(e) : Le(e) ? /* @__PURE__ */ function(r) {
    return function(i, o) {
      return t != null && (o = i.value - t), r(CN(n, i), o, i.level != null ? {
        level: i.level
      } : null);
    };
  }(e) : function(r) {
    return n.scale.getLabel(r);
  };
}
function CN(n, e) {
  return n.type === "category" ? n.scale.getLabel(e) : e.value;
}
function DTt(n) {
  var e = n.model, t = n.scale;
  if (!(!e.get(["axisLabel", "show"]) || t.isBlank())) {
    var r, i, o = t.getExtent();
    t instanceof wN ? i = t.count() : (r = t.getTicks(), i = r.length);
    var a = n.getLabelModel(), s = Gb(n), l, u = 1;
    i > 40 && (u = Math.ceil(i / 40));
    for (var c = 0; c < i; c += u) {
      var h = r ? r[c] : {
        value: o[0] + c
      }, f = s(h, c), d = a.getTextRect(f), p = LTt(d, a.get("rotate") || 0);
      l ? l.union(p) : l = p;
    }
    return l;
  }
}
function LTt(n, e) {
  var t = e * Math.PI / 180, r = n.width, i = n.height, o = r * Math.abs(Math.cos(t)) + Math.abs(i * Math.sin(t)), a = r * Math.abs(Math.sin(t)) + Math.abs(i * Math.cos(t)), s = new ot(n.x, n.y, o, a);
  return s;
}
function AN(n) {
  var e = n.get("interval");
  return e ?? "auto";
}
function Pne(n) {
  return n.type === "category" && AN(n.getLabelModel()) === 0;
}
function LS(n, e) {
  var t = {};
  return I(n.mapDimensionsAll(e), function(r) {
    t[hne(n, r)] = !0;
  }), Ot(t);
}
function ITt(n, e, t) {
  e && I(LS(e, t), function(r) {
    var i = e.getApproximateExtent(r);
    i[0] < n[0] && (n[0] = i[0]), i[1] > n[1] && (n[1] = i[1]);
  });
}
var jb = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, n.prototype.getCoordSysModel = function() {
    }, n;
  }()
), RTt = 1e-8;
function J6(n, e) {
  return Math.abs(n - e) < RTt;
}
function af(n, e, t) {
  var r = 0, i = n[0];
  if (!i)
    return !1;
  for (var o = 1; o < n.length; o++) {
    var a = n[o];
    r += Ql(i[0], i[1], a[0], a[1], e, t), i = a;
  }
  var s = n[0];
  return (!J6(i[0], s[0]) || !J6(i[1], s[1])) && (r += Ql(i[0], i[1], s[0], s[1], e, t)), r !== 0;
}
var NTt = [];
function _T(n, e) {
  for (var t = 0; t < n.length; t++)
    vi(n[t], n[t], e);
}
function e8(n, e, t, r) {
  for (var i = 0; i < n.length; i++) {
    var o = n[i];
    r && (o = r.project(o)), o && isFinite(o[0]) && isFinite(o[1]) && (dc(e, e, o), pc(t, t, o));
  }
}
function $Tt(n) {
  for (var e = 0, t = 0, r = 0, i = n.length, o = n[i - 1][0], a = n[i - 1][1], s = 0; s < i; s++) {
    var l = n[s][0], u = n[s][1], c = o * u - l * a;
    e += c, t += (o + l) * c, r += (a + u) * c, o = l, a = u;
  }
  return e ? [t / e / 3, r / e / 3, e] : [n[0][0] || 0, n[0][1] || 0];
}
var Ene = (
  /** @class */
  function() {
    function n(e) {
      this.name = e;
    }
    return n.prototype.setCenter = function(e) {
      this._center = e;
    }, n.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, n;
  }()
), t8 = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e, t) {
      this.type = "polygon", this.exterior = e, this.interiors = t;
    }
    return n;
  }()
), n8 = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.type = "linestring", this.points = e;
    }
    return n;
  }()
), Mne = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this, t) || this;
      return o.type = "geoJSON", o.geometries = r, o._center = i && [i[0], i[1]], o;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this.geometries, r, i = 0, o = 0; o < t.length; o++) {
        var a = t[o], s = a.exterior, l = s && s.length;
        l > i && (r = a, i = l);
      }
      if (r)
        return $Tt(r.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, e.prototype.getBoundingRect = function(t) {
      var r = this._rect;
      if (r && !t)
        return r;
      var i = [1 / 0, 1 / 0], o = [-1 / 0, -1 / 0], a = this.geometries;
      return I(a, function(s) {
        s.type === "polygon" ? e8(s.exterior, i, o, t) : I(s.points, function(l) {
          e8(l, i, o, t);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(o[0]) && isFinite(o[1]) || (i[0] = i[1] = o[0] = o[1] = 0), r = new ot(i[0], i[1], o[0] - i[0], o[1] - i[1]), t || (this._rect = r), r;
    }, e.prototype.contain = function(t) {
      var r = this.getBoundingRect(), i = this.geometries;
      if (!r.contain(t[0], t[1]))
        return !1;
      e:
        for (var o = 0, a = i.length; o < a; o++) {
          var s = i[o];
          if (s.type === "polygon") {
            var l = s.exterior, u = s.interiors;
            if (af(l, t[0], t[1])) {
              for (var c = 0; c < (u ? u.length : 0); c++)
                if (af(u[c], t[0], t[1]))
                  continue e;
              return !0;
            }
          }
        }
      return !1;
    }, e.prototype.transformTo = function(t, r, i, o) {
      var a = this.getBoundingRect(), s = a.width / a.height;
      i ? o || (o = i / s) : i = s * o;
      for (var l = new ot(t, r, i, o), u = a.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
        var f = c[h];
        f.type === "polygon" ? (_T(f.exterior, u), I(f.interiors, function(d) {
          _T(d, u);
        })) : I(f.points, function(d) {
          _T(d, u);
        });
      }
      a = this._rect, a.copy(l), this._center = [a.x + a.width / 2, a.y + a.height / 2];
    }, e.prototype.cloneShallow = function(t) {
      t == null && (t = this.name);
      var r = new e(t, this.geometries, this._center);
      return r._rect = this._rect, r.transformTo = null, r;
    }, e;
  }(Ene)
), BTt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r) {
      var i = n.call(this, t) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = r, i;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this._elOnlyForCalculate, r = t.getBoundingRect(), i = [r.x + r.width / 2, r.y + r.height / 2], o = pC(NTt), a = t; a && !a.isGeoSVGGraphicRoot; )
        eu(o, a.getLocalTransform(), o), a = a.parent;
      return Ev(o, o), vi(i, i, o), i;
    }, e;
  }(Ene)
);
function VTt(n) {
  if (!n.UTF8Encoding)
    return n;
  var e = n, t = e.UTF8Scale;
  t == null && (t = 1024);
  var r = e.features;
  return I(r, function(i) {
    var o = i.geometry, a = o.encodeOffsets, s = o.coordinates;
    if (a)
      switch (o.type) {
        case "LineString":
          o.coordinates = Dne(s, a, t);
          break;
        case "Polygon":
          CT(s, a, t);
          break;
        case "MultiLineString":
          CT(s, a, t);
          break;
        case "MultiPolygon":
          I(s, function(l, u) {
            return CT(l, a[u], t);
          });
      }
  }), e.UTF8Encoding = !1, e;
}
function CT(n, e, t) {
  for (var r = 0; r < n.length; r++)
    n[r] = Dne(n[r], e[r], t);
}
function Dne(n, e, t) {
  for (var r = [], i = e[0], o = e[1], a = 0; a < n.length; a += 2) {
    var s = n.charCodeAt(a) - 64, l = n.charCodeAt(a + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += o, i = s, o = l, r.push([s / t, l / t]);
  }
  return r;
}
function zTt(n, e) {
  return n = VTt(n), le(en(n.features, function(t) {
    return t.geometry && t.properties && t.geometry.coordinates.length > 0;
  }), function(t) {
    var r = t.properties, i = t.geometry, o = [];
    switch (i.type) {
      case "Polygon":
        var a = i.coordinates;
        o.push(new t8(a[0], a.slice(1)));
        break;
      case "MultiPolygon":
        I(i.coordinates, function(l) {
          l[0] && o.push(new t8(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        o.push(new n8([i.coordinates]));
        break;
      case "MultiLineString":
        o.push(new n8(i.coordinates));
    }
    var s = new Mne(r[e || "name"], o, r.cp);
    return s.properties = r, s;
  });
}
var G0 = It();
function FTt(n) {
  return n.type === "category" ? ZTt(n) : GTt(n);
}
function QTt(n, e) {
  return n.type === "category" ? WTt(n, e) : {
    ticks: le(n.scale.getTicks(), function(t) {
      return t.value;
    })
  };
}
function ZTt(n) {
  var e = n.getLabelModel(), t = Lne(n, e);
  return !e.get("show") || n.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: t.labelCategoryInterval
  } : t;
}
function Lne(n, e) {
  var t = Ine(n, "labels"), r = AN(e), i = Rne(t, r);
  if (i)
    return i;
  var o, a;
  return Le(r) ? o = Bne(n, r) : (a = r === "auto" ? jTt(n) : r, o = $ne(n, a)), Nne(t, r, {
    labels: o,
    labelCategoryInterval: a
  });
}
function WTt(n, e) {
  var t = Ine(n, "ticks"), r = AN(e), i = Rne(t, r);
  if (i)
    return i;
  var o, a;
  if ((!e.get("show") || n.scale.isBlank()) && (o = []), Le(r))
    o = Bne(n, r, !0);
  else if (r === "auto") {
    var s = Lne(n, n.getLabelModel());
    a = s.labelCategoryInterval, o = le(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    a = r, o = $ne(n, a, !0);
  return Nne(t, r, {
    ticks: o,
    tickCategoryInterval: a
  });
}
function GTt(n) {
  var e = n.scale.getTicks(), t = Gb(n);
  return {
    labels: le(e, function(r, i) {
      return {
        level: r.level,
        formattedLabel: t(r, i),
        rawLabel: n.scale.getLabel(r),
        tickValue: r.value
      };
    })
  };
}
function Ine(n, e) {
  return G0(n)[e] || (G0(n)[e] = []);
}
function Rne(n, e) {
  for (var t = 0; t < n.length; t++)
    if (n[t].key === e)
      return n[t].value;
}
function Nne(n, e, t) {
  return n.push({
    key: e,
    value: t
  }), t;
}
function jTt(n) {
  var e = G0(n).autoInterval;
  return e ?? (G0(n).autoInterval = n.calculateCategoryInterval());
}
function HTt(n) {
  var e = qTt(n), t = Gb(n), r = (e.axisRotate - e.labelRotate) / 180 * Math.PI, i = n.scale, o = i.getExtent(), a = i.count();
  if (o[1] - o[0] < 1)
    return 0;
  var s = 1;
  a > 40 && (s = Math.max(1, Math.floor(a / 40)));
  for (var l = o[0], u = n.dataToCoord(l + 1) - n.dataToCoord(l), c = Math.abs(u * Math.cos(r)), h = Math.abs(u * Math.sin(r)), f = 0, d = 0; l <= o[1]; l += s) {
    var p = 0, g = 0, v = $b(t({
      value: l
    }), e.font, "center", "top");
    p = v.width * 1.3, g = v.height * 1.3, f = Math.max(f, p, 7), d = Math.max(d, g, 7);
  }
  var m = f / c, y = d / h;
  isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
  var b = Math.max(0, Math.floor(Math.min(m, y))), O = G0(n.model), w = n.getExtent(), x = O.lastAutoInterval, S = O.lastTickCount;
  return x != null && S != null && Math.abs(x - b) <= 1 && Math.abs(S - a) <= 1 && x > b && O.axisExtent0 === w[0] && O.axisExtent1 === w[1] ? b = x : (O.lastTickCount = a, O.lastAutoInterval = b, O.axisExtent0 = w[0], O.axisExtent1 = w[1]), b;
}
function qTt(n) {
  var e = n.getLabelModel();
  return {
    axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0,
    labelRotate: e.get("rotate") || 0,
    font: e.getFont()
  };
}
function $ne(n, e, t) {
  var r = Gb(n), i = n.scale, o = i.getExtent(), a = n.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), u = o[0], c = i.count();
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var h = Pne(n), f = a.get("showMinLabel") || h, d = a.get("showMaxLabel") || h;
  f && u !== o[0] && g(o[0]);
  for (var p = u; p <= o[1]; p += l)
    g(p);
  d && p - l !== o[1] && g(o[1]);
  function g(v) {
    var m = {
      value: v
    };
    s.push(t ? v : {
      formattedLabel: r(m),
      rawLabel: i.getLabel(m),
      tickValue: v
    });
  }
  return s;
}
function Bne(n, e, t) {
  var r = n.scale, i = Gb(n), o = [];
  return I(r.getTicks(), function(a) {
    var s = r.getLabel(a), l = a.value;
    e(a.value, s) && o.push(t ? l : {
      formattedLabel: i(a),
      rawLabel: s,
      tickValue: l
    });
  }), o;
}
var r8 = [0, 1], YTt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.onBand = !1, this.inverse = !1, this.dim = e, this.scale = t, this._extent = r || [0, 0];
    }
    return n.prototype.contain = function(e) {
      var t = this._extent, r = Math.min(t[0], t[1]), i = Math.max(t[0], t[1]);
      return e >= r && e <= i;
    }, n.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.getPixelPrecision = function(e) {
      return EJ(e || this.scale.getExtent(), this._extent);
    }, n.prototype.setExtent = function(e, t) {
      var r = this._extent;
      r[0] = e, r[1] = t;
    }, n.prototype.dataToCoord = function(e, t) {
      var r = this._extent, i = this.scale;
      return e = i.normalize(e), this.onBand && i.type === "ordinal" && (r = r.slice(), i8(r, i.count())), Yt(e, r8, r, t);
    }, n.prototype.coordToData = function(e, t) {
      var r = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (r = r.slice(), i8(r, i.count()));
      var o = Yt(e, r, r8, t);
      return this.scale.scale(o);
    }, n.prototype.pointToData = function(e, t) {
    }, n.prototype.getTicksCoords = function(e) {
      e = e || {};
      var t = e.tickModel || this.getTickModel(), r = QTt(this, t), i = r.ticks, o = le(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), a = t.get("alignWithLabel");
      return XTt(this, o, a, e.clamp), o;
    }, n.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var e = this.model.getModel("minorTick"), t = e.get("splitNumber");
      t > 0 && t < 100 || (t = 5);
      var r = this.scale.getMinorTicks(t), i = le(r, function(o) {
        return le(o, function(a) {
          return {
            coord: this.dataToCoord(a),
            tickValue: a
          };
        }, this);
      }, this);
      return i;
    }, n.prototype.getViewLabels = function() {
      return FTt(this).labels;
    }, n.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, n.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, n.prototype.getBandWidth = function() {
      var e = this._extent, t = this.scale.getExtent(), r = t[1] - t[0] + (this.onBand ? 1 : 0);
      r === 0 && (r = 1);
      var i = Math.abs(e[1] - e[0]);
      return Math.abs(i) / r;
    }, n.prototype.calculateCategoryInterval = function() {
      return HTt(this);
    }, n;
  }()
);
function i8(n, e) {
  var t = n[1] - n[0], r = e, i = t / r / 2;
  n[0] += i, n[1] -= i;
}
function XTt(n, e, t, r) {
  var i = e.length;
  if (!n.onBand || t || !i)
    return;
  var o = n.getExtent(), a, s;
  if (i === 1)
    e[0].coord = o[0], a = e[1] = {
      coord: o[1]
    };
  else {
    var l = e[i - 1].tickValue - e[0].tickValue, u = (e[i - 1].coord - e[0].coord) / l;
    I(e, function(d) {
      d.coord -= u / 2;
    });
    var c = n.scale.getExtent();
    s = 1 + c[1] - e[i - 1].tickValue, a = {
      coord: e[i - 1].coord + u * s
    }, e.push(a);
  }
  var h = o[0] > o[1];
  f(e[0].coord, o[0]) && (r ? e[0].coord = o[0] : e.shift()), r && f(o[0], e[0].coord) && e.unshift({
    coord: o[0]
  }), f(o[1], a.coord) && (r ? a.coord = o[1] : e.pop()), r && f(a.coord, o[1]) && e.push({
    coord: o[1]
  });
  function f(d, p) {
    return d = qn(d), p = qn(p), h ? d > p : d < p;
  }
}
const As = YTt;
var _m = Math.PI * 2, Fh = Al.CMD, UTt = ["top", "right", "bottom", "left"];
function KTt(n, e, t, r, i) {
  var o = t.width, a = t.height;
  switch (n) {
    case "top":
      r.set(t.x + o / 2, t.y - e), i.set(0, -1);
      break;
    case "bottom":
      r.set(t.x + o / 2, t.y + a + e), i.set(0, 1);
      break;
    case "left":
      r.set(t.x - e, t.y + a / 2), i.set(-1, 0);
      break;
    case "right":
      r.set(t.x + o + e, t.y + a / 2), i.set(1, 0);
      break;
  }
}
function JTt(n, e, t, r, i, o, a, s, l) {
  a -= n, s -= e;
  var u = Math.sqrt(a * a + s * s);
  a /= u, s /= u;
  var c = a * t + n, h = s * t + e;
  if (Math.abs(r - i) % _m < 1e-4)
    return l[0] = c, l[1] = h, u - t;
  if (o) {
    var f = r;
    r = jo(i), i = jo(f);
  } else
    r = jo(r), i = jo(i);
  r > i && (i += _m);
  var d = Math.atan2(s, a);
  if (d < 0 && (d += _m), d >= r && d <= i || d + _m >= r && d + _m <= i)
    return l[0] = c, l[1] = h, u - t;
  var p = t * Math.cos(r) + n, g = t * Math.sin(r) + e, v = t * Math.cos(i) + n, m = t * Math.sin(i) + e, y = (p - a) * (p - a) + (g - s) * (g - s), b = (v - a) * (v - a) + (m - s) * (m - s);
  return y < b ? (l[0] = p, l[1] = g, Math.sqrt(y)) : (l[0] = v, l[1] = m, Math.sqrt(b));
}
function IS(n, e, t, r, i, o, a, s) {
  var l = i - n, u = o - e, c = t - n, h = r - e, f = Math.sqrt(c * c + h * h);
  c /= f, h /= f;
  var d = l * c + u * h, p = d / f;
  s && (p = Math.min(Math.max(p, 0), 1)), p *= f;
  var g = a[0] = n + p * c, v = a[1] = e + p * h;
  return Math.sqrt((g - i) * (g - i) + (v - o) * (v - o));
}
function Vne(n, e, t, r, i, o, a) {
  t < 0 && (n = n + t, t = -t), r < 0 && (e = e + r, r = -r);
  var s = n + t, l = e + r, u = a[0] = Math.min(Math.max(i, n), s), c = a[1] = Math.min(Math.max(o, e), l);
  return Math.sqrt((u - i) * (u - i) + (c - o) * (c - o));
}
var Ya = [];
function ekt(n, e, t) {
  var r = Vne(e.x, e.y, e.width, e.height, n.x, n.y, Ya);
  return t.set(Ya[0], Ya[1]), r;
}
function tkt(n, e, t) {
  for (var r = 0, i = 0, o = 0, a = 0, s, l, u = 1 / 0, c = e.data, h = n.x, f = n.y, d = 0; d < c.length; ) {
    var p = c[d++];
    d === 1 && (r = c[d], i = c[d + 1], o = r, a = i);
    var g = u;
    switch (p) {
      case Fh.M:
        o = c[d++], a = c[d++], r = o, i = a;
        break;
      case Fh.L:
        g = IS(r, i, c[d], c[d + 1], h, f, Ya, !0), r = c[d++], i = c[d++];
        break;
      case Fh.C:
        g = hJ(r, i, c[d++], c[d++], c[d++], c[d++], c[d], c[d + 1], h, f, Ya), r = c[d++], i = c[d++];
        break;
      case Fh.Q:
        g = dJ(r, i, c[d++], c[d++], c[d], c[d + 1], h, f, Ya), r = c[d++], i = c[d++];
        break;
      case Fh.A:
        var v = c[d++], m = c[d++], y = c[d++], b = c[d++], O = c[d++], w = c[d++];
        d += 1;
        var x = !!(1 - c[d++]);
        s = Math.cos(O) * y + v, l = Math.sin(O) * b + m, d <= 1 && (o = s, a = l);
        var S = (h - v) * b / y + v;
        g = JTt(v, m, b, O, O + w, x, S, f, Ya), r = Math.cos(O + w) * y + v, i = Math.sin(O + w) * b + m;
        break;
      case Fh.R:
        o = r = c[d++], a = i = c[d++];
        var _ = c[d++], C = c[d++];
        g = Vne(o, a, _, C, h, f, Ya);
        break;
      case Fh.Z:
        g = IS(r, i, o, a, h, f, Ya, !0), r = o, i = a;
        break;
    }
    g < u && (u = g, t.set(Ya[0], Ya[1]));
  }
  return u;
}
var os = new nt(), pn = new nt(), Kn = new nt(), al = new nt(), Xs = new nt();
function o8(n, e) {
  if (n) {
    var t = n.getTextGuideLine(), r = n.getTextContent();
    if (r && t) {
      var i = n.textGuideLineConfig || {}, o = [[0, 0], [0, 0], [0, 0]], a = i.candidates || UTt, s = r.getBoundingRect().clone();
      s.applyTransform(r.getComputedTransform());
      var l = 1 / 0, u = i.anchor, c = n.getComputedTransform(), h = c && Ev([], c), f = e.get("length2") || 0;
      u && Kn.copy(u);
      for (var d = 0; d < a.length; d++) {
        var p = a[d];
        KTt(p, 0, s, os, al), nt.scaleAndAdd(pn, os, al, f), pn.transform(h);
        var g = n.getBoundingRect(), v = u ? u.distance(pn) : n instanceof gt ? tkt(pn, n.path, Kn) : ekt(pn, g, Kn);
        v < l && (l = v, pn.transform(c), Kn.transform(c), Kn.toArray(o[0]), pn.toArray(o[1]), os.toArray(o[2]));
      }
      zne(o, e.get("minTurnAngle")), t.setShape({
        points: o
      });
    }
  }
}
var RS = [], Hi = new nt();
function zne(n, e) {
  if (e <= 180 && e > 0) {
    e = e / 180 * Math.PI, os.fromArray(n[0]), pn.fromArray(n[1]), Kn.fromArray(n[2]), nt.sub(al, os, pn), nt.sub(Xs, Kn, pn);
    var t = al.len(), r = Xs.len();
    if (!(t < 1e-3 || r < 1e-3)) {
      al.scale(1 / t), Xs.scale(1 / r);
      var i = al.dot(Xs), o = Math.cos(e);
      if (o < i) {
        var a = IS(pn.x, pn.y, Kn.x, Kn.y, os.x, os.y, RS, !1);
        Hi.fromArray(RS), Hi.scaleAndAdd(Xs, a / Math.tan(Math.PI - e));
        var s = Kn.x !== pn.x ? (Hi.x - pn.x) / (Kn.x - pn.x) : (Hi.y - pn.y) / (Kn.y - pn.y);
        if (isNaN(s))
          return;
        s < 0 ? nt.copy(Hi, pn) : s > 1 && nt.copy(Hi, Kn), Hi.toArray(n[1]);
      }
    }
  }
}
function nkt(n, e, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, os.fromArray(n[0]), pn.fromArray(n[1]), Kn.fromArray(n[2]), nt.sub(al, pn, os), nt.sub(Xs, Kn, pn);
    var r = al.len(), i = Xs.len();
    if (!(r < 1e-3 || i < 1e-3)) {
      al.scale(1 / r), Xs.scale(1 / i);
      var o = al.dot(e), a = Math.cos(t);
      if (o < a) {
        var s = IS(pn.x, pn.y, Kn.x, Kn.y, os.x, os.y, RS, !1);
        Hi.fromArray(RS);
        var l = Math.PI / 2, u = Math.acos(Xs.dot(e)), c = l + u - t;
        if (c >= l)
          nt.copy(Hi, Kn);
        else {
          Hi.scaleAndAdd(Xs, s / Math.tan(Math.PI / 2 - c));
          var h = Kn.x !== pn.x ? (Hi.x - pn.x) / (Kn.x - pn.x) : (Hi.y - pn.y) / (Kn.y - pn.y);
          if (isNaN(h))
            return;
          h < 0 ? nt.copy(Hi, pn) : h > 1 && nt.copy(Hi, Kn);
        }
        Hi.toArray(n[1]);
      }
    }
  }
}
function AT(n, e, t, r) {
  var i = t === "normal", o = i ? n : n.ensureState(t);
  o.ignore = e;
  var a = r.get("smooth");
  a && a === !0 && (a = 0.3), o.shape = o.shape || {}, a > 0 && (o.shape.smooth = a);
  var s = r.getModel("lineStyle").getLineStyle();
  i ? n.useStyle(s) : o.style = s;
}
function rkt(n, e) {
  var t = e.smooth, r = e.points;
  if (r)
    if (n.moveTo(r[0][0], r[0][1]), t > 0 && r.length >= 3) {
      var i = fc(r[0], r[1]), o = fc(r[1], r[2]);
      if (!i || !o) {
        n.lineTo(r[1][0], r[1][1]), n.lineTo(r[2][0], r[2][1]);
        return;
      }
      var a = Math.min(i, o) * t, s = zw([], r[1], r[0], a / i), l = zw([], r[1], r[2], a / o), u = zw([], s, l, 0.5);
      n.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), n.bezierCurveTo(l[0], l[1], l[0], l[1], r[2][0], r[2][1]);
    } else
      for (var c = 1; c < r.length; c++)
        n.lineTo(r[c][0], r[c][1]);
}
function TN(n, e, t) {
  var r = n.getTextGuideLine(), i = n.getTextContent();
  if (!i) {
    r && n.removeTextGuideLine();
    return;
  }
  for (var o = e.normal, a = o.get("show"), s = i.ignore, l = 0; l < $0.length; l++) {
    var u = $0[l], c = e[u], h = u === "normal";
    if (c) {
      var f = c.get("show"), d = h ? s : qe(i.states[u] && i.states[u].ignore, s);
      if (d || !qe(f, a)) {
        var p = h ? r : r && r.states[u];
        p && (p.ignore = !0), r && AT(r, !0, u, c);
        continue;
      }
      r || (r = new io(), n.setTextGuideLine(r), !h && (s || !a) && AT(r, !0, "normal", e.normal), n.stateProxy && (r.stateProxy = n.stateProxy)), AT(r, !1, u, c);
    }
  }
  if (r) {
    Be(r.style, t), r.style.fill = null;
    var g = o.get("showAbove"), v = n.textGuideLineConfig = n.textGuideLineConfig || {};
    v.showAbove = g || !1, r.buildPath = rkt;
  }
}
function kN(n, e) {
  e = e || "labelLine";
  for (var t = {
    normal: n.getModel(e)
  }, r = 0; r < no.length; r++) {
    var i = no[r];
    t[i] = n.getModel([i, e]);
  }
  return t;
}
function Fne(n) {
  for (var e = [], t = 0; t < n.length; t++) {
    var r = n[t];
    if (!r.defaultAttr.ignore) {
      var i = r.label, o = i.getComputedTransform(), a = i.getBoundingRect(), s = !o || o[1] < 1e-5 && o[2] < 1e-5, l = i.style.margin || 0, u = a.clone();
      u.applyTransform(o), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
      var c = s ? new mS(a, o) : null;
      e.push({
        label: i,
        labelLine: r.labelLine,
        rect: u,
        localRect: a,
        obb: c,
        priority: r.priority,
        defaultAttr: r.defaultAttr,
        layoutOption: r.computedLayoutOption,
        axisAligned: s,
        transform: o
      });
    }
  }
  return e;
}
function Qne(n, e, t, r, i, o) {
  var a = n.length;
  if (a < 2)
    return;
  n.sort(function(_, C) {
    return _.rect[e] - C.rect[e];
  });
  for (var s = 0, l, u = !1, c = 0, h = 0; h < a; h++) {
    var f = n[h], d = f.rect;
    l = d[e] - s, l < 0 && (d[e] -= l, f.label[e] -= l, u = !0);
    var p = Math.max(-l, 0);
    c += p, s = d[e] + d[t];
  }
  c > 0 && o && w(-c / a, 0, a);
  var g = n[0], v = n[a - 1], m, y;
  b(), m < 0 && x(-m, 0.8), y < 0 && x(y, 0.8), b(), O(m, y, 1), O(y, m, -1), b(), m < 0 && S(-m), y < 0 && S(y);
  function b() {
    m = g.rect[e] - r, y = i - v.rect[e] - v.rect[t];
  }
  function O(_, C, A) {
    if (_ < 0) {
      var k = Math.min(C, -_);
      if (k > 0) {
        w(k * A, 0, a);
        var P = k + _;
        P < 0 && x(-P * A, 1);
      } else
        x(-_ * A, 1);
    }
  }
  function w(_, C, A) {
    _ !== 0 && (u = !0);
    for (var k = C; k < A; k++) {
      var P = n[k], L = P.rect;
      L[e] += _, P.label[e] += _;
    }
  }
  function x(_, C) {
    for (var A = [], k = 0, P = 1; P < a; P++) {
      var L = n[P - 1].rect, D = Math.max(n[P].rect[e] - L[e] - L[t], 0);
      A.push(D), k += D;
    }
    if (k) {
      var E = Math.min(Math.abs(_) / k, C);
      if (_ > 0)
        for (var P = 0; P < a - 1; P++) {
          var M = A[P] * E;
          w(M, 0, P + 1);
        }
      else
        for (var P = a - 1; P > 0; P--) {
          var M = A[P - 1] * E;
          w(-M, P, a);
        }
    }
  }
  function S(_) {
    var C = _ < 0 ? -1 : 1;
    _ = Math.abs(_);
    for (var A = Math.ceil(_ / (a - 1)), k = 0; k < a - 1; k++)
      if (C > 0 ? w(A, 0, k + 1) : w(-A, a - k - 1, a), _ -= A, _ <= 0)
        return;
  }
  return u;
}
function ikt(n, e, t, r) {
  return Qne(n, "x", "width", e, t, r);
}
function Zne(n, e, t, r) {
  return Qne(n, "y", "height", e, t, r);
}
function Wne(n) {
  var e = [];
  n.sort(function(g, v) {
    return v.priority - g.priority;
  });
  var t = new ot(0, 0, 0, 0);
  function r(g) {
    if (!g.ignore) {
      var v = g.ensureState("emphasis");
      v.ignore == null && (v.ignore = !1);
    }
    g.ignore = !0;
  }
  for (var i = 0; i < n.length; i++) {
    var o = n[i], a = o.axisAligned, s = o.localRect, l = o.transform, u = o.label, c = o.labelLine;
    t.copy(o.rect), t.width -= 0.1, t.height -= 0.1, t.x += 0.05, t.y += 0.05;
    for (var h = o.obb, f = !1, d = 0; d < e.length; d++) {
      var p = e[d];
      if (t.intersect(p.rect)) {
        if (a && p.axisAligned) {
          f = !0;
          break;
        }
        if (p.obb || (p.obb = new mS(p.localRect, p.transform)), h || (h = new mS(s, l)), h.intersect(p.obb)) {
          f = !0;
          break;
        }
      }
    }
    f ? (r(u), c && r(c)) : (u.attr("ignore", o.defaultAttr.ignore), c && c.attr("ignore", o.defaultAttr.labelGuideIgnore), e.push(o));
  }
}
function okt(n) {
  if (n) {
    for (var e = [], t = 0; t < n.length; t++)
      e.push(n[t].slice());
    return e;
  }
}
function akt(n, e) {
  var t = n.label, r = e && e.getTextGuideLine();
  return {
    dataIndex: n.dataIndex,
    dataType: n.dataType,
    seriesIndex: n.seriesModel.seriesIndex,
    text: n.label.style.text,
    rect: n.hostRect,
    labelRect: n.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: t.style.align,
    verticalAlign: t.style.verticalAlign,
    labelLinePoints: okt(r && r.shape.points)
  };
}
var a8 = ["align", "verticalAlign", "width", "height", "fontSize"], Fi = new Yl(), TT = It(), skt = It();
function EO(n, e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    e[i] != null && (n[i] = e[i]);
  }
}
var MO = ["x", "y", "rotation"], lkt = (
  /** @class */
  function() {
    function n() {
      this._labelList = [], this._chartViewList = [];
    }
    return n.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, n.prototype._addLabel = function(e, t, r, i, o) {
      var a = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      ot.applyTransform(c, c, u), u ? Fi.setLocalTransform(u) : (Fi.x = Fi.y = Fi.rotation = Fi.originX = Fi.originY = 0, Fi.scaleX = Fi.scaleY = 1), Fi.rotation = jo(Fi.rotation);
      var h = i.__hostTarget, f;
      if (h) {
        f = h.getBoundingRect().plain();
        var d = h.getComputedTransform();
        ot.applyTransform(f, f, d);
      }
      var p = f && h.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: r,
        dataIndex: e,
        dataType: t,
        layoutOption: o,
        computedLayoutOption: null,
        rect: c,
        hostRect: f,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: f ? f.width * f.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: Fi.x,
          y: Fi.y,
          scaleX: Fi.scaleX,
          scaleY: Fi.scaleY,
          rotation: Fi.rotation,
          style: {
            x: a.x,
            y: a.y,
            align: a.align,
            verticalAlign: a.verticalAlign,
            width: a.width,
            height: a.height,
            fontSize: a.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, n.prototype.addLabelsOfSeries = function(e) {
      var t = this;
      this._chartViewList.push(e);
      var r = e.__model, i = r.get("labelLayout");
      (Le(i) || Ot(i).length) && e.group.traverse(function(o) {
        if (o.ignore)
          return !0;
        var a = o.getTextContent(), s = He(o);
        a && !a.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, r, a, i);
      });
    }, n.prototype.updateLayoutConfig = function(e) {
      var t = e.getWidth(), r = e.getHeight();
      function i(b, O) {
        return function() {
          o8(b, O);
        };
      }
      for (var o = 0; o < this._labelList.length; o++) {
        var a = this._labelList[o], s = a.label, l = s.__hostTarget, u = a.defaultAttr, c = void 0;
        Le(a.layoutOption) ? c = a.layoutOption(akt(a, l)) : c = a.layoutOption, c = c || {}, a.computedLayoutOption = c;
        var h = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: c.x != null || c.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: c.rotate != null ? c.rotate * h : u.attachedRot,
          offset: [c.dx || 0, c.dy || 0]
        });
        var f = !1;
        if (c.x != null ? (s.x = be(c.x, t), s.setStyle("x", 0), f = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = be(c.y, r), s.setStyle("y", 0), f = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: c.labelLinePoints
          }), f = !1);
        }
        var p = TT(s);
        p.needsUpdateLabelLine = f, s.rotation = c.rotate != null ? c.rotate * h : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < a8.length; g++) {
          var v = a8[g];
          s.setStyle(v, c[v] != null ? c[v] : u.style[v]);
        }
        if (c.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var m = a.seriesModel;
            if (a.dataIndex != null) {
              var y = a.seriesModel.getData(a.dataType);
              m = y.getItemModel(a.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, n.prototype.layout = function(e) {
      var t = e.getWidth(), r = e.getHeight(), i = Fne(this._labelList), o = en(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), a = en(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      ikt(o, 0, t), Zne(a, 0, r);
      var s = en(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      Wne(s);
    }, n.prototype.processLabelsOverall = function() {
      var e = this;
      I(this._chartViewList, function(t) {
        var r = t.__model, i = t.ignoreLabelLineUpdate, o = r.isAnimationEnabled();
        t.group.traverse(function(a) {
          if (a.ignore && !a.forceLabelAnimation)
            return !0;
          var s = !i, l = a.getTextContent();
          !s && l && (s = TT(l).needsUpdateLabelLine), s && e._updateLabelLine(a, r), o && e._animateLabels(a, r);
        });
      });
    }, n.prototype._updateLabelLine = function(e, t) {
      var r = e.getTextContent(), i = He(e), o = i.dataIndex;
      if (r && o != null) {
        var a = t.getData(i.dataType), s = a.getItemModel(o), l = {}, u = a.getItemVisual(o, "style");
        if (u) {
          var c = a.getVisual("drawType");
          l.stroke = u[c];
        }
        var h = s.getModel("labelLine");
        TN(e, kN(s), l), o8(e, h);
      }
    }, n.prototype._animateLabels = function(e, t) {
      var r = e.getTextContent(), i = e.getTextGuideLine();
      if (r && (e.forceLabelAnimation || !r.ignore && !r.invisible && !e.disableLabelAnimation && !Up(e))) {
        var o = TT(r), a = o.oldLayout, s = He(e), l = s.dataIndex, u = {
          x: r.x,
          y: r.y,
          rotation: r.rotation
        }, c = t.getData(s.dataType);
        if (a) {
          r.attr(a);
          var f = e.prevStates;
          f && (ct(f, "select") >= 0 && r.attr(o.oldLayoutSelect), ct(f, "emphasis") >= 0 && r.attr(o.oldLayoutEmphasis)), Vt(r, u, t, l);
        } else if (r.attr(u), !Rv(r).valueAnimation) {
          var h = qe(r.style.opacity, 1);
          r.style.opacity = 0, Cn(r, {
            style: {
              opacity: h
            }
          }, t, l);
        }
        if (o.oldLayout = u, r.states.select) {
          var d = o.oldLayoutSelect = {};
          EO(d, u, MO), EO(d, r.states.select, MO);
        }
        if (r.states.emphasis) {
          var p = o.oldLayoutEmphasis = {};
          EO(p, u, MO), EO(p, r.states.emphasis, MO);
        }
        Iee(r, l, c, t, t);
      }
      if (i && !i.ignore && !i.invisible) {
        var o = skt(i), a = o.oldLayout, g = {
          points: i.shape.points
        };
        a ? (i.attr({
          shape: a
        }), Vt(i, {
          shape: g
        }, t)) : (i.setShape(g), i.style.strokePercent = 0, Cn(i, {
          style: {
            strokePercent: 1
          }
        }, t)), o.oldLayout = g;
      }
    }, n;
  }()
), kT = It();
function ukt(n) {
  n.registerUpdateLifecycle("series:beforeupdate", function(e, t, r) {
    var i = kT(t).labelManager;
    i || (i = kT(t).labelManager = new lkt()), i.clearLabels();
  }), n.registerUpdateLifecycle("series:layoutlabels", function(e, t, r) {
    var i = kT(t).labelManager;
    r.updatedSeries.forEach(function(o) {
      i.addLabelsOfSeries(t.getViewOfSeriesModel(o));
    }), i.updateLayoutConfig(t), i.layout(t), i.processLabelsOverall();
  });
}
var PT = Math.sin, ET = Math.cos, Gne = Math.PI, Qh = Math.PI * 2, ckt = 180 / Gne, jne = function() {
  function n() {
  }
  return n.prototype.reset = function(e) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, e || 4);
  }, n.prototype.moveTo = function(e, t) {
    this._add("M", e, t);
  }, n.prototype.lineTo = function(e, t) {
    this._add("L", e, t);
  }, n.prototype.bezierCurveTo = function(e, t, r, i, o, a) {
    this._add("C", e, t, r, i, o, a);
  }, n.prototype.quadraticCurveTo = function(e, t, r, i) {
    this._add("Q", e, t, r, i);
  }, n.prototype.arc = function(e, t, r, i, o, a) {
    this.ellipse(e, t, r, r, 0, i, o, a);
  }, n.prototype.ellipse = function(e, t, r, i, o, a, s, l) {
    var u = s - a, c = !l, h = Math.abs(u), f = mc(h - Qh) || (c ? u >= Qh : -u >= Qh), d = u > 0 ? u % Qh : u % Qh + Qh, p = !1;
    f ? p = !0 : mc(h) ? p = !1 : p = d >= Gne == !!c;
    var g = e + r * ET(a), v = t + i * PT(a);
    this._start && this._add("M", g, v);
    var m = Math.round(o * ckt);
    if (f) {
      var y = 1 / this._p, b = (c ? 1 : -1) * (Qh - y);
      this._add("A", r, i, m, 1, +c, e + r * ET(a + b), t + i * PT(a + b)), y > 0.01 && this._add("A", r, i, m, 0, +c, g, v);
    } else {
      var O = e + r * ET(s), w = t + i * PT(s);
      this._add("A", r, i, m, +p, +c, O, w);
    }
  }, n.prototype.rect = function(e, t, r, i) {
    this._add("M", e, t), this._add("l", r, 0), this._add("l", 0, i), this._add("l", -r, 0), this._add("Z");
  }, n.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, n.prototype._add = function(e, t, r, i, o, a, s, l, u) {
    for (var c = [], h = this._p, f = 1; f < arguments.length; f++) {
      var d = arguments[f];
      if (isNaN(d)) {
        this._invalid = !0;
        return;
      }
      c.push(Math.round(d * h) / h);
    }
    this._d.push(e + c.join(" ")), this._start = e === "Z";
  }, n.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, n.prototype.getStr = function() {
    return this._str;
  }, n;
}(), Zy = "none", hkt = Math.round;
function fkt(n) {
  var e = n.fill;
  return e != null && e !== Zy;
}
function dkt(n) {
  var e = n.stroke;
  return e != null && e !== Zy;
}
var hD = ["lineCap", "miterLimit", "lineJoin"], pkt = le(hD, function(n) {
  return "stroke-" + n.toLowerCase();
});
function gkt(n, e, t, r) {
  var i = e.opacity == null ? 1 : e.opacity;
  if (t instanceof Si) {
    n("opacity", i);
    return;
  }
  if (fkt(e)) {
    var o = I0(e.fill);
    n("fill", o.color);
    var a = e.fillOpacity != null ? e.fillOpacity * o.opacity * i : o.opacity * i;
    (r || a < 1) && n("fill-opacity", a);
  } else
    n("fill", Zy);
  if (dkt(e)) {
    var s = I0(e.stroke);
    n("stroke", s.color);
    var l = e.strokeNoScale ? t.getLineScale() : 1, u = l ? (e.lineWidth || 0) / l : 0, c = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * i : s.opacity * i, h = e.strokeFirst;
    if ((r || u !== 1) && n("stroke-width", u), (r || h) && n("paint-order", h ? "stroke" : "fill"), (r || c < 1) && n("stroke-opacity", c), e.lineDash) {
      var f = gN(t), d = f[0], p = f[1];
      d && (p = hkt(p || 0), n("stroke-dasharray", d.join(",")), (p || r) && n("stroke-dashoffset", p));
    } else
      r && n("stroke-dasharray", Zy);
    for (var g = 0; g < hD.length; g++) {
      var v = hD[g];
      if (r || e[v] !== gS[v]) {
        var m = e[v] || gS[v];
        m && n(pkt[g], m);
      }
    }
  } else
    r && n("stroke", Zy);
}
var Hne = "http://www.w3.org/2000/svg", qne = "http://www.w3.org/1999/xlink", vkt = "http://www.w3.org/2000/xmlns/", mkt = "http://www.w3.org/XML/1998/namespace", s8 = "ecmeta_";
function Yne(n) {
  return document.createElementNS(Hne, n);
}
function Vr(n, e, t, r, i) {
  return {
    tag: n,
    attrs: t || {},
    children: r,
    text: i,
    key: e
  };
}
function ykt(n, e) {
  var t = [];
  if (e)
    for (var r in e) {
      var i = e[r], o = r;
      i !== !1 && (i !== !0 && i != null && (o += '="' + i + '"'), t.push(o));
    }
  return "<" + n + " " + t.join(" ") + ">";
}
function bkt(n) {
  return "</" + n + ">";
}
function PN(n, e) {
  e = e || {};
  var t = e.newline ? `
` : "";
  function r(i) {
    var o = i.children, a = i.tag, s = i.attrs, l = i.text;
    return ykt(a, s) + (a !== "style" ? mo(l) : l || "") + (o ? "" + t + le(o, function(u) {
      return r(u);
    }).join(t) + t : "") + bkt(a);
  }
  return r(n);
}
function Okt(n, e, t) {
  t = t || {};
  var r = t.newline ? `
` : "", i = " {" + r, o = r + "}", a = le(Ot(n), function(l) {
    return l + i + le(Ot(n[l]), function(u) {
      return u + ":" + n[l][u] + ";";
    }).join(r) + o;
  }).join(r), s = le(Ot(e), function(l) {
    return "@keyframes " + l + i + le(Ot(e[l]), function(u) {
      return u + i + le(Ot(e[l][u]), function(c) {
        var h = e[l][u][c];
        return c === "d" && (h = 'path("' + h + '")'), c + ":" + h + ";";
      }).join(r) + o;
    }).join(r) + o;
  }).join(r);
  return !a && !s ? "" : ["<![CDATA[", a, s, "]]>"].join(r);
}
function fD(n) {
  return {
    zrId: n,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function l8(n, e, t, r) {
  return Vr("svg", "root", {
    width: n,
    height: e,
    xmlns: Hne,
    "xmlns:xlink": qne,
    version: "1.1",
    baseProfile: "full",
    viewBox: r ? "0 0 " + n + " " + e : !1
  }, t);
}
var wkt = 0;
function Xne() {
  return wkt++;
}
var u8 = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, qh = "transform-origin";
function xkt(n, e, t) {
  var r = re({}, n.shape);
  re(r, e), n.buildPath(t, r);
  var i = new jne();
  return i.reset(OJ(n)), t.rebuildPath(i, 1), i.generateStr(), i.getStr();
}
function Skt(n, e) {
  var t = e.originX, r = e.originY;
  (t || r) && (n[qh] = t + "px " + r + "px");
}
var _kt = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function Une(n, e) {
  var t = e.zrId + "-ani-" + e.cssAnimIdx++;
  return e.cssAnims[t] = n, t;
}
function Ckt(n, e, t) {
  var r = n.shape.paths, i = {}, o, a;
  if (I(r, function(l) {
    var u = fD(t.zrId);
    u.animation = !0, WC(l, {}, u, !0);
    var c = u.cssAnims, h = u.cssNodes, f = Ot(c), d = f.length;
    if (d) {
      a = f[d - 1];
      var p = c[a];
      for (var g in p) {
        var v = p[g];
        i[g] = i[g] || { d: "" }, i[g].d += v.d || "";
      }
      for (var m in h) {
        var y = h[m].animation;
        y.indexOf(a) >= 0 && (o = y);
      }
    }
  }), !!o) {
    e.d = !1;
    var s = Une(i, t);
    return o.replace(a, s);
  }
}
function c8(n) {
  return we(n) ? u8[n] ? "cubic-bezier(" + u8[n] + ")" : kR(n) ? n : "" : "";
}
function WC(n, e, t, r) {
  var i = n.animators, o = i.length, a = [];
  if (n instanceof jR) {
    var s = Ckt(n, e, t);
    if (s)
      a.push(s);
    else if (!o)
      return;
  } else if (!o)
    return;
  for (var l = {}, u = 0; u < o; u++) {
    var c = i[u], h = [c.getMaxTime() / 1e3 + "s"], f = c8(c.getClip().easing), d = c.getDelay();
    f ? h.push(f) : h.push("linear"), d && h.push(d / 1e3 + "s"), c.getLoop() && h.push("infinite");
    var p = h.join(" ");
    l[p] = l[p] || [p, []], l[p][1].push(c);
  }
  function g(y) {
    var b = y[1], O = b.length, w = {}, x = {}, S = {}, _ = "animation-timing-function";
    function C(ne, ye, te) {
      for (var ue = ne.getTracks(), xe = ne.getMaxTime(), dt = 0; dt < ue.length; dt++) {
        var Ue = ue[dt];
        if (Ue.needsAnimate()) {
          var Rt = Ue.keyframes, zt = Ue.propName;
          if (te && (zt = te(zt)), zt)
            for (var tn = 0; tn < Rt.length; tn++) {
              var jn = Rt[tn], An = Math.round(jn.time / xe * 100) + "%", Tn = c8(jn.easing), Un = jn.rawValue;
              (we(Un) || $t(Un)) && (ye[An] = ye[An] || {}, ye[An][zt] = jn.rawValue, Tn && (ye[An][_] = Tn));
            }
        }
      }
    }
    for (var A = 0; A < O; A++) {
      var k = b[A], P = k.targetName;
      P ? P === "shape" && C(k, x) : !r && C(k, w);
    }
    for (var L in w) {
      var D = {};
      CJ(D, n), re(D, w[L]);
      var E = wJ(D), M = w[L][_];
      S[L] = E ? {
        transform: E
      } : {}, Skt(S[L], D), M && (S[L][_] = M);
    }
    var R, N = !0;
    for (var L in x) {
      S[L] = S[L] || {};
      var $ = !R, M = x[L][_];
      $ && (R = new Al());
      var F = R.len();
      R.reset(), S[L].d = xkt(n, x[L], R);
      var W = R.len();
      if (!$ && F !== W) {
        N = !1;
        break;
      }
      M && (S[L][_] = M);
    }
    if (!N)
      for (var L in S)
        delete S[L].d;
    if (!r)
      for (var A = 0; A < O; A++) {
        var k = b[A], P = k.targetName;
        P === "style" && C(k, S, function(ue) {
          return _kt[ue];
        });
      }
    for (var j = Ot(S), Y = !0, X, A = 1; A < j.length; A++) {
      var ie = j[A - 1], ae = j[A];
      if (S[ie][qh] !== S[ae][qh]) {
        Y = !1;
        break;
      }
      X = S[ie][qh];
    }
    if (Y && X) {
      for (var L in S)
        S[L][qh] && delete S[L][qh];
      e[qh] = X;
    }
    if (en(j, function(ne) {
      return Ot(S[ne]).length > 0;
    }).length) {
      var ee = Une(S, t);
      return ee + " " + y[0] + " both";
    }
  }
  for (var v in l) {
    var s = g(l[v]);
    s && a.push(s);
  }
  if (a.length) {
    var m = t.zrId + "-cls-" + Xne();
    t.cssNodes["." + m] = {
      animation: a.join(",")
    }, e.class = m;
  }
}
function Akt(n, e, t) {
  if (!n.ignore)
    if (n.isSilent()) {
      var r = {
        "pointer-events": "none"
      };
      h8(r, e, t, !0);
    } else {
      var i = n.states.emphasis && n.states.emphasis.style ? n.states.emphasis.style : {}, o = i.fill;
      if (!o) {
        var a = n.style && n.style.fill, s = n.states.select && n.states.select.style && n.states.select.style.fill, l = n.currentStates.indexOf("select") >= 0 && s || a;
        l && (o = xM(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && n.transform ? n.transform[0] : 1;
        u = u / c;
      }
      var r = {
        cursor: "pointer"
      };
      o && (r.fill = o), i.stroke && (r.stroke = i.stroke), u && (r["stroke-width"] = u), h8(r, e, t, !0);
    }
}
function h8(n, e, t, r) {
  var i = JSON.stringify(n), o = t.cssStyleCache[i];
  o || (o = t.zrId + "-cls-" + Xne(), t.cssStyleCache[i] = o, t.cssNodes["." + o + (r ? ":hover" : "")] = n), e.class = e.class ? e.class + " " + o : o;
}
var j0 = Math.round;
function Kne(n) {
  return n && we(n.src);
}
function Jne(n) {
  return n && Le(n.toDataURL);
}
function EN(n, e, t, r) {
  gkt(function(i, o) {
    var a = i === "fill" || i === "stroke";
    a && bJ(o) ? tre(e, n, i, r) : a && PR(o) ? nre(t, n, i, r) : a && o === "none" ? n[i] = "transparent" : n[i] = o;
  }, e, t, !1), Lkt(t, n, r);
}
function MN(n, e) {
  var t = axt(e);
  t && (t.each(function(r, i) {
    r != null && (n[(s8 + i).toLowerCase()] = r + "");
  }), e.isSilent() && (n[s8 + "silent"] = "true"));
}
function f8(n) {
  return mc(n[0] - 1) && mc(n[1]) && mc(n[2]) && mc(n[3] - 1);
}
function Tkt(n) {
  return mc(n[4]) && mc(n[5]);
}
function DN(n, e, t) {
  if (e && !(Tkt(e) && f8(e))) {
    var r = t ? 10 : 1e4;
    n.transform = f8(e) ? "translate(" + j0(e[4] * r) / r + " " + j0(e[5] * r) / r + ")" : kwt(e);
  }
}
function d8(n, e, t) {
  for (var r = n.points, i = [], o = 0; o < r.length; o++)
    i.push(j0(r[o][0] * t) / t), i.push(j0(r[o][1] * t) / t);
  e.points = i.join(" ");
}
function p8(n) {
  return !n.smooth;
}
function kkt(n) {
  var e = le(n, function(t) {
    return typeof t == "string" ? [t, t] : t;
  });
  return function(t, r, i) {
    for (var o = 0; o < e.length; o++) {
      var a = e[o], s = t[a[0]];
      s != null && (r[a[1]] = j0(s * i) / i);
    }
  };
}
var Pkt = {
  circle: [kkt(["cx", "cy", "r"])],
  polyline: [d8, p8],
  polygon: [d8, p8]
};
function Ekt(n) {
  for (var e = n.animators, t = 0; t < e.length; t++)
    if (e[t].targetName === "shape")
      return !0;
  return !1;
}
function ere(n, e) {
  var t = n.style, r = n.shape, i = Pkt[n.type], o = {}, a = e.animation, s = "path", l = n.style.strokePercent, u = e.compress && OJ(n) || 4;
  if (i && !e.willUpdate && !(i[1] && !i[1](r)) && !(a && Ekt(n)) && !(l < 1)) {
    s = n.type;
    var c = Math.pow(10, u);
    i[0](r, o, c);
  } else {
    var h = !n.path || n.shapeChanged();
    n.path || n.createPathProxy();
    var f = n.path;
    h && (f.beginPath(), n.buildPath(f, n.shape), n.pathUpdated());
    var d = f.getVersion(), p = n, g = p.__svgPathBuilder;
    (p.__svgPathVersion !== d || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new jne()), g.reset(u), f.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), o.d = g.getStr();
  }
  return DN(o, n.transform), EN(o, t, n, e), MN(o, n), e.animation && WC(n, o, e), e.emphasis && Akt(n, o, e), Vr(s, n.id + "", o);
}
function Mkt(n, e) {
  var t = n.style, r = t.image;
  if (r && !we(r) && (Kne(r) ? r = r.src : Jne(r) && (r = r.toDataURL())), !!r) {
    var i = t.x || 0, o = t.y || 0, a = t.width, s = t.height, l = {
      href: r,
      width: a,
      height: s
    };
    return i && (l.x = i), o && (l.y = o), DN(l, n.transform), EN(l, t, n, e), MN(l, n), e.animation && WC(n, l, e), Vr("image", n.id + "", l);
  }
}
function Dkt(n, e) {
  var t = n.style, r = t.text;
  if (r != null && (r += ""), !(!r || isNaN(t.x) || isNaN(t.y))) {
    var i = t.font || Gc, o = t.x || 0, a = Ewt(t.y || 0, vC(i), t.textBaseline), s = Pwt[t.textAlign] || t.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (tee(t)) {
      var u = "", c = t.fontStyle, h = eee(t.fontSize);
      if (!parseFloat(h))
        return;
      var f = t.fontFamily || qK, d = t.fontWeight;
      u += "font-size:" + h + ";font-family:" + f + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
    } else
      l.style = "font: " + i;
    return r.match(/\s/) && (l["xml:space"] = "preserve"), o && (l.x = o), a && (l.y = a), DN(l, n.transform), EN(l, t, n, e), MN(l, n), e.animation && WC(n, l, e), Vr("text", n.id + "", l, void 0, r);
  }
}
function g8(n, e) {
  if (n instanceof gt)
    return ere(n, e);
  if (n instanceof Si)
    return Mkt(n, e);
  if (n instanceof N0)
    return Dkt(n, e);
}
function Lkt(n, e, t) {
  var r = n.style;
  if (Mwt(r)) {
    var i = Dwt(n), o = t.shadowCache, a = o[i];
    if (!a) {
      var s = n.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var c = r.shadowOffsetX || 0, h = r.shadowOffsetY || 0, f = r.shadowBlur, d = I0(r.shadowColor), p = d.opacity, g = d.color, v = f / 2 / l, m = f / 2 / u, y = v + " " + m;
      a = t.zrId + "-s" + t.shadowIdx++, t.defs[a] = Vr("filter", a, {
        id: a,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        Vr("feDropShadow", "", {
          dx: c / l,
          dy: h / u,
          stdDeviation: y,
          "flood-color": g,
          "flood-opacity": p
        })
      ]), o[i] = a;
    }
    e.filter = gC(a);
  }
}
function tre(n, e, t, r) {
  var i = n[t], o, a = {
    gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (mJ(i))
    o = "linearGradient", a.x1 = i.x, a.y1 = i.y, a.x2 = i.x2, a.y2 = i.y2;
  else if (yJ(i))
    o = "radialGradient", a.cx = qe(i.x, 0.5), a.cy = qe(i.y, 0.5), a.r = qe(i.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && ls("Illegal gradient type.");
    return;
  }
  for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var h = SM(s[u].offset) * 100 + "%", f = s[u].color, d = I0(f), p = d.color, g = d.opacity, v = {
      offset: h
    };
    v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(Vr("stop", u + "", v));
  }
  var m = Vr(o, "", a, l), y = PN(m), b = r.gradientCache, O = b[y];
  O || (O = r.zrId + "-g" + r.gradientIdx++, b[y] = O, a.id = O, r.defs[O] = Vr(o, O, a, l)), e[t] = gC(O);
}
function nre(n, e, t, r) {
  var i = n.style[t], o = n.getBoundingRect(), a = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", h;
  if (vJ(i)) {
    var f = i.imageWidth, d = i.imageHeight, p = void 0, g = i.image;
    if (we(g) ? p = g : Kne(g) ? p = g.src : Jne(g) && (p = g.toDataURL()), typeof Image > "u") {
      var v = "Image width/height must been given explictly in svg-ssr renderer.";
      $e(f, v), $e(d, v);
    } else if (f == null || d == null) {
      var m = function(A, k) {
        if (A) {
          var P = A.elm, L = f || k.width, D = d || k.height;
          A.tag === "pattern" && (u ? (D = 1, L /= o.width) : c && (L = 1, D /= o.height)), A.attrs.width = L, A.attrs.height = D, P && (P.setAttribute("width", L), P.setAttribute("height", D));
        }
      }, y = NR(p, null, n, function(A) {
        l || m(x, A), m(h, A);
      });
      y && y.width && y.height && (f = f || y.width, d = d || y.height);
    }
    h = Vr("image", "img", {
      href: p,
      width: f,
      height: d
    }), a.width = f, a.height = d;
  } else
    i.svgElement && (h = Fe(i.svgElement), a.width = i.svgWidth, a.height = i.svgHeight);
  if (h) {
    var b, O;
    l ? b = O = 1 : u ? (O = 1, b = a.width / o.width) : c ? (b = 1, O = a.height / o.height) : a.patternUnits = "userSpaceOnUse", b != null && !isNaN(b) && (a.width = b), O != null && !isNaN(O) && (a.height = O);
    var w = wJ(i);
    w && (a.patternTransform = w);
    var x = Vr("pattern", "", a, [h]), S = PN(x), _ = r.patternCache, C = _[S];
    C || (C = r.zrId + "-p" + r.patternIdx++, _[S] = C, a.id = C, x = r.defs[C] = Vr("pattern", C, a, [h])), e[t] = gC(C);
  }
}
function Ikt(n, e, t) {
  var r = t.clipPathCache, i = t.defs, o = r[n.id];
  if (!o) {
    o = t.zrId + "-c" + t.clipPathIdx++;
    var a = {
      id: o
    };
    r[n.id] = o, i[o] = Vr("clipPath", o, a, [ere(n, t)]);
  }
  e["clip-path"] = gC(o);
}
function v8(n) {
  return document.createTextNode(n);
}
function sf(n, e, t) {
  n.insertBefore(e, t);
}
function m8(n, e) {
  n.removeChild(e);
}
function y8(n, e) {
  n.appendChild(e);
}
function rre(n) {
  return n.parentNode;
}
function ire(n) {
  return n.nextSibling;
}
function MT(n, e) {
  n.textContent = e;
}
var b8 = 58, Rkt = 120, Nkt = Vr("", "");
function dD(n) {
  return n === void 0;
}
function Vs(n) {
  return n !== void 0;
}
function $kt(n, e, t) {
  for (var r = {}, i = e; i <= t; ++i) {
    var o = n[i].key;
    o !== void 0 && (process.env.NODE_ENV !== "production" && r[o] != null && console.error("Duplicate key " + o), r[o] = i);
  }
  return r;
}
function ty(n, e) {
  var t = n.key === e.key, r = n.tag === e.tag;
  return r && t;
}
function H0(n) {
  var e, t = n.children, r = n.tag;
  if (Vs(r)) {
    var i = n.elm = Yne(r);
    if (LN(Nkt, n), se(t))
      for (e = 0; e < t.length; ++e) {
        var o = t[e];
        o != null && y8(i, H0(o));
      }
    else
      Vs(n.text) && !Ne(n.text) && y8(i, v8(n.text));
  } else
    n.elm = v8(n.text);
  return n.elm;
}
function ore(n, e, t, r, i) {
  for (; r <= i; ++r) {
    var o = t[r];
    o != null && sf(n, H0(o), e);
  }
}
function NS(n, e, t, r) {
  for (; t <= r; ++t) {
    var i = e[t];
    if (i != null)
      if (Vs(i.tag)) {
        var o = rre(i.elm);
        m8(o, i.elm);
      } else
        m8(n, i.elm);
  }
}
function LN(n, e) {
  var t, r = e.elm, i = n && n.attrs || {}, o = e.attrs || {};
  if (i !== o) {
    for (t in o) {
      var a = o[t], s = i[t];
      s !== a && (a === !0 ? r.setAttribute(t, "") : a === !1 ? r.removeAttribute(t) : t === "style" ? r.style.cssText = a : t.charCodeAt(0) !== Rkt ? r.setAttribute(t, a) : t === "xmlns:xlink" || t === "xmlns" ? r.setAttributeNS(vkt, t, a) : t.charCodeAt(3) === b8 ? r.setAttributeNS(mkt, t, a) : t.charCodeAt(5) === b8 ? r.setAttributeNS(qne, t, a) : r.setAttribute(t, a));
    }
    for (t in i)
      t in o || r.removeAttribute(t);
  }
}
function Bkt(n, e, t) {
  for (var r = 0, i = 0, o = e.length - 1, a = e[0], s = e[o], l = t.length - 1, u = t[0], c = t[l], h, f, d, p; r <= o && i <= l; )
    a == null ? a = e[++r] : s == null ? s = e[--o] : u == null ? u = t[++i] : c == null ? c = t[--l] : ty(a, u) ? (Cp(a, u), a = e[++r], u = t[++i]) : ty(s, c) ? (Cp(s, c), s = e[--o], c = t[--l]) : ty(a, c) ? (Cp(a, c), sf(n, a.elm, ire(s.elm)), a = e[++r], c = t[--l]) : ty(s, u) ? (Cp(s, u), sf(n, s.elm, a.elm), s = e[--o], u = t[++i]) : (dD(h) && (h = $kt(e, r, o)), f = h[u.key], dD(f) ? sf(n, H0(u), a.elm) : (d = e[f], d.tag !== u.tag ? sf(n, H0(u), a.elm) : (Cp(d, u), e[f] = void 0, sf(n, d.elm, a.elm))), u = t[++i]);
  (r <= o || i <= l) && (r > o ? (p = t[l + 1] == null ? null : t[l + 1].elm, ore(n, p, t, i, l)) : NS(n, e, r, o));
}
function Cp(n, e) {
  var t = e.elm = n.elm, r = n.children, i = e.children;
  n !== e && (LN(n, e), dD(e.text) ? Vs(r) && Vs(i) ? r !== i && Bkt(t, r, i) : Vs(i) ? (Vs(n.text) && MT(t, ""), ore(t, null, i, 0, i.length - 1)) : Vs(r) ? NS(t, r, 0, r.length - 1) : Vs(n.text) && MT(t, "") : n.text !== e.text && (Vs(r) && NS(t, r, 0, r.length - 1), MT(t, e.text)));
}
function Vkt(n, e) {
  if (ty(n, e))
    Cp(n, e);
  else {
    var t = n.elm, r = rre(t);
    H0(e), r !== null && (sf(r, e.elm, ire(t)), NS(r, [n], 0, 0));
  }
  return e;
}
var zkt = 0, Fkt = function() {
  function n(e, t, r) {
    if (this.type = "svg", this.refreshHover = O8("refreshHover"), this.configLayer = O8("configLayer"), this.storage = t, this._opts = r = re({}, r), this.root = e, this._id = "zr" + zkt++, this._oldVNode = l8(r.width, r.height), e && !r.ssr) {
      var i = this._viewport = document.createElement("div");
      i.style.cssText = "position:relative;overflow:hidden";
      var o = this._svgDom = this._oldVNode.elm = Yne("svg");
      LN(null, this._oldVNode), i.appendChild(o), e.appendChild(i);
    }
    this.resize(r.width, r.height);
  }
  return n.prototype.getType = function() {
    return this.type;
  }, n.prototype.getViewportRoot = function() {
    return this._viewport;
  }, n.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, n.prototype.getSvgDom = function() {
    return this._svgDom;
  }, n.prototype.refresh = function() {
    if (this.root) {
      var e = this.renderToVNode({
        willUpdate: !0
      });
      e.attrs.style = "position:absolute;left:0;top:0;user-select:none", Vkt(this._oldVNode, e), this._oldVNode = e;
    }
  }, n.prototype.renderOneToVNode = function(e) {
    return g8(e, fD(this._id));
  }, n.prototype.renderToVNode = function(e) {
    e = e || {};
    var t = this.storage.getDisplayList(!0), r = this._width, i = this._height, o = fD(this._id);
    o.animation = e.animation, o.willUpdate = e.willUpdate, o.compress = e.compress, o.emphasis = e.emphasis;
    var a = [], s = this._bgVNode = Qkt(r, i, this._backgroundColor, o);
    s && a.push(s);
    var l = e.compress ? null : this._mainVNode = Vr("g", "main", {}, []);
    this._paintList(t, o, l ? l.children : a), l && a.push(l);
    var u = le(Ot(o.defs), function(f) {
      return o.defs[f];
    });
    if (u.length && a.push(Vr("defs", "defs", {}, u)), e.animation) {
      var c = Okt(o.cssNodes, o.cssAnims, { newline: !0 });
      if (c) {
        var h = Vr("style", "stl", {}, [], c);
        a.push(h);
      }
    }
    return l8(r, i, a, e.useViewBox);
  }, n.prototype.renderToString = function(e) {
    return e = e || {}, PN(this.renderToVNode({
      animation: qe(e.cssAnimation, !0),
      emphasis: qe(e.cssEmphasis, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: qe(e.useViewBox, !0)
    }), { newline: !0 });
  }, n.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e;
  }, n.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, n.prototype._paintList = function(e, t, r) {
    for (var i = e.length, o = [], a = 0, s, l, u = 0, c = 0; c < i; c++) {
      var h = e[c];
      if (!h.invisible) {
        var f = h.__clipPaths, d = f && f.length || 0, p = l && l.length || 0, g = void 0;
        for (g = Math.max(d - 1, p - 1); g >= 0 && !(f && l && f[g] === l[g]); g--)
          ;
        for (var v = p - 1; v > g; v--)
          a--, s = o[a - 1];
        for (var m = g + 1; m < d; m++) {
          var y = {};
          Ikt(f[m], y, t);
          var b = Vr("g", "clip-g-" + u++, y, []);
          (s ? s.children : r).push(b), o[a++] = b, s = b;
        }
        l = f;
        var O = g8(h, t);
        O && (s ? s.children : r).push(O);
      }
    }
  }, n.prototype.resize = function(e, t) {
    var r = this._opts, i = this.root, o = this._viewport;
    if (e != null && (r.width = e), t != null && (r.height = t), i && o && (o.style.display = "none", e = Lp(i, 0, r), t = Lp(i, 1, r), o.style.display = ""), this._width !== e || this._height !== t) {
      if (this._width = e, this._height = t, o) {
        var a = o.style;
        a.width = e + "px", a.height = t + "px";
      }
      if (PR(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", e), s.setAttribute("height", t));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", e), l.setAttribute("height", t));
      }
    }
  }, n.prototype.getWidth = function() {
    return this._width;
  }, n.prototype.getHeight = function() {
    return this._height;
  }, n.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, n.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, n.prototype.toDataURL = function(e) {
    var t = this.renderToString(), r = "data:image/svg+xml;";
    return e ? (t = Iwt(t), t && r + "base64," + t) : r + "charset=UTF-8," + encodeURIComponent(t);
  }, n;
}();
function O8(n) {
  return function() {
    process.env.NODE_ENV !== "production" && ls('In SVG mode painter not support method "' + n + '"');
  };
}
function Qkt(n, e, t, r) {
  var i;
  if (t && t !== "none")
    if (i = Vr("rect", "bg", {
      width: n,
      height: e,
      x: "0",
      y: "0"
    }), bJ(t))
      tre({ fill: t }, i.attrs, "fill", r);
    else if (PR(t))
      nre({
        style: {
          fill: t
        },
        dirty: nr,
        getBoundingRect: function() {
          return { width: n, height: e };
        }
      }, i.attrs, "fill", r);
    else {
      var o = I0(t), a = o.color, s = o.opacity;
      i.attrs.fill = a, s < 1 && (i.attrs["fill-opacity"] = s);
    }
  return i;
}
const Zkt = Fkt;
function Wkt(n) {
  n.registerPainter("svg", Zkt);
}
function w8(n, e, t) {
  var r = jc.createCanvas(), i = e.getWidth(), o = e.getHeight(), a = r.style;
  return a && (a.position = "absolute", a.left = "0", a.top = "0", a.width = i + "px", a.height = o + "px", r.setAttribute("data-zr-dom-id", n)), r.width = i * t, r.height = o * t, r;
}
var Gkt = function(n) {
  H(e, n);
  function e(t, r, i) {
    var o = n.call(this) || this;
    o.motionBlur = !1, o.lastFrameAlpha = 0.7, o.dpr = 1, o.virtual = !1, o.config = {}, o.incremental = !1, o.zlevel = 0, o.maxRepaintRectCount = 5, o.__dirty = !0, o.__firstTimePaint = !0, o.__used = !1, o.__drawIndex = 0, o.__startIndex = 0, o.__endIndex = 0, o.__prevStartIndex = null, o.__prevEndIndex = null;
    var a;
    i = i || dS, typeof t == "string" ? a = w8(t, r, i) : Ne(t) && (a = t, t = a.id), o.id = t, o.dom = a;
    var s = a.style;
    return s && (tJ(a), a.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), o.painter = r, o.dpr = i, o;
  }
  return e.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, e.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, e.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, e.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, e.prototype.createBackBuffer = function() {
    var t = this.dpr;
    this.domBack = w8("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
  }, e.prototype.createRepaintRects = function(t, r, i, o) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var a = [], s = this.maxRepaintRectCount, l = !1, u = new ot(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (a.length === 0) {
          var b = new ot(0, 0, 0, 0);
          b.copy(y), a.push(b);
        } else {
          for (var O = !1, w = 1 / 0, x = 0, S = 0; S < a.length; ++S) {
            var _ = a[S];
            if (_.intersect(y)) {
              var C = new ot(0, 0, 0, 0);
              C.copy(_), C.union(y), a[S] = C, O = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(_);
              var A = y.width * y.height, k = _.width * _.height, P = u.width * u.height, L = P - A - k;
              L < w && (w = L, x = S);
            }
          }
          if (l && (a[x].union(y), O = !0), !O) {
            var b = new ot(0, 0, 0, 0);
            b.copy(y), a.push(b);
          }
          l || (l = a.length >= s);
        }
    }
    for (var h = this.__startIndex; h < this.__endIndex; ++h) {
      var f = t[h];
      if (f) {
        var d = f.shouldBePainted(i, o, !0, !0), p = f.__isRendered && (f.__dirty & Zo || !d) ? f.getPrevPaintRect() : null;
        p && c(p);
        var g = d && (f.__dirty & Zo || !f.__isRendered) ? f.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
      var f = r[h], d = f && f.shouldBePainted(i, o, !0, !0);
      if (f && (!d || !f.__zr) && f.__isRendered) {
        var p = f.getPrevPaintRect();
        p && c(p);
      }
    }
    var v;
    do {
      v = !1;
      for (var h = 0; h < a.length; ) {
        if (a[h].isZero()) {
          a.splice(h, 1);
          continue;
        }
        for (var m = h + 1; m < a.length; )
          a[h].intersect(a[m]) ? (v = !0, a[h].union(a[m]), a.splice(m, 1)) : m++;
        h++;
      }
    } while (v);
    return this._paintRects = a, a;
  }, e.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, e.prototype.resize = function(t, r) {
    var i = this.dpr, o = this.dom, a = o.style, s = this.domBack;
    a && (a.width = t + "px", a.height = r + "px"), o.width = t * i, o.height = r * i, s && (s.width = t * i, s.height = r * i, i !== 1 && this.ctxBack.scale(i, i));
  }, e.prototype.clear = function(t, r, i) {
    var o = this.dom, a = this.ctx, s = o.width, l = o.height;
    r = r || this.clearColor;
    var u = this.motionBlur && !t, c = this.lastFrameAlpha, h = this.dpr, f = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(o, 0, 0, s / h, l / h));
    var d = this.domBack;
    function p(g, v, m, y) {
      if (a.clearRect(g, v, m, y), r && r !== "transparent") {
        var b = void 0;
        if (fC(r)) {
          var O = r.global || r.__width === m && r.__height === y;
          b = O && r.__canvasGradient || rD(a, r, {
            x: 0,
            y: 0,
            width: m,
            height: y
          }), r.__canvasGradient = b, r.__width = m, r.__height = y;
        } else
          VOt(r) && (r.scaleX = r.scaleX || h, r.scaleY = r.scaleY || h, b = iD(a, r, {
            dirty: function() {
              f.setUnpainted(), f.painter.refresh();
            }
          }));
        a.save(), a.fillStyle = b || r, a.fillRect(g, v, m, y), a.restore();
      }
      u && (a.save(), a.globalAlpha = c, a.drawImage(d, g, v, m, y), a.restore());
    }
    !i || u ? p(0, 0, s, l) : i.length && I(i, function(g) {
      p(g.x * h, g.y * h, g.width * h, g.height * h);
    });
  }, e;
}(Ba);
const DT = Gkt;
var x8 = 1e5, Zh = 314159, DO = 0.01, jkt = 1e-3;
function Hkt(n) {
  return n ? n.__builtin__ ? !0 : !(typeof n.resize != "function" || typeof n.refresh != "function") : !1;
}
function qkt(n, e) {
  var t = document.createElement("div");
  return t.style.cssText = [
    "position:relative",
    "width:" + n + "px",
    "height:" + e + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", t;
}
var Ykt = function() {
  function n(e, t, r, i) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var o = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
    this._opts = r = re({}, r || {}), this.dpr = r.devicePixelRatio || dS, this._singleCanvas = o, this.root = e;
    var a = e.style;
    a && (tJ(e), e.innerHTML = ""), this.storage = t;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (o) {
      var c = e, h = c.width, f = c.height;
      r.width != null && (h = r.width), r.height != null && (f = r.height), this.dpr = r.devicePixelRatio || 1, c.width = h * this.dpr, c.height = f * this.dpr, this._width = h, this._height = f;
      var d = new DT(c, this, this.dpr);
      d.__builtin__ = !0, d.initContext(), l[Zh] = d, d.zlevel = Zh, s.push(Zh), this._domRoot = e;
    } else {
      this._width = Lp(e, 0, r), this._height = Lp(e, 1, r);
      var u = this._domRoot = qkt(this._width, this._height);
      e.appendChild(u);
    }
  }
  return n.prototype.getType = function() {
    return "canvas";
  }, n.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, n.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, n.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, n.prototype.refresh = function(e) {
    var t = this.storage.getDisplayList(!0), r = this._prevDisplayList, i = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(t, r, e, this._redrawId);
    for (var o = 0; o < i.length; o++) {
      var a = i[o], s = this._layers[a];
      if (!s.__builtin__ && s.refresh) {
        var l = o === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this;
  }, n.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, n.prototype._paintHoverList = function(e) {
    var t = e.length, r = this._hoverlayer;
    if (r && r.clear(), !!t) {
      for (var i = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, o, a = 0; a < t; a++) {
        var s = e[a];
        s.__inHover && (r || (r = this._hoverlayer = this.getLayer(x8)), o || (o = r.ctx, o.save()), Af(o, s, i, a === t - 1));
      }
      o && o.restore();
    }
  }, n.prototype.getHoverLayer = function() {
    return this.getLayer(x8);
  }, n.prototype.paintOne = function(e, t) {
    Fte(e, t);
  }, n.prototype._paintList = function(e, t, r, i) {
    if (this._redrawId === i) {
      r = r || !1, this._updateLayerStatus(e);
      var o = this._doPaintList(e, t, r), a = o.finished, s = o.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), a)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        mM(function() {
          l._paintList(e, t, r, i);
        });
      }
    }
  }, n.prototype._compositeManually = function() {
    var e = this.getLayer(Zh).ctx, t = this._domRoot.width, r = this._domRoot.height;
    e.clearRect(0, 0, t, r), this.eachBuiltinLayer(function(i) {
      i.virtual && e.drawImage(i.dom, 0, 0, t, r);
    });
  }, n.prototype._doPaintList = function(e, t, r) {
    for (var i = this, o = [], a = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || r) && o.push(u);
    }
    for (var c = !0, h = !1, f = function(g) {
      var v = o[g], m = v.ctx, y = a && v.createRepaintRects(e, t, d._width, d._height), b = r ? v.__startIndex : v.__drawIndex, O = !r && v.incremental && Date.now, w = O && Date.now(), x = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
      if (v.__startIndex === v.__endIndex)
        v.clear(!1, x, y);
      else if (b === v.__startIndex) {
        var S = e[b];
        (!S.incremental || !S.notClear || r) && v.clear(!1, x, y);
      }
      b === -1 && (console.error("For some unknown reason. drawIndex is -1"), b = v.__startIndex);
      var _, C = function(L) {
        var D = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: i._width,
          viewHeight: i._height
        };
        for (_ = b; _ < v.__endIndex; _++) {
          var E = e[_];
          if (E.__inHover && (h = !0), i._doPaintEl(E, v, a, L, D, _ === v.__endIndex - 1), O) {
            var M = Date.now() - w;
            if (M > 15)
              break;
          }
        }
        D.prevElClipPaths && m.restore();
      };
      if (y)
        if (y.length === 0)
          _ = v.__endIndex;
        else
          for (var A = d.dpr, k = 0; k < y.length; ++k) {
            var P = y[k];
            m.save(), m.beginPath(), m.rect(P.x * A, P.y * A, P.width * A, P.height * A), m.clip(), C(P), m.restore();
          }
      else
        m.save(), C(), m.restore();
      v.__drawIndex = _, v.__drawIndex < v.__endIndex && (c = !1);
    }, d = this, p = 0; p < o.length; p++)
      f(p);
    return mt.wxa && I(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: h
    };
  }, n.prototype._doPaintEl = function(e, t, r, i, o, a) {
    var s = t.ctx;
    if (r) {
      var l = e.getPaintRect();
      (!i || l && l.intersect(i)) && (Af(s, e, o, a), e.setPrevPaintRect(l));
    } else
      Af(s, e, o, a);
  }, n.prototype.getLayer = function(e, t) {
    this._singleCanvas && !this._needsManuallyCompositing && (e = Zh);
    var r = this._layers[e];
    return r || (r = new DT("zr_" + e, this, this.dpr), r.zlevel = e, r.__builtin__ = !0, this._layerConfig[e] ? it(r, this._layerConfig[e], !0) : this._layerConfig[e - DO] && it(r, this._layerConfig[e - DO], !0), t && (r.virtual = t), this.insertLayer(e, r), r.initContext()), r;
  }, n.prototype.insertLayer = function(e, t) {
    var r = this._layers, i = this._zlevelList, o = i.length, a = this._domRoot, s = null, l = -1;
    if (r[e]) {
      process.env.NODE_ENV !== "production" && ls("ZLevel " + e + " has been used already");
      return;
    }
    if (!Hkt(t)) {
      process.env.NODE_ENV !== "production" && ls("Layer of zlevel " + e + " is not valid");
      return;
    }
    if (o > 0 && e > i[0]) {
      for (l = 0; l < o - 1 && !(i[l] < e && i[l + 1] > e); l++)
        ;
      s = r[i[l]];
    }
    if (i.splice(l + 1, 0, e), r[e] = t, !t.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? a.insertBefore(t.dom, u.nextSibling) : a.appendChild(t.dom);
      } else
        a.firstChild ? a.insertBefore(t.dom, a.firstChild) : a.appendChild(t.dom);
    t.painter || (t.painter = this);
  }, n.prototype.eachLayer = function(e, t) {
    for (var r = this._zlevelList, i = 0; i < r.length; i++) {
      var o = r[i];
      e.call(t, this._layers[o], o);
    }
  }, n.prototype.eachBuiltinLayer = function(e, t) {
    for (var r = this._zlevelList, i = 0; i < r.length; i++) {
      var o = r[i], a = this._layers[o];
      a.__builtin__ && e.call(t, a, o);
    }
  }, n.prototype.eachOtherLayer = function(e, t) {
    for (var r = this._zlevelList, i = 0; i < r.length; i++) {
      var o = r[i], a = this._layers[o];
      a.__builtin__ || e.call(t, a, o);
    }
  }, n.prototype.getLayers = function() {
    return this._layers;
  }, n.prototype._updateLayerStatus = function(e) {
    this.eachBuiltinLayer(function(h, f) {
      h.__dirty = h.__used = !1;
    });
    function t(h) {
      o && (o.__endIndex !== h && (o.__dirty = !0), o.__endIndex = h);
    }
    if (this._singleCanvas)
      for (var r = 1; r < e.length; r++) {
        var i = e[r];
        if (i.zlevel !== e[r - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var o = null, a = 0, s, l;
    for (l = 0; l < e.length; l++) {
      var i = e[l], u = i.zlevel, c = void 0;
      s !== u && (s = u, a = 0), i.incremental ? (c = this.getLayer(u + jkt, this._needsManuallyCompositing), c.incremental = !0, a = 1) : c = this.getLayer(u + (a > 0 ? DO : 0), this._needsManuallyCompositing), c.__builtin__ || ls("ZLevel " + u + " has been used by unkown layer " + c.id), c !== o && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, t(l), o = c), i.__dirty & Zo && !i.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    t(l), this.eachBuiltinLayer(function(h, f) {
      !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
    });
  }, n.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, n.prototype._clearLayer = function(e) {
    e.clear();
  }, n.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e, I(this._layers, function(t) {
      t.setUnpainted();
    });
  }, n.prototype.configLayer = function(e, t) {
    if (t) {
      var r = this._layerConfig;
      r[e] ? it(r[e], t, !0) : r[e] = t;
      for (var i = 0; i < this._zlevelList.length; i++) {
        var o = this._zlevelList[i];
        if (o === e || o === e + DO) {
          var a = this._layers[o];
          it(a, r[e], !0);
        }
      }
    }
  }, n.prototype.delLayer = function(e) {
    var t = this._layers, r = this._zlevelList, i = t[e];
    i && (i.dom.parentNode.removeChild(i.dom), delete t[e], r.splice(ct(r, e), 1));
  }, n.prototype.resize = function(e, t) {
    if (this._domRoot.style) {
      var r = this._domRoot;
      r.style.display = "none";
      var i = this._opts, o = this.root;
      if (e != null && (i.width = e), t != null && (i.height = t), e = Lp(o, 0, i), t = Lp(o, 1, i), r.style.display = "", this._width !== e || t !== this._height) {
        r.style.width = e + "px", r.style.height = t + "px";
        for (var a in this._layers)
          this._layers.hasOwnProperty(a) && this._layers[a].resize(e, t);
        this.refresh(!0);
      }
      this._width = e, this._height = t;
    } else {
      if (e == null || t == null)
        return;
      this._width = e, this._height = t, this.getLayer(Zh).resize(e, t);
    }
    return this;
  }, n.prototype.clearLayer = function(e) {
    var t = this._layers[e];
    t && t.clear();
  }, n.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, n.prototype.getRenderedCanvas = function(e) {
    if (e = e || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Zh].dom;
    var t = new DT("image", this, e.pixelRatio || this.dpr);
    t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor);
    var r = t.ctx;
    if (e.pixelRatio <= this.dpr) {
      this.refresh();
      var i = t.dom.width, o = t.dom.height;
      this.eachLayer(function(h) {
        h.__builtin__ ? r.drawImage(h.dom, 0, 0, i, o) : h.renderToCanvas && (r.save(), h.renderToCanvas(r), r.restore());
      });
    } else
      for (var a = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        Af(r, c, a, l === u - 1);
      }
    return t.dom;
  }, n.prototype.getWidth = function() {
    return this._width;
  }, n.prototype.getHeight = function() {
    return this._height;
  }, n;
}();
const Xkt = Ykt;
function Ukt(n) {
  n.registerPainter("canvas", Xkt);
}
var Kkt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var r = t.coordinateSystem;
        if (r !== "polar" && r !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return ku(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getLegendIcon = function(t) {
      var r = new We(), i = vr("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1);
      r.add(i), i.setStyle(t.lineStyle);
      var o = this.getData().getVisual("symbol"), a = this.getData().getVisual("symbolRotate"), s = o === "none" ? "circle" : o, l = t.itemHeight * 0.8, u = vr(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
      r.add(u), u.setStyle(t.itemStyle);
      var c = t.iconRotate === "inherit" ? a : t.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), r;
    }, e.type = "series.line", e.dependencies = ["grid", "polar"], e.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, e;
  }(Ln)
);
const Jkt = Kkt;
function Jg(n, e) {
  var t = n.mapDimensionsAll("defaultedLabel"), r = t.length;
  if (r === 1) {
    var i = Xg(n, e, t[0]);
    return i != null ? i + "" : null;
  } else if (r) {
    for (var o = [], a = 0; a < t.length; a++)
      o.push(Xg(n, e, t[a]));
    return o.join(" ");
  }
}
function are(n, e) {
  var t = n.mapDimensionsAll("defaultedLabel");
  if (!se(e))
    return e + "";
  for (var r = [], i = 0; i < t.length; i++) {
    var o = n.getDimensionIndex(t[i]);
    o >= 0 && r.push(e[o]);
  }
  return r.join(" ");
}
var Hb = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i, o) {
      var a = n.call(this) || this;
      return a.updateData(t, r, i, o), a;
    }
    return e.prototype._createSymbol = function(t, r, i, o, a) {
      this.removeAll();
      var s = vr(t, -1, -1, 2, 2, null, a);
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: o[0] / 2,
        scaleY: o[1] / 2
      }), s.drift = ePt, this._symbolType = t, this.add(s);
    }, e.prototype.stopSymbolAnimation = function(t) {
      this.childAt(0).stopAnimation(null, t);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      gu(this.childAt(0));
    }, e.prototype.downplay = function() {
      vu(this.childAt(0));
    }, e.prototype.setZ = function(t, r) {
      var i = this.childAt(0);
      i.zlevel = t, i.z = r;
    }, e.prototype.setDraggable = function(t, r) {
      var i = this.childAt(0);
      i.draggable = t, i.cursor = !r && t ? "move" : i.cursor;
    }, e.prototype.updateData = function(t, r, i, o) {
      this.silent = !1;
      var a = t.getItemVisual(r, "symbol") || "circle", s = t.hostModel, l = e.getSymbolSize(t, r), u = a !== this._symbolType, c = o && o.disableAnimation;
      if (u) {
        var h = t.getItemVisual(r, "symbolKeepAspect");
        this._createSymbol(a, t, r, l, h);
      } else {
        var f = this.childAt(0);
        f.silent = !1;
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? f.attr(d) : Vt(f, d, s, r), ms(f);
      }
      if (this._updateCommon(t, r, l, i, o), u) {
        var f = this.childAt(0);
        if (!c) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: f.style.opacity
            }
          };
          f.scaleX = f.scaleY = 0, f.style.opacity = 0, Cn(f, d, s, r);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(t, r, i, o, a) {
      var s = this.childAt(0), l = t.hostModel, u, c, h, f, d, p, g, v, m;
      if (o && (u = o.emphasisItemStyle, c = o.blurItemStyle, h = o.selectItemStyle, f = o.focus, d = o.blurScope, g = o.labelStatesModels, v = o.hoverScale, m = o.cursorStyle, p = o.emphasisDisabled), !o || t.hasItemOption) {
        var y = o && o.itemModel ? o.itemModel : t.getItemModel(r), b = y.getModel("emphasis");
        u = b.getModel("itemStyle").getItemStyle(), h = y.getModel(["select", "itemStyle"]).getItemStyle(), c = y.getModel(["blur", "itemStyle"]).getItemStyle(), f = b.get("focus"), d = b.get("blurScope"), p = b.get("disabled"), g = Fr(y), v = b.getShallow("scale"), m = y.getShallow("cursor");
      }
      var O = t.getItemVisual(r, "symbolRotate");
      s.attr("rotation", (O || 0) * Math.PI / 180 || 0);
      var w = Id(t.getItemVisual(r, "symbolOffset"), i);
      w && (s.x = w[0], s.y = w[1]), m && s.attr("cursor", m);
      var x = t.getItemVisual(r, "style"), S = x.fill;
      if (s instanceof Si) {
        var _ = s.style;
        s.useStyle(re({
          // TODO other properties like x, y ?
          image: _.image,
          x: _.x,
          y: _.y,
          width: _.width,
          height: _.height
        }, x));
      } else
        s.__isEmptyBrush ? s.useStyle(re({}, x)) : s.useStyle(x), s.style.decal = null, s.setColor(S, a && a.symbolInnerColor), s.style.strokeNoScale = !0;
      var C = t.getItemVisual(r, "liftZ"), A = this._z2;
      C != null ? A == null && (this._z2 = s.z2, s.z2 += C) : A != null && (s.z2 = A, this._z2 = null);
      var k = a && a.useNameLabel;
      wi(s, g, {
        labelFetcher: l,
        labelDataIndex: r,
        defaultText: P,
        inheritColor: S,
        defaultOpacity: x.opacity
      });
      function P(E) {
        return k ? t.getName(E) : Jg(t, E);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var L = s.ensureState("emphasis");
      L.style = u, s.ensureState("select").style = h, s.ensureState("blur").style = c;
      var D = v == null || v === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      L.scaleX = this._sizeX * D, L.scaleY = this._sizeY * D, this.setSymbolScale(1), Wn(this, f, d, p);
    }, e.prototype.setSymbolScale = function(t) {
      this.scaleX = this.scaleY = t;
    }, e.prototype.fadeOut = function(t, r, i) {
      var o = this.childAt(0), a = He(this).dataIndex, s = i && i.animation;
      if (this.silent = o.silent = !0, i && i.fadeLabel) {
        var l = o.getTextContent();
        l && Yc(l, {
          style: {
            opacity: 0
          }
        }, r, {
          dataIndex: a,
          removeOpt: s,
          cb: function() {
            o.removeTextContent();
          }
        });
      } else
        o.removeTextContent();
      Yc(o, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, r, {
        dataIndex: a,
        cb: t,
        removeOpt: s
      });
    }, e.getSymbolSize = function(t, r) {
      return Wv(t.getItemVisual(r, "symbolSize"));
    }, e;
  }(We)
);
function ePt(n, e) {
  this.parent.drift(n, e);
}
function LT(n, e, t, r) {
  return e && !isNaN(e[0]) && !isNaN(e[1]) && !(r.isIgnore && r.isIgnore(t)) && !(r.clipShape && !r.clipShape.contain(e[0], e[1])) && n.getItemVisual(t, "symbol") !== "none";
}
function S8(n) {
  return n != null && !Ne(n) && (n = {
    isIgnore: n
  }), n || {};
}
function _8(n) {
  var e = n.hostModel, t = e.getModel("emphasis");
  return {
    emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
    blurItemStyle: e.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: e.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: t.get("focus"),
    blurScope: t.get("blurScope"),
    emphasisDisabled: t.get("disabled"),
    hoverScale: t.get("scale"),
    labelStatesModels: Fr(e),
    cursorStyle: e.get("cursor")
  };
}
var qb = (
  /** @class */
  function() {
    function n(e) {
      this.group = new We(), this._SymbolCtor = e || Hb;
    }
    return n.prototype.updateData = function(e, t) {
      this._progressiveEls = null, t = S8(t);
      var r = this.group, i = e.hostModel, o = this._data, a = this._SymbolCtor, s = t.disableAnimation, l = _8(e), u = {
        disableAnimation: s
      }, c = t.getSymbolPoint || function(h) {
        return e.getItemLayout(h);
      };
      o || r.removeAll(), e.diff(o).add(function(h) {
        var f = c(h);
        if (LT(e, f, h, t)) {
          var d = new a(e, h, l, u);
          d.setPosition(f), e.setItemGraphicEl(h, d), r.add(d);
        }
      }).update(function(h, f) {
        var d = o.getItemGraphicEl(f), p = c(h);
        if (!LT(e, p, h, t)) {
          r.remove(d);
          return;
        }
        var g = e.getItemVisual(h, "symbol") || "circle", v = d && d.getSymbolType && d.getSymbolType();
        if (!d || v && v !== g)
          r.remove(d), d = new a(e, h, l, u), d.setPosition(p);
        else {
          d.updateData(e, h, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          s ? d.attr(m) : Vt(d, m, i);
        }
        r.add(d), e.setItemGraphicEl(h, d);
      }).remove(function(h) {
        var f = o.getItemGraphicEl(h);
        f && f.fadeOut(function() {
          r.remove(f);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = e;
    }, n.prototype.updateLayout = function() {
      var e = this, t = this._data;
      t && t.eachItemGraphicEl(function(r, i) {
        var o = e._getSymbolPoint(i);
        r.setPosition(o), r.markRedraw();
      });
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = _8(e), this._data = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(e, t, r) {
      this._progressiveEls = [], r = S8(r);
      function i(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var o = e.start; o < e.end; o++) {
        var a = t.getItemLayout(o);
        if (LT(t, a, o, r)) {
          var s = new this._SymbolCtor(t, o, this._seriesScope);
          s.traverse(i), s.setPosition(a), this.group.add(s), t.setItemGraphicEl(o, s), this._progressiveEls.push(s);
        }
      }
    }, n.prototype.eachRendered = function(e) {
      dh(this._progressiveEls || this.group, e);
    }, n.prototype.remove = function(e) {
      var t = this.group, r = this._data;
      r && e ? r.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          t.remove(i);
        }, r.hostModel);
      }) : t.removeAll();
    }, n;
  }()
);
function sre(n, e, t) {
  var r = n.getBaseAxis(), i = n.getOtherAxis(r), o = tPt(i, t), a = r.dim, s = i.dim, l = e.mapDimension(s), u = e.mapDimension(a), c = s === "x" || s === "radius" ? 1 : 0, h = le(n.dimensions, function(p) {
    return e.mapDimension(p);
  }), f = !1, d = e.getCalculationInfo("stackResultDimension");
  return Uc(
    e,
    h[0]
    /* , dims[1] */
  ) && (f = !0, h[0] = d), Uc(
    e,
    h[1]
    /* , dims[0] */
  ) && (f = !0, h[1] = d), {
    dataDimsForPoint: h,
    valueStart: o,
    valueAxisDim: s,
    baseAxisDim: a,
    stacked: !!f,
    valueDim: l,
    baseDim: u,
    baseDataOffset: c,
    stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
  };
}
function tPt(n, e) {
  var t = 0, r = n.scale.getExtent();
  return e === "start" ? t = r[0] : e === "end" ? t = r[1] : $t(e) && !isNaN(e) ? t = e : r[0] > 0 ? t = r[0] : r[1] < 0 && (t = r[1]), t;
}
function lre(n, e, t, r) {
  var i = NaN;
  n.stacked && (i = t.get(t.getCalculationInfo("stackedOverDimension"), r)), isNaN(i) && (i = n.valueStart);
  var o = n.baseDataOffset, a = [];
  return a[o] = t.get(n.baseDim, r), a[1 - o] = i, e.dataToPoint(a);
}
function nPt(n, e) {
  var t = [];
  return e.diff(n).add(function(r) {
    t.push({
      cmd: "+",
      idx: r
    });
  }).update(function(r, i) {
    t.push({
      cmd: "=",
      idx: i,
      idx1: r
    });
  }).remove(function(r) {
    t.push({
      cmd: "-",
      idx: r
    });
  }).execute(), t;
}
function rPt(n, e, t, r, i, o, a, s) {
  for (var l = nPt(n, e), u = [], c = [], h = [], f = [], d = [], p = [], g = [], v = sre(i, e, a), m = n.getLayout("points") || [], y = e.getLayout("points") || [], b = 0; b < l.length; b++) {
    var O = l[b], w = !0, x = void 0, S = void 0;
    switch (O.cmd) {
      case "=":
        x = O.idx * 2, S = O.idx1 * 2;
        var _ = m[x], C = m[x + 1], A = y[S], k = y[S + 1];
        (isNaN(_) || isNaN(C)) && (_ = A, C = k), u.push(_, C), c.push(A, k), h.push(t[x], t[x + 1]), f.push(r[S], r[S + 1]), g.push(e.getRawIndex(O.idx1));
        break;
      case "+":
        var P = O.idx, L = v.dataDimsForPoint, D = i.dataToPoint([e.get(L[0], P), e.get(L[1], P)]);
        S = P * 2, u.push(D[0], D[1]), c.push(y[S], y[S + 1]);
        var E = lre(v, i, e, P);
        h.push(E[0], E[1]), f.push(r[S], r[S + 1]), g.push(e.getRawIndex(P));
        break;
      case "-":
        w = !1;
    }
    w && (d.push(O), p.push(p.length));
  }
  p.sort(function(ie, ae) {
    return g[ie] - g[ae];
  });
  for (var M = u.length, R = ol(M), N = ol(M), $ = ol(M), F = ol(M), W = [], b = 0; b < p.length; b++) {
    var j = p[b], Y = b * 2, X = j * 2;
    R[Y] = u[X], R[Y + 1] = u[X + 1], N[Y] = c[X], N[Y + 1] = c[X + 1], $[Y] = h[X], $[Y + 1] = h[X + 1], F[Y] = f[X], F[Y + 1] = f[X + 1], W[b] = d[j];
  }
  return {
    current: R,
    next: N,
    stackedOnCurrent: $,
    stackedOnNext: F,
    status: W
  };
}
var Vu = Math.min, zu = Math.max;
function jf(n, e) {
  return isNaN(n) || isNaN(e);
}
function pD(n, e, t, r, i, o, a, s, l) {
  for (var u, c, h, f, d, p, g = t, v = 0; v < r; v++) {
    var m = e[g * 2], y = e[g * 2 + 1];
    if (g >= i || g < 0)
      break;
    if (jf(m, y)) {
      if (l) {
        g += o;
        continue;
      }
      break;
    }
    if (g === t)
      n[o > 0 ? "moveTo" : "lineTo"](m, y), h = m, f = y;
    else {
      var b = m - u, O = y - c;
      if (b * b + O * O < 0.5) {
        g += o;
        continue;
      }
      if (a > 0) {
        for (var w = g + o, x = e[w * 2], S = e[w * 2 + 1]; x === m && S === y && v < r; )
          v++, w += o, g += o, x = e[w * 2], S = e[w * 2 + 1], m = e[g * 2], y = e[g * 2 + 1], b = m - u, O = y - c;
        var _ = v + 1;
        if (l)
          for (; jf(x, S) && _ < r; )
            _++, w += o, x = e[w * 2], S = e[w * 2 + 1];
        var C = 0.5, A = 0, k = 0, P = void 0, L = void 0;
        if (_ >= r || jf(x, S))
          d = m, p = y;
        else {
          A = x - u, k = S - c;
          var D = m - u, E = x - m, M = y - c, R = S - y, N = void 0, $ = void 0;
          if (s === "x") {
            N = Math.abs(D), $ = Math.abs(E);
            var F = A > 0 ? 1 : -1;
            d = m - F * N * a, p = y, P = m + F * $ * a, L = y;
          } else if (s === "y") {
            N = Math.abs(M), $ = Math.abs(R);
            var W = k > 0 ? 1 : -1;
            d = m, p = y - W * N * a, P = m, L = y + W * $ * a;
          } else
            N = Math.sqrt(D * D + M * M), $ = Math.sqrt(E * E + R * R), C = $ / ($ + N), d = m - A * a * (1 - C), p = y - k * a * (1 - C), P = m + A * a * C, L = y + k * a * C, P = Vu(P, zu(x, m)), L = Vu(L, zu(S, y)), P = zu(P, Vu(x, m)), L = zu(L, Vu(S, y)), A = P - m, k = L - y, d = m - A * N / $, p = y - k * N / $, d = Vu(d, zu(u, m)), p = Vu(p, zu(c, y)), d = zu(d, Vu(u, m)), p = zu(p, Vu(c, y)), A = m - d, k = y - p, P = m + A * $ / N, L = y + k * $ / N;
        }
        n.bezierCurveTo(h, f, d, p, m, y), h = P, f = L;
      } else
        n.lineTo(m, y);
    }
    u = m, c = y, g += o;
  }
  return v;
}
var ure = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return n;
  }()
), iPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-polyline", r;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new ure();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, o = 0, a = i.length / 2;
      if (r.connectNulls) {
        for (; a > 0 && jf(i[a * 2 - 2], i[a * 2 - 1]); a--)
          ;
        for (; o < a && jf(i[o * 2], i[o * 2 + 1]); o++)
          ;
      }
      for (; o < a; )
        o += pD(t, i, o, a, a, 1, r.smooth, r.smoothMonotone, r.connectNulls) + 1;
    }, e.prototype.getPointOn = function(t, r) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, o = i.data, a = Al.CMD, s, l, u = r === "x", c = [], h = 0; h < o.length; ) {
        var f = o[h++], d = void 0, p = void 0, g = void 0, v = void 0, m = void 0, y = void 0, b = void 0;
        switch (f) {
          case a.M:
            s = o[h++], l = o[h++];
            break;
          case a.L:
            if (d = o[h++], p = o[h++], b = u ? (t - s) / (d - s) : (t - l) / (p - l), b <= 1 && b >= 0) {
              var O = u ? (p - l) * b + l : (d - s) * b + s;
              return u ? [t, O] : [O, t];
            }
            s = d, l = p;
            break;
          case a.C:
            d = o[h++], p = o[h++], g = o[h++], v = o[h++], m = o[h++], y = o[h++];
            var w = u ? uS(s, d, g, m, t, c) : uS(l, p, v, y, t, c);
            if (w > 0)
              for (var x = 0; x < w; x++) {
                var S = c[x];
                if (S <= 1 && S >= 0) {
                  var O = u ? Dr(l, p, v, y, S) : Dr(s, d, g, m, S);
                  return u ? [t, O] : [O, t];
                }
              }
            s = m, l = y;
            break;
        }
      }
    }, e;
  }(gt)
), oPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e;
  }(ure)
), cre = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-polygon", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new oPt();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, o = r.stackedOnPoints, a = 0, s = i.length / 2, l = r.smoothMonotone;
      if (r.connectNulls) {
        for (; s > 0 && jf(i[s * 2 - 2], i[s * 2 - 1]); s--)
          ;
        for (; a < s && jf(i[a * 2], i[a * 2 + 1]); a++)
          ;
      }
      for (; a < s; ) {
        var u = pD(t, i, a, s, s, 1, r.smooth, l, r.connectNulls);
        pD(t, o, a + u - 1, u, s, -1, r.stackedOnSmooth, l, r.connectNulls), a += u + 1, t.closePath();
      }
    }, e;
  }(gt)
);
function hre(n, e, t, r, i) {
  var o = n.getArea(), a = o.x, s = o.y, l = o.width, u = o.height, c = t.get(["lineStyle", "width"]) || 2;
  a -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), a !== Math.floor(a) && (a = Math.floor(a), l++);
  var h = new Lt({
    shape: {
      x: a,
      y: s,
      width: l,
      height: u
    }
  });
  if (e) {
    var f = n.getBaseAxis(), d = f.isHorizontal(), p = f.inverse;
    d ? (p && (h.shape.x += l), h.shape.width = 0) : (p || (h.shape.y += u), h.shape.height = 0);
    var g = Le(i) ? function(v) {
      i(v, h);
    } : null;
    Cn(h, {
      shape: {
        width: l,
        height: u,
        x: a,
        y: s
      }
    }, t, null, r, g);
  }
  return h;
}
function fre(n, e, t) {
  var r = n.getArea(), i = qn(r.r0, 1), o = qn(r.r, 1), a = new Eo({
    shape: {
      cx: qn(n.cx, 1),
      cy: qn(n.cy, 1),
      r0: i,
      r: o,
      startAngle: r.startAngle,
      endAngle: r.endAngle,
      clockwise: r.clockwise
    }
  });
  if (e) {
    var s = n.getBaseAxis().dim === "angle";
    s ? a.shape.endAngle = r.startAngle : a.shape.r = i, Cn(a, {
      shape: {
        endAngle: r.endAngle,
        r: o
      }
    }, t);
  }
  return a;
}
function Yb(n, e, t, r, i) {
  if (n) {
    if (n.type === "polar")
      return fre(n, e, t);
    if (n.type === "cartesian2d")
      return hre(n, e, t, r, i);
  } else
    return null;
  return null;
}
function Nd(n, e) {
  return n.type === e;
}
function C8(n, e) {
  if (n.length === e.length) {
    for (var t = 0; t < n.length; t++)
      if (n[t] !== e[t])
        return;
    return !0;
  }
}
function A8(n) {
  for (var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, o = 0; o < n.length; ) {
    var a = n[o++], s = n[o++];
    isNaN(a) || (e = Math.min(a, e), r = Math.max(a, r)), isNaN(s) || (t = Math.min(s, t), i = Math.max(s, i));
  }
  return [[e, t], [r, i]];
}
function T8(n, e) {
  var t = A8(n), r = t[0], i = t[1], o = A8(e), a = o[0], s = o[1];
  return Math.max(Math.abs(r[0] - a[0]), Math.abs(r[1] - a[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
}
function k8(n) {
  return $t(n) ? n : n ? 0.5 : 0;
}
function aPt(n, e, t) {
  if (!t.valueDim)
    return [];
  for (var r = e.count(), i = ol(r * 2), o = 0; o < r; o++) {
    var a = lre(t, n, e, o);
    i[o * 2] = a[0], i[o * 2 + 1] = a[1];
  }
  return i;
}
function Fu(n, e, t, r) {
  var i = e.getBaseAxis(), o = i.dim === "x" || i.dim === "radius" ? 0 : 1, a = [], s = 0, l = [], u = [], c = [], h = [];
  if (r) {
    for (s = 0; s < n.length; s += 2)
      !isNaN(n[s]) && !isNaN(n[s + 1]) && h.push(n[s], n[s + 1]);
    n = h;
  }
  for (s = 0; s < n.length - 2; s += 2)
    switch (c[0] = n[s + 2], c[1] = n[s + 3], u[0] = n[s], u[1] = n[s + 1], a.push(u[0], u[1]), t) {
      case "end":
        l[o] = c[o], l[1 - o] = u[1 - o], a.push(l[0], l[1]);
        break;
      case "middle":
        var f = (u[o] + c[o]) / 2, d = [];
        l[o] = d[o] = f, l[1 - o] = u[1 - o], d[1 - o] = c[1 - o], a.push(l[0], l[1]), a.push(d[0], d[1]);
        break;
      default:
        l[o] = u[o], l[1 - o] = c[1 - o], a.push(l[0], l[1]);
    }
  return a.push(n[s++], n[s++]), a;
}
function sPt(n, e) {
  var t = [], r = n.length, i, o;
  function a(c, h, f) {
    var d = c.coord, p = (f - d) / (h.coord - d), g = Twt(p, [c.color, h.color]);
    return {
      coord: f,
      color: g
    };
  }
  for (var s = 0; s < r; s++) {
    var l = n[s], u = l.coord;
    if (u < 0)
      i = l;
    else if (u > e) {
      o ? t.push(a(o, l, e)) : i && t.push(a(i, l, 0), a(i, l, e));
      break;
    } else
      i && (t.push(a(i, l, 0)), i = null), t.push(l), o = l;
  }
  return t;
}
function lPt(n, e, t) {
  var r = n.getVisual("visualMeta");
  if (!(!r || !r.length || !n.count())) {
    if (e.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var i, o, a = r.length - 1; a >= 0; a--) {
      var s = n.getDimensionInfo(r[a].dimension);
      if (i = s && s.coordDim, i === "x" || i === "y") {
        o = r[a];
        break;
      }
    }
    if (!o) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var l = e.getAxis(i), u = le(o.stops, function(b) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(b.value)),
        color: b.color
      };
    }), c = u.length, h = o.outerColors.slice();
    c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse());
    var f = sPt(u, i === "x" ? t.getWidth() : t.getHeight()), d = f.length;
    if (!d && c)
      return u[0].coord < 0 ? h[1] ? h[1] : u[c - 1].color : h[0] ? h[0] : u[0].color;
    var p = 10, g = f[0].coord - p, v = f[d - 1].coord + p, m = v - g;
    if (m < 1e-3)
      return "transparent";
    I(f, function(b) {
      b.offset = (b.coord - g) / m;
    }), f.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: d ? f[d - 1].offset : 0.5,
      color: h[1] || "transparent"
    }), f.unshift({
      offset: d ? f[0].offset : 0.5,
      color: h[0] || "transparent"
    });
    var y = new zb(0, 0, 0, 0, f, !0);
    return y[i] = g, y[i + "2"] = v, y;
  }
}
function uPt(n, e, t) {
  var r = n.get("showAllSymbol"), i = r === "auto";
  if (!(r && !i)) {
    var o = t.getAxesByScale("ordinal")[0];
    if (o && !(i && cPt(o, e))) {
      var a = e.mapDimension(o.dim), s = {};
      return I(o.getViewLabels(), function(l) {
        var u = o.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(e.get(a, l));
      };
    }
  }
}
function cPt(n, e) {
  var t = n.getExtent(), r = Math.abs(t[1] - t[0]) / n.scale.count();
  isNaN(r) && (r = 0);
  for (var i = e.count(), o = Math.max(1, Math.round(i / 5)), a = 0; a < i; a += o)
    if (Hb.getSymbolSize(
      e,
      a
      // Only for cartesian, where `isHorizontal` exists.
    )[n.isHorizontal() ? 1 : 0] * 1.5 > r)
      return !1;
  return !0;
}
function hPt(n, e) {
  return isNaN(n) || isNaN(e);
}
function fPt(n) {
  for (var e = n.length / 2; e > 0 && hPt(n[e * 2 - 2], n[e * 2 - 1]); e--)
    ;
  return e - 1;
}
function P8(n, e) {
  return [n[e * 2], n[e * 2 + 1]];
}
function dPt(n, e, t) {
  for (var r = n.length / 2, i = t === "x" ? 0 : 1, o, a, s = 0, l = -1, u = 0; u < r; u++)
    if (a = n[u * 2 + i], !(isNaN(a) || isNaN(n[u * 2 + 1 - i]))) {
      if (u === 0) {
        o = a;
        continue;
      }
      if (o <= e && a >= e || o >= e && a <= e) {
        l = u;
        break;
      }
      s = u, o = a;
    }
  return {
    range: [s, l],
    t: (e - o) / (a - o)
  };
}
function dre(n) {
  if (n.get(["endLabel", "show"]))
    return !0;
  for (var e = 0; e < no.length; e++)
    if (n.get([no[e], "endLabel", "show"]))
      return !0;
  return !1;
}
function IT(n, e, t, r) {
  if (Nd(e, "cartesian2d")) {
    var i = r.getModel("endLabel"), o = i.get("valueAnimation"), a = r.getData(), s = {
      lastFrameIndex: 0
    }, l = dre(r) ? function(d, p) {
      n._endLabelOnDuring(d, p, a, s, o, i, e);
    } : null, u = e.getBaseAxis().isHorizontal(), c = hre(e, t, r, function() {
      var d = n._endLabel;
      d && t && s.originalX != null && d.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!r.get("clip", !0)) {
      var h = c.shape, f = Math.max(h.width, h.height);
      u ? (h.y -= f, h.height += f * 2) : (h.x -= f, h.width += f * 2);
    }
    return l && l(1, c), c;
  } else
    return process.env.NODE_ENV !== "production" && r.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), fre(e, t, r);
}
function pPt(n, e) {
  var t = e.getBaseAxis(), r = t.isHorizontal(), i = t.inverse, o = r ? i ? "right" : "left" : "center", a = r ? "middle" : i ? "top" : "bottom";
  return {
    normal: {
      align: n.get("align") || o,
      verticalAlign: n.get("verticalAlign") || a
    }
  };
}
var gPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var t = new We(), r = new qb();
      this.group.add(r.group), this._symbolDraw = r, this._lineGroup = t;
    }, e.prototype.render = function(t, r, i) {
      var o = this, a = t.coordinateSystem, s = this.group, l = t.getData(), u = t.getModel("lineStyle"), c = t.getModel("areaStyle"), h = l.getLayout("points") || [], f = a.type === "polar", d = this._coordSys, p = this._symbolDraw, g = this._polyline, v = this._polygon, m = this._lineGroup, y = !r.ssr && t.get("animation"), b = !c.isEmpty(), O = c.get("origin"), w = sre(a, l, O), x = b && aPt(a, l, w), S = t.get("showSymbol"), _ = t.get("connectNulls"), C = S && !f && uPt(t, l, a), A = this._data;
      A && A.eachItemGraphicEl(function(ae, ee) {
        ae.__temp && (s.remove(ae), A.setItemGraphicEl(ee, null));
      }), S || p.remove(), s.add(m);
      var k = f ? !1 : t.get("step"), P;
      a && a.getArea && t.get("clip", !0) && (P = a.getArea(), P.width != null ? (P.x -= 0.1, P.y -= 0.1, P.width += 0.2, P.height += 0.2) : P.r0 && (P.r0 -= 0.5, P.r += 0.5)), this._clipShapeForSymbol = P;
      var L = lPt(l, a, i) || l.getVisual("style")[l.getVisual("drawType")];
      if (!(g && d.type === a.type && k === this._step))
        S && p.updateData(l, {
          isIgnore: C,
          clipShape: P,
          disableAnimation: !0,
          getSymbolPoint: function(ae) {
            return [h[ae * 2], h[ae * 2 + 1]];
          }
        }), y && this._initSymbolLabelAnimation(l, a, P), k && (h = Fu(h, a, k, _), x && (x = Fu(x, a, k, _))), g = this._newPolyline(h), b ? v = this._newPolygon(h, x) : v && (m.remove(v), v = this._polygon = null), f || this._initOrUpdateEndLabel(t, a, gd(L)), m.setClipPath(IT(this, a, !0, t));
      else {
        b && !v ? v = this._newPolygon(h, x) : v && !b && (m.remove(v), v = this._polygon = null), f || this._initOrUpdateEndLabel(t, a, gd(L));
        var D = m.getClipPath();
        if (D) {
          var E = IT(this, a, !1, t);
          Cn(D, {
            shape: E.shape
          }, t);
        } else
          m.setClipPath(IT(this, a, !0, t));
        S && p.updateData(l, {
          isIgnore: C,
          clipShape: P,
          disableAnimation: !0,
          getSymbolPoint: function(ae) {
            return [h[ae * 2], h[ae * 2 + 1]];
          }
        }), (!C8(this._stackedOnPoints, x) || !C8(this._points, h)) && (y ? this._doUpdateAnimation(l, x, a, i, k, O, _) : (k && (h = Fu(h, a, k, _), x && (x = Fu(x, a, k, _))), g.setShape({
          points: h
        }), v && v.setShape({
          points: h,
          stackedOnPoints: x
        })));
      }
      var M = t.getModel("emphasis"), R = M.get("focus"), N = M.get("blurScope"), $ = M.get("disabled");
      if (g.useStyle(Be(
        // Use color in lineStyle first
        u.getLineStyle(),
        {
          fill: "none",
          stroke: L,
          lineJoin: "bevel"
        }
      )), Oi(g, t, "lineStyle"), g.style.lineWidth > 0 && t.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var F = g.getState("emphasis").style;
        F.lineWidth = +g.style.lineWidth + 1;
      }
      He(g).seriesIndex = t.seriesIndex, Wn(g, R, N, $);
      var W = k8(t.get("smooth")), j = t.get("smoothMonotone");
      if (g.setShape({
        smooth: W,
        smoothMonotone: j,
        connectNulls: _
      }), v) {
        var Y = l.getCalculationInfo("stackedOnSeries"), X = 0;
        v.useStyle(Be(c.getAreaStyle(), {
          fill: L,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: l.getVisual("style").decal
        })), Y && (X = k8(Y.get("smooth"))), v.setShape({
          smooth: W,
          stackedOnSmooth: X,
          smoothMonotone: j,
          connectNulls: _
        }), Oi(v, t, "areaStyle"), He(v).seriesIndex = t.seriesIndex, Wn(v, R, N, $);
      }
      var ie = function(ae) {
        o._changePolyState(ae);
      };
      l.eachItemGraphicEl(function(ae) {
        ae && (ae.onHoverStateChange = ie);
      }), this._polyline.onHoverStateChange = ie, this._data = l, this._coordSys = a, this._stackedOnPoints = x, this._points = h, this._step = k, this._valueOrigin = O, t.get("triggerLineEvent") && (this.packEventData(t, g), v && this.packEventData(t, v));
    }, e.prototype.packEventData = function(t, r) {
      He(r).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: t.componentIndex,
        seriesIndex: t.seriesIndex,
        seriesName: t.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(t, r, i, o) {
      var a = t.getData(), s = fd(a, o);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = a.getLayout("points"), u = a.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], h = l[s * 2 + 1];
          if (isNaN(c) || isNaN(h) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, h))
            return;
          var f = t.get("zlevel") || 0, d = t.get("z") || 0;
          u = new Hb(a, s), u.x = c, u.y = h, u.setZ(f, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = f, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = !0, a.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        bn.prototype.highlight.call(this, t, r, i, o);
    }, e.prototype.downplay = function(t, r, i, o) {
      var a = t.getData(), s = fd(a, o);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = a.getItemGraphicEl(s);
        l && (l.__temp ? (a.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        bn.prototype.downplay.call(this, t, r, i, o);
    }, e.prototype._changePolyState = function(t) {
      var r = this._polygon;
      vS(this._polyline, t), r && vS(r, t);
    }, e.prototype._newPolyline = function(t) {
      var r = this._polyline;
      return r && this._lineGroup.remove(r), r = new iPt({
        shape: {
          points: t
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(r), this._polyline = r, r;
    }, e.prototype._newPolygon = function(t, r) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new cre({
        shape: {
          points: t,
          stackedOnPoints: r
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, e.prototype._initSymbolLabelAnimation = function(t, r, i) {
      var o, a, s = r.getBaseAxis(), l = s.inverse;
      r.type === "cartesian2d" ? (o = s.isHorizontal(), a = !1) : r.type === "polar" && (o = s.dim === "angle", a = !0);
      var u = t.hostModel, c = u.get("animationDuration");
      Le(c) && (c = c(null));
      var h = u.get("animationDelay") || 0, f = Le(h) ? h(null) : h;
      t.eachItemGraphicEl(function(d, p) {
        var g = d;
        if (g) {
          var v = [d.x, d.y], m = void 0, y = void 0, b = void 0;
          if (i)
            if (a) {
              var O = i, w = r.pointToCoord(v);
              o ? (m = O.startAngle, y = O.endAngle, b = -w[1] / 180 * Math.PI) : (m = O.r0, y = O.r, b = w[0]);
            } else {
              var x = i;
              o ? (m = x.x, y = x.x + x.width, b = d.x) : (m = x.y + x.height, y = x.y, b = d.y);
            }
          var S = y === m ? 0 : (b - m) / (y - m);
          l && (S = 1 - S);
          var _ = Le(h) ? h(p) : c * S + f, C = g.getSymbolPath(), A = C.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: _
          }), A && A.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: _
          }), C.disableLabelAnimation = !0;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(t, r, i) {
      var o = t.getModel("endLabel");
      if (dre(t)) {
        var a = t.getData(), s = this._polyline, l = a.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new Nt({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var c = fPt(l);
        c >= 0 && (wi(s, Fr(t, "endLabel"), {
          inheritColor: i,
          labelFetcher: t,
          labelDataIndex: c,
          defaultText: function(h, f, d) {
            return d != null ? are(a, d) : Jg(a, h);
          },
          enableTextSetter: !0
        }, pPt(o, r)), s.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(t, r, i, o, a, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        t < 1 && o.originalX == null && (o.originalX = u.x, o.originalY = u.y);
        var h = i.getLayout("points"), f = i.hostModel, d = f.get("connectNulls"), p = s.get("precision"), g = s.get("distance") || 0, v = l.getBaseAxis(), m = v.isHorizontal(), y = v.inverse, b = r.shape, O = y ? m ? b.x : b.y + b.height : m ? b.x + b.width : b.y, w = (m ? g : 0) * (y ? -1 : 1), x = (m ? 0 : -g) * (y ? -1 : 1), S = m ? "x" : "y", _ = dPt(h, O, S), C = _.range, A = C[1] - C[0], k = void 0;
        if (A >= 1) {
          if (A > 1 && !d) {
            var P = P8(h, C[0]);
            u.attr({
              x: P[0] + w,
              y: P[1] + x
            }), a && (k = f.getRawValue(C[0]));
          } else {
            var P = c.getPointOn(O, S);
            P && u.attr({
              x: P[0] + w,
              y: P[1] + x
            });
            var L = f.getRawValue(C[0]), D = f.getRawValue(C[1]);
            a && (k = zJ(i, p, L, D, _.t));
          }
          o.lastFrameIndex = C[0];
        } else {
          var E = t === 1 || o.lastFrameIndex > 0 ? C[0] : 0, P = P8(h, E);
          a && (k = f.getRawValue(E)), u.attr({
            x: P[0] + w,
            y: P[1] + x
          });
        }
        if (a) {
          var M = Rv(u);
          typeof M.setLabelText == "function" && M.setLabelText(k);
        }
      }
    }, e.prototype._doUpdateAnimation = function(t, r, i, o, a, s, l) {
      var u = this._polyline, c = this._polygon, h = t.hostModel, f = rPt(this._data, t, this._stackedOnPoints, r, this._coordSys, i, this._valueOrigin), d = f.current, p = f.stackedOnCurrent, g = f.next, v = f.stackedOnNext;
      if (a && (d = Fu(f.current, i, a, l), p = Fu(f.stackedOnCurrent, i, a, l), g = Fu(f.next, i, a, l), v = Fu(f.stackedOnNext, i, a, l)), T8(d, g) > 3e3 || c && T8(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = f.current, u.shape.points = d;
      var m = {
        shape: {
          points: g
        }
      };
      f.current !== d && (m.shape.__points = f.next), u.stopAnimation(), Vt(u, m, h), c && (c.setShape({
        // Reuse the points with polyline.
        points: d,
        stackedOnPoints: p
      }), c.stopAnimation(), Vt(c, {
        shape: {
          stackedOnPoints: v
        }
      }, h), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], b = f.status, O = 0; O < b.length; O++) {
        var w = b[O].cmd;
        if (w === "=") {
          var x = t.getItemGraphicEl(b[O].idx1);
          x && y.push({
            el: x,
            ptIdx: O
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var S = u.shape.__points, _ = 0; _ < y.length; _++) {
          var C = y[_].el, A = y[_].ptIdx * 2;
          C.x = S[A], C.y = S[A + 1], C.markRedraw();
        }
      });
    }, e.prototype.remove = function(t) {
      var r = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(o, a) {
        o.__temp && (r.remove(o), i.setItemGraphicEl(a, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }(bn)
);
const vPt = gPt;
function Xb(n, e) {
  return {
    seriesType: n,
    plan: Qv(),
    reset: function(t) {
      var r = t.getData(), i = t.coordinateSystem, o = t.pipelineContext, a = e || o.large;
      if (i) {
        var s = le(i.dimensions, function(d) {
          return r.mapDimension(d);
        }).slice(0, 2), l = s.length, u = r.getCalculationInfo("stackResultDimension");
        Uc(r, s[0]) && (s[0] = u), Uc(r, s[1]) && (s[1] = u);
        var c = r.getStore(), h = r.getDimensionIndex(s[0]), f = r.getDimensionIndex(s[1]);
        return l && {
          progress: function(d, p) {
            for (var g = d.end - d.start, v = a && ol(g * l), m = [], y = [], b = d.start, O = 0; b < d.end; b++) {
              var w = void 0;
              if (l === 1) {
                var x = c.get(h, b);
                w = i.dataToPoint(x, null, y);
              } else
                m[0] = c.get(h, b), m[1] = c.get(f, b), w = i.dataToPoint(m, null, y);
              a ? (v[O++] = w[0], v[O++] = w[1]) : p.setItemLayout(b, w.slice());
            }
            a && p.setLayout("points", v);
          }
        };
      }
    }
  };
}
var mPt = {
  average: function(n) {
    for (var e = 0, t = 0, r = 0; r < n.length; r++)
      isNaN(n[r]) || (e += n[r], t++);
    return t === 0 ? NaN : e / t;
  },
  sum: function(n) {
    for (var e = 0, t = 0; t < n.length; t++)
      e += n[t] || 0;
    return e;
  },
  max: function(n) {
    for (var e = -1 / 0, t = 0; t < n.length; t++)
      n[t] > e && (e = n[t]);
    return isFinite(e) ? e : NaN;
  },
  min: function(n) {
    for (var e = 1 / 0, t = 0; t < n.length; t++)
      n[t] < e && (e = n[t]);
    return isFinite(e) ? e : NaN;
  },
  minmax: function(n) {
    for (var e = -1 / 0, t = -1 / 0, r = 0; r < n.length; r++) {
      var i = n[r], o = Math.abs(i);
      o > e && (e = o, t = i);
    }
    return isFinite(t) ? t : NaN;
  },
  // TODO
  // Median
  nearest: function(n) {
    return n[0];
  }
}, yPt = function(n) {
  return Math.round(n.length / 2);
};
function pre(n) {
  return {
    seriesType: n,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(e, t, r) {
      var i = e.getData(), o = e.get("sampling"), a = e.coordinateSystem, s = i.count();
      if (s > 10 && a.type === "cartesian2d" && o) {
        var l = a.getBaseAxis(), u = a.getOtherAxis(l), c = l.getExtent(), h = r.getDevicePixelRatio(), f = Math.abs(c[1] - c[0]) * (h || 1), d = Math.round(s / f);
        if (isFinite(d) && d > 1) {
          o === "lttb" && e.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d));
          var p = void 0;
          we(o) ? p = mPt[o] : Le(o) && (p = o), p && e.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, yPt));
        }
      }
    }
  };
}
function bPt(n) {
  n.registerChartView(vPt), n.registerSeriesModel(Jkt), n.registerLayout(Xb("line", !0)), n.registerVisual({
    seriesType: "line",
    reset: function(e) {
      var t = e.getData(), r = e.getModel("lineStyle").getLineStyle();
      r && !r.stroke && (r.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", r);
    }
  }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, pre("line"));
}
var q0 = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return ku(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getMarkerPosition = function(t, r, i) {
      var o = this.coordinateSystem;
      if (o && o.clampData) {
        var a = o.clampData(t), s = o.dataToPoint(a);
        if (i)
          I(o.getAxes(), function(f, d) {
            if (f.type === "category" && r != null) {
              var p = f.getTicksCoords(), g = f.getTickModel().get("alignWithLabel"), v = a[d], m = r[d] === "x1" || r[d] === "y1";
              if (m && !g && (v += 1), p.length < 2)
                return;
              if (p.length === 2) {
                s[d] = f.toGlobalCoord(f.getExtent()[m ? 1 : 0]);
                return;
              }
              for (var y = void 0, b = void 0, O = 1, w = 0; w < p.length; w++) {
                var x = p[w].coord, S = w === p.length - 1 ? p[w - 1].tickValue + O : p[w].tickValue;
                if (S === v) {
                  b = x;
                  break;
                } else if (S < v)
                  y = x;
                else if (y != null && S > v) {
                  b = (x + y) / 2;
                  break;
                }
                w === 1 && (O = S - p[0].tickValue);
              }
              b == null && (y ? y && (b = p[p.length - 1].coord) : b = p[0].coord), s[d] = f.toGlobalCoord(b);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), h = o.getBaseAxis().isHorizontal() ? 0 : 1;
          s[h] += u + c / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(Ln)
);
Ln.registerClass(q0);
var OPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function() {
      return ku(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.get("progressiveThreshold"), r = this.get("largeThreshold");
      return r > t && (t = r), t;
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.rect(r.getItemLayout(t));
    }, e.type = "series.bar", e.dependencies = ["grid", "polar"], e.defaultOption = ph(q0.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), e;
  }(q0)
);
const wPt = OPt;
var xPt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return n;
  }()
), $S = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "sausage", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new xPt();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.cx, o = r.cy, a = Math.max(r.r0 || 0, 0), s = Math.max(r.r, 0), l = (s - a) * 0.5, u = a + l, c = r.startAngle, h = r.endAngle, f = r.clockwise, d = Math.PI * 2, p = f ? h - c < d : c - h < d;
      p || (c = h - (f ? d : -d));
      var g = Math.cos(c), v = Math.sin(c), m = Math.cos(h), y = Math.sin(h);
      p ? (t.moveTo(g * a + i, v * a + o), t.arc(g * u + i, v * u + o, l, -Math.PI + c, c, !f)) : t.moveTo(g * s + i, v * s + o), t.arc(i, o, s, c, h, !f), t.arc(m * u + i, y * u + o, l, h - Math.PI * 2, h - Math.PI, !f), a !== 0 && t.arc(i, o, a, h, c, f);
    }, e;
  }(gt)
);
function SPt(n, e) {
  e = e || {};
  var t = e.isRoundCap;
  return function(r, i, o) {
    var a = i.position;
    if (!a || a instanceof Array)
      return pS(r, i, o);
    var s = n(a), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, h = u.cy, f = u.r, d = u.r0, p = (f + d) / 2, g = u.startAngle, v = u.endAngle, m = (g + v) / 2, y = t ? Math.abs(f - d) / 2 : 0, b = Math.cos, O = Math.sin, w = c + f * b(g), x = h + f * O(g), S = "left", _ = "top";
    switch (s) {
      case "startArc":
        w = c + (d - l) * b(m), x = h + (d - l) * O(m), S = "center", _ = "top";
        break;
      case "insideStartArc":
        w = c + (d + l) * b(m), x = h + (d + l) * O(m), S = "center", _ = "bottom";
        break;
      case "startAngle":
        w = c + p * b(g) + LO(g, l + y, !1), x = h + p * O(g) + IO(g, l + y, !1), S = "right", _ = "middle";
        break;
      case "insideStartAngle":
        w = c + p * b(g) + LO(g, -l + y, !1), x = h + p * O(g) + IO(g, -l + y, !1), S = "left", _ = "middle";
        break;
      case "middle":
        w = c + p * b(m), x = h + p * O(m), S = "center", _ = "middle";
        break;
      case "endArc":
        w = c + (f + l) * b(m), x = h + (f + l) * O(m), S = "center", _ = "bottom";
        break;
      case "insideEndArc":
        w = c + (f - l) * b(m), x = h + (f - l) * O(m), S = "center", _ = "top";
        break;
      case "endAngle":
        w = c + p * b(v) + LO(v, l + y, !0), x = h + p * O(v) + IO(v, l + y, !0), S = "left", _ = "middle";
        break;
      case "insideEndAngle":
        w = c + p * b(v) + LO(v, -l + y, !0), x = h + p * O(v) + IO(v, -l + y, !0), S = "right", _ = "middle";
        break;
      default:
        return pS(r, i, o);
    }
    return r = r || {}, r.x = w, r.y = x, r.align = S, r.verticalAlign = _, r;
  };
}
function _Pt(n, e, t, r) {
  if ($t(r)) {
    n.setTextConfig({
      rotation: r
    });
    return;
  } else if (se(e)) {
    n.setTextConfig({
      rotation: 0
    });
    return;
  }
  var i = n.shape, o = i.clockwise ? i.startAngle : i.endAngle, a = i.clockwise ? i.endAngle : i.startAngle, s = (o + a) / 2, l, u = t(e);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = o;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = a;
      break;
    default:
      n.setTextConfig({
        rotation: 0
      });
      return;
  }
  var c = Math.PI * 1.5 - l;
  u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), n.setTextConfig({
    rotation: c
  });
}
function LO(n, e, t) {
  return e * Math.sin(n) * (t ? -1 : 1);
}
function IO(n, e, t) {
  return e * Math.cos(n) * (t ? 1 : -1);
}
function Tf(n, e, t) {
  var r = n.get("borderRadius");
  if (r == null)
    return t ? {
      cornerRadius: 0
    } : null;
  se(r) || (r = [r, r, r, r]);
  var i = Math.abs(e.r || 0 - e.r0 || 0);
  return {
    cornerRadius: le(r, function(o) {
      return gs(o, i);
    })
  };
}
var RT = Math.max, NT = Math.min;
function CPt(n, e) {
  var t = n.getArea && n.getArea();
  if (Nd(n, "cartesian2d")) {
    var r = n.getBaseAxis();
    if (r.type !== "category" || !r.onBand) {
      var i = e.getLayout("bandWidth");
      r.isHorizontal() ? (t.x -= i, t.width += i * 2) : (t.y -= i, t.height += i * 2);
    }
  }
  return t;
}
var APt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n.call(this) || this;
      return t.type = e.type, t._isFirstFrame = !0, t;
    }
    return e.prototype.render = function(t, r, i, o) {
      this._model = t, this._removeOnRenderedListener(i), this._updateDrawMode(t);
      var a = t.get("coordinateSystem");
      a === "cartesian2d" || a === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, r, i) : this._renderNormal(t, r, i, o)) : process.env.NODE_ENV !== "production" && $n("Only cartesian2d and polar supported for bar.");
    }, e.prototype.incrementalPrepareRender = function(t) {
      this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
    }, e.prototype.incrementalRender = function(t, r) {
      this._progressiveEls = [], this._incrementalRenderLarge(t, r);
    }, e.prototype.eachRendered = function(t) {
      dh(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var r = t.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, e.prototype._renderNormal = function(t, r, i, o) {
      var a = this.group, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.getBaseAxis(), h;
      u.type === "cartesian2d" ? h = c.isHorizontal() : u.type === "polar" && (h = c.dim === "angle");
      var f = t.isAnimationEnabled() ? t : null, d = TPt(t, u);
      d && this._enableRealtimeSort(d, s, i);
      var p = t.get("clip", !0) || d, g = CPt(u, s);
      a.removeClipPath();
      var v = t.get("roundCap", !0), m = t.get("showBackground", !0), y = t.getModel("backgroundStyle"), b = y.get("borderRadius") || 0, O = [], w = this._backgroundEls, x = o && o.isInitSort, S = o && o.type === "changeAxisOrder";
      function _(k) {
        var P = RO[u.type](s, k), L = IPt(u, h, P);
        return L.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? L.setShape("r", b) : L.setShape("cornerRadius", b), O[k] = L, L;
      }
      s.diff(l).add(function(k) {
        var P = s.getItemModel(k), L = RO[u.type](s, k, P);
        if (m && _(k), !(!s.hasValue(k) || !I8[u.type](L))) {
          var D = !1;
          p && (D = E8[u.type](g, L));
          var E = M8[u.type](t, s, k, L, h, f, c.model, !1, v);
          d && (E.forceLabelAnimation = !0), R8(E, s, k, P, L, t, h, u.type === "polar"), x ? E.attr({
            shape: L
          }) : d ? D8(d, f, E, L, k, h, !1, !1) : Cn(E, {
            shape: L
          }, t, k), s.setItemGraphicEl(k, E), a.add(E), E.ignore = D;
        }
      }).update(function(k, P) {
        var L = s.getItemModel(k), D = RO[u.type](s, k, L);
        if (m) {
          var E = void 0;
          w.length === 0 ? E = _(P) : (E = w[P], E.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? E.setShape("r", b) : E.setShape("cornerRadius", b), O[k] = E);
          var M = RO[u.type](s, k), R = vre(h, M, u);
          Vt(E, {
            shape: R
          }, f, k);
        }
        var N = l.getItemGraphicEl(P);
        if (!s.hasValue(k) || !I8[u.type](D)) {
          a.remove(N);
          return;
        }
        var $ = !1;
        if (p && ($ = E8[u.type](g, D), $ && a.remove(N)), N ? ms(N) : N = M8[u.type](t, s, k, D, h, f, c.model, !!N, v), d && (N.forceLabelAnimation = !0), S) {
          var F = N.getTextContent();
          if (F) {
            var W = Rv(F);
            W.prevValue != null && (W.prevValue = W.value);
          }
        } else
          R8(N, s, k, L, D, t, h, u.type === "polar");
        x ? N.attr({
          shape: D
        }) : d ? D8(d, f, N, D, k, h, !0, S) : Vt(N, {
          shape: D
        }, t, k, null), s.setItemGraphicEl(k, N), N.ignore = $, a.add(N);
      }).remove(function(k) {
        var P = l.getItemGraphicEl(k);
        P && B0(P, t, k);
      }).execute();
      var C = this._backgroundGroup || (this._backgroundGroup = new We());
      C.removeAll();
      for (var A = 0; A < O.length; ++A)
        C.add(O[A]);
      a.add(C), this._backgroundEls = O, this._data = s;
    }, e.prototype._renderLarge = function(t, r, i) {
      this._clear(), $8(t, this.group), this._updateLargeClip(t);
    }, e.prototype._incrementalRenderLarge = function(t, r) {
      this._removeBackground(), $8(r, this.group, this._progressiveEls, !0);
    }, e.prototype._updateLargeClip = function(t) {
      var r = t.get("clip", !0) && Yb(t.coordinateSystem, !1, t), i = this.group;
      r ? i.setClipPath(r) : i.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(t, r, i) {
      var o = this;
      if (r.count()) {
        var a = t.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(r, t, i), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = r.getItemGraphicEl(l), c = u && u.shape;
            return c && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(a.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            o._updateSortWithinSameData(r, s, a, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(t, r, i) {
      var o = [];
      return t.each(t.mapDimension(r.dim), function(a, s) {
        var l = i(s);
        l = l ?? NaN, o.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: a
        });
      }), o.sort(function(a, s) {
        return s.mappedValue - a.mappedValue;
      }), {
        ordinalNumbers: le(o, function(a) {
          return a.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(t, r, i) {
      for (var o = i.scale, a = t.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = o.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = t.rawIndexOf(a, o.getRawOrdinalNumber(l)), h = c < 0 ? Number.MIN_VALUE : r(t.indexOfRawIndex(c));
        if (h > s)
          return !0;
        s = h;
      }
      return !1;
    }, e.prototype._isOrderDifferentInView = function(t, r) {
      for (var i = r.scale, o = i.getExtent(), a = Math.max(0, o[0]), s = Math.min(o[1], i.getOrdinalMeta().categories.length - 1); a <= s; ++a)
        if (t.ordinalNumbers[a] !== i.getRawOrdinalNumber(a))
          return !0;
    }, e.prototype._updateSortWithinSameData = function(t, r, i, o) {
      if (this._isOrderChangedWithinSameData(t, r, i)) {
        var a = this._dataSort(t, i, r);
        this._isOrderDifferentInView(a, i) && (this._removeOnRenderedListener(o), o.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: a
        }));
      }
    }, e.prototype._dispatchInitSort = function(t, r, i) {
      var o = r.baseAxis, a = this._dataSort(t, o, function(s) {
        return t.get(t.mapDimension(r.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: o.dim + "Axis",
        isInitSort: !0,
        axisId: o.index,
        sortInfo: a
      });
    }, e.prototype.remove = function(t, r) {
      this._clear(this._model), this._removeOnRenderedListener(r);
    }, e.prototype.dispose = function(t, r) {
      this._removeOnRenderedListener(r);
    }, e.prototype._removeOnRenderedListener = function(t) {
      this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(t) {
      var r = this.group, i = this._data;
      t && t.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(o) {
        B0(o, t, He(o).dataIndex);
      })) : r.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }(bn)
), E8 = {
  cartesian2d: function(n, e) {
    var t = e.width < 0 ? -1 : 1, r = e.height < 0 ? -1 : 1;
    t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height);
    var i = n.x + n.width, o = n.y + n.height, a = RT(e.x, n.x), s = NT(e.x + e.width, i), l = RT(e.y, n.y), u = NT(e.y + e.height, o), c = s < a, h = u < l;
    return e.x = c && a > i ? s : a, e.y = h && l > o ? u : l, e.width = c ? 0 : s - a, e.height = h ? 0 : u - l, t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height), c || h;
  },
  polar: function(n, e) {
    var t = e.r0 <= e.r ? 1 : -1;
    if (t < 0) {
      var r = e.r;
      e.r = e.r0, e.r0 = r;
    }
    var i = NT(e.r, n.r), o = RT(e.r0, n.r0);
    e.r = i, e.r0 = o;
    var a = i - o < 0;
    if (t < 0) {
      var r = e.r;
      e.r = e.r0, e.r0 = r;
    }
    return a;
  }
}, M8 = {
  cartesian2d: function(n, e, t, r, i, o, a, s, l) {
    var u = new Lt({
      shape: re({}, r),
      z2: 1
    });
    if (u.__dataIndex = t, u.name = "item", o) {
      var c = u.shape, h = i ? "height" : "width";
      c[h] = 0;
    }
    return u;
  },
  polar: function(n, e, t, r, i, o, a, s, l) {
    var u = !i && l ? $S : Eo, c = new u({
      shape: r,
      z2: 1
    });
    c.name = "item";
    var h = gre(i);
    if (c.calculateTextPosition = SPt(h, {
      isRoundCap: u === $S
    }), o) {
      var f = c.shape, d = i ? "r" : "endAngle", p = {};
      f[d] = i ? r.r0 : r.startAngle, p[d] = r[d], (s ? Vt : Cn)(c, {
        shape: p
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, o);
    }
    return c;
  }
};
function TPt(n, e) {
  var t = n.get("realtimeSort", !0), r = e.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && t && (r.type !== "category" && $n("`realtimeSort` will not work because this bar series is not based on a category axis."), e.type !== "cartesian2d" && $n("`realtimeSort` will not work because this bar series is not on cartesian2d.")), t && r.type === "category" && e.type === "cartesian2d")
    return {
      baseAxis: r,
      otherAxis: e.getOtherAxis(r)
    };
}
function D8(n, e, t, r, i, o, a, s) {
  var l, u;
  o ? (u = {
    x: r.x,
    width: r.width
  }, l = {
    y: r.y,
    height: r.height
  }) : (u = {
    y: r.y,
    height: r.height
  }, l = {
    x: r.x,
    width: r.width
  }), s || (a ? Vt : Cn)(t, {
    shape: l
  }, e, i, null);
  var c = e ? n.baseAxis.model : null;
  (a ? Vt : Cn)(t, {
    shape: u
  }, c, i);
}
function L8(n, e) {
  for (var t = 0; t < e.length; t++)
    if (!isFinite(n[e[t]]))
      return !0;
  return !1;
}
var kPt = ["x", "y", "width", "height"], PPt = ["cx", "cy", "r", "startAngle", "endAngle"], I8 = {
  cartesian2d: function(n) {
    return !L8(n, kPt);
  },
  polar: function(n) {
    return !L8(n, PPt);
  }
}, RO = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(n, e, t) {
    var r = n.getItemLayout(e), i = t ? MPt(t, r) : 0, o = r.width > 0 ? 1 : -1, a = r.height > 0 ? 1 : -1;
    return {
      x: r.x + o * i / 2,
      y: r.y + a * i / 2,
      width: r.width - o * i,
      height: r.height - a * i
    };
  },
  polar: function(n, e, t) {
    var r = n.getItemLayout(e);
    return {
      cx: r.cx,
      cy: r.cy,
      r0: r.r0,
      r: r.r,
      startAngle: r.startAngle,
      endAngle: r.endAngle,
      clockwise: r.clockwise
    };
  }
};
function EPt(n) {
  return n.startAngle != null && n.endAngle != null && n.startAngle === n.endAngle;
}
function gre(n) {
  return /* @__PURE__ */ function(e) {
    var t = e ? "Arc" : "Angle";
    return function(r) {
      switch (r) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return r + t;
        default:
          return r;
      }
    };
  }(n);
}
function R8(n, e, t, r, i, o, a, s) {
  var l = e.getItemVisual(t, "style");
  if (s) {
    if (!o.get("roundCap")) {
      var c = n.shape, h = Tf(r.getModel("itemStyle"), c, !0);
      re(c, h), n.setShape(c);
    }
  } else {
    var u = r.get(["itemStyle", "borderRadius"]) || 0;
    n.setShape("r", u);
  }
  n.useStyle(l);
  var f = r.getShallow("cursor");
  f && n.attr("cursor", f);
  var d = s ? a ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : a ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = Fr(r);
  wi(n, p, {
    labelFetcher: o,
    labelDataIndex: t,
    defaultText: Jg(o.getData(), t),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: d
  });
  var g = n.getTextContent();
  if (s && g) {
    var v = r.get(["label", "position"]);
    n.textConfig.inside = v === "middle" ? !0 : null, _Pt(n, v === "outside" ? d : v, gre(a), r.get(["label", "rotate"]));
  }
  Lee(g, p, o.getRawValue(t), function(y) {
    return are(e, y);
  });
  var m = r.getModel(["emphasis"]);
  Wn(n, m.get("focus"), m.get("blurScope"), m.get("disabled")), Oi(n, r), EPt(i) && (n.style.fill = "none", n.style.stroke = "none", I(n.states, function(y) {
    y.style && (y.style.fill = y.style.stroke = "none");
  }));
}
function MPt(n, e) {
  var t = n.get(["itemStyle", "borderColor"]);
  if (!t || t === "none")
    return 0;
  var r = n.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), o = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
  return Math.min(r, i, o);
}
var DPt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), N8 = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "largeBar", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new DPt();
    }, e.prototype.buildPath = function(t, r) {
      for (var i = r.points, o = this.baseDimIdx, a = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3)
        l[o] = u, l[a] = i[c + 2], s[o] = i[c + o], s[a] = i[c + a], t.rect(s[0], s[1], l[0], l[1]);
    }, e;
  }(gt)
);
function $8(n, e, t, r) {
  var i = n.getData(), o = i.getLayout("valueAxisHorizontal") ? 1 : 0, a = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = n.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
  if (u) {
    var c = new N8({
      shape: {
        points: u
      },
      incremental: !!r,
      silent: !0,
      z2: 0
    });
    c.baseDimIdx = o, c.largeDataIndices = a, c.barWidth = s, c.useStyle(l.getItemStyle()), e.add(c), t && t.push(c);
  }
  var h = new N8({
    shape: {
      points: i.getLayout("largePoints")
    },
    incremental: !!r,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  h.baseDimIdx = o, h.largeDataIndices = a, h.barWidth = s, e.add(h), h.useStyle(i.getVisual("style")), He(h).seriesIndex = n.seriesIndex, n.get("silent") || (h.on("mousedown", B8), h.on("mousemove", B8)), t && t.push(h);
}
var B8 = dN(function(n) {
  var e = this, t = LPt(e, n.offsetX, n.offsetY);
  He(e).dataIndex = t >= 0 ? t : null;
}, 30, !1);
function LPt(n, e, t) {
  for (var r = n.baseDimIdx, i = 1 - r, o = n.shape.points, a = n.largeDataIndices, s = [], l = [], u = n.barWidth, c = 0, h = o.length / 3; c < h; c++) {
    var f = c * 3;
    if (l[r] = u, l[i] = o[f + 2], s[r] = o[f + r], s[i] = o[f + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), e >= s[0] && e <= s[0] + l[0] && t >= s[1] && t <= s[1] + l[1])
      return a[c];
  }
  return -1;
}
function vre(n, e, t) {
  if (Nd(t, "cartesian2d")) {
    var r = e, i = t.getArea();
    return {
      x: n ? r.x : i.x,
      y: n ? i.y : r.y,
      width: n ? r.width : i.width,
      height: n ? i.height : r.height
    };
  } else {
    var i = t.getArea(), o = e;
    return {
      cx: i.cx,
      cy: i.cy,
      r0: n ? i.r0 : o.r0,
      r: n ? i.r : o.r,
      startAngle: n ? o.startAngle : 0,
      endAngle: n ? o.endAngle : Math.PI * 2
    };
  }
}
function IPt(n, e, t) {
  var r = n.type === "polar" ? Eo : Lt;
  return new r({
    shape: vre(e, t, n),
    silent: !0,
    z2: 0
  });
}
const RPt = APt;
function NPt(n) {
  n.registerChartView(RPt), n.registerSeriesModel(wPt), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Je(One, "bar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, wne("bar")), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, pre("bar")), n.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(e, t) {
    var r = e.componentType || "series";
    t.eachComponent({
      mainType: r,
      query: e
    }, function(i) {
      e.sortInfo && i.axis.setCategorySortInfo(e.sortInfo);
    });
  });
}
var V8 = Math.PI * 2, NO = Math.PI / 180;
function mre(n, e) {
  return Cr(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function yre(n, e) {
  var t = mre(n, e), r = n.get("center"), i = n.get("radius");
  se(i) || (i = [0, i]);
  var o = be(t.width, e.getWidth()), a = be(t.height, e.getHeight()), s = Math.min(o, a), l = be(i[0], s / 2), u = be(i[1], s / 2), c, h, f = n.coordinateSystem;
  if (f) {
    var d = f.dataToPoint(r);
    c = d[0] || 0, h = d[1] || 0;
  } else
    se(r) || (r = [r, r]), c = be(r[0], o) + t.x, h = be(r[1], a) + t.y;
  return {
    cx: c,
    cy: h,
    r0: l,
    r: u
  };
}
function $Pt(n, e, t) {
  e.eachSeriesByType(n, function(r) {
    var i = r.getData(), o = i.mapDimension("value"), a = mre(r, t), s = yre(r, t), l = s.cx, u = s.cy, c = s.r, h = s.r0, f = -r.get("startAngle") * NO, d = r.get("endAngle"), p = r.get("padAngle") * NO;
    d = d === "auto" ? f - V8 : -d * NO;
    var g = r.get("minAngle") * NO, v = g + p, m = 0;
    i.each(o, function(M) {
      !isNaN(M) && m++;
    });
    var y = i.getSum(o), b = Math.PI / (y || m) * 2, O = r.get("clockwise"), w = r.get("roseType"), x = r.get("stillShowZeroSum"), S = i.getDataExtent(o);
    S[0] = 0;
    var _ = O ? 1 : -1, C = [f, d], A = _ * p / 2;
    $R(C, !O), f = C[0], d = C[1];
    var k = Math.abs(d - f), P = k, L = 0, D = f;
    if (i.setLayout({
      viewRect: a,
      r: c
    }), i.each(o, function(M, R) {
      var N;
      if (isNaN(M)) {
        i.setItemLayout(R, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: O,
          cx: l,
          cy: u,
          r0: h,
          r: w ? NaN : c
        });
        return;
      }
      w !== "area" ? N = y === 0 && x ? b : M * b : N = k / m, N < v ? (N = v, P -= v) : L += M;
      var $ = D + _ * N, F = 0, W = 0;
      p > N ? (F = D + _ * N / 2, W = F) : (F = D + A, W = $ - A), i.setItemLayout(R, {
        angle: N,
        startAngle: F,
        endAngle: W,
        clockwise: O,
        cx: l,
        cy: u,
        r0: h,
        r: w ? Yt(M, S, [h, c]) : c
      }), D = $;
    }), P < V8 && m)
      if (P <= 1e-3) {
        var E = k / m;
        i.each(o, function(M, R) {
          if (!isNaN(M)) {
            var N = i.getItemLayout(R);
            N.angle = E;
            var $ = 0, F = 0;
            E < p ? ($ = f + _ * (R + 1 / 2) * E, F = $) : ($ = f + _ * R * E + A, F = f + _ * (R + 1) * E - A), N.startAngle = $, N.endAngle = F;
          }
        });
      } else
        b = P / L, D = f, i.each(o, function(M, R) {
          if (!isNaN(M)) {
            var N = i.getItemLayout(R), $ = N.angle === v ? v : M * b, F = 0, W = 0;
            $ < p ? (F = D + _ * $ / 2, W = F) : (F = D + A, W = D + _ * $ - A), N.startAngle = F, N.endAngle = W, D += _ * $;
          }
        });
  });
}
function Ub(n) {
  return {
    seriesType: n,
    reset: function(e, t) {
      var r = t.findComponents({
        mainType: "legend"
      });
      if (!(!r || !r.length)) {
        var i = e.getData();
        i.filterSelf(function(o) {
          for (var a = i.getName(o), s = 0; s < r.length; s++)
            if (!r[s].isSelected(a))
              return !1;
          return !0;
        });
      }
    }
  };
}
var BPt = Math.PI / 180;
function z8(n, e, t, r, i, o, a, s, l, u) {
  if (n.length < 2)
    return;
  function c(g) {
    for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
      var b = g.list[y], O = Math.abs(b.label.y - t), w = r + b.len, x = w * w, S = Math.sqrt((1 - Math.abs(O * O / m)) * x), _ = e + (S + b.len2) * i, C = _ - b.label.x, A = b.targetTextWidth - C * i;
      bre(b, A, !0), b.label.x = _;
    }
  }
  function h(g) {
    for (var v = {
      list: [],
      maxY: 0
    }, m = {
      list: [],
      maxY: 0
    }, y = 0; y < g.length; y++)
      if (g[y].labelAlignTo === "none") {
        var b = g[y], O = b.label.y > t ? m : v, w = Math.abs(b.label.y - t);
        if (w >= O.maxY) {
          var x = b.label.x - e - b.len2 * i, S = r + b.len, _ = Math.abs(x) < S ? Math.sqrt(w * w / (1 - x * x / S / S)) : S;
          O.rB = _, O.maxY = w;
        }
        O.list.push(b);
      }
    c(v), c(m);
  }
  for (var f = n.length, d = 0; d < f; d++)
    if (n[d].position === "outer" && n[d].labelAlignTo === "labelLine") {
      var p = n[d].label.x - u;
      n[d].linePoints[1][0] += p, n[d].label.x = u;
    }
  Zne(n, l, l + a) && h(n);
}
function VPt(n, e, t, r, i, o, a, s) {
  for (var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, f = 0; f < n.length; f++) {
    var d = n[f].label;
    $T(n[f]) || (d.x < e ? (c = Math.min(c, d.x), l.push(n[f])) : (h = Math.max(h, d.x), u.push(n[f])));
  }
  for (var f = 0; f < n.length; f++) {
    var p = n[f];
    if (!$T(p) && p.linePoints) {
      if (p.labelStyleWidth != null)
        continue;
      var d = p.label, g = p.linePoints, v = void 0;
      p.labelAlignTo === "edge" ? d.x < e ? v = g[2][0] - p.labelDistance - a - p.edgeDistance : v = a + i - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < e ? v = c - a - p.bleedMargin : v = a + i - h - p.bleedMargin : d.x < e ? v = d.x - a - p.bleedMargin : v = a + i - d.x - p.bleedMargin, p.targetTextWidth = v, bre(p, v);
    }
  }
  z8(u, e, t, r, 1, i, o, a, s, h), z8(l, e, t, r, -1, i, o, a, s, c);
  for (var f = 0; f < n.length; f++) {
    var p = n[f];
    if (!$T(p) && p.linePoints) {
      var d = p.label, g = p.linePoints, m = p.labelAlignTo === "edge", y = d.style.padding, b = y ? y[1] + y[3] : 0, O = d.style.backgroundColor ? 0 : b, w = p.rect.width + O, x = g[1][0] - g[2][0];
      m ? d.x < e ? g[2][0] = a + p.edgeDistance + w + p.labelDistance : g[2][0] = a + i - p.edgeDistance - w - p.labelDistance : (d.x < e ? g[2][0] = d.x + p.labelDistance : g[2][0] = d.x - p.labelDistance, g[1][0] = g[2][0] + x), g[1][1] = g[2][1] = d.y;
    }
  }
}
function bre(n, e, t) {
  if (t === void 0 && (t = !1), n.labelStyleWidth == null) {
    var r = n.label, i = r.style, o = n.rect, a = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = o.width + (a ? 0 : l);
    if (e < c || t) {
      var h = o.height;
      if (u && u.match("break")) {
        r.setStyle("backgroundColor", null), r.setStyle("width", e - l);
        var f = r.getBoundingRect();
        r.setStyle("width", Math.ceil(f.width)), r.setStyle("backgroundColor", a);
      } else {
        var d = e - l, p = e < c ? d : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          t ? d > n.unconstrainedWidth ? null : d : null
        );
        r.setStyle("width", p);
      }
      var g = r.getBoundingRect();
      o.width = g.width;
      var v = (r.style.margin || 0) + 2.1;
      o.height = g.height + v, o.y -= (o.height - h) / 2;
    }
  }
}
function $T(n) {
  return n.position === "center";
}
function zPt(n) {
  var e = n.getData(), t = [], r, i, o = !1, a = (n.get("minShowLabelAngle") || 0) * BPt, s = e.getLayout("viewRect"), l = e.getLayout("r"), u = s.width, c = s.x, h = s.y, f = s.height;
  function d(x) {
    x.ignore = !0;
  }
  function p(x) {
    if (!x.ignore)
      return !0;
    for (var S in x.states)
      if (x.states[S].ignore === !1)
        return !0;
    return !1;
  }
  e.each(function(x) {
    var S = e.getItemGraphicEl(x), _ = S.shape, C = S.getTextContent(), A = S.getTextGuideLine(), k = e.getItemModel(x), P = k.getModel("label"), L = P.get("position") || k.get(["emphasis", "label", "position"]), D = P.get("distanceToLabelLine"), E = P.get("alignTo"), M = be(P.get("edgeDistance"), u), R = P.get("bleedMargin"), N = k.getModel("labelLine"), $ = N.get("length");
    $ = be($, u);
    var F = N.get("length2");
    if (F = be(F, u), Math.abs(_.endAngle - _.startAngle) < a) {
      I(C.states, d), C.ignore = !0, A && (I(A.states, d), A.ignore = !0);
      return;
    }
    if (p(C)) {
      var W = (_.startAngle + _.endAngle) / 2, j = Math.cos(W), Y = Math.sin(W), X, ie, ae, ee;
      r = _.cx, i = _.cy;
      var ne = L === "inside" || L === "inner";
      if (L === "center")
        X = _.cx, ie = _.cy, ee = "center";
      else {
        var ye = (ne ? (_.r + _.r0) / 2 * j : _.r * j) + r, te = (ne ? (_.r + _.r0) / 2 * Y : _.r * Y) + i;
        if (X = ye + j * 3, ie = te + Y * 3, !ne) {
          var ue = ye + j * ($ + l - _.r), xe = te + Y * ($ + l - _.r), dt = ue + (j < 0 ? -1 : 1) * F, Ue = xe;
          E === "edge" ? X = j < 0 ? c + M : c + u - M : X = dt + (j < 0 ? -D : D), ie = Ue, ae = [[ye, te], [ue, xe], [dt, Ue]];
        }
        ee = ne ? "center" : E === "edge" ? j > 0 ? "right" : "left" : j > 0 ? "left" : "right";
      }
      var Rt = Math.PI, zt = 0, tn = P.get("rotate");
      if ($t(tn))
        zt = tn * (Rt / 180);
      else if (L === "center")
        zt = 0;
      else if (tn === "radial" || tn === !0) {
        var jn = j < 0 ? -W + Rt : -W;
        zt = jn;
      } else if (tn === "tangential" && L !== "outside" && L !== "outer") {
        var An = Math.atan2(j, Y);
        An < 0 && (An = Rt * 2 + An);
        var Tn = Y > 0;
        Tn && (An = Rt + An), zt = An - Rt;
      }
      if (o = !!zt, C.x = X, C.y = ie, C.rotation = zt, C.setStyle({
        verticalAlign: "middle"
      }), ne) {
        C.setStyle({
          align: ee
        });
        var Jr = C.states.select;
        Jr && (Jr.x += C.x, Jr.y += C.y);
      } else {
        var Un = C.getBoundingRect().clone();
        Un.applyTransform(C.getComputedTransform());
        var Vi = (C.style.margin || 0) + 2.1;
        Un.y -= Vi / 2, Un.height += Vi, t.push({
          label: C,
          labelLine: A,
          position: L,
          len: $,
          len2: F,
          minTurnAngle: N.get("minTurnAngle"),
          maxSurfaceAngle: N.get("maxSurfaceAngle"),
          surfaceNormal: new nt(j, Y),
          linePoints: ae,
          textAlign: ee,
          labelDistance: D,
          labelAlignTo: E,
          edgeDistance: M,
          bleedMargin: R,
          rect: Un,
          unconstrainedWidth: Un.width,
          labelStyleWidth: C.style.width
        });
      }
      S.setTextConfig({
        inside: ne
      });
    }
  }), !o && n.get("avoidLabelOverlap") && VPt(t, r, i, l, u, f, c, h);
  for (var g = 0; g < t.length; g++) {
    var v = t[g], m = v.label, y = v.labelLine, b = isNaN(m.x) || isNaN(m.y);
    if (m) {
      m.setStyle({
        align: v.textAlign
      }), b && (I(m.states, d), m.ignore = !0);
      var O = m.states.select;
      O && (O.x += m.x, O.y += m.y);
    }
    if (y) {
      var w = v.linePoints;
      b || !w ? (I(y.states, d), y.ignore = !0) : (zne(w, v.minTurnAngle), nkt(w, v.surfaceNormal, v.maxSurfaceAngle), y.setShape({
        points: w
      }), m.__hostTarget.textGuideLineConfig = {
        anchor: new nt(w[0][0], w[0][1])
      });
    }
  }
}
var FPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this) || this;
      o.z2 = 2;
      var a = new Nt();
      return o.setTextContent(a), o.updateData(t, r, i, !0), o;
    }
    return e.prototype.updateData = function(t, r, i, o) {
      var a = this, s = t.hostModel, l = t.getItemModel(r), u = l.getModel("emphasis"), c = t.getItemLayout(r), h = re(Tf(l.getModel("itemStyle"), c, !0), c);
      if (isNaN(h.startAngle)) {
        a.setShape(h);
        return;
      }
      if (o) {
        a.setShape(h);
        var f = s.getShallow("animationType");
        s.ecModel.ssr ? (Cn(a, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: r,
          isFrom: !0
        }), a.originX = h.cx, a.originY = h.cy) : f === "scale" ? (a.shape.r = c.r0, Cn(a, {
          shape: {
            r: c.r
          }
        }, s, r)) : i != null ? (a.setShape({
          startAngle: i,
          endAngle: i
        }), Cn(a, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, r)) : (a.shape.endAngle = c.startAngle, Vt(a, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, r));
      } else
        ms(a), Vt(a, {
          shape: h
        }, s, r);
      a.useStyle(t.getItemVisual(r, "style")), Oi(a, l);
      var d = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), g = Math.cos(d) * p, v = Math.sin(d) * p, m = l.getShallow("cursor");
      m && a.attr("cursor", m), this._updateLabel(s, t, r), a.ensureState("emphasis").shape = re({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Tf(u.getModel("itemStyle"), c)), re(a.ensureState("select"), {
        x: g,
        y: v,
        shape: Tf(l.getModel(["select", "itemStyle"]), c)
      }), re(a.ensureState("blur"), {
        shape: Tf(l.getModel(["blur", "itemStyle"]), c)
      });
      var y = a.getTextGuideLine(), b = a.getTextContent();
      y && re(y.ensureState("select"), {
        x: g,
        y: v
      }), re(b.ensureState("select"), {
        x: g,
        y: v
      }), Wn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, r, i) {
      var o = this, a = r.getItemModel(i), s = a.getModel("labelLine"), l = r.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      wi(o, Fr(a), {
        labelFetcher: r.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: t.getFormattedLabel(i, "normal") || r.getName(i)
      });
      var h = o.getTextContent();
      o.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), h.attr({
        z2: 10
      });
      var f = t.get(["label", "position"]);
      if (f !== "outside" && f !== "outer")
        o.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new io(), this.setTextGuideLine(d)), TN(this, kN(a), {
          stroke: u,
          opacity: Aa(s.get(["lineStyle", "opacity"]), c, 1)
        });
      }
    }, e;
  }(Eo)
), QPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, r, i, o) {
      var a = t.getData(), s = this._data, l = this.group, u;
      if (!s && a.count() > 0) {
        for (var c = a.getItemLayout(0), h = 1; isNaN(c && c.startAngle) && h < a.count(); ++h)
          c = a.getItemLayout(h);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), a.count() === 0 && t.get("showEmptyCircle")) {
        var f = new Eo({
          shape: yre(t, i)
        });
        f.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = f, l.add(f);
      }
      a.diff(s).add(function(d) {
        var p = new FPt(a, d, u);
        a.setItemGraphicEl(d, p), l.add(p);
      }).update(function(d, p) {
        var g = s.getItemGraphicEl(p);
        g.updateData(a, d, u), g.off("click"), l.add(g), a.setItemGraphicEl(d, g);
      }).remove(function(d) {
        var p = s.getItemGraphicEl(d);
        B0(p, t, d);
      }).execute(), zPt(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = a);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(t, r) {
      var i = r.getData(), o = i.getItemLayout(0);
      if (o) {
        var a = t[0] - o.cx, s = t[1] - o.cy, l = Math.sqrt(a * a + s * s);
        return l <= o.r && l >= o.r0;
      }
    }, e.type = "pie", e;
  }(bn)
);
const ZPt = QPt;
function Gv(n, e, t) {
  e = se(e) && {
    coordDimensions: e
  } || re({
    encodeDefine: n.getEncode()
  }, e);
  var r = n.getSource(), i = Wb(r, e).dimensions, o = new Ki(i, n);
  return o.initData(r, t), o;
}
var WPt = (
  /** @class */
  function() {
    function n(e, t) {
      this._getDataWithEncodedVisual = e, this._getRawData = t;
    }
    return n.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, n.prototype.containName = function(e) {
      var t = this._getRawData();
      return t.indexOfName(e) >= 0;
    }, n.prototype.indexOfName = function(e) {
      var t = this._getDataWithEncodedVisual();
      return t.indexOfName(e);
    }, n.prototype.getItemVisual = function(e, t) {
      var r = this._getDataWithEncodedVisual();
      return r.getItemVisual(e, t);
    }, n;
  }()
);
const Kb = WPt;
var GPt = It(), jPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Kb(_e(this.getData, this), _e(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.mergeOption = function() {
      n.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return Gv(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Je(nN, this)
      });
    }, e.prototype.getDataParams = function(t) {
      var r = this.getData(), i = GPt(r), o = i.seats;
      if (!o) {
        var a = [];
        r.each(r.mapDimension("value"), function(l) {
          a.push(l);
        }), o = i.seats = uxt(a, r.hostModel.get("percentPrecision"));
      }
      var s = n.prototype.getDataParams.call(this, t);
      return s.percent = o[t] || 0, s.$vars.push("percent"), s;
    }, e.prototype._defaultLabelLine = function(t) {
      hd(t, "labelLine", ["show"]);
      var r = t.labelLine, i = t.emphasis.labelLine;
      r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 最小角度改为0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 选中时扇区偏移量
      selectedOffset: 10,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调
        // 默认使用全局文本样式，详见 textStyle
        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 引导线两段中的第一段长度
        length: 15,
        // 引导线两段中的第二段长度
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(Ln)
);
const HPt = jPt;
function qPt(n) {
  return {
    seriesType: n,
    reset: function(e, t) {
      var r = e.getData();
      r.filterSelf(function(i) {
        var o = r.mapDimension("value"), a = r.get(o, i);
        return !($t(a) && !isNaN(a) && a < 0);
      });
    }
  };
}
function YPt(n) {
  n.registerChartView(ZPt), n.registerSeriesModel(HPt), Bte("pie", n.registerAction), n.registerLayout(Je($Pt, "pie")), n.registerProcessor(Ub("pie")), n.registerProcessor(qPt("pie"));
}
var XPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return ku(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.point(r.getItemLayout(t));
    }, e.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, e.type = "series.scatter", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 图形旋转控制
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 各异
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, e;
  }(Ln)
);
const UPt = XPt;
var Ore = 4, KPt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), JPt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return e.prototype.getDefaultShape = function() {
      return new KPt();
    }, e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, o = r.size, a = this.symbolProxy, s = a.shape, l = t.getContext ? t.getContext() : t, u = l && o[0] < Ore, c = this.softClipShape, h;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, h = this._off; h < i.length; ) {
        var f = i[h++], d = i[h++];
        isNaN(f) || isNaN(d) || c && !c.contain(f, d) || (s.x = f - o[0] / 2, s.y = d - o[1] / 2, s.width = o[0], s.height = o[1], a.buildPath(t, s, !0));
      }
      this.incremental && (this._off = h, this.notClear = !0);
    }, e.prototype.afterBrush = function() {
      var t = this.shape, r = t.points, i = t.size, o = this._ctx, a = this.softClipShape, s;
      if (o) {
        for (s = this._off; s < r.length; ) {
          var l = r[s++], u = r[s++];
          isNaN(l) || isNaN(u) || a && !a.contain(l, u) || o.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, e.prototype.findDataIndex = function(t, r) {
      for (var i = this.shape, o = i.points, a = i.size, s = Math.max(a[0], 4), l = Math.max(a[1], 4), u = o.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, h = o[c] - s / 2, f = o[c + 1] - l / 2;
        if (t >= h && r >= f && t <= h + s && r <= f + l)
          return u;
      }
      return -1;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), o = this.getBoundingRect();
      if (t = i[0], r = i[1], o.contain(t, r)) {
        var a = this.hoverDataIdx = this.findDataIndex(t, r);
        return a >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var r = this.shape, i = r.points, o = r.size, a = o[0], s = o[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, h = -1 / 0, f = 0; f < i.length; ) {
          var d = i[f++], p = i[f++];
          l = Math.min(d, l), c = Math.max(d, c), u = Math.min(p, u), h = Math.max(p, h);
        }
        t = this._rect = new ot(l - a / 2, u - s / 2, c - l + a, h - u + s);
      }
      return t;
    }, e;
  }(gt)
), eEt = (
  /** @class */
  function() {
    function n() {
      this.group = new We();
    }
    return n.prototype.updateData = function(e, t) {
      this._clear();
      var r = this._create();
      r.setShape({
        points: e.getLayout("points")
      }), this._setCommon(r, e, t);
    }, n.prototype.updateLayout = function(e) {
      var t = e.getLayout("points");
      this.group.eachChild(function(r) {
        if (r.startIndex != null) {
          var i = (r.endIndex - r.startIndex) * 2, o = r.startIndex * 4 * 2;
          t = new Float32Array(t.buffer, o, i);
        }
        r.setShape("points", t), r.reset();
      });
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._clear();
    }, n.prototype.incrementalUpdate = function(e, t, r) {
      var i = this._newAdded[0], o = t.getLayout("points"), a = i && i.shape.points;
      if (a && a.length < 2e4) {
        var s = a.length, l = new Float32Array(s + o.length);
        l.set(a), l.set(o, s), i.endIndex = e.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = e.start, u.endIndex = e.end, u.incremental = !0, u.setShape({
          points: o
        }), this._setCommon(u, t, r);
      }
    }, n.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, n.prototype._create = function() {
      var e = new JPt({
        cursor: "default"
      });
      return e.ignoreCoarsePointer = !0, this.group.add(e), this._newAdded.push(e), e;
    }, n.prototype._setCommon = function(e, t, r) {
      var i = t.hostModel;
      r = r || {};
      var o = t.getVisual("symbolSize");
      e.setShape("size", o instanceof Array ? o : [o, o]), e.softClipShape = r.clipShape || null, e.symbolProxy = vr(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
      var a = e.shape.size[0] < Ore;
      e.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        i.getModel("itemStyle").getItemStyle(a ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = t.getVisual("style"), l = s && s.fill;
      l && e.setColor(l);
      var u = He(e);
      u.seriesIndex = i.seriesIndex, e.on("mousemove", function(c) {
        u.dataIndex = null;
        var h = e.hoverDataIdx;
        h >= 0 && (u.dataIndex = h + (e.startIndex || 0));
      });
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }()
), tEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = t.getData(), a = this._updateSymbolDraw(o, t);
      a.updateData(o, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(t)
      }), this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      var o = t.getData(), a = this._updateSymbolDraw(o, t);
      a.incrementalPrepareUpdate(o), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, r, i) {
      this._symbolDraw.incrementalUpdate(t, r.getData(), {
        clipShape: this._getClipShape(r)
      }), this._finished = t.end === r.getData().count();
    }, e.prototype.updateTransform = function(t, r, i) {
      var o = t.getData();
      if (this.group.dirty(), !this._finished || o.count() > 1e4)
        return {
          update: !0
        };
      var a = Xb("").reset(t, r, i);
      a.progress && a.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._symbolDraw.updateLayout(o);
    }, e.prototype.eachRendered = function(t) {
      this._symbolDraw && this._symbolDraw.eachRendered(t);
    }, e.prototype._getClipShape = function(t) {
      if (t.get("clip", !0)) {
        var r = t.coordinateSystem;
        return r && r.getArea && r.getArea(0.1);
      }
    }, e.prototype._updateSymbolDraw = function(t, r) {
      var i = this._symbolDraw, o = r.pipelineContext, a = o.large;
      return (!i || a !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = a ? new eEt() : new qb(), this._isLargeDraw = a, this.group.removeAll()), this.group.add(i.group), i;
    }, e.prototype.remove = function(t, r) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, e.prototype.dispose = function() {
    }, e.type = "scatter", e;
  }(bn)
);
const nEt = tEt;
var rEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = ["xAxis", "yAxis"], e.layoutMode = "box", e.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(Pt)
);
const iEt = rEt;
var gD = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", cr).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(Pt)
);
mr(gD, jb);
var wre = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, oEt = it({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, wre), IN = it({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, wre), aEt = it({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, IN), sEt = Be({
  logBase: 10
}, IN);
const xre = {
  category: oEt,
  value: IN,
  time: aEt,
  log: sEt
};
var lEt = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function ev(n, e, t, r) {
  I(lEt, function(i, o) {
    var a = it(it({}, xre[o], !0), r, !0), s = (
      /** @class */
      function(l) {
        H(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = e + "Axis." + o, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, h) {
          var f = z0(this), d = f ? Bv(c) : {}, p = h.getTheme();
          it(c, p.get(o + "Axis")), it(c, this.getDefaultOption()), c.type = F8(c), f && Xc(c, d, f);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = lD.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var h = this.option;
          if (h.type === "category")
            return c ? h.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + o, u.defaultOption = a, u;
      }(t)
    );
    n.registerComponentModel(s);
  }), n.registerSubTypeDefaulter(e + "Axis", F8);
}
function F8(n) {
  return n.type || (n.data ? "category" : "value");
}
var uEt = (
  /** @class */
  function() {
    function n(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return n.prototype.getAxis = function(e) {
      return this._axes[e];
    }, n.prototype.getAxes = function() {
      return le(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, n.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), en(this.getAxes(), function(t) {
        return t.scale.type === e;
      });
    }, n.prototype.addAxis = function(e) {
      var t = e.dim;
      this._axes[t] = e, this._dimList.push(t);
    }, n;
  }()
);
const cEt = uEt;
var vD = ["x", "y"];
function Q8(n) {
  return n.type === "interval" || n.type === "time";
}
var hEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "cartesian2d", t.dimensions = vD, t;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var t = this.getAxis("x").scale, r = this.getAxis("y").scale;
      if (!(!Q8(t) || !Q8(r))) {
        var i = t.getExtent(), o = r.getExtent(), a = this.dataToPoint([i[0], o[0]]), s = this.dataToPoint([i[1], o[1]]), l = i[1] - i[0], u = o[1] - o[0];
        if (!(!l || !u)) {
          var c = (s[0] - a[0]) / l, h = (s[1] - a[1]) / u, f = a[0] - i[0] * c, d = a[1] - o[0] * h, p = this._transform = [c, 0, 0, h, f, d];
          this._invTransform = Ev([], p);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(t) {
      var r = this.getAxis("x"), i = this.getAxis("y");
      return r.contain(r.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
    }, e.prototype.containData = function(t) {
      return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
    }, e.prototype.containZone = function(t, r) {
      var i = this.dataToPoint(t), o = this.dataToPoint(r), a = this.getArea(), s = new ot(i[0], i[1], o[0] - i[0], o[1] - i[1]);
      return a.intersect(s);
    }, e.prototype.dataToPoint = function(t, r, i) {
      i = i || [];
      var o = t[0], a = t[1];
      if (this._transform && o != null && isFinite(o) && a != null && isFinite(a))
        return vi(i, t, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(o, r)), i[1] = l.toGlobalCoord(l.dataToCoord(a, r)), i;
    }, e.prototype.clampData = function(t, r) {
      var i = this.getAxis("x").scale, o = this.getAxis("y").scale, a = i.getExtent(), s = o.getExtent(), l = i.parse(t[0]), u = o.parse(t[1]);
      return r = r || [], r[0] = Math.min(Math.max(Math.min(a[0], a[1]), l), Math.max(a[0], a[1])), r[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), r;
    }, e.prototype.pointToData = function(t, r) {
      var i = [];
      if (this._invTransform)
        return vi(i, t, this._invTransform);
      var o = this.getAxis("x"), a = this.getAxis("y");
      return i[0] = o.coordToData(o.toLocalCoord(t[0]), r), i[1] = a.coordToData(a.toLocalCoord(t[1]), r), i;
    }, e.prototype.getOtherAxis = function(t) {
      return this.getAxis(t.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function(t) {
      t = t || 0;
      var r = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), o = Math.min(r[0], r[1]) - t, a = Math.min(i[0], i[1]) - t, s = Math.max(r[0], r[1]) - o + t, l = Math.max(i[0], i[1]) - a + t;
      return new ot(o, a, s, l);
    }, e;
  }(cEt)
), fEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i, o, a) {
      var s = n.call(this, t, r, i) || this;
      return s.index = 0, s.type = o || "value", s.position = a || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.getGlobalExtent = function(t) {
      var r = this.getExtent();
      return r[0] = this.toGlobalCoord(r[0]), r[1] = this.toGlobalCoord(r[1]), t && r[0] > r[1] && r.reverse(), r;
    }, e.prototype.pointToData = function(t, r) {
      return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), r);
    }, e.prototype.setCategorySortInfo = function(t) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
    }, e;
  }(As)
);
const dEt = fEt;
function mD(n, e, t) {
  t = t || {};
  var r = n.coordinateSystem, i = e.axis, o = {}, a = i.getAxesOnZeroOf()[0], s = i.position, l = a ? "onZero" : s, u = i.dim, c = r.getRect(), h = [c.x, c.x + c.width, c.y, c.y + c.height], f = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, d = e.get("offset") || 0, p = u === "x" ? [h[2] - d, h[3] + d] : [h[0] - d, h[1] + d];
  if (a) {
    var g = a.toGlobalCoord(a.dataToCoord(0));
    p[f.onZero] = Math.max(Math.min(g, p[1]), p[0]);
  }
  o.position = [u === "y" ? p[f[l]] : h[0], u === "x" ? p[f[l]] : h[3]], o.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  o.labelDirection = o.tickDirection = o.nameDirection = v[s], o.labelOffset = a ? p[f[s]] - p[f.onZero] : 0, e.get(["axisTick", "inside"]) && (o.tickDirection = -o.tickDirection), ur(t.labelInside, e.get(["axisLabel", "inside"])) && (o.labelDirection = -o.labelDirection);
  var m = e.get(["axisLabel", "rotate"]);
  return o.labelRotate = l === "top" ? -m : m, o.z2 = 1, o;
}
function Z8(n) {
  return n.get("coordinateSystem") === "cartesian2d";
}
function W8(n) {
  var e = {
    xAxisModel: null,
    yAxisModel: null
  };
  return I(e, function(t, r) {
    var i = r.replace(/Model$/, ""), o = n.getReferringComponents(i, cr).models[0];
    if (process.env.NODE_ENV !== "production" && !o)
      throw new Error(i + ' "' + Aa(n.get(i + "Index"), n.get(i + "Id"), 0) + '" not found');
    e[r] = o;
  }), e;
}
var BT = Math.log;
function Sre(n, e, t) {
  var r = Kc.prototype, i = r.getTicks.call(t), o = r.getTicks.call(t, !0), a = i.length - 1, s = r.getInterval.call(t), l = kne(n, e), u = l.extent, c = l.fixMin, h = l.fixMax;
  if (n.type === "log") {
    var f = BT(n.base);
    u = [BT(u[0]) / f, BT(u[1]) / f];
  }
  n.setExtent(u[0], u[1]), n.calcNiceExtent({
    splitNumber: a,
    fixMin: c,
    fixMax: h
  });
  var d = r.getExtent.call(n);
  c && (u[0] = d[0]), h && (u[1] = d[1]);
  var p = r.getInterval.call(n), g = u[0], v = u[1];
  if (c && h)
    p = (v - g) / a;
  else if (c)
    for (v = u[0] + p * a; v < u[1] && isFinite(v) && isFinite(u[1]); )
      p = ST(p), v = u[0] + p * a;
  else if (h)
    for (g = u[1] - p * a; g > u[0] && isFinite(g) && isFinite(u[0]); )
      p = ST(p), g = u[1] - p * a;
  else {
    var m = n.getTicks().length - 1;
    m > a && (p = ST(p));
    var y = p * a;
    v = Math.ceil(u[1] / p) * p, g = qn(v - y), g < 0 && u[0] >= 0 ? (g = 0, v = qn(y)) : v > 0 && u[1] <= 0 && (v = 0, g = -qn(y));
  }
  var b = (i[0].value - o[0].value) / s, O = (i[a].value - o[a].value) / s;
  if (r.setExtent.call(n, g + p * b, v + p * O), r.setInterval.call(n, p), (b || O) && r.setNiceExtent.call(n, g + p, v - p), process.env.NODE_ENV !== "production") {
    var w = r.getTicks.call(n);
    w[1] && (!sTt(p) || LM(w[1].value) > LM(p)) && $n(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + e.get("min") + ", max: " + e.get("max") + " and alignTicks: true"
    );
  }
}
var pEt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = vD, this._initCartesian(e, t, r), this.model = e;
    }
    return n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.update = function(e, t) {
      var r = this._axesMap;
      this._updateScale(e, this.model);
      function i(a) {
        var s, l = Ot(a), u = l.length;
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var f = +l[h], d = a[f], p = d.model, g = d.scale;
            // Only value and log axis without interval support alignTicks.
            uD(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(d) : (Kg(g, p), uD(g) && (s = d));
          }
          c.length && (s || (s = c.pop(), Kg(s.scale, s.model)), I(c, function(v) {
            Sre(v.scale, v.model, s.scale);
          }));
        }
      }
      i(r.x), i(r.y);
      var o = {};
      I(r.x, function(a) {
        G8(r, "y", a, o);
      }), I(r.y, function(a) {
        G8(r, "x", a, o);
      }), this.resize(this.model, t);
    }, n.prototype.resize = function(e, t, r) {
      var i = e.getBoxLayoutParams(), o = !r && e.get("containLabel"), a = Cr(i, {
        width: t.getWidth(),
        height: t.getHeight()
      });
      this._rect = a;
      var s = this._axesList;
      l(), o && (I(s, function(u) {
        if (!u.model.get(["axisLabel", "inside"])) {
          var c = DTt(u);
          if (c) {
            var h = u.isHorizontal() ? "height" : "width", f = u.model.get(["axisLabel", "margin"]);
            a[h] -= c[h] + f, u.position === "top" ? a.y += c.height + f : u.position === "left" && (a.x += c.width + f);
          }
        }
      }), l()), I(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        I(s, function(u) {
          var c = u.isHorizontal(), h = c ? [0, a.width] : [0, a.height], f = u.inverse ? 1 : 0;
          u.setExtent(h[f], h[1 - f]), gEt(u, c ? a.x : a.y);
        });
      }
    }, n.prototype.getAxis = function(e, t) {
      var r = this._axesMap[e];
      if (r != null)
        return r[t || 0];
    }, n.prototype.getAxes = function() {
      return this._axesList.slice();
    }, n.prototype.getCartesian = function(e, t) {
      if (e != null && t != null) {
        var r = "x" + e + "y" + t;
        return this._coordsMap[r];
      }
      Ne(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
      for (var i = 0, o = this._coordsList; i < o.length; i++)
        if (o[i].getAxis("x").index === e || o[i].getAxis("y").index === t)
          return o[i];
    }, n.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.dataToPoint(r) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(r)) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.pointToData(r) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(r)) : null;
    }, n.prototype._findConvertTarget = function(e) {
      var t = e.seriesModel, r = e.xAxisModel || t && t.getReferringComponents("xAxis", cr).models[0], i = e.yAxisModel || t && t.getReferringComponents("yAxis", cr).models[0], o = e.gridModel, a = this._coordsList, s, l;
      if (t)
        s = t.coordinateSystem, ct(a, s) < 0 && (s = null);
      else if (r && i)
        s = this.getCartesian(r.componentIndex, i.componentIndex);
      else if (r)
        l = this.getAxis("x", r.componentIndex);
      else if (i)
        l = this.getAxis("y", i.componentIndex);
      else if (o) {
        var u = o.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, n.prototype.containPoint = function(e) {
      var t = this._coordsList[0];
      if (t)
        return t.containPoint(e);
    }, n.prototype._initCartesian = function(e, t, r) {
      var i = this, o = this, a = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, I(s.x, function(c, h) {
        I(s.y, function(f, d) {
          var p = "x" + h + "y" + d, g = new hEt(p);
          g.master = i, g.model = e, i._coordsMap[p] = g, i._coordsList.push(g), g.addAxis(c), g.addAxis(f);
        });
      });
      function u(c) {
        return function(h, f) {
          if (VT(h, e)) {
            var d = h.get("position");
            c === "x" ? d !== "top" && d !== "bottom" && (d = a.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = a.left ? "right" : "left"), a[d] = !0;
            var p = new dEt(c, ZC(h), [0, 0], h.get("type"), d), g = p.type === "category";
            p.onBand = g && h.get("boundaryGap"), p.inverse = h.get("inverse"), h.axis = p, p.model = h, p.grid = o, p.index = f, o._axesList.push(p), s[c][f] = p, l[c]++;
          }
        };
      }
    }, n.prototype._updateScale = function(e, t) {
      I(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var o = i.model.get("categorySortInfo");
          i.scale.setSortInfo(o);
        }
      }), e.eachSeries(function(i) {
        if (Z8(i)) {
          var o = W8(i), a = o.xAxisModel, s = o.yAxisModel;
          if (!VT(a, t) || !VT(s, t))
            return;
          var l = this.getCartesian(a.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), h = l.getAxis("y");
          r(u, c), r(u, h);
        }
      }, this);
      function r(i, o) {
        I(LS(i, o.dim), function(a) {
          o.scale.unionExtentFromData(i, a);
        });
      }
    }, n.prototype.getTooltipAxes = function(e) {
      var t = [], r = [];
      return I(this.getCartesians(), function(i) {
        var o = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(), a = i.getOtherAxis(o);
        ct(t, o) < 0 && t.push(o), ct(r, a) < 0 && r.push(a);
      }), {
        baseAxes: t,
        otherAxes: r
      };
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("grid", function(i, o) {
        var a = new n(i, e, t);
        a.name = "grid_" + o, a.resize(i, t, !0), i.coordinateSystem = a, r.push(a);
      }), e.eachSeries(function(i) {
        if (Z8(i)) {
          var o = W8(i), a = o.xAxisModel, s = o.yAxisModel, l = a.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!l)
              throw new Error('Grid "' + Aa(a.get("gridIndex"), a.get("gridId"), 0) + '" not found');
            if (a.getCoordSysModel() !== s.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(a.componentIndex, s.componentIndex);
        }
      }), r;
    }, n.dimensions = vD, n;
  }()
);
function VT(n, e) {
  return n.getCoordSysModel() === e;
}
function G8(n, e, t, r) {
  t.getAxesOnZeroOf = function() {
    return o ? [o] : [];
  };
  var i = n[e], o, a = t.model, s = a.get(["axisLine", "onZero"]), l = a.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    j8(i[l]) && (o = i[l]);
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && j8(i[u]) && !r[c(i[u])]) {
        o = i[u];
        break;
      }
  o && (r[c(o)] = !0);
  function c(h) {
    return h.dim + "_" + h.index;
  }
}
function j8(n) {
  return n && n.type !== "category" && n.type !== "time" && MTt(n);
}
function gEt(n, e) {
  var t = n.getExtent(), r = t[0] + t[1];
  n.toGlobalCoord = n.dim === "x" ? function(i) {
    return i + e;
  } : function(i) {
    return r - i + e;
  }, n.toLocalCoord = n.dim === "x" ? function(i) {
    return i - e;
  } : function(i) {
    return r - i + e;
  };
}
const vEt = pEt;
var yc = Math.PI, Ji = (
  /** @class */
  function() {
    function n(e, t) {
      this.group = new We(), this.opt = t, this.axisModel = e, Be(t, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var r = new We({
        x: t.position[0],
        y: t.position[1],
        rotation: t.rotation
      });
      r.updateTransform(), this._transformGroup = r;
    }
    return n.prototype.hasBuilder = function(e) {
      return !!H8[e];
    }, n.prototype.add = function(e) {
      H8[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, n.prototype.getGroup = function() {
      return this.group;
    }, n.innerTextLayout = function(e, t, r) {
      var i = MJ(t - e), o, a;
      return R0(i) ? (a = r > 0 ? "top" : "bottom", o = "center") : R0(i - yc) ? (a = r > 0 ? "bottom" : "top", o = "center") : (a = "middle", i > 0 && i < yc ? o = r > 0 ? "right" : "left" : o = r > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: o,
        textVerticalAlign: a
      };
    }, n.makeAxisEventDataBase = function(e) {
      var t = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return t[e.mainType + "Index"] = e.componentIndex, t;
    }, n.isLabelSilent = function(e) {
      var t = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || t && t.show);
    }, n;
  }()
), H8 = {
  axisLine: function(n, e, t, r) {
    var i = e.get(["axisLine", "show"]);
    if (i === "auto" && n.handleAutoShown && (i = n.handleAutoShown("axisLine")), !!i) {
      var o = e.axis.getExtent(), a = r.transform, s = [o[0], 0], l = [o[1], 0], u = s[0] > l[0];
      a && (vi(s, s, a), vi(l, l, a));
      var c = re({
        lineCap: "round"
      }, e.getModel(["axisLine", "lineStyle"]).getLineStyle()), h = new Br({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: l[0],
          y2: l[1]
        },
        style: c,
        strokeContainThreshold: n.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      Yg(h.shape, h.style.lineWidth), h.anid = "line", t.add(h);
      var f = e.get(["axisLine", "symbol"]);
      if (f != null) {
        var d = e.get(["axisLine", "symbolSize"]);
        we(f) && (f = [f, f]), (we(d) || $t(d)) && (d = [d, d]);
        var p = Id(e.get(["axisLine", "symbolOffset"]) || 0, d), g = d[0], v = d[1];
        I([{
          rotate: n.rotation + Math.PI / 2,
          offset: p[0],
          r: 0
        }, {
          rotate: n.rotation - Math.PI / 2,
          offset: p[1],
          r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
        }], function(m, y) {
          if (f[y] !== "none" && f[y] != null) {
            var b = vr(f[y], -g / 2, -v / 2, g, v, c.stroke, !0), O = m.r + m.offset, w = u ? l : s;
            b.attr({
              rotation: m.rotate,
              x: w[0] + O * Math.cos(n.rotation),
              y: w[1] - O * Math.sin(n.rotation),
              silent: !0,
              z2: 11
            }), t.add(b);
          }
        });
      }
    }
  },
  axisTickLabel: function(n, e, t, r) {
    var i = bEt(t, r, e, n), o = wEt(t, r, e, n);
    if (yEt(e, o, i), OEt(t, r, e, n.tickDirection), e.get(["axisLabel", "hideOverlap"])) {
      var a = Fne(le(o, function(s) {
        return {
          label: s,
          priority: s.z2,
          defaultAttr: {
            ignore: s.ignore
          }
        };
      }));
      Wne(a);
    }
  },
  axisName: function(n, e, t, r) {
    var i = ur(n.axisName, e.get("name"));
    if (i) {
      var o = e.get("nameLocation"), a = n.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, h = [
        o === "start" ? u[0] - c * l : o === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
        // Reuse labelOffset.
        Y8(o) ? n.labelOffset + a * l : 0
      ], f, d = e.get("nameRotate");
      d != null && (d = d * yc / 180);
      var p;
      Y8(o) ? f = Ji.innerTextLayout(
        n.rotation,
        d ?? n.rotation,
        // Adapt to axis.
        a
      ) : (f = mEt(n.rotation, o, d || 0, u), p = n.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(f.rotation)), !isFinite(p) && (p = null)));
      var g = s.getFont(), v = e.get("nameTruncate", !0) || {}, m = v.ellipsis, y = ur(n.nameTruncateMaxWidth, v.maxWidth, p), b = new Nt({
        x: h[0],
        y: h[1],
        rotation: f.rotation,
        silent: Ji.isLabelSilent(e),
        style: vn(s, {
          text: i,
          font: g,
          overflow: "truncate",
          width: y,
          ellipsis: m,
          fill: s.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          align: s.get("align") || f.textAlign,
          verticalAlign: s.get("verticalAlign") || f.textVerticalAlign
        }),
        z2: 1
      });
      if (Iv({
        el: b,
        componentModel: e,
        itemName: i
      }), b.__fullText = i, b.anid = "name", e.get("triggerEvent")) {
        var O = Ji.makeAxisEventDataBase(e);
        O.targetType = "axisName", O.name = i, He(b).eventData = O;
      }
      r.add(b), b.updateTransform(), t.add(b), b.decomposeTransform();
    }
  }
};
function mEt(n, e, t, r) {
  var i = MJ(t - n), o, a, s = r[0] > r[1], l = e === "start" && !s || e !== "start" && s;
  return R0(i - yc / 2) ? (a = l ? "bottom" : "top", o = "center") : R0(i - yc * 1.5) ? (a = l ? "top" : "bottom", o = "center") : (a = "middle", i < yc * 1.5 && i > yc / 2 ? o = l ? "left" : "right" : o = l ? "right" : "left"), {
    rotation: i,
    textAlign: o,
    textVerticalAlign: a
  };
}
function yEt(n, e, t) {
  if (!Pne(n.axis)) {
    var r = n.get(["axisLabel", "showMinLabel"]), i = n.get(["axisLabel", "showMaxLabel"]);
    e = e || [], t = t || [];
    var o = e[0], a = e[1], s = e[e.length - 1], l = e[e.length - 2], u = t[0], c = t[1], h = t[t.length - 1], f = t[t.length - 2];
    r === !1 ? (ta(o), ta(u)) : q8(o, a) && (r ? (ta(a), ta(c)) : (ta(o), ta(u))), i === !1 ? (ta(s), ta(h)) : q8(l, s) && (i ? (ta(l), ta(f)) : (ta(s), ta(h)));
  }
}
function ta(n) {
  n && (n.ignore = !0);
}
function q8(n, e) {
  var t = n && n.getBoundingRect().clone(), r = e && e.getBoundingRect().clone();
  if (!(!t || !r)) {
    var i = pC([]);
    return Md(i, i, -n.rotation), t.applyTransform(eu([], i, n.getLocalTransform())), r.applyTransform(eu([], i, e.getLocalTransform())), t.intersect(r);
  }
}
function Y8(n) {
  return n === "middle" || n === "center";
}
function _re(n, e, t, r, i) {
  for (var o = [], a = [], s = [], l = 0; l < n.length; l++) {
    var u = n[l].coord;
    a[0] = u, a[1] = 0, s[0] = u, s[1] = t, e && (vi(a, a, e), vi(s, s, e));
    var c = new Br({
      shape: {
        x1: a[0],
        y1: a[1],
        x2: s[0],
        y2: s[1]
      },
      style: r,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    Yg(c.shape, c.style.lineWidth), c.anid = i + "_" + n[l].tickValue, o.push(c);
  }
  return o;
}
function bEt(n, e, t, r) {
  var i = t.axis, o = t.getModel("axisTick"), a = o.get("show");
  if (a === "auto" && r.handleAutoShown && (a = r.handleAutoShown("axisTick")), !(!a || i.scale.isBlank())) {
    for (var s = o.getModel("lineStyle"), l = r.tickDirection * o.get("length"), u = i.getTicksCoords(), c = _re(u, e.transform, l, Be(s.getLineStyle(), {
      stroke: t.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), h = 0; h < c.length; h++)
      n.add(c[h]);
    return c;
  }
}
function OEt(n, e, t, r) {
  var i = t.axis, o = t.getModel("minorTick");
  if (!(!o.get("show") || i.scale.isBlank())) {
    var a = i.getMinorTicksCoords();
    if (a.length)
      for (var s = o.getModel("lineStyle"), l = r * o.get("length"), u = Be(s.getLineStyle(), Be(t.getModel("axisTick").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })), c = 0; c < a.length; c++)
        for (var h = _re(a[c], e.transform, l, u, "minorticks_" + c), f = 0; f < h.length; f++)
          n.add(h[f]);
  }
}
function wEt(n, e, t, r) {
  var i = t.axis, o = ur(r.axisLabelShow, t.get(["axisLabel", "show"]));
  if (!(!o || i.scale.isBlank())) {
    var a = t.getModel("axisLabel"), s = a.get("margin"), l = i.getViewLabels(), u = (ur(r.labelRotate, a.get("rotate")) || 0) * yc / 180, c = Ji.innerTextLayout(r.rotation, u, r.labelDirection), h = t.getCategories && t.getCategories(!0), f = [], d = Ji.isLabelSilent(t), p = t.get("triggerEvent");
    return I(l, function(g, v) {
      var m = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, y = g.formattedLabel, b = g.rawLabel, O = a;
      if (h && h[m]) {
        var w = h[m];
        Ne(w) && w.textStyle && (O = new mn(w.textStyle, a, t.ecModel));
      }
      var x = O.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), S = i.dataToCoord(m), _ = O.getShallow("align", !0) || c.textAlign, C = qe(O.getShallow("alignMinLabel", !0), _), A = qe(O.getShallow("alignMaxLabel", !0), _), k = O.getShallow("verticalAlign", !0) || O.getShallow("baseline", !0) || c.textVerticalAlign, P = qe(O.getShallow("verticalAlignMinLabel", !0), k), L = qe(O.getShallow("verticalAlignMaxLabel", !0), k), D = new Nt({
        x: S,
        y: r.labelOffset + r.labelDirection * s,
        rotation: c.rotation,
        silent: d,
        z2: 10 + (g.level || 0),
        style: vn(O, {
          text: y,
          align: v === 0 ? C : v === l.length - 1 ? A : _,
          verticalAlign: v === 0 ? P : v === l.length - 1 ? L : k,
          fill: Le(x) ? x(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            i.type === "category" ? b : i.type === "value" ? m + "" : m,
            v
          ) : x
        })
      });
      if (D.anid = "label_" + m, p) {
        var E = Ji.makeAxisEventDataBase(t);
        E.targetType = "axisLabel", E.value = b, E.tickIndex = v, i.type === "category" && (E.dataIndex = m), He(D).eventData = E;
      }
      e.add(D), D.updateTransform(), f.push(D), n.add(D), D.decomposeTransform();
    }), f;
  }
}
function xEt(n, e) {
  var t = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return SEt(t, n, e), t.seriesInvolved && CEt(t, n), t;
}
function SEt(n, e, t) {
  var r = e.getComponent("tooltip"), i = e.getComponent("axisPointer"), o = i.get("link", !0) || [], a = [];
  I(t.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = Y0(s.model), u = n.coordSysAxesInfo[l] = {};
    n.coordSysMap[l] = s;
    var c = s.model, h = c.getModel("tooltip", r);
    if (I(s.getAxes(), Je(g, !1, null)), s.getTooltipAxes && r && h.get("show")) {
      var f = h.get("trigger") === "axis", d = h.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(h.get(["axisPointer", "axis"]));
      (f || d) && I(p.baseAxes, Je(g, d ? "cross" : !0, f)), d && I(p.otherAxes, Je(g, "cross", !1));
    }
    function g(v, m, y) {
      var b = y.model.getModel("axisPointer", i), O = b.get("show");
      if (!(!O || O === "auto" && !v && !yD(b))) {
        m == null && (m = b.get("triggerTooltip")), b = v ? _Et(y, h, i, e, v, m) : b;
        var w = b.get("snap"), x = b.get("triggerEmphasis"), S = Y0(y.model), _ = m || w || y.type === "category", C = n.axesInfo[S] = {
          key: S,
          axis: y,
          coordSys: s,
          axisPointerModel: b,
          triggerTooltip: m,
          triggerEmphasis: x,
          involveSeries: _,
          snap: w,
          useHandle: yD(b),
          seriesModels: [],
          linkGroup: null
        };
        u[S] = C, n.seriesInvolved = n.seriesInvolved || _;
        var A = AEt(o, y);
        if (A != null) {
          var k = a[A] || (a[A] = {
            axesInfo: {}
          });
          k.axesInfo[S] = C, k.mapper = o[A].mapper, C.linkGroup = k;
        }
      }
    }
  });
}
function _Et(n, e, t, r, i, o) {
  var a = e.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  I(s, function(f) {
    l[f] = Fe(a.get(f));
  }), l.snap = n.type !== "category" && !!o, a.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), i === "cross") {
    var c = a.get(["label", "show"]);
    if (u.show = c ?? !0, !o) {
      var h = l.lineStyle = a.get("crossStyle");
      h && Be(u, h.textStyle);
    }
  }
  return n.model.getModel("axisPointer", new mn(l, t, r));
}
function CEt(n, e) {
  e.eachSeries(function(t) {
    var r = t.coordinateSystem, i = t.get(["tooltip", "trigger"], !0), o = t.get(["tooltip", "show"], !0);
    !r || i === "none" || i === !1 || i === "item" || o === !1 || t.get(["axisPointer", "show"], !0) === !1 || I(n.coordSysAxesInfo[Y0(r.model)], function(a) {
      var s = a.axis;
      r.getAxis(s.dim) === s && (a.seriesModels.push(t), a.seriesDataCount == null && (a.seriesDataCount = 0), a.seriesDataCount += t.getData().count());
    });
  });
}
function AEt(n, e) {
  for (var t = e.model, r = e.dim, i = 0; i < n.length; i++) {
    var o = n[i] || {};
    if (zT(o[r + "AxisId"], t.id) || zT(o[r + "AxisIndex"], t.componentIndex) || zT(o[r + "AxisName"], t.name))
      return i;
  }
}
function zT(n, e) {
  return n === "all" || se(n) && ct(n, e) >= 0 || n === e;
}
function TEt(n) {
  var e = RN(n);
  if (e) {
    var t = e.axisPointerModel, r = e.axis.scale, i = t.option, o = t.get("status"), a = t.get("value");
    a != null && (a = r.parse(a));
    var s = yD(t);
    o == null && (i.status = s ? "show" : "hide");
    var l = r.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (a == null || a > l[1]) && (a = l[1]), a < l[0] && (a = l[0]), i.value = a, s && (i.status = e.axis.scale.isBlank() ? "hide" : "show");
  }
}
function RN(n) {
  var e = (n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return e && e.axesInfo[Y0(n)];
}
function kEt(n) {
  var e = RN(n);
  return e && e.axisPointerModel;
}
function yD(n) {
  return !!n.get(["handle", "show"]);
}
function Y0(n) {
  return n.type + "||" + n.id;
}
var FT = {}, $d = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, o) {
      this.axisPointerClass && TEt(t), n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, i, !0);
    }, e.prototype.updateAxisPointer = function(t, r, i, o) {
      this._doUpdateAxisPointerClass(t, i, !1);
    }, e.prototype.remove = function(t, r) {
      var i = this._axisPointer;
      i && i.remove(r);
    }, e.prototype.dispose = function(t, r) {
      this._disposeAxisPointer(r), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(t, r, i) {
      var o = e.getAxisPointerClass(this.axisPointerClass);
      if (o) {
        var a = kEt(t);
        a ? (this._axisPointer || (this._axisPointer = new o())).render(t, a, r, i) : this._disposeAxisPointer(r);
      }
    }, e.prototype._disposeAxisPointer = function(t) {
      this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(t, r) {
      if (process.env.NODE_ENV !== "production" && FT[t])
        throw new Error("axisPointer " + t + " exists");
      FT[t] = r;
    }, e.getAxisPointerClass = function(t) {
      return t && FT[t];
    }, e.type = "axis", e;
  }(Gn)
), bD = It();
function Cre(n, e, t, r) {
  var i = t.axis;
  if (!i.scale.isBlank()) {
    var o = t.getModel("splitArea"), a = o.getModel("areaStyle"), s = a.get("color"), l = r.coordinateSystem.getRect(), u = i.getTicksCoords({
      tickModel: o,
      clamp: !0
    });
    if (u.length) {
      var c = s.length, h = bD(n).splitAreaColors, f = Ee(), d = 0;
      if (h)
        for (var p = 0; p < u.length; p++) {
          var g = h.get(u[p].tickValue);
          if (g != null) {
            d = (g + (c - 1) * p) % c;
            break;
          }
        }
      var v = i.toGlobalCoord(u[0].coord), m = a.getAreaStyle();
      s = se(s) ? s : [s];
      for (var p = 1; p < u.length; p++) {
        var y = i.toGlobalCoord(u[p].coord), b = void 0, O = void 0, w = void 0, x = void 0;
        i.isHorizontal() ? (b = v, O = l.y, w = y - b, x = l.height, v = b + w) : (b = l.x, O = v, w = l.width, x = y - O, v = O + x);
        var S = u[p - 1].tickValue;
        S != null && f.set(S, d), e.add(new Lt({
          anid: S != null ? "area_" + S : null,
          shape: {
            x: b,
            y: O,
            width: w,
            height: x
          },
          style: Be({
            fill: s[d]
          }, m),
          autoBatch: !0,
          silent: !0
        })), d = (d + 1) % c;
      }
      bD(n).splitAreaColors = f;
    }
  }
}
function Are(n) {
  bD(n).splitAreaColors = null;
}
var PEt = ["axisLine", "axisTickLabel", "axisName"], EEt = ["splitArea", "splitLine", "minorSplitLine"], Tre = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t;
    }
    return e.prototype.render = function(t, r, i, o) {
      this.group.removeAll();
      var a = this._axisGroup;
      if (this._axisGroup = new We(), this.group.add(this._axisGroup), !!t.get("show")) {
        var s = t.getCoordSysModel(), l = mD(s, t), u = new Ji(t, re({
          handleAutoShown: function(h) {
            for (var f = s.coordinateSystem.getCartesians(), d = 0; d < f.length; d++)
              if (uD(f[d].getOtherAxis(t.axis).scale))
                return !0;
            return !1;
          }
        }, l));
        I(PEt, u.add, u), this._axisGroup.add(u.getGroup()), I(EEt, function(h) {
          t.get([h, "show"]) && MEt[h](this, this._axisGroup, t, s);
        }, this);
        var c = o && o.type === "changeAxisOrder" && o.isInitSort;
        c || Fb(a, this._axisGroup, t), n.prototype.render.call(this, t, r, i, o);
      }
    }, e.prototype.remove = function() {
      Are(this);
    }, e.type = "cartesianAxis", e;
  }($d)
), MEt = {
  splitLine: function(n, e, t, r) {
    var i = t.axis;
    if (!i.scale.isBlank()) {
      var o = t.getModel("splitLine"), a = o.getModel("lineStyle"), s = a.get("color");
      s = se(s) ? s : [s];
      for (var l = r.coordinateSystem.getRect(), u = i.isHorizontal(), c = 0, h = i.getTicksCoords({
        tickModel: o
      }), f = [], d = [], p = a.getLineStyle(), g = 0; g < h.length; g++) {
        var v = i.toGlobalCoord(h[g].coord);
        u ? (f[0] = v, f[1] = l.y, d[0] = v, d[1] = l.y + l.height) : (f[0] = l.x, f[1] = v, d[0] = l.x + l.width, d[1] = v);
        var m = c++ % s.length, y = h[g].tickValue, b = new Br({
          anid: y != null ? "line_" + h[g].tickValue : null,
          autoBatch: !0,
          shape: {
            x1: f[0],
            y1: f[1],
            x2: d[0],
            y2: d[1]
          },
          style: Be({
            stroke: s[m]
          }, p),
          silent: !0
        });
        Yg(b.shape, p.lineWidth), e.add(b);
      }
    }
  },
  minorSplitLine: function(n, e, t, r) {
    var i = t.axis, o = t.getModel("minorSplitLine"), a = o.getModel("lineStyle"), s = r.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
    if (u.length)
      for (var c = [], h = [], f = a.getLineStyle(), d = 0; d < u.length; d++)
        for (var p = 0; p < u[d].length; p++) {
          var g = i.toGlobalCoord(u[d][p].coord);
          l ? (c[0] = g, c[1] = s.y, h[0] = g, h[1] = s.y + s.height) : (c[0] = s.x, c[1] = g, h[0] = s.x + s.width, h[1] = g);
          var v = new Br({
            anid: "minor_line_" + u[d][p].tickValue,
            autoBatch: !0,
            shape: {
              x1: c[0],
              y1: c[1],
              x2: h[0],
              y2: h[1]
            },
            style: f,
            silent: !0
          });
          Yg(v.shape, f.lineWidth), e.add(v);
        }
  },
  splitArea: function(n, e, t, r) {
    Cre(n, e, t, r);
  }
}, kre = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "xAxis", e;
  }(Tre)
), DEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = kre.type, t;
    }
    return e.type = "yAxis", e;
  }(Tre)
), LEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "grid", t;
    }
    return e.prototype.render = function(t, r) {
      this.group.removeAll(), t.get("show") && this.group.add(new Lt({
        shape: t.coordinateSystem.getRect(),
        style: Be({
          fill: t.get("backgroundColor")
        }, t.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(Gn)
), X8 = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function Pre(n) {
  n.registerComponentView(LEt), n.registerComponentModel(iEt), n.registerCoordinateSystem("cartesian2d", vEt), ev(n, "x", gD, X8), ev(n, "y", gD, X8), n.registerComponentView(kre), n.registerComponentView(DEt), n.registerPreprocessor(function(e) {
    e.xAxis && e.yAxis && !e.grid && (e.grid = {});
  });
}
function IEt(n) {
  ft(Pre), n.registerSeriesModel(UPt), n.registerChartView(nEt), n.registerLayout(Xb("scatter"));
}
function REt(n) {
  n.eachSeriesByType("radar", function(e) {
    var t = e.getData(), r = [], i = e.coordinateSystem;
    if (i) {
      var o = i.getIndicatorAxes();
      I(o, function(a, s) {
        t.each(t.mapDimension(o[s].dim), function(l, u) {
          r[u] = r[u] || [];
          var c = i.dataToPoint(l, s);
          r[u][s] = U8(c) ? c : K8(i);
        });
      }), t.each(function(a) {
        var s = $Ot(r[a], function(l) {
          return U8(l);
        }) || K8(i);
        r[a].push(s.slice()), t.setItemLayout(a, r[a]);
      });
    }
  });
}
function U8(n) {
  return !isNaN(n[0]) && !isNaN(n[1]);
}
function K8(n) {
  return [n.cx, n.cy];
}
function NEt(n) {
  var e = n.polar;
  if (e) {
    se(e) || (e = [e]);
    var t = [];
    I(e, function(r, i) {
      r.indicator ? (r.type && !r.shape && (r.shape = r.type), n.radar = n.radar || [], se(n.radar) || (n.radar = [n.radar]), n.radar.push(r)) : t.push(r);
    }), n.polar = t;
  }
  I(n.series, function(r) {
    r && r.type === "radar" && r.polarIndex && (r.radarIndex = r.polarIndex);
  });
}
var $Et = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = t.coordinateSystem, a = this.group, s = t.getData(), l = this._data;
      function u(f, d) {
        var p = f.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var g = Wv(f.getItemVisual(d, "symbolSize")), v = vr(p, -1, -1, 2, 2), m = f.getItemVisual(d, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), v;
        }
      }
      function c(f, d, p, g, v, m) {
        p.removeAll();
        for (var y = 0; y < d.length - 1; y++) {
          var b = u(g, v);
          b && (b.__dimIdx = y, f[y] ? (b.setPosition(f[y]), Dd[m ? "initProps" : "updateProps"](b, {
            x: d[y][0],
            y: d[y][1]
          }, t, v)) : b.setPosition(d[y]), p.add(b));
        }
      }
      function h(f) {
        return le(f, function(d) {
          return [o.cx, o.cy];
        });
      }
      s.diff(l).add(function(f) {
        var d = s.getItemLayout(f);
        if (d) {
          var p = new ro(), g = new io(), v = {
            shape: {
              points: d
            }
          };
          p.shape.points = h(d), g.shape.points = h(d), Cn(p, v, t, f), Cn(g, v, t, f);
          var m = new We(), y = new We();
          m.add(g), m.add(p), m.add(y), c(g.shape.points, d, y, s, f, !0), s.setItemGraphicEl(f, m);
        }
      }).update(function(f, d) {
        var p = l.getItemGraphicEl(d), g = p.childAt(0), v = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: s.getItemLayout(f)
          }
        };
        y.shape.points && (c(g.shape.points, y.shape.points, m, s, f, !1), ms(v), ms(g), Vt(g, y, t), Vt(v, y, t), s.setItemGraphicEl(f, p));
      }).remove(function(f) {
        a.remove(l.getItemGraphicEl(f));
      }).execute(), s.eachItemGraphicEl(function(f, d) {
        var p = s.getItemModel(d), g = f.childAt(0), v = f.childAt(1), m = f.childAt(2), y = s.getItemVisual(d, "style"), b = y.fill;
        a.add(f), g.useStyle(Be(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: b
        })), Oi(g, p, "lineStyle"), Oi(v, p, "areaStyle");
        var O = p.getModel("areaStyle"), w = O.isEmpty() && O.parentModel.isEmpty();
        v.ignore = w, I(["emphasis", "select", "blur"], function(_) {
          var C = p.getModel([_, "areaStyle"]), A = C.isEmpty() && C.parentModel.isEmpty();
          v.ensureState(_).ignore = A && w;
        }), v.useStyle(Be(O.getAreaStyle(), {
          fill: b,
          opacity: 0.7,
          decal: y.decal
        }));
        var x = p.getModel("emphasis"), S = x.getModel("itemStyle").getItemStyle();
        m.eachChild(function(_) {
          if (_ instanceof Si) {
            var C = _.style;
            _.useStyle(re({
              // TODO other properties like x, y ?
              image: C.image,
              x: C.x,
              y: C.y,
              width: C.width,
              height: C.height
            }, y));
          } else
            _.useStyle(y), _.setColor(b), _.style.strokeNoScale = !0;
          var A = _.ensureState("emphasis");
          A.style = Fe(S);
          var k = s.getStore().get(s.getDimensionIndex(_.__dimIdx), d);
          (k == null || isNaN(k)) && (k = ""), wi(_, Fr(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: d,
            labelDimIndex: _.__dimIdx,
            defaultText: k,
            inheritColor: b,
            defaultOpacity: y.opacity
          });
        }), Wn(f, x.get("focus"), x.get("blurScope"), x.get("disabled"));
      }), this._data = s;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "radar", e;
  }(bn)
);
const BEt = $Et;
var VEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Kb(_e(this.getData, this), _e(this.getRawData, this));
    }, e.prototype.getInitialData = function(t, r) {
      return Gv(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, e.prototype.formatTooltip = function(t, r, i) {
      var o = this.getData(), a = this.coordinateSystem, s = a.getIndicatorAxes(), l = this.getData().getName(t), u = l === "" ? this.name : l, c = Ate(this, t);
      return Qr("section", {
        header: u,
        sortBlocks: !0,
        blocks: le(s, function(h) {
          var f = o.get(o.mapDimension(h.dim), t);
          return Qr("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: h.name,
            value: f,
            sortParam: f
          });
        })
      });
    }, e.prototype.getTooltipPosition = function(t) {
      if (t != null) {
        for (var r = this.getData(), i = this.coordinateSystem, o = r.getValues(le(i.dimensions, function(u) {
          return r.mapDimension(u);
        }), t), a = 0, s = o.length; a < s; a++)
          if (!isNaN(o[a])) {
            var l = i.getIndicatorAxes();
            return i.coordToPoint(l[a].dataToCoord(o[a]), a);
          }
      }
    }, e.type = "series.radar", e.dependencies = ["radar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, e;
  }(Ln)
);
const zEt = VEt;
var Cm = xre.value;
function $O(n, e) {
  return Be({
    show: e
  }, n);
}
var FEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      var t = this.get("boundaryGap"), r = this.get("splitNumber"), i = this.get("scale"), o = this.get("axisLine"), a = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), c = this.get(["axisName", "formatter"]), h = this.get("axisNameGap"), f = this.get("triggerEvent"), d = le(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = Be({
          color: p.color
        }, l));
        var v = it(Fe(p), {
          boundaryGap: t,
          splitNumber: r,
          scale: i,
          axisLine: o,
          axisTick: a,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: h,
          // min: 0,
          nameTextStyle: g,
          triggerEvent: f
        }, !1);
        if (we(c)) {
          var m = v.name;
          v.name = c.replace("{value}", m ?? "");
        } else
          Le(c) && (v.name = c(v.name, v));
        var y = new mn(v, null, this.ecModel);
        return mr(y, jb.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = d;
    }, e.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, e.type = "radar", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: it({
        lineStyle: {
          color: "#bbb"
        }
      }, Cm.axisLine),
      axisLabel: $O(Cm.axisLabel, !1),
      axisTick: $O(Cm.axisTick, !1),
      // axisType: 'value',
      splitLine: $O(Cm.splitLine, !0),
      splitArea: $O(Cm.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, e;
  }(Pt)
);
const QEt = FEt;
var ZEt = ["axisLine", "axisTickLabel", "axisName"], WEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = this.group;
      o.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
    }, e.prototype._buildAxes = function(t) {
      var r = t.coordinateSystem, i = r.getIndicatorAxes(), o = le(i, function(a) {
        var s = a.model.get("showName") ? a.name : "", l = new Ji(a.model, {
          axisName: s,
          position: [r.cx, r.cy],
          rotation: a.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      I(o, function(a) {
        I(ZEt, a.add, a), this.group.add(a.getGroup());
      }, this);
    }, e.prototype._buildSplitLineAndArea = function(t) {
      var r = t.coordinateSystem, i = r.getIndicatorAxes();
      if (!i.length)
        return;
      var o = t.get("shape"), a = t.getModel("splitLine"), s = t.getModel("splitArea"), l = a.getModel("lineStyle"), u = s.getModel("areaStyle"), c = a.get("show"), h = s.get("show"), f = l.get("color"), d = u.get("color"), p = se(f) ? f : [f], g = se(d) ? d : [d], v = [], m = [];
      function y(E, M, R) {
        var N = R % M.length;
        return E[N] = E[N] || [], N;
      }
      if (o === "circle")
        for (var b = i[0].getTicksCoords(), O = r.cx, w = r.cy, x = 0; x < b.length; x++) {
          if (c) {
            var S = y(v, p, x);
            v[S].push(new fh({
              shape: {
                cx: O,
                cy: w,
                r: b[x].coord
              }
            }));
          }
          if (h && x < b.length - 1) {
            var S = y(m, g, x);
            m[S].push(new CC({
              shape: {
                cx: O,
                cy: w,
                r0: b[x].coord,
                r: b[x + 1].coord
              }
            }));
          }
        }
      else
        for (var _, C = le(i, function(E, M) {
          var R = E.getTicksCoords();
          return _ = _ == null ? R.length - 1 : Math.min(R.length - 1, _), le(R, function(N) {
            return r.coordToPoint(N.coord, M);
          });
        }), A = [], x = 0; x <= _; x++) {
          for (var k = [], P = 0; P < i.length; P++)
            k.push(C[P][x]);
          if (k[0] ? k.push(k[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + x), c) {
            var S = y(v, p, x);
            v[S].push(new io({
              shape: {
                points: k
              }
            }));
          }
          if (h && A) {
            var S = y(m, g, x - 1);
            m[S].push(new ro({
              shape: {
                points: k.concat(A)
              }
            }));
          }
          A = k.slice().reverse();
        }
      var L = l.getLineStyle(), D = u.getAreaStyle();
      I(m, function(E, M) {
        this.group.add(ma(E, {
          style: Be({
            stroke: "none",
            fill: g[M % g.length]
          }, D),
          silent: !0
        }));
      }, this), I(v, function(E, M) {
        this.group.add(ma(E, {
          style: Be({
            fill: "none",
            stroke: p[M % p.length]
          }, L),
          silent: !0
        }));
      }, this);
    }, e.type = "radar", e;
  }(Gn)
);
const GEt = WEt;
var jEt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this, t, r, i) || this;
      return o.type = "value", o.angle = 0, o.name = "", o;
    }
    return e;
  }(As)
);
const HEt = jEt;
var qEt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.dimensions = [], this._model = e, this._indicatorAxes = le(e.getIndicatorModels(), function(i, o) {
        var a = "indicator_" + o, s = new HEt(
          a,
          new Kc()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(a), s;
      }, this), this.resize(e, r);
    }
    return n.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, n.prototype.dataToPoint = function(e, t) {
      var r = this._indicatorAxes[t];
      return this.coordToPoint(r.dataToCoord(e), t);
    }, n.prototype.coordToPoint = function(e, t) {
      var r = this._indicatorAxes[t], i = r.angle, o = this.cx + e * Math.cos(i), a = this.cy - e * Math.sin(i);
      return [o, a];
    }, n.prototype.pointToData = function(e) {
      var t = e[0] - this.cx, r = e[1] - this.cy, i = Math.sqrt(t * t + r * r);
      t /= i, r /= i;
      for (var o = Math.atan2(-r, t), a = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], h = Math.abs(o - c.angle);
        h < a && (s = c, l = u, a = h);
      }
      return [l, +(s && s.coordToData(i))];
    }, n.prototype.resize = function(e, t) {
      var r = e.get("center"), i = t.getWidth(), o = t.getHeight(), a = Math.min(i, o) / 2;
      this.cx = be(r[0], i), this.cy = be(r[1], o), this.startAngle = e.get("startAngle") * Math.PI / 180;
      var s = e.get("radius");
      (we(s) || $t(s)) && (s = [0, s]), this.r0 = be(s[0], a), this.r = be(s[1], a), I(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, n.prototype.update = function(e, t) {
      var r = this._indicatorAxes, i = this._model;
      I(r, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), e.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || e.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          I(r, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var o = i.get("splitNumber"), a = new Kc();
      a.setExtent(0, o), a.setInterval(1), I(r, function(s, l) {
        Sre(s.scale, s.model, a);
      });
    }, n.prototype.convertToPixel = function(e, t, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("radar", function(i) {
        var o = new n(i, e, t);
        r.push(o), i.coordinateSystem = o;
      }), e.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = r[i.get("radarIndex") || 0]);
      }), r;
    }, n.dimensions = [], n;
  }()
);
const YEt = qEt;
function XEt(n) {
  n.registerCoordinateSystem("radar", YEt), n.registerComponentModel(QEt), n.registerComponentView(GEt), n.registerVisual({
    seriesType: "radar",
    reset: function(e) {
      var t = e.getData();
      t.each(function(r) {
        t.setItemVisual(r, "legendIcon", "roundRect");
      }), t.setVisual("legendIcon", "roundRect");
    }
  });
}
function UEt(n) {
  ft(XEt), n.registerChartView(BEt), n.registerSeriesModel(zEt), n.registerLayout(REt), n.registerProcessor(Ub("radar")), n.registerPreprocessor(NEt);
}
var J8 = "\0_ec_interaction_mutex";
function KEt(n, e, t) {
  var r = NN(n);
  r[e] = t;
}
function JEt(n, e, t) {
  var r = NN(n), i = r[e];
  i === t && (r[e] = null);
}
function eQ(n, e) {
  return !!NN(n)[e];
}
function NN(n) {
  return n[J8] || (n[J8] = {});
}
Rl({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, nr);
var eMt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this) || this;
      r._zr = t;
      var i = _e(r._mousedownHandler, r), o = _e(r._mousemoveHandler, r), a = _e(r._mouseupHandler, r), s = _e(r._mousewheelHandler, r), l = _e(r._pinchHandler, r);
      return r.enable = function(u, c) {
        this.disable(), this._opt = Be(Fe(c) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (t.on("mousedown", i), t.on("mousemove", o), t.on("mouseup", a)), (u === !0 || u === "scale" || u === "zoom") && (t.on("mousewheel", s), t.on("pinch", l));
      }, r.disable = function() {
        t.off("mousedown", i), t.off("mousemove", o), t.off("mouseup", a), t.off("mousewheel", s), t.off("pinch", l);
      }, r;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(t) {
      this.pointerChecker = t;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(t) {
      if (!_z(t)) {
        for (var r = t.target; r; ) {
          if (r.draggable)
            return;
          r = r.__hostTarget || r.parent;
        }
        var i = t.offsetX, o = t.offsetY;
        this.pointerChecker && this.pointerChecker(t, i, o) && (this._x = i, this._y = o, this._dragging = !0);
      }
    }, e.prototype._mousemoveHandler = function(t) {
      if (!(!this._dragging || !Kw("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || eQ(this._zr, "globalPan"))) {
        var r = t.offsetX, i = t.offsetY, o = this._x, a = this._y, s = r - o, l = i - a;
        this._x = r, this._y = i, this._opt.preventDefaultMouseMove && du(t.event), Ere(this, "pan", "moveOnMouseMove", t, {
          dx: s,
          dy: l,
          oldX: o,
          oldY: a,
          newX: r,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(t) {
      _z(t) || (this._dragging = !1);
    }, e.prototype._mousewheelHandler = function(t) {
      var r = Kw("zoomOnMouseWheel", t, this._opt), i = Kw("moveOnMouseWheel", t, this._opt), o = t.wheelDelta, a = Math.abs(o), s = t.offsetX, l = t.offsetY;
      if (!(o === 0 || !r && !i)) {
        if (r) {
          var u = a > 3 ? 1.4 : a > 1 ? 1.2 : 1.1, c = o > 0 ? u : 1 / u;
          QT(this, "zoom", "zoomOnMouseWheel", t, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var h = Math.abs(o), f = (o > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
          QT(this, "scrollMove", "moveOnMouseWheel", t, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(t) {
      if (!eQ(this._zr, "globalPan")) {
        var r = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
        QT(this, "zoom", null, t, {
          scale: r,
          originX: t.pinchX,
          originY: t.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(Ba)
);
function QT(n, e, t, r, i) {
  n.pointerChecker && n.pointerChecker(r, i.originX, i.originY) && (du(r.event), Ere(n, e, t, r, i));
}
function Ere(n, e, t, r, i) {
  i.isAvailableBehavior = _e(Kw, null, t, r), n.trigger(e, i);
}
function Kw(n, e, t) {
  var r = t[n];
  return !n || r && (!we(r) || e.event[r + "Key"]);
}
const Jb = eMt;
function $N(n, e, t) {
  var r = n.target;
  r.x += e, r.y += t, r.dirty();
}
function BN(n, e, t, r) {
  var i = n.target, o = n.zoomLimit, a = n.zoom = n.zoom || 1;
  if (a *= e, o) {
    var s = o.min || 0, l = o.max || 1 / 0;
    a = Math.max(Math.min(l, a), s);
  }
  var u = a / n.zoom;
  n.zoom = a, i.x -= (t - i.x) * (u - 1), i.y -= (r - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
}
var tMt = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function GC(n, e, t) {
  var r = e.getComponentByElement(n.topTarget), i = r && r.coordinateSystem;
  return r && r !== t && !tMt.hasOwnProperty(r.mainType) && i && i.model !== t;
}
function Mre(n) {
  if (we(n)) {
    var e = new DOMParser();
    n = e.parseFromString(n, "text/xml");
  }
  var t = n;
  for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1; )
    t = t.nextSibling;
  return t;
}
var ZT, BS = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, tQ = Ot(BS), VS = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, nQ = Ot(VS), nMt = function() {
  function n() {
    this._defs = {}, this._root = null;
  }
  return n.prototype.parse = function(e, t) {
    t = t || {};
    var r = Mre(e);
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var i = new We();
    this._root = i;
    var o = [], a = r.getAttribute("viewBox") || "", s = parseFloat(r.getAttribute("width") || t.width), l = parseFloat(r.getAttribute("height") || t.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), Lo(r, i, null, !0, !1);
    for (var u = r.firstChild; u; )
      this._parseNode(u, i, o, null, !1, !1), u = u.nextSibling;
    oMt(this._defs, this._defsUsePending), this._defsUsePending = [];
    var c, h;
    if (a) {
      var f = jC(a);
      f.length >= 4 && (c = {
        x: parseFloat(f[0] || 0),
        y: parseFloat(f[1] || 0),
        width: parseFloat(f[2]),
        height: parseFloat(f[3])
      });
    }
    if (c && s != null && l != null && (h = Lre(c, { x: 0, y: 0, width: s, height: l }), !t.ignoreViewBox)) {
      var d = i;
      i = new We(), i.add(d), d.scaleX = d.scaleY = h.scale, d.x = h.x, d.y = h.y;
    }
    return !t.ignoreRootClip && s != null && l != null && i.setClipPath(new Lt({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: i,
      width: s,
      height: l,
      viewBoxRect: c,
      viewBoxTransform: h,
      named: o
    };
  }, n.prototype._parseNode = function(e, t, r, i, o, a) {
    var s = e.nodeName.toLowerCase(), l, u = i;
    if (s === "defs" && (o = !0), s === "text" && (a = !0), s === "defs" || s === "switch")
      l = t;
    else {
      if (!o) {
        var c = ZT[s];
        if (c && Ce(ZT, s)) {
          l = c.call(this, e, t);
          var h = e.getAttribute("name");
          if (h) {
            var f = {
              name: h,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            r.push(f), s === "g" && (u = f);
          } else
            i && r.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: s,
              el: l
            });
          t.add(l);
        }
      }
      var d = rQ[s];
      if (d && Ce(rQ, s)) {
        var p = d.call(this, e), g = e.getAttribute("id");
        g && (this._defs[g] = p);
      }
    }
    if (l && l.isGroup)
      for (var v = e.firstChild; v; )
        v.nodeType === 1 ? this._parseNode(v, l, r, u, o, a) : v.nodeType === 3 && a && this._parseText(v, l), v = v.nextSibling;
  }, n.prototype._parseText = function(e, t) {
    var r = new N0({
      style: {
        text: e.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    na(t, r), Lo(e, r, this._defsUsePending, !1, !1), rMt(r, t);
    var i = r.style, o = i.fontSize;
    o && o < 9 && (i.fontSize = 9, r.scaleX *= o / 9, r.scaleY *= o / 9);
    var a = (i.fontSize || i.fontFamily) && [
      i.fontStyle,
      i.fontWeight,
      (i.fontSize || 12) + "px",
      i.fontFamily || "sans-serif"
    ].join(" ");
    i.font = a;
    var s = r.getBoundingRect();
    return this._textX += s.width, t.add(r), r;
  }, n.internalField = function() {
    ZT = {
      g: function(e, t) {
        var r = new We();
        return na(t, r), Lo(e, r, this._defsUsePending, !1, !1), r;
      },
      rect: function(e, t) {
        var r = new Lt();
        return na(t, r), Lo(e, r, this._defsUsePending, !1, !1), r.setShape({
          x: parseFloat(e.getAttribute("x") || "0"),
          y: parseFloat(e.getAttribute("y") || "0"),
          width: parseFloat(e.getAttribute("width") || "0"),
          height: parseFloat(e.getAttribute("height") || "0")
        }), r.silent = !0, r;
      },
      circle: function(e, t) {
        var r = new fh();
        return na(t, r), Lo(e, r, this._defsUsePending, !1, !1), r.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          r: parseFloat(e.getAttribute("r") || "0")
        }), r.silent = !0, r;
      },
      line: function(e, t) {
        var r = new Br();
        return na(t, r), Lo(e, r, this._defsUsePending, !1, !1), r.setShape({
          x1: parseFloat(e.getAttribute("x1") || "0"),
          y1: parseFloat(e.getAttribute("y1") || "0"),
          x2: parseFloat(e.getAttribute("x2") || "0"),
          y2: parseFloat(e.getAttribute("y2") || "0")
        }), r.silent = !0, r;
      },
      ellipse: function(e, t) {
        var r = new WR();
        return na(t, r), Lo(e, r, this._defsUsePending, !1, !1), r.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          rx: parseFloat(e.getAttribute("rx") || "0"),
          ry: parseFloat(e.getAttribute("ry") || "0")
        }), r.silent = !0, r;
      },
      polygon: function(e, t) {
        var r = e.getAttribute("points"), i;
        r && (i = aQ(r));
        var o = new ro({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return na(t, o), Lo(e, o, this._defsUsePending, !1, !1), o;
      },
      polyline: function(e, t) {
        var r = e.getAttribute("points"), i;
        r && (i = aQ(r));
        var o = new io({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return na(t, o), Lo(e, o, this._defsUsePending, !1, !1), o;
      },
      image: function(e, t) {
        var r = new Si();
        return na(t, r), Lo(e, r, this._defsUsePending, !1, !1), r.setStyle({
          image: e.getAttribute("xlink:href") || e.getAttribute("href"),
          x: +e.getAttribute("x"),
          y: +e.getAttribute("y"),
          width: +e.getAttribute("width"),
          height: +e.getAttribute("height")
        }), r.silent = !0, r;
      },
      text: function(e, t) {
        var r = e.getAttribute("x") || "0", i = e.getAttribute("y") || "0", o = e.getAttribute("dx") || "0", a = e.getAttribute("dy") || "0";
        this._textX = parseFloat(r) + parseFloat(o), this._textY = parseFloat(i) + parseFloat(a);
        var s = new We();
        return na(t, s), Lo(e, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(e, t) {
        var r = e.getAttribute("x"), i = e.getAttribute("y");
        r != null && (this._textX = parseFloat(r)), i != null && (this._textY = parseFloat(i));
        var o = e.getAttribute("dx") || "0", a = e.getAttribute("dy") || "0", s = new We();
        return na(t, s), Lo(e, s, this._defsUsePending, !1, !0), this._textX += parseFloat(o), this._textY += parseFloat(a), s;
      },
      path: function(e, t) {
        var r = e.getAttribute("d") || "", i = gee(r);
        return na(t, i), Lo(e, i, this._defsUsePending, !1, !1), i.silent = !0, i;
      }
    };
  }(), n;
}(), rQ = {
  lineargradient: function(n) {
    var e = parseInt(n.getAttribute("x1") || "0", 10), t = parseInt(n.getAttribute("y1") || "0", 10), r = parseInt(n.getAttribute("x2") || "10", 10), i = parseInt(n.getAttribute("y2") || "0", 10), o = new zb(e, t, r, i);
    return iQ(n, o), oQ(n, o), o;
  },
  radialgradient: function(n) {
    var e = parseInt(n.getAttribute("cx") || "0", 10), t = parseInt(n.getAttribute("cy") || "0", 10), r = parseInt(n.getAttribute("r") || "0", 10), i = new Cee(e, t, r);
    return iQ(n, i), oQ(n, i), i;
  }
};
function iQ(n, e) {
  var t = n.getAttribute("gradientUnits");
  t === "userSpaceOnUse" && (e.global = !0);
}
function oQ(n, e) {
  for (var t = n.firstChild; t; ) {
    if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
      var r = t.getAttribute("offset"), i = void 0;
      r && r.indexOf("%") > 0 ? i = parseInt(r, 10) / 100 : r ? i = parseFloat(r) : i = 0;
      var o = {};
      Dre(t, o, o);
      var a = o.stopColor || t.getAttribute("stop-color") || "#000000";
      e.colorStops.push({
        offset: i,
        color: a
      });
    }
    t = t.nextSibling;
  }
}
function na(n, e) {
  n && n.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), Be(e.__inheritedStyle, n.__inheritedStyle));
}
function aQ(n) {
  for (var e = jC(n), t = [], r = 0; r < e.length; r += 2) {
    var i = parseFloat(e[r]), o = parseFloat(e[r + 1]);
    t.push([i, o]);
  }
  return t;
}
function Lo(n, e, t, r, i) {
  var o = e, a = o.__inheritedStyle = o.__inheritedStyle || {}, s = {};
  n.nodeType === 1 && (lMt(n, e), Dre(n, a, s), r || uMt(n, a, s)), o.style = o.style || {}, a.fill != null && (o.style.fill = sQ(o, "fill", a.fill, t)), a.stroke != null && (o.style.stroke = sQ(o, "stroke", a.stroke, t)), I([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    a[l] != null && (o.style[l] = parseFloat(a[l]));
  }), I([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    a[l] != null && (o.style[l] = a[l]);
  }), i && (o.__selfStyle = s), a.lineDash && (o.style.lineDash = le(jC(a.lineDash), function(l) {
    return parseFloat(l);
  })), (a.visibility === "hidden" || a.visibility === "collapse") && (o.invisible = !0), a.display === "none" && (o.ignore = !0);
}
function rMt(n, e) {
  var t = e.__selfStyle;
  if (t) {
    var r = t.textBaseline, i = r;
    !r || r === "auto" || r === "baseline" ? i = "alphabetic" : r === "before-edge" || r === "text-before-edge" ? i = "top" : r === "after-edge" || r === "text-after-edge" ? i = "bottom" : (r === "central" || r === "mathematical") && (i = "middle"), n.style.textBaseline = i;
  }
  var o = e.__inheritedStyle;
  if (o) {
    var a = o.textAlign, s = a;
    a && (a === "middle" && (s = "center"), n.style.textAlign = s);
  }
}
var iMt = /^url\(\s*#(.*?)\)/;
function sQ(n, e, t, r) {
  var i = t && t.match(iMt);
  if (i) {
    var o = is(i[1]);
    r.push([n, e, o]);
    return;
  }
  return t === "none" && (t = null), t;
}
function oMt(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r[0].style[r[1]] = n[r[2]];
  }
}
var aMt = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function jC(n) {
  return n.match(aMt) || [];
}
var sMt = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, WT = Math.PI / 180;
function lMt(n, e) {
  var t = n.getAttribute("transform");
  if (t) {
    t = t.replace(/,/g, " ");
    var r = [], i = null;
    t.replace(sMt, function(h, f, d) {
      return r.push(f, d), "";
    });
    for (var o = r.length - 1; o > 0; o -= 2) {
      var a = r[o], s = r[o - 1], l = jC(a);
      switch (i = i || Ho(), s) {
        case "translate":
          Sl(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          TR(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          Md(i, i, -parseFloat(l[0]) * WT, [
            parseFloat(l[1] || "0"),
            parseFloat(l[2] || "0")
          ]);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * WT);
          eu(i, [1, 0, u, 1, 0, 0], i);
          break;
        case "skewY":
          var c = Math.tan(parseFloat(l[0]) * WT);
          eu(i, [1, c, 0, 1, 0, 0], i);
          break;
        case "matrix":
          i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
          break;
      }
    }
    e.setLocalTransform(i);
  }
}
var lQ = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function Dre(n, e, t) {
  var r = n.getAttribute("style");
  if (r) {
    lQ.lastIndex = 0;
    for (var i; (i = lQ.exec(r)) != null; ) {
      var o = i[1], a = Ce(BS, o) ? BS[o] : null;
      a && (e[a] = i[2]);
      var s = Ce(VS, o) ? VS[o] : null;
      s && (t[s] = i[2]);
    }
  }
}
function uMt(n, e, t) {
  for (var r = 0; r < tQ.length; r++) {
    var i = tQ[r], o = n.getAttribute(i);
    o != null && (e[BS[i]] = o);
  }
  for (var r = 0; r < nQ.length; r++) {
    var i = nQ[r], o = n.getAttribute(i);
    o != null && (t[VS[i]] = o);
  }
}
function Lre(n, e) {
  var t = e.width / n.width, r = e.height / n.height, i = Math.min(t, r);
  return {
    scale: i,
    x: -(n.x + n.width / 2) * i + (e.x + e.width / 2),
    y: -(n.y + n.height / 2) * i + (e.y + e.height / 2)
  };
}
function cMt(n, e) {
  var t = new nMt();
  return t.parse(n, e);
}
var hMt = Ee([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), fMt = (
  /** @class */
  function() {
    function n(e, t) {
      this.type = "geoSVG", this._usedGraphicMap = Ee(), this._freedGraphics = [], this._mapName = e, this._parsedXML = Mre(t);
    }
    return n.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var t = pMt(e.named), r = t.regions, i = t.regionsMap;
        this._regions = r, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, n.prototype._buildGraphic = function(e) {
      var t, r;
      try {
        t = e && cMt(e, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, r = t.root, $e(r != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var i = new We();
      i.add(r), i.isGeoSVGGraphicRoot = !0;
      var o = t.width, a = t.height, s = t.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, h = void 0, f = void 0;
        if (o != null ? (u = 0, h = o) : s && (u = s.x, h = s.width), a != null ? (c = 0, f = a) : s && (c = s.y, f = s.height), u == null || c == null) {
          var d = r.getBoundingRect();
          u == null && (u = d.x, h = d.width), c == null && (c = d.y, f = d.height);
        }
        l = this._boundingRect = new ot(u, c, h, f);
      }
      if (s) {
        var p = Lre(s, l);
        r.scaleX = r.scaleY = p.scale, r.x = p.x, r.y = p.y;
      }
      i.setClipPath(new Lt({
        shape: l.plain()
      }));
      var g = [];
      return I(t.named, function(v) {
        hMt.get(v.svgNodeTagLower) != null && (g.push(v), dMt(v.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, n.prototype.useGraphic = function(e) {
      var t = this._usedGraphicMap, r = t.get(e);
      return r || (r = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, r), r);
    }, n.prototype.freeGraphic = function(e) {
      var t = this._usedGraphicMap, r = t.get(e);
      r && (t.removeKey(e), this._freedGraphics.push(r));
    }, n;
  }()
);
function dMt(n) {
  n.silent = !1, n.isGroup && n.traverse(function(e) {
    e.silent = !1;
  });
}
function pMt(n) {
  var e = [], t = Ee();
  return I(n, function(r) {
    if (r.namedFrom == null) {
      var i = new BTt(r.name, r.el);
      e.push(i), t.set(r.name, i);
    }
  }), {
    regions: e,
    regionsMap: t
  };
}
var OD = [126, 25], uQ = "南海诸岛", Yh = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var Wh = 0; Wh < Yh.length; Wh++)
  for (var lp = 0; lp < Yh[Wh].length; lp++)
    Yh[Wh][lp][0] /= 10.5, Yh[Wh][lp][1] /= -10.5 / 0.75, Yh[Wh][lp][0] += OD[0], Yh[Wh][lp][1] += OD[1];
function gMt(n, e) {
  if (n === "china") {
    for (var t = 0; t < e.length; t++)
      if (e[t].name === uQ)
        return;
    e.push(new Mne(uQ, le(Yh, function(r) {
      return {
        type: "polygon",
        exterior: r
      };
    }), OD));
  }
}
var vMt = {
  南海诸岛: [32, 80],
  // 全国
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  // '北京': [-10, 0],
  天津: [5, 5]
};
function mMt(n, e) {
  if (n === "china") {
    var t = vMt[e.name];
    if (t) {
      var r = e.getCenter();
      r[0] += t[0] / 10.5, r[1] += -t[1] / (10.5 / 0.75), e.setCenter(r);
    }
  }
}
var yMt = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function bMt(n, e) {
  n === "china" && e.name === "台湾" && e.geometries.push({
    type: "polygon",
    exterior: yMt[0]
  });
}
var OMt = "name", wMt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "geoJSON", this._parsedMap = Ee(), this._mapName = e, this._specialAreas = r, this._geoJSON = SMt(t);
    }
    return n.prototype.load = function(e, t) {
      t = t || OMt;
      var r = this._parsedMap.get(t);
      if (!r) {
        var i = this._parseToRegions(t);
        r = this._parsedMap.set(t, {
          regions: i,
          boundingRect: xMt(i)
        });
      }
      var o = Ee(), a = [];
      return I(r.regions, function(s) {
        var l = s.name;
        e && Ce(e, l) && (s = s.cloneShallow(l = e[l])), a.push(s), o.set(l, s);
      }), {
        regions: a,
        boundingRect: r.boundingRect || new ot(0, 0, 0, 0),
        regionsMap: o
      };
    }, n.prototype._parseToRegions = function(e) {
      var t = this._mapName, r = this._geoJSON, i;
      try {
        i = r ? zTt(r, e) : [];
      } catch (o) {
        throw new Error(`Invalid geoJson format
` + o.message);
      }
      return gMt(t, i), I(i, function(o) {
        var a = o.name;
        mMt(t, o), bMt(t, o);
        var s = this._specialAreas && this._specialAreas[a];
        s && o.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, n.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, n;
  }()
);
function xMt(n) {
  for (var e, t = 0; t < n.length; t++) {
    var r = n[t].getBoundingRect();
    e = e || r.clone(), e.union(r);
  }
  return e;
}
function SMt(n) {
  return we(n) ? typeof JSON < "u" && JSON.parse ? JSON.parse(n) : new Function("return (" + n + ");")() : n;
}
var Am = Ee();
const yu = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(n, e, t) {
    if (e.svg) {
      var r = new fMt(n, e.svg);
      Am.set(n, r);
    } else {
      var i = e.geoJson || e.geoJSON;
      i && !e.features ? t = e.specialAreas : i = e;
      var r = new wMt(n, i, t);
      Am.set(n, r);
    }
  },
  getGeoResource: function(n) {
    return Am.get(n);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(n) {
    var e = Am.get(n);
    return e && e.type === "geoJSON" && e.getMapForUser();
  },
  load: function(n, e, t) {
    var r = Am.get(n);
    if (!r) {
      process.env.NODE_ENV !== "production" && console.error("Map " + n + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return r.load(e, t);
  }
};
var VN = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], _Mt = Ee(VN), CMt = Ee(VN.concat(["g"])), AMt = Ee(VN.concat(["g"])), Ire = It();
function BO(n) {
  var e = n.getItemStyle(), t = n.get("areaColor");
  return t != null && (e.fill = t), e;
}
function cQ(n) {
  var e = n.style;
  e && (e.stroke = e.stroke || e.fill, e.fill = null);
}
var TMt = (
  /** @class */
  function() {
    function n(e) {
      var t = new We();
      this.uid = Nv("ec_map_draw"), this._controller = new Jb(e.getZr()), this._controllerHost = {
        target: t
      }, this.group = t, t.add(this._regionsGroup = new We()), t.add(this._svgGroup = new We());
    }
    return n.prototype.draw = function(e, t, r, i, o) {
      var a = e.mainType === "geo", s = e.getData && e.getData();
      a && t.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(m) {
        !s && m.getHostGeoModel() === e && (s = m.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, c = this.group, h = l.getTransformInfo(), f = h.raw, d = h.roam, p = !u.childAt(0) || o;
      p ? (c.x = d.x, c.y = d.y, c.scaleX = d.scaleX, c.scaleY = d.scaleY, c.dirty()) : Vt(c, d, e);
      var g = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, v = {
        api: r,
        geo: l,
        mapOrGeoModel: e,
        data: s,
        isVisualEncodedByVisualMap: g,
        isGeo: a,
        transformInfoRaw: f
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(v) : l.resourceType === "geoSVG" && this._buildSVG(v), this._updateController(e, t, r), this._updateMapSelectHandler(e, u, r, i);
    }, n.prototype._buildGeoJSON = function(e) {
      var t = this._regionsGroupByName = Ee(), r = Ee(), i = this._regionsGroup, o = e.transformInfoRaw, a = e.mapOrGeoModel, s = e.data, l = e.geo.projection, u = l && l.stream;
      function c(d, p) {
        return p && (d = p(d)), d && [d[0] * o.scaleX + o.x, d[1] * o.scaleY + o.y];
      }
      function h(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var m = c(d[v], g);
          m && p.push(m);
        }
        return p;
      }
      function f(d) {
        return {
          shape: {
            points: h(d)
          }
        };
      }
      i.removeAll(), I(e.geo.regions, function(d) {
        var p = d.name, g = t.get(p), v = r.get(p) || {}, m = v.dataIdx, y = v.regionModel;
        g || (g = t.set(p, new We()), i.add(g), m = s ? s.indexOfName(p) : null, y = e.isGeo ? a.getRegionModel(p) : s ? s.getItemModel(m) : null, r.set(p, {
          dataIdx: m,
          regionModel: y
        }));
        var b = [], O = [];
        I(d.geometries, function(S) {
          if (S.type === "polygon") {
            var _ = [S.exterior].concat(S.interiors || []);
            u && (_ = vQ(_, u)), I(_, function(A) {
              b.push(new ro(f(A)));
            });
          } else {
            var C = S.points;
            u && (C = vQ(C, u, !0)), I(C, function(A) {
              O.push(new io(f(A)));
            });
          }
        });
        var w = c(d.getCenter(), l && l.project);
        function x(S, _) {
          if (S.length) {
            var C = new jR({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: S
              }
            });
            g.add(C), hQ(e, C, m, y), fQ(e, C, p, y, a, m, w), _ && (cQ(C), I(C.states, cQ));
          }
        }
        x(b), x(O, !0);
      }), t.each(function(d, p) {
        var g = r.get(p), v = g.dataIdx, m = g.regionModel;
        dQ(e, d, p, m, a, v), pQ(e, d, p, m, a), gQ(e, d, p, m, a);
      }, this);
    }, n.prototype._buildSVG = function(e) {
      var t = e.geo.map, r = e.transformInfoRaw;
      this._svgGroup.x = r.x, this._svgGroup.y = r.y, this._svgGroup.scaleX = r.scaleX, this._svgGroup.scaleY = r.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
      var i = this._svgDispatcherMap = Ee(), o = !1;
      I(this._svgGraphicRecord.named, function(a) {
        var s = a.name, l = e.mapOrGeoModel, u = e.data, c = a.svgNodeTagLower, h = a.el, f = u ? u.indexOfName(s) : null, d = l.getRegionModel(s);
        if (_Mt.get(c) != null && h instanceof Ia && hQ(e, h, f, d), h instanceof Ia && (h.culling = !0), h.z2EmphasisLift = 0, !a.namedFrom && (AMt.get(c) != null && fQ(e, h, s, d, l, f, null), dQ(e, h, s, d, l, f), pQ(e, h, s, d, l), CMt.get(c) != null)) {
          var p = gQ(e, h, s, d, l);
          p === "self" && (o = !0);
          var g = i.get(s) || i.set(s, []);
          g.push(h);
        }
      }, this), this._enableBlurEntireSVG(o, e);
    }, n.prototype._enableBlurEntireSVG = function(e, t) {
      if (e && t.isGeo) {
        var r = t.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = r.opacity;
        this._svgGraphicRecord.root.traverse(function(o) {
          if (!o.isGroup) {
            pd(o);
            var a = o.ensureState("blur").style || {};
            a.opacity == null && i != null && (a.opacity = i), o.ensureState("emphasis");
          }
        });
      }
    }, n.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, n.prototype.findHighDownDispatchers = function(e, t) {
      if (e == null)
        return [];
      var r = t.coordinateSystem;
      if (r.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var o = i.get(e);
          return o ? [o] : [];
        }
      } else if (r.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, n.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, n.prototype._useSVG = function(e) {
      var t = yu.getGeoResource(e);
      if (t && t.type === "geoSVG") {
        var r = t.useGraphic(this.uid);
        this._svgGroup.add(r.root), this._svgGraphicRecord = r, this._svgMapName = e;
      }
    }, n.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var t = yu.getGeoResource(e);
        t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, n.prototype._updateController = function(e, t, r) {
      var i = e.coordinateSystem, o = this._controller, a = this._controllerHost;
      a.zoomLimit = e.get("scaleLimit"), a.zoom = i.getZoom(), o.enable(e.get("roam") || !1);
      var s = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = e.id, u;
      }
      o.off("pan").on("pan", function(u) {
        this._mouseDownFlag = !1, $N(a, u.dx, u.dy), r.dispatchAction(re(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), o.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = !1, BN(a, u.scale, u.originX, u.originY), r.dispatchAction(re(l(), {
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), o.setPointerChecker(function(u, c, h) {
        return i.containPoint([c, h]) && !GC(u, r, e);
      });
    }, n.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var t = e.getTextContent();
        t && (t.ignore = Ire(t).ignore);
      });
    }, n.prototype._updateMapSelectHandler = function(e, t, r, i) {
      var o = this;
      t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function() {
        o._mouseDownFlag = !0;
      }), t.on("click", function(a) {
        o._mouseDownFlag && (o._mouseDownFlag = !1);
      }));
    }, n;
  }()
);
function hQ(n, e, t, r) {
  var i = r.getModel("itemStyle"), o = r.getModel(["emphasis", "itemStyle"]), a = r.getModel(["blur", "itemStyle"]), s = r.getModel(["select", "itemStyle"]), l = BO(i), u = BO(o), c = BO(s), h = BO(a), f = n.data;
  if (f) {
    var d = f.getItemVisual(t, "style"), p = f.getItemVisual(t, "decal");
    n.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = Ug(p, n.api));
  }
  e.setStyle(l), e.style.strokeNoScale = !0, e.ensureState("emphasis").style = u, e.ensureState("select").style = c, e.ensureState("blur").style = h, pd(e);
}
function fQ(n, e, t, r, i, o, a) {
  var s = n.data, l = n.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), o)), c = s && s.getItemLayout(o);
  if (l || u || c && c.showLabel) {
    var h = l ? t : o, f = void 0;
    (!s || o >= 0) && (f = i);
    var d = a ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    wi(e, Fr(r), {
      labelFetcher: f,
      labelDataIndex: h,
      defaultText: t
    }, d);
    var p = e.getTextContent();
    if (p && (Ire(p).ignore = p.ignore, e.textConfig && a)) {
      var g = e.getBoundingRect().clone();
      e.textConfig.layoutRect = g, e.textConfig.position = [(a[0] - g.x) / g.width * 100 + "%", (a[1] - g.y) / g.height * 100 + "%"];
    }
    e.disableLabelAnimation = !0;
  } else
    e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
}
function dQ(n, e, t, r, i, o) {
  n.data ? n.data.setItemGraphicEl(o, e) : He(e).eventData = {
    componentType: "geo",
    componentIndex: i.componentIndex,
    geoIndex: i.componentIndex,
    name: t,
    region: r && r.option || {}
  };
}
function pQ(n, e, t, r, i) {
  n.data || Iv({
    el: e,
    componentModel: i,
    itemName: t,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: r.get("tooltip")
  });
}
function gQ(n, e, t, r, i) {
  e.highDownSilentOnTouch = !!i.get("selectedMode");
  var o = r.getModel("emphasis"), a = o.get("focus");
  return Wn(e, a, o.get("blurScope"), o.get("disabled")), n.isGeo && zSt(e, i, t), a;
}
function vQ(n, e, t) {
  var r = [], i;
  function o() {
    i = [];
  }
  function a() {
    i.length && (r.push(i), i = []);
  }
  var s = e({
    polygonStart: o,
    polygonEnd: a,
    lineStart: o,
    lineEnd: a,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !t && s.polygonStart(), I(n, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !t && s.polygonEnd(), r;
}
const Rre = TMt;
var kMt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, o) {
      if (!(o && o.type === "mapToggleSelect" && o.from === this.uid)) {
        var a = this.group;
        if (a.removeAll(), !t.getHostGeoModel()) {
          if (this._mapDraw && o && o.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), o && o.type === "geoRoam" && o.componentType === "series" && o.seriesId === t.id) {
            var s = this._mapDraw;
            s && a.add(s.group);
          } else if (t.needsDrawMap) {
            var s = this._mapDraw || new Rre(i);
            a.add(s.group), s.draw(t, r, i, this, o), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          t.get("showLegendSymbol") && r.getComponent("legend") && this._renderSymbols(t, r, i);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(t, r, i) {
      var o = t.originalData, a = this.group;
      o.each(o.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = o.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, h = u.offset, f = new fh({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: t.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + h * 9,
                cy: c[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (h ? 0 : Dv + 1)
            });
            if (!h) {
              var d = t.mainSeries.getData(), p = o.getName(l), g = d.indexOfName(p), v = o.getItemModel(l), m = v.getModel("label"), y = d.getItemGraphicEl(g);
              wi(f, Fr(v), {
                labelFetcher: {
                  getFormattedLabel: function(b, O) {
                    return t.getFormattedLabel(g, O);
                  }
                },
                defaultText: p
              }), f.disableLabelAnimation = !0, m.get("position") || f.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(b) {
                vS(f, b);
              };
            }
            a.add(f);
          }
        }
      });
    }, e.type = "map", e;
  }(bn)
);
const PMt = kMt;
var EMt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.needsDrawMap = !1, t.seriesGroup = [], t.getTooltipPosition = function(r) {
        if (r != null) {
          var i = this.getData().getName(r), o = this.coordinateSystem, a = o.getRegion(i);
          return a && o.dataToPoint(a.getCenter());
        }
      }, t;
    }
    return e.prototype.getInitialData = function(t) {
      for (var r = Gv(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Je(nN, this)
      }), i = Ee(), o = [], a = 0, s = r.count(); a < s; a++) {
        var l = r.getName(a);
        i.set(l, !0);
      }
      var u = yu.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return I(u.regions, function(c) {
        var h = c.name;
        i.get(h) || o.push(h);
      }), r.appendValues([], o), r;
    }, e.prototype.getHostGeoModel = function() {
      var t = this.option.geoIndex;
      return t != null ? this.ecModel.getComponent("geo", t) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(t) {
      var r = this.getData();
      return r.get(r.mapDimension("value"), t);
    }, e.prototype.getRegionModel = function(t) {
      var r = this.getData();
      return r.getItemModel(r.indexOfName(t));
    }, e.prototype.formatTooltip = function(t, r, i) {
      for (var o = this.getData(), a = this.getRawValue(t), s = o.getName(t), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var h = l[c].originalData.indexOfName(s), f = o.mapDimension("value");
        isNaN(l[c].originalData.get(f, h)) || u.push(l[c].name);
      }
      return Qr("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [Qr("nameValue", {
          name: s,
          value: a
        })]
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.getLegendIcon = function(t) {
      var r = t.icon || "roundRect", i = vr(r, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
      return i.setStyle(t.itemStyle), i.style.stroke = "none", r.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, e.type = "series.map", e.dependencies = ["geo"], e.layoutMode = "box", e.defaultOption = {
      // 一级层叠
      // zlevel: 0,
      // 二级层叠
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(Ln)
);
const MMt = EMt;
function DMt(n, e) {
  var t = {};
  return I(n, function(r) {
    r.each(r.mapDimension("value"), function(i, o) {
      var a = "ec-" + r.getName(o);
      t[a] = t[a] || [], isNaN(i) || t[a].push(i);
    });
  }), n[0].map(n[0].mapDimension("value"), function(r, i) {
    for (var o = "ec-" + n[0].getName(i), a = 0, s = 1 / 0, l = -1 / 0, u = t[o].length, c = 0; c < u; c++)
      s = Math.min(s, t[o][c]), l = Math.max(l, t[o][c]), a += t[o][c];
    var h;
    return e === "min" ? h = s : e === "max" ? h = l : e === "average" ? h = a / u : h = a, u === 0 ? NaN : h;
  });
}
function LMt(n) {
  var e = {};
  n.eachSeriesByType("map", function(t) {
    var r = t.getHostGeoModel(), i = r ? "o" + r.id : "i" + t.getMapType();
    (e[i] = e[i] || []).push(t);
  }), I(e, function(t, r) {
    for (var i = DMt(le(t, function(a) {
      return a.getData();
    }), t[0].get("mapValueCalculation")), o = 0; o < t.length; o++)
      t[o].originalData = t[o].getData();
    for (var o = 0; o < t.length; o++)
      t[o].seriesGroup = t, t[o].needsDrawMap = o === 0 && !t[o].getHostGeoModel(), t[o].setData(i.cloneShallow()), t[o].mainSeries = t[0];
  });
}
function IMt(n) {
  var e = {};
  n.eachSeriesByType("map", function(t) {
    var r = t.getMapType();
    if (!(t.getHostGeoModel() || e[r])) {
      var i = {};
      I(t.seriesGroup, function(a) {
        var s = a.coordinateSystem, l = a.originalData;
        a.get("showLegendSymbol") && n.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
          var h = l.getName(c), f = s.getRegion(h);
          if (!(!f || isNaN(u))) {
            var d = i[h] || 0, p = s.dataToPoint(f.getCenter());
            i[h] = d + 1, l.setItemLayout(c, {
              point: p,
              offset: d
            });
          }
        });
      });
      var o = t.getData();
      o.each(function(a) {
        var s = o.getName(a), l = o.getItemLayout(a) || {};
        l.showLabel = !i[s], o.setItemLayout(a, l);
      }), e[r] = !0;
    }
  });
}
var mQ = vi, e1 = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new Yl(), r._rawTransformable = new Yl(), r.name = t, r;
    }
    return e.prototype.setBoundingRect = function(t, r, i, o) {
      return this._rect = new ot(t, r, i, o), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(t, r, i, o) {
      this._transformTo(t, r, i, o), this._viewRect = new ot(t, r, i, o);
    }, e.prototype._transformTo = function(t, r, i, o) {
      var a = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = a.calculateTransform(new ot(t, r, i, o));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(t, r) {
      t && (this._center = [be(t[0], r.getWidth()), be(t[1], r.getHeight())], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(t) {
      t = t || 1;
      var r = this.zoomLimit;
      r && (r.max != null && (t = Math.min(r.max, t)), r.min != null && (t = Math.max(r.min, t))), this._zoom = t, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var t = this.getBoundingRect(), r = t.x + t.width / 2, i = t.y + t.height / 2;
      return [r, i];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var t = this._rawTransformable.getLocalTransform(), r = this._roamTransformable, i = this.getDefaultCenter(), o = this.getCenter(), a = this.getZoom();
      o = vi([], o, t), i = vi([], i, t), r.originX = o[0], r.originY = o[1], r.x = i[0] - o[0], r.y = i[1] - o[1], r.scaleX = r.scaleY = a, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var t = this._roamTransformable, r = this._rawTransformable;
      r.parent = t, t.updateTransform(), r.updateTransform(), AR(this.transform || (this.transform = []), r.transform || Ho()), this._rawTransform = r.getLocalTransform(), this.invTransform = this.invTransform || [], Ev(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var t = this._rawTransformable, r = this._roamTransformable, i = new Yl();
      return i.transform = r.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: t.x,
          y: t.y,
          scaleX: t.scaleX,
          scaleY: t.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var t = this.getBoundingRect().clone();
      return t.applyTransform(this.transform), t;
    }, e.prototype.dataToPoint = function(t, r, i) {
      var o = r ? this._rawTransform : this.transform;
      return i = i || [], o ? mQ(i, t, o) : Gi(i, t);
    }, e.prototype.pointToData = function(t) {
      var r = this.invTransform;
      return r ? mQ([], t, r) : [t[0], t[1]];
    }, e.prototype.convertToPixel = function(t, r, i) {
      var o = yQ(r);
      return o === this ? o.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, r, i) {
      var o = yQ(r);
      return o === this ? o.pointToData(i) : null;
    }, e.prototype.containPoint = function(t) {
      return this.getViewRectAfterRoam().contain(t[0], t[1]);
    }, e.dimensions = ["x", "y"], e;
  }(Yl)
);
function yQ(n) {
  var e = n.seriesModel;
  return e ? e.coordinateSystem : null;
}
var RMt = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, Nre = ["lng", "lat"], $re = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this, t) || this;
      o.dimensions = Nre, o.type = "geo", o._nameCoordMap = Ee(), o.map = r;
      var a = i.projection, s = yu.load(r, i.nameMap, i.nameProperty), l = yu.getGeoResource(r), u = o.resourceType = l ? l.type : null, c = o.regions = s.regions, h = RMt[l.type];
      o._regionsMap = s.regionsMap, o.regions = s.regions, process.env.NODE_ENV !== "production" && a && (u === "geoSVG" && (process.env.NODE_ENV !== "production" && $n("Map " + r + " with SVG source can't use projection. Only GeoJSON source supports projection."), a = null), a.project && a.unproject || (process.env.NODE_ENV !== "production" && $n("project and unproject must be both provided in the projeciton."), a = null)), o.projection = a;
      var f;
      if (a)
        for (var d = 0; d < c.length; d++) {
          var p = c[d].getBoundingRect(a);
          f = f || p.clone(), f.union(p);
        }
      else
        f = s.boundingRect;
      return o.setBoundingRect(f.x, f.y, f.width, f.height), o.aspectScale = a ? 1 : qe(i.aspectScale, h.aspectScale), o._invertLongitute = a ? !1 : h.invertLongitute, o;
    }
    return e.prototype._transformTo = function(t, r, i, o) {
      var a = this.getBoundingRect(), s = this._invertLongitute;
      a = a.clone(), s && (a.y = -a.y - a.height);
      var l = this._rawTransformable;
      l.transform = a.calculateTransform(new ot(t, r, i, o));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(t) {
      return this._regionsMap.get(t);
    }, e.prototype.getRegionByCoord = function(t) {
      for (var r = this.regions, i = 0; i < r.length; i++) {
        var o = r[i];
        if (o.type === "geoJSON" && o.contain(t))
          return r[i];
      }
    }, e.prototype.addGeoCoord = function(t, r) {
      this._nameCoordMap.set(t, r);
    }, e.prototype.getGeoCoord = function(t) {
      var r = this._regionsMap.get(t);
      return this._nameCoordMap.get(t) || r && r.getCenter();
    }, e.prototype.dataToPoint = function(t, r, i) {
      if (we(t) && (t = this.getGeoCoord(t)), t) {
        var o = this.projection;
        return o && (t = o.project(t)), t && this.projectedToPoint(t, r, i);
      }
    }, e.prototype.pointToData = function(t) {
      var r = this.projection;
      return r && (t = r.unproject(t)), t && this.pointToProjected(t);
    }, e.prototype.pointToProjected = function(t) {
      return n.prototype.pointToData.call(this, t);
    }, e.prototype.projectedToPoint = function(t, r, i) {
      return n.prototype.dataToPoint.call(this, t, r, i);
    }, e.prototype.convertToPixel = function(t, r, i) {
      var o = bQ(r);
      return o === this ? o.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, r, i) {
      var o = bQ(r);
      return o === this ? o.pointToData(i) : null;
    }, e;
  }(e1)
);
mr($re, e1);
function bQ(n) {
  var e = n.geoModel, t = n.seriesModel;
  return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", cr).models[0] || {}).coordinateSystem : null;
}
const OQ = $re;
function wQ(n, e) {
  var t = n.get("boundingCoords");
  if (t != null) {
    var r = t[0], i = t[1];
    if (!(isFinite(r[0]) && isFinite(r[1]) && isFinite(i[0]) && isFinite(i[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var o = this.projection;
      if (o) {
        var a = r[0], s = r[1], l = i[0], u = i[1];
        r = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
        var c = function(x, S, _, C) {
          for (var A = _ - x, k = C - S, P = 0; P <= 100; P++) {
            var L = P / 100, D = o.project([x + A * L, S + k * L]);
            dc(r, r, D), pc(i, i, D);
          }
        };
        c(a, s, l, s), c(l, s, l, u), c(l, u, a, u), c(a, u, l, s);
      }
      this.setBoundingRect(r[0], r[1], i[0] - r[0], i[1] - r[1]);
    }
  }
  var h = this.getBoundingRect(), f = n.get("layoutCenter"), d = n.get("layoutSize"), p = e.getWidth(), g = e.getHeight(), v = h.width / h.height * this.aspectScale, m = !1, y, b;
  f && d && (y = [be(f[0], p), be(f[1], g)], b = be(d, Math.min(p, g)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(b) ? m = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var O;
  if (m)
    O = {}, v > 1 ? (O.width = b, O.height = b / v) : (O.height = b, O.width = b * v), O.y = y[1] - O.height / 2, O.x = y[0] - O.width / 2;
  else {
    var w = n.getBoxLayoutParams();
    w.aspect = v, O = Cr(w, {
      width: p,
      height: g
    });
  }
  this.setViewRect(O.x, O.y, O.width, O.height), this.setCenter(n.get("center"), e), this.setZoom(n.get("zoom"));
}
function NMt(n, e) {
  I(e.get("geoCoord"), function(t, r) {
    n.addGeoCoord(r, t);
  });
}
var $Mt = (
  /** @class */
  function() {
    function n() {
      this.dimensions = Nre;
    }
    return n.prototype.create = function(e, t) {
      var r = [];
      function i(a) {
        return {
          nameProperty: a.get("nameProperty"),
          aspectScale: a.get("aspectScale"),
          projection: a.get("projection")
        };
      }
      e.eachComponent("geo", function(a, s) {
        var l = a.get("map"), u = new OQ(l + s, l, re({
          nameMap: a.get("nameMap")
        }, i(a)));
        u.zoomLimit = a.get("scaleLimit"), r.push(u), a.coordinateSystem = u, u.model = a, u.resize = wQ, u.resize(a, t);
      }), e.eachSeries(function(a) {
        var s = a.get("coordinateSystem");
        if (s === "geo") {
          var l = a.get("geoIndex") || 0;
          a.coordinateSystem = r[l];
        }
      });
      var o = {};
      return e.eachSeriesByType("map", function(a) {
        if (!a.getHostGeoModel()) {
          var s = a.getMapType();
          o[s] = o[s] || [], o[s].push(a);
        }
      }), I(o, function(a, s) {
        var l = le(a, function(c) {
          return c.get("nameMap");
        }), u = new OQ(s, s, re({
          nameMap: xR(l)
        }, i(a[0])));
        u.zoomLimit = ur.apply(null, le(a, function(c) {
          return c.get("scaleLimit");
        })), r.push(u), u.resize = wQ, u.resize(a[0], t), I(a, function(c) {
          c.coordinateSystem = u, NMt(u, c);
        });
      }), r;
    }, n.prototype.getFilledRegions = function(e, t, r, i) {
      for (var o = (e || []).slice(), a = Ee(), s = 0; s < o.length; s++)
        a.set(o[s].name, o[s]);
      var l = yu.load(t, r, i);
      return I(l.regions, function(u) {
        var c = u.name;
        !a.get(c) && o.push({
          name: c
        });
      }), o;
    }, n;
  }()
), BMt = new $Mt();
const Bre = BMt;
var VMt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r, i) {
      var o = yu.getGeoResource(t.map);
      if (o && o.type === "geoJSON") {
        var a = t.itemStyle = t.itemStyle || {};
        "color" in a || (a.color = "#eee");
      }
      this.mergeDefaultAndTheme(t, i), hd(t, "label", ["show"]);
    }, e.prototype.optionUpdated = function() {
      var t = this, r = this.option;
      r.regions = Bre.getFilledRegions(r.regions, r.map, r.nameMap, r.nameProperty);
      var i = {};
      this._optionModelMap = xl(r.regions || [], function(o, a) {
        var s = a.name;
        return s && (o.set(s, new mn(a, t, t.ecModel)), a.selected && (i[s] = !0)), o;
      }, Ee()), r.selectedMap || (r.selectedMap = i);
    }, e.prototype.getRegionModel = function(t) {
      return this._optionModelMap.get(t) || new mn(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(t, r) {
      var i = this.getRegionModel(t), o = r === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), a = {
        name: t
      };
      if (Le(o))
        return a.status = r, o(a);
      if (we(o))
        return o.replace("{a}", t ?? "");
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.select = function(t) {
      var r = this.option, i = r.selectedMode;
      if (i) {
        i !== "multiple" && (r.selectedMap = null);
        var o = r.selectedMap || (r.selectedMap = {});
        o[t] = !0;
      }
    }, e.prototype.unSelect = function(t) {
      var r = this.option.selectedMap;
      r && (r[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      this[this.isSelected(t) ? "unSelect" : "select"](t);
    }, e.prototype.isSelected = function(t) {
      var r = this.option.selectedMap;
      return !!(r && r[t]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, e;
  }(Pt)
);
const zMt = VMt;
function xQ(n, e) {
  return n.pointToProjected ? n.pointToProjected(e) : n.pointToData(e);
}
function zN(n, e, t, r) {
  var i = n.getZoom(), o = n.getCenter(), a = e.zoom, s = n.projectedToPoint ? n.projectedToPoint(o) : n.dataToPoint(o);
  if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, n.setCenter(xQ(n, s), r)), a != null) {
    if (t) {
      var l = t.min || 0, u = t.max || 1 / 0;
      a = Math.max(Math.min(i * a, u), l) / i;
    }
    n.scaleX *= a, n.scaleY *= a;
    var c = (e.originX - n.x) * (a - 1), h = (e.originY - n.y) * (a - 1);
    n.x -= c, n.y -= h, n.updateTransform(), n.setCenter(xQ(n, s), r), n.setZoom(a * i);
  }
  return {
    center: n.getCenter(),
    zoom: n.getZoom()
  };
}
var FMt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.focusBlurEnabled = !0, t;
    }
    return e.prototype.init = function(t, r) {
      this._api = r;
    }, e.prototype.render = function(t, r, i, o) {
      if (this._model = t, !t.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new Rre(i));
      var a = this._mapDraw;
      a.draw(t, r, i, this, o), a.group.on("click", this._handleRegionClick, this), a.group.silent = t.get("silent"), this.group.add(a.group), this.updateSelectStatus(t, r, i);
    }, e.prototype._handleRegionClick = function(t) {
      var r;
      _f(t.target, function(i) {
        return (r = He(i).eventData) != null;
      }, !0), r && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: r.name
      });
    }, e.prototype.updateSelectStatus = function(t, r, i) {
      var o = this;
      this._mapDraw.group.traverse(function(a) {
        var s = He(a).eventData;
        if (s)
          return o._model.isSelected(s.name) ? i.enterSelect(a) : i.leaveSelect(a), !0;
      });
    }, e.prototype.findHighDownDispatchers = function(t) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(Gn)
);
const QMt = FMt;
function ZMt(n, e, t) {
  yu.registerMap(n, e, t);
}
function Vre(n) {
  n.registerCoordinateSystem("geo", Bre), n.registerComponentModel(zMt), n.registerComponentView(QMt), n.registerImpl("registerMap", ZMt), n.registerImpl("getMap", function(t) {
    return yu.getMapForUser(t);
  });
  function e(t, r) {
    r.update = "geo:updateSelectStatus", n.registerAction(r, function(i, o) {
      var a = {}, s = [];
      return o.eachComponent({
        mainType: "geo",
        query: i
      }, function(l) {
        l[t](i.name);
        var u = l.coordinateSystem;
        I(u.regions, function(h) {
          a[h.name] = l.isSelected(h.name) || !1;
        });
        var c = [];
        I(a, function(h, f) {
          a[f] && c.push(f);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: c
        });
      }), {
        selected: a,
        allSelected: s,
        name: i.name
      };
    });
  }
  e("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), e("select", {
    type: "geoSelect",
    event: "geoselected"
  }), e("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), n.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(t, r, i) {
    var o = t.componentType || "series";
    r.eachComponent({
      mainType: o,
      query: t
    }, function(a) {
      var s = a.coordinateSystem;
      if (s.type === "geo") {
        var l = zN(s, t, a.get("scaleLimit"), i);
        a.setCenter && a.setCenter(l.center), a.setZoom && a.setZoom(l.zoom), o === "series" && I(a.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function WMt(n) {
  ft(Vre), n.registerChartView(PMt), n.registerSeriesModel(MMt), n.registerLayout(IMt), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, LMt), Bte("map", n.registerAction);
}
function GMt(n) {
  var e = n;
  e.hierNode = {
    defaultAncestor: null,
    ancestor: e,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var t = [e], r, i; r = t.pop(); )
    if (i = r.children, r.isExpand && i.length)
      for (var o = i.length, a = o - 1; a >= 0; a--) {
        var s = i[a];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: a,
          thread: null
        }, t.push(s);
      }
}
function jMt(n, e) {
  var t = n.isExpand ? n.children : [], r = n.parentNode.children, i = n.hierNode.i ? r[n.hierNode.i - 1] : null;
  if (t.length) {
    YMt(n);
    var o = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2;
    i ? (n.hierNode.prelim = i.hierNode.prelim + e(n, i), n.hierNode.modifier = n.hierNode.prelim - o) : n.hierNode.prelim = o;
  } else
    i && (n.hierNode.prelim = i.hierNode.prelim + e(n, i));
  n.parentNode.hierNode.defaultAncestor = XMt(n, i, n.parentNode.hierNode.defaultAncestor || r[0], e);
}
function HMt(n) {
  var e = n.hierNode.prelim + n.parentNode.hierNode.modifier;
  n.setLayout({
    x: e
  }, !0), n.hierNode.modifier += n.parentNode.hierNode.modifier;
}
function SQ(n) {
  return arguments.length ? n : JMt;
}
function ny(n, e) {
  return n -= Math.PI / 2, {
    x: e * Math.cos(n),
    y: e * Math.sin(n)
  };
}
function qMt(n, e) {
  return Cr(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function YMt(n) {
  for (var e = n.children, t = e.length, r = 0, i = 0; --t >= 0; ) {
    var o = e[t];
    o.hierNode.prelim += r, o.hierNode.modifier += r, i += o.hierNode.change, r += o.hierNode.shift + i;
  }
}
function XMt(n, e, t, r) {
  if (e) {
    for (var i = n, o = n, a = o.parentNode.children[0], s = e, l = i.hierNode.modifier, u = o.hierNode.modifier, c = a.hierNode.modifier, h = s.hierNode.modifier; s = GT(s), o = jT(o), s && o; ) {
      i = GT(i), a = jT(a), i.hierNode.ancestor = n;
      var f = s.hierNode.prelim + h - o.hierNode.prelim - u + r(s, o);
      f > 0 && (KMt(UMt(s, n, t), n, f), u += f, l += f), h += s.hierNode.modifier, u += o.hierNode.modifier, l += i.hierNode.modifier, c += a.hierNode.modifier;
    }
    s && !GT(i) && (i.hierNode.thread = s, i.hierNode.modifier += h - l), o && !jT(a) && (a.hierNode.thread = o, a.hierNode.modifier += u - c, t = n);
  }
  return t;
}
function GT(n) {
  var e = n.children;
  return e.length && n.isExpand ? e[e.length - 1] : n.hierNode.thread;
}
function jT(n) {
  var e = n.children;
  return e.length && n.isExpand ? e[0] : n.hierNode.thread;
}
function UMt(n, e, t) {
  return n.hierNode.ancestor.parentNode === e.parentNode ? n.hierNode.ancestor : t;
}
function KMt(n, e, t) {
  var r = t / (e.hierNode.i - n.hierNode.i);
  e.hierNode.change -= r, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, n.hierNode.change += r;
}
function JMt(n, e) {
  return n.parentNode === e.parentNode ? 1 : 2;
}
var eDt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.parentPoint = [], this.childPoints = [];
    }
    return n;
  }()
), tDt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new eDt();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.childPoints, o = i.length, a = r.parentPoint, s = i[0], l = i[o - 1];
      if (o === 1) {
        t.moveTo(a[0], a[1]), t.lineTo(s[0], s[1]);
        return;
      }
      var u = r.orient, c = u === "TB" || u === "BT" ? 0 : 1, h = 1 - c, f = be(r.forkPosition, 1), d = [];
      d[c] = a[c], d[h] = a[h] + (l[h] - a[h]) * f, t.moveTo(a[0], a[1]), t.lineTo(d[0], d[1]), t.moveTo(s[0], s[1]), d[c] = s[c], t.lineTo(d[0], d[1]), d[c] = l[c], t.lineTo(d[0], d[1]), t.lineTo(l[0], l[1]);
      for (var p = 1; p < o - 1; p++) {
        var g = i[p];
        t.moveTo(g[0], g[1]), d[c] = g[c], t.lineTo(d[0], d[1]);
      }
    }, e;
  }(gt)
), nDt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._mainGroup = new We(), t;
    }
    return e.prototype.init = function(t, r) {
      this._controller = new Jb(r.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, e.prototype.render = function(t, r, i) {
      var o = t.getData(), a = t.layoutInfo, s = this._mainGroup, l = t.get("layout");
      l === "radial" ? (s.x = a.x + a.width / 2, s.y = a.y + a.height / 2) : (s.x = a.x, s.y = a.y), this._updateViewCoordSys(t, i), this._updateController(t, r, i);
      var u = this._data;
      o.diff(u).add(function(c) {
        _Q(o, c) && CQ(o, c, null, s, t);
      }).update(function(c, h) {
        var f = u.getItemGraphicEl(h);
        if (!_Q(o, c)) {
          f && TQ(u, h, f, s, t);
          return;
        }
        CQ(o, c, f, s, t);
      }).remove(function(c) {
        var h = u.getItemGraphicEl(c);
        h && TQ(u, c, h, s, t);
      }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === !0 && o.eachItemGraphicEl(function(c, h) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: t.id,
            dataIndex: h
          });
        });
      }), this._data = o;
    }, e.prototype._updateViewCoordSys = function(t, r) {
      var i = t.getData(), o = [];
      i.each(function(h) {
        var f = i.getItemLayout(h);
        f && !isNaN(f.x) && !isNaN(f.y) && o.push([+f.x, +f.y]);
      });
      var a = [], s = [];
      xC(o, a, s);
      var l = this._min, u = this._max;
      s[0] - a[0] === 0 && (a[0] = l ? l[0] : a[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - a[1] === 0 && (a[1] = l ? l[1] : a[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = t.coordinateSystem = new e1();
      c.zoomLimit = t.get("scaleLimit"), c.setBoundingRect(a[0], a[1], s[0] - a[0], s[1] - a[1]), c.setCenter(t.get("center"), r), c.setZoom(t.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = a, this._max = s;
    }, e.prototype._updateController = function(t, r, i) {
      var o = this, a = this._controller, s = this._controllerHost, l = this.group;
      a.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !GC(u, i, t);
      }), a.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), a.off("pan").off("zoom").on("pan", function(u) {
        $N(s, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        BN(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), o._updateNodeAndLinkScale(t), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function(t) {
      var r = t.getData(), i = this._getNodeGlobalScale(t);
      r.eachItemGraphicEl(function(o, a) {
        o.setSymbolScale(i);
      });
    }, e.prototype._getNodeGlobalScale = function(t) {
      var r = t.coordinateSystem;
      if (r.type !== "view")
        return 1;
      var i = this._nodeScaleRatio, o = r.scaleX || 1, a = r.getZoom(), s = (a - 1) * i + 1;
      return s / o;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, e.type = "tree", e;
  }(bn)
);
function _Q(n, e) {
  var t = n.getItemLayout(e);
  return t && !isNaN(t.x) && !isNaN(t.y);
}
function CQ(n, e, t, r, i) {
  var o = !t, a = n.tree.getNodeByDataIndex(e), s = a.getModel(), l = a.getVisual("style").fill, u = a.isExpand === !1 && a.children.length !== 0 ? l : "#fff", c = n.tree.root, h = a.parentNode === c ? a : a.parentNode || a, f = n.getItemGraphicEl(h.dataIndex), d = h.getLayout(), p = f ? {
    x: f.__oldX,
    y: f.__oldY,
    rawX: f.__radialOldRawX,
    rawY: f.__radialOldRawY
  } : d, g = a.getLayout();
  o ? (t = new Hb(n, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.x = p.x, t.y = p.y) : t.updateData(n, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = g.rawX, t.__radialRawY = g.rawY, r.add(t), n.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, Vt(t, {
    x: g.x,
    y: g.y
  }, i);
  var v = t.getSymbolPath();
  if (i.get("layout") === "radial") {
    var m = c.children[0], y = m.getLayout(), b = m.children.length, O = void 0, w = void 0;
    if (g.x === y.x && a.isExpand === !0 && m.children.length) {
      var x = {
        x: (m.children[0].getLayout().x + m.children[b - 1].getLayout().x) / 2,
        y: (m.children[0].getLayout().y + m.children[b - 1].getLayout().y) / 2
      };
      O = Math.atan2(x.y - y.y, x.x - y.x), O < 0 && (O = Math.PI * 2 + O), w = x.x < y.x, w && (O = O - Math.PI);
    } else
      O = Math.atan2(g.y - y.y, g.x - y.x), O < 0 && (O = Math.PI * 2 + O), a.children.length === 0 || a.children.length !== 0 && a.isExpand === !1 ? (w = g.x < y.x, w && (O = O - Math.PI)) : (w = g.x > y.x, w || (O = O - Math.PI));
    var S = w ? "left" : "right", _ = s.getModel("label"), C = _.get("rotate"), A = C * (Math.PI / 180), k = v.getTextContent();
    k && (v.setTextConfig({
      position: _.get("position") || S,
      rotation: C == null ? -O : A,
      origin: "center"
    }), k.setStyle("verticalAlign", "middle"));
  }
  var P = s.get(["emphasis", "focus"]), L = P === "relative" ? sS(a.getAncestorsIndices(), a.getDescendantIndices()) : P === "ancestor" ? a.getAncestorsIndices() : P === "descendant" ? a.getDescendantIndices() : null;
  L && (He(t).focus = L), rDt(i, a, c, t, p, d, g, r), t.__edge && (t.onHoverStateChange = function(D) {
    if (D !== "blur") {
      var E = a.parentNode && n.getItemGraphicEl(a.parentNode.dataIndex);
      E && E.hoverState === Vb || vS(t.__edge, D);
    }
  });
}
function rDt(n, e, t, r, i, o, a, s) {
  var l = e.getModel(), u = n.get("edgeShape"), c = n.get("layout"), h = n.getOrient(), f = n.get(["lineStyle", "curveness"]), d = n.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = r.__edge;
  if (u === "curve")
    e.parentNode && e.parentNode !== t && (g || (g = r.__edge = new AC({
      shape: wD(c, h, f, i, i)
    })), Vt(g, {
      shape: wD(c, h, f, o, a)
    }, n));
  else if (u === "polyline") {
    if (c === "orthogonal") {
      if (e !== t && e.children && e.children.length !== 0 && e.isExpand === !0) {
        for (var v = e.children, m = [], y = 0; y < v.length; y++) {
          var b = v[y].getLayout();
          m.push([b.x, b.y]);
        }
        g || (g = r.__edge = new tDt({
          shape: {
            parentPoint: [a.x, a.y],
            childPoints: [[a.x, a.y]],
            orient: h,
            forkPosition: d
          }
        })), Vt(g, {
          shape: {
            parentPoint: [a.x, a.y],
            childPoints: m
          }
        }, n);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  g && !(u === "polyline" && !e.isExpand) && (g.useStyle(Be({
    strokeNoScale: !0,
    fill: null
  }, p)), Oi(g, l, "lineStyle"), pd(g), s.add(g));
}
function AQ(n, e, t, r, i) {
  var o = e.tree.root, a = zre(o, n), s = a.source, l = a.sourceLayout, u = e.getItemGraphicEl(n.dataIndex);
  if (u) {
    var c = e.getItemGraphicEl(s.dataIndex), h = c.__edge, f = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? h : void 0), d = r.get("edgeShape"), p = r.get("layout"), g = r.get("orient"), v = r.get(["lineStyle", "curveness"]);
    f && (d === "curve" ? Yc(f, {
      shape: wD(p, g, v, l, l),
      style: {
        opacity: 0
      }
    }, r, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: i
    }) : d === "polyline" && r.get("layout") === "orthogonal" && Yc(f, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, r, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: i
    }));
  }
}
function zre(n, e) {
  for (var t = e.parentNode === n ? e : e.parentNode || e, r; r = t.getLayout(), r == null; )
    t = t.parentNode === n ? t : t.parentNode || t;
  return {
    source: t,
    sourceLayout: r
  };
}
function TQ(n, e, t, r, i) {
  var o = n.tree.getNodeByDataIndex(e), a = n.tree.root, s = zre(a, o).sourceLayout, l = {
    duration: i.get("animationDurationUpdate"),
    easing: i.get("animationEasingUpdate")
  };
  Yc(t, {
    x: s.x + 1,
    y: s.y + 1
  }, i, {
    cb: function() {
      r.remove(t), n.setItemGraphicEl(e, null);
    },
    removeOpt: l
  }), t.fadeOut(null, n.hostModel, {
    fadeLabel: !0,
    animation: l
  }), o.children.forEach(function(u) {
    AQ(u, n, r, i, l);
  }), AQ(o, n, r, i, l);
}
function wD(n, e, t, r, i) {
  var o, a, s, l, u, c, h, f;
  if (n === "radial") {
    u = r.rawX, h = r.rawY, c = i.rawX, f = i.rawY;
    var d = ny(u, h), p = ny(u, h + (f - h) * t), g = ny(c, f + (h - f) * t), v = ny(c, f);
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0
    };
  } else
    u = r.x, h = r.y, c = i.x, f = i.y, (e === "LR" || e === "RL") && (o = u + (c - u) * t, a = h, s = c + (u - c) * t, l = f), (e === "TB" || e === "BT") && (o = u, a = h + (f - h) * t, s = c, l = f + (h - f) * t);
  return {
    x1: u,
    y1: h,
    x2: c,
    y2: f,
    cpx1: o,
    cpy1: a,
    cpx2: s,
    cpy2: l
  };
}
const iDt = nDt;
var Ta = It();
function Fre(n) {
  var e = n.mainData, t = n.datas;
  t || (t = {
    main: e
  }, n.datasAttr = {
    main: "data"
  }), n.datas = n.mainData = null, Qre(e, t, n), I(t, function(r) {
    I(e.TRANSFERABLE_METHODS, function(i) {
      r.wrapMethod(i, Je(oDt, n));
    });
  }), e.wrapMethod("cloneShallow", Je(sDt, n)), I(e.CHANGABLE_METHODS, function(r) {
    e.wrapMethod(r, Je(aDt, n));
  }), $e(t[e.dataType] === e);
}
function oDt(n, e) {
  if (cDt(this)) {
    var t = re({}, Ta(this).datas);
    t[this.dataType] = e, Qre(e, t, n);
  } else
    FN(e, this.dataType, Ta(this).mainData, n);
  return e;
}
function aDt(n, e) {
  return n.struct && n.struct.update(), e;
}
function sDt(n, e) {
  return I(Ta(e).datas, function(t, r) {
    t !== e && FN(t.cloneShallow(), r, e, n);
  }), e;
}
function lDt(n) {
  var e = Ta(this).mainData;
  return n == null || e == null ? e : Ta(e).datas[n];
}
function uDt() {
  var n = Ta(this).mainData;
  return n == null ? [{
    data: n
  }] : le(Ot(Ta(n).datas), function(e) {
    return {
      type: e,
      data: Ta(n).datas[e]
    };
  });
}
function cDt(n) {
  return Ta(n).mainData === n;
}
function Qre(n, e, t) {
  Ta(n).datas = {}, I(e, function(r, i) {
    FN(r, i, n, t);
  });
}
function FN(n, e, t, r) {
  Ta(t).datas[e] = n, Ta(n).mainData = t, n.dataType = e, r.struct && (n[r.structAttr] = r.struct, r.struct[r.datasAttr[e]] = n), n.getLinkedData = lDt, n.getLinkedDataAll = uDt;
}
var hDt = (
  /** @class */
  function() {
    function n(e, t) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = e || "", this.hostTree = t;
    }
    return n.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, n.prototype.eachNode = function(e, t, r) {
      Le(e) && (r = t, t = e, e = null), e = e || {}, we(e) && (e = {
        order: e
      });
      var i = e.order || "preorder", o = this[e.attr || "children"], a;
      i === "preorder" && (a = t.call(r, this));
      for (var s = 0; !a && s < o.length; s++)
        o[s].eachNode(e, t, r);
      i === "postorder" && t.call(r, this);
    }, n.prototype.updateDepthAndHeight = function(e) {
      var t = 0;
      this.depth = e;
      for (var r = 0; r < this.children.length; r++) {
        var i = this.children[r];
        i.updateDepthAndHeight(e + 1), i.height > t && (t = i.height);
      }
      this.height = t + 1;
    }, n.prototype.getNodeById = function(e) {
      if (this.getId() === e)
        return this;
      for (var t = 0, r = this.children, i = r.length; t < i; t++) {
        var o = r[t].getNodeById(e);
        if (o)
          return o;
      }
    }, n.prototype.contains = function(e) {
      if (e === this)
        return !0;
      for (var t = 0, r = this.children, i = r.length; t < i; t++) {
        var o = r[t].contains(e);
        if (o)
          return o;
      }
    }, n.prototype.getAncestors = function(e) {
      for (var t = [], r = e ? this : this.parentNode; r; )
        t.push(r), r = r.parentNode;
      return t.reverse(), t;
    }, n.prototype.getAncestorsIndices = function() {
      for (var e = [], t = this; t; )
        e.push(t.dataIndex), t = t.parentNode;
      return e.reverse(), e;
    }, n.prototype.getDescendantIndices = function() {
      var e = [];
      return this.eachNode(function(t) {
        e.push(t.dataIndex);
      }), e;
    }, n.prototype.getValue = function(e) {
      var t = this.hostTree.data;
      return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex);
    }, n.prototype.setLayout = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t);
    }, n.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostTree, r = t.data.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, n.prototype.setVisual = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t);
    }, n.prototype.getVisual = function(e) {
      return this.hostTree.data.getItemVisual(this.dataIndex, e);
    }, n.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, n.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, n.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var e = this.parentNode.children, t = 0; t < e.length; ++t)
          if (e[t] === this)
            return t;
        return -1;
      }
      return -1;
    }, n.prototype.isAncestorOf = function(e) {
      for (var t = e.parentNode; t; ) {
        if (t === this)
          return !0;
        t = t.parentNode;
      }
      return !1;
    }, n.prototype.isDescendantOf = function(e) {
      return e !== this && e.isAncestorOf(this);
    }, n;
  }()
), QN = (
  /** @class */
  function() {
    function n(e) {
      this.type = "tree", this._nodes = [], this.hostModel = e;
    }
    return n.prototype.eachNode = function(e, t, r) {
      this.root.eachNode(e, t, r);
    }, n.prototype.getNodeByDataIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this._nodes[t];
    }, n.prototype.getNodeById = function(e) {
      return this.root.getNodeById(e);
    }, n.prototype.update = function() {
      for (var e = this.data, t = this._nodes, r = 0, i = t.length; r < i; r++)
        t[r].dataIndex = -1;
      for (var r = 0, i = e.count(); r < i; r++)
        t[e.getRawIndex(r)].dataIndex = r;
    }, n.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, n.createTree = function(e, t, r) {
      var i = new n(t), o = [], a = 1;
      s(e);
      function s(c, h) {
        var f = c.value;
        a = Math.max(a, se(f) ? f.length : 1), o.push(c);
        var d = new hDt(wr(c.name, ""), i);
        h ? fDt(d, h) : i.root = d, i._nodes.push(d);
        var p = c.children;
        if (p)
          for (var g = 0; g < p.length; g++)
            s(p[g], d);
      }
      i.root.updateDepthAndHeight(0);
      var l = Wb(o, {
        coordDimensions: ["value"],
        dimensionsCount: a
      }).dimensions, u = new Ki(l, t);
      return u.initData(o), r && r(u), Fre({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, n;
  }()
);
function fDt(n, e) {
  var t = e.children;
  n.parentNode !== e && (t.push(n), n.parentNode = e);
}
function X0(n, e, t) {
  if (n && ct(e, n.type) >= 0) {
    var r = t.getData().tree.root, i = n.targetNode;
    if (we(i) && (i = r.getNodeById(i)), i && r.contains(i))
      return {
        node: i
      };
    var o = n.targetNodeId;
    if (o != null && (i = r.getNodeById(o)))
      return {
        node: i
      };
  }
}
function Zre(n) {
  for (var e = []; n; )
    n = n.parentNode, n && e.push(n);
  return e.reverse();
}
function ZN(n, e) {
  var t = Zre(n);
  return ct(t, e) >= 0;
}
function HC(n, e) {
  for (var t = []; n; ) {
    var r = n.dataIndex;
    t.push({
      name: n.name,
      dataIndex: r,
      value: e.getRawValue(r)
    }), n = n.parentNode;
  }
  return t.reverse(), t;
}
var dDt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.hasSymbolVisual = !0, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      var r = {
        name: t.name,
        children: t.data
      }, i = t.leaves || {}, o = new mn(i, this, this.ecModel), a = QN.createTree(r, this, s);
      function s(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = a.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (f.parentModel = o), f;
        });
      }
      var l = 0;
      a.eachNode("preorder", function(h) {
        h.depth > l && (l = h.depth);
      });
      var u = t.expandAndCollapse, c = u && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l;
      return a.root.eachNode("preorder", function(h) {
        var f = h.hostTree.data.getRawDataItem(h.dataIndex);
        h.isExpand = f && f.collapsed != null ? !f.collapsed : h.depth <= c;
      }), a.data;
    }, e.prototype.getOrient = function() {
      var t = this.get("orient");
      return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t;
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.formatTooltip = function(t, r, i) {
      for (var o = this.getData().tree, a = o.root.children[0], s = o.getNodeByDataIndex(t), l = s.getValue(), u = s.name; s && s !== a; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return Qr("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treeAncestors = HC(i, this), r.collapsed = !i.isExpand, r;
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, e;
  }(Ln)
);
const pDt = dDt;
function gDt(n, e, t) {
  for (var r = [n], i = [], o; o = r.pop(); )
    if (i.push(o), o.isExpand) {
      var a = o.children;
      if (a.length)
        for (var s = 0; s < a.length; s++)
          r.push(a[s]);
    }
  for (; o = i.pop(); )
    e(o, t);
}
function Tm(n, e) {
  for (var t = [n], r; r = t.pop(); )
    if (e(r), r.isExpand) {
      var i = r.children;
      if (i.length)
        for (var o = i.length - 1; o >= 0; o--)
          t.push(i[o]);
    }
}
function vDt(n, e) {
  n.eachSeriesByType("tree", function(t) {
    mDt(t, e);
  });
}
function mDt(n, e) {
  var t = qMt(n, e);
  n.layoutInfo = t;
  var r = n.get("layout"), i = 0, o = 0, a = null;
  r === "radial" ? (i = 2 * Math.PI, o = Math.min(t.height, t.width) / 2, a = SQ(function(b, O) {
    return (b.parentNode === O.parentNode ? 1 : 2) / b.depth;
  })) : (i = t.width, o = t.height, a = SQ());
  var s = n.getData().tree.root, l = s.children[0];
  if (l) {
    GMt(s), gDt(l, jMt, a), s.hierNode.modifier = -l.hierNode.prelim, Tm(l, HMt);
    var u = l, c = l, h = l;
    Tm(l, function(b) {
      var O = b.getLayout().x;
      O < u.getLayout().x && (u = b), O > c.getLayout().x && (c = b), b.depth > h.depth && (h = b);
    });
    var f = u === c ? 1 : a(u, c) / 2, d = f - u.getLayout().x, p = 0, g = 0, v = 0, m = 0;
    if (r === "radial")
      p = i / (c.getLayout().x + f + d), g = o / (h.depth - 1 || 1), Tm(l, function(b) {
        v = (b.getLayout().x + d) * p, m = (b.depth - 1) * g;
        var O = ny(v, m);
        b.setLayout({
          x: O.x,
          y: O.y,
          rawX: v,
          rawY: m
        }, !0);
      });
    else {
      var y = n.getOrient();
      y === "RL" || y === "LR" ? (g = o / (c.getLayout().x + f + d), p = i / (h.depth - 1 || 1), Tm(l, function(b) {
        m = (b.getLayout().x + d) * g, v = y === "LR" ? (b.depth - 1) * p : i - (b.depth - 1) * p, b.setLayout({
          x: v,
          y: m
        }, !0);
      })) : (y === "TB" || y === "BT") && (p = i / (c.getLayout().x + f + d), g = o / (h.depth - 1 || 1), Tm(l, function(b) {
        v = (b.getLayout().x + d) * p, m = y === "TB" ? (b.depth - 1) * g : o - (b.depth - 1) * g, b.setLayout({
          x: v,
          y: m
        }, !0);
      }));
    }
  }
}
function yDt(n) {
  n.eachSeriesByType("tree", function(e) {
    var t = e.getData(), r = t.tree;
    r.eachNode(function(i) {
      var o = i.getModel(), a = o.getModel("itemStyle").getItemStyle(), s = t.ensureUniqueItemVisual(i.dataIndex, "style");
      re(s, a);
    });
  });
}
function bDt(n) {
  n.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(r) {
      var i = e.dataIndex, o = r.getData().tree, a = o.getNodeByDataIndex(i);
      a.isExpand = !a.isExpand;
    });
  }), n.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(e, t, r) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(i) {
      var o = i.coordinateSystem, a = zN(o, e, void 0, r);
      i.setCenter && i.setCenter(a.center), i.setZoom && i.setZoom(a.zoom);
    });
  });
}
function ODt(n) {
  n.registerChartView(iDt), n.registerSeriesModel(pDt), n.registerLayout(vDt), n.registerVisual(yDt), bDt(n);
}
var kQ = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function wDt(n) {
  for (var e = 0; e < kQ.length; e++)
    n.registerAction({
      type: kQ[e],
      update: "updateView"
    }, nr);
  n.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: t
    }, i);
    function i(o, a) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = X0(t, s, o);
      if (l) {
        var u = o.getViewRoot();
        u && (t.direction = ZN(u, l.node) ? "rollUp" : "drillDown"), o.resetViewRoot(l.node);
      }
    }
  });
}
function Wre(n) {
  var e = n.getData(), t = e.tree, r = {};
  t.eachNode(function(i) {
    for (var o = i; o && o.depth > 1; )
      o = o.parentNode;
    var a = XM(n.ecModel, o.name || o.dataIndex + "", r);
    i.setVisual("decal", a);
  });
}
var xDt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.preventUsingHoverLayer = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = {
        name: t.name,
        children: t.data
      };
      Gre(i);
      var o = t.levels || [], a = this.designatedVisualItemStyle = {}, s = new mn({
        itemStyle: a
      }, this, r);
      o = t.levels = SDt(o, r);
      var l = le(o || [], function(h) {
        return new mn(h, s, r);
      }, this), u = QN.createTree(i, this, c);
      function c(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = u.getNodeByDataIndex(d), g = p ? l[p.depth] : null;
          return f.parentModel = g || s, f;
        });
      }
      return u.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.formatTooltip = function(t, r, i) {
      var o = this.getData(), a = this.getRawValue(t), s = o.getName(t);
      return Qr("nameValue", {
        name: s,
        value: a
      });
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treeAncestors = HC(i, this), r.treePathInfo = r.treeAncestors, r;
    }, e.prototype.setLayoutInfo = function(t) {
      this.layoutInfo = this.layoutInfo || {}, re(this.layoutInfo, t);
    }, e.prototype.mapIdToIndex = function(t) {
      var r = this._idIndexMap;
      r || (r = this._idIndexMap = Ee(), this._idIndexMapCount = 0);
      var i = r.get(t);
      return i == null && r.set(t, i = this._idIndexMapCount++), i;
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!t || t !== r && !r.contains(t)) && (this._viewRoot = r);
    }, e.prototype.enableAriaDecal = function() {
      Wre(this);
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "▶",
      // to align specialized icon. ▷▶❒❐▼✚
      zoomToNodeRatio: 0.32 * 0.32,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, e;
  }(Ln)
);
function Gre(n) {
  var e = 0;
  I(n.children, function(r) {
    Gre(r);
    var i = r.value;
    se(i) && (i = i[0]), e += i;
  });
  var t = n.value;
  se(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), se(n.value) ? n.value[0] = t : n.value = t;
}
function SDt(n, e) {
  var t = an(e.get("color")), r = an(e.get(["aria", "decal", "decals"]));
  if (t) {
    n = n || [];
    var i, o;
    I(n, function(s) {
      var l = new mn(s), u = l.get("color"), c = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || c && c !== "none") && (o = !0);
    });
    var a = n[0] || (n[0] = {});
    return i || (a.color = t.slice()), !o && r && (a.decal = r.slice()), n;
  }
}
const _Dt = xDt;
var CDt = 8, PQ = 8, HT = 5, ADt = (
  /** @class */
  function() {
    function n(e) {
      this.group = new We(), e.add(this.group);
    }
    return n.prototype.render = function(e, t, r, i) {
      var o = e.getModel("breadcrumb"), a = this.group;
      if (a.removeAll(), !(!o.get("show") || !r)) {
        var s = o.getModel("itemStyle"), l = o.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel(["itemStyle", "textStyle"]), h = {
          pos: {
            left: o.get("left"),
            right: o.get("right"),
            top: o.get("top"),
            bottom: o.get("bottom")
          },
          box: {
            width: t.getWidth(),
            height: t.getHeight()
          },
          emptyItemWidth: o.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(r, h, u), this._renderContent(e, h, s, l, u, c, i), RC(a, h.pos, h.box);
      }
    }, n.prototype._prepare = function(e, t, r) {
      for (var i = e; i; i = i.parentNode) {
        var o = wr(i.getModel().get("name"), ""), a = r.getTextRect(o), s = Math.max(a.width + CDt * 2, t.emptyItemWidth);
        t.totalWidth += s + PQ, t.renderList.push({
          node: i,
          text: o,
          width: s
        });
      }
    }, n.prototype._renderContent = function(e, t, r, i, o, a, s) {
      for (var l = 0, u = t.emptyItemWidth, c = e.get(["breadcrumb", "height"]), h = q_t(t.pos, t.box), f = t.totalWidth, d = t.renderList, p = i.getModel("itemStyle").getItemStyle(), g = d.length - 1; g >= 0; g--) {
        var v = d[g], m = v.node, y = v.width, b = v.text;
        f > h.width && (f -= y - u, y = u, b = null);
        var O = new ro({
          shape: {
            points: TDt(l, 0, y, c, g === d.length - 1, g === 0)
          },
          style: Be(r.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new Nt({
            style: vn(o, {
              text: b
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: Dv * 1e4,
          onclick: Je(s, m)
        });
        O.disableLabelAnimation = !0, O.getTextContent().ensureState("emphasis").style = vn(a, {
          text: b
        }), O.ensureState("emphasis").style = p, Wn(O, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(O), kDt(O, e, m), l += y + PQ;
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n;
  }()
);
function TDt(n, e, t, r, i, o) {
  var a = [[i ? n : n - HT, e], [n + t, e], [n + t, e + r], [i ? n : n - HT, e + r]];
  return !o && a.splice(2, 0, [n + t + HT, e + r / 2]), !i && a.push([n, e + r / 2]), a;
}
function kDt(n, e, t) {
  He(n).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: e.componentIndex,
    seriesIndex: e.seriesIndex,
    seriesName: e.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: t && t.dataIndex,
      name: t && t.name
    },
    treePathInfo: t && HC(t, e)
  };
}
const PDt = ADt;
var EDt = (
  /** @class */
  function() {
    function n() {
      this._storage = [], this._elExistsMap = {};
    }
    return n.prototype.add = function(e, t, r, i, o) {
      return this._elExistsMap[e.id] ? !1 : (this._elExistsMap[e.id] = !0, this._storage.push({
        el: e,
        target: t,
        duration: r,
        delay: i,
        easing: o
      }), !0);
    }, n.prototype.finished = function(e) {
      return this._finishedCallback = e, this;
    }, n.prototype.start = function() {
      for (var e = this, t = this._storage.length, r = function() {
        t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback());
      }, i = 0, o = this._storage.length; i < o; i++) {
        var a = this._storage[i];
        a.el.animateTo(a.target, {
          duration: a.duration,
          delay: a.delay,
          easing: a.easing,
          setToFinal: !0,
          done: r,
          aborted: r
        });
      }
      return this;
    }, n;
  }()
);
function MDt() {
  return new EDt();
}
var xD = We, EQ = Lt, MQ = 3, DQ = "label", LQ = "upperLabel", DDt = Dv * 10, LDt = Dv * 2, IDt = Dv * 3, Xh = dd([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), IQ = function(n) {
  var e = Xh(n);
  return e.stroke = e.fill = e.lineWidth = null, e;
}, zS = It(), RDt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._state = "ready", t._storage = km(), t;
    }
    return e.prototype.render = function(t, r, i, o) {
      var a = r.findComponents({
        mainType: "series",
        subType: "treemap",
        query: o
      });
      if (!(ct(a, t) < 0)) {
        this.seriesModel = t, this.api = i, this.ecModel = r;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = X0(o, s, t), u = o && o.type, c = t.layoutInfo, h = !this._oldTree, f = this._storage, d = u === "treemapRootToNode" && l && f ? {
          rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
          direction: o.direction
        } : null, p = this._giveContainerGroup(c), g = t.get("animation"), v = this._doRender(p, t, d);
        g && !h && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, t, d) : v.renderFinally(), this._resetController(i), this._renderBreadcrumb(t, i, l);
      }
    }, e.prototype._giveContainerGroup = function(t) {
      var r = this._containerGroup;
      return r || (r = this._containerGroup = new xD(), this._initEvents(r), this.group.add(r)), r.x = t.x, r.y = t.y, r;
    }, e.prototype._doRender = function(t, r, i) {
      var o = r.getData().tree, a = this._oldTree, s = km(), l = km(), u = this._storage, c = [];
      function h(v, m, y, b) {
        return NDt(r, l, u, i, s, c, v, m, y, b);
      }
      d(o.root ? [o.root] : [], a && a.root ? [a.root] : [], t, o === a || !a, 0);
      var f = p(u);
      return this._oldTree = o, this._storage = l, {
        lastsForAnimation: s,
        willDeleteEls: f,
        renderFinally: g
      };
      function d(v, m, y, b, O) {
        b ? (m = v, I(v, function(S, _) {
          !S.isRemoved() && x(_, _);
        })) : new mu(m, v, w, w).add(x).update(x).remove(Je(x, null)).execute();
        function w(S) {
          return S.getId();
        }
        function x(S, _) {
          var C = S != null ? v[S] : null, A = _ != null ? m[_] : null, k = h(C, A, y, O);
          k && d(C && C.viewChildren || [], A && A.viewChildren || [], k, b, O + 1);
        }
      }
      function p(v) {
        var m = km();
        return v && I(v, function(y, b) {
          var O = m[b];
          I(y, function(w) {
            w && (O.push(w), zS(w).willDelete = !0);
          });
        }), m;
      }
      function g() {
        I(f, function(v) {
          I(v, function(m) {
            m.parent && m.parent.remove(m);
          });
        }), I(c, function(v) {
          v.invisible = !0, v.dirty();
        });
      }
    }, e.prototype._doAnimation = function(t, r, i, o) {
      var a = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (Le(a) ? 0 : a) || 0, u = (Le(s) ? null : s) || "cubicOut", c = MDt();
      I(r.willDeleteEls, function(h, f) {
        I(h, function(d, p) {
          if (!d.invisible) {
            var g = d.parent, v, m = zS(g);
            if (o && o.direction === "drillDown")
              v = g === o.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: m.nodeWidth,
                  height: m.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var y = 0, b = 0;
              m.willDelete || (y = m.nodeWidth / 2, b = m.nodeHeight / 2), v = f === "nodeGroup" ? {
                x: y,
                y: b,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: b,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && c.add(d, v, l, 0, u);
          }
        });
      }), I(this._storage, function(h, f) {
        I(h, function(d, p) {
          var g = r.lastsForAnimation[f][p], v = {};
          g && (d instanceof We ? g.oldX != null && (v.x = d.x, v.y = d.y, d.x = g.oldX, d.y = g.oldY) : (g.oldShape && (v.shape = re({}, d.shape), d.setShape(g.oldShape)), g.fadein ? (d.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), c.add(d, v, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(_e(function() {
        this._state = "ready", r.renderFinally();
      }, this)).start();
    }, e.prototype._resetController = function(t) {
      var r = this._controller;
      r || (r = this._controller = new Jb(t.getZr()), r.enable(this.seriesModel.get("roam")), r.on("pan", _e(this._onPan, this)), r.on("zoom", _e(this._onZoom, this)));
      var i = new ot(0, 0, t.getWidth(), t.getHeight());
      r.setPointerChecker(function(o, a, s) {
        return i.contain(a, s);
      });
    }, e.prototype._clearController = function() {
      var t = this._controller;
      t && (t.dispose(), t = null);
    }, e.prototype._onPan = function(t) {
      if (this._state !== "animating" && (Math.abs(t.dx) > MQ || Math.abs(t.dy) > MQ)) {
        var r = this.seriesModel.getData().tree.root;
        if (!r)
          return;
        var i = r.getLayout();
        if (!i)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + t.dx,
            y: i.y + t.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, e.prototype._onZoom = function(t) {
      var r = t.originX, i = t.originY;
      if (this._state !== "animating") {
        var o = this.seriesModel.getData().tree.root;
        if (!o)
          return;
        var a = o.getLayout();
        if (!a)
          return;
        var s = new ot(a.x, a.y, a.width, a.height), l = this.seriesModel.layoutInfo;
        r -= l.x, i -= l.y;
        var u = Ho();
        Sl(u, u, [-r, -i]), TR(u, u, [t.scale, t.scale]), Sl(u, u, [r, i]), s.applyTransform(u), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: s.x,
            y: s.y,
            width: s.width,
            height: s.height
          }
        });
      }
    }, e.prototype._initEvents = function(t) {
      var r = this;
      t.on("click", function(i) {
        if (r._state === "ready") {
          var o = r.seriesModel.get("nodeClick", !0);
          if (o) {
            var a = r.findTarget(i.offsetX, i.offsetY);
            if (a) {
              var s = a.node;
              if (s.getLayout().isLeafRoot)
                r._rootToNode(a);
              else if (o === "zoomToNode")
                r._zoomToNode(a);
              else if (o === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), c = l.get("target", !0) || "blank";
                u && xS(u, c);
              }
            }
          }
        }
      }, this);
    }, e.prototype._renderBreadcrumb = function(t, r, i) {
      var o = this;
      i || (i = t.get("leafDepth", !0) != null ? {
        node: t.getViewRoot()
      } : this.findTarget(r.getWidth() / 2, r.getHeight() / 2), i || (i = {
        node: t.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new PDt(this.group))).render(t, r, i.node, function(a) {
        o._state !== "animating" && (ZN(t.getViewRoot(), a) ? o._rootToNode({
          node: a
        }) : o._zoomToNode({
          node: a
        }));
      });
    }, e.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = km(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, e.prototype.dispose = function() {
      this._clearController();
    }, e.prototype._zoomToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype._rootToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype.findTarget = function(t, r) {
      var i, o = this.seriesModel.getViewRoot();
      return o.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(a) {
        var s = this._storage.background[a.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(t, r), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            i = {
              node: a,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), i;
    }, e.type = "treemap", e;
  }(bn)
);
function km() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function NDt(n, e, t, r, i, o, a, s, l, u) {
  if (!a)
    return;
  var c = a.getLayout(), h = n.getData(), f = a.getModel();
  if (h.setItemGraphicEl(a.dataIndex, null), !c || !c.isInView)
    return;
  var d = c.width, p = c.height, g = c.borderWidth, v = c.invisible, m = a.getRawIndex(), y = s && s.getRawIndex(), b = a.viewChildren, O = c.upperHeight, w = b && b.length, x = f.getModel("itemStyle"), S = f.getModel(["emphasis", "itemStyle"]), _ = f.getModel(["blur", "itemStyle"]), C = f.getModel(["select", "itemStyle"]), A = x.get("borderRadius") || 0, k = X("nodeGroup", xD);
  if (!k)
    return;
  if (l.add(k), k.x = c.x || 0, k.y = c.y || 0, k.markRedraw(), zS(k).nodeWidth = d, zS(k).nodeHeight = p, c.isAboveViewRoot)
    return k;
  var P = X("background", EQ, u, LDt);
  P && $(k, P, w && c.upperLabelHeight);
  var L = f.getModel("emphasis"), D = L.get("focus"), E = L.get("blurScope"), M = L.get("disabled"), R = D === "ancestor" ? a.getAncestorsIndices() : D === "descendant" ? a.getDescendantIndices() : D;
  if (w)
    qc(k) && xf(k, !1), P && (xf(P, !M), h.setItemGraphicEl(a.dataIndex, P), FM(P, R, E));
  else {
    var N = X("content", EQ, u, IDt);
    N && F(k, N), P.disableMorphing = !0, P && qc(P) && xf(P, !1), xf(k, !M), h.setItemGraphicEl(a.dataIndex, k), FM(k, R, E);
  }
  return k;
  function $(ee, ne, ye) {
    var te = He(ne);
    if (te.dataIndex = a.dataIndex, te.seriesIndex = n.seriesIndex, ne.setShape({
      x: 0,
      y: 0,
      width: d,
      height: p,
      r: A
    }), v)
      W(ne);
    else {
      ne.invisible = !1;
      var ue = a.getVisual("style"), xe = ue.stroke, dt = IQ(x);
      dt.fill = xe;
      var Ue = Xh(S);
      Ue.fill = S.get("borderColor");
      var Rt = Xh(_);
      Rt.fill = _.get("borderColor");
      var zt = Xh(C);
      if (zt.fill = C.get("borderColor"), ye) {
        var tn = d - 2 * g;
        j(
          // PENDING: convert ZRColor to ColorString for text.
          ne,
          xe,
          ue.opacity,
          {
            x: g,
            y: 0,
            width: tn,
            height: O
          }
        );
      } else
        ne.removeTextContent();
      ne.setStyle(dt), ne.ensureState("emphasis").style = Ue, ne.ensureState("blur").style = Rt, ne.ensureState("select").style = zt, pd(ne);
    }
    ee.add(ne);
  }
  function F(ee, ne) {
    var ye = He(ne);
    ye.dataIndex = a.dataIndex, ye.seriesIndex = n.seriesIndex;
    var te = Math.max(d - 2 * g, 0), ue = Math.max(p - 2 * g, 0);
    if (ne.culling = !0, ne.setShape({
      x: g,
      y: g,
      width: te,
      height: ue,
      r: A
    }), v)
      W(ne);
    else {
      ne.invisible = !1;
      var xe = a.getVisual("style"), dt = xe.fill, Ue = IQ(x);
      Ue.fill = dt, Ue.decal = xe.decal;
      var Rt = Xh(S), zt = Xh(_), tn = Xh(C);
      j(ne, dt, xe.opacity, null), ne.setStyle(Ue), ne.ensureState("emphasis").style = Rt, ne.ensureState("blur").style = zt, ne.ensureState("select").style = tn, pd(ne);
    }
    ee.add(ne);
  }
  function W(ee) {
    !ee.invisible && o.push(ee);
  }
  function j(ee, ne, ye, te) {
    var ue = f.getModel(te ? LQ : DQ), xe = wr(f.get("name"), null), dt = ue.getShallow("show");
    wi(ee, Fr(f, te ? LQ : DQ), {
      defaultText: dt ? xe : null,
      inheritColor: ne,
      defaultOpacity: ye,
      labelFetcher: n,
      labelDataIndex: a.dataIndex
    });
    var Ue = ee.getTextContent();
    if (Ue) {
      var Rt = Ue.style, zt = _R(Rt.padding || 0);
      te && (ee.setTextConfig({
        layoutRect: te
      }), Ue.disableLabelLayout = !0), Ue.beforeUpdate = function() {
        var jn = Math.max((te ? te.width : ee.shape.width) - zt[1] - zt[3], 0), An = Math.max((te ? te.height : ee.shape.height) - zt[0] - zt[2], 0);
        (Rt.width !== jn || Rt.height !== An) && Ue.setStyle({
          width: jn,
          height: An
        });
      }, Rt.truncateMinChar = 2, Rt.lineOverflow = "truncate", Y(Rt, te, c);
      var tn = Ue.getState("emphasis");
      Y(tn ? tn.style : null, te, c);
    }
  }
  function Y(ee, ne, ye) {
    var te = ee ? ee.text : null;
    if (!ne && ye.isLeafRoot && te != null) {
      var ue = n.get("drillDownIcon", !0);
      ee.text = ue ? ue + " " + te : te;
    }
  }
  function X(ee, ne, ye, te) {
    var ue = y != null && t[ee][y], xe = i[ee];
    return ue ? (t[ee][y] = null, ie(xe, ue)) : v || (ue = new ne(), ue instanceof Ia && (ue.z2 = $Dt(ye, te)), ae(xe, ue)), e[ee][m] = ue;
  }
  function ie(ee, ne) {
    var ye = ee[m] = {};
    ne instanceof xD ? (ye.oldX = ne.x, ye.oldY = ne.y) : ye.oldShape = re({}, ne.shape);
  }
  function ae(ee, ne) {
    var ye = ee[m] = {}, te = a.parentNode, ue = ne instanceof We;
    if (te && (!r || r.direction === "drillDown")) {
      var xe = 0, dt = 0, Ue = i.background[te.getRawIndex()];
      !r && Ue && Ue.oldShape && (xe = Ue.oldShape.width, dt = Ue.oldShape.height), ue ? (ye.oldX = 0, ye.oldY = dt) : ye.oldShape = {
        x: xe,
        y: dt,
        width: 0,
        height: 0
      };
    }
    ye.fadein = !ue;
  }
}
function $Dt(n, e) {
  return n * DDt + e;
}
const BDt = RDt;
var U0 = I, VDt = Ne, FS = -1, WN = (
  /** @class */
  function() {
    function n(e) {
      var t = e.mappingMethod, r = e.type, i = this.option = Fe(e);
      this.type = r, this.mappingMethod = t, this._normalizeData = QDt[t];
      var o = n.visualHandlers[r];
      this.applyVisual = o.applyVisual, this.getColorMapper = o.getColorMapper, this._normalizedToVisual = o._normalizedToVisual[t], t === "piecewise" ? (qT(i), zDt(i)) : t === "category" ? i.categories ? FDt(i) : qT(i, !0) : ($e(t !== "linear" || i.dataExtent), qT(i));
    }
    return n.prototype.mapValueToVisual = function(e) {
      var t = this._normalizeData(e);
      return this._normalizedToVisual(t, e);
    }, n.prototype.getNormalizer = function() {
      return _e(this._normalizeData, this);
    }, n.listVisualTypes = function() {
      return Ot(n.visualHandlers);
    }, n.isValidType = function(e) {
      return n.visualHandlers.hasOwnProperty(e);
    }, n.eachVisual = function(e, t, r) {
      Ne(e) ? I(e, t, r) : t.call(r, e);
    }, n.mapVisual = function(e, t, r) {
      var i, o = se(e) ? [] : Ne(e) ? {} : (i = !0, null);
      return n.eachVisual(e, function(a, s) {
        var l = t.call(r, a, s);
        i ? o = l : o[s] = l;
      }), o;
    }, n.retrieveVisuals = function(e) {
      var t = {}, r;
      return e && U0(n.visualHandlers, function(i, o) {
        e.hasOwnProperty(o) && (t[o] = e[o], r = !0);
      }), r ? t : null;
    }, n.prepareVisualTypes = function(e) {
      if (se(e))
        e = e.slice();
      else if (VDt(e)) {
        var t = [];
        U0(e, function(r, i) {
          t.push(i);
        }), e = t;
      } else
        return [];
      return e.sort(function(r, i) {
        return i === "color" && r !== "color" && r.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, n.dependsOn = function(e, t) {
      return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t;
    }, n.findPieceIndex = function(e, t, r) {
      for (var i, o = 1 / 0, a = 0, s = t.length; a < s; a++) {
        var l = t[a].value;
        if (l != null) {
          if (l === e || we(l) && l === e + "")
            return a;
          r && f(l, a);
        }
      }
      for (var a = 0, s = t.length; a < s; a++) {
        var u = t[a], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (zO(h[1], e, c[1]))
              return a;
          } else if (c[1] === 1 / 0) {
            if (zO(h[0], c[0], e))
              return a;
          } else if (zO(h[0], c[0], e) && zO(h[1], e, c[1]))
            return a;
          r && f(c[0], a), r && f(c[1], a);
        }
      }
      if (r)
        return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : i;
      function f(d, p) {
        var g = Math.abs(d - e);
        g < o && (o = g, i = p);
      }
    }, n.visualHandlers = {
      color: {
        applyVisual: Pm("color"),
        getColorMapper: function() {
          var e = this.option;
          return _e(e.mappingMethod === "category" ? function(t, r) {
            return !r && (t = this._normalizeData(t)), ry.call(this, t);
          } : function(t, r, i) {
            var o = !!i;
            return !r && (t = this._normalizeData(t)), i = AA(t, e.parsedVisual, i), o ? i : tu(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return tu(AA(e, this.option.parsedVisual), "rgba");
          },
          category: ry,
          piecewise: function(e, t) {
            var r = _D.call(this, t);
            return r == null && (r = tu(AA(e, this.option.parsedVisual), "rgba")), r;
          },
          fixed: Uh
        }
      },
      colorHue: VO(function(e, t) {
        return My(e, t);
      }),
      colorSaturation: VO(function(e, t) {
        return My(e, null, t);
      }),
      colorLightness: VO(function(e, t) {
        return My(e, null, null, t);
      }),
      colorAlpha: VO(function(e, t) {
        return cS(e, t);
      }),
      decal: {
        applyVisual: Pm("decal"),
        _normalizedToVisual: {
          linear: null,
          category: ry,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: Pm("opacity"),
        _normalizedToVisual: SD([0, 1])
      },
      liftZ: {
        applyVisual: Pm("liftZ"),
        _normalizedToVisual: {
          linear: Uh,
          category: Uh,
          piecewise: Uh,
          fixed: Uh
        }
      },
      symbol: {
        applyVisual: function(e, t, r) {
          var i = this.mapValueToVisual(e);
          r("symbol", i);
        },
        _normalizedToVisual: {
          linear: RQ,
          category: ry,
          piecewise: function(e, t) {
            var r = _D.call(this, t);
            return r == null && (r = RQ.call(this, e)), r;
          },
          fixed: Uh
        }
      },
      symbolSize: {
        applyVisual: Pm("symbolSize"),
        _normalizedToVisual: SD([0, 1])
      }
    }, n;
  }()
);
function zDt(n) {
  var e = n.pieceList;
  n.hasSpecialVisual = !1, I(e, function(t, r) {
    t.originIndex = r, t.visual != null && (n.hasSpecialVisual = !0);
  });
}
function FDt(n) {
  var e = n.categories, t = n.categoryMap = {}, r = n.visual;
  if (U0(e, function(a, s) {
    t[a] = s;
  }), !se(r)) {
    var i = [];
    Ne(r) ? U0(r, function(a, s) {
      var l = t[s];
      i[l ?? FS] = a;
    }) : i[FS] = r, r = jre(n, i);
  }
  for (var o = e.length - 1; o >= 0; o--)
    r[o] == null && (delete t[e[o]], e.pop());
}
function qT(n, e) {
  var t = n.visual, r = [];
  Ne(t) ? U0(t, function(o) {
    r.push(o);
  }) : t != null && r.push(t);
  var i = {
    color: 1,
    symbol: 1
  };
  !e && r.length === 1 && !i.hasOwnProperty(n.type) && (r[1] = r[0]), jre(n, r);
}
function VO(n) {
  return {
    applyVisual: function(e, t, r) {
      var i = this.mapValueToVisual(e);
      r("color", n(t("color"), i));
    },
    _normalizedToVisual: SD([0, 1])
  };
}
function RQ(n) {
  var e = this.option.visual;
  return e[Math.round(Yt(n, [0, 1], [0, e.length - 1], !0))] || {};
}
function Pm(n) {
  return function(e, t, r) {
    r(n, this.mapValueToVisual(e));
  };
}
function ry(n) {
  var e = this.option.visual;
  return e[this.option.loop && n !== FS ? n % e.length : n];
}
function Uh() {
  return this.option.visual[0];
}
function SD(n) {
  return {
    linear: function(e) {
      return Yt(e, n, this.option.visual, !0);
    },
    category: ry,
    piecewise: function(e, t) {
      var r = _D.call(this, t);
      return r == null && (r = Yt(e, n, this.option.visual, !0)), r;
    },
    fixed: Uh
  };
}
function _D(n) {
  var e = this.option, t = e.pieceList;
  if (e.hasSpecialVisual) {
    var r = WN.findPieceIndex(n, t), i = t[r];
    if (i && i.visual)
      return i.visual[this.type];
  }
}
function jre(n, e) {
  return n.visual = e, n.type === "color" && (n.parsedVisual = le(e, function(t) {
    var r = qo(t);
    return !r && process.env.NODE_ENV !== "production" && $n("'" + t + "' is an illegal color, fallback to '#000000'", !0), r || [0, 0, 0, 1];
  })), e;
}
var QDt = {
  linear: function(n) {
    return Yt(n, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(n) {
    var e = this.option.pieceList, t = WN.findPieceIndex(n, e, !0);
    if (t != null)
      return Yt(t, [0, e.length - 1], [0, 1], !0);
  },
  category: function(n) {
    var e = this.option.categories ? this.option.categoryMap[n] : n;
    return e ?? FS;
  },
  fixed: nr
};
function zO(n, e, t) {
  return n ? e <= t : e < t;
}
const mi = WN;
var ZDt = "itemStyle", Hre = It();
const WDt = {
  seriesType: "treemap",
  reset: function(n) {
    var e = n.getData().tree, t = e.root;
    t.isRemoved() || qre(
      t,
      // Visual should calculate from tree root but not view root.
      {},
      n.getViewRoot().getAncestors(),
      n
    );
  }
};
function qre(n, e, t, r) {
  var i = n.getModel(), o = n.getLayout(), a = n.hostTree.data;
  if (!(!o || o.invisible || !o.isInView)) {
    var s = i.getModel(ZDt), l = GDt(s, e, r), u = a.ensureUniqueItemVisual(n.dataIndex, "style"), c = s.get("borderColor"), h = s.get("borderColorSaturation"), f;
    h != null && (f = NQ(l), c = jDt(h, f)), u.stroke = c;
    var d = n.viewChildren;
    if (!d || !d.length)
      f = NQ(l), u.fill = f;
    else {
      var p = HDt(n, i, o, s, l, d);
      I(d, function(g, v) {
        if (g.depth >= t.length || g === t[g.depth]) {
          var m = qDt(i, l, g, v, p, r);
          qre(g, m, t, r);
        }
      });
    }
  }
}
function GDt(n, e, t) {
  var r = re({}, e), i = t.designatedVisualItemStyle;
  return I(["color", "colorAlpha", "colorSaturation"], function(o) {
    i[o] = e[o];
    var a = n.get(o);
    i[o] = null, a != null && (r[o] = a);
  }), r;
}
function NQ(n) {
  var e = YT(n, "color");
  if (e) {
    var t = YT(n, "colorAlpha"), r = YT(n, "colorSaturation");
    return r && (e = My(e, null, null, r)), t && (e = cS(e, t)), e;
  }
}
function jDt(n, e) {
  return e != null ? My(e, null, null, n) : null;
}
function YT(n, e) {
  var t = n[e];
  if (t != null && t !== "none")
    return t;
}
function HDt(n, e, t, r, i, o) {
  if (!(!o || !o.length)) {
    var a = XT(e, "color") || i.color != null && i.color !== "none" && (XT(e, "colorAlpha") || XT(e, "colorSaturation"));
    if (a) {
      var s = e.get("visualMin"), l = e.get("visualMax"), u = t.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var c = e.get("colorMappingBy"), h = {
        type: a.name,
        dataExtent: u,
        visual: a.range
      };
      h.type === "color" && (c === "index" || c === "id") ? (h.mappingMethod = "category", h.loop = !0) : h.mappingMethod = "linear";
      var f = new mi(h);
      return Hre(f).drColorMappingBy = c, f;
    }
  }
}
function XT(n, e) {
  var t = n.get(e);
  return se(t) && t.length ? {
    name: e,
    range: t
  } : null;
}
function qDt(n, e, t, r, i, o) {
  var a = re({}, e);
  if (i) {
    var s = i.type, l = s === "color" && Hre(i).drColorMappingBy, u = l === "index" ? r : l === "id" ? o.mapIdToIndex(t.getId()) : t.getValue(n.get("visualDimension"));
    a[s] = i.mapValueToVisual(u);
  }
  return a;
}
var K0 = Math.max, QS = Math.min, $Q = ur, GN = I, Yre = ["itemStyle", "borderWidth"], YDt = ["itemStyle", "gapWidth"], XDt = ["upperLabel", "show"], UDt = ["upperLabel", "height"];
const KDt = {
  seriesType: "treemap",
  reset: function(n, e, t, r) {
    var i = t.getWidth(), o = t.getHeight(), a = n.option, s = Cr(n.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    }), l = a.size || [], u = be($Q(s.width, l[0]), i), c = be($Q(s.height, l[1]), o), h = r && r.type, f = ["treemapZoomToNode", "treemapRootToNode"], d = X0(r, f, n), p = h === "treemapRender" || h === "treemapMove" ? r.rootRect : null, g = n.getViewRoot(), v = Zre(g);
    if (h !== "treemapMove") {
      var m = h === "treemapZoomToNode" ? iLt(n, d, g, u, c) : p ? [p.width, p.height] : [u, c], y = a.sort;
      y && y !== "asc" && y !== "desc" && (y = "desc");
      var b = {
        squareRatio: a.squareRatio,
        sort: y,
        leafDepth: a.leafDepth
      };
      g.hostTree.clearLayouts();
      var O = {
        x: 0,
        y: 0,
        width: m[0],
        height: m[1],
        area: m[0] * m[1]
      };
      g.setLayout(O), Xre(g, b, !1, 0), O = g.getLayout(), GN(v, function(x, S) {
        var _ = (v[S + 1] || g).getValue();
        x.setLayout(re({
          dataExtent: [_, _],
          borderWidth: 0,
          upperHeight: 0
        }, O));
      });
    }
    var w = n.getData().tree.root;
    w.setLayout(oLt(s, p, d), !0), n.setLayoutInfo(s), Ure(
      w,
      // Transform to base element coordinate system.
      new ot(-s.x, -s.y, i, o),
      v,
      g,
      0
    );
  }
};
function Xre(n, e, t, r) {
  var i, o;
  if (!n.isRemoved()) {
    var a = n.getLayout();
    i = a.width, o = a.height;
    var s = n.getModel(), l = s.get(Yre), u = s.get(YDt) / 2, c = Kre(s), h = Math.max(l, c), f = l - u, d = h - u;
    n.setLayout({
      borderWidth: l,
      upperHeight: h,
      upperLabelHeight: c
    }, !0), i = K0(i - 2 * f, 0), o = K0(o - f - d, 0);
    var p = i * o, g = JDt(n, s, p, e, t, r);
    if (g.length) {
      var v = {
        x: f,
        y: d,
        width: i,
        height: o
      }, m = QS(i, o), y = 1 / 0, b = [];
      b.area = 0;
      for (var O = 0, w = g.length; O < w; ) {
        var x = g[O];
        b.push(x), b.area += x.getLayout().area;
        var S = rLt(b, m, e.squareRatio);
        S <= y ? (O++, y = S) : (b.area -= b.pop().getLayout().area, BQ(b, m, v, u, !1), m = QS(v.width, v.height), b.length = b.area = 0, y = 1 / 0);
      }
      if (b.length && BQ(b, m, v, u, !0), !t) {
        var _ = s.get("childrenVisibleMin");
        _ != null && p < _ && (t = !0);
      }
      for (var O = 0, w = g.length; O < w; O++)
        Xre(g[O], e, t, r + 1);
    }
  }
}
function JDt(n, e, t, r, i, o) {
  var a = n.children || [], s = r.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = r.leafDepth != null && r.leafDepth <= o;
  if (i && !l)
    return n.viewChildren = [];
  a = en(a, function(d) {
    return !d.isRemoved();
  }), tLt(a, s);
  var u = nLt(e, a, s);
  if (u.sum === 0)
    return n.viewChildren = [];
  if (u.sum = eLt(e, t, u.sum, s, a), u.sum === 0)
    return n.viewChildren = [];
  for (var c = 0, h = a.length; c < h; c++) {
    var f = a[c].getValue() / u.sum * t;
    a[c].setLayout({
      area: f
    });
  }
  return l && (a.length && n.setLayout({
    isLeafRoot: !0
  }, !0), a.length = 0), n.viewChildren = a, n.setLayout({
    dataExtent: u.dataExtent
  }, !0), a;
}
function eLt(n, e, t, r, i) {
  if (!r)
    return t;
  for (var o = n.get("visibleMin"), a = i.length, s = a, l = a - 1; l >= 0; l--) {
    var u = i[r === "asc" ? a - l - 1 : l].getValue();
    u / t * e < o && (s = l, t -= u);
  }
  return r === "asc" ? i.splice(0, a - s) : i.splice(s, a - s), t;
}
function tLt(n, e) {
  return e && n.sort(function(t, r) {
    var i = e === "asc" ? t.getValue() - r.getValue() : r.getValue() - t.getValue();
    return i === 0 ? e === "asc" ? t.dataIndex - r.dataIndex : r.dataIndex - t.dataIndex : i;
  }), n;
}
function nLt(n, e, t) {
  for (var r = 0, i = 0, o = e.length; i < o; i++)
    r += e[i].getValue();
  var a = n.get("visualDimension"), s;
  return !e || !e.length ? s = [NaN, NaN] : a === "value" && t ? (s = [e[e.length - 1].getValue(), e[0].getValue()], t === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], GN(e, function(l) {
    var u = l.getValue(a);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: r,
    dataExtent: s
  };
}
function rLt(n, e, t) {
  for (var r = 0, i = 1 / 0, o = 0, a = void 0, s = n.length; o < s; o++)
    a = n[o].getLayout().area, a && (a < i && (i = a), a > r && (r = a));
  var l = n.area * n.area, u = e * e * t;
  return l ? K0(u * r / l, l / (u * i)) : 1 / 0;
}
function BQ(n, e, t, r, i) {
  var o = e === t.width ? 0 : 1, a = 1 - o, s = ["x", "y"], l = ["width", "height"], u = t[s[o]], c = e ? n.area / e : 0;
  (i || c > t[l[a]]) && (c = t[l[a]]);
  for (var h = 0, f = n.length; h < f; h++) {
    var d = n[h], p = {}, g = c ? d.getLayout().area / c : 0, v = p[l[a]] = K0(c - 2 * r, 0), m = t[s[o]] + t[l[o]] - u, y = h === f - 1 || m < g ? m : g, b = p[l[o]] = K0(y - 2 * r, 0);
    p[s[a]] = t[s[a]] + QS(r, v / 2), p[s[o]] = u + QS(r, b / 2), u += y, d.setLayout(p, !0);
  }
  t[s[a]] += c, t[l[a]] -= c;
}
function iLt(n, e, t, r, i) {
  var o = (e || {}).node, a = [r, i];
  if (!o || o === t)
    return a;
  for (var s, l = r * i, u = l * n.option.zoomToNodeRatio; s = o.parentNode; ) {
    for (var c = 0, h = s.children, f = 0, d = h.length; f < d; f++)
      c += h[f].getValue();
    var p = o.getValue();
    if (p === 0)
      return a;
    u *= c / p;
    var g = s.getModel(), v = g.get(Yre), m = Math.max(v, Kre(g));
    u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5), u > qz && (u = qz), o = s;
  }
  u < l && (u = l);
  var y = Math.pow(u / l, 0.5);
  return [r * y, i * y];
}
function oLt(n, e, t) {
  if (e)
    return {
      x: e.x,
      y: e.y
    };
  var r = {
    x: 0,
    y: 0
  };
  if (!t)
    return r;
  var i = t.node, o = i.getLayout();
  if (!o)
    return r;
  for (var a = [o.width / 2, o.height / 2], s = i; s; ) {
    var l = s.getLayout();
    a[0] += l.x, a[1] += l.y, s = s.parentNode;
  }
  return {
    x: n.width / 2 - a[0],
    y: n.height / 2 - a[1]
  };
}
function Ure(n, e, t, r, i) {
  var o = n.getLayout(), a = t[i], s = a && a === n;
  if (!(a && !s || i === t.length && n !== r)) {
    n.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !e.intersect(o),
      isAboveViewRoot: s
    }, !0);
    var l = new ot(e.x - o.x, e.y - o.y, e.width, e.height);
    GN(n.viewChildren || [], function(u) {
      Ure(u, l, t, r, i + 1);
    });
  }
}
function Kre(n) {
  return n.get(XDt) ? n.get(UDt) : 0;
}
function aLt(n) {
  n.registerSeriesModel(_Dt), n.registerChartView(BDt), n.registerVisual(WDt), n.registerLayout(KDt), wDt(n);
}
function sLt(n) {
  var e = n.findComponents({
    mainType: "legend"
  });
  !e || !e.length || n.eachSeriesByType("graph", function(t) {
    var r = t.getCategoriesData(), i = t.getGraph(), o = i.data, a = r.mapArray(r.getName);
    o.filterSelf(function(s) {
      var l = o.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        $t(u) && (u = a[u]);
        for (var c = 0; c < e.length; c++)
          if (!e[c].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function lLt(n) {
  var e = {};
  n.eachSeriesByType("graph", function(t) {
    var r = t.getCategoriesData(), i = t.getData(), o = {};
    r.each(function(a) {
      var s = r.getName(a);
      o["ec-" + s] = a;
      var l = r.getItemModel(a), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = t.getColorFromPalette(s, e)), r.setItemVisual(a, "style", u);
      for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < c.length; h++) {
        var f = l.getShallow(c[h], !0);
        f != null && r.setItemVisual(a, c[h], f);
      }
    }), r.count() && i.each(function(a) {
      var s = i.getItemModel(a), l = s.getShallow("category");
      if (l != null) {
        we(l) && (l = o["ec-" + l]);
        var u = r.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(a, "style");
        re(c, u);
        for (var h = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < h.length; f++)
          i.setItemVisual(a, h[f], r.getItemVisual(l, h[f]));
      }
    });
  });
}
function FO(n) {
  return n instanceof Array || (n = [n, n]), n;
}
function uLt(n) {
  n.eachSeriesByType("graph", function(e) {
    var t = e.getGraph(), r = e.getEdgeData(), i = FO(e.get("edgeSymbol")), o = FO(e.get("edgeSymbolSize"));
    r.setVisual("fromSymbol", i && i[0]), r.setVisual("toSymbol", i && i[1]), r.setVisual("fromSymbolSize", o && o[0]), r.setVisual("toSymbolSize", o && o[1]), r.setVisual("style", e.getModel("lineStyle").getLineStyle()), r.each(function(a) {
      var s = r.getItemModel(a), l = t.getEdgeByIndex(a), u = FO(s.getShallow("symbol", !0)), c = FO(s.getShallow("symbolSize", !0)), h = s.getModel("lineStyle").getLineStyle(), f = r.ensureUniqueItemVisual(a, "style");
      switch (re(f, h), f.stroke) {
        case "source": {
          var d = l.node1.getVisual("style");
          f.stroke = d && d.fill;
          break;
        }
        case "target": {
          var d = l.node2.getVisual("style");
          f.stroke = d && d.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
    });
  });
}
var CD = "-->", qC = function(n) {
  return n.get("autoCurveness") || null;
}, Jre = function(n, e) {
  var t = qC(n), r = 20, i = [];
  if ($t(t))
    r = t;
  else if (se(t)) {
    n.__curvenessList = t;
    return;
  }
  e > r && (r = e);
  var o = r % 2 ? r + 2 : r + 3;
  i = [];
  for (var a = 0; a < o; a++)
    i.push((a % 2 ? a + 1 : a) / 10 * (a % 2 ? -1 : 1));
  n.__curvenessList = i;
}, J0 = function(n, e, t) {
  var r = [n.id, n.dataIndex].join("."), i = [e.id, e.dataIndex].join(".");
  return [t.uid, r, i].join(CD);
}, eie = function(n) {
  var e = n.split(CD);
  return [e[0], e[2], e[1]].join(CD);
}, cLt = function(n, e) {
  var t = J0(n.node1, n.node2, e);
  return e.__edgeMap[t];
}, hLt = function(n, e) {
  var t = AD(J0(n.node1, n.node2, e), e), r = AD(J0(n.node2, n.node1, e), e);
  return t + r;
}, AD = function(n, e) {
  var t = e.__edgeMap;
  return t[n] ? t[n].length : 0;
};
function fLt(n) {
  qC(n) && (n.__curvenessList = [], n.__edgeMap = {}, Jre(n));
}
function dLt(n, e, t, r) {
  if (qC(t)) {
    var i = J0(n, e, t), o = t.__edgeMap, a = o[eie(i)];
    o[i] && !a ? o[i].isForward = !0 : a && o[i] && (a.isForward = !0, o[i].isForward = !1), o[i] = o[i] || [], o[i].push(r);
  }
}
function jN(n, e, t, r) {
  var i = qC(e), o = se(i);
  if (!i)
    return null;
  var a = cLt(n, e);
  if (!a)
    return null;
  for (var s = -1, l = 0; l < a.length; l++)
    if (a[l] === t) {
      s = l;
      break;
    }
  var u = hLt(n, e);
  Jre(e, u), n.lineStyle = n.lineStyle || {};
  var c = J0(n.node1, n.node2, e), h = e.__curvenessList, f = o || u % 2 ? 0 : 1;
  if (a.isForward)
    return h[f + s];
  var d = eie(c), p = AD(d, e), g = h[s + p + f];
  return r ? o ? i && i[0] === 0 ? (p + f) % 2 ? g : -g : ((p % 2 ? 0 : 1) + f) % 2 ? g : -g : (p + f) % 2 ? g : -g : h[s + p + f];
}
function tie(n) {
  var e = n.coordinateSystem;
  if (!(e && e.type !== "view")) {
    var t = n.getGraph();
    t.eachNode(function(r) {
      var i = r.getModel();
      r.setLayout([+i.get("x"), +i.get("y")]);
    }), HN(t, n);
  }
}
function HN(n, e) {
  n.eachEdge(function(t, r) {
    var i = Aa(t.getModel().get(["lineStyle", "curveness"]), -jN(t, e, r, !0), 0), o = Jl(t.node1.getLayout()), a = Jl(t.node2.getLayout()), s = [o, a];
    +i && s.push([(o[0] + a[0]) / 2 - (o[1] - a[1]) * i, (o[1] + a[1]) / 2 - (a[0] - o[0]) * i]), t.setLayout(s);
  });
}
function pLt(n, e) {
  n.eachSeriesByType("graph", function(t) {
    var r = t.get("layout"), i = t.coordinateSystem;
    if (i && i.type !== "view") {
      var o = t.getData(), a = [];
      I(i.dimensions, function(f) {
        a = a.concat(o.mapDimensionsAll(f));
      });
      for (var s = 0; s < o.count(); s++) {
        for (var l = [], u = !1, c = 0; c < a.length; c++) {
          var h = o.get(a[c], s);
          isNaN(h) || (u = !0), l.push(h);
        }
        u ? o.setItemLayout(s, i.dataToPoint(l)) : o.setItemLayout(s, [NaN, NaN]);
      }
      HN(o.graph, t);
    } else
      (!r || r === "none") && tie(t);
  });
}
function iy(n) {
  var e = n.coordinateSystem;
  if (e.type !== "view")
    return 1;
  var t = n.option.nodeScaleRatio, r = e.scaleX, i = e.getZoom(), o = (i - 1) * t + 1;
  return o / r;
}
function oy(n) {
  var e = n.getVisual("symbolSize");
  return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
}
var VQ = Math.PI, UT = [];
function qN(n, e, t, r) {
  var i = n.coordinateSystem;
  if (!(i && i.type !== "view")) {
    var o = i.getBoundingRect(), a = n.getData(), s = a.graph, l = o.width / 2 + o.x, u = o.height / 2 + o.y, c = Math.min(o.width, o.height) / 2, h = a.count();
    if (a.setLayout({
      cx: l,
      cy: u
    }), !!h) {
      if (t) {
        var f = i.pointToData(r), d = f[0], p = f[1], g = [d - l, p - u];
        Pv(g, g), Vw(g, g, c), t.setLayout([l + g[0], u + g[1]], !0);
        var v = n.get(["circular", "rotateLabel"]);
        nie(t, v, l, u);
      }
      gLt[e](n, s, a, c, l, u, h), s.eachEdge(function(m, y) {
        var b = Aa(m.getModel().get(["lineStyle", "curveness"]), jN(m, n, y), 0), O = Jl(m.node1.getLayout()), w = Jl(m.node2.getLayout()), x, S = (O[0] + w[0]) / 2, _ = (O[1] + w[1]) / 2;
        +b && (b *= 3, x = [l * b + S * (1 - b), u * b + _ * (1 - b)]), m.setLayout([O, w, x]);
      });
    }
  }
}
var gLt = {
  value: function(n, e, t, r, i, o, a) {
    var s = 0, l = t.getSum("value"), u = Math.PI * 2 / (l || a);
    e.eachNode(function(c) {
      var h = c.getValue("value"), f = u * (l ? h : 1) / 2;
      s += f, c.setLayout([r * Math.cos(s) + i, r * Math.sin(s) + o]), s += f;
    });
  },
  symbolSize: function(n, e, t, r, i, o, a) {
    var s = 0;
    UT.length = a;
    var l = iy(n);
    e.eachNode(function(h) {
      var f = oy(h);
      isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
      var d = Math.asin(f / 2 / r);
      isNaN(d) && (d = VQ / 2), UT[h.dataIndex] = d, s += d * 2;
    });
    var u = (2 * VQ - s) / a / 2, c = 0;
    e.eachNode(function(h) {
      var f = u + UT[h.dataIndex];
      c += f, (!h.getLayout() || !h.getLayout().fixed) && h.setLayout([r * Math.cos(c) + i, r * Math.sin(c) + o]), c += f;
    });
  }
};
function nie(n, e, t, r) {
  var i = n.getGraphicEl();
  if (i) {
    var o = n.getModel(), a = o.get(["label", "rotate"]) || 0, s = i.getSymbolPath();
    if (e) {
      var l = n.getLayout(), u = Math.atan2(l[1] - r, l[0] - t);
      u < 0 && (u = Math.PI * 2 + u);
      var c = l[0] < t;
      c && (u = u - Math.PI);
      var h = c ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: h,
        origin: "center"
      });
      var f = s.ensureState("emphasis");
      re(f.textConfig || (f.textConfig = {}), {
        position: h
      });
    } else
      s.setTextConfig({
        rotation: a *= Math.PI / 180
      });
  }
}
function vLt(n) {
  n.eachSeriesByType("graph", function(e) {
    e.get("layout") === "circular" && qN(e, "symbolSize");
  });
}
var up = cM;
function mLt(n, e, t) {
  for (var r = n, i = e, o = t.rect, a = o.width, s = o.height, l = [o.x + a / 2, o.y + s / 2], u = t.gravity == null ? 0.1 : t.gravity, c = 0; c < r.length; c++) {
    var h = r[c];
    h.p || (h.p = Ed(a * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), h.pp = Jl(h.p), h.edges = null;
  }
  var f = t.friction == null ? 0.6 : t.friction, d = f, p, g;
  return {
    warmUp: function() {
      d = f * 0.8;
    },
    setFixed: function(v) {
      r[v].fixed = !0;
    },
    setUnfixed: function(v) {
      r[v].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(v) {
      p = v;
    },
    /**
     * After step hook
     */
    afterStep: function(v) {
      g = v;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(v) {
      p && p(r, i);
      for (var m = [], y = r.length, b = 0; b < i.length; b++) {
        var O = i[b];
        if (!O.ignoreForceLayout) {
          var w = O.n1, x = O.n2;
          Of(m, x.p, w.p);
          var S = hM(m) - O.d, _ = x.w / (w.w + x.w);
          isNaN(_) && (_ = 0), Pv(m, m), !w.fixed && up(w.p, w.p, m, _ * S * d), !x.fixed && up(x.p, x.p, m, -(1 - _) * S * d);
        }
      }
      for (var b = 0; b < y; b++) {
        var C = r[b];
        C.fixed || (Of(m, l, C.p), up(C.p, C.p, m, u * d));
      }
      for (var b = 0; b < y; b++)
        for (var w = r[b], A = b + 1; A < y; A++) {
          var x = r[A];
          Of(m, x.p, w.p);
          var S = hM(m);
          S === 0 && (ZOt(m, Math.random() - 0.5, Math.random() - 0.5), S = 1);
          var k = (w.rep + x.rep) / S / S;
          !w.fixed && up(w.pp, w.pp, m, k), !x.fixed && up(x.pp, x.pp, m, -k);
        }
      for (var P = [], b = 0; b < y; b++) {
        var C = r[b];
        C.fixed || (Of(P, C.p, C.pp), up(C.p, C.p, P, d), Gi(C.pp, C.p));
      }
      d = d * 0.992;
      var L = d < 0.01;
      g && g(r, i, L), v && v(L);
    }
  };
}
function yLt(n) {
  n.eachSeriesByType("graph", function(e) {
    var t = e.coordinateSystem;
    if (!(t && t.type !== "view"))
      if (e.get("layout") === "force") {
        var r = e.preservedPoints || {}, i = e.getGraph(), o = i.data, a = i.edgeData, s = e.getModel("force"), l = s.get("initLayout");
        e.preservedPoints ? o.each(function(b) {
          var O = o.getId(b);
          o.setItemLayout(b, r[O] || [NaN, NaN]);
        }) : !l || l === "none" ? tie(e) : l === "circular" && qN(e, "value");
        var u = o.getDataExtent("value"), c = a.getDataExtent("value"), h = s.get("repulsion"), f = s.get("edgeLength"), d = se(h) ? h : [h, h], p = se(f) ? f : [f, f];
        p = [p[1], p[0]];
        var g = o.mapArray("value", function(b, O) {
          var w = o.getItemLayout(O), x = Yt(b, u, d);
          return isNaN(x) && (x = (d[0] + d[1]) / 2), {
            w: x,
            rep: x,
            fixed: o.getItemModel(O).get("fixed"),
            p: !w || isNaN(w[0]) || isNaN(w[1]) ? null : w
          };
        }), v = a.mapArray("value", function(b, O) {
          var w = i.getEdgeByIndex(O), x = Yt(b, c, p);
          isNaN(x) && (x = (p[0] + p[1]) / 2);
          var S = w.getModel(), _ = Aa(w.getModel().get(["lineStyle", "curveness"]), -jN(w, e, O, !0), 0);
          return {
            n1: g[w.node1.dataIndex],
            n2: g[w.node2.dataIndex],
            d: x,
            curveness: _,
            ignoreForceLayout: S.get("ignoreForceLayout")
          };
        }), m = t.getBoundingRect(), y = mLt(g, v, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(b, O) {
          for (var w = 0, x = b.length; w < x; w++)
            b[w].fixed && Gi(b[w].p, i.getNodeByIndex(w).getLayout());
        }), y.afterStep(function(b, O, w) {
          for (var x = 0, S = b.length; x < S; x++)
            b[x].fixed || i.getNodeByIndex(x).setLayout(b[x].p), r[o.getId(x)] = b[x].p;
          for (var x = 0, S = O.length; x < S; x++) {
            var _ = O[x], C = i.getEdgeByIndex(x), A = _.n1.p, k = _.n2.p, P = C.getLayout();
            P = P ? P.slice() : [], P[0] = P[0] || [], P[1] = P[1] || [], Gi(P[0], A), Gi(P[1], k), +_.curveness && (P[2] = [(A[0] + k[0]) / 2 - (A[1] - k[1]) * _.curveness, (A[1] + k[1]) / 2 - (k[0] - A[0]) * _.curveness]), C.setLayout(P);
          }
        }), e.forceLayout = y, e.preservedPoints = r, y.step();
      } else
        e.forceLayout = null;
  });
}
function bLt(n, e, t) {
  var r = re(n.getBoxLayoutParams(), {
    aspect: t
  });
  return Cr(r, {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function OLt(n, e) {
  var t = [];
  return n.eachSeriesByType("graph", function(r) {
    var i = r.get("coordinateSystem");
    if (!i || i === "view") {
      var o = r.getData(), a = o.mapArray(function(v) {
        var m = o.getItemModel(v);
        return [+m.get("x"), +m.get("y")];
      }), s = [], l = [];
      xC(a, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), c = bLt(r, e, u);
      isNaN(u) && (s = [c.x, c.y], l = [c.x + c.width, c.y + c.height]);
      var h = l[0] - s[0], f = l[1] - s[1], d = c.width, p = c.height, g = r.coordinateSystem = new e1();
      g.zoomLimit = r.get("scaleLimit"), g.setBoundingRect(s[0], s[1], h, f), g.setViewRect(c.x, c.y, d, p), g.setCenter(r.get("center"), e), g.setZoom(r.get("zoom")), t.push(g);
    }
  }), t;
}
var zQ = Br.prototype, KT = AC.prototype, rie = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return n;
  }()
);
(function(n) {
  H(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
})(rie);
function JT(n) {
  return isNaN(+n.cpx1) || isNaN(+n.cpy1);
}
var wLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-line", r;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new rie();
    }, e.prototype.buildPath = function(t, r) {
      JT(r) ? zQ.buildPath.call(this, t, r) : KT.buildPath.call(this, t, r);
    }, e.prototype.pointAt = function(t) {
      return JT(this.shape) ? zQ.pointAt.call(this, t) : KT.pointAt.call(this, t);
    }, e.prototype.tangentAt = function(t) {
      var r = this.shape, i = JT(r) ? [r.x2 - r.x1, r.y2 - r.y1] : KT.tangentAt.call(this, t);
      return Pv(i, i);
    }, e;
  }(gt)
), ek = ["fromSymbol", "toSymbol"];
function FQ(n) {
  return "_" + n + "Type";
}
function QQ(n, e, t) {
  var r = e.getItemVisual(t, n);
  if (!r || r === "none")
    return r;
  var i = e.getItemVisual(t, n + "Size"), o = e.getItemVisual(t, n + "Rotate"), a = e.getItemVisual(t, n + "Offset"), s = e.getItemVisual(t, n + "KeepAspect"), l = Wv(i), u = Id(a || 0, l);
  return r + l + u + (o || "") + (s || "");
}
function ZQ(n, e, t) {
  var r = e.getItemVisual(t, n);
  if (!(!r || r === "none")) {
    var i = e.getItemVisual(t, n + "Size"), o = e.getItemVisual(t, n + "Rotate"), a = e.getItemVisual(t, n + "Offset"), s = e.getItemVisual(t, n + "KeepAspect"), l = Wv(i), u = Id(a || 0, l), c = vr(r, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return c.__specifiedRotation = o == null || isNaN(o) ? void 0 : +o * Math.PI / 180 || 0, c.name = n, c;
  }
}
function xLt(n) {
  var e = new wLt({
    name: "line",
    subPixelOptimize: !0
  });
  return TD(e.shape, n), e;
}
function TD(n, e) {
  n.x1 = e[0][0], n.y1 = e[0][1], n.x2 = e[1][0], n.y2 = e[1][1], n.percent = 1;
  var t = e[2];
  t ? (n.cpx1 = t[0], n.cpy1 = t[1]) : (n.cpx1 = NaN, n.cpy1 = NaN);
}
var SLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this) || this;
      return o._createLine(t, r, i), o;
    }
    return e.prototype._createLine = function(t, r, i) {
      var o = t.hostModel, a = t.getItemLayout(r), s = xLt(a);
      s.shape.percent = 0, Cn(s, {
        shape: {
          percent: 1
        }
      }, o, r), this.add(s), I(ek, function(l) {
        var u = ZQ(l, t, r);
        this.add(u), this[FQ(l)] = QQ(l, t, r);
      }, this), this._updateCommonStl(t, r, i);
    }, e.prototype.updateData = function(t, r, i) {
      var o = t.hostModel, a = this.childOfName("line"), s = t.getItemLayout(r), l = {
        shape: {}
      };
      TD(l.shape, s), Vt(a, l, o, r), I(ek, function(u) {
        var c = QQ(u, t, r), h = FQ(u);
        if (this[h] !== c) {
          this.remove(this.childOfName(u));
          var f = ZQ(u, t, r);
          this.add(f);
        }
        this[h] = c;
      }, this), this._updateCommonStl(t, r, i);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(t, r, i) {
      var o = t.hostModel, a = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, h = i && i.emphasisDisabled, f = i && i.focus, d = i && i.blurScope;
      if (!i || t.hasItemOption) {
        var p = t.getItemModel(r), g = p.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), h = g.get("disabled"), f = g.get("focus"), d = g.get("blurScope"), c = Fr(p);
      }
      var v = t.getItemVisual(r, "style"), m = v.stroke;
      a.useStyle(v), a.style.fill = null, a.style.strokeNoScale = !0, a.ensureState("emphasis").style = s, a.ensureState("blur").style = l, a.ensureState("select").style = u, I(ek, function(x) {
        var S = this.childOfName(x);
        if (S) {
          S.setColor(m), S.style.opacity = v.opacity;
          for (var _ = 0; _ < no.length; _++) {
            var C = no[_], A = a.getState(C);
            if (A) {
              var k = A.style || {}, P = S.ensureState(C), L = P.style || (P.style = {});
              k.stroke != null && (L[S.__isEmptyBrush ? "stroke" : "fill"] = k.stroke), k.opacity != null && (L.opacity = k.opacity);
            }
          }
          S.markRedraw();
        }
      }, this);
      var y = o.getRawValue(r);
      wi(this, c, {
        labelDataIndex: r,
        labelFetcher: {
          getFormattedLabel: function(x, S) {
            return o.getFormattedLabel(x, S, t.dataType);
          }
        },
        inheritColor: m || "#000",
        defaultOpacity: v.opacity,
        defaultText: (y == null ? t.getName(r) : isFinite(y) ? qn(y) : y) + ""
      });
      var b = this.getTextContent();
      if (b) {
        var O = c.normal;
        b.__align = b.style.align, b.__verticalAlign = b.style.verticalAlign, b.__position = O.get("position") || "middle";
        var w = O.get("distance");
        se(w) || (w = [w, w]), b.__labelDistance = w;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), Wn(this, f, d, h);
    }, e.prototype.highlight = function() {
      gu(this);
    }, e.prototype.downplay = function() {
      vu(this);
    }, e.prototype.updateLayout = function(t, r) {
      this.setLinePoints(t.getItemLayout(r));
    }, e.prototype.setLinePoints = function(t) {
      var r = this.childOfName("line");
      TD(r.shape, t), r.dirty();
    }, e.prototype.beforeUpdate = function() {
      var t = this, r = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), o = t.getTextContent();
      if (!r && !i && (!o || o.ignore))
        return;
      for (var a = 1, s = this.parent; s; )
        s.scaleX && (a /= s.scaleX), s = s.parent;
      var l = t.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, c = l.pointAt(0), h = l.pointAt(u), f = Of([], h, c);
      Pv(f, f);
      function d(A, k) {
        var P = A.__specifiedRotation;
        if (P == null) {
          var L = l.tangentAt(k);
          A.attr("rotation", (k === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(L[1], L[0]));
        } else
          A.attr("rotation", P);
      }
      if (r && (r.setPosition(c), d(r, 0), r.scaleX = r.scaleY = a * u, r.markRedraw()), i && (i.setPosition(h), d(i, 1), i.scaleX = i.scaleY = a * u, i.markRedraw()), o && !o.ignore) {
        o.x = o.y = 0, o.originX = o.originY = 0;
        var p = void 0, g = void 0, v = o.__labelDistance, m = v[0] * a, y = v[1] * a, b = u / 2, O = l.tangentAt(b), w = [O[1], -O[0]], x = l.pointAt(b);
        w[1] > 0 && (w[0] = -w[0], w[1] = -w[1]);
        var S = O[0] < 0 ? -1 : 1;
        if (o.__position !== "start" && o.__position !== "end") {
          var _ = -Math.atan2(O[1], O[0]);
          h[0] < c[0] && (_ = Math.PI + _), o.rotation = _;
        }
        var C = void 0;
        switch (o.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            C = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            C = y, g = "top";
            break;
          default:
            C = 0, g = "middle";
        }
        switch (o.__position) {
          case "end":
            o.x = f[0] * m + h[0], o.y = f[1] * y + h[1], p = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", g = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            o.x = -f[0] * m + c[0], o.y = -f[1] * y + c[1], p = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", g = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            o.x = m * S + c[0], o.y = c[1] + C, p = O[0] < 0 ? "right" : "left", o.originX = -m * S, o.originY = -C;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            o.x = x[0], o.y = x[1] + C, p = "center", o.originY = -C;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            o.x = -m * S + h[0], o.y = h[1] + C, p = O[0] >= 0 ? "right" : "left", o.originX = m * S, o.originY = -C;
            break;
        }
        o.scaleX = o.scaleY = a, o.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: o.__verticalAlign || g,
          align: o.__align || p
        });
      }
    }, e;
  }(We)
);
const YN = SLt;
var XN = (
  /** @class */
  function() {
    function n(e) {
      this.group = new We(), this._LineCtor = e || YN;
    }
    return n.prototype.updateData = function(e) {
      var t = this;
      this._progressiveEls = null;
      var r = this, i = r.group, o = r._lineData;
      r._lineData = e, o || i.removeAll();
      var a = WQ(e);
      e.diff(o).add(function(s) {
        t._doAdd(e, s, a);
      }).update(function(s, l) {
        t._doUpdate(o, e, l, s, a);
      }).remove(function(s) {
        i.remove(o.getItemGraphicEl(s));
      }).execute();
    }, n.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(t, r) {
        t.updateLayout(e, r);
      }, this);
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = WQ(e), this._lineData = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(e, t) {
      this._progressiveEls = [];
      function r(s) {
        !s.isGroup && !_Lt(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var i = e.start; i < e.end; i++) {
        var o = t.getItemLayout(i);
        if (tk(o)) {
          var a = new this._LineCtor(t, i, this._seriesScope);
          a.traverse(r), this.group.add(a), t.setItemGraphicEl(i, a), this._progressiveEls.push(a);
        }
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n.prototype.eachRendered = function(e) {
      dh(this._progressiveEls || this.group, e);
    }, n.prototype._doAdd = function(e, t, r) {
      var i = e.getItemLayout(t);
      if (tk(i)) {
        var o = new this._LineCtor(e, t, r);
        e.setItemGraphicEl(t, o), this.group.add(o);
      }
    }, n.prototype._doUpdate = function(e, t, r, i, o) {
      var a = e.getItemGraphicEl(r);
      if (!tk(t.getItemLayout(i))) {
        this.group.remove(a);
        return;
      }
      a ? a.updateData(t, i, o) : a = new this._LineCtor(t, i, o), t.setItemGraphicEl(i, a), this.group.add(a);
    }, n;
  }()
);
function _Lt(n) {
  return n.animators && n.animators.length > 0;
}
function WQ(n) {
  var e = n.hostModel, t = e.getModel("emphasis");
  return {
    lineStyle: e.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: t.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: e.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: e.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: t.get("disabled"),
    blurScope: t.get("blurScope"),
    focus: t.get("focus"),
    labelStatesModels: Fr(e)
  };
}
function GQ(n) {
  return isNaN(n[0]) || isNaN(n[1]);
}
function tk(n) {
  return n && !GQ(n[0]) && !GQ(n[1]);
}
var nk = [], rk = [], ik = [], cp = jr, ok = Vf, jQ = Math.abs;
function HQ(n, e, t) {
  for (var r = n[0], i = n[1], o = n[2], a = 1 / 0, s, l = t * t, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
    nk[0] = cp(r[0], i[0], o[0], c), nk[1] = cp(r[1], i[1], o[1], c);
    var h = jQ(ok(nk, e) - l);
    h < a && (a = h, s = c);
  }
  for (var f = 0; f < 32; f++) {
    var d = s + u;
    rk[0] = cp(r[0], i[0], o[0], s), rk[1] = cp(r[1], i[1], o[1], s), ik[0] = cp(r[0], i[0], o[0], d), ik[1] = cp(r[1], i[1], o[1], d);
    var h = ok(rk, e) - l;
    if (jQ(h) < 0.01)
      break;
    var p = ok(ik, e) - l;
    u /= 2, h < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function ak(n, e) {
  var t = [], r = D0, i = [[], [], []], o = [[], []], a = [];
  e /= 2, n.eachEdge(function(s, l) {
    var u = s.getLayout(), c = s.getVisual("fromSymbol"), h = s.getVisual("toSymbol");
    u.__original || (u.__original = [Jl(u[0]), Jl(u[1])], u[2] && u.__original.push(Jl(u[2])));
    var f = u.__original;
    if (u[2] != null) {
      if (Gi(i[0], f[0]), Gi(i[1], f[2]), Gi(i[2], f[1]), c && c !== "none") {
        var d = oy(s.node1), p = HQ(i, f[0], d * e);
        r(i[0][0], i[1][0], i[2][0], p, t), i[0][0] = t[3], i[1][0] = t[4], r(i[0][1], i[1][1], i[2][1], p, t), i[0][1] = t[3], i[1][1] = t[4];
      }
      if (h && h !== "none") {
        var d = oy(s.node2), p = HQ(i, f[1], d * e);
        r(i[0][0], i[1][0], i[2][0], p, t), i[1][0] = t[1], i[2][0] = t[2], r(i[0][1], i[1][1], i[2][1], p, t), i[1][1] = t[1], i[2][1] = t[2];
      }
      Gi(u[0], i[0]), Gi(u[1], i[2]), Gi(u[2], i[1]);
    } else {
      if (Gi(o[0], f[0]), Gi(o[1], f[1]), Of(a, o[1], o[0]), Pv(a, a), c && c !== "none") {
        var d = oy(s.node1);
        cM(o[0], o[0], a, d * e);
      }
      if (h && h !== "none") {
        var d = oy(s.node2);
        cM(o[1], o[1], a, -d * e);
      }
      Gi(u[0], o[0]), Gi(u[1], o[1]);
    }
  });
}
function qQ(n) {
  return n.type === "view";
}
var CLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      var i = new qb(), o = new XN(), a = this.group;
      this._controller = new Jb(r.getZr()), this._controllerHost = {
        target: a
      }, a.add(i.group), a.add(o.group), this._symbolDraw = i, this._lineDraw = o, this._firstRender = !0;
    }, e.prototype.render = function(t, r, i) {
      var o = this, a = t.coordinateSystem;
      this._model = t;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (qQ(a)) {
        var c = {
          x: a.x,
          y: a.y,
          scaleX: a.scaleX,
          scaleY: a.scaleY
        };
        this._firstRender ? u.attr(c) : Vt(u, c, t);
      }
      ak(t.getGraph(), iy(t));
      var h = t.getData();
      s.updateData(h);
      var f = t.getEdgeData();
      l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(t, r, i), clearTimeout(this._layoutTimeout);
      var d = t.forceLayout, p = t.get(["force", "layoutAnimation"]);
      d && this._startForceLayoutIteration(d, p);
      var g = t.get("layout");
      h.graph.eachNode(function(b) {
        var O = b.dataIndex, w = b.getGraphicEl(), x = b.getModel();
        if (w) {
          w.off("drag").off("dragend");
          var S = x.get("draggable");
          S && w.on("drag", function(C) {
            switch (g) {
              case "force":
                d.warmUp(), !o._layouting && o._startForceLayoutIteration(d, p), d.setFixed(O), h.setItemLayout(O, [w.x, w.y]);
                break;
              case "circular":
                h.setItemLayout(O, [w.x, w.y]), b.setLayout({
                  fixed: !0
                }, !0), qN(t, "symbolSize", b, [C.offsetX, C.offsetY]), o.updateLayout(t);
                break;
              case "none":
              default:
                h.setItemLayout(O, [w.x, w.y]), HN(t.getGraph(), t), o.updateLayout(t);
                break;
            }
          }).on("dragend", function() {
            d && d.setUnfixed(O);
          }), w.setDraggable(S, !!x.get("cursor"));
          var _ = x.get(["emphasis", "focus"]);
          _ === "adjacency" && (He(w).focus = b.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(b) {
        var O = b.getGraphicEl(), w = b.getModel().get(["emphasis", "focus"]);
        O && w === "adjacency" && (He(O).focus = {
          edge: [b.dataIndex],
          node: [b.node1.dataIndex, b.node2.dataIndex]
        });
      });
      var v = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]), m = h.getLayout("cx"), y = h.getLayout("cy");
      h.graph.eachNode(function(b) {
        nie(b, v, m, y);
      }), this._firstRender = !1;
    }, e.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(t, r) {
      var i = this;
      (function o() {
        t.step(function(a) {
          i.updateLayout(i._model), (i._layouting = !a) && (r ? i._layoutTimeout = setTimeout(o, 16) : o());
        });
      })();
    }, e.prototype._updateController = function(t, r, i) {
      var o = this, a = this._controller, s = this._controllerHost, l = this.group;
      if (a.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !GC(u, i, t);
      }), !qQ(t.coordinateSystem)) {
        a.disable();
        return;
      }
      a.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), a.off("pan").off("zoom").on("pan", function(u) {
        $N(s, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        BN(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), o._updateNodeAndLinkScale(), ak(t.getGraph(), iy(t)), o._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var t = this._model, r = t.getData(), i = iy(t);
      r.eachItemGraphicEl(function(o, a) {
        o && o.setSymbolScale(i);
      });
    }, e.prototype.updateLayout = function(t) {
      ak(t.getGraph(), iy(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }(bn)
);
const ALt = CLt;
function hp(n) {
  return "_EC_" + n;
}
var TLt = (
  /** @class */
  function() {
    function n(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || !1;
    }
    return n.prototype.isDirected = function() {
      return this._directed;
    }, n.prototype.addNode = function(e, t) {
      e = e == null ? "" + t : "" + e;
      var r = this._nodesMap;
      if (r[hp(e)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var i = new Kh(e, t);
      return i.hostGraph = this, this.nodes.push(i), r[hp(e)] = i, i;
    }, n.prototype.getNodeByIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this.nodes[t];
    }, n.prototype.getNodeById = function(e) {
      return this._nodesMap[hp(e)];
    }, n.prototype.addEdge = function(e, t, r) {
      var i = this._nodesMap, o = this._edgesMap;
      if ($t(e) && (e = this.nodes[e]), $t(t) && (t = this.nodes[t]), e instanceof Kh || (e = i[hp(e)]), t instanceof Kh || (t = i[hp(t)]), !(!e || !t)) {
        var a = e.id + "-" + t.id, s = new iie(e, t, r);
        return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), o[a] = s, s;
      }
    }, n.prototype.getEdgeByIndex = function(e) {
      var t = this.edgeData.getRawIndex(e);
      return this.edges[t];
    }, n.prototype.getEdge = function(e, t) {
      e instanceof Kh && (e = e.id), t instanceof Kh && (t = t.id);
      var r = this._edgesMap;
      return this._directed ? r[e + "-" + t] : r[e + "-" + t] || r[t + "-" + e];
    }, n.prototype.eachNode = function(e, t) {
      for (var r = this.nodes, i = r.length, o = 0; o < i; o++)
        r[o].dataIndex >= 0 && e.call(t, r[o], o);
    }, n.prototype.eachEdge = function(e, t) {
      for (var r = this.edges, i = r.length, o = 0; o < i; o++)
        r[o].dataIndex >= 0 && r[o].node1.dataIndex >= 0 && r[o].node2.dataIndex >= 0 && e.call(t, r[o], o);
    }, n.prototype.breadthFirstTraverse = function(e, t, r, i) {
      if (t instanceof Kh || (t = this._nodesMap[hp(t)]), !!t) {
        for (var o = r === "out" ? "outEdges" : r === "in" ? "inEdges" : "edges", a = 0; a < this.nodes.length; a++)
          this.nodes[a].__visited = !1;
        if (!e.call(i, t, null))
          for (var s = [t]; s.length; )
            for (var l = s.shift(), u = l[o], a = 0; a < u.length; a++) {
              var c = u[a], h = c.node1 === l ? c.node2 : c.node1;
              if (!h.__visited) {
                if (e.call(i, h, l))
                  return;
                s.push(h), h.__visited = !0;
              }
            }
      }
    }, n.prototype.update = function() {
      for (var e = this.data, t = this.edgeData, r = this.nodes, i = this.edges, o = 0, a = r.length; o < a; o++)
        r[o].dataIndex = -1;
      for (var o = 0, a = e.count(); o < a; o++)
        r[e.getRawIndex(o)].dataIndex = o;
      t.filterSelf(function(s) {
        var l = i[t.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var o = 0, a = i.length; o < a; o++)
        i[o].dataIndex = -1;
      for (var o = 0, a = t.count(); o < a; o++)
        i[t.getRawIndex(o)].dataIndex = o;
    }, n.prototype.clone = function() {
      for (var e = new n(this._directed), t = this.nodes, r = this.edges, i = 0; i < t.length; i++)
        e.addNode(t[i].id, t[i].dataIndex);
      for (var i = 0; i < r.length; i++) {
        var o = r[i];
        e.addEdge(o.node1.id, o.node2.id, o.dataIndex);
      }
      return e;
    }, n;
  }()
), Kh = (
  /** @class */
  function() {
    function n(e, t) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1;
    }
    return n.prototype.degree = function() {
      return this.edges.length;
    }, n.prototype.inDegree = function() {
      return this.inEdges.length;
    }, n.prototype.outDegree = function() {
      return this.outEdges.length;
    }, n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, r = t.data.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, t = 0; t < this.edges.length; t++) {
        var r = this.edges[t];
        r.dataIndex < 0 || (e.edge.push(r.dataIndex), e.node.push(r.node1.dataIndex, r.node2.dataIndex));
      }
      return e;
    }, n.prototype.getTrajectoryDataIndices = function() {
      for (var e = Ee(), t = Ee(), r = 0; r < this.edges.length; r++) {
        var i = this.edges[r];
        if (!(i.dataIndex < 0)) {
          e.set(i.dataIndex, !0);
          for (var o = [i.node1], a = [i.node2], s = 0; s < o.length; ) {
            var l = o[s];
            s++, t.set(l.dataIndex, !0);
            for (var u = 0; u < l.inEdges.length; u++)
              e.set(l.inEdges[u].dataIndex, !0), o.push(l.inEdges[u].node1);
          }
          for (s = 0; s < a.length; ) {
            var c = a[s];
            s++, t.set(c.dataIndex, !0);
            for (var u = 0; u < c.outEdges.length; u++)
              e.set(c.outEdges[u].dataIndex, !0), a.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, n;
  }()
), iie = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = r ?? -1;
    }
    return n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, r = t.edgeData.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, n.prototype.getTrajectoryDataIndices = function() {
      var e = Ee(), t = Ee();
      e.set(this.dataIndex, !0);
      for (var r = [this.node1], i = [this.node2], o = 0; o < r.length; ) {
        var a = r[o];
        o++, t.set(a.dataIndex, !0);
        for (var s = 0; s < a.inEdges.length; s++)
          e.set(a.inEdges[s].dataIndex, !0), r.push(a.inEdges[s].node1);
      }
      for (o = 0; o < i.length; ) {
        var l = i[o];
        o++, t.set(l.dataIndex, !0);
        for (var s = 0; s < l.outEdges.length; s++)
          e.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2);
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, n;
  }()
);
function oie(n, e) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(t) {
      var r = this[n][e];
      return r.getStore().get(r.getDimensionIndex(t || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(t, r) {
      this.dataIndex >= 0 && this[n][e].setItemVisual(this.dataIndex, t, r);
    },
    getVisual: function(t) {
      return this[n][e].getItemVisual(this.dataIndex, t);
    },
    setLayout: function(t, r) {
      this.dataIndex >= 0 && this[n][e].setItemLayout(this.dataIndex, t, r);
    },
    getLayout: function() {
      return this[n][e].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[n][e].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[n][e].getRawIndex(this.dataIndex);
    }
  };
}
mr(Kh, oie("hostGraph", "data"));
mr(iie, oie("hostGraph", "edgeData"));
function aie(n, e, t, r, i) {
  for (var o = new TLt(r), a = 0; a < n.length; a++)
    o.addNode(ur(
      // Id, name, dataIndex
      n[a].id,
      n[a].name,
      a
    ), a);
  for (var s = [], l = [], u = 0, a = 0; a < e.length; a++) {
    var c = e[a], h = c.source, f = c.target;
    o.addEdge(h, f, u) && (l.push(c), s.push(ur(wr(c.id, null), h + " > " + f)), u++);
  }
  var d = t.get("coordinateSystem"), p;
  if (d === "cartesian2d" || d === "polar")
    p = ku(n, t);
  else {
    var g = Fv.get(d), v = g ? g.dimensions || [] : [];
    ct(v, "value") < 0 && v.concat(["value"]);
    var m = Wb(n, {
      coordDimensions: v,
      encodeDefine: t.getEncode()
    }).dimensions;
    p = new Ki(m, t), p.initData(n);
  }
  var y = new Ki(["value"], t);
  return y.initData(l, s), i && i(p, y), Fre({
    mainData: p,
    struct: o,
    structAttr: "graph",
    datas: {
      node: p,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), o.update(), o;
}
var kLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments);
      var r = this;
      function i() {
        return r._categoriesData;
      }
      this.legendVisualProvider = new Kb(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(t) {
      n.prototype.mergeDefaultAndTheme.apply(this, arguments), hd(t, "edgeLabel", ["show"]);
    }, e.prototype.getInitialData = function(t, r) {
      var i = t.edges || t.links || [], o = t.data || t.nodes || [], a = this;
      if (o && i) {
        fLt(this);
        var s = aie(o, i, this, !0, l);
        return I(s.edges, function(u) {
          dLt(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = a._categoriesModels, v = p.getShallow("category"), m = g[v];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var h = mn.prototype.getModel;
        function f(p, g) {
          var v = h.call(this, p, g);
          return v.resolveParentPath = d, v;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = f, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(t, r, i) {
      if (i === "edge") {
        var o = this.getData(), a = this.getDataParams(t, i), s = o.graph.getEdgeByIndex(t), l = o.getName(s.node1.dataIndex), u = o.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), Qr("nameValue", {
          name: c.join(" > "),
          value: a.value,
          noValue: a.value == null
        });
      }
      var h = kte({
        series: this,
        dataIndex: t,
        multipleSeries: r
      });
      return h;
    }, e.prototype._updateCategoriesData = function() {
      var t = le(this.option.categories || [], function(i) {
        return i.value != null ? i : re({
          value: 0
        }, i);
      }), r = new Ki(["value"], this);
      r.initData(t), this._categoriesData = r, this._categoriesModels = r.mapArray(function(i) {
        return r.getItemModel(i);
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.isAnimationEnabled = function() {
      return n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, e.type = "series.graph", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Ln)
);
const PLt = kLt;
var ELt = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function MLt(n) {
  n.registerChartView(ALt), n.registerSeriesModel(PLt), n.registerProcessor(sLt), n.registerVisual(lLt), n.registerVisual(uLt), n.registerLayout(pLt), n.registerLayout(n.PRIORITY.VISUAL.POST_CHART_LAYOUT, vLt), n.registerLayout(yLt), n.registerCoordinateSystem("graphView", {
    dimensions: e1.dimensions,
    create: OLt
  }), n.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, nr), n.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, nr), n.registerAction(ELt, function(e, t, r) {
    t.eachComponent({
      mainType: "series",
      query: e
    }, function(i) {
      var o = i.coordinateSystem, a = zN(o, e, void 0, r);
      i.setCenter && i.setCenter(a.center), i.setZoom && i.setZoom(a.zoom);
    });
  });
}
var DLt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return n;
  }()
), LLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "pointer", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new DLt();
    }, e.prototype.buildPath = function(t, r) {
      var i = Math.cos, o = Math.sin, a = r.r, s = r.width, l = r.angle, u = r.x - i(l) * s * (s >= a / 3 ? 1 : 2), c = r.y - o(l) * s * (s >= a / 3 ? 1 : 2);
      l = r.angle - Math.PI / 2, t.moveTo(u, c), t.lineTo(r.x + i(l) * s, r.y + o(l) * s), t.lineTo(r.x + i(r.angle) * a, r.y + o(r.angle) * a), t.lineTo(r.x - i(l) * s, r.y - o(l) * s), t.lineTo(u, c);
    }, e;
  }(gt)
);
function ILt(n, e) {
  var t = n.get("center"), r = e.getWidth(), i = e.getHeight(), o = Math.min(r, i), a = be(t[0], e.getWidth()), s = be(t[1], e.getHeight()), l = be(n.get("radius"), o / 2);
  return {
    cx: a,
    cy: s,
    r: l
  };
}
function QO(n, e) {
  var t = n == null ? "" : n + "";
  return e && (we(e) ? t = e.replace("{value}", t) : Le(e) && (t = e(n))), t;
}
var RLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this.group.removeAll();
      var o = t.get(["axisLine", "lineStyle", "color"]), a = ILt(t, i);
      this._renderMain(t, r, i, o, a), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.prototype._renderMain = function(t, r, i, o, a) {
      var s = this.group, l = t.get("clockwise"), u = -t.get("startAngle") / 180 * Math.PI, c = -t.get("endAngle") / 180 * Math.PI, h = t.getModel("axisLine"), f = h.get("roundCap"), d = f ? $S : Eo, p = h.get("show"), g = h.getModel("lineStyle"), v = g.get("width"), m = [u, c];
      $R(m, !l), u = m[0], c = m[1];
      for (var y = c - u, b = u, O = [], w = 0; p && w < o.length; w++) {
        var x = Math.min(Math.max(o[w][0], 0), 1);
        c = u + y * x;
        var S = new d({
          shape: {
            startAngle: b,
            endAngle: c,
            cx: a.cx,
            cy: a.cy,
            clockwise: l,
            r0: a.r - v,
            r: a.r
          },
          silent: !0
        });
        S.setStyle({
          fill: o[w][1]
        }), S.setStyle(g.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), O.push(S), b = c;
      }
      O.reverse(), I(O, function(C) {
        return s.add(C);
      });
      var _ = function(C) {
        if (C <= 0)
          return o[0][1];
        var A;
        for (A = 0; A < o.length; A++)
          if (o[A][0] >= C && (A === 0 ? 0 : o[A - 1][0]) < C)
            return o[A][1];
        return o[A - 1][1];
      };
      this._renderTicks(t, r, i, _, a, u, c, l, v), this._renderTitleAndDetail(t, r, i, _, a), this._renderAnchor(t, a), this._renderPointer(t, r, i, _, a, u, c, l, v);
    }, e.prototype._renderTicks = function(t, r, i, o, a, s, l, u, c) {
      for (var h = this.group, f = a.cx, d = a.cy, p = a.r, g = +t.get("min"), v = +t.get("max"), m = t.getModel("splitLine"), y = t.getModel("axisTick"), b = t.getModel("axisLabel"), O = t.get("splitNumber"), w = y.get("splitNumber"), x = be(m.get("length"), p), S = be(y.get("length"), p), _ = s, C = (l - s) / O, A = C / w, k = m.getModel("lineStyle").getLineStyle(), P = y.getModel("lineStyle").getLineStyle(), L = m.get("distance"), D, E, M = 0; M <= O; M++) {
        if (D = Math.cos(_), E = Math.sin(_), m.get("show")) {
          var R = L ? L + c : c, N = new Br({
            shape: {
              x1: D * (p - R) + f,
              y1: E * (p - R) + d,
              x2: D * (p - x - R) + f,
              y2: E * (p - x - R) + d
            },
            style: k,
            silent: !0
          });
          k.stroke === "auto" && N.setStyle({
            stroke: o(M / O)
          }), h.add(N);
        }
        if (b.get("show")) {
          var R = b.get("distance") + L, $ = QO(qn(M / O * (v - g) + g), b.get("formatter")), F = o(M / O), W = D * (p - x - R) + f, j = E * (p - x - R) + d, Y = b.get("rotate"), X = 0;
          Y === "radial" ? (X = -_ + 2 * Math.PI, X > Math.PI / 2 && (X += Math.PI)) : Y === "tangential" ? X = -_ - Math.PI / 2 : $t(Y) && (X = Y * Math.PI / 180), X === 0 ? h.add(new Nt({
            style: vn(b, {
              text: $,
              x: W,
              y: j,
              verticalAlign: E < -0.8 ? "top" : E > 0.8 ? "bottom" : "middle",
              align: D < -0.4 ? "left" : D > 0.4 ? "right" : "center"
            }, {
              inheritColor: F
            }),
            silent: !0
          })) : h.add(new Nt({
            style: vn(b, {
              text: $,
              x: W,
              y: j,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: F
            }),
            silent: !0,
            originX: W,
            originY: j,
            rotation: X
          }));
        }
        if (y.get("show") && M !== O) {
          var R = y.get("distance");
          R = R ? R + c : c;
          for (var ie = 0; ie <= w; ie++) {
            D = Math.cos(_), E = Math.sin(_);
            var ae = new Br({
              shape: {
                x1: D * (p - R) + f,
                y1: E * (p - R) + d,
                x2: D * (p - S - R) + f,
                y2: E * (p - S - R) + d
              },
              silent: !0,
              style: P
            });
            P.stroke === "auto" && ae.setStyle({
              stroke: o((M + ie / w) / O)
            }), h.add(ae), _ += A;
          }
          _ -= A;
        } else
          _ += C;
      }
    }, e.prototype._renderPointer = function(t, r, i, o, a, s, l, u, c) {
      var h = this.group, f = this._data, d = this._progressEls, p = [], g = t.get(["pointer", "show"]), v = t.getModel("progress"), m = v.get("show"), y = t.getData(), b = y.mapDimension("value"), O = +t.get("min"), w = +t.get("max"), x = [O, w], S = [s, l];
      function _(A, k) {
        var P = y.getItemModel(A), L = P.getModel("pointer"), D = be(L.get("width"), a.r), E = be(L.get("length"), a.r), M = t.get(["pointer", "icon"]), R = L.get("offsetCenter"), N = be(R[0], a.r), $ = be(R[1], a.r), F = L.get("keepAspect"), W;
        return M ? W = vr(M, N - D / 2, $ - E, D, E, null, F) : W = new LLt({
          shape: {
            angle: -Math.PI / 2,
            width: D,
            r: E,
            x: N,
            y: $
          }
        }), W.rotation = -(k + Math.PI / 2), W.x = a.cx, W.y = a.cy, W;
      }
      function C(A, k) {
        var P = v.get("roundCap"), L = P ? $S : Eo, D = v.get("overlap"), E = D ? v.get("width") : c / y.count(), M = D ? a.r - E : a.r - (A + 1) * E, R = D ? a.r : a.r - A * E, N = new L({
          shape: {
            startAngle: s,
            endAngle: k,
            cx: a.cx,
            cy: a.cy,
            clockwise: u,
            r0: M,
            r: R
          }
        });
        return D && (N.z2 = w - y.get(b, A) % w), N;
      }
      (m || g) && (y.diff(f).add(function(A) {
        var k = y.get(b, A);
        if (g) {
          var P = _(A, s);
          Cn(P, {
            rotation: -((isNaN(+k) ? S[0] : Yt(k, x, S, !0)) + Math.PI / 2)
          }, t), h.add(P), y.setItemGraphicEl(A, P);
        }
        if (m) {
          var L = C(A, s), D = v.get("clip");
          Cn(L, {
            shape: {
              endAngle: Yt(k, x, S, D)
            }
          }, t), h.add(L), BM(t.seriesIndex, y.dataType, A, L), p[A] = L;
        }
      }).update(function(A, k) {
        var P = y.get(b, A);
        if (g) {
          var L = f.getItemGraphicEl(k), D = L ? L.rotation : s, E = _(A, D);
          E.rotation = D, Vt(E, {
            rotation: -((isNaN(+P) ? S[0] : Yt(P, x, S, !0)) + Math.PI / 2)
          }, t), h.add(E), y.setItemGraphicEl(A, E);
        }
        if (m) {
          var M = d[k], R = M ? M.shape.endAngle : s, N = C(A, R), $ = v.get("clip");
          Vt(N, {
            shape: {
              endAngle: Yt(P, x, S, $)
            }
          }, t), h.add(N), BM(t.seriesIndex, y.dataType, A, N), p[A] = N;
        }
      }).execute(), y.each(function(A) {
        var k = y.getItemModel(A), P = k.getModel("emphasis"), L = P.get("focus"), D = P.get("blurScope"), E = P.get("disabled");
        if (g) {
          var M = y.getItemGraphicEl(A), R = y.getItemVisual(A, "style"), N = R.fill;
          if (M instanceof Si) {
            var $ = M.style;
            M.useStyle(re({
              image: $.image,
              x: $.x,
              y: $.y,
              width: $.width,
              height: $.height
            }, R));
          } else
            M.useStyle(R), M.type !== "pointer" && M.setColor(N);
          M.setStyle(k.getModel(["pointer", "itemStyle"]).getItemStyle()), M.style.fill === "auto" && M.setStyle("fill", o(Yt(y.get(b, A), x, [0, 1], !0))), M.z2EmphasisLift = 0, Oi(M, k), Wn(M, L, D, E);
        }
        if (m) {
          var F = p[A];
          F.useStyle(y.getItemVisual(A, "style")), F.setStyle(k.getModel(["progress", "itemStyle"]).getItemStyle()), F.z2EmphasisLift = 0, Oi(F, k), Wn(F, L, D, E);
        }
      }), this._progressEls = p);
    }, e.prototype._renderAnchor = function(t, r) {
      var i = t.getModel("anchor"), o = i.get("show");
      if (o) {
        var a = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = vr(s, r.cx - a / 2 + be(l[0], r.r), r.cy - a / 2 + be(l[1], r.r), a, a, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, e.prototype._renderTitleAndDetail = function(t, r, i, o, a) {
      var s = this, l = t.getData(), u = l.mapDimension("value"), c = +t.get("min"), h = +t.get("max"), f = new We(), d = [], p = [], g = t.isAnimationEnabled(), v = t.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(m) {
        d[m] = new Nt({
          silent: !0
        }), p[m] = new Nt({
          silent: !0
        });
      }).update(function(m, y) {
        d[m] = s._titleEls[y], p[m] = s._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), b = l.get(u, m), O = new We(), w = o(Yt(b, [c, h], [0, 1], !0)), x = y.getModel("title");
        if (x.get("show")) {
          var S = x.get("offsetCenter"), _ = a.cx + be(S[0], a.r), C = a.cy + be(S[1], a.r), A = d[m];
          A.attr({
            z2: v ? 0 : 2,
            style: vn(x, {
              x: _,
              y: C,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: w
            })
          }), O.add(A);
        }
        var k = y.getModel("detail");
        if (k.get("show")) {
          var P = k.get("offsetCenter"), L = a.cx + be(P[0], a.r), D = a.cy + be(P[1], a.r), E = be(k.get("width"), a.r), M = be(k.get("height"), a.r), R = t.get(["progress", "show"]) ? l.getItemVisual(m, "style").fill : w, A = p[m], N = k.get("formatter");
          A.attr({
            z2: v ? 0 : 2,
            style: vn(k, {
              x: L,
              y: D,
              text: QO(b, N),
              width: isNaN(E) ? null : E,
              height: isNaN(M) ? null : M,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: R
            })
          }), Lee(A, {
            normal: k
          }, b, function(F) {
            return QO(F, N);
          }), g && Iee(A, m, l, t, {
            getFormattedLabel: function(F, W, j, Y, X, ie) {
              return QO(ie ? ie.interpolatedValue : b, N);
            }
          }), O.add(A);
        }
        f.add(O);
      }), this.group.add(f), this._titleEls = d, this._detailEls = p;
    }, e.type = "gauge", e;
  }(bn)
);
const NLt = RLt;
var $Lt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return Gv(this, ["value"]);
    }, e.type = "series.gauge", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 最小值
      min: 0,
      // 最大值
      max: 100,
      // 分割段数，默认为10
      splitNumber: 10,
      // 坐标轴线
      axisLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 坐标轴线
      progress: {
        // 默认显示，属性show控制显示与否
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 分隔线
      splitLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        // 属性length控制线长
        length: 10,
        distance: 10,
        // 属性lineStyle（详见lineStyle）控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 坐标轴小标记
      axisTick: {
        // 属性show控制显示与否，默认不显示
        show: !0,
        // 每份split细分多少段
        splitNumber: 5,
        // 属性length控制线长
        length: 6,
        distance: 10,
        // 属性lineStyle控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, y，单位px
        offsetCenter: [0, "20%"],
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, y，单位px
        offsetCenter: [0, "40%"],
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, e;
  }(Ln)
);
const BLt = $Lt;
function VLt(n) {
  n.registerChartView(NLt), n.registerSeriesModel(BLt);
}
var zLt = ["itemStyle", "opacity"], FLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r) {
      var i = n.call(this) || this, o = i, a = new io(), s = new Nt();
      return o.setTextContent(s), i.setTextGuideLine(a), i.updateData(t, r, !0), i;
    }
    return e.prototype.updateData = function(t, r, i) {
      var o = this, a = t.hostModel, s = t.getItemModel(r), l = t.getItemLayout(r), u = s.getModel("emphasis"), c = s.get(zLt);
      c = c ?? 1, i || ms(o), o.useStyle(t.getItemVisual(r, "style")), o.style.lineJoin = "round", i ? (o.setShape({
        points: l.points
      }), o.style.opacity = 0, Cn(o, {
        style: {
          opacity: c
        }
      }, a, r)) : Vt(o, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, a, r), Oi(o, s), this._updateLabel(t, r), Wn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, r) {
      var i = this, o = this.getTextGuideLine(), a = i.getTextContent(), s = t.hostModel, l = t.getItemModel(r), u = t.getItemLayout(r), c = u.label, h = t.getItemVisual(r, "style"), f = h.fill;
      wi(
        // position will not be used in setLabelStyle
        a,
        Fr(l),
        {
          labelFetcher: t.hostModel,
          labelDataIndex: r,
          defaultOpacity: h.opacity,
          defaultText: t.getName(r)
        },
        {
          normal: {
            align: c.textAlign,
            verticalAlign: c.verticalAlign
          }
        }
      ), i.setTextConfig({
        local: !0,
        inside: !!c.inside,
        insideStroke: f,
        // insideFill: 'auto',
        outsideFill: f
      });
      var d = c.linePoints;
      o.setShape({
        points: d
      }), i.textGuideLineConfig = {
        anchor: d ? new nt(d[0][0], d[0][1]) : null
      }, Vt(a, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, r), a.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), TN(i, kN(l), {
        // Default use item visual color
        stroke: f
      });
    }, e;
  }(ro)
), QLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = t.getData(), a = this._data, s = this.group;
      o.diff(a).add(function(l) {
        var u = new FLt(o, l);
        o.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = a.getItemGraphicEl(u);
        c.updateData(o, l), s.add(c), o.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = a.getItemGraphicEl(l);
        B0(u, t, l);
      }).execute(), this._data = o;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.prototype.dispose = function() {
    }, e.type = "funnel", e;
  }(bn)
);
const ZLt = QLt;
var WLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Kb(_e(this.getData, this), _e(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.getInitialData = function(t, r) {
      return Gv(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Je(nN, this)
      });
    }, e.prototype._defaultLabelLine = function(t) {
      hd(t, "labelLine", ["show"]);
      var r = t.labelLine, i = t.emphasis.labelLine;
      r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.prototype.getDataParams = function(t) {
      var r = this.getData(), i = n.prototype.getDataParams.call(this, t), o = r.mapDimension("value"), a = r.getSum(o);
      return i.percent = a ? +(r.get(o, t) / a * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, e.type = "series.funnel", e.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 默认取数据最小最大值
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: 各异,
          width: 1
        }
      },
      itemStyle: {
        // color: 各异,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Ln)
);
const GLt = WLt;
function jLt(n, e) {
  return Cr(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function HLt(n, e) {
  for (var t = n.mapDimension("value"), r = n.mapArray(t, function(l) {
    return l;
  }), i = [], o = e === "ascending", a = 0, s = n.count(); a < s; a++)
    i[a] = a;
  return Le(e) ? i.sort(e) : e !== "none" && i.sort(function(l, u) {
    return o ? r[l] - r[u] : r[u] - r[l];
  }), i;
}
function qLt(n) {
  var e = n.hostModel, t = e.get("orient");
  n.each(function(r) {
    var i = n.getItemModel(r), o = i.getModel("label"), a = o.get("position"), s = i.getModel("labelLine"), l = n.getItemLayout(r), u = l.points, c = a === "inner" || a === "inside" || a === "center" || a === "insideLeft" || a === "insideRight", h, f, d, p;
    if (c)
      a === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, h = "left") : a === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, h = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, h = "center"), p = [[f, d], [f, d]];
    else {
      var g = void 0, v = void 0, m = void 0, y = void 0, b = s.get("length");
      process.env.NODE_ENV !== "production" && (t === "vertical" && ["top", "bottom"].indexOf(a) > -1 && (a = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), t === "horizontal" && ["left", "right"].indexOf(a) > -1 && (a = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), a === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = g - b, f = m - 5, h = "right") : a === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = g + b, f = m + 5, h = "left") : a === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, y = v - b, d = y - 5, h = "center") : a === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, y = v + b, d = y + 5, h = "center") : a === "rightTop" ? (g = t === "horizontal" ? u[3][0] : u[1][0], v = t === "horizontal" ? u[3][1] : u[1][1], t === "horizontal" ? (y = v - b, d = y - 5, h = "center") : (m = g + b, f = m + 5, h = "top")) : a === "rightBottom" ? (g = u[2][0], v = u[2][1], t === "horizontal" ? (y = v + b, d = y + 5, h = "center") : (m = g + b, f = m + 5, h = "bottom")) : a === "leftTop" ? (g = u[0][0], v = t === "horizontal" ? u[0][1] : u[1][1], t === "horizontal" ? (y = v - b, d = y - 5, h = "center") : (m = g - b, f = m - 5, h = "right")) : a === "leftBottom" ? (g = t === "horizontal" ? u[1][0] : u[3][0], v = t === "horizontal" ? u[1][1] : u[2][1], t === "horizontal" ? (y = v + b, d = y + 5, h = "center") : (m = g - b, f = m - 5, h = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, t === "horizontal" ? (y = v + b, d = y + 5, h = "center") : (m = g + b, f = m + 5, h = "left")), t === "horizontal" ? (m = g, f = m) : (y = v, d = y), p = [[g, v], [m, y]];
    }
    l.label = {
      linePoints: p,
      x: f,
      y: d,
      verticalAlign: "middle",
      textAlign: h,
      inside: c
    };
  });
}
function YLt(n, e) {
  n.eachSeriesByType("funnel", function(t) {
    var r = t.getData(), i = r.mapDimension("value"), o = t.get("sort"), a = jLt(t, e), s = t.get("orient"), l = a.width, u = a.height, c = HLt(r, o), h = a.x, f = a.y, d = s === "horizontal" ? [be(t.get("minSize"), u), be(t.get("maxSize"), u)] : [be(t.get("minSize"), l), be(t.get("maxSize"), l)], p = r.getDataExtent(i), g = t.get("min"), v = t.get("max");
    g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1]);
    var m = t.get("funnelAlign"), y = t.get("gap"), b = s === "horizontal" ? l : u, O = (b - y * (r.count() - 1)) / r.count(), w = function(D, E) {
      if (s === "horizontal") {
        var M = r.get(i, D) || 0, R = Yt(M, [g, v], d, !0), N = void 0;
        switch (m) {
          case "top":
            N = f;
            break;
          case "center":
            N = f + (u - R) / 2;
            break;
          case "bottom":
            N = f + (u - R);
            break;
        }
        return [[E, N], [E, N + R]];
      }
      var $ = r.get(i, D) || 0, F = Yt($, [g, v], d, !0), W;
      switch (m) {
        case "left":
          W = h;
          break;
        case "center":
          W = h + (l - F) / 2;
          break;
        case "right":
          W = h + l - F;
          break;
      }
      return [[W, E], [W + F, E]];
    };
    o === "ascending" && (O = -O, y = -y, s === "horizontal" ? h += l : f += u, c = c.reverse());
    for (var x = 0; x < c.length; x++) {
      var S = c[x], _ = c[x + 1], C = r.getItemModel(S);
      if (s === "horizontal") {
        var A = C.get(["itemStyle", "width"]);
        A == null ? A = O : (A = be(A, l), o === "ascending" && (A = -A));
        var k = w(S, h), P = w(_, h + A);
        h += A + y, r.setItemLayout(S, {
          points: k.concat(P.slice().reverse())
        });
      } else {
        var L = C.get(["itemStyle", "height"]);
        L == null ? L = O : (L = be(L, u), o === "ascending" && (L = -L));
        var k = w(S, f), P = w(_, f + L);
        f += L + y, r.setItemLayout(S, {
          points: k.concat(P.slice().reverse())
        });
      }
    }
    qLt(r);
  });
}
function XLt(n) {
  n.registerChartView(ZLt), n.registerSeriesModel(GLt), n.registerLayout(YLt), n.registerProcessor(Ub("funnel"));
}
var ULt = 0.3, KLt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._dataGroup = new We(), t._initialized = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, e.prototype.render = function(t, r, i, o) {
      this._progressiveEls = null;
      var a = this._dataGroup, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.dimensions, h = XQ(t);
      s.diff(l).add(f).update(d).remove(p).execute();
      function f(v) {
        var m = YQ(s, a, v, c, u);
        sk(m, s, v, h);
      }
      function d(v, m) {
        var y = l.getItemGraphicEl(m), b = sie(s, v, c, u);
        s.setItemGraphicEl(v, y), Vt(y, {
          shape: {
            points: b
          }
        }, t, v), ms(y), sk(y, s, v, h);
      }
      function p(v) {
        var m = l.getItemGraphicEl(v);
        a.remove(m);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var g = JLt(u, t, function() {
          setTimeout(function() {
            a.removeClipPath();
          });
        });
        a.setClipPath(g);
      }
      this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, e.prototype.incrementalRender = function(t, r, i) {
      for (var o = r.getData(), a = r.coordinateSystem, s = a.dimensions, l = XQ(r), u = this._progressiveEls = [], c = t.start; c < t.end; c++) {
        var h = YQ(o, this._dataGroup, c, s, a);
        h.incremental = !0, sk(h, o, c, l), u.push(h);
      }
    }, e.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, e.type = "parallel", e;
  }(bn)
);
function JLt(n, e, t) {
  var r = n.model, i = n.getRect(), o = new Lt({
    shape: {
      x: i.x,
      y: i.y,
      width: i.width,
      height: i.height
    }
  }), a = r.get("layout") === "horizontal" ? "width" : "height";
  return o.setShape(a, 0), Cn(o, {
    shape: {
      width: i.width,
      height: i.height
    }
  }, e, t), o;
}
function sie(n, e, t, r) {
  for (var i = [], o = 0; o < t.length; o++) {
    var a = t[o], s = n.get(n.mapDimension(a), e);
    eIt(s, r.getAxis(a).type) || i.push(r.dataToPoint(s, a));
  }
  return i;
}
function YQ(n, e, t, r, i) {
  var o = sie(n, t, r, i), a = new io({
    shape: {
      points: o
    },
    // silent: true,
    z2: 10
  });
  return e.add(a), n.setItemGraphicEl(t, a), a;
}
function XQ(n) {
  var e = n.get("smooth", !0);
  return e === !0 && (e = ULt), e = pu(e), cd(e) && (e = 0), {
    smooth: e
  };
}
function sk(n, e, t, r) {
  n.useStyle(e.getItemVisual(t, "style")), n.style.fill = null, n.setShape("smooth", r.smooth);
  var i = e.getItemModel(t), o = i.getModel("emphasis");
  Oi(n, i, "lineStyle"), Wn(n, o.get("focus"), o.get("blurScope"), o.get("disabled"));
}
function eIt(n, e) {
  return e === "category" ? n == null : n == null || isNaN(n);
}
const tIt = KLt;
var nIt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return ku(null, this, {
        useEncodeDefaulter: _e(rIt, null, this)
      });
    }, e.prototype.getRawIndicesByActiveState = function(t) {
      var r = this.coordinateSystem, i = this.getData(), o = [];
      return r.eachActiveState(i, function(a, s) {
        t === a && o.push(i.getRawIndex(s));
      }), o;
    }, e.type = "series.parallel", e.dependencies = ["parallel"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, e;
  }(Ln)
);
function rIt(n) {
  var e = n.ecModel.getComponent("parallel", n.get("parallelIndex"));
  if (e) {
    var t = {};
    return I(e.dimensions, function(r) {
      var i = iIt(r);
      t[r] = i;
    }), t;
  }
}
function iIt(n) {
  return +n.replace("dim", "");
}
const oIt = nIt;
var aIt = ["lineStyle", "opacity"], sIt = {
  seriesType: "parallel",
  reset: function(n, e) {
    var t = n.coordinateSystem, r = {
      normal: n.get(["lineStyle", "opacity"]),
      active: n.get("activeOpacity"),
      inactive: n.get("inactiveOpacity")
    };
    return {
      progress: function(i, o) {
        t.eachActiveState(o, function(a, s) {
          var l = r[a];
          if (a === "normal" && o.hasItemOption) {
            var u = o.getItemModel(s).get(aIt, !0);
            u != null && (l = u);
          }
          var c = o.ensureUniqueItemVisual(s, "style");
          c.opacity = l;
        }, i.start, i.end);
      }
    };
  }
};
const lIt = sIt;
function uIt(n) {
  cIt(n), hIt(n);
}
function cIt(n) {
  if (!n.parallel) {
    var e = !1;
    I(n.series, function(t) {
      t && t.type === "parallel" && (e = !0);
    }), e && (n.parallel = [{}]);
  }
}
function hIt(n) {
  var e = an(n.parallelAxis);
  I(e, function(t) {
    if (Ne(t)) {
      var r = t.parallelIndex || 0, i = an(n.parallel)[r];
      i && i.parallelAxisDefault && it(t, i.parallelAxisDefault, !1);
    }
  });
}
var fIt = 5, dIt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this._model = t, this._api = i, this._handlers || (this._handlers = {}, I(pIt, function(o, a) {
        i.getZr().on(a, this._handlers[a] = _e(o, this));
      }, this)), Zv(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
    }, e.prototype.dispose = function(t, r) {
      Q0(this, "_throttledDispatchExpand"), I(this._handlers, function(i, o) {
        r.getZr().off(o, i);
      }), this._handlers = null;
    }, e.prototype._throttledDispatchExpand = function(t) {
      this._dispatchExpand(t);
    }, e.prototype._dispatchExpand = function(t) {
      t && this._api.dispatchAction(re({
        type: "parallelAxisExpand"
      }, t));
    }, e.type = "parallel", e;
  }(Gn)
), pIt = {
  mousedown: function(n) {
    lk(this, "click") && (this._mouseDownPoint = [n.offsetX, n.offsetY]);
  },
  mouseup: function(n) {
    var e = this._mouseDownPoint;
    if (lk(this, "click") && e) {
      var t = [n.offsetX, n.offsetY], r = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
      if (r > fIt)
        return;
      var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]);
      i.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: i.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(n) {
    if (!(this._mouseDownPoint || !lk(this, "mousemove"))) {
      var e = this._model, t = e.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]), r = t.behavior;
      r === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(r === "none" ? null : {
        axisExpandWindow: t.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: r === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function lk(n, e) {
  var t = n._model;
  return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e;
}
const gIt = dIt;
var vIt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      n.prototype.init.apply(this, arguments), this.mergeOption({});
    }, e.prototype.mergeOption = function(t) {
      var r = this.option;
      t && it(r, t, !0), this._initDimensions();
    }, e.prototype.contains = function(t, r) {
      var i = t.get("parallelIndex");
      return i != null && r.getComponent("parallel", i) === this;
    }, e.prototype.setAxisExpand = function(t) {
      I(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(r) {
        t.hasOwnProperty(r) && (this.option[r] = t[r]);
      }, this);
    }, e.prototype._initDimensions = function() {
      var t = this.dimensions = [], r = this.parallelAxisIndex = [], i = en(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(o) {
        return (o.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      I(i, function(o) {
        t.push("dim" + o.get("dim")), r.push(o.componentIndex);
      });
    }, e.type = "parallel", e.dependencies = ["parallelAxis"], e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, e;
  }(Pt)
);
const mIt = vIt;
var yIt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i, o, a) {
      var s = n.call(this, t, r, i) || this;
      return s.type = o || "value", s.axisIndex = a, s;
    }
    return e.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, e;
  }(As)
);
const bIt = yIt;
function Bd(n, e, t, r, i, o) {
  n = n || 0;
  var a = t[1] - t[0];
  if (i != null && (i = fp(i, [0, a])), o != null && (o = Math.max(o, i ?? 0)), r === "all") {
    var s = Math.abs(e[1] - e[0]);
    s = fp(s, [0, a]), i = o = fp(s, [i, o]), r = 0;
  }
  e[0] = fp(e[0], t), e[1] = fp(e[1], t);
  var l = uk(e, r);
  e[r] += n;
  var u = i || 0, c = t.slice();
  l.sign < 0 ? c[0] += u : c[1] -= u, e[r] = fp(e[r], c);
  var h;
  return h = uk(e, r), i != null && (h.sign !== l.sign || h.span < i) && (e[1 - r] = e[r] + l.sign * i), h = uk(e, r), o != null && h.span > o && (e[1 - r] = e[r] + h.sign * o), e;
}
function uk(n, e) {
  var t = n[e] - n[1 - e];
  return {
    span: Math.abs(t),
    sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
  };
}
function fp(n, e) {
  return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, n));
}
var ck = I, lie = Math.min, uie = Math.max, UQ = Math.floor, OIt = Math.ceil, KQ = qn, wIt = Math.PI, xIt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "parallel", this._axesMap = Ee(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, r);
    }
    return n.prototype._init = function(e, t, r) {
      var i = e.dimensions, o = e.parallelAxisIndex;
      ck(i, function(a, s) {
        var l = o[s], u = t.getComponent("parallelAxis", l), c = this._axesMap.set(a, new bIt(a, ZC(u), [0, 0], u.get("type"), l)), h = c.type === "category";
        c.onBand = h && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, n.prototype.update = function(e, t) {
      this._updateAxesFromSeries(this._model, e);
    }, n.prototype.containPoint = function(e) {
      var t = this._makeLayoutInfo(), r = t.axisBase, i = t.layoutBase, o = t.pixelDimIndex, a = e[1 - o], s = e[o];
      return a >= r && a <= r + t.axisLength && s >= i && s <= i + t.layoutLength;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype._updateAxesFromSeries = function(e, t) {
      t.eachSeries(function(r) {
        if (e.contains(r, t)) {
          var i = r.getData();
          ck(this.dimensions, function(o) {
            var a = this._axesMap.get(o);
            a.scale.unionExtentFromData(i, i.mapDimension(o)), Kg(a.scale, a.model);
          }, this);
        }
      }, this);
    }, n.prototype.resize = function(e, t) {
      this._rect = Cr(e.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._layoutAxes();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._makeLayoutInfo = function() {
      var e = this._model, t = this._rect, r = ["x", "y"], i = ["width", "height"], o = e.get("layout"), a = o === "horizontal" ? 0 : 1, s = t[i[a]], l = [0, s], u = this.dimensions.length, c = ZO(e.get("axisExpandWidth"), l), h = ZO(e.get("axisExpandCount") || 0, [0, u]), f = e.get("axisExpandable") && u > 3 && u > h && h > 1 && c > 0 && s > 0, d = e.get("axisExpandWindow"), p;
      if (d)
        p = ZO(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = ZO(c * (h - 1), l);
        var g = e.get("axisExpandCenter") || UQ(u / 2);
        d = [c * g - p / 2], d[1] = d[0] + p;
      }
      var v = (s - p) / (u - h);
      v < 3 && (v = 0);
      var m = [UQ(KQ(d[0] / c, 1)) + 1, OIt(KQ(d[1] / c, 1)) - 1], y = v / c * d[0];
      return {
        layout: o,
        pixelDimIndex: a,
        layoutBase: t[r[a]],
        layoutLength: s,
        axisBase: t[r[1 - a]],
        axisLength: t[i[1 - a]],
        axisExpandable: f,
        axisExpandWidth: c,
        axisCollapseWidth: v,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, n.prototype._layoutAxes = function() {
      var e = this._rect, t = this._axesMap, r = this.dimensions, i = this._makeLayoutInfo(), o = i.layout;
      t.each(function(a) {
        var s = [0, i.axisLength], l = a.inverse ? 1 : 0;
        a.setExtent(s[l], s[1 - l]);
      }), ck(r, function(a, s) {
        var l = (i.axisExpandable ? _It : SIt)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: wIt / 2,
          vertical: 0
        }, h = [u[o].x + e.x, u[o].y + e.y], f = c[o], d = Ho();
        Md(d, d, f), Sl(d, d, h), this._axesLayout[a] = {
          position: h,
          rotation: f,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, n.prototype.getAxis = function(e) {
      return this._axesMap.get(e);
    }, n.prototype.dataToPoint = function(e, t) {
      return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t);
    }, n.prototype.eachActiveState = function(e, t, r, i) {
      r == null && (r = 0), i == null && (i = e.count());
      var o = this._axesMap, a = this.dimensions, s = [], l = [];
      I(a, function(v) {
        s.push(e.mapDimension(v)), l.push(o.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), c = r; c < i; c++) {
        var h = void 0;
        if (!u)
          h = "normal";
        else {
          h = "active";
          for (var f = e.getValues(s, c), d = 0, p = a.length; d < p; d++) {
            var g = l[d].getActiveState(f[d]);
            if (g === "inactive") {
              h = "inactive";
              break;
            }
          }
        }
        t(h, c);
      }
    }, n.prototype.hasAxisBrushed = function() {
      for (var e = this.dimensions, t = this._axesMap, r = !1, i = 0, o = e.length; i < o; i++)
        t.get(e[i]).model.getActiveState() !== "normal" && (r = !0);
      return r;
    }, n.prototype.axisCoordToPoint = function(e, t) {
      var r = this._axesLayout[t];
      return cs([e, 0], r.transform);
    }, n.prototype.getAxisLayout = function(e) {
      return Fe(this._axesLayout[e]);
    }, n.prototype.getSlidedAxisExpandWindow = function(e) {
      var t = this._makeLayoutInfo(), r = t.pixelDimIndex, i = t.axisExpandWindow.slice(), o = i[1] - i[0], a = [0, t.axisExpandWidth * (t.axisCount - 1)];
      if (!this.containPoint(e))
        return {
          behavior: "none",
          axisExpandWindow: i
        };
      var s = e[r] - t.layoutBase - t.axisExpandWindow0Pos, l, u = "slide", c = t.axisCollapseWidth, h = this._model.get("axisExpandSlideTriggerArea"), f = h[0] != null;
      if (c)
        f && c && s < o * h[0] ? (u = "jump", l = s - o * h[2]) : f && c && s > o * (1 - h[0]) ? (u = "jump", l = s - o * (1 - h[2])) : (l = s - o * h[1]) >= 0 && (l = s - o * (1 - h[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / c, l ? Bd(l, i, a, "all") : u = "none";
      else {
        var d = i[1] - i[0], p = a[1] * s / d;
        i = [uie(0, p - d / 2)], i[1] = lie(a[1], i[0] + d), i[0] = i[1] - d;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, n;
  }()
);
function ZO(n, e) {
  return lie(uie(n, e[0]), e[1]);
}
function SIt(n, e) {
  var t = e.layoutLength / (e.axisCount - 1);
  return {
    position: t * n,
    axisNameAvailableWidth: t,
    axisLabelShow: !0
  };
}
function _It(n, e) {
  var t = e.layoutLength, r = e.axisExpandWidth, i = e.axisCount, o = e.axisCollapseWidth, a = e.winInnerIndices, s, l = o, u = !1, c;
  return n < a[0] ? (s = n * o, c = o) : n <= a[1] ? (s = e.axisExpandWindow0Pos + n * r - e.axisExpandWindow[0], l = r, u = !0) : (s = t - (i - 1 - n) * o, c = o), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: c
  };
}
function CIt(n, e) {
  var t = [];
  return n.eachComponent("parallel", function(r, i) {
    var o = new xIt(r, n, e);
    o.name = "parallel_" + i, o.resize(r, e), r.coordinateSystem = o, o.model = r, t.push(o);
  }), n.eachSeries(function(r) {
    if (r.get("coordinateSystem") === "parallel") {
      var i = r.getReferringComponents("parallel", cr).models[0];
      r.coordinateSystem = i.coordinateSystem;
    }
  }), t;
}
var AIt = {
  create: CIt
};
const TIt = AIt;
var cie = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.activeIntervals = [], t;
    }
    return e.prototype.getAreaSelectStyle = function() {
      return dd([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, e.prototype.setActiveIntervals = function(t) {
      var r = this.activeIntervals = Fe(t);
      if (r)
        for (var i = r.length - 1; i >= 0; i--)
          wa(r[i]);
    }, e.prototype.getActiveState = function(t) {
      var r = this.activeIntervals;
      if (!r.length)
        return "normal";
      if (t == null || isNaN(+t))
        return "inactive";
      if (r.length === 1) {
        var i = r[0];
        if (i[0] <= t && t <= i[1])
          return "active";
      } else
        for (var o = 0, a = r.length; o < a; o++)
          if (r[o][0] <= t && t <= r[o][1])
            return "active";
      return "inactive";
    }, e;
  }(Pt)
);
mr(cie, jb);
const JQ = cie;
var vd = !0, eb = Math.min, tv = Math.max, kIt = Math.pow, PIt = 1e4, EIt = 6, MIt = 6, eZ = "globalPan", DIt = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, LIt = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, tZ = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, IIt = 0, RIt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r._track = [], r._covers = [], r._handlers = {}, process.env.NODE_ENV !== "production" && $e(t), r._zr = t, r.group = new We(), r._uid = "brushController_" + IIt++, I(QIt, function(i, o) {
        this._handlers[o] = _e(i, this);
      }, r), r;
    }
    return e.prototype.enableBrush = function(t) {
      return process.env.NODE_ENV !== "production" && $e(this._mounted), this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this;
    }, e.prototype._doEnableBrush = function(t) {
      var r = this._zr;
      this._enableGlobalPan || KEt(r, eZ, this._uid), I(this._handlers, function(i, o) {
        r.on(o, i);
      }), this._brushType = t.brushType, this._brushOption = it(Fe(tZ), t, !0);
    }, e.prototype._doDisableBrush = function() {
      var t = this._zr;
      JEt(t, eZ, this._uid), I(this._handlers, function(r, i) {
        t.off(i, r);
      }), this._brushType = this._brushOption = null;
    }, e.prototype.setPanels = function(t) {
      if (t && t.length) {
        var r = this._panels = {};
        I(t, function(i) {
          r[i.panelId] = Fe(i);
        });
      } else
        this._panels = null;
      return this;
    }, e.prototype.mount = function(t) {
      t = t || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = t.enableGlobalPan;
      var r = this.group;
      return this._zr.add(r), r.attr({
        x: t.x || 0,
        y: t.y || 0,
        rotation: t.rotation || 0,
        scaleX: t.scaleX || 1,
        scaleY: t.scaleY || 1
      }), this._transform = r.getLocalTransform(), this;
    }, e.prototype.updateCovers = function(t) {
      process.env.NODE_ENV !== "production" && $e(this._mounted), t = le(t, function(f) {
        return it(Fe(tZ), f, !0);
      });
      var r = "\0-brush-index-", i = this._covers, o = this._covers = [], a = this, s = this._creatingCover;
      return new mu(i, t, u, l).add(c).update(c).remove(h).execute(), this;
      function l(f, d) {
        return (f.id != null ? f.id : r + d) + "-" + f.brushType;
      }
      function u(f, d) {
        return l(f.__brushOption, d);
      }
      function c(f, d) {
        var p = t[f];
        if (d != null && i[d] === s)
          o[f] = i[d];
        else {
          var g = o[f] = d != null ? (i[d].__brushOption = p, i[d]) : fie(a, hie(a, p));
          UN(a, g);
        }
      }
      function h(f) {
        i[f] !== s && a.group.remove(i[f]);
      }
    }, e.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), kD(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, e.prototype.dispose = function() {
      this.unmount(), this.off();
    }, e;
  }(Ba)
);
function hie(n, e) {
  var t = YC[e.brushType].createCover(n, e);
  return t.__brushOption = e, pie(t, e), n.group.add(t), t;
}
function fie(n, e) {
  var t = KN(e);
  return t.endCreating && (t.endCreating(n, e), pie(e, e.__brushOption)), e;
}
function die(n, e) {
  var t = e.__brushOption;
  KN(e).updateCoverShape(n, e, t.range, t);
}
function pie(n, e) {
  var t = e.z;
  t == null && (t = PIt), n.traverse(function(r) {
    r.z = t, r.z2 = t;
  });
}
function UN(n, e) {
  KN(e).updateCommon(n, e), die(n, e);
}
function KN(n) {
  return YC[n.__brushOption.brushType];
}
function JN(n, e, t) {
  var r = n._panels;
  if (!r)
    return vd;
  var i, o = n._transform;
  return I(r, function(a) {
    a.isTargetByCursor(e, t, o) && (i = a);
  }), i;
}
function gie(n, e) {
  var t = n._panels;
  if (!t)
    return vd;
  var r = e.__brushOption.panelId;
  return r != null ? t[r] : vd;
}
function kD(n) {
  var e = n._covers, t = e.length;
  return I(e, function(r) {
    n.group.remove(r);
  }, n), e.length = 0, !!t;
}
function md(n, e) {
  var t = le(n._covers, function(r) {
    var i = r.__brushOption, o = Fe(i.range);
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: o
    };
  });
  n.trigger("brush", {
    areas: t,
    isEnd: !!e.isEnd,
    removeOnClick: !!e.removeOnClick
  });
}
function NIt(n) {
  var e = n._track;
  if (!e.length)
    return !1;
  var t = e[e.length - 1], r = e[0], i = t[0] - r[0], o = t[1] - r[1], a = kIt(i * i + o * o, 0.5);
  return a > EIt;
}
function vie(n) {
  var e = n.length - 1;
  return e < 0 && (e = 0), [n[0], n[e]];
}
function mie(n, e, t, r) {
  var i = new We();
  return i.add(new Lt({
    name: "main",
    style: e$(t),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: Je(nZ, n, e, i, ["n", "s", "w", "e"]),
    ondragend: Je(md, e, {
      isEnd: !0
    })
  })), I(r, function(o) {
    i.add(new Lt({
      name: o.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: Je(nZ, n, e, i, o),
      ondragend: Je(md, e, {
        isEnd: !0
      })
    }));
  }), i;
}
function yie(n, e, t, r) {
  var i = r.brushStyle.lineWidth || 0, o = tv(i, MIt), a = t[0][0], s = t[1][0], l = a - i / 2, u = s - i / 2, c = t[0][1], h = t[1][1], f = c - o + i / 2, d = h - o + i / 2, p = c - a, g = h - s, v = p + i, m = g + i;
  Vl(n, e, "main", a, s, p, g), r.transformable && (Vl(n, e, "w", l, u, o, m), Vl(n, e, "e", f, u, o, m), Vl(n, e, "n", l, u, v, o), Vl(n, e, "s", l, d, v, o), Vl(n, e, "nw", l, u, o, o), Vl(n, e, "ne", f, u, o, o), Vl(n, e, "sw", l, d, o, o), Vl(n, e, "se", f, d, o, o));
}
function PD(n, e) {
  var t = e.__brushOption, r = t.transformable, i = e.childAt(0);
  i.useStyle(e$(t)), i.attr({
    silent: !r,
    cursor: r ? "move" : "default"
  }), I([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(o) {
    var a = e.childOfName(o.join("")), s = o.length === 1 ? ED(n, o[0]) : BIt(n, o);
    a && a.attr({
      silent: !r,
      invisible: !r,
      cursor: r ? LIt[s] + "-resize" : null
    });
  });
}
function Vl(n, e, t, r, i, o, a) {
  var s = e.childOfName(t);
  s && s.setShape(zIt(t$(n, e, [[r, i], [r + o, i + a]])));
}
function e$(n) {
  return Be({
    strokeNoScale: !0
  }, n.brushStyle);
}
function bie(n, e, t, r) {
  var i = [eb(n, t), eb(e, r)], o = [tv(n, t), tv(e, r)];
  return [
    [i[0], o[0]],
    [i[1], o[1]]
    // y range
  ];
}
function $It(n) {
  return Wf(n.group);
}
function ED(n, e) {
  var t = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, r = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, i = kC(t[e], $It(n));
  return r[i];
}
function BIt(n, e) {
  var t = [ED(n, e[0]), ED(n, e[1])];
  return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("");
}
function nZ(n, e, t, r, i, o) {
  var a = t.__brushOption, s = n.toRectRange(a.range), l = Oie(e, i, o);
  I(r, function(u) {
    var c = DIt[u];
    s[c[0]][c[1]] += l[c[0]];
  }), a.range = n.fromRectRange(bie(s[0][0], s[1][0], s[0][1], s[1][1])), UN(e, t), md(e, {
    isEnd: !1
  });
}
function VIt(n, e, t, r) {
  var i = e.__brushOption.range, o = Oie(n, t, r);
  I(i, function(a) {
    a[0] += o[0], a[1] += o[1];
  }), UN(n, e), md(n, {
    isEnd: !1
  });
}
function Oie(n, e, t) {
  var r = n.group, i = r.transformCoordToLocal(e, t), o = r.transformCoordToLocal(0, 0);
  return [i[0] - o[0], i[1] - o[1]];
}
function t$(n, e, t) {
  var r = gie(n, e);
  return r && r !== vd ? r.clipPath(t, n._transform) : Fe(t);
}
function zIt(n) {
  var e = eb(n[0][0], n[1][0]), t = eb(n[0][1], n[1][1]), r = tv(n[0][0], n[1][0]), i = tv(n[0][1], n[1][1]);
  return {
    x: e,
    y: t,
    width: r - e,
    height: i - t
  };
}
function FIt(n, e, t) {
  if (
    // Check active
    !(!n._brushType || ZIt(n, e.offsetX, e.offsetY))
  ) {
    var r = n._zr, i = n._covers, o = JN(n, e, t);
    if (!n._dragging)
      for (var a = 0; a < i.length; a++) {
        var s = i[a].__brushOption;
        if (o && (o === vd || s.panelId === o.panelId) && YC[s.brushType].contain(i[a], t[0], t[1]))
          return;
      }
    o && r.setCursorStyle("crosshair");
  }
}
function MD(n) {
  var e = n.event;
  e.preventDefault && e.preventDefault();
}
function DD(n, e, t) {
  return n.childOfName("main").contain(e, t);
}
function wie(n, e, t, r) {
  var i = n._creatingCover, o = n._creatingPanel, a = n._brushOption, s;
  if (n._track.push(t.slice()), NIt(n) || i) {
    if (o && !i) {
      a.brushMode === "single" && kD(n);
      var l = Fe(a);
      l.brushType = rZ(l.brushType, o), l.panelId = o === vd ? null : o.panelId, i = n._creatingCover = hie(n, l), n._covers.push(i);
    }
    if (i) {
      var u = YC[rZ(n._brushType, o)], c = i.__brushOption;
      c.range = u.getCreatingRange(t$(n, i, n._track)), r && (fie(n, i), u.updateCommon(n, i)), die(n, i), s = {
        isEnd: r
      };
    }
  } else
    r && a.brushMode === "single" && a.removeOnClick && JN(n, e, t) && kD(n) && (s = {
      isEnd: r,
      removeOnClick: !0
    });
  return s;
}
function rZ(n, e) {
  return n === "auto" ? (process.env.NODE_ENV !== "production" && $e(e && e.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), e.defaultBrushType) : n;
}
var QIt = {
  mousedown: function(n) {
    if (this._dragging)
      iZ(this, n);
    else if (!n.target || !n.target.draggable) {
      MD(n);
      var e = this.group.transformCoordToLocal(n.offsetX, n.offsetY);
      this._creatingCover = null;
      var t = this._creatingPanel = JN(this, n, e);
      t && (this._dragging = !0, this._track = [e.slice()]);
    }
  },
  mousemove: function(n) {
    var e = n.offsetX, t = n.offsetY, r = this.group.transformCoordToLocal(e, t);
    if (FIt(this, n, r), this._dragging) {
      MD(n);
      var i = wie(this, n, r, !1);
      i && md(this, i);
    }
  },
  mouseup: function(n) {
    iZ(this, n);
  }
};
function iZ(n, e) {
  if (n._dragging) {
    MD(e);
    var t = e.offsetX, r = e.offsetY, i = n.group.transformCoordToLocal(t, r), o = wie(n, e, i, !0);
    n._dragging = !1, n._track = [], n._creatingCover = null, o && md(n, o);
  }
}
function ZIt(n, e, t) {
  var r = n._zr;
  return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight();
}
var YC = {
  lineX: oZ(0),
  lineY: oZ(1),
  rect: {
    createCover: function(n, e) {
      function t(r) {
        return r;
      }
      return mie({
        toRectRange: t,
        fromRectRange: t
      }, n, e, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(n) {
      var e = vie(n);
      return bie(e[1][0], e[1][1], e[0][0], e[0][1]);
    },
    updateCoverShape: function(n, e, t, r) {
      yie(n, e, t, r);
    },
    updateCommon: PD,
    contain: DD
  },
  polygon: {
    createCover: function(n, e) {
      var t = new We();
      return t.add(new io({
        name: "main",
        style: e$(e),
        silent: !0
      })), t;
    },
    getCreatingRange: function(n) {
      return n;
    },
    endCreating: function(n, e) {
      e.remove(e.childAt(0)), e.add(new ro({
        name: "main",
        draggable: !0,
        drift: Je(VIt, n, e),
        ondragend: Je(md, n, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(n, e, t, r) {
      e.childAt(0).setShape({
        points: t$(n, e, t)
      });
    },
    updateCommon: PD,
    contain: DD
  }
};
function oZ(n) {
  return {
    createCover: function(e, t) {
      return mie({
        toRectRange: function(r) {
          var i = [r, [0, 100]];
          return n && i.reverse(), i;
        },
        fromRectRange: function(r) {
          return r[n];
        }
      }, e, t, [[["w"], ["e"]], [["n"], ["s"]]][n]);
    },
    getCreatingRange: function(e) {
      var t = vie(e), r = eb(t[0][n], t[1][n]), i = tv(t[0][n], t[1][n]);
      return [r, i];
    },
    updateCoverShape: function(e, t, r, i) {
      var o, a = gie(e, t);
      if (a !== vd && a.getLinearBrushOtherExtent)
        o = a.getLinearBrushOtherExtent(n);
      else {
        var s = e._zr;
        o = [0, [s.getWidth(), s.getHeight()][1 - n]];
      }
      var l = [r, o];
      n && l.reverse(), yie(e, t, l, i);
    },
    updateCommon: PD,
    contain: DD
  };
}
const n$ = RIt;
function xie(n) {
  return n = r$(n), function(e) {
    return Eee(e, n);
  };
}
function Sie(n, e) {
  return n = r$(n), function(t) {
    var r = e ?? t, i = r ? n.width : n.height, o = r ? n.x : n.y;
    return [o, o + (i || 0)];
  };
}
function _ie(n, e, t) {
  var r = r$(n);
  return function(i, o) {
    return r.contain(o[0], o[1]) && !GC(i, e, t);
  };
}
function r$(n) {
  return ot.create(n);
}
var WIt = ["axisLine", "axisTickLabel", "axisName"], GIt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      n.prototype.init.apply(this, arguments), (this._brushController = new n$(r.getZr())).on("brush", _e(this._onBrush, this));
    }, e.prototype.render = function(t, r, i, o) {
      if (!jIt(t, r, o)) {
        this.axisModel = t, this.api = i, this.group.removeAll();
        var a = this._axisGroup;
        if (this._axisGroup = new We(), this.group.add(this._axisGroup), !!t.get("show")) {
          var s = qIt(t, r), l = s.coordinateSystem, u = t.getAreaSelectStyle(), c = u.width, h = t.axis.dim, f = l.getAxisLayout(h), d = re({
            strokeContainThreshold: c
          }, f), p = new Ji(t, d);
          I(WIt, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(d, u, t, s, c, i), Fb(a, this._axisGroup, t);
        }
      }
    }, e.prototype._refreshBrushController = function(t, r, i, o, a, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), h = ot.create({
        x: l[0],
        y: -a / 2,
        width: u,
        height: a
      });
      h.x -= c, h.width += 2 * c, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: t.rotation,
        x: t.position[0],
        y: t.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: xie(h),
        isTargetByCursor: _ie(h, s, o),
        getLinearBrushOtherExtent: Sie(h, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: r,
        removeOnClick: !0
      }).updateCovers(HIt(i));
    }, e.prototype._onBrush = function(t) {
      var r = t.areas, i = this.axisModel, o = i.axis, a = le(r, function(s) {
        return [o.coordToData(s.range[0], !0), o.coordToData(s.range[1], !0)];
      });
      (!i.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: a
      });
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.type = "parallelAxis", e;
  }(Gn)
);
function jIt(n, e, t) {
  return t && t.type === "axisAreaSelect" && e.findComponents({
    mainType: "parallelAxis",
    query: t
  })[0] === n;
}
function HIt(n) {
  var e = n.axis;
  return le(n.activeIntervals, function(t) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)]
    };
  });
}
function qIt(n, e) {
  return e.getComponent("parallel", n.get("parallelIndex"));
}
const YIt = GIt;
var XIt = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function UIt(n) {
  n.registerAction(XIt, function(e, t) {
    t.eachComponent({
      mainType: "parallelAxis",
      query: e
    }, function(r) {
      r.axis.model.setActiveIntervals(e.intervals);
    });
  }), n.registerAction("parallelAxisExpand", function(e, t) {
    t.eachComponent({
      mainType: "parallel",
      query: e
    }, function(r) {
      r.setAxisExpand(e);
    });
  });
}
var KIt = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function Cie(n) {
  n.registerComponentView(gIt), n.registerComponentModel(mIt), n.registerCoordinateSystem("parallel", TIt), n.registerPreprocessor(uIt), n.registerComponentModel(JQ), n.registerComponentView(YIt), ev(n, "parallel", JQ, KIt), UIt(n);
}
function JIt(n) {
  ft(Cie), n.registerChartView(tIt), n.registerSeriesModel(oIt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, lIt);
}
var eRt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return n;
  }()
), tRt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new eRt();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.extent;
      t.moveTo(r.x1, r.y1), t.bezierCurveTo(r.cpx1, r.cpy1, r.cpx2, r.cpy2, r.x2, r.y2), r.orient === "vertical" ? (t.lineTo(r.x2 + i, r.y2), t.bezierCurveTo(r.cpx2 + i, r.cpy2, r.cpx1 + i, r.cpy1, r.x1 + i, r.y1)) : (t.lineTo(r.x2, r.y2 + i), t.bezierCurveTo(r.cpx2, r.cpy2 + i, r.cpx1, r.cpy1 + i, r.x1, r.y1 + i)), t.closePath();
    }, e.prototype.highlight = function() {
      gu(this);
    }, e.prototype.downplay = function() {
      vu(this);
    }, e;
  }(gt)
), nRt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._focusAdjacencyDisabled = !1, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = this, a = t.getGraph(), s = this.group, l = t.layoutInfo, u = l.width, c = l.height, h = t.getData(), f = t.getData("edge"), d = t.get("orient");
      this._model = t, s.removeAll(), s.x = l.x, s.y = l.y, a.eachEdge(function(p) {
        var g = new tRt(), v = He(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = t.seriesIndex, v.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), b = y.get("curveness"), O = p.node1.getLayout(), w = p.node1.getModel(), x = w.get("localX"), S = w.get("localY"), _ = p.node2.getLayout(), C = p.node2.getModel(), A = C.get("localX"), k = C.get("localY"), P = p.getLayout(), L, D, E, M, R, N, $, F;
        g.shape.extent = Math.max(1, P.dy), g.shape.orient = d, d === "vertical" ? (L = (x != null ? x * u : O.x) + P.sy, D = (S != null ? S * c : O.y) + O.dy, E = (A != null ? A * u : _.x) + P.ty, M = k != null ? k * c : _.y, R = L, N = D * (1 - b) + M * b, $ = E, F = D * b + M * (1 - b)) : (L = (x != null ? x * u : O.x) + O.dx, D = (S != null ? S * c : O.y) + P.sy, E = A != null ? A * u : _.x, M = (k != null ? k * c : _.y) + P.ty, R = L * (1 - b) + E * b, N = D, $ = L * b + E * (1 - b), F = M), g.setShape({
          x1: L,
          y1: D,
          x2: E,
          y2: M,
          cpx1: R,
          cpy1: N,
          cpx2: $,
          cpy2: F
        }), g.useStyle(y.getItemStyle()), aZ(g.style, d, p);
        var W = "" + m.get("value"), j = Fr(m, "edgeLabel");
        wi(g, j, {
          labelFetcher: {
            getFormattedLabel: function(ie, ae, ee, ne, ye, te) {
              return t.getFormattedLabel(
                ie,
                ae,
                "edge",
                ne,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Aa(ye, j.normal && j.normal.get("formatter"), W),
                te
              );
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: W
        }), g.setTextConfig({
          position: "inside"
        });
        var Y = m.getModel("emphasis");
        Oi(g, m, "lineStyle", function(ie) {
          var ae = ie.getItemStyle();
          return aZ(ae, d, p), ae;
        }), s.add(g), f.setItemGraphicEl(p.dataIndex, g);
        var X = Y.get("focus");
        Wn(g, X === "adjacency" ? p.getAdjacentDataIndices() : X === "trajectory" ? p.getTrajectoryDataIndices() : X, Y.get("blurScope"), Y.get("disabled"));
      }), a.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), m = v.get("localX"), y = v.get("localY"), b = v.getModel("emphasis"), O = new Lt({
          shape: {
            x: m != null ? m * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        wi(O, Fr(v), {
          labelFetcher: {
            getFormattedLabel: function(x, S) {
              return t.getFormattedLabel(x, S, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), O.disableLabelAnimation = !0, O.setStyle("fill", p.getVisual("color")), O.setStyle("decal", p.getVisual("style").decal), Oi(O, v), s.add(O), h.setItemGraphicEl(p.dataIndex, O), He(O).dataType = "node";
        var w = b.get("focus");
        Wn(O, w === "adjacency" ? p.getAdjacentDataIndices() : w === "trajectory" ? p.getTrajectoryDataIndices() : w, b.get("blurScope"), b.get("disabled"));
      }), h.eachItemGraphicEl(function(p, g) {
        var v = h.getItemModel(g);
        v.get("draggable") && (p.drift = function(m, y) {
          o._focusAdjacencyDisabled = !0, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: t.id,
            dataIndex: h.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          o._focusAdjacencyDisabled = !1;
        }, p.draggable = !0, p.cursor = "move");
      }), !this._data && t.isAnimationEnabled() && s.setClipPath(rRt(s.getBoundingRect(), t, function() {
        s.removeClipPath();
      })), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.type = "sankey", e;
  }(bn)
);
function aZ(n, e, t) {
  switch (n.fill) {
    case "source":
      n.fill = t.node1.getVisual("color"), n.decal = t.node1.getVisual("style").decal;
      break;
    case "target":
      n.fill = t.node2.getVisual("color"), n.decal = t.node2.getVisual("style").decal;
      break;
    case "gradient":
      var r = t.node1.getVisual("color"), i = t.node2.getVisual("color");
      we(r) && we(i) && (n.fill = new zb(0, 0, +(e === "horizontal"), +(e === "vertical"), [{
        color: r,
        offset: 0
      }, {
        color: i,
        offset: 1
      }]));
  }
}
function rRt(n, e, t) {
  var r = new Lt({
    shape: {
      x: n.x - 10,
      y: n.y - 10,
      width: 0,
      height: n.height + 20
    }
  });
  return Cn(r, {
    shape: {
      width: n.width + 20
    }
  }, e, t), r;
}
const iRt = nRt;
var oRt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = t.edges || t.links, o = t.data || t.nodes, a = t.levels;
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < a.length; l++)
        if (a[l].depth != null && a[l].depth >= 0)
          s[a[l].depth] = new mn(a[l], this, r);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      if (o && i) {
        var u = aie(o, i, this, !0, c);
        return u.data;
      }
      function c(h, f) {
        h.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var m = v.depth, y = g.levelModels[m];
            y && (d.parentModel = y);
          }
          return d;
        }), f.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getGraph().getEdgeByIndex(p), m = v.node1.getLayout();
          if (m) {
            var y = m.depth, b = g.levelModels[y];
            b && (d.parentModel = b);
          }
          return d;
        });
      }
    }, e.prototype.setNodePosition = function(t, r) {
      var i = this.option.data || this.option.nodes, o = i[t];
      o.localX = r[0], o.localY = r[1];
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.formatTooltip = function(t, r, i) {
      function o(d) {
        return isNaN(d) || d == null;
      }
      if (i === "edge") {
        var a = this.getDataParams(t, i), s = a.data, l = a.value, u = s.source + " -- " + s.target;
        return Qr("nameValue", {
          name: u,
          value: l,
          noValue: o(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(t), h = c.getLayout().value, f = this.getDataParams(t, i).data.name;
        return Qr("nameValue", {
          name: f != null ? f + "" : null,
          value: h,
          noValue: o(h)
        });
      }
    }, e.prototype.optionUpdated = function() {
    }, e.prototype.getDataParams = function(t, r) {
      var i = n.prototype.getDataParams.call(this, t, r);
      if (i.value == null && r === "node") {
        var o = this.getGraph().getNodeByIndex(t), a = o.getLayout().value;
        i.value = a;
      }
      return i;
    }, e.type = "series.sankey", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, e;
  }(Ln)
);
const aRt = oRt;
function sRt(n, e) {
  n.eachSeriesByType("sankey", function(t) {
    var r = t.get("nodeWidth"), i = t.get("nodeGap"), o = lRt(t, e);
    t.layoutInfo = o;
    var a = o.width, s = o.height, l = t.getGraph(), u = l.nodes, c = l.edges;
    cRt(u);
    var h = en(u, function(g) {
      return g.getLayout().value === 0;
    }), f = h.length !== 0 ? 0 : t.get("layoutIterations"), d = t.get("orient"), p = t.get("nodeAlign");
    uRt(u, c, r, i, a, s, f, d, p);
  });
}
function lRt(n, e) {
  return Cr(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function uRt(n, e, t, r, i, o, a, s, l) {
  hRt(n, e, t, i, o, s, l), gRt(n, e, o, i, r, a, s), _Rt(n, s);
}
function cRt(n) {
  I(n, function(e) {
    var t = Ac(e.outEdges, ZS), r = Ac(e.inEdges, ZS), i = e.getValue() || 0, o = Math.max(t, r, i);
    e.setLayout({
      value: o
    }, !0);
  });
}
function hRt(n, e, t, r, i, o, a) {
  for (var s = [], l = [], u = [], c = [], h = 0, f = 0; f < e.length; f++)
    s[f] = 1;
  for (var f = 0; f < n.length; f++)
    l[f] = n[f].inEdges.length, l[f] === 0 && u.push(n[f]);
  for (var d = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), m = v.depth != null && v.depth >= 0;
      m && v.depth > d && (d = v.depth), g.setLayout({
        depth: m ? v.depth : h
      }, !0), o === "vertical" ? g.setLayout({
        dy: t
      }, !0) : g.setLayout({
        dx: t
      }, !0);
      for (var y = 0; y < g.outEdges.length; y++) {
        var b = g.outEdges[y], O = e.indexOf(b);
        s[O] = 0;
        var w = b.node2, x = n.indexOf(w);
        --l[x] === 0 && c.indexOf(w) < 0 && c.push(w);
      }
    }
    ++h, u = c, c = [];
  }
  for (var f = 0; f < s.length; f++)
    if (s[f] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var S = d > h - 1 ? d : h - 1;
  a && a !== "left" && fRt(n, a, o, S);
  var _ = o === "vertical" ? (i - t) / S : (r - t) / S;
  pRt(n, _, o);
}
function Aie(n) {
  var e = n.hostGraph.data.getRawDataItem(n.dataIndex);
  return e.depth != null && e.depth >= 0;
}
function fRt(n, e, t, r) {
  if (e === "right") {
    for (var i = [], o = n, a = 0; o.length; ) {
      for (var s = 0; s < o.length; s++) {
        var l = o[s];
        l.setLayout({
          skNodeHeight: a
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          i.indexOf(c.node1) < 0 && i.push(c.node1);
        }
      }
      o = i, i = [], ++a;
    }
    I(n, function(h) {
      Aie(h) || h.setLayout({
        depth: Math.max(0, r - h.getLayout().skNodeHeight)
      }, !0);
    });
  } else
    e === "justify" && dRt(n, r);
}
function dRt(n, e) {
  I(n, function(t) {
    !Aie(t) && !t.outEdges.length && t.setLayout({
      depth: e
    }, !0);
  });
}
function pRt(n, e, t) {
  I(n, function(r) {
    var i = r.getLayout().depth * e;
    t === "vertical" ? r.setLayout({
      y: i
    }, !0) : r.setLayout({
      x: i
    }, !0);
  });
}
function gRt(n, e, t, r, i, o, a) {
  var s = vRt(n, a);
  mRt(s, e, t, r, i, a), hk(s, i, t, r, a);
  for (var l = 1; o > 0; o--)
    l *= 0.99, yRt(s, l, a), hk(s, i, t, r, a), SRt(s, l, a), hk(s, i, t, r, a);
}
function vRt(n, e) {
  var t = [], r = e === "vertical" ? "y" : "x", i = IM(n, function(o) {
    return o.getLayout()[r];
  });
  return i.keys.sort(function(o, a) {
    return o - a;
  }), I(i.keys, function(o) {
    t.push(i.buckets.get(o));
  }), t;
}
function mRt(n, e, t, r, i, o) {
  var a = 1 / 0;
  I(n, function(s) {
    var l = s.length, u = 0;
    I(s, function(h) {
      u += h.getLayout().value;
    });
    var c = o === "vertical" ? (r - (l - 1) * i) / u : (t - (l - 1) * i) / u;
    c < a && (a = c);
  }), I(n, function(s) {
    I(s, function(l, u) {
      var c = l.getLayout().value * a;
      o === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), I(e, function(s) {
    var l = +s.getValue() * a;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function hk(n, e, t, r, i) {
  var o = i === "vertical" ? "x" : "y";
  I(n, function(a) {
    a.sort(function(g, v) {
      return g.getLayout()[o] - v.getLayout()[o];
    });
    for (var s, l, u, c = 0, h = a.length, f = i === "vertical" ? "dx" : "dy", d = 0; d < h; d++)
      l = a[d], u = c - l.getLayout()[o], u > 0 && (s = l.getLayout()[o] + u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[o] + l.getLayout()[f] + e;
    var p = i === "vertical" ? r : t;
    if (u = c - e - p, u > 0) {
      s = l.getLayout()[o] - u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var d = h - 2; d >= 0; --d)
        l = a[d], u = l.getLayout()[o] + l.getLayout()[f] + e - c, u > 0 && (s = l.getLayout()[o] - u, i === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[o];
    }
  });
}
function yRt(n, e, t) {
  I(n.slice().reverse(), function(r) {
    I(r, function(i) {
      if (i.outEdges.length) {
        var o = Ac(i.outEdges, bRt, t) / Ac(i.outEdges, ZS);
        if (isNaN(o)) {
          var a = i.outEdges.length;
          o = a ? Ac(i.outEdges, ORt, t) / a : 0;
        }
        if (t === "vertical") {
          var s = i.getLayout().x + (o - Jc(i, t)) * e;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (o - Jc(i, t)) * e;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function bRt(n, e) {
  return Jc(n.node2, e) * n.getValue();
}
function ORt(n, e) {
  return Jc(n.node2, e);
}
function wRt(n, e) {
  return Jc(n.node1, e) * n.getValue();
}
function xRt(n, e) {
  return Jc(n.node1, e);
}
function Jc(n, e) {
  return e === "vertical" ? n.getLayout().x + n.getLayout().dx / 2 : n.getLayout().y + n.getLayout().dy / 2;
}
function ZS(n) {
  return n.getValue();
}
function Ac(n, e, t) {
  for (var r = 0, i = n.length, o = -1; ++o < i; ) {
    var a = +e(n[o], t);
    isNaN(a) || (r += a);
  }
  return r;
}
function SRt(n, e, t) {
  I(n, function(r) {
    I(r, function(i) {
      if (i.inEdges.length) {
        var o = Ac(i.inEdges, wRt, t) / Ac(i.inEdges, ZS);
        if (isNaN(o)) {
          var a = i.inEdges.length;
          o = a ? Ac(i.inEdges, xRt, t) / a : 0;
        }
        if (t === "vertical") {
          var s = i.getLayout().x + (o - Jc(i, t)) * e;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (o - Jc(i, t)) * e;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function _Rt(n, e) {
  var t = e === "vertical" ? "x" : "y";
  I(n, function(r) {
    r.outEdges.sort(function(i, o) {
      return i.node2.getLayout()[t] - o.node2.getLayout()[t];
    }), r.inEdges.sort(function(i, o) {
      return i.node1.getLayout()[t] - o.node1.getLayout()[t];
    });
  }), I(n, function(r) {
    var i = 0, o = 0;
    I(r.outEdges, function(a) {
      a.setLayout({
        sy: i
      }, !0), i += a.getLayout().dy;
    }), I(r.inEdges, function(a) {
      a.setLayout({
        ty: o
      }, !0), o += a.getLayout().dy;
    });
  });
}
function CRt(n) {
  n.eachSeriesByType("sankey", function(e) {
    var t = e.getGraph(), r = t.nodes, i = t.edges;
    if (r.length) {
      var o = 1 / 0, a = -1 / 0;
      I(r, function(s) {
        var l = s.getLayout().value;
        l < o && (o = l), l > a && (a = l);
      }), I(r, function(s) {
        var l = new mi({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [o, a],
          visual: e.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    i.length && I(i, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function ARt(n) {
  n.registerChartView(iRt), n.registerSeriesModel(aRt), n.registerLayout(sRt), n.registerVisual(CRt), n.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: e
    }, function(r) {
      r.setNodePosition(e.dataIndex, [e.localX, e.localY]);
    });
  });
}
var Tie = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getInitialData = function(e, t) {
      var r, i = t.getComponent("xAxis", this.get("xAxisIndex")), o = t.getComponent("yAxis", this.get("yAxisIndex")), a = i.get("type"), s = o.get("type"), l;
      a === "category" ? (e.layout = "horizontal", r = i.getOrdinalMeta(), l = !0) : s === "category" ? (e.layout = "vertical", r = o.getOrdinalMeta(), l = !0) : e.layout = e.layout || "horizontal";
      var u = ["x", "y"], c = e.layout === "horizontal" ? 0 : 1, h = this._baseAxisDim = u[c], f = u[1 - c], d = [i, o], p = d[c].get("type"), g = d[1 - c].get("type"), v = e.data;
      if (v && l) {
        var m = [];
        I(v, function(O, w) {
          var x;
          se(O) ? (x = O.slice(), O.unshift(w)) : se(O.value) ? (x = re({}, O), x.value = x.value.slice(), O.value.unshift(w)) : x = O, m.push(x);
        }), e.data = m;
      }
      var y = this.defaultValueDimensions, b = [{
        name: h,
        type: DS(p),
        ordinalMeta: r,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: f,
        type: DS(g),
        dimsDef: y.slice()
      }];
      return Gv(this, {
        coordDimensions: b,
        dimensionsCount: y.length + 1,
        encodeDefaulter: Je(tte, b, this)
      });
    }, n.prototype.getBaseAxis = function() {
      var e = this._baseAxisDim;
      return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis;
    }, n;
  }()
), kie = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], t.visualDrawType = "stroke", t;
    }
    return e.type = "series.boxplot", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, e;
  }(Ln)
);
mr(kie, Tie, !0);
const TRt = kie;
var kRt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = t.getData(), a = this.group, s = this._data;
      this._data || a.removeAll();
      var l = t.get("layout") === "horizontal" ? 1 : 0;
      o.diff(s).add(function(u) {
        if (o.hasValue(u)) {
          var c = o.getItemLayout(u), h = sZ(c, o, u, l, !0);
          o.setItemGraphicEl(u, h), a.add(h);
        }
      }).update(function(u, c) {
        var h = s.getItemGraphicEl(c);
        if (!o.hasValue(u)) {
          a.remove(h);
          return;
        }
        var f = o.getItemLayout(u);
        h ? (ms(h), Pie(f, h, o, u)) : h = sZ(f, o, u, l), a.add(h), o.setItemGraphicEl(u, h);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && a.remove(c);
      }).execute(), this._data = o;
    }, e.prototype.remove = function(t) {
      var r = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(o) {
        o && r.remove(o);
      });
    }, e.type = "boxplot", e;
  }(bn)
), PRt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), ERt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "boxplotBoxPath", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new PRt();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, o = 0;
      for (t.moveTo(i[o][0], i[o][1]), o++; o < 4; o++)
        t.lineTo(i[o][0], i[o][1]);
      for (t.closePath(); o < i.length; o++)
        t.moveTo(i[o][0], i[o][1]), o++, t.lineTo(i[o][0], i[o][1]);
    }, e;
  }(gt)
);
function sZ(n, e, t, r, i) {
  var o = n.ends, a = new ERt({
    shape: {
      points: i ? MRt(o, r, n) : o
    }
  });
  return Pie(n, a, e, t, i), a;
}
function Pie(n, e, t, r, i) {
  var o = t.hostModel, a = Dd[i ? "initProps" : "updateProps"];
  a(e, {
    shape: {
      points: n.ends
    }
  }, o, r), e.useStyle(t.getItemVisual(r, "style")), e.style.strokeNoScale = !0, e.z2 = 100;
  var s = t.getItemModel(r), l = s.getModel("emphasis");
  Oi(e, s), Wn(e, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function MRt(n, e, t) {
  return le(n, function(r) {
    return r = r.slice(), r[e] = t.initBaseline, r;
  });
}
const DRt = kRt;
var Wy = I;
function LRt(n) {
  var e = IRt(n);
  Wy(e, function(t) {
    var r = t.seriesModels;
    r.length && (RRt(t), Wy(r, function(i, o) {
      NRt(i, t.boxOffsetList[o], t.boxWidthList[o]);
    }));
  });
}
function IRt(n) {
  var e = [], t = [];
  return n.eachSeriesByType("boxplot", function(r) {
    var i = r.getBaseAxis(), o = ct(t, i);
    o < 0 && (o = t.length, t[o] = i, e[o] = {
      axis: i,
      seriesModels: []
    }), e[o].seriesModels.push(r);
  }), e;
}
function RRt(n) {
  var e = n.axis, t = n.seriesModels, r = t.length, i = n.boxWidthList = [], o = n.boxOffsetList = [], a = [], s;
  if (e.type === "category")
    s = e.getBandWidth();
  else {
    var l = 0;
    Wy(t, function(p) {
      l = Math.max(l, p.getData().count());
    });
    var u = e.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  Wy(t, function(p) {
    var g = p.get("boxWidth");
    se(g) || (g = [g, g]), a.push([be(g[0], s) || 0, be(g[1], s) || 0]);
  });
  var c = s * 0.8 - 2, h = c / r * 0.3, f = (c - h * (r - 1)) / r, d = f / 2 - c / 2;
  Wy(t, function(p, g) {
    o.push(d), d += h + f, i.push(Math.min(Math.max(f, a[g][0]), a[g][1]));
  });
}
function NRt(n, e, t) {
  var r = n.coordinateSystem, i = n.getData(), o = t / 2, a = n.get("layout") === "horizontal" ? 0 : 1, s = 1 - a, l = ["x", "y"], u = i.mapDimension(l[a]), c = i.mapDimensionsAll(l[s]);
  if (u == null || c.length < 5)
    return;
  for (var h = 0; h < i.count(); h++) {
    var f = i.get(u, h), d = b(f, c[2], h), p = b(f, c[0], h), g = b(f, c[1], h), v = b(f, c[3], h), m = b(f, c[4], h), y = [];
    O(y, g, !1), O(y, v, !0), y.push(p, g, m, v), w(y, p), w(y, m), w(y, d), i.setItemLayout(h, {
      initBaseline: d[s],
      ends: y
    });
  }
  function b(x, S, _) {
    var C = i.get(S, _), A = [];
    A[a] = x, A[s] = C;
    var k;
    return isNaN(x) || isNaN(C) ? k = [NaN, NaN] : (k = r.dataToPoint(A), k[a] += e), k;
  }
  function O(x, S, _) {
    var C = S.slice(), A = S.slice();
    C[a] += o, A[a] -= o, _ ? x.push(C, A) : x.push(A, C);
  }
  function w(x, S) {
    var _ = S.slice(), C = S.slice();
    _[a] -= o, C[a] += o, x.push(_, C);
  }
}
function $Rt(n, e) {
  e = e || {};
  for (var t = [], r = [], i = e.boundIQR, o = i === "none" || i === 0, a = 0; a < n.length; a++) {
    var s = wa(n[a].slice()), l = BA(s, 0.25), u = BA(s, 0.5), c = BA(s, 0.75), h = s[0], f = s[s.length - 1], d = (i ?? 1.5) * (c - l), p = o ? h : Math.max(h, l - d), g = o ? f : Math.min(f, c + d), v = e.itemNameFormatter, m = Le(v) ? v({
      value: a
    }) : we(v) ? v.replace("{value}", a + "") : a + "";
    t.push([m, p, l, u, c, g]);
    for (var y = 0; y < s.length; y++) {
      var b = s[y];
      if (b < p || b > g) {
        var O = [m, b];
        r.push(O);
      }
    }
  }
  return {
    boxData: t,
    outliers: r
  };
}
var BRt = {
  type: "echarts:boxplot",
  transform: function(e) {
    var t = e.upstream;
    if (t.sourceFormat !== $i) {
      var r = "";
      process.env.NODE_ENV !== "production" && (r = to("source data is not applicable for this boxplot transform. Expect number[][].")), Gt(r);
    }
    var i = $Rt(t.getRawData(), e.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: i.boxData
    }, {
      data: i.outliers
    }];
  }
};
function VRt(n) {
  n.registerSeriesModel(TRt), n.registerChartView(DRt), n.registerLayout(LRt), n.registerTransform(BRt);
}
var zRt = ["color", "borderColor"], FRt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this._clear(), this._updateDrawMode(t);
    }, e.prototype.incrementalRender = function(t, r, i, o) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, r) : this._incrementalRenderNormal(t, r);
    }, e.prototype.eachRendered = function(t) {
      dh(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var r = t.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, e.prototype._renderNormal = function(t) {
      var r = t.getData(), i = this._data, o = this.group, a = r.getLayout("isSimpleBox"), s = t.get("clip", !0), l = t.coordinateSystem, u = l.getArea && l.getArea();
      this._data || o.removeAll(), r.diff(i).add(function(c) {
        if (r.hasValue(c)) {
          var h = r.getItemLayout(c);
          if (s && lZ(u, h))
            return;
          var f = fk(h, c, !0);
          Cn(f, {
            shape: {
              points: h.ends
            }
          }, t, c), dk(f, r, c, a), o.add(f), r.setItemGraphicEl(c, f);
        }
      }).update(function(c, h) {
        var f = i.getItemGraphicEl(h);
        if (!r.hasValue(c)) {
          o.remove(f);
          return;
        }
        var d = r.getItemLayout(c);
        if (s && lZ(u, d)) {
          o.remove(f);
          return;
        }
        f ? (Vt(f, {
          shape: {
            points: d.ends
          }
        }, t, c), ms(f)) : f = fk(d), dk(f, r, c, a), o.add(f), r.setItemGraphicEl(c, f);
      }).remove(function(c) {
        var h = i.getItemGraphicEl(c);
        h && o.remove(h);
      }).execute(), this._data = r;
    }, e.prototype._renderLarge = function(t) {
      this._clear(), uZ(t, this.group);
      var r = t.get("clip", !0) ? Yb(t.coordinateSystem, !1, t) : null;
      r ? this.group.setClipPath(r) : this.group.removeClipPath();
    }, e.prototype._incrementalRenderNormal = function(t, r) {
      for (var i = r.getData(), o = i.getLayout("isSimpleBox"), a; (a = t.next()) != null; ) {
        var s = i.getItemLayout(a), l = fk(s);
        dk(l, i, a, o), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, e.prototype._incrementalRenderLarge = function(t, r) {
      uZ(r, this.group, this._progressiveEls, !0);
    }, e.prototype.remove = function(t) {
      this._clear();
    }, e.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "candlestick", e;
  }(bn)
), QRt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), ZRt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "normalCandlestickBox", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new QRt();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points;
      this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1]));
    }, e;
  }(gt)
);
function fk(n, e, t) {
  var r = n.ends;
  return new ZRt({
    shape: {
      points: t ? WRt(r, n) : r
    },
    z2: 100
  });
}
function lZ(n, e) {
  for (var t = !0, r = 0; r < e.ends.length; r++)
    if (n.contain(e.ends[r][0], e.ends[r][1])) {
      t = !1;
      break;
    }
  return t;
}
function dk(n, e, t, r) {
  var i = e.getItemModel(t);
  n.useStyle(e.getItemVisual(t, "style")), n.style.strokeNoScale = !0, n.__simpleBox = r, Oi(n, i);
}
function WRt(n, e) {
  return le(n, function(t) {
    return t = t.slice(), t[1] = e.initBaseline, t;
  });
}
var GRt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), pk = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "largeCandlestickBox", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new GRt();
    }, e.prototype.buildPath = function(t, r) {
      for (var i = r.points, o = 0; o < i.length; )
        if (this.__sign === i[o++]) {
          var a = i[o++];
          t.moveTo(a, i[o++]), t.lineTo(a, i[o++]);
        } else
          o += 3;
    }, e;
  }(gt)
);
function uZ(n, e, t, r) {
  var i = n.getData(), o = i.getLayout("largePoints"), a = new pk({
    shape: {
      points: o
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  e.add(a);
  var s = new pk({
    shape: {
      points: o
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  e.add(s);
  var l = new pk({
    shape: {
      points: o
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  e.add(l), gk(1, a, n), gk(-1, s, n), gk(0, l, n), r && (a.incremental = !0, s.incremental = !0), t && t.push(a, s);
}
function gk(n, e, t, r) {
  var i = t.get(["itemStyle", n > 0 ? "borderColor" : "borderColor0"]) || t.get(["itemStyle", n > 0 ? "color" : "color0"]);
  n === 0 && (i = t.get(["itemStyle", "borderColorDoji"]));
  var o = t.getModel("itemStyle").getItemStyle(zRt);
  e.useStyle(o), e.style.fill = null, e.style.stroke = i;
}
const jRt = FRt;
var Eie = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], t;
    }
    return e.prototype.getShadowDim = function() {
      return "open";
    }, e.prototype.brushSelector = function(t, r, i) {
      var o = r.getItemLayout(t);
      return o && i.rect(o.brushRect);
    }, e.type = "series.candlestick", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, e;
  }(Ln)
);
mr(Eie, Tie, !0);
const HRt = Eie;
function qRt(n) {
  !n || !se(n.series) || I(n.series, function(e) {
    Ne(e) && e.type === "k" && (e.type = "candlestick");
  });
}
var YRt = ["itemStyle", "borderColor"], XRt = ["itemStyle", "borderColor0"], URt = ["itemStyle", "borderColorDoji"], KRt = ["itemStyle", "color"], JRt = ["itemStyle", "color0"], eNt = {
  seriesType: "candlestick",
  plan: Qv(),
  // For legend.
  performRawSeries: !0,
  reset: function(n, e) {
    function t(o, a) {
      return a.get(o > 0 ? KRt : JRt);
    }
    function r(o, a) {
      return a.get(o === 0 ? URt : o > 0 ? YRt : XRt);
    }
    if (!e.isSeriesFiltered(n)) {
      var i = n.pipelineContext.large;
      return !i && {
        progress: function(o, a) {
          for (var s; (s = o.next()) != null; ) {
            var l = a.getItemModel(s), u = a.getItemLayout(s).sign, c = l.getItemStyle();
            c.fill = t(u, l), c.stroke = r(u, l) || c.fill;
            var h = a.ensureUniqueItemVisual(s, "style");
            re(h, c);
          }
        }
      };
    }
  }
};
const tNt = eNt;
var nNt = {
  seriesType: "candlestick",
  plan: Qv(),
  reset: function(n) {
    var e = n.coordinateSystem, t = n.getData(), r = rNt(n, t), i = 0, o = 1, a = ["x", "y"], s = t.getDimensionIndex(t.mapDimension(a[i])), l = le(t.mapDimensionsAll(a[o]), t.getDimensionIndex, t), u = l[0], c = l[1], h = l[2], f = l[3];
    if (t.setLayout({
      candleWidth: r,
      // The value is experimented visually.
      isSimpleBox: r <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: n.pipelineContext.large ? p : d
    };
    function d(g, v) {
      for (var m, y = v.getStore(); (m = g.next()) != null; ) {
        var b = y.get(s, m), O = y.get(u, m), w = y.get(c, m), x = y.get(h, m), S = y.get(f, m), _ = Math.min(O, w), C = Math.max(O, w), A = R(_, b), k = R(C, b), P = R(x, b), L = R(S, b), D = [];
        N(D, k, 0), N(D, A, 1), D.push(F(L), F(k), F(P), F(A));
        var E = v.getItemModel(m), M = !!E.get(["itemStyle", "borderColorDoji"]);
        v.setItemLayout(m, {
          sign: cZ(y, m, O, w, c, M),
          initBaseline: O > w ? k[o] : A[o],
          ends: D,
          brushRect: $(x, S, b)
        });
      }
      function R(W, j) {
        var Y = [];
        return Y[i] = j, Y[o] = W, isNaN(j) || isNaN(W) ? [NaN, NaN] : e.dataToPoint(Y);
      }
      function N(W, j, Y) {
        var X = j.slice(), ie = j.slice();
        X[i] = Hw(X[i] + r / 2, 1, !1), ie[i] = Hw(ie[i] - r / 2, 1, !0), Y ? W.push(X, ie) : W.push(ie, X);
      }
      function $(W, j, Y) {
        var X = R(W, Y), ie = R(j, Y);
        return X[i] -= r / 2, ie[i] -= r / 2, {
          x: X[0],
          y: X[1],
          width: r,
          height: ie[1] - X[1]
        };
      }
      function F(W) {
        return W[i] = Hw(W[i], 1), W;
      }
    }
    function p(g, v) {
      for (var m = ol(g.count * 4), y = 0, b, O = [], w = [], x, S = v.getStore(), _ = !!n.get(["itemStyle", "borderColorDoji"]); (x = g.next()) != null; ) {
        var C = S.get(s, x), A = S.get(u, x), k = S.get(c, x), P = S.get(h, x), L = S.get(f, x);
        if (isNaN(C) || isNaN(P) || isNaN(L)) {
          m[y++] = NaN, y += 3;
          continue;
        }
        m[y++] = cZ(S, x, A, k, c, _), O[i] = C, O[o] = P, b = e.dataToPoint(O, null, w), m[y++] = b ? b[0] : NaN, m[y++] = b ? b[1] : NaN, O[o] = L, b = e.dataToPoint(O, null, w), m[y++] = b ? b[1] : NaN;
      }
      v.setLayout("largePoints", m);
    }
  }
};
function cZ(n, e, t, r, i, o) {
  var a;
  return t > r ? a = -1 : t < r ? a = 1 : a = o ? 0 : e > 0 ? n.get(i, e - 1) <= r ? 1 : -1 : 1, a;
}
function rNt(n, e) {
  var t = n.getBaseAxis(), r, i = t.type === "category" ? t.getBandWidth() : (r = t.getExtent(), Math.abs(r[1] - r[0]) / e.count()), o = be(qe(n.get("barMaxWidth"), i), i), a = be(qe(n.get("barMinWidth"), 1), i), s = n.get("barWidth");
  return s != null ? be(s, i) : Math.max(Math.min(i / 2, o), a);
}
const iNt = nNt;
function oNt(n) {
  n.registerChartView(jRt), n.registerSeriesModel(HRt), n.registerPreprocessor(qRt), n.registerVisual(tNt), n.registerLayout(iNt);
}
function hZ(n, e) {
  var t = e.rippleEffectColor || e.color;
  n.eachChild(function(r) {
    r.attr({
      z: e.z,
      zlevel: e.zlevel,
      style: {
        stroke: e.brushType === "stroke" ? t : null,
        fill: e.brushType === "fill" ? t : null
      }
    });
  });
}
var aNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r) {
      var i = n.call(this) || this, o = new Hb(t, r), a = new We();
      return i.add(o), i.add(a), i.updateData(t, r), i;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(t) {
      for (var r = t.symbolType, i = t.color, o = t.rippleNumber, a = this.childAt(1), s = 0; s < o; s++) {
        var l = vr(r, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / o * t.period + t.effectOffset;
        l.animate("", !0).when(t.period, {
          scaleX: t.rippleScale / 2,
          scaleY: t.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(t.period, {
          opacity: 0
        }).delay(u).start(), a.add(l);
      }
      hZ(a, t);
    }, e.prototype.updateEffectAnimation = function(t) {
      for (var r = this._effectCfg, i = this.childAt(1), o = ["symbolType", "period", "rippleScale", "rippleNumber"], a = 0; a < o.length; a++) {
        var s = o[a];
        if (r[s] !== t[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(t);
          return;
        }
      }
      hZ(i, t);
    }, e.prototype.highlight = function() {
      gu(this);
    }, e.prototype.downplay = function() {
      vu(this);
    }, e.prototype.getSymbolType = function() {
      var t = this.childAt(0);
      return t && t.getSymbolType();
    }, e.prototype.updateData = function(t, r) {
      var i = this, o = t.hostModel;
      this.childAt(0).updateData(t, r);
      var a = this.childAt(1), s = t.getItemModel(r), l = t.getItemVisual(r, "symbol"), u = Wv(t.getItemVisual(r, "symbolSize")), c = t.getItemVisual(r, "style"), h = c && c.fill, f = s.getModel("emphasis");
      a.setScale(u), a.traverse(function(v) {
        v.setStyle("fill", h);
      });
      var d = Id(t.getItemVisual(r, "symbolOffset"), u);
      d && (a.x = d[0], a.y = d[1]);
      var p = t.getItemVisual(r, "symbolRotate");
      a.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = o.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = r / t.count(), g.z = o.getShallow("z") || 0, g.zlevel = o.getShallow("zlevel") || 0, g.symbolType = l, g.color = h, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, Wn(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
    }, e.prototype.fadeOut = function(t) {
      t && t();
    }, e;
  }(We)
);
const sNt = aNt;
var lNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new qb(sNt);
    }, e.prototype.render = function(t, r, i) {
      var o = t.getData(), a = this._symbolDraw;
      a.updateData(o, {
        clipShape: this._getClipShape(t)
      }), this.group.add(a.group);
    }, e.prototype._getClipShape = function(t) {
      var r = t.coordinateSystem, i = r && r.getArea && r.getArea();
      return t.get("clip", !0) ? i : null;
    }, e.prototype.updateTransform = function(t, r, i) {
      var o = t.getData();
      this.group.dirty();
      var a = Xb("").reset(t, r, i);
      a.progress && a.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(t) {
      var r = t.coordinateSystem;
      r && r.getRoamTransform && (this.group.transform = awt(r.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(t, r) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, e.type = "effectScatter", e;
  }(bn)
);
const uNt = lNt;
var cNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return ku(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.point(r.getItemLayout(t));
    }, e.type = "series.effectScatter", e.dependencies = ["grid", "polar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      // itemStyle: {
      //     opacity: 1
      // }
    }, e;
  }(Ln)
);
const hNt = cNt;
function fNt(n) {
  n.registerChartView(uNt), n.registerSeriesModel(hNt), n.registerLayout(Xb("effectScatter"));
}
var dNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this) || this;
      return o.add(o.createLine(t, r, i)), o._updateEffectSymbol(t, r), o;
    }
    return e.prototype.createLine = function(t, r, i) {
      return new YN(t, r, i);
    }, e.prototype._updateEffectSymbol = function(t, r) {
      var i = t.getItemModel(r), o = i.getModel("effect"), a = o.get("symbolSize"), s = o.get("symbol");
      se(a) || (a = [a, a]);
      var l = t.getItemVisual(r, "style"), u = o.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = vr(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(o.getItemStyle(["color"])), c.scaleX = a[0], c.scaleY = a[1], c.setColor(u), this._symbolType = s, this._symbolScale = a, this._updateEffectAnimation(t, o, r));
    }, e.prototype._updateEffectAnimation = function(t, r, i) {
      var o = this.childAt(1);
      if (o) {
        var a = t.getItemLayout(i), s = r.get("period") * 1e3, l = r.get("loop"), u = r.get("roundTrip"), c = r.get("constantSpeed"), h = ur(r.get("delay"), function(d) {
          return d / t.count() * s / 3;
        });
        if (o.ignore = !0, this._updateAnimationPoints(o, a), c > 0 && (s = this._getLineLength(o) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          o.stopAnimation();
          var f = void 0;
          Le(h) ? f = h(i) : f = h, o.__t > 0 && (f = -s * o.__t), this._animateSymbol(o, s, f, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(t, r, i, o, a) {
      if (r > 0) {
        t.__t = 0;
        var s = this, l = t.animate("", o).when(a ? r * 2 : r, {
          __t: a ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(t);
        });
        o || l.done(function() {
          s.remove(t);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(t) {
      return fc(t.__p1, t.__cp1) + fc(t.__cp1, t.__p2);
    }, e.prototype._updateAnimationPoints = function(t, r) {
      t.__p1 = r[0], t.__p2 = r[1], t.__cp1 = r[2] || [(r[0][0] + r[1][0]) / 2, (r[0][1] + r[1][1]) / 2];
    }, e.prototype.updateData = function(t, r, i) {
      this.childAt(0).updateData(t, r, i), this._updateEffectSymbol(t, r);
    }, e.prototype._updateSymbolPosition = function(t) {
      var r = t.__p1, i = t.__p2, o = t.__cp1, a = t.__t < 1 ? t.__t : 2 - t.__t, s = [t.x, t.y], l = s.slice(), u = jr, c = yM;
      s[0] = u(r[0], o[0], i[0], a), s[1] = u(r[1], o[1], i[1], a);
      var h = t.__t < 1 ? c(r[0], o[0], i[0], a) : c(i[0], o[0], r[0], 1 - a), f = t.__t < 1 ? c(r[1], o[1], i[1], a) : c(i[1], o[1], r[1], 1 - a);
      t.rotation = -Math.atan2(f, h) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = fc(l, s) * 1.05, a === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * fc(r, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1];
    }, e.prototype.updateLayout = function(t, r) {
      this.childAt(0).updateLayout(t, r);
      var i = t.getItemModel(r).getModel("effect");
      this._updateEffectAnimation(t, i, r);
    }, e;
  }(We)
);
const Mie = dNt;
var pNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i) {
      var o = n.call(this) || this;
      return o._createPolyline(t, r, i), o;
    }
    return e.prototype._createPolyline = function(t, r, i) {
      var o = t.getItemLayout(r), a = new io({
        shape: {
          points: o
        }
      });
      this.add(a), this._updateCommonStl(t, r, i);
    }, e.prototype.updateData = function(t, r, i) {
      var o = t.hostModel, a = this.childAt(0), s = {
        shape: {
          points: t.getItemLayout(r)
        }
      };
      Vt(a, s, o, r), this._updateCommonStl(t, r, i);
    }, e.prototype._updateCommonStl = function(t, r, i) {
      var o = this.childAt(0), a = t.getItemModel(r), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || t.hasItemOption) {
        var h = a.getModel("emphasis");
        s = h.getModel("lineStyle").getLineStyle(), c = h.get("disabled"), l = h.get("focus"), u = h.get("blurScope");
      }
      o.useStyle(t.getItemVisual(r, "style")), o.style.fill = null, o.style.strokeNoScale = !0;
      var f = o.ensureState("emphasis");
      f.style = s, Wn(this, l, u, c);
    }, e.prototype.updateLayout = function(t, r) {
      var i = this.childAt(0);
      i.setShape("points", t.getItemLayout(r));
    }, e;
  }(We)
);
const Die = pNt;
var gNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t._lastFrame = 0, t._lastFramePercent = 0, t;
    }
    return e.prototype.createLine = function(t, r, i) {
      return new Die(t, r, i);
    }, e.prototype._updateAnimationPoints = function(t, r) {
      this._points = r;
      for (var i = [0], o = 0, a = 1; a < r.length; a++) {
        var s = r[a - 1], l = r[a];
        o += fc(s, l), i.push(o);
      }
      if (o === 0) {
        this._length = 0;
        return;
      }
      for (var a = 0; a < i.length; a++)
        i[a] /= o;
      this._offsets = i, this._length = o;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(t) {
      var r = t.__t < 1 ? t.__t : 2 - t.__t, i = this._points, o = this._offsets, a = i.length;
      if (o) {
        var s = this._lastFrame, l;
        if (r < this._lastFramePercent) {
          var u = Math.min(s + 1, a - 1);
          for (l = u; l >= 0 && !(o[l] <= r); l--)
            ;
          l = Math.min(l, a - 2);
        } else {
          for (l = s; l < a && !(o[l] > r); l++)
            ;
          l = Math.min(l - 1, a - 2);
        }
        var c = (r - o[l]) / (o[l + 1] - o[l]), h = i[l], f = i[l + 1];
        t.x = h[0] * (1 - c) + c * f[0], t.y = h[1] * (1 - c) + c * f[1];
        var d = t.__t < 1 ? f[0] - h[0] : h[0] - f[0], p = t.__t < 1 ? f[1] - h[1] : h[1] - f[1];
        t.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = r, t.ignore = !1;
      }
    }, e;
  }(Mie)
);
const vNt = gNt;
var mNt = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return n;
  }()
), yNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new mNt();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.segs, o = r.curveness, a;
      if (r.polyline)
        for (a = this._off; a < i.length; ) {
          var s = i[a++];
          if (s > 0) {
            t.moveTo(i[a++], i[a++]);
            for (var l = 1; l < s; l++)
              t.lineTo(i[a++], i[a++]);
          }
        }
      else
        for (a = this._off; a < i.length; ) {
          var u = i[a++], c = i[a++], h = i[a++], f = i[a++];
          if (t.moveTo(u, c), o > 0) {
            var d = (u + h) / 2 - (c - f) * o, p = (c + f) / 2 - (h - u) * o;
            t.quadraticCurveTo(d, p, h, f);
          } else
            t.lineTo(h, f);
        }
      this.incremental && (this._off = a, this.notClear = !0);
    }, e.prototype.findDataIndex = function(t, r) {
      var i = this.shape, o = i.segs, a = i.curveness, s = this.style.lineWidth;
      if (i.polyline)
        for (var l = 0, u = 0; u < o.length; ) {
          var c = o[u++];
          if (c > 0)
            for (var h = o[u++], f = o[u++], d = 1; d < c; d++) {
              var p = o[u++], g = o[u++];
              if (tc(h, f, p, g, s, t, r))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < o.length; ) {
          var h = o[u++], f = o[u++], p = o[u++], g = o[u++];
          if (a > 0) {
            var v = (h + p) / 2 - (f - g) * a, m = (f + g) / 2 - (p - h) * a;
            if (jJ(h, f, v, m, p, g, s, t, r))
              return l;
          } else if (tc(h, f, p, g, s, t, r))
            return l;
          l++;
        }
      return -1;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), o = this.getBoundingRect();
      if (t = i[0], r = i[1], o.contain(t, r)) {
        var a = this.hoverDataIdx = this.findDataIndex(t, r);
        return a >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var r = this.shape, i = r.segs, o = 1 / 0, a = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], h = i[u++];
          o = Math.min(c, o), s = Math.max(c, s), a = Math.min(h, a), l = Math.max(h, l);
        }
        t = this._rect = new ot(o, a, s, l);
      }
      return t;
    }, e;
  }(gt)
), bNt = (
  /** @class */
  function() {
    function n() {
      this.group = new We();
    }
    return n.prototype.updateData = function(e) {
      this._clear();
      var t = this._create();
      t.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(t, e);
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, n.prototype.incrementalUpdate = function(e, t) {
      var r = this._newAdded[0], i = t.getLayout("linesPoints"), o = r && r.shape.segs;
      if (o && o.length < 2e4) {
        var a = o.length, s = new Float32Array(a + i.length);
        s.set(o), s.set(i, a), r.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: i
        }), this._setCommon(l, t), l.__startIndex = e.start;
      }
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, n.prototype._create = function() {
      var e = new yNt({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, n.prototype._setCommon = function(e, t, r) {
      var i = t.hostModel;
      e.setShape({
        polyline: i.get("polyline"),
        curveness: i.get(["lineStyle", "curveness"])
      }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = !0;
      var o = t.getVisual("style");
      o && o.stroke && e.setStyle("stroke", o.stroke), e.setStyle("fill", null);
      var a = He(e);
      a.seriesIndex = i.seriesIndex, e.on("mousemove", function(s) {
        a.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (a.dataIndex = l + e.__startIndex);
      });
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }()
), ONt = {
  seriesType: "lines",
  plan: Qv(),
  reset: function(n) {
    var e = n.coordinateSystem;
    if (!e) {
      process.env.NODE_ENV !== "production" && bi("The lines series must have a coordinate system.");
      return;
    }
    var t = n.get("polyline"), r = n.pipelineContext.large;
    return {
      progress: function(i, o) {
        var a = [];
        if (r) {
          var s = void 0, l = i.end - i.start;
          if (t) {
            for (var u = 0, c = i.start; c < i.end; c++)
              u += n.getLineCoordsCount(c);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var h = 0, f = [], c = i.start; c < i.end; c++) {
            var d = n.getLineCoords(c, a);
            t && (s[h++] = d);
            for (var p = 0; p < d; p++)
              f = e.dataToPoint(a[p], !1, f), s[h++] = f[0], s[h++] = f[1];
          }
          o.setLayout("linesPoints", s);
        } else
          for (var c = i.start; c < i.end; c++) {
            var g = o.getItemModel(c), d = n.getLineCoords(c, a), v = [];
            if (t)
              for (var m = 0; m < d; m++)
                v.push(e.dataToPoint(a[m]));
            else {
              v[0] = e.dataToPoint(a[0]), v[1] = e.dataToPoint(a[1]);
              var y = g.get(["lineStyle", "curveness"]);
              +y && (v[2] = [(v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y, (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y]);
            }
            o.setItemLayout(c, v);
          }
      }
    };
  }
};
const Lie = ONt;
var wNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = t.getData(), a = this._updateLineDraw(o, t), s = t.get("zlevel"), l = t.get(["effect", "trailLength"]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(t) && l > 0 && (c ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), a.updateData(o);
      var h = t.get("clip", !0) && Yb(t.coordinateSystem, !1, t);
      h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      var o = t.getData(), a = this._updateLineDraw(o, t);
      a.incrementalPrepareUpdate(o), this._clearLayer(i), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, r, i) {
      this._lineDraw.incrementalUpdate(t, r.getData()), this._finished = t.end === r.getData().count();
    }, e.prototype.eachRendered = function(t) {
      this._lineDraw && this._lineDraw.eachRendered(t);
    }, e.prototype.updateTransform = function(t, r, i) {
      var o = t.getData(), a = t.pipelineContext;
      if (!this._finished || a.large || a.progressiveRender)
        return {
          update: !0
        };
      var s = Lie.reset(t, r, i);
      s.progress && s.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, e.prototype._updateLineDraw = function(t, r) {
      var i = this._lineDraw, o = this._showEffect(r), a = !!r.get("polyline"), s = r.pipelineContext, l = s.large;
      return process.env.NODE_ENV !== "production" && o && l && console.warn("Large lines not support effect"), (!i || o !== this._hasEffet || a !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new bNt() : new XN(a ? o ? vNt : Die : o ? Mie : YN), this._hasEffet = o, this._isPolyline = a, this._isLargeDraw = l), this.group.add(i.group), i;
    }, e.prototype._showEffect = function(t) {
      return !!t.get(["effect", "show"]);
    }, e.prototype._clearLayer = function(t) {
      var r = t.getZr(), i = r.painter.getType() === "svg";
      !i && this._lastZlevel != null && r.painter.getLayer(this._lastZlevel).clear(!0);
    }, e.prototype.remove = function(t, r) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(r);
    }, e.prototype.dispose = function(t, r) {
      this.remove(t, r);
    }, e.type = "lines", e;
  }(bn)
);
const xNt = wNt;
var SNt = typeof Uint32Array > "u" ? Array : Uint32Array, _Nt = typeof Float64Array > "u" ? Array : Float64Array;
function fZ(n) {
  var e = n.data;
  e && e[0] && e[0][0] && e[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), n.data = le(e, function(t) {
    var r = [t[0].coord, t[1].coord], i = {
      coords: r
    };
    return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), xR([i, t[0], t[1]]);
  }));
}
var CNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.init = function(t) {
      t.data = t.data || [], fZ(t);
      var r = this._processFlatCoordsArray(t.data);
      this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count)), n.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(t) {
      if (fZ(t), t.data) {
        var r = this._processFlatCoordsArray(t.data);
        this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count));
      }
      n.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(t) {
      var r = this._processFlatCoordsArray(t.data);
      r.flatCoords && (this._flatCoords ? (this._flatCoords = sS(this._flatCoords, r.flatCoords), this._flatCoordsOffset = sS(this._flatCoordsOffset, r.flatCoordsOffset)) : (this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset), t.data = new Float32Array(r.count)), this.getRawData().appendData(t.data);
    }, e.prototype._getCoordsFromItemModel = function(t) {
      var r = this.getData().getItemModel(t), i = r.option instanceof Array ? r.option : r.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(i instanceof Array && i.length > 0 && i[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(i) + ". Lines must have 2d coords array in data item.");
      return i;
    }, e.prototype.getLineCoordsCount = function(t) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
    }, e.prototype.getLineCoords = function(t, r) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[t * 2], o = this._flatCoordsOffset[t * 2 + 1], a = 0; a < o; a++)
          r[a] = r[a] || [], r[a][0] = this._flatCoords[i + a * 2], r[a][1] = this._flatCoords[i + a * 2 + 1];
        return o;
      } else {
        for (var s = this._getCoordsFromItemModel(t), a = 0; a < s.length; a++)
          r[a] = r[a] || [], r[a][0] = s[a][0], r[a][1] = s[a][1];
        return s.length;
      }
    }, e.prototype._processFlatCoordsArray = function(t) {
      var r = 0;
      if (this._flatCoords && (r = this._flatCoords.length), $t(t[0])) {
        for (var i = t.length, o = new SNt(i), a = new _Nt(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var h = t[c++];
          o[l++] = s + r, o[l++] = h;
          for (var f = 0; f < h; f++) {
            var d = t[c++], p = t[c++];
            if (a[s++] = d, a[s++] = p, c > i && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(o.buffer, 0, l),
          flatCoords: a,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: t.length
      };
    }, e.prototype.getInitialData = function(t, r) {
      if (process.env.NODE_ENV !== "production") {
        var i = Fv.get(t.coordinateSystem);
        if (!i)
          throw new Error("Unknown coordinate system " + t.coordinateSystem);
      }
      var o = new Ki(["value"], this);
      return o.hasItemOption = !1, o.initData(t.data, [], function(a, s, l, u) {
        if (a instanceof Array)
          return NaN;
        o.hasItemOption = !0;
        var c = a.value;
        if (c != null)
          return c instanceof Array ? c[u] : c;
      }), o;
    }, e.prototype.formatTooltip = function(t, r, i) {
      var o = this.getData(), a = o.getItemModel(t), s = a.get("name");
      if (s)
        return s;
      var l = a.get("fromName"), u = a.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), Qr("nameValue", {
        name: c.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var t = this.getModel("effect"), r = t.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && r > 0 ? r + "" : "";
    }, e.type = "series.lines", e.dependencies = ["grid", "polar", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(Ln)
);
const ANt = CNt;
function WO(n) {
  return n instanceof Array || (n = [n, n]), n;
}
var TNt = {
  seriesType: "lines",
  reset: function(n) {
    var e = WO(n.get("symbol")), t = WO(n.get("symbolSize")), r = n.getData();
    r.setVisual("fromSymbol", e && e[0]), r.setVisual("toSymbol", e && e[1]), r.setVisual("fromSymbolSize", t && t[0]), r.setVisual("toSymbolSize", t && t[1]);
    function i(o, a) {
      var s = o.getItemModel(a), l = WO(s.getShallow("symbol", !0)), u = WO(s.getShallow("symbolSize", !0));
      l[0] && o.setItemVisual(a, "fromSymbol", l[0]), l[1] && o.setItemVisual(a, "toSymbol", l[1]), u[0] && o.setItemVisual(a, "fromSymbolSize", u[0]), u[1] && o.setItemVisual(a, "toSymbolSize", u[1]);
    }
    return {
      dataEach: r.hasItemOption ? i : null
    };
  }
};
const kNt = TNt;
function PNt(n) {
  n.registerChartView(xNt), n.registerSeriesModel(ANt), n.registerLayout(Lie), n.registerVisual(kNt);
}
var ENt = 256, MNt = (
  /** @class */
  function() {
    function n() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var e = jc.createCanvas();
      this.canvas = e;
    }
    return n.prototype.update = function(e, t, r, i, o, a) {
      var s = this._getBrush(), l = this._getGradient(o, "inRange"), u = this._getGradient(o, "outOfRange"), c = this.pointSize + this.blurSize, h = this.canvas, f = h.getContext("2d"), d = e.length;
      h.width = t, h.height = r;
      for (var p = 0; p < d; ++p) {
        var g = e[p], v = g[0], m = g[1], y = g[2], b = i(y);
        f.globalAlpha = b, f.drawImage(s, v - c, m - c);
      }
      if (!h.width || !h.height)
        return h;
      for (var O = f.getImageData(0, 0, h.width, h.height), w = O.data, x = 0, S = w.length, _ = this.minOpacity, C = this.maxOpacity, A = C - _; x < S; ) {
        var b = w[x + 3] / 256, k = Math.floor(b * (ENt - 1)) * 4;
        if (b > 0) {
          var P = a(b) ? l : u;
          b > 0 && (b = b * A + _), w[x++] = P[k], w[x++] = P[k + 1], w[x++] = P[k + 2], w[x++] = P[k + 3] * b * 256;
        } else
          x += 4;
      }
      return f.putImageData(O, 0, 0), h;
    }, n.prototype._getBrush = function() {
      var e = this._brushCanvas || (this._brushCanvas = jc.createCanvas()), t = this.pointSize + this.blurSize, r = t * 2;
      e.width = r, e.height = r;
      var i = e.getContext("2d");
      return i.clearRect(0, 0, r, r), i.shadowOffsetX = r, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-t, t, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), e;
    }, n.prototype._getGradient = function(e, t) {
      for (var r = this._gradientPixels, i = r[t] || (r[t] = new Uint8ClampedArray(256 * 4)), o = [0, 0, 0, 0], a = 0, s = 0; s < 256; s++)
        e[t](s / 255, !0, o), i[a++] = o[0], i[a++] = o[1], i[a++] = o[2], i[a++] = o[3];
      return i;
    }, n;
  }()
);
const DNt = MNt;
function LNt(n, e, t) {
  var r = n[1] - n[0];
  e = le(e, function(a) {
    return {
      interval: [(a.interval[0] - n[0]) / r, (a.interval[1] - n[0]) / r]
    };
  });
  var i = e.length, o = 0;
  return function(a) {
    var s;
    for (s = o; s < i; s++) {
      var l = e[s].interval;
      if (l[0] <= a && a <= l[1]) {
        o = s;
        break;
      }
    }
    if (s === i)
      for (s = o - 1; s >= 0; s--) {
        var l = e[s].interval;
        if (l[0] <= a && a <= l[1]) {
          o = s;
          break;
        }
      }
    return s >= 0 && s < i && t[s];
  };
}
function INt(n, e) {
  var t = n[1] - n[0];
  return e = [(e[0] - n[0]) / t, (e[1] - n[0]) / t], function(r) {
    return r >= e[0] && r <= e[1];
  };
}
function dZ(n) {
  var e = n.dimensions;
  return e[0] === "lng" && e[1] === "lat";
}
var RNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o;
      if (r.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === t && (o = s);
        });
      }), process.env.NODE_ENV !== "production" && !o)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var a = t.coordinateSystem;
      a.type === "cartesian2d" || a.type === "calendar" ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : dZ(a) && this._renderOnGeo(a, t, o, i);
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this.group.removeAll();
    }, e.prototype.incrementalRender = function(t, r, i, o) {
      var a = r.coordinateSystem;
      a && (dZ(a) ? this.render(r, i, o) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(r, o, t.start, t.end, !0)));
    }, e.prototype.eachRendered = function(t) {
      dh(this._progressiveEls || this.group, t);
    }, e.prototype._renderOnCartesianAndCalendar = function(t, r, i, o, a) {
      var s = t.coordinateSystem, l = Nd(s, "cartesian2d"), u, c, h, f;
      if (l) {
        var d = s.getAxis("x"), p = s.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(d.type === "category" && p.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(d.onBand && p.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        u = d.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, h = d.scale.getExtent(), f = p.scale.getExtent();
      }
      for (var g = this.group, v = t.getData(), m = t.getModel(["emphasis", "itemStyle"]).getItemStyle(), y = t.getModel(["blur", "itemStyle"]).getItemStyle(), b = t.getModel(["select", "itemStyle"]).getItemStyle(), O = t.get(["itemStyle", "borderRadius"]), w = Fr(t), x = t.getModel("emphasis"), S = x.get("focus"), _ = x.get("blurScope"), C = x.get("disabled"), A = l ? [v.mapDimension("x"), v.mapDimension("y"), v.mapDimension("value")] : [v.mapDimension("time"), v.mapDimension("value")], k = i; k < o; k++) {
        var P = void 0, L = v.getItemVisual(k, "style");
        if (l) {
          var D = v.get(A[0], k), E = v.get(A[1], k);
          if (isNaN(v.get(A[2], k)) || isNaN(D) || isNaN(E) || D < h[0] || D > h[1] || E < f[0] || E > f[1])
            continue;
          var M = s.dataToPoint([D, E]);
          P = new Lt({
            shape: {
              x: M[0] - u / 2,
              y: M[1] - c / 2,
              width: u,
              height: c
            },
            style: L
          });
        } else {
          if (isNaN(v.get(A[1], k)))
            continue;
          P = new Lt({
            z2: 1,
            shape: s.dataToRect([v.get(A[0], k)]).contentShape,
            style: L
          });
        }
        if (v.hasItemOption) {
          var R = v.getItemModel(k), N = R.getModel("emphasis");
          m = N.getModel("itemStyle").getItemStyle(), y = R.getModel(["blur", "itemStyle"]).getItemStyle(), b = R.getModel(["select", "itemStyle"]).getItemStyle(), O = R.get(["itemStyle", "borderRadius"]), S = N.get("focus"), _ = N.get("blurScope"), C = N.get("disabled"), w = Fr(R);
        }
        P.shape.r = O;
        var $ = t.getRawValue(k), F = "-";
        $ && $[2] != null && (F = $[2] + ""), wi(P, w, {
          labelFetcher: t,
          labelDataIndex: k,
          defaultOpacity: L.opacity,
          defaultText: F
        }), P.ensureState("emphasis").style = m, P.ensureState("blur").style = y, P.ensureState("select").style = b, Wn(P, S, _, C), P.incremental = a, a && (P.states.emphasis.hoverLayer = !0), g.add(P), v.setItemGraphicEl(k, P), this._progressiveEls && this._progressiveEls.push(P);
      }
    }, e.prototype._renderOnGeo = function(t, r, i, o) {
      var a = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = r.getData(), u = this._hmLayer || this._hmLayer || new DNt();
      u.blurSize = r.get("blurSize"), u.pointSize = r.get("pointSize"), u.minOpacity = r.get("minOpacity"), u.maxOpacity = r.get("maxOpacity");
      var c = t.getViewRect().clone(), h = t.getRoamTransform();
      c.applyTransform(h);
      var f = Math.max(c.x, 0), d = Math.max(c.y, 0), p = Math.min(c.width + c.x, o.getWidth()), g = Math.min(c.height + c.y, o.getHeight()), v = p - f, m = g - d, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], b = l.mapArray(y, function(S, _, C) {
        var A = t.dataToPoint([S, _]);
        return A[0] -= f, A[1] -= d, A.push(C), A;
      }), O = i.getExtent(), w = i.type === "visualMap.continuous" ? INt(O, i.option.range) : LNt(O, i.getPieceList(), i.option.selected);
      u.update(b, v, m, a.color.getNormalizer(), {
        inRange: a.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, w);
      var x = new Si({
        style: {
          width: v,
          height: m,
          x: f,
          y: d,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(x);
    }, e.type = "heatmap", e;
  }(bn)
);
const NNt = RNt;
var $Nt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return ku(null, this, {
        generateCoord: "value"
      });
    }, e.prototype.preventIncremental = function() {
      var t = Fv.get(this.get("coordinateSystem"));
      if (t && t.dimensions)
        return t.dimensions[0] === "lng" && t.dimensions[1] === "lat";
    }, e.type = "series.heatmap", e.dependencies = ["grid", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Ln)
);
const BNt = $Nt;
function VNt(n) {
  n.registerChartView(NNt), n.registerSeriesModel(BNt);
}
var zNt = ["itemStyle", "borderWidth"], pZ = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], vk = new fh(), FNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = this.group, a = t.getData(), s = this._data, l = t.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), h = l.master.getRect(), f = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: t,
        coordSys: l,
        coordSysExtent: [[h.x, h.x + h.width], [h.y, h.y + h.height]],
        isHorizontal: c,
        valueDim: pZ[+c],
        categoryDim: pZ[1 - +c]
      };
      a.diff(s).add(function(p) {
        if (a.hasValue(p)) {
          var g = vZ(a, p), v = gZ(a, p, g, f), m = mZ(a, f, v);
          a.setItemGraphicEl(p, m), o.add(m), bZ(m, f, v);
        }
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        if (!a.hasValue(p)) {
          o.remove(v);
          return;
        }
        var m = vZ(a, p), y = gZ(a, p, m, f), b = Vie(a, y);
        v && b !== v.__pictorialShapeStr && (o.remove(v), a.setItemGraphicEl(p, null), v = null), v ? qNt(v, f, y) : v = mZ(a, f, y, !0), a.setItemGraphicEl(p, v), v.__pictorialSymbolMeta = y, o.add(v), bZ(v, f, y);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        g && yZ(s, p, g.__pictorialSymbolMeta.animationModel, g);
      }).execute();
      var d = t.get("clip", !0) ? Yb(t.coordinateSystem, !1, t) : null;
      return d ? o.setClipPath(d) : o.removeClipPath(), this._data = a, this.group;
    }, e.prototype.remove = function(t, r) {
      var i = this.group, o = this._data;
      t.get("animation") ? o && o.eachItemGraphicEl(function(a) {
        yZ(o, He(a).dataIndex, t, a);
      }) : i.removeAll();
    }, e.type = "pictorialBar", e;
  }(bn)
);
function gZ(n, e, t, r) {
  var i = n.getItemLayout(e), o = t.get("symbolRepeat"), a = t.get("symbolClip"), s = t.get("symbolPosition") || "start", l = t.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = t.get("symbolPatternSize") || 2, h = t.isAnimationEnabled(), f = {
    dataIndex: e,
    layout: i,
    itemModel: t,
    symbolType: n.getItemVisual(e, "symbol") || "circle",
    style: n.getItemVisual(e, "style"),
    symbolClip: a,
    symbolRepeat: o,
    symbolRepeatDirection: t.get("symbolRepeatDirection"),
    symbolPatternSize: c,
    rotation: u,
    animationModel: h ? t : null,
    hoverScale: h && t.get(["emphasis", "scale"]),
    z2: t.getShallow("z", !0) || 0
  };
  QNt(t, o, i, r, f), ZNt(n, e, i, o, a, f.boundingLength, f.pxSign, c, r, f), WNt(t, f.symbolScale, u, r, f);
  var d = f.symbolSize, p = Id(t.get("symbolOffset"), d);
  return GNt(t, d, i, o, a, p, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, r, f), f;
}
function QNt(n, e, t, r, i) {
  var o = r.valueDim, a = n.get("symbolBoundingData"), s = r.coordSys.getOtherAxis(r.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(t[o.wh] <= 0), c;
  if (se(a)) {
    var h = [mk(s, a[0]) - l, mk(s, a[1]) - l];
    h[1] < h[0] && h.reverse(), c = h[u];
  } else
    a != null ? c = mk(s, a) - l : e ? c = r.coordSysExtent[o.index][u] - l : c = t[o.wh];
  i.boundingLength = c, e && (i.repeatCutLength = t[o.wh]), i.pxSign = c > 0 ? 1 : -1;
}
function mk(n, e) {
  return n.toGlobalCoord(n.dataToCoord(n.scale.parse(e)));
}
function ZNt(n, e, t, r, i, o, a, s, l, u) {
  var c = l.valueDim, h = l.categoryDim, f = Math.abs(t[h.wh]), d = n.getItemVisual(e, "symbolSize"), p;
  se(d) ? p = d.slice() : d == null ? p = ["100%", "100%"] : p = [d, d], p[h.index] = be(p[h.index], f), p[c.index] = be(p[c.index], r ? f : Math.abs(o)), u.symbolSize = p;
  var g = u.symbolScale = [p[0] / s, p[1] / s];
  g[c.index] *= (l.isHorizontal ? -1 : 1) * a;
}
function WNt(n, e, t, r, i) {
  var o = n.get(zNt) || 0;
  o && (vk.attr({
    scaleX: e[0],
    scaleY: e[1],
    rotation: t
  }), vk.updateTransform(), o /= vk.getLineScale(), o *= e[r.valueDim.index]), i.valueLineWidth = o || 0;
}
function GNt(n, e, t, r, i, o, a, s, l, u, c, h) {
  var f = c.categoryDim, d = c.valueDim, p = h.pxSign, g = Math.max(e[d.index] + s, 0), v = g;
  if (r) {
    var m = Math.abs(l), y = ur(n.get("symbolMargin"), "15%") + "", b = !1;
    y.lastIndexOf("!") === y.length - 1 && (b = !0, y = y.slice(0, y.length - 1));
    var O = be(y, e[d.index]), w = Math.max(g + O * 2, 0), x = b ? 0 : O * 2, S = DR(r), _ = S ? r : OZ((m + x) / w), C = m - _ * g;
    O = C / 2 / (b ? _ : Math.max(_ - 1, 1)), w = g + O * 2, x = b ? 0 : O * 2, !S && r !== "fixed" && (_ = u ? OZ((Math.abs(u) + x) / w) : 0), v = _ * w - x, h.repeatTimes = _, h.symbolMargin = O;
  }
  var A = p * (v / 2), k = h.pathPosition = [];
  k[f.index] = t[f.wh] / 2, k[d.index] = a === "start" ? A : a === "end" ? l - A : l / 2, o && (k[0] += o[0], k[1] += o[1]);
  var P = h.bundlePosition = [];
  P[f.index] = t[f.xy], P[d.index] = t[d.xy];
  var L = h.barRectShape = re({}, t);
  L[d.wh] = p * Math.max(Math.abs(t[d.wh]), Math.abs(k[d.index] + A)), L[f.wh] = t[f.wh];
  var D = h.clipShape = {};
  D[f.xy] = -t[f.xy], D[f.wh] = c.ecSize[f.wh], D[d.xy] = 0, D[d.wh] = t[d.wh];
}
function Iie(n) {
  var e = n.symbolPatternSize, t = vr(
    // Consider texture img, make a big size.
    n.symbolType,
    -e / 2,
    -e / 2,
    e,
    e
  );
  return t.attr({
    culling: !0
  }), t.type !== "image" && t.setStyle({
    strokeNoScale: !0
  }), t;
}
function Rie(n, e, t, r) {
  var i = n.__pictorialBundle, o = t.symbolSize, a = t.valueLineWidth, s = t.pathPosition, l = e.valueDim, u = t.repeatTimes || 0, c = 0, h = o[e.valueDim.index] + a + t.symbolMargin * 2;
  for (i$(n, function(g) {
    g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? tg(g, null, p(c), t, r) : tg(g, null, {
      scaleX: 0,
      scaleY: 0
    }, t, r, function() {
      i.remove(g);
    }), c++;
  }); c < u; c++) {
    var f = Iie(t);
    f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = u, i.add(f);
    var d = p(c);
    tg(f, {
      x: d.x,
      y: d.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: d.scaleX,
      scaleY: d.scaleY,
      rotation: d.rotation
    }, t, r);
  }
  function p(g) {
    var v = s.slice(), m = t.pxSign, y = g;
    return (t.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - g), v[l.index] = h * (y - u / 2 + 0.5) + s[l.index], {
      x: v[0],
      y: v[1],
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1],
      rotation: t.rotation
    };
  }
}
function Nie(n, e, t, r) {
  var i = n.__pictorialBundle, o = n.__pictorialMainPath;
  o ? tg(o, null, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1],
    rotation: t.rotation
  }, t, r) : (o = n.__pictorialMainPath = Iie(t), i.add(o), tg(o, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: t.rotation
  }, {
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1]
  }, t, r));
}
function $ie(n, e, t) {
  var r = re({}, e.barRectShape), i = n.__pictorialBarRect;
  i ? tg(i, null, {
    shape: r
  }, e, t) : (i = n.__pictorialBarRect = new Lt({
    z2: 2,
    shape: r,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), i.disableMorphing = !0, n.add(i));
}
function Bie(n, e, t, r) {
  if (t.symbolClip) {
    var i = n.__pictorialClipPath, o = re({}, t.clipShape), a = e.valueDim, s = t.animationModel, l = t.dataIndex;
    if (i)
      Vt(i, {
        shape: o
      }, s, l);
    else {
      o[a.wh] = 0, i = new Lt({
        shape: o
      }), n.__pictorialBundle.setClipPath(i), n.__pictorialClipPath = i;
      var u = {};
      u[a.wh] = t.clipShape[a.wh], Dd[r ? "updateProps" : "initProps"](i, {
        shape: u
      }, s, l);
    }
  }
}
function vZ(n, e) {
  var t = n.getItemModel(e);
  return t.getAnimationDelayParams = jNt, t.isAnimationEnabled = HNt, t;
}
function jNt(n) {
  return {
    index: n.__pictorialAnimationIndex,
    count: n.__pictorialRepeatTimes
  };
}
function HNt() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function mZ(n, e, t, r) {
  var i = new We(), o = new We();
  return i.add(o), i.__pictorialBundle = o, o.x = t.bundlePosition[0], o.y = t.bundlePosition[1], t.symbolRepeat ? Rie(i, e, t) : Nie(i, e, t), $ie(i, t, r), Bie(i, e, t, r), i.__pictorialShapeStr = Vie(n, t), i.__pictorialSymbolMeta = t, i;
}
function qNt(n, e, t) {
  var r = t.animationModel, i = t.dataIndex, o = n.__pictorialBundle;
  Vt(o, {
    x: t.bundlePosition[0],
    y: t.bundlePosition[1]
  }, r, i), t.symbolRepeat ? Rie(n, e, t, !0) : Nie(n, e, t, !0), $ie(n, t, !0), Bie(n, e, t, !0);
}
function yZ(n, e, t, r) {
  var i = r.__pictorialBarRect;
  i && i.removeTextContent();
  var o = [];
  i$(r, function(a) {
    o.push(a);
  }), r.__pictorialMainPath && o.push(r.__pictorialMainPath), r.__pictorialClipPath && (t = null), I(o, function(a) {
    Yc(a, {
      scaleX: 0,
      scaleY: 0
    }, t, e, function() {
      r.parent && r.parent.remove(r);
    });
  }), n.setItemGraphicEl(e, null);
}
function Vie(n, e) {
  return [n.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":");
}
function i$(n, e, t) {
  I(n.__pictorialBundle.children(), function(r) {
    r !== n.__pictorialBarRect && e.call(t, r);
  });
}
function tg(n, e, t, r, i, o) {
  e && n.attr(e), r.symbolClip && !i ? t && n.attr(t) : t && Dd[i ? "updateProps" : "initProps"](n, t, r.animationModel, r.dataIndex, o);
}
function bZ(n, e, t) {
  var r = t.dataIndex, i = t.itemModel, o = i.getModel("emphasis"), a = o.getModel("itemStyle").getItemStyle(), s = i.getModel(["blur", "itemStyle"]).getItemStyle(), l = i.getModel(["select", "itemStyle"]).getItemStyle(), u = i.getShallow("cursor"), c = o.get("focus"), h = o.get("blurScope"), f = o.get("scale");
  i$(n, function(g) {
    if (g instanceof Si) {
      var v = g.style;
      g.useStyle(re({
        // TODO other properties like dx, dy ?
        image: v.image,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      }, t.style));
    } else
      g.useStyle(t.style);
    var m = g.ensureState("emphasis");
    m.style = a, f && (m.scaleX = g.scaleX * 1.1, m.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = s, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = t.z2;
  });
  var d = e.valueDim.posDesc[+(t.boundingLength > 0)], p = n.__pictorialBarRect;
  p.ignoreClip = !0, wi(p, Fr(i), {
    labelFetcher: e.seriesModel,
    labelDataIndex: r,
    defaultText: Jg(e.seriesModel.getData(), r),
    inheritColor: t.style.fill,
    defaultOpacity: t.style.opacity,
    defaultOutsidePosition: d
  }), Wn(n, c, h, o.get("disabled"));
}
function OZ(n) {
  var e = Math.round(n);
  return Math.abs(n - e) < 1e-4 ? e : Math.ceil(n);
}
const YNt = FNt;
var XNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t.defaultSymbol = "roundRect", t;
    }
    return e.prototype.getInitialData = function(t) {
      return t.stack = null, n.prototype.getInitialData.apply(this, arguments);
    }, e.type = "series.pictorialBar", e.dependencies = ["grid"], e.defaultOption = ph(q0.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // Pictorial bar do not clip by default because in many cases
      // xAxis and yAxis are not displayed and it's expected not to clip
      clip: !1,
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), e;
  }(q0)
);
const UNt = XNt;
function KNt(n) {
  n.registerChartView(YNt), n.registerSeriesModel(UNt), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Je(One, "pictorialBar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, wne("pictorialBar"));
}
var JNt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._layers = [], t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = t.getData(), a = this, s = this.group, l = t.getLayerSeries(), u = o.getLayout("layoutInfo"), c = u.rect, h = u.boundaryGap;
      s.x = 0, s.y = c.y + h[0];
      function f(v) {
        return v.name;
      }
      var d = new mu(this._layersSeries || [], l, f, f), p = [];
      d.add(_e(g, this, "add")).update(_e(g, this, "update")).remove(_e(g, this, "remove")).execute();
      function g(v, m, y) {
        var b = a._layers;
        if (v === "remove") {
          s.remove(b[m]);
          return;
        }
        for (var O = [], w = [], x, S = l[m].indices, _ = 0; _ < S.length; _++) {
          var C = o.getItemLayout(S[_]), A = C.x, k = C.y0, P = C.y;
          O.push(A, k), w.push(A, k + P), x = o.getItemVisual(S[_], "style");
        }
        var L, D = o.getItemLayout(S[0]), E = t.getModel("label"), M = E.get("margin"), R = t.getModel("emphasis");
        if (v === "add") {
          var N = p[m] = new We();
          L = new cre({
            shape: {
              points: O,
              stackedOnPoints: w,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), N.add(L), s.add(N), t.isAnimationEnabled() && L.setClipPath(e$t(L.getBoundingRect(), t, function() {
            L.removeClipPath();
          }));
        } else {
          var N = b[y];
          L = N.childAt(0), s.add(N), p[m] = N, Vt(L, {
            shape: {
              points: O,
              stackedOnPoints: w
            }
          }, t), ms(L);
        }
        wi(L, Fr(t), {
          labelDataIndex: S[_ - 1],
          defaultText: o.getName(S[_ - 1]),
          inheritColor: x.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), L.setTextConfig({
          position: null,
          local: !0
        });
        var $ = L.getTextContent();
        $ && ($.x = D.x - M, $.y = D.y0 + D.y / 2), L.useStyle(x), o.setItemGraphicEl(m, L), Oi(L, t), Wn(L, R.get("focus"), R.get("blurScope"), R.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, e.type = "themeRiver", e;
  }(bn)
);
function e$t(n, e, t) {
  var r = new Lt({
    shape: {
      x: n.x - 10,
      y: n.y - 10,
      width: 0,
      height: n.height + 20
    }
  });
  return Cn(r, {
    shape: {
      x: n.x - 50,
      width: n.width + 100,
      height: n.height + 20
    }
  }, e, t), r;
}
const t$t = JNt;
var yk = 2, n$t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Kb(_e(this.getData, this), _e(this.getRawData, this));
    }, e.prototype.fixData = function(t) {
      var r = t.length, i = {}, o = IM(t, function(f) {
        return i.hasOwnProperty(f[0] + "") || (i[f[0] + ""] = -1), f[2];
      }), a = [];
      o.buckets.each(function(f, d) {
        a.push({
          name: d,
          dataList: f
        });
      });
      for (var s = a.length, l = 0; l < s; ++l) {
        for (var u = a[l].name, c = 0; c < a[l].dataList.length; ++c) {
          var h = a[l].dataList[c][0] + "";
          i[h] = l;
        }
        for (var h in i)
          i.hasOwnProperty(h) && i[h] !== l && (i[h] = l, t[r] = [h, 0, u], r++);
      }
      return t;
    }, e.prototype.getInitialData = function(t, r) {
      for (var i = this.getReferringComponents("singleAxis", cr).models[0], o = i.get("type"), a = en(t.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(a || []), l = [], u = this.nameMap = Ee(), c = 0, h = 0; h < s.length; ++h)
        l.push(s[h][yk]), u.get(s[h][yk]) || (u.set(s[h][yk], c), c++);
      var f = Wb(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: DS(o)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new Ki(f, this);
      return d.initData(s), d;
    }, e.prototype.getLayerSeries = function() {
      for (var t = this.getData(), r = t.count(), i = [], o = 0; o < r; ++o)
        i[o] = o;
      var a = t.mapDimension("single"), s = IM(i, function(u) {
        return t.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(h, f) {
          return t.get(a, h) - t.get(a, f);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, e.prototype.getAxisTooltipData = function(t, r, i) {
      se(t) || (t = t ? [t] : []);
      for (var o = this.getData(), a = this.getLayerSeries(), s = [], l = a.length, u, c = 0; c < l; ++c) {
        for (var h = Number.MAX_VALUE, f = -1, d = a[c].indices.length, p = 0; p < d; ++p) {
          var g = o.get(t[0], a[c].indices[p]), v = Math.abs(g - r);
          v <= h && (u = g, h = v, f = a[c].indices[p]);
        }
        s.push(f);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, e.prototype.formatTooltip = function(t, r, i) {
      var o = this.getData(), a = o.getName(t), s = o.get(o.mapDimension("value"), t);
      return Qr("nameValue", {
        name: a,
        value: s
      });
    }, e.type = "series.themeRiver", e.dependencies = ["singleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(Ln)
);
const r$t = n$t;
function i$t(n, e) {
  n.eachSeriesByType("themeRiver", function(t) {
    var r = t.getData(), i = t.coordinateSystem, o = {}, a = i.getRect();
    o.rect = a;
    var s = t.get("boundaryGap"), l = i.getAxis();
    if (o.boundaryGap = s, l.orient === "horizontal") {
      s[0] = be(s[0], a.height), s[1] = be(s[1], a.height);
      var u = a.height - s[0] - s[1];
      wZ(r, t, u);
    } else {
      s[0] = be(s[0], a.width), s[1] = be(s[1], a.width);
      var c = a.width - s[0] - s[1];
      wZ(r, t, c);
    }
    r.setLayout("layoutInfo", o);
  });
}
function wZ(n, e, t) {
  if (n.count())
    for (var r = e.coordinateSystem, i = e.getLayerSeries(), o = n.mapDimension("single"), a = n.mapDimension("value"), s = le(i, function(v) {
      return le(v.indices, function(m) {
        var y = r.dataToPoint(n.get(o, m));
        return y[1] = n.get(a, m), y;
      });
    }), l = o$t(s), u = l.y0, c = t / l.max, h = i.length, f = i[0].indices.length, d, p = 0; p < f; ++p) {
      d = u[p] * c, n.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: d,
        y: s[0][p][1] * c
      });
      for (var g = 1; g < h; ++g)
        d += s[g - 1][p][1] * c, n.setItemLayout(i[g].indices[p], {
          layerIndex: g,
          x: s[g][p][0],
          y0: d,
          y: s[g][p][1] * c
        });
    }
}
function o$t(n) {
  for (var e = n.length, t = n[0].length, r = [], i = [], o = 0, a = 0; a < t; ++a) {
    for (var s = 0, l = 0; l < e; ++l)
      s += n[l][a][1];
    s > o && (o = s), r.push(s);
  }
  for (var u = 0; u < t; ++u)
    i[u] = (o - r[u]) / 2;
  o = 0;
  for (var c = 0; c < t; ++c) {
    var h = r[c] + i[c];
    h > o && (o = h);
  }
  return {
    y0: i,
    max: o
  };
}
function a$t(n) {
  n.registerChartView(t$t), n.registerSeriesModel(r$t), n.registerLayout(i$t), n.registerProcessor(Ub("themeRiver"));
}
var s$t = 2, l$t = 4, xZ = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i, o) {
      var a = n.call(this) || this;
      a.z2 = s$t, a.textConfig = {
        inside: !0
      }, He(a).seriesIndex = r.seriesIndex;
      var s = new Nt({
        z2: l$t,
        silent: t.getModel().get(["label", "silent"])
      });
      return a.setTextContent(s), a.updateData(!0, t, r, i, o), a;
    }
    return e.prototype.updateData = function(t, r, i, o, a) {
      this.node = r, r.piece = this, i = i || this._seriesModel, o = o || this._ecModel;
      var s = this;
      He(s).dataIndex = r.dataIndex;
      var l = r.getModel(), u = l.getModel("emphasis"), c = r.getLayout(), h = re({}, c);
      h.label = null;
      var f = r.getVisual("style");
      f.lineJoin = "bevel";
      var d = r.getVisual("decal");
      d && (f.decal = Ug(d, a));
      var p = Tf(l.getModel("itemStyle"), h, !0);
      re(h, p), I(no, function(y) {
        var b = s.ensureState(y), O = l.getModel([y, "itemStyle"]);
        b.style = O.getItemStyle();
        var w = Tf(O, h);
        w && (b.shape = w);
      }), t ? (s.setShape(h), s.shape.r = c.r0, Cn(s, {
        shape: {
          r: c.r
        }
      }, i, r.dataIndex)) : (Vt(s, {
        shape: h
      }, i), ms(s)), s.useStyle(f), this._updateLabel(i);
      var g = l.getShallow("cursor");
      g && s.attr("cursor", g), this._seriesModel = i || this._seriesModel, this._ecModel = o || this._ecModel;
      var v = u.get("focus"), m = v === "ancestor" ? r.getAncestorsIndices() : v === "descendant" ? r.getDescendantIndices() : v;
      Wn(this, m, u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t) {
      var r = this, i = this.node.getModel(), o = i.getModel("label"), a = this.node.getLayout(), s = a.endAngle - a.startAngle, l = (a.startAngle + a.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), h = this, f = h.getTextContent(), d = this.node.dataIndex, p = o.get("minAngle") / 180 * Math.PI, g = o.get("show") && !(p != null && Math.abs(s) < p);
      f.ignore = !g, I($0, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([m, "label"]), b = m === "normal", O = b ? f : f.ensureState(m), w = t.getFormattedLabel(d, m);
        b && (w = w || r.node.name), O.style = vn(y, {}, null, m !== "normal", !0), w && (O.style.text = w);
        var x = y.get("show");
        x != null && !b && (O.ignore = !x);
        var S = v(y, "position"), _ = b ? h : h.states[m], C = _.style.fill;
        _.textConfig = {
          outsideFill: y.get("color") === "inherit" ? C : null,
          inside: S !== "outside"
        };
        var A, k = v(y, "distance") || 0, P = v(y, "align"), L = v(y, "rotate"), D = Math.PI * 0.5, E = Math.PI * 1.5, M = jo(L === "tangential" ? Math.PI / 2 - l : l), R = M > D && !R0(M - D) && M < E;
        S === "outside" ? (A = a.r + k, P = R ? "right" : "left") : !P || P === "center" ? (s === 2 * Math.PI && a.r0 === 0 ? A = 0 : A = (a.r + a.r0) / 2, P = "center") : P === "left" ? (A = a.r0 + k, P = R ? "right" : "left") : P === "right" && (A = a.r - k, P = R ? "left" : "right"), O.style.align = P, O.style.verticalAlign = v(y, "verticalAlign") || "middle", O.x = A * u + a.cx, O.y = A * c + a.cy;
        var N = 0;
        L === "radial" ? N = jo(-l) + (R ? Math.PI : 0) : L === "tangential" ? N = jo(Math.PI / 2 - l) + (R ? Math.PI : 0) : $t(L) && (N = L * Math.PI / 180), O.rotation = jo(N);
      });
      function v(m, y) {
        var b = m.get(y);
        return b ?? o.get(y);
      }
      f.dirtyStyle();
    }, e;
  }(Eo)
), LD = "sunburstRootToNode", SZ = "sunburstHighlight", u$t = "sunburstUnhighlight";
function c$t(n) {
  n.registerAction({
    type: LD,
    update: "updateView"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, r);
    function r(i, o) {
      var a = X0(e, [LD], i);
      if (a) {
        var s = i.getViewRoot();
        s && (e.direction = ZN(s, a.node) ? "rollUp" : "drillDown"), i.resetViewRoot(a.node);
      }
    }
  }), n.registerAction({
    type: SZ,
    update: "none"
  }, function(e, t, r) {
    e = re({}, e), t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, i);
    function i(o) {
      var a = X0(e, [SZ], o);
      a && (e.dataIndex = a.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && lr("sunburstHighlight", "highlight"), r.dispatchAction(re(e, {
      type: "highlight"
    }));
  }), n.registerAction({
    type: u$t,
    update: "updateView"
  }, function(e, t, r) {
    e = re({}, e), process.env.NODE_ENV !== "production" && lr("sunburstUnhighlight", "downplay"), r.dispatchAction(re(e, {
      type: "downplay"
    }));
  });
}
var h$t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, o) {
      var a = this;
      this.seriesModel = t, this.api = i, this.ecModel = r;
      var s = t.getData(), l = s.tree.root, u = t.getViewRoot(), c = this.group, h = t.get("renderLabelForZeroData"), f = [];
      u.eachNode(function(y) {
        f.push(y);
      });
      var d = this._oldChildren || [];
      p(f, d), m(l, u), this._initEvents(), this._oldChildren = f;
      function p(y, b) {
        if (y.length === 0 && b.length === 0)
          return;
        new mu(b, y, O, O).add(w).update(w).remove(Je(w, null)).execute();
        function O(x) {
          return x.getId();
        }
        function w(x, S) {
          var _ = x == null ? null : y[x], C = S == null ? null : b[S];
          g(_, C);
        }
      }
      function g(y, b) {
        if (!h && y && !y.getValue() && (y = null), y !== l && b !== l) {
          if (b && b.piece)
            y ? (b.piece.updateData(!1, y, t, r, i), s.setItemGraphicEl(y.dataIndex, b.piece)) : v(b);
          else if (y) {
            var O = new xZ(y, t, r, i);
            c.add(O), s.setItemGraphicEl(y.dataIndex, O);
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, b) {
        b.depth > 0 ? (a.virtualPiece ? a.virtualPiece.updateData(!1, y, t, r, i) : (a.virtualPiece = new xZ(y, t, r, i), c.add(a.virtualPiece)), b.piece.off("click"), a.virtualPiece.on("click", function(O) {
          a._rootToNode(b.parentNode);
        })) : a.virtualPiece && (c.remove(a.virtualPiece), a.virtualPiece = null);
      }
    }, e.prototype._initEvents = function() {
      var t = this;
      this.group.off("click"), this.group.on("click", function(r) {
        var i = !1, o = t.seriesModel.getViewRoot();
        o.eachNode(function(a) {
          if (!i && a.piece && a.piece === r.target) {
            var s = a.getModel().get("nodeClick");
            if (s === "rootToNode")
              t._rootToNode(a);
            else if (s === "link") {
              var l = a.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", !0) || "_blank";
                xS(u, c);
              }
            }
            i = !0;
          }
        });
      });
    }, e.prototype._rootToNode = function(t) {
      t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: LD,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t
      });
    }, e.prototype.containPoint = function(t, r) {
      var i = r.getData(), o = i.getItemLayout(0);
      if (o) {
        var a = t[0] - o.cx, s = t[1] - o.cy, l = Math.sqrt(a * a + s * s);
        return l <= o.r && l >= o.r0;
      }
    }, e.type = "sunburst", e;
  }(bn)
);
const f$t = h$t;
var d$t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = {
        name: t.name,
        children: t.data
      };
      zie(i);
      var o = this._levelModels = le(t.levels || [], function(l) {
        return new mn(l, this, r);
      }, this), a = QN.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var h = a.getNodeByDataIndex(c), f = o[h.depth];
          return f && (u.parentModel = f), u;
        });
      }
      return a.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treePathInfo = HC(i, this), r;
    }, e.prototype.getLevelModel = function(t) {
      return this._levelModels && this._levelModels[t.depth];
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!t || t !== r && !r.contains(t)) && (this._viewRoot = r);
    }, e.prototype.enableAriaDecal = function() {
      Wre(this);
    }, e.type = "series.sunburst", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, e;
  }(Ln)
);
function zie(n) {
  var e = 0;
  I(n.children, function(r) {
    zie(r);
    var i = r.value;
    se(i) && (i = i[0]), e += i;
  });
  var t = n.value;
  se(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), se(n.value) ? n.value[0] = t : n.value = t;
}
const p$t = d$t;
var _Z = Math.PI / 180;
function g$t(n, e, t) {
  e.eachSeriesByType(n, function(r) {
    var i = r.get("center"), o = r.get("radius");
    se(o) || (o = [0, o]), se(i) || (i = [i, i]);
    var a = t.getWidth(), s = t.getHeight(), l = Math.min(a, s), u = be(i[0], a), c = be(i[1], s), h = be(o[0], l / 2), f = be(o[1], l / 2), d = -r.get("startAngle") * _Z, p = r.get("minAngle") * _Z, g = r.getData().tree.root, v = r.getViewRoot(), m = v.depth, y = r.get("sort");
    y != null && Fie(v, y);
    var b = 0;
    I(v.children, function(M) {
      !isNaN(M.getValue()) && b++;
    });
    var O = v.getValue(), w = Math.PI / (O || b) * 2, x = v.depth > 0, S = v.height - (x ? -1 : 1), _ = (f - h) / (S || 1), C = r.get("clockwise"), A = r.get("stillShowZeroSum"), k = C ? 1 : -1, P = function(M, R) {
      if (M) {
        var N = R;
        if (M !== g) {
          var $ = M.getValue(), F = O === 0 && A ? w : $ * w;
          F < p && (F = p), N = R + k * F;
          var W = M.depth - m - (x ? -1 : 1), j = h + _ * W, Y = h + _ * (W + 1), X = r.getLevelModel(M);
          if (X) {
            var ie = X.get("r0", !0), ae = X.get("r", !0), ee = X.get("radius", !0);
            ee != null && (ie = ee[0], ae = ee[1]), ie != null && (j = be(ie, l / 2)), ae != null && (Y = be(ae, l / 2));
          }
          M.setLayout({
            angle: F,
            startAngle: R,
            endAngle: N,
            clockwise: C,
            cx: u,
            cy: c,
            r0: j,
            r: Y
          });
        }
        if (M.children && M.children.length) {
          var ne = 0;
          I(M.children, function(ye) {
            ne += P(ye, R + ne);
          });
        }
        return N - R;
      }
    };
    if (x) {
      var L = h, D = h + _, E = Math.PI * 2;
      g.setLayout({
        angle: E,
        startAngle: d,
        endAngle: d + E,
        clockwise: C,
        cx: u,
        cy: c,
        r0: L,
        r: D
      });
    }
    P(v, d);
  });
}
function Fie(n, e) {
  var t = n.children || [];
  n.children = v$t(t, e), t.length && I(n.children, function(r) {
    Fie(r, e);
  });
}
function v$t(n, e) {
  if (Le(e)) {
    var t = le(n, function(i, o) {
      var a = i.getValue();
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function() {
            return a;
          }
        },
        index: o
      };
    });
    return t.sort(function(i, o) {
      return e(i.params, o.params);
    }), le(t, function(i) {
      return n[i.index];
    });
  } else {
    var r = e === "asc";
    return n.sort(function(i, o) {
      var a = (i.getValue() - o.getValue()) * (r ? 1 : -1);
      return a === 0 ? (i.dataIndex - o.dataIndex) * (r ? -1 : 1) : a;
    });
  }
}
function m$t(n) {
  var e = {};
  function t(r, i, o) {
    for (var a = r; a && a.depth > 1; )
      a = a.parentNode;
    var s = i.getColorFromPalette(a.name || a.dataIndex + "", e);
    return r.depth > 1 && we(s) && (s = wM(s, (r.depth - 1) / (o - 1) * 0.5)), s;
  }
  n.eachSeriesByType("sunburst", function(r) {
    var i = r.getData(), o = i.tree;
    o.eachNode(function(a) {
      var s = a.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = t(a, r, o.root.height));
      var u = i.ensureUniqueItemVisual(a.dataIndex, "style");
      re(u, l);
    });
  });
}
function y$t(n) {
  n.registerChartView(f$t), n.registerSeriesModel(p$t), n.registerLayout(Je(g$t, "sunburst")), n.registerProcessor(Je(Ub, "sunburst")), n.registerVisual(m$t), c$t(n);
}
var CZ = {
  color: "fill",
  borderColor: "stroke"
}, b$t = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, ru = It(), O$t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, e.prototype.getInitialData = function(t, r) {
      return ku(null, this);
    }, e.prototype.getDataParams = function(t, r, i) {
      var o = n.prototype.getDataParams.call(this, t, r);
      return i && (o.info = ru(i).info), o;
    }, e.type = "series.custom", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, e;
  }(Ln)
);
const w$t = O$t;
function x$t(n, e) {
  return e = e || [0, 0], le(["x", "y"], function(t, r) {
    var i = this.getAxis(t), o = e[r], a = n[r] / 2;
    return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(o - a) - i.dataToCoord(o + a));
  }, this);
}
function S$t(n) {
  var e = n.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return n.dataToPoint(t);
      },
      size: _e(x$t, n)
    }
  };
}
function _$t(n, e) {
  return e = e || [0, 0], le([0, 1], function(t) {
    var r = e[t], i = n[t] / 2, o = [], a = [];
    return o[t] = r - i, a[t] = r + i, o[1 - t] = a[1 - t] = e[1 - t], Math.abs(this.dataToPoint(o)[t] - this.dataToPoint(a)[t]);
  }, this);
}
function C$t(n) {
  var e = n.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      zoom: n.getZoom()
    },
    api: {
      coord: function(t) {
        return n.dataToPoint(t);
      },
      size: _e(_$t, n)
    }
  };
}
function A$t(n, e) {
  var t = this.getAxis(), r = e instanceof Array ? e[0] : e, i = (n instanceof Array ? n[0] : n) / 2;
  return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(r - i) - t.dataToCoord(r + i));
}
function T$t(n) {
  var e = n.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return n.dataToPoint(t);
      },
      size: _e(A$t, n)
    }
  };
}
function k$t(n, e) {
  return e = e || [0, 0], le(["Radius", "Angle"], function(t, r) {
    var i = "get" + t + "Axis", o = this[i](), a = e[r], s = n[r] / 2, l = o.type === "category" ? o.getBandWidth() : Math.abs(o.dataToCoord(a - s) - o.dataToCoord(a + s));
    return t === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function P$t(n) {
  var e = n.getRadiusAxis(), t = n.getAngleAxis(), r = e.getExtent();
  return r[0] > r[1] && r.reverse(), {
    coordSys: {
      type: "polar",
      cx: n.cx,
      cy: n.cy,
      r: r[1],
      r0: r[0]
    },
    api: {
      coord: function(i) {
        var o = e.dataToRadius(i[0]), a = t.dataToAngle(i[1]), s = n.coordToPoint([o, a]);
        return s.push(o, a * Math.PI / 180), s;
      },
      size: _e(k$t, n)
    }
  };
}
function E$t(n) {
  var e = n.getRect(), t = n.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      cellWidth: n.getCellWidth(),
      cellHeight: n.getCellHeight(),
      rangeInfo: {
        start: t.start,
        end: t.end,
        weeks: t.weeks,
        dayCount: t.allDay
      }
    },
    api: {
      coord: function(r, i) {
        return n.dataToPoint(r, i);
      }
    }
  };
}
var AZ = {};
function Qie(n, e, t, r) {
  return n && (n.legacy || n.legacy !== !1 && !t && !r && e !== "tspan" && (e === "text" || Ce(n, "text")));
}
function Zie(n, e, t) {
  var r = n, i, o, a;
  if (e === "text")
    a = r;
  else {
    a = {}, Ce(r, "text") && (a.text = r.text), Ce(r, "rich") && (a.rich = r.rich), Ce(r, "textFill") && (a.fill = r.textFill), Ce(r, "textStroke") && (a.stroke = r.textStroke), Ce(r, "fontFamily") && (a.fontFamily = r.fontFamily), Ce(r, "fontSize") && (a.fontSize = r.fontSize), Ce(r, "fontStyle") && (a.fontStyle = r.fontStyle), Ce(r, "fontWeight") && (a.fontWeight = r.fontWeight), o = {
      type: "text",
      style: a,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, i = {};
    var s = Ce(r, "textPosition");
    t ? i.position = s ? r.textPosition : "inside" : s && (i.position = r.textPosition), Ce(r, "textPosition") && (i.position = r.textPosition), Ce(r, "textOffset") && (i.offset = r.textOffset), Ce(r, "textRotation") && (i.rotation = r.textRotation), Ce(r, "textDistance") && (i.distance = r.textDistance);
  }
  return TZ(a, n), I(a.rich, function(l) {
    TZ(l, l);
  }), {
    textConfig: i,
    textContent: o
  };
}
function TZ(n, e) {
  e && (e.font = e.textFont || e.font, Ce(e, "textStrokeWidth") && (n.lineWidth = e.textStrokeWidth), Ce(e, "textAlign") && (n.align = e.textAlign), Ce(e, "textVerticalAlign") && (n.verticalAlign = e.textVerticalAlign), Ce(e, "textLineHeight") && (n.lineHeight = e.textLineHeight), Ce(e, "textWidth") && (n.width = e.textWidth), Ce(e, "textHeight") && (n.height = e.textHeight), Ce(e, "textBackgroundColor") && (n.backgroundColor = e.textBackgroundColor), Ce(e, "textPadding") && (n.padding = e.textPadding), Ce(e, "textBorderColor") && (n.borderColor = e.textBorderColor), Ce(e, "textBorderWidth") && (n.borderWidth = e.textBorderWidth), Ce(e, "textBorderRadius") && (n.borderRadius = e.textBorderRadius), Ce(e, "textBoxShadowColor") && (n.shadowColor = e.textBoxShadowColor), Ce(e, "textBoxShadowBlur") && (n.shadowBlur = e.textBoxShadowBlur), Ce(e, "textBoxShadowOffsetX") && (n.shadowOffsetX = e.textBoxShadowOffsetX), Ce(e, "textBoxShadowOffsetY") && (n.shadowOffsetY = e.textBoxShadowOffsetY));
}
function kZ(n, e, t) {
  var r = n;
  r.textPosition = r.textPosition || t.position || "inside", t.offset != null && (r.textOffset = t.offset), t.rotation != null && (r.textRotation = t.rotation), t.distance != null && (r.textDistance = t.distance);
  var i = r.textPosition.indexOf("inside") >= 0, o = n.fill || "#000";
  PZ(r, e);
  var a = r.textFill == null;
  return i ? a && (r.textFill = t.insideFill || "#fff", !r.textStroke && t.insideStroke && (r.textStroke = t.insideStroke), !r.textStroke && (r.textStroke = o), r.textStrokeWidth == null && (r.textStrokeWidth = 2)) : (a && (r.textFill = n.fill || t.outsideFill || "#000"), !r.textStroke && t.outsideStroke && (r.textStroke = t.outsideStroke)), r.text = e.text, r.rich = e.rich, I(e.rich, function(s) {
    PZ(s, s);
  }), r;
}
function PZ(n, e) {
  e && (Ce(e, "fill") && (n.textFill = e.fill), Ce(e, "stroke") && (n.textStroke = e.fill), Ce(e, "lineWidth") && (n.textStrokeWidth = e.lineWidth), Ce(e, "font") && (n.font = e.font), Ce(e, "fontStyle") && (n.fontStyle = e.fontStyle), Ce(e, "fontWeight") && (n.fontWeight = e.fontWeight), Ce(e, "fontSize") && (n.fontSize = e.fontSize), Ce(e, "fontFamily") && (n.fontFamily = e.fontFamily), Ce(e, "align") && (n.textAlign = e.align), Ce(e, "verticalAlign") && (n.textVerticalAlign = e.verticalAlign), Ce(e, "lineHeight") && (n.textLineHeight = e.lineHeight), Ce(e, "width") && (n.textWidth = e.width), Ce(e, "height") && (n.textHeight = e.height), Ce(e, "backgroundColor") && (n.textBackgroundColor = e.backgroundColor), Ce(e, "padding") && (n.textPadding = e.padding), Ce(e, "borderColor") && (n.textBorderColor = e.borderColor), Ce(e, "borderWidth") && (n.textBorderWidth = e.borderWidth), Ce(e, "borderRadius") && (n.textBorderRadius = e.borderRadius), Ce(e, "shadowColor") && (n.textBoxShadowColor = e.shadowColor), Ce(e, "shadowBlur") && (n.textBoxShadowBlur = e.shadowBlur), Ce(e, "shadowOffsetX") && (n.textBoxShadowOffsetX = e.shadowOffsetX), Ce(e, "shadowOffsetY") && (n.textBoxShadowOffsetY = e.shadowOffsetY), Ce(e, "textShadowColor") && (n.textShadowColor = e.textShadowColor), Ce(e, "textShadowBlur") && (n.textShadowBlur = e.textShadowBlur), Ce(e, "textShadowOffsetX") && (n.textShadowOffsetX = e.textShadowOffsetX), Ce(e, "textShadowOffsetY") && (n.textShadowOffsetY = e.textShadowOffsetY));
}
function EZ(n, e) {
  if (process.env.NODE_ENV !== "production") {
    var t = n + "^_^" + e;
    AZ[t] || (console.warn('[ECharts] DEPRECATED: "' + n + '" has been deprecated. ' + e), AZ[t] = !0);
  }
}
var Wie = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, MZ = Ot(Wie), WS = xl(_l, function(n, e) {
  return n[e] = 1, n;
}, {}), DZ = _l.join(", "), GS = ["", "style", "shape", "extra"], nv = It();
function o$(n, e, t, r, i) {
  var o = n + "Animation", a = Lv(n, r, i) || {}, s = nv(e).userDuring;
  return a.duration > 0 && (a.during = s ? _e(R$t, {
    el: e,
    userDuring: s
  }) : null, a.setToFinal = !0, a.scope = n), re(a, t[o]), a;
}
function Jw(n, e, t, r) {
  r = r || {};
  var i = r.dataIndex, o = r.isInit, a = r.clearStyle, s = t.isAnimationEnabled(), l = nv(n), u = e.style;
  l.userDuring = e.during;
  var c = {}, h = {};
  if ($$t(n, e, h), IZ("shape", e, h), IZ("extra", e, h), !o && s && (N$t(n, e, c), LZ("shape", n, e, c), LZ("extra", n, e, c), B$t(n, e, u, c)), h.style = u, M$t(n, h, a), L$t(n, e), s)
    if (o) {
      var f = {};
      I(GS, function(p) {
        var g = p ? e[p] : e;
        g && g.enterFrom && (p && (f[p] = f[p] || {}), re(p ? f[p] : f, g.enterFrom));
      });
      var d = o$("enter", n, e, t, i);
      d.duration > 0 && n.animateFrom(f, d);
    } else
      D$t(n, e, i || 0, t, c);
  Gie(n, e), u ? n.dirty() : n.markRedraw();
}
function Gie(n, e) {
  for (var t = nv(n).leaveToProps, r = 0; r < GS.length; r++) {
    var i = GS[r], o = i ? e[i] : e;
    o && o.leaveTo && (t || (t = nv(n).leaveToProps = {}), i && (t[i] = t[i] || {}), re(i ? t[i] : t, o.leaveTo));
  }
}
function XC(n, e, t, r) {
  if (n) {
    var i = n.parent, o = nv(n).leaveToProps;
    if (o) {
      var a = o$("update", n, e, t, 0);
      a.done = function() {
        i.remove(n), r && r();
      }, n.animateTo(o, a);
    } else
      i.remove(n), r && r();
  }
}
function Hf(n) {
  return n === "all";
}
function M$t(n, e, t) {
  var r = e.style;
  if (!n.isGroup && r) {
    if (t) {
      n.useStyle({});
      for (var i = n.animators, o = 0; o < i.length; o++) {
        var a = i[o];
        a.targetName === "style" && a.changeTarget(n.style);
      }
    }
    n.setStyle(r);
  }
  e && (e.style = null, e && n.attr(e), e.style = r);
}
function D$t(n, e, t, r, i) {
  if (i) {
    var o = o$("update", n, e, r, t);
    o.duration > 0 && n.animateFrom(i, o);
  }
}
function L$t(n, e) {
  Ce(e, "silent") && (n.silent = e.silent), Ce(e, "ignore") && (n.ignore = e.ignore), n instanceof Ia && Ce(e, "invisible") && (n.invisible = e.invisible), n instanceof gt && Ce(e, "autoBatch") && (n.autoBatch = e.autoBatch);
}
var $s = {}, I$t = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(n, e) {
    return process.env.NODE_ENV !== "production" && $e(Ce(WS, n), "Only " + DZ + " available in `setTransform`."), $s.el[n] = e, this;
  },
  getTransform: function(n) {
    return process.env.NODE_ENV !== "production" && $e(Ce(WS, n), "Only " + DZ + " available in `getTransform`."), $s.el[n];
  },
  setShape: function(n, e) {
    process.env.NODE_ENV !== "production" && dp(n);
    var t = $s.el, r = t.shape || (t.shape = {});
    return r[n] = e, t.dirtyShape && t.dirtyShape(), this;
  },
  getShape: function(n) {
    process.env.NODE_ENV !== "production" && dp(n);
    var e = $s.el.shape;
    if (e)
      return e[n];
  },
  setStyle: function(n, e) {
    process.env.NODE_ENV !== "production" && dp(n);
    var t = $s.el, r = t.style;
    return r && (process.env.NODE_ENV !== "production" && cd(e) && $n("style." + n + " must not be assigned with NaN."), r[n] = e, t.dirtyStyle && t.dirtyStyle()), this;
  },
  getStyle: function(n) {
    process.env.NODE_ENV !== "production" && dp(n);
    var e = $s.el.style;
    if (e)
      return e[n];
  },
  setExtra: function(n, e) {
    process.env.NODE_ENV !== "production" && dp(n);
    var t = $s.el.extra || ($s.el.extra = {});
    return t[n] = e, this;
  },
  getExtra: function(n) {
    process.env.NODE_ENV !== "production" && dp(n);
    var e = $s.el.extra;
    if (e)
      return e[n];
  }
};
function dp(n) {
  if (process.env.NODE_ENV !== "production" && (n === "transition" || n === "enterFrom" || n === "leaveTo"))
    throw new Error('key must not be "' + n + '"');
}
function R$t() {
  var n = this, e = n.el;
  if (e) {
    var t = nv(e).userDuring, r = n.userDuring;
    if (t !== r) {
      n.el = n.userDuring = null;
      return;
    }
    $s.el = e, r(I$t);
  }
}
function LZ(n, e, t, r) {
  var i = t[n];
  if (i) {
    var o = e[n], a;
    if (o) {
      var s = t.transition, l = i.transition;
      if (l)
        if (!a && (a = r[n] = {}), Hf(l))
          re(a, o);
        else
          for (var u = an(l), c = 0; c < u.length; c++) {
            var h = u[c], f = o[h];
            a[h] = f;
          }
      else if (Hf(s) || ct(s, n) >= 0) {
        !a && (a = r[n] = {});
        for (var d = Ot(o), c = 0; c < d.length; c++) {
          var h = d[c], f = o[h];
          V$t(i[h], f) && (a[h] = f);
        }
      }
    }
  }
}
function IZ(n, e, t) {
  var r = e[n];
  if (r)
    for (var i = t[n] = {}, o = Ot(r), a = 0; a < o.length; a++) {
      var s = o[a];
      i[s] = Dy(r[s]);
    }
}
function N$t(n, e, t) {
  for (var r = e.transition, i = Hf(r) ? _l : an(r || []), o = 0; o < i.length; o++) {
    var a = i[o];
    if (!(a === "style" || a === "shape" || a === "extra")) {
      var s = n[a];
      process.env.NODE_ENV !== "production" && jie(a, "el.transition"), t[a] = s;
    }
  }
}
function $$t(n, e, t) {
  for (var r = 0; r < MZ.length; r++) {
    var i = MZ[r], o = Wie[i], a = e[i];
    a && (t[o[0]] = a[0], t[o[1]] = a[1]);
  }
  for (var r = 0; r < _l.length; r++) {
    var s = _l[r];
    e[s] != null && (t[s] = e[s]);
  }
}
function B$t(n, e, t, r) {
  if (t) {
    var i = n.style, o;
    if (i) {
      var a = t.transition, s = e.transition;
      if (a && !Hf(a)) {
        var l = an(a);
        !o && (o = r.style = {});
        for (var u = 0; u < l.length; u++) {
          var c = l[u], h = i[c];
          o[c] = h;
        }
      } else if (n.getAnimationStyleProps && (Hf(s) || Hf(a) || ct(s, "style") >= 0)) {
        var f = n.getAnimationStyleProps(), d = f ? f.style : null;
        if (d) {
          !o && (o = r.style = {});
          for (var p = Ot(t), u = 0; u < p.length; u++) {
            var c = p[u];
            if (d[c]) {
              var h = i[c];
              o[c] = h;
            }
          }
        }
      }
    }
  }
}
function V$t(n, e) {
  return Ni(n) ? n !== e : n != null && isFinite(n);
}
var jie;
process.env.NODE_ENV !== "production" && (jie = function(n, e) {
  Ce(WS, n) || $n("Prop `" + n + "` is not a permitted in `" + e + "`. Only `" + Ot(WS).join("`, `") + "` are permitted.");
});
var Hie = It(), z$t = ["percent", "easing", "shape", "style", "extra"];
function qie(n) {
  n.stopAnimation("keyframe"), n.attr(Hie(n));
}
function jS(n, e, t) {
  if (!(!t.isAnimationEnabled() || !e)) {
    if (se(e)) {
      I(e, function(s) {
        jS(n, s, t);
      });
      return;
    }
    var r = e.keyframes, i = e.duration;
    if (t && i == null) {
      var o = Lv("enter", t, 0);
      i = o && o.duration;
    }
    if (!(!r || !i)) {
      var a = Hie(n);
      I(GS, function(s) {
        if (!(s && !n[s])) {
          var l, u = !1;
          r.sort(function(c, h) {
            return c.percent - h.percent;
          }), I(r, function(c) {
            var h = n.animators, f = s ? c[s] : c;
            if (process.env.NODE_ENV !== "production" && c.percent >= 1 && (u = !0), !!f) {
              var d = Ot(f);
              if (s || (d = en(d, function(v) {
                return ct(z$t, v) < 0;
              })), !!d.length) {
                l || (l = n.animate(s, e.loop, !0), l.scope = "keyframe");
                for (var p = 0; p < h.length; p++)
                  h[p] !== l && h[p].targetName === l.targetName && h[p].stopTracks(d);
                s && (a[s] = a[s] || {});
                var g = s ? a[s] : a;
                I(d, function(v) {
                  g[v] = ((s ? n[s] : n) || {})[v];
                }), l.whenWithKeys(i * c.percent, f, d, c.easing);
              }
            }
          }), l && (process.env.NODE_ENV !== "production" && (u || $n("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), l.delay(e.delay || 0).duration(i).start(e.easing));
        }
      });
    }
  }
}
var iu = "emphasis", bc = "normal", a$ = "blur", s$ = "select", eh = [bc, iu, a$, s$], bk = {
  normal: ["itemStyle"],
  emphasis: [iu, "itemStyle"],
  blur: [a$, "itemStyle"],
  select: [s$, "itemStyle"]
}, Ok = {
  normal: ["label"],
  emphasis: [iu, "label"],
  blur: [a$, "label"],
  select: [s$, "label"]
}, F$t = ["x", "y"], Q$t = "e\0\0", ra = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, RZ = {
  cartesian2d: S$t,
  geo: C$t,
  single: T$t,
  polar: P$t,
  calendar: E$t
};
function HS(n) {
  return n instanceof gt;
}
function ID(n) {
  return n instanceof Ia;
}
function Z$t(n, e) {
  e.copyTransform(n), ID(e) && ID(n) && (e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel, e.invisible = n.invisible, e.ignore = n.ignore, HS(e) && HS(n) && e.setShape(n.shape));
}
var W$t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, o) {
      this._progressiveEls = null;
      var a = this._data, s = t.getData(), l = this.group, u = NZ(t, s, r, i);
      a || l.removeAll(), s.diff(a).add(function(h) {
        wk(i, null, h, u(h, o), t, l, s);
      }).remove(function(h) {
        var f = a.getItemGraphicEl(h);
        f && XC(f, ru(f).option, t);
      }).update(function(h, f) {
        var d = a.getItemGraphicEl(f);
        wk(i, d, h, u(h, o), t, l, s);
      }).execute();
      var c = t.get("clip", !0) ? Yb(t.coordinateSystem, !1, t) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this.group.removeAll(), this._data = null;
    }, e.prototype.incrementalRender = function(t, r, i, o, a) {
      var s = r.getData(), l = NZ(r, s, i, o), u = this._progressiveEls = [];
      function c(d) {
        d.isGroup || (d.incremental = !0, d.ensureState("emphasis").hoverLayer = !0);
      }
      for (var h = t.start; h < t.end; h++) {
        var f = wk(null, null, h, l(h, a), r, this.group, s);
        f && (f.traverse(c), u.push(f));
      }
    }, e.prototype.eachRendered = function(t) {
      dh(this._progressiveEls || this.group, t);
    }, e.prototype.filterForExposedEvent = function(t, r, i, o) {
      var a = r.element;
      if (a == null || i.name === a)
        return !0;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === a)
          return !0;
      return !1;
    }, e.type = "custom", e;
  }(bn)
);
const G$t = W$t;
function l$(n) {
  var e = n.type, t;
  if (e === "path") {
    var r = n.shape, i = r.width != null && r.height != null ? {
      x: r.x || 0,
      y: r.y || 0,
      width: r.width,
      height: r.height
    } : null, o = Uie(r);
    t = TC(o, null, i, r.layout || "center"), ru(t).customPathData = o;
  } else if (e === "image")
    t = new Si({}), ru(t).customImagePath = n.style.image;
  else if (e === "text")
    t = new Nt({});
  else if (e === "group")
    t = new We();
  else {
    if (e === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var a = qR(e);
    if (!a) {
      var s = "";
      process.env.NODE_ENV !== "production" && (s = 'graphic type "' + e + '" can not be found.'), Gt(s);
    }
    t = new a();
  }
  return ru(t).customGraphicType = e, t.name = n.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t;
}
function u$(n, e, t, r, i, o, a) {
  qie(e);
  var s = i && i.normal.cfg;
  s && e.setTextConfig(s), r && r.transition == null && (r.transition = F$t);
  var l = r && r.style;
  if (l) {
    if (e.type === "text") {
      var u = l;
      Ce(u, "textFill") && (u.fill = u.textFill), Ce(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var c = void 0, h = HS(e) ? l.decal : null;
    n && h && (h.dirty = !0, c = Ug(h, n)), l.__decalPattern = c;
  }
  if (ID(e) && l) {
    var c = l.__decalPattern;
    c && (l.decal = c);
  }
  Jw(e, r, o, {
    dataIndex: t,
    isInit: a,
    clearStyle: !0
  }), jS(e, r.keyframeAnimation, o);
}
function Yie(n, e, t, r, i) {
  var o = e.isGroup ? null : e, a = i && i[n].cfg;
  if (o) {
    var s = o.ensureState(n);
    if (r === !1) {
      var l = o.getState(n);
      l && (l.style = null);
    } else
      s.style = r || null;
    a && (s.textConfig = a), pd(o);
  }
}
function j$t(n, e, t) {
  if (!n.isGroup) {
    var r = n, i = t.currentZ, o = t.currentZLevel;
    r.z = i, r.zlevel = o;
    var a = e.z2;
    a != null && (r.z2 = a || 0);
    for (var s = 0; s < eh.length; s++)
      H$t(r, e, eh[s]);
  }
}
function H$t(n, e, t) {
  var r = t === bc, i = r ? e : qS(e, t), o = i ? i.z2 : null, a;
  o != null && (a = r ? n : n.ensureState(t), a.z2 = o || 0);
}
function NZ(n, e, t, r) {
  var i = n.get("renderItem"), o = n.coordinateSystem, a = {};
  o && (process.env.NODE_ENV !== "production" && ($e(i, "series.render is required."), $e(o.prepareCustoms || RZ[o.type], "This coordSys does not support custom series.")), a = o.prepareCustoms ? o.prepareCustoms(o) : RZ[o.type](o));
  for (var s = Be({
    getWidth: r.getWidth,
    getHeight: r.getHeight,
    getZr: r.getZr,
    getDevicePixelRatio: r.getDevicePixelRatio,
    value: O,
    style: x,
    ordinalRawValue: w,
    styleEmphasis: S,
    visual: A,
    barLayout: k,
    currentSeriesIndices: P,
    font: L
  }, a.api || {}), l = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: n.id,
    seriesName: n.name,
    seriesIndex: n.seriesIndex,
    coordSys: a.coordSys,
    dataInsideLength: e.count(),
    encode: q$t(n.getData())
  }, u, c, h = {}, f = {}, d = {}, p = {}, g = 0; g < eh.length; g++) {
    var v = eh[g];
    d[v] = n.getModel(bk[v]), p[v] = n.getModel(Ok[v]);
  }
  function m(D) {
    return D === u ? c || (c = e.getItemModel(D)) : e.getItemModel(D);
  }
  function y(D, E) {
    return e.hasItemOption ? D === u ? h[E] || (h[E] = m(D).getModel(bk[E])) : m(D).getModel(bk[E]) : d[E];
  }
  function b(D, E) {
    return e.hasItemOption ? D === u ? f[E] || (f[E] = m(D).getModel(Ok[E])) : m(D).getModel(Ok[E]) : p[E];
  }
  return function(D, E) {
    return u = D, c = null, h = {}, f = {}, i && i(Be({
      dataIndexInside: D,
      dataIndex: e.getRawIndex(D),
      // Can be used for optimization when zoom or roam.
      actionType: E ? E.type : null
    }, l), s);
  };
  function O(D, E) {
    return E == null && (E = u), e.getStore().get(e.getDimensionIndex(D || 0), E);
  }
  function w(D, E) {
    E == null && (E = u), D = D || 0;
    var M = e.getDimensionInfo(D);
    if (!M) {
      var R = e.getDimensionIndex(D);
      return R >= 0 ? e.getStore().get(R, E) : void 0;
    }
    var N = e.get(M.name, E), $ = M && M.ordinalMeta;
    return $ ? $.categories[N] : N;
  }
  function x(D, E) {
    process.env.NODE_ENV !== "production" && EZ("api.style", "Please write literal style directly instead."), E == null && (E = u);
    var M = e.getItemVisual(E, "style"), R = M && M.fill, N = M && M.opacity, $ = y(E, bc).getItemStyle();
    R != null && ($.fill = R), N != null && ($.opacity = N);
    var F = {
      inheritColor: we(R) ? R : "#000"
    }, W = b(E, bc), j = vn(W, null, F, !1, !0);
    j.text = W.getShallow("show") ? qe(n.getFormattedLabel(E, bc), Jg(e, E)) : null;
    var Y = OS(W, F, !1);
    return C(D, $), $ = kZ($, j, Y), D && _($, D), $.legacy = !0, $;
  }
  function S(D, E) {
    process.env.NODE_ENV !== "production" && EZ("api.styleEmphasis", "Please write literal style directly instead."), E == null && (E = u);
    var M = y(E, iu).getItemStyle(), R = b(E, iu), N = vn(R, null, null, !0, !0);
    N.text = R.getShallow("show") ? Aa(n.getFormattedLabel(E, iu), n.getFormattedLabel(E, bc), Jg(e, E)) : null;
    var $ = OS(R, null, !0);
    return C(D, M), M = kZ(M, N, $), D && _(M, D), M.legacy = !0, M;
  }
  function _(D, E) {
    for (var M in E)
      Ce(E, M) && (D[M] = E[M]);
  }
  function C(D, E) {
    D && (D.textFill && (E.textFill = D.textFill), D.textPosition && (E.textPosition = D.textPosition));
  }
  function A(D, E) {
    if (E == null && (E = u), Ce(CZ, D)) {
      var M = e.getItemVisual(E, "style");
      return M ? M[CZ[D]] : null;
    }
    if (Ce(b$t, D))
      return e.getItemVisual(E, D);
  }
  function k(D) {
    if (o.type === "cartesian2d") {
      var E = o.getBaseAxis();
      return hTt(Be({
        axis: E
      }, D));
    }
  }
  function P() {
    return t.getCurrentSeriesIndices();
  }
  function L(D) {
    return YR(D, t);
  }
}
function q$t(n) {
  var e = {};
  return I(n.dimensions, function(t) {
    var r = n.getDimensionInfo(t);
    if (!r.isExtraCoord) {
      var i = r.coordDim, o = e[i] = e[i] || [];
      o[r.coordDimIndex] = n.getDimensionIndex(t);
    }
  }), e;
}
function wk(n, e, t, r, i, o, a) {
  if (!r) {
    o.remove(e);
    return;
  }
  var s = c$(n, e, t, r, i, o);
  return s && a.setItemGraphicEl(t, s), s && Wn(s, r.focus, r.blurScope, r.emphasisDisabled), s;
}
function c$(n, e, t, r, i, o) {
  process.env.NODE_ENV !== "production" && $e(r, "should not have an null/undefined element setting");
  var a = -1, s = e;
  e && Xie(e, r, i) && (a = ct(o.childrenRef(), e), e = null);
  var l = !e, u = e;
  u ? u.clearStates() : (u = l$(r), s && Z$t(s, u)), r.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), ra.normal.cfg = ra.normal.conOpt = ra.emphasis.cfg = ra.emphasis.conOpt = ra.blur.cfg = ra.blur.conOpt = ra.select.cfg = ra.select.conOpt = null, ra.isLegacy = !1, X$t(u, t, r, i, l, ra), Y$t(u, t, r, i, l), u$(n, u, t, r, ra, i, l), Ce(r, "info") && (ru(u).info = r.info);
  for (var c = 0; c < eh.length; c++) {
    var h = eh[c];
    if (h !== bc) {
      var f = qS(r, h), d = h$(r, f, h);
      Yie(h, u, f, d, ra);
    }
  }
  return j$t(u, r, i), r.type === "group" && U$t(n, u, t, r, i), a >= 0 ? o.replaceAt(u, a) : o.add(u), u;
}
function Xie(n, e, t) {
  var r = ru(n), i = e.type, o = e.shape, a = e.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    t.isUniversalTransitionEnabled() || i != null && i !== r.customGraphicType || i === "path" && t3t(o) && Uie(o) !== r.customPathData || i === "image" && Ce(a, "image") && a.image !== r.customImagePath
  );
}
function Y$t(n, e, t, r, i) {
  var o = t.clipPath;
  if (o === !1)
    n && n.getClipPath() && n.removeClipPath();
  else if (o) {
    var a = n.getClipPath();
    a && Xie(a, o, r) && (a = null), a || (a = l$(o), process.env.NODE_ENV !== "production" && $e(HS(a), "Only any type of `path` can be used in `clipPath`, rather than " + a.type + "."), n.setClipPath(a)), u$(null, a, e, o, null, r, i);
  }
}
function X$t(n, e, t, r, i, o) {
  if (!n.isGroup) {
    $Z(t, null, o), $Z(t, iu, o);
    var a = o.normal.conOpt, s = o.emphasis.conOpt, l = o.blur.conOpt, u = o.select.conOpt;
    if (a != null || s != null || u != null || l != null) {
      var c = n.getTextContent();
      if (a === !1)
        c && n.removeTextContent();
      else {
        a = o.normal.conOpt = a || {
          type: "text"
        }, c ? c.clearStates() : (c = l$(a), n.setTextContent(c)), u$(null, c, e, a, null, r, i);
        for (var h = a && a.style, f = 0; f < eh.length; f++) {
          var d = eh[f];
          if (d !== bc) {
            var p = o[d].conOpt;
            Yie(d, c, p, h$(a, p, d), null);
          }
        }
        h ? c.dirty() : c.markRedraw();
      }
    }
  }
}
function $Z(n, e, t) {
  var r = e ? qS(n, e) : n, i = e ? h$(n, r, iu) : n.style, o = n.type, a = r ? r.textConfig : null, s = n.textContent, l = s ? e ? qS(s, e) : s : null;
  if (i && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (t.isLegacy || Qie(i, o, !!a, !!l))) {
    t.isLegacy = !0;
    var u = Zie(i, o, !e);
    !a && u.textConfig && (a = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!e && l) {
    var c = l;
    !c.type && (c.type = "text"), process.env.NODE_ENV !== "production" && $e(c.type === "text", 'textContent.type must be "text"');
  }
  var h = e ? t[e] : t.normal;
  h.cfg = a, h.conOpt = l;
}
function qS(n, e) {
  return e ? n ? n[e] : null : n;
}
function h$(n, e, t) {
  var r = e && e.style;
  return r == null && t === iu && n && (r = n.styleEmphasis), r;
}
function U$t(n, e, t, r, i) {
  var o = r.children, a = o ? o.length : 0, s = r.$mergeChildren, l = s === "byName" || r.diffChildrenByName, u = s === !1;
  if (!(!a && !l && !u)) {
    if (l) {
      J$t({
        api: n,
        oldChildren: e.children() || [],
        newChildren: o || [],
        dataIndex: t,
        seriesModel: i,
        group: e
      });
      return;
    }
    u && e.removeAll();
    for (var c = 0; c < a; c++) {
      var h = o[c], f = e.childAt(c);
      h ? (h.ignore == null && (h.ignore = !1), c$(n, f, t, h, i, e)) : (process.env.NODE_ENV !== "production" && $e(f, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), f.ignore = !0);
    }
    for (var d = e.childCount() - 1; d >= c; d--) {
      var p = e.childAt(d);
      K$t(e, p, i);
    }
  }
}
function K$t(n, e, t) {
  e && XC(e, ru(n).option, t);
}
function J$t(n) {
  new mu(n.oldChildren, n.newChildren, BZ, BZ, n).add(VZ).update(VZ).remove(e3t).execute();
}
function BZ(n, e) {
  var t = n && n.name;
  return t ?? Q$t + e;
}
function VZ(n, e) {
  var t = this.context, r = n != null ? t.newChildren[n] : null, i = e != null ? t.oldChildren[e] : null;
  c$(t.api, i, t.dataIndex, r, t.seriesModel, t.group);
}
function e3t(n) {
  var e = this.context, t = e.oldChildren[n];
  t && XC(t, ru(t).option, e.seriesModel);
}
function Uie(n) {
  return n && (n.pathData || n.d);
}
function t3t(n) {
  return n && (Ce(n, "pathData") || Ce(n, "d"));
}
function n3t(n) {
  n.registerChartView(G$t), n.registerSeriesModel(w$t);
}
var lf = It(), zZ = Fe, xk = _e, r3t = (
  /** @class */
  function() {
    function n() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return n.prototype.render = function(e, t, r, i) {
      var o = t.get("value"), a = t.get("status");
      if (this._axisModel = e, this._axisPointerModel = t, this._api = r, !(!i && this._lastValue === o && this._lastStatus === a)) {
        this._lastValue = o, this._lastStatus = a;
        var s = this._group, l = this._handle;
        if (!a || a === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, o, e, t, r);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(r), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(e, t);
        if (!s)
          s = this._group = new We(), this.createPointerEl(s, u, e, t), this.createLabelEl(s, u, e, t), r.getZr().add(s);
        else {
          var f = Je(FZ, t, h);
          this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, t);
        }
        ZZ(s, t, !0), this._renderHandle(o);
      }
    }, n.prototype.remove = function(e) {
      this.clear(e);
    }, n.prototype.dispose = function(e) {
      this.clear(e);
    }, n.prototype.determineAnimation = function(e, t) {
      var r = t.get("animation"), i = e.axis, o = i.type === "category", a = t.get("snap");
      if (!a && !o)
        return !1;
      if (r === "auto" || r == null) {
        var s = this.animationThreshold;
        if (o && i.getBandWidth() > s)
          return !0;
        if (a) {
          var l = RN(e).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return r === !0;
    }, n.prototype.makeElOption = function(e, t, r, i, o) {
    }, n.prototype.createPointerEl = function(e, t, r, i) {
      var o = t.pointer;
      if (o) {
        var a = lf(e).pointerEl = new Dd[o.type](zZ(t.pointer));
        e.add(a);
      }
    }, n.prototype.createLabelEl = function(e, t, r, i) {
      if (t.label) {
        var o = lf(e).labelEl = new Nt(zZ(t.label));
        e.add(o), QZ(o, i);
      }
    }, n.prototype.updatePointerEl = function(e, t, r) {
      var i = lf(e).pointerEl;
      i && t.pointer && (i.setStyle(t.pointer.style), r(i, {
        shape: t.pointer.shape
      }));
    }, n.prototype.updateLabelEl = function(e, t, r, i) {
      var o = lf(e).labelEl;
      o && (o.setStyle(t.label.style), r(o, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: t.label.x,
        y: t.label.y
      }), QZ(o, i));
    }, n.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var t = this._axisPointerModel, r = this._api.getZr(), i = this._handle, o = t.getModel("handle"), a = t.get("status");
        if (!o.get("show") || !a || a === "hide") {
          i && r.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, i = this._handle = Qb(o.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            du(u.event);
          },
          onmousedown: xk(this._onHandleDragMove, this, 0, 0),
          drift: xk(this._onHandleDragMove, this),
          ondragend: xk(this._onHandleDragEnd, this)
        }), r.add(i)), ZZ(i, t, !1), i.setStyle(o.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = o.get("size");
        se(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Zv(this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s);
      }
    }, n.prototype._moveHandleToValue = function(e, t) {
      FZ(this._axisPointerModel, !t && this._moveAnimation, this._handle, Sk(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, n.prototype._onHandleDragMove = function(e, t) {
      var r = this._handle;
      if (r) {
        this._dragging = !0;
        var i = this.updateHandleTransform(Sk(r), [e, t], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, r.stopAnimation(), r.attr(Sk(i)), lf(r).lastProp = null, this._doDispatchAxisPointer();
      }
    }, n.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var t = this._payloadInfo, r = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: t.cursorPoint[0],
          y: t.cursorPoint[1],
          tooltipOption: t.tooltipOption,
          axesInfo: [{
            axisDim: r.axis.dim,
            axisIndex: r.componentIndex
          }]
        });
      }
    }, n.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var e = this._handle;
      if (e) {
        var t = this._axisPointerModel.get("value");
        this._moveHandleToValue(t), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, n.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var t = e.getZr(), r = this._group, i = this._handle;
      t && r && (this._lastGraphicKey = null, r && t.remove(r), i && t.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), Q0(this, "_doDispatchAxisPointer");
    }, n.prototype.doClear = function() {
    }, n.prototype.buildLabel = function(e, t, r) {
      return r = r || 0, {
        x: e[r],
        y: e[1 - r],
        width: t[r],
        height: t[1 - r]
      };
    }, n;
  }()
);
function FZ(n, e, t, r) {
  Kie(lf(t).lastProp, r) || (lf(t).lastProp = r, e ? Vt(t, r, n) : (t.stopAnimation(), t.attr(r)));
}
function Kie(n, e) {
  if (Ne(n) && Ne(e)) {
    var t = !0;
    return I(e, function(r, i) {
      t = t && Kie(n[i], r);
    }), !!t;
  } else
    return n === e;
}
function QZ(n, e) {
  n[e.get(["label", "show"]) ? "show" : "hide"]();
}
function Sk(n) {
  return {
    x: n.x || 0,
    y: n.y || 0,
    rotation: n.rotation || 0
  };
}
function ZZ(n, e, t) {
  var r = e.get("z"), i = e.get("zlevel");
  n && n.traverse(function(o) {
    o.type !== "group" && (r != null && (o.z = r), i != null && (o.zlevel = i), o.silent = t);
  });
}
const f$ = r3t;
function d$(n) {
  var e = n.get("type"), t = n.getModel(e + "Style"), r;
  return e === "line" ? (r = t.getLineStyle(), r.fill = null) : e === "shadow" && (r = t.getAreaStyle(), r.stroke = null), r;
}
function Jie(n, e, t, r, i) {
  var o = t.get("value"), a = eoe(o, e.axis, e.ecModel, t.get("seriesDataIndices"), {
    precision: t.get(["label", "precision"]),
    formatter: t.get(["label", "formatter"])
  }), s = t.getModel("label"), l = $v(s.get("padding") || 0), u = s.getFont(), c = $b(a, u), h = i.position, f = c.width + l[1] + l[3], d = c.height + l[0] + l[2], p = i.align;
  p === "right" && (h[0] -= f), p === "center" && (h[0] -= f / 2);
  var g = i.verticalAlign;
  g === "bottom" && (h[1] -= d), g === "middle" && (h[1] -= d / 2), i3t(h, f, d, r);
  var v = s.get("backgroundColor");
  (!v || v === "auto") && (v = e.get(["axisLine", "lineStyle", "color"])), n.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: h[0],
    y: h[1],
    style: vn(s, {
      text: a,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: v
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function i3t(n, e, t, r) {
  var i = r.getWidth(), o = r.getHeight();
  n[0] = Math.min(n[0] + e, i) - e, n[1] = Math.min(n[1] + t, o) - t, n[0] = Math.max(n[0], 0), n[1] = Math.max(n[1], 0);
}
function eoe(n, e, t, r, i) {
  n = e.scale.parse(n);
  var o = e.scale.getLabel({
    value: n
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: i.precision
  }), a = i.formatter;
  if (a) {
    var s = {
      value: CN(e, {
        value: n
      }),
      axisDimension: e.dim,
      axisIndex: e.index,
      seriesData: []
    };
    I(r, function(l) {
      var u = t.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
      h && s.seriesData.push(h);
    }), we(a) ? o = a.replace("{value}", o) : Le(a) && (o = a(s));
  }
  return o;
}
function p$(n, e, t) {
  var r = Ho();
  return Md(r, r, t.rotation), Sl(r, r, t.position), cs([n.dataToCoord(e), (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)], r);
}
function toe(n, e, t, r, i, o) {
  var a = Ji.innerTextLayout(t.rotation, 0, t.labelDirection);
  t.labelMargin = i.get(["label", "margin"]), Jie(e, r, i, o, {
    position: p$(r.axis, n, t),
    align: a.textAlign,
    verticalAlign: a.textVerticalAlign
  });
}
function g$(n, e, t) {
  return t = t || 0, {
    x1: n[t],
    y1: n[1 - t],
    x2: e[t],
    y2: e[1 - t]
  };
}
function noe(n, e, t) {
  return t = t || 0, {
    x: n[t],
    y: n[1 - t],
    width: e[t],
    height: e[1 - t]
  };
}
function WZ(n, e, t, r, i, o) {
  return {
    cx: n,
    cy: e,
    r0: t,
    r,
    startAngle: i,
    endAngle: o,
    clockwise: !0
  };
}
var o3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, o, a) {
      var s = i.axis, l = s.grid, u = o.get("type"), c = GZ(l, s).getOtherAxis(s).getGlobalExtent(), h = s.toGlobalCoord(s.dataToCoord(r, !0));
      if (u && u !== "none") {
        var f = d$(o), d = a3t[u](s, h, c);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = mD(l.model, i);
      toe(
        // @ts-ignore
        r,
        t,
        p,
        i,
        o,
        a
      );
    }, e.prototype.getHandleTransform = function(t, r, i) {
      var o = mD(r.axis.grid.model, r, {
        labelInside: !1
      });
      o.labelMargin = i.get(["handle", "margin"]);
      var a = p$(r.axis, t, o);
      return {
        x: a[0],
        y: a[1],
        rotation: o.rotation + (o.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, r, i, o) {
      var a = i.axis, s = a.grid, l = a.getGlobalExtent(!0), u = GZ(s, a).getOtherAxis(a).getGlobalExtent(), c = a.dim === "x" ? 0 : 1, h = [t.x, t.y];
      h[c] += r[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var f = (u[1] + u[0]) / 2, d = [f, f];
      d[c] = h[c];
      var p = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: h[0],
        y: h[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: p[c]
      };
    }, e;
  }(f$)
);
function GZ(n, e) {
  var t = {};
  return t[e.dim + "AxisIndex"] = e.index, n.getCartesian(t);
}
var a3t = {
  line: function(n, e, t) {
    var r = g$([e, t[0]], [e, t[1]], jZ(n));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: r
    };
  },
  shadow: function(n, e, t) {
    var r = Math.max(1, n.getBandWidth()), i = t[1] - t[0];
    return {
      type: "Rect",
      shape: noe([e - r / 2, t[0]], [r, i], jZ(n))
    };
  }
};
function jZ(n) {
  return n.dim === "x" ? 0 : 1;
}
const s3t = o3t;
var l3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "axisPointer", e.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, e;
  }(Pt)
);
const u3t = l3t;
var Xl = It(), c3t = I;
function roe(n, e, t) {
  if (!mt.node) {
    var r = e.getZr();
    Xl(r).records || (Xl(r).records = {}), h3t(r, e);
    var i = Xl(r).records[n] || (Xl(r).records[n] = {});
    i.handler = t;
  }
}
function h3t(n, e) {
  if (Xl(n).initialized)
    return;
  Xl(n).initialized = !0, t("click", Je(HZ, "click")), t("mousemove", Je(HZ, "mousemove")), t("globalout", d3t);
  function t(r, i) {
    n.on(r, function(o) {
      var a = p3t(e);
      c3t(Xl(n).records, function(s) {
        s && i(s, o, a.dispatchAction);
      }), f3t(a.pendings, e);
    });
  }
}
function f3t(n, e) {
  var t = n.showTip.length, r = n.hideTip.length, i;
  t ? i = n.showTip[t - 1] : r && (i = n.hideTip[r - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
}
function d3t(n, e, t) {
  n.handler("leave", null, t);
}
function HZ(n, e, t, r) {
  e.handler(n, t, r);
}
function p3t(n) {
  var e = {
    showTip: [],
    hideTip: []
  }, t = function(r) {
    var i = e[r.type];
    i ? i.push(r) : (r.dispatchAction = t, n.dispatchAction(r));
  };
  return {
    dispatchAction: t,
    pendings: e
  };
}
function RD(n, e) {
  if (!mt.node) {
    var t = e.getZr(), r = (Xl(t).records || {})[n];
    r && (Xl(t).records[n] = null);
  }
}
var g3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = r.getComponent("tooltip"), a = t.get("triggerOn") || o && o.get("triggerOn") || "mousemove|click";
      roe("axisPointer", i, function(s, l, u) {
        a !== "none" && (s === "leave" || a.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(t, r) {
      RD("axisPointer", r);
    }, e.prototype.dispose = function(t, r) {
      RD("axisPointer", r);
    }, e.type = "axisPointer", e;
  }(Gn)
);
const v3t = g3t;
function ioe(n, e) {
  var t = [], r = n.seriesIndex, i;
  if (r == null || !(i = e.getSeriesByIndex(r)))
    return {
      point: []
    };
  var o = i.getData(), a = fd(o, n);
  if (a == null || a < 0 || se(a))
    return {
      point: []
    };
  var s = o.getItemGraphicEl(a), l = i.coordinateSystem;
  if (i.getTooltipPosition)
    t = i.getTooltipPosition(a) || [];
  else if (l && l.dataToPoint)
    if (n.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, f = u.dim, d = h === "x" || h === "radius" ? 1 : 0, p = o.mapDimension(f), g = [];
      g[d] = o.get(p, a), g[1 - d] = o.get(o.getCalculationInfo("stackResultDimension"), a), t = l.dataToPoint(g) || [];
    } else
      t = l.dataToPoint(o.getValues(le(l.dimensions, function(m) {
        return o.mapDimension(m);
      }), a)) || [];
  else if (s) {
    var v = s.getBoundingRect().clone();
    v.applyTransform(s.transform), t = [v.x + v.width / 2, v.y + v.height / 2];
  }
  return {
    point: t,
    el: s
  };
}
var qZ = It();
function m3t(n, e, t) {
  var r = n.currTrigger, i = [n.x, n.y], o = n, a = n.dispatchAction || _e(t.dispatchAction, t), s = e.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    ex(i) && (i = ioe({
      seriesIndex: o.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: o.dataIndex
    }, e).point);
    var l = ex(i), u = o.axesInfo, c = s.axesInfo, h = r === "leave" || ex(i), f = {}, d = {}, p = {
      list: [],
      map: {}
    }, g = {
      showPointer: Je(b3t, d),
      showTooltip: Je(O3t, p)
    };
    I(s.coordSysMap, function(m, y) {
      var b = l || m.containPoint(i);
      I(s.coordSysAxesInfo[y], function(O, w) {
        var x = O.axis, S = _3t(u, O);
        if (!h && b && (!u || S)) {
          var _ = S && S.value;
          _ == null && !l && (_ = x.pointToData(i)), _ != null && YZ(O, _, g, !1, f);
        }
      });
    });
    var v = {};
    return I(c, function(m, y) {
      var b = m.linkGroup;
      b && !d[y] && I(b.axesInfo, function(O, w) {
        var x = d[w];
        if (O !== m && x) {
          var S = x.value;
          b.mapper && (S = m.axis.scale.parse(b.mapper(S, XZ(O), XZ(m)))), v[m.key] = S;
        }
      });
    }), I(v, function(m, y) {
      YZ(c[y], m, g, !0, f);
    }), w3t(d, c, f), x3t(p, i, n, a), S3t(c, a, t), f;
  }
}
function YZ(n, e, t, r, i) {
  var o = n.axis;
  if (!(o.scale.isBlank() || !o.containData(e))) {
    if (!n.involveSeries) {
      t.showPointer(n, e);
      return;
    }
    var a = y3t(e, n), s = a.payloadBatch, l = a.snapToValue;
    s[0] && i.seriesIndex == null && re(i, s[0]), !r && n.snap && o.containData(l) && l != null && (e = l), t.showPointer(n, e, s), t.showTooltip(n, a, l);
  }
}
function y3t(n, e) {
  var t = e.axis, r = t.dim, i = n, o = [], a = Number.MAX_VALUE, s = -1;
  return I(e.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(r), h, f;
    if (l.getAxisTooltipData) {
      var d = l.getAxisTooltipData(c, n, t);
      f = d.dataIndices, h = d.nestestValue;
    } else {
      if (f = l.getData().indicesOfNearest(
        c[0],
        n,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        t.type === "category" ? 0.5 : null
      ), !f.length)
        return;
      h = l.getData().get(c[0], f[0]);
    }
    if (!(h == null || !isFinite(h))) {
      var p = n - h, g = Math.abs(p);
      g <= a && ((g < a || p >= 0 && s < 0) && (a = g, s = p, i = h, o.length = 0), I(f, function(v) {
        o.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: v,
          dataIndex: l.getData().getRawIndex(v)
        });
      }));
    }
  }), {
    payloadBatch: o,
    snapToValue: i
  };
}
function b3t(n, e, t, r) {
  n[e.key] = {
    value: t,
    payloadBatch: r
  };
}
function O3t(n, e, t, r) {
  var i = t.payloadBatch, o = e.axis, a = o.model, s = e.axisPointerModel;
  if (!(!e.triggerTooltip || !i.length)) {
    var l = e.coordSys.model, u = Y0(l), c = n.map[u];
    c || (c = n.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, n.list.push(c)), c.dataByAxis.push({
      axisDim: o.dim,
      axisIndex: a.componentIndex,
      axisType: a.type,
      axisId: a.id,
      value: r,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: i.slice()
    });
  }
}
function w3t(n, e, t) {
  var r = t.axesInfo = [];
  I(e, function(i, o) {
    var a = i.axisPointerModel.option, s = n[o];
    s ? (!i.useHandle && (a.status = "show"), a.value = s.value, a.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (a.status = "hide"), a.status === "show" && r.push({
      axisDim: i.axis.dim,
      axisIndex: i.axis.model.componentIndex,
      value: a.value
    });
  });
}
function x3t(n, e, t, r) {
  if (ex(e) || !n.list.length) {
    r({
      type: "hideTip"
    });
    return;
  }
  var i = ((n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  r({
    type: "showTip",
    escapeConnect: !0,
    x: e[0],
    y: e[1],
    tooltipOption: t.tooltipOption,
    position: t.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: n.list
  });
}
function S3t(n, e, t) {
  var r = t.getZr(), i = "axisPointerLastHighlights", o = qZ(r)[i] || {}, a = qZ(r)[i] = {};
  I(n, function(u, c) {
    var h = u.axisPointerModel.option;
    h.status === "show" && u.triggerEmphasis && I(h.seriesDataIndices, function(f) {
      var d = f.seriesIndex + " | " + f.dataIndex;
      a[d] = f;
    });
  });
  var s = [], l = [];
  I(o, function(u, c) {
    !a[c] && l.push(u);
  }), I(a, function(u, c) {
    !o[c] && s.push(u);
  }), l.length && t.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && t.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function _3t(n, e) {
  for (var t = 0; t < (n || []).length; t++) {
    var r = n[t];
    if (e.axis.dim === r.axisDim && e.axis.model.componentIndex === r.axisIndex)
      return r;
  }
}
function XZ(n) {
  var e = n.axis.model, t = {}, r = t.axisDim = n.axis.dim;
  return t.axisIndex = t[r + "AxisIndex"] = e.componentIndex, t.axisName = t[r + "AxisName"] = e.name, t.axisId = t[r + "AxisId"] = e.id, t;
}
function ex(n) {
  return !n || n[0] == null || isNaN(n[0]) || n[1] == null || isNaN(n[1]);
}
function t1(n) {
  $d.registerAxisPointerClass("CartesianAxisPointer", s3t), n.registerComponentModel(u3t), n.registerComponentView(v3t), n.registerPreprocessor(function(e) {
    if (e) {
      (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
      var t = e.axisPointer.link;
      t && !se(t) && (e.axisPointer.link = [t]);
    }
  }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function(e, t) {
    e.getComponent("axisPointer").coordSysAxesInfo = xEt(e, t);
  }), n.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, m3t);
}
function C3t(n) {
  ft(Pre), ft(t1);
}
var A3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, o, a) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), h = s.dataToCoord(r), f = o.get("type");
      if (f && f !== "none") {
        var d = d$(o), p = k3t[f](s, l, h, c);
        p.style = d, t.graphicKey = p.type, t.pointer = p;
      }
      var g = o.get(["label", "margin"]), v = T3t(r, i, o, l, g);
      Jie(t, i, o, a, v);
    }, e;
  }(f$)
);
function T3t(n, e, t, r, i) {
  var o = e.axis, a = o.dataToCoord(n), s = r.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = r.getRadiusAxis().getExtent(), u, c, h;
  if (o.dim === "radius") {
    var f = Ho();
    Md(f, f, s), Sl(f, f, [r.cx, r.cy]), u = cs([a, -i], f);
    var d = e.getModel("axisLabel").get("rotate") || 0, p = Ji.innerTextLayout(s, d * Math.PI / 180, -1);
    c = p.textAlign, h = p.textVerticalAlign;
  } else {
    var g = l[1];
    u = r.coordToPoint([g + i, a]);
    var v = r.cx, m = r.cy;
    c = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", h = Math.abs(u[1] - m) / g < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
  }
  return {
    position: u,
    align: c,
    verticalAlign: h
  };
}
var k3t = {
  line: function(n, e, t, r) {
    return n.dim === "angle" ? {
      type: "Line",
      shape: g$(e.coordToPoint([r[0], t]), e.coordToPoint([r[1], t]))
    } : {
      type: "Circle",
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: t
      }
    };
  },
  shadow: function(n, e, t, r) {
    var i = Math.max(1, n.getBandWidth()), o = Math.PI / 180;
    return n.dim === "angle" ? {
      type: "Sector",
      shape: WZ(
        e.cx,
        e.cy,
        r[0],
        r[1],
        // In ECharts y is negative if angle is positive
        (-t - i / 2) * o,
        (-t + i / 2) * o
      )
    } : {
      type: "Sector",
      shape: WZ(e.cx, e.cy, t - i / 2, t + i / 2, 0, Math.PI * 2)
    };
  }
};
const P3t = A3t;
var E3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.findAxisModel = function(t) {
      var r, i = this.ecModel;
      return i.eachComponent(t, function(o) {
        o.getCoordSysModel() === this && (r = o);
      }, this), r;
    }, e.type = "polar", e.dependencies = ["radiusAxis", "angleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, e;
  }(Pt)
);
const M3t = E3t;
var v$ = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", cr).models[0];
    }, e.type = "polarAxis", e;
  }(Pt)
);
mr(v$, jb);
var D3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "angleAxis", e;
  }(v$)
), L3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "radiusAxis", e;
  }(v$)
), m$ = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r) {
      return n.call(this, "radius", t, r) || this;
    }
    return e.prototype.pointToData = function(t, r) {
      return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1];
    }, e;
  }(As)
);
m$.prototype.dataToRadius = As.prototype.dataToCoord;
m$.prototype.radiusToData = As.prototype.coordToData;
var I3t = It(), y$ = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r) {
      return n.call(this, "angle", t, r || [0, 360]) || this;
    }
    return e.prototype.pointToData = function(t, r) {
      return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1];
    }, e.prototype.calculateCategoryInterval = function() {
      var t = this, r = t.getLabelModel(), i = t.scale, o = i.getExtent(), a = i.count();
      if (o[1] - o[0] < 1)
        return 0;
      var s = o[0], l = t.dataToCoord(s + 1) - t.dataToCoord(s), u = Math.abs(l), c = $b(s == null ? "" : s + "", r.getFont(), "center", "top"), h = Math.max(c.height, 7), f = h / u;
      isNaN(f) && (f = 1 / 0);
      var d = Math.max(0, Math.floor(f)), p = I3t(t.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - d) <= 1 && Math.abs(v - a) <= 1 && g > d ? d = g : (p.lastTickCount = a, p.lastAutoInterval = d), d;
    }, e;
  }(As)
);
y$.prototype.dataToAngle = As.prototype.dataToCoord;
y$.prototype.angleToData = As.prototype.coordToData;
var ooe = ["radius", "angle"], R3t = (
  /** @class */
  function() {
    function n(e) {
      this.dimensions = ooe, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new m$(), this._angleAxis = new y$(), this.axisPointerEnabled = !0, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return n.prototype.containPoint = function(e) {
      var t = this.pointToCoord(e);
      return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1]);
    }, n.prototype.containData = function(e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]);
    }, n.prototype.getAxis = function(e) {
      var t = "_" + e + "Axis";
      return this[t];
    }, n.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, n.prototype.getAxesByScale = function(e) {
      var t = [], r = this._angleAxis, i = this._radiusAxis;
      return r.scale.type === e && t.push(r), i.scale.type === e && t.push(i), t;
    }, n.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, n.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, n.prototype.getOtherAxis = function(e) {
      var t = this._angleAxis;
      return e === t ? this._radiusAxis : t;
    }, n.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, n.prototype.getTooltipAxes = function(e) {
      var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
      return {
        baseAxes: [t],
        otherAxes: [this.getOtherAxis(t)]
      };
    }, n.prototype.dataToPoint = function(e, t) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(e[0], t), this._angleAxis.dataToAngle(e[1], t)]);
    }, n.prototype.pointToData = function(e, t) {
      var r = this.pointToCoord(e);
      return [this._radiusAxis.radiusToData(r[0], t), this._angleAxis.angleToData(r[1], t)];
    }, n.prototype.pointToCoord = function(e) {
      var t = e[0] - this.cx, r = e[1] - this.cy, i = this.getAngleAxis(), o = i.getExtent(), a = Math.min(o[0], o[1]), s = Math.max(o[0], o[1]);
      i.inverse ? a = s - 360 : s = a + 360;
      var l = Math.sqrt(t * t + r * r);
      t /= l, r /= l;
      for (var u = Math.atan2(-r, t) / Math.PI * 180, c = u < a ? 1 : -1; u < a || u > s; )
        u += c * 360;
      return [l, u];
    }, n.prototype.coordToPoint = function(e) {
      var t = e[0], r = e[1] / 180 * Math.PI, i = Math.cos(r) * t + this.cx, o = -Math.sin(r) * t + this.cy;
      return [i, o];
    }, n.prototype.getArea = function() {
      var e = this.getAngleAxis(), t = this.getRadiusAxis(), r = t.getExtent().slice();
      r[0] > r[1] && r.reverse();
      var i = e.getExtent(), o = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: r[0],
        r: r[1],
        startAngle: -i[0] * o,
        endAngle: -i[1] * o,
        clockwise: e.inverse,
        contain: function(a, s) {
          var l = a - this.cx, u = s - this.cy, c = l * l + u * u - 1e-4, h = this.r, f = this.r0;
          return c <= h * h && c >= f * f;
        }
      };
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = UZ(t);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = UZ(t);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }()
);
function UZ(n) {
  var e = n.seriesModel, t = n.polarModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
const N3t = R3t;
function $3t(n, e, t) {
  var r = e.get("center"), i = t.getWidth(), o = t.getHeight();
  n.cx = be(r[0], i), n.cy = be(r[1], o);
  var a = n.getRadiusAxis(), s = Math.min(i, o) / 2, l = e.get("radius");
  l == null ? l = [0, "100%"] : se(l) || (l = [0, l]);
  var u = [be(l[0], s), be(l[1], s)];
  a.inverse ? a.setExtent(u[1], u[0]) : a.setExtent(u[0], u[1]);
}
function B3t(n, e) {
  var t = this, r = t.getAngleAxis(), i = t.getRadiusAxis();
  if (r.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), n.eachSeries(function(s) {
    if (s.coordinateSystem === t) {
      var l = s.getData();
      I(LS(l, "radius"), function(u) {
        i.scale.unionExtentFromData(l, u);
      }), I(LS(l, "angle"), function(u) {
        r.scale.unionExtentFromData(l, u);
      });
    }
  }), Kg(r.scale, r.model), Kg(i.scale, i.model), r.type === "category" && !r.onBand) {
    var o = r.getExtent(), a = 360 / r.scale.count();
    r.inverse ? o[1] += a : o[1] -= a, r.setExtent(o[0], o[1]);
  }
}
function V3t(n) {
  return n.mainType === "angleAxis";
}
function KZ(n, e) {
  var t;
  if (n.type = e.get("type"), n.scale = ZC(e), n.onBand = e.get("boundaryGap") && n.type === "category", n.inverse = e.get("inverse"), V3t(e)) {
    n.inverse = n.inverse !== e.get("clockwise");
    var r = e.get("startAngle"), i = (t = e.get("endAngle")) !== null && t !== void 0 ? t : r + (n.inverse ? -360 : 360);
    n.setExtent(r, i);
  }
  e.axis = n, n.model = e;
}
var z3t = {
  dimensions: ooe,
  create: function(n, e) {
    var t = [];
    return n.eachComponent("polar", function(r, i) {
      var o = new N3t(i + "");
      o.update = B3t;
      var a = o.getRadiusAxis(), s = o.getAngleAxis(), l = r.findAxisModel("radiusAxis"), u = r.findAxisModel("angleAxis");
      KZ(a, l), KZ(s, u), $3t(o, r, e), t.push(o), r.coordinateSystem = o, o.model = r;
    }), n.eachSeries(function(r) {
      if (r.get("coordinateSystem") === "polar") {
        var i = r.getReferringComponents("polar", cr).models[0];
        if (process.env.NODE_ENV !== "production" && !i)
          throw new Error('Polar "' + ur(r.get("polarIndex"), r.get("polarId"), 0) + '" not found');
        r.coordinateSystem = i.coordinateSystem;
      }
    }), t;
  }
};
const F3t = z3t;
var Q3t = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function GO(n, e, t) {
  e[1] > e[0] && (e = e.slice().reverse());
  var r = n.coordToPoint([e[0], t]), i = n.coordToPoint([e[1], t]);
  return {
    x1: r[0],
    y1: r[1],
    x2: i[0],
    y2: i[1]
  };
}
function jO(n) {
  var e = n.getRadiusAxis();
  return e.inverse ? 0 : 1;
}
function JZ(n) {
  var e = n[0], t = n[n.length - 1];
  e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && n.pop();
}
var Z3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, r) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = t.axis, o = i.polar, a = o.getRadiusAxis().getExtent(), s = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = le(i.getViewLabels(), function(c) {
          c = Fe(c);
          var h = i.scale, f = h.type === "ordinal" ? h.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(f), c;
        });
        JZ(u), JZ(s), I(Q3t, function(c) {
          t.get([c, "show"]) && (!i.scale.isBlank() || c === "axisLine") && W3t[c](this.group, t, o, s, l, a, u);
        }, this);
      }
    }, e.type = "angleAxis", e;
  }($d)
), W3t = {
  axisLine: function(n, e, t, r, i, o) {
    var a = e.getModel(["axisLine", "lineStyle"]), s = t.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = jO(t), h = c ? 0 : 1, f, d = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
    o[h] === 0 ? f = new Dd[d]({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: o[c],
        startAngle: -u[0] * l,
        endAngle: -u[1] * l,
        clockwise: s.inverse
      },
      style: a.getLineStyle(),
      z2: 1,
      silent: !0
    }) : f = new CC({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: o[c],
        r0: o[h]
      },
      style: a.getLineStyle(),
      z2: 1,
      silent: !0
    }), f.style.fill = null, n.add(f);
  },
  axisTick: function(n, e, t, r, i, o) {
    var a = e.getModel("axisTick"), s = (a.get("inside") ? -1 : 1) * a.get("length"), l = o[jO(t)], u = le(r, function(c) {
      return new Br({
        shape: GO(t, [l, l + s], c.coord)
      });
    });
    n.add(ma(u, {
      style: Be(a.getModel("lineStyle").getLineStyle(), {
        stroke: e.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(n, e, t, r, i, o) {
    if (i.length) {
      for (var a = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (a.get("inside") ? -1 : 1) * s.get("length"), u = o[jO(t)], c = [], h = 0; h < i.length; h++)
        for (var f = 0; f < i[h].length; f++)
          c.push(new Br({
            shape: GO(t, [u, u + l], i[h][f].coord)
          }));
      n.add(ma(c, {
        style: Be(s.getModel("lineStyle").getLineStyle(), Be(a.getLineStyle(), {
          stroke: e.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(n, e, t, r, i, o, a) {
    var s = e.getCategories(!0), l = e.getModel("axisLabel"), u = l.get("margin"), c = e.get("triggerEvent");
    I(a, function(h, f) {
      var d = l, p = h.tickValue, g = o[jO(t)], v = t.coordToPoint([g + u, h.coord]), m = t.cx, y = t.cy, b = Math.abs(v[0] - m) / g < 0.3 ? "center" : v[0] > m ? "left" : "right", O = Math.abs(v[1] - y) / g < 0.3 ? "middle" : v[1] > y ? "top" : "bottom";
      if (s && s[p]) {
        var w = s[p];
        Ne(w) && w.textStyle && (d = new mn(w.textStyle, l, l.ecModel));
      }
      var x = new Nt({
        silent: Ji.isLabelSilent(e),
        style: vn(d, {
          x: v[0],
          y: v[1],
          fill: d.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          text: h.formattedLabel,
          align: b,
          verticalAlign: O
        })
      });
      if (n.add(x), c) {
        var S = Ji.makeAxisEventDataBase(e);
        S.targetType = "axisLabel", S.value = h.rawLabel, He(x).eventData = S;
      }
    }, this);
  },
  splitLine: function(n, e, t, r, i, o) {
    var a = e.getModel("splitLine"), s = a.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], h = 0; h < r.length; h++) {
      var f = u++ % l.length;
      c[f] = c[f] || [], c[f].push(new Br({
        shape: GO(t, o, r[h].coord)
      }));
    }
    for (var h = 0; h < c.length; h++)
      n.add(ma(c[h], {
        style: Be({
          stroke: l[h % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: e.get("z")
      }));
  },
  minorSplitLine: function(n, e, t, r, i, o) {
    if (i.length) {
      for (var a = e.getModel("minorSplitLine"), s = a.getModel("lineStyle"), l = [], u = 0; u < i.length; u++)
        for (var c = 0; c < i[u].length; c++)
          l.push(new Br({
            shape: GO(t, o, i[u][c].coord)
          }));
      n.add(ma(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: e.get("z")
      }));
    }
  },
  splitArea: function(n, e, t, r, i, o) {
    if (r.length) {
      var a = e.getModel("splitArea"), s = a.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], h = Math.PI / 180, f = -r[0].coord * h, d = Math.min(o[0], o[1]), p = Math.max(o[0], o[1]), g = e.get("clockwise"), v = 1, m = r.length; v <= m; v++) {
        var y = v === m ? r[0].coord : r[v].coord, b = u++ % l.length;
        c[b] = c[b] || [], c[b].push(new Eo({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: d,
            r: p,
            startAngle: f,
            endAngle: -y * h,
            clockwise: g
          },
          silent: !0
        })), f = -y * h;
      }
      for (var v = 0; v < c.length; v++)
        n.add(ma(c[v], {
          style: Be({
            fill: l[v % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
const G3t = Z3t;
var j3t = ["axisLine", "axisTickLabel", "axisName"], H3t = ["splitLine", "splitArea", "minorSplitLine"], q3t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, r) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = this._axisGroup, o = this._axisGroup = new We();
        this.group.add(o);
        var a = t.axis, s = a.polar, l = s.getAngleAxis(), u = a.getTicksCoords(), c = a.getMinorTicksCoords(), h = l.getExtent()[0], f = a.getExtent(), d = X3t(s, t, h), p = new Ji(t, d);
        I(j3t, p.add, p), o.add(p.getGroup()), Fb(i, o, t), I(H3t, function(g) {
          t.get([g, "show"]) && !a.scale.isBlank() && Y3t[g](this.group, t, s, h, f, u, c);
        }, this);
      }
    }, e.type = "radiusAxis", e;
  }($d)
), Y3t = {
  splitLine: function(n, e, t, r, i, o) {
    var a = e.getModel("splitLine"), s = a.getModel("lineStyle"), l = s.get("color"), u = 0, c = t.getAngleAxis(), h = Math.PI / 180, f = c.getExtent(), d = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc";
    l = l instanceof Array ? l : [l];
    for (var p = [], g = 0; g < o.length; g++) {
      var v = u++ % l.length;
      p[v] = p[v] || [], p[v].push(new Dd[d]({
        shape: {
          cx: t.cx,
          cy: t.cy,
          // ensure circle radius >= 0
          r: Math.max(o[g].coord, 0),
          startAngle: -f[0] * h,
          endAngle: -f[1] * h,
          clockwise: c.inverse
        }
      }));
    }
    for (var g = 0; g < p.length; g++)
      n.add(ma(p[g], {
        style: Be({
          stroke: l[g % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(n, e, t, r, i, o, a) {
    if (a.length) {
      for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < a.length; c++)
        for (var h = 0; h < a[c].length; h++)
          u.push(new fh({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r: a[c][h].coord
            }
          }));
      n.add(ma(u, {
        style: Be({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(n, e, t, r, i, o) {
    if (o.length) {
      var a = e.getModel("splitArea"), s = a.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], h = o[0].coord, f = 1; f < o.length; f++) {
        var d = u++ % l.length;
        c[d] = c[d] || [], c[d].push(new Eo({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: h,
            r: o[f].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), h = o[f].coord;
      }
      for (var f = 0; f < c.length; f++)
        n.add(ma(c[f], {
          style: Be({
            fill: l[f % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function X3t(n, e, t) {
  return {
    position: [n.cx, n.cy],
    rotation: t / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: e.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
const U3t = q3t;
function aoe(n) {
  return n.get("stack") || "__ec_stack_" + n.seriesIndex;
}
function soe(n, e) {
  return e.dim + n.model.componentIndex;
}
function K3t(n, e, t) {
  var r = {}, i = J3t(en(e.getSeriesByType(n), function(o) {
    return !e.isSeriesFiltered(o) && o.coordinateSystem && o.coordinateSystem.type === "polar";
  }));
  e.eachSeriesByType(n, function(o) {
    if (o.coordinateSystem.type === "polar") {
      var a = o.getData(), s = o.coordinateSystem, l = s.getBaseAxis(), u = soe(s, l), c = aoe(o), h = i[u][c], f = h.offset, d = h.width, p = s.getOtherAxis(l), g = o.coordinateSystem.cx, v = o.coordinateSystem.cy, m = o.get("barMinHeight") || 0, y = o.get("barMinAngle") || 0;
      r[c] = r[c] || [];
      for (var b = a.mapDimension(p.dim), O = a.mapDimension(l.dim), w = Uc(
        a,
        b
        /* , baseDim */
      ), x = l.dim !== "radius" || !o.get("roundCap", !0), S = p.dataToCoord(0), _ = 0, C = a.count(); _ < C; _++) {
        var A = a.get(b, _), k = a.get(O, _), P = A >= 0 ? "p" : "n", L = S;
        w && (r[c][k] || (r[c][k] = {
          p: S,
          n: S
          // Negative stack
        }), L = r[c][k][P]);
        var D = void 0, E = void 0, M = void 0, R = void 0;
        if (p.dim === "radius") {
          var N = p.dataToCoord(A) - S, $ = l.dataToCoord(k);
          Math.abs(N) < m && (N = (N < 0 ? -1 : 1) * m), D = L, E = L + N, M = $ - f, R = M - d, w && (r[c][k][P] = E);
        } else {
          var F = p.dataToCoord(A, x) - S, W = l.dataToCoord(k);
          Math.abs(F) < y && (F = (F < 0 ? -1 : 1) * y), D = W + f, E = D + d, M = L, R = L + F, w && (r[c][k][P] = R);
        }
        a.setItemLayout(_, {
          cx: g,
          cy: v,
          r0: D,
          r: E,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -M * Math.PI / 180,
          endAngle: -R * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: M >= R
        });
      }
    }
  });
}
function J3t(n) {
  var e = {};
  I(n, function(r, i) {
    var o = r.getData(), a = r.coordinateSystem, s = a.getBaseAxis(), l = soe(a, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / o.count(), h = e[l] || {
      bandWidth: c,
      remainedWidth: c,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, f = h.stacks;
    e[l] = h;
    var d = aoe(r);
    f[d] || h.autoWidthCount++, f[d] = f[d] || {
      width: 0,
      maxWidth: 0
    };
    var p = be(r.get("barWidth"), c), g = be(r.get("barMaxWidth"), c), v = r.get("barGap"), m = r.get("barCategoryGap");
    p && !f[d].width && (p = Math.min(h.remainedWidth, p), f[d].width = p, h.remainedWidth -= p), g && (f[d].maxWidth = g), v != null && (h.gap = v), m != null && (h.categoryGap = m);
  });
  var t = {};
  return I(e, function(r, i) {
    t[i] = {};
    var o = r.stacks, a = r.bandWidth, s = be(r.categoryGap, a), l = be(r.gap, 1), u = r.remainedWidth, c = r.autoWidthCount, h = (u - s) / (c + (c - 1) * l);
    h = Math.max(h, 0), I(o, function(g, v) {
      var m = g.maxWidth;
      m && m < h && (m = Math.min(m, u), g.width && (m = Math.min(m, g.width)), u -= m, g.width = m, c--);
    }), h = (u - s) / (c + (c - 1) * l), h = Math.max(h, 0);
    var f = 0, d;
    I(o, function(g, v) {
      g.width || (g.width = h), d = g, f += g.width * (1 + l);
    }), d && (f -= d.width * l);
    var p = -f / 2;
    I(o, function(g, v) {
      t[i][v] = t[i][v] || {
        offset: p,
        width: g.width
      }, p += g.width * (1 + l);
    });
  }), t;
}
var eBt = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, tBt = {
  splitNumber: 5
}, nBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "polar", e;
  }(Gn)
);
function rBt(n) {
  ft(t1), $d.registerAxisPointerClass("PolarAxisPointer", P3t), n.registerCoordinateSystem("polar", F3t), n.registerComponentModel(M3t), n.registerComponentView(nBt), ev(n, "angle", D3t, eBt), ev(n, "radius", L3t, tBt), n.registerComponentView(G3t), n.registerComponentView(U3t), n.registerLayout(Je(K3t, "bar"));
}
function ND(n, e) {
  e = e || {};
  var t = n.coordinateSystem, r = n.axis, i = {}, o = r.position, a = r.orient, s = t.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  i.position = [a === "vertical" ? u.vertical[o] : l[0], a === "horizontal" ? u.horizontal[o] : l[3]];
  var c = {
    horizontal: 0,
    vertical: 1
  };
  i.rotation = Math.PI / 2 * c[a];
  var h = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = h[o], n.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), ur(e.labelInside, n.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var f = e.rotate;
  return f == null && (f = n.get(["axisLabel", "rotate"])), i.labelRotation = o === "top" ? -f : f, i.z2 = 1, i;
}
var iBt = ["axisLine", "axisTickLabel", "axisName"], oBt = ["splitArea", "splitLine"], aBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t;
    }
    return e.prototype.render = function(t, r, i, o) {
      var a = this.group;
      a.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new We();
      var l = ND(t), u = new Ji(t, l);
      I(iBt, u.add, u), a.add(this._axisGroup), a.add(u.getGroup()), I(oBt, function(c) {
        t.get([c, "show"]) && sBt[c](this, this.group, this._axisGroup, t);
      }, this), Fb(s, this._axisGroup, t), n.prototype.render.call(this, t, r, i, o);
    }, e.prototype.remove = function() {
      Are(this);
    }, e.type = "singleAxis", e;
  }($d)
), sBt = {
  splitLine: function(n, e, t, r) {
    var i = r.axis;
    if (!i.scale.isBlank()) {
      var o = r.getModel("splitLine"), a = o.getModel("lineStyle"), s = a.get("color");
      s = s instanceof Array ? s : [s];
      for (var l = a.get("width"), u = r.coordinateSystem.getRect(), c = i.isHorizontal(), h = [], f = 0, d = i.getTicksCoords({
        tickModel: o
      }), p = [], g = [], v = 0; v < d.length; ++v) {
        var m = i.toGlobalCoord(d[v].coord);
        c ? (p[0] = m, p[1] = u.y, g[0] = m, g[1] = u.y + u.height) : (p[0] = u.x, p[1] = m, g[0] = u.x + u.width, g[1] = m);
        var y = new Br({
          shape: {
            x1: p[0],
            y1: p[1],
            x2: g[0],
            y2: g[1]
          },
          silent: !0
        });
        Yg(y.shape, l);
        var b = f++ % s.length;
        h[b] = h[b] || [], h[b].push(y);
      }
      for (var O = a.getLineStyle(["color"]), v = 0; v < h.length; ++v)
        e.add(ma(h[v], {
          style: Be({
            stroke: s[v % s.length]
          }, O),
          silent: !0
        }));
    }
  },
  splitArea: function(n, e, t, r) {
    Cre(n, t, r, r);
  }
};
const lBt = aBt;
var loe = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getCoordSysModel = function() {
      return this;
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, e;
  }(Pt)
);
mr(loe, jb.prototype);
const _k = loe;
var uBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i, o, a) {
      var s = n.call(this, t, r, i) || this;
      return s.type = o || "value", s.position = a || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.pointToData = function(t, r) {
      return this.coordinateSystem.pointToData(t)[0];
    }, e;
  }(As)
);
const cBt = uBt;
var uoe = ["single"], hBt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "single", this.dimension = "single", this.dimensions = uoe, this.axisPointerEnabled = !0, this.model = e, this._init(e, t, r);
    }
    return n.prototype._init = function(e, t, r) {
      var i = this.dimension, o = new cBt(i, ZC(e), [0, 0], e.get("type"), e.get("position")), a = o.type === "category";
      o.onBand = a && e.get("boundaryGap"), o.inverse = e.get("inverse"), o.orient = e.get("orient"), e.axis = o, o.model = e, o.coordinateSystem = this, this._axis = o;
    }, n.prototype.update = function(e, t) {
      e.eachSeries(function(r) {
        if (r.coordinateSystem === this) {
          var i = r.getData();
          I(i.mapDimensionsAll(this.dimension), function(o) {
            this._axis.scale.unionExtentFromData(i, o);
          }, this), Kg(this._axis.scale, this._axis.model);
        }
      }, this);
    }, n.prototype.resize = function(e, t) {
      this._rect = Cr({
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      }, {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._adjustAxis();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._adjustAxis = function() {
      var e = this._rect, t = this._axis, r = t.isHorizontal(), i = r ? [0, e.width] : [0, e.height], o = t.inverse ? 1 : 0;
      t.setExtent(i[o], i[1 - o]), this._updateAxisTransform(t, r ? e.x : e.y);
    }, n.prototype._updateAxisTransform = function(e, t) {
      var r = e.getExtent(), i = r[0] + r[1], o = e.isHorizontal();
      e.toGlobalCoord = o ? function(a) {
        return a + t;
      } : function(a) {
        return i - a + t;
      }, e.toLocalCoord = o ? function(a) {
        return a - t;
      } : function(a) {
        return i - a + t;
      };
    }, n.prototype.getAxis = function() {
      return this._axis;
    }, n.prototype.getBaseAxis = function() {
      return this._axis;
    }, n.prototype.getAxes = function() {
      return [this._axis];
    }, n.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, n.prototype.containPoint = function(e) {
      var t = this.getRect(), r = this.getAxis(), i = r.orient;
      return i === "horizontal" ? r.contain(r.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : r.contain(r.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height;
    }, n.prototype.pointToData = function(e) {
      var t = this.getAxis();
      return [t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))];
    }, n.prototype.dataToPoint = function(e) {
      var t = this.getAxis(), r = this.getRect(), i = [], o = t.orient === "horizontal" ? 0 : 1;
      return e instanceof Array && (e = e[0]), i[o] = t.toGlobalCoord(t.dataToCoord(+e)), i[1 - o] = o === 0 ? r.y + r.height / 2 : r.x + r.width / 2, i;
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = eW(t);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = eW(t);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }()
);
function eW(n) {
  var e = n.seriesModel, t = n.singleAxisModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
function fBt(n, e) {
  var t = [];
  return n.eachComponent("singleAxis", function(r, i) {
    var o = new hBt(r, n, e);
    o.name = "single_" + i, o.resize(r, e), r.coordinateSystem = o, t.push(o);
  }), n.eachSeries(function(r) {
    if (r.get("coordinateSystem") === "singleAxis") {
      var i = r.getReferringComponents("singleAxis", cr).models[0];
      r.coordinateSystem = i && i.coordinateSystem;
    }
  }), t;
}
var dBt = {
  create: fBt,
  dimensions: uoe
};
const pBt = dBt;
var tW = ["x", "y"], gBt = ["width", "height"], vBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, o, a) {
      var s = i.axis, l = s.coordinateSystem, u = Ck(l, 1 - YS(s)), c = l.dataToPoint(r)[0], h = o.get("type");
      if (h && h !== "none") {
        var f = d$(o), d = mBt[h](s, c, u);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = ND(i);
      toe(
        // @ts-ignore
        r,
        t,
        p,
        i,
        o,
        a
      );
    }, e.prototype.getHandleTransform = function(t, r, i) {
      var o = ND(r, {
        labelInside: !1
      });
      o.labelMargin = i.get(["handle", "margin"]);
      var a = p$(r.axis, t, o);
      return {
        x: a[0],
        y: a[1],
        rotation: o.rotation + (o.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, r, i, o) {
      var a = i.axis, s = a.coordinateSystem, l = YS(a), u = Ck(s, l), c = [t.x, t.y];
      c[l] += r[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var h = Ck(s, 1 - l), f = (h[1] + h[0]) / 2, d = [f, f];
      return d[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, e;
  }(f$)
), mBt = {
  line: function(n, e, t) {
    var r = g$([e, t[0]], [e, t[1]], YS(n));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: r
    };
  },
  shadow: function(n, e, t) {
    var r = n.getBandWidth(), i = t[1] - t[0];
    return {
      type: "Rect",
      shape: noe([e - r / 2, t[0]], [r, i], YS(n))
    };
  }
};
function YS(n) {
  return n.isHorizontal() ? 0 : 1;
}
function Ck(n, e) {
  var t = n.getRect();
  return [t[tW[e]], t[tW[e]] + t[gBt[e]]];
}
const yBt = vBt;
var bBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "single", e;
  }(Gn)
);
function OBt(n) {
  ft(t1), $d.registerAxisPointerClass("SingleAxisPointer", yBt), n.registerComponentView(bBt), n.registerComponentView(lBt), n.registerComponentModel(_k), ev(n, "single", _k, _k.defaultOption), n.registerCoordinateSystem("single", pBt);
}
var wBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r, i) {
      var o = Bv(t);
      n.prototype.init.apply(this, arguments), nW(t, o);
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), nW(this.option, t);
    }, e.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, e.type = "calendar", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, e;
  }(Pt)
);
function nW(n, e) {
  var t = n.cellSize, r;
  se(t) ? r = t : r = n.cellSize = [t, t], r.length === 1 && (r[1] = r[0]);
  var i = le([0, 1], function(o) {
    return Y_t(e, o) && (r[o] = "auto"), r[o] != null && r[o] !== "auto";
  });
  Xc(n, e, {
    type: "box",
    ignoreSize: i
  });
}
const xBt = wBt;
var SBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var o = this.group;
      o.removeAll();
      var a = t.coordinateSystem, s = a.getRangeInfo(), l = a.getOrient(), u = r.getLocaleModel();
      this._renderDayRect(t, s, o), this._renderLines(t, s, l, o), this._renderYearText(t, s, l, o), this._renderMonthText(t, u, l, o), this._renderWeekText(t, u, s, l, o);
    }, e.prototype._renderDayRect = function(t, r, i) {
      for (var o = t.coordinateSystem, a = t.getModel("itemStyle").getItemStyle(), s = o.getCellWidth(), l = o.getCellHeight(), u = r.start.time; u <= r.end.time; u = o.getNextNDay(u, 1).time) {
        var c = o.dataToRect([u], !1).tl, h = new Lt({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: a
        });
        i.add(h);
      }
    }, e.prototype._renderLines = function(t, r, i, o) {
      var a = this, s = t.coordinateSystem, l = t.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = t.get(["splitLine", "show"]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var h = r.start, f = 0; h.time <= r.end.time; f++) {
        p(h.formatedDate), f === 0 && (h = s.getDateInfo(r.start.y + "-" + r.start.m));
        var d = h.date;
        d.setMonth(d.getMonth() + 1), h = s.getDateInfo(d);
      }
      p(s.getNextNDay(r.end.time, 1).formatedDate);
      function p(g) {
        a._firstDayOfMonth.push(s.getDateInfo(g)), a._firstDayPoints.push(s.dataToRect([g], !1).tl);
        var v = a._getLinePointsOfOneWeek(t, g, i);
        a._tlpoints.push(v[0]), a._blpoints.push(v[v.length - 1]), u && a._drawSplitline(v, l, o);
      }
      u && this._drawSplitline(a._getEdgesPoints(a._tlpoints, c, i), l, o), u && this._drawSplitline(a._getEdgesPoints(a._blpoints, c, i), l, o);
    }, e.prototype._getEdgesPoints = function(t, r, i) {
      var o = [t[0].slice(), t[t.length - 1].slice()], a = i === "horizontal" ? 0 : 1;
      return o[0][a] = o[0][a] - r / 2, o[1][a] = o[1][a] + r / 2, o;
    }, e.prototype._drawSplitline = function(t, r, i) {
      var o = new io({
        z2: 20,
        shape: {
          points: t
        },
        style: r
      });
      i.add(o);
    }, e.prototype._getLinePointsOfOneWeek = function(t, r, i) {
      for (var o = t.coordinateSystem, a = o.getDateInfo(r), s = [], l = 0; l < 7; l++) {
        var u = o.getNextNDay(a.time, l), c = o.dataToRect([u.time], !1);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, e.prototype._formatterLabel = function(t, r) {
      return we(t) && t ? j_t(t, r) : Le(t) ? t(r) : r.nameMap;
    }, e.prototype._yearTextPositionControl = function(t, r, i, o, a) {
      var s = r[0], l = r[1], u = ["center", "bottom"];
      o === "bottom" ? (l += a, u = ["center", "top"]) : o === "left" ? s -= a : o === "right" ? (s += a, u = ["center", "top"]) : l -= a;
      var c = 0;
      return (o === "left" || o === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, e.prototype._renderYearText = function(t, r, i, o) {
      var a = t.getModel("yearLabel");
      if (a.get("show")) {
        var s = a.get("margin"), l = a.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], c = (u[0][0] + u[1][0]) / 2, h = (u[0][1] + u[1][1]) / 2, f = i === "horizontal" ? 0 : 1, d = {
          top: [c, u[f][1]],
          bottom: [c, u[1 - f][1]],
          left: [u[1 - f][0], h],
          right: [u[f][0], h]
        }, p = r.start.y;
        +r.end.y > +r.start.y && (p = p + "-" + r.end.y);
        var g = a.get("formatter"), v = {
          start: r.start.y,
          end: r.end.y,
          nameMap: p
        }, m = this._formatterLabel(g, v), y = new Nt({
          z2: 30,
          style: vn(a, {
            text: m
          })
        });
        y.attr(this._yearTextPositionControl(y, d[l], i, l, s)), o.add(y);
      }
    }, e.prototype._monthTextPositionControl = function(t, r, i, o, a) {
      var s = "left", l = "top", u = t[0], c = t[1];
      return i === "horizontal" ? (c = c + a, r && (s = "center"), o === "start" && (l = "bottom")) : (u = u + a, r && (l = "middle"), o === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderMonthText = function(t, r, i, o) {
      var a = t.getModel("monthLabel");
      if (a.get("show")) {
        var s = a.get("nameMap"), l = a.get("margin"), u = a.get("position"), c = a.get("align"), h = [this._tlpoints, this._blpoints];
        (!s || we(s)) && (s && (r = jM(s) || r), s = r.get(["time", "monthAbbr"]) || []);
        var f = u === "start" ? 0 : 1, d = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = 0; g < h[f].length - 1; g++) {
          var v = h[f][g].slice(), m = this._firstDayOfMonth[g];
          if (p) {
            var y = this._firstDayPoints[g];
            v[d] = (y[d] + h[0][g + 1][d]) / 2;
          }
          var b = a.get("formatter"), O = s[+m.m - 1], w = {
            yyyy: m.y,
            yy: (m.y + "").slice(2),
            MM: m.m,
            M: +m.m,
            nameMap: O
          }, x = this._formatterLabel(b, w), S = new Nt({
            z2: 30,
            style: re(vn(a, {
              text: x
            }), this._monthTextPositionControl(v, p, i, u, l))
          });
          o.add(S);
        }
      }
    }, e.prototype._weekTextPositionControl = function(t, r, i, o, a) {
      var s = "center", l = "middle", u = t[0], c = t[1], h = i === "start";
      return r === "horizontal" ? (u = u + o + (h ? 1 : -1) * a[0] / 2, s = h ? "right" : "left") : (c = c + o + (h ? 1 : -1) * a[1] / 2, l = h ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderWeekText = function(t, r, i, o, a) {
      var s = t.getModel("dayLabel");
      if (s.get("show")) {
        var l = t.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), h = s.get("margin"), f = l.getFirstDayOfWeek();
        if (!c || we(c)) {
          c && (r = jM(c) || r);
          var d = r.get(["time", "dayOfWeekShort"]);
          c = d || le(r.get(["time", "dayOfWeekAbbr"]), function(w) {
            return w[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, g = [l.getCellWidth(), l.getCellHeight()];
        h = be(h, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, h = -h);
        for (var v = 0; v < 7; v++) {
          var m = l.getNextNDay(p, v), y = l.dataToRect([m.time], !1).center, b = v;
          b = Math.abs((v + f) % 7);
          var O = new Nt({
            z2: 30,
            style: re(vn(s, {
              text: c[b]
            }), this._weekTextPositionControl(y, o, u, h, g))
          });
          a.add(O);
        }
      }
    }, e.type = "calendar", e;
  }(Gn)
);
const _Bt = SBt;
var Ak = 864e5, CBt = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "calendar", this.dimensions = n.dimensions, this.getDimensionsInfo = n.getDimensionsInfo, this._model = e;
    }
    return n.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, n.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.getCellWidth = function() {
      return this._sw;
    }, n.prototype.getCellHeight = function() {
      return this._sh;
    }, n.prototype.getOrient = function() {
      return this._orient;
    }, n.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, n.prototype.getDateInfo = function(e) {
      e = Cl(e);
      var t = e.getFullYear(), r = e.getMonth() + 1, i = r < 10 ? "0" + r : "" + r, o = e.getDate(), a = o < 10 ? "0" + o : "" + o, s = e.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: t + "",
        m: i,
        d: a,
        day: s,
        time: e.getTime(),
        formatedDate: t + "-" + i + "-" + a,
        date: e
      };
    }, n.prototype.getNextNDay = function(e, t) {
      return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e));
    }, n.prototype.update = function(e, t) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var r = this._rangeInfo.weeks || 1, i = ["width", "height"], o = this._model.getCellSize().slice(), a = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [r, 7] : [7, r];
      I([0, 1], function(h) {
        c(o, h) && (a[i[h]] = o[h] * s[h]);
      });
      var l = {
        width: t.getWidth(),
        height: t.getHeight()
      }, u = this._rect = Cr(a, l);
      I([0, 1], function(h) {
        c(o, h) || (o[h] = u[i[h]] / s[h]);
      });
      function c(h, f) {
        return h[f] != null && h[f] !== "auto";
      }
      this._sw = o[0], this._sh = o[1];
    }, n.prototype.dataToPoint = function(e, t) {
      se(e) && (e = e[0]), t == null && (t = !0);
      var r = this.getDateInfo(e), i = this._rangeInfo, o = r.formatedDate;
      if (t && !(r.time >= i.start.time && r.time < i.end.time + Ak))
        return [NaN, NaN];
      var a = r.day, s = this._getRangeInfo([i.start.time, o]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2];
    }, n.prototype.pointToData = function(e) {
      var t = this.pointToDate(e);
      return t && t.time;
    }, n.prototype.dataToRect = function(e, t) {
      var r = this.dataToPoint(e, t);
      return {
        contentShape: {
          x: r[0] - (this._sw - this._lineWidth) / 2,
          y: r[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: r,
        tl: [r[0] - this._sw / 2, r[1] - this._sh / 2],
        tr: [r[0] + this._sw / 2, r[1] - this._sh / 2],
        br: [r[0] + this._sw / 2, r[1] + this._sh / 2],
        bl: [r[0] - this._sw / 2, r[1] + this._sh / 2]
      };
    }, n.prototype.pointToDate = function(e) {
      var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1, r = Math.floor((e[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(r, t - 1, i) : this._getDateByWeeksAndDay(t, r - 1, i);
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = rW(t);
      return i === this ? i.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = rW(t);
      return i === this ? i.pointToData(r) : null;
    }, n.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, n.prototype._initRangeOption = function() {
      var e = this._model.get("range"), t;
      if (se(e) && e.length === 1 && (e = e[0]), se(e))
        t = e;
      else {
        var r = e.toString();
        if (/^\d{4}$/.test(r) && (t = [r + "-01-01", r + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(r)) {
          var i = this.getDateInfo(r), o = i.date;
          o.setMonth(o.getMonth() + 1);
          var a = this.getNextNDay(o, -1);
          t = [i.formatedDate, a.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(r) && (t = [r, r]);
      }
      if (!t)
        return process.env.NODE_ENV !== "production" && ls("Invalid date range."), e;
      var s = this._getRangeInfo(t);
      return s.start.time > s.end.time && t.reverse(), t;
    }, n.prototype._getRangeInfo = function(e) {
      var t = [this.getDateInfo(e[0]), this.getDateInfo(e[1])], r;
      t[0].time > t[1].time && (r = !0, t.reverse());
      var i = Math.floor(t[1].time / Ak) - Math.floor(t[0].time / Ak) + 1, o = new Date(t[0].time), a = o.getDate(), s = t[1].date.getDate();
      o.setDate(a + i - 1);
      var l = o.getDate();
      if (l !== s)
        for (var u = o.getTime() - t[1].time > 0 ? 1 : -1; (l = o.getDate()) !== s && (o.getTime() - t[1].time) * u > 0; )
          i -= u, o.setDate(l - u);
      var c = Math.floor((i + t[0].day + 6) / 7), h = r ? -c + 1 : c - 1;
      return r && t.reverse(), {
        range: [t[0].formatedDate, t[1].formatedDate],
        start: t[0],
        end: t[1],
        allDay: i,
        weeks: c,
        // From 0.
        nthWeek: h,
        fweek: t[0].day,
        lweek: t[1].day
      };
    }, n.prototype._getDateByWeeksAndDay = function(e, t, r) {
      var i = this._getRangeInfo(r);
      if (e > i.weeks || e === 0 && t < i.fweek || e === i.weeks && t > i.lweek)
        return null;
      var o = (e - 1) * 7 - i.fweek + t, a = new Date(i.start.time);
      return a.setDate(+i.start.d + o), this.getDateInfo(a);
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("calendar", function(i) {
        var o = new n(i);
        r.push(o), i.coordinateSystem = o;
      }), e.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = r[i.get("calendarIndex") || 0]);
      }), r;
    }, n.dimensions = ["time", "value"], n;
  }()
);
function rW(n) {
  var e = n.calendarModel, t = n.seriesModel, r = e ? e.coordinateSystem : t ? t.coordinateSystem : null;
  return r;
}
const ABt = CBt;
function TBt(n) {
  n.registerComponentModel(xBt), n.registerComponentView(_Bt), n.registerCoordinateSystem("calendar", ABt);
}
function kBt(n, e) {
  var t = n.existing;
  if (e.id = n.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) {
    var r = e.parentOption;
    r ? e.parentId = r.id : t && (e.parentId = t.parentId);
  }
  e.parentOption = null;
}
function iW(n, e) {
  var t;
  return I(e, function(r) {
    n[r] != null && n[r] !== "auto" && (t = !0);
  }), t;
}
function PBt(n, e, t) {
  var r = re({}, t), i = n[e], o = t.$action || "merge";
  if (o === "merge")
    if (i) {
      if (process.env.NODE_ENV !== "production") {
        var a = t.type;
        $e(!a || i.type === a, 'Please set $action: "replace" to change `type`');
      }
      it(i, r, !0), Xc(i, r, {
        ignoreSize: !0
      }), Uee(t, i), HO(t, i), HO(t, i, "shape"), HO(t, i, "style"), HO(t, i, "extra"), t.clipPath = i.clipPath;
    } else
      n[e] = r;
  else
    o === "replace" ? n[e] = r : o === "remove" && i && (n[e] = null);
}
var coe = ["transition", "enterFrom", "leaveTo"], EBt = coe.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function HO(n, e, t) {
  if (t && (!n[t] && e[t] && (n[t] = {}), n = n[t], e = e[t]), !(!n || !e))
    for (var r = t ? coe : EBt, i = 0; i < r.length; i++) {
      var o = r[i];
      n[o] == null && e[o] != null && (n[o] = e[o]);
    }
}
function MBt(n, e) {
  if (n && (n.hv = e.hv = [
    // Rigid body, don't care about `width`.
    iW(e, ["left", "right"]),
    // Rigid body, don't care about `height`.
    iW(e, ["top", "bottom"])
  ], n.type === "group")) {
    var t = n, r = e;
    t.width == null && (t.width = r.width = 0), t.height == null && (t.height = r.height = 0);
  }
}
var DBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.preventAutoZ = !0, t;
    }
    return e.prototype.mergeOption = function(t, r) {
      var i = this.option.elements;
      this.option.elements = null, n.prototype.mergeOption.call(this, t, r), this.option.elements = i;
    }, e.prototype.optionUpdated = function(t, r) {
      var i = this.option, o = (r ? i : t).elements, a = i.elements = r ? [] : i.elements, s = [];
      this._flatten(o, s, null);
      var l = $J(a, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      I(l, function(c, h) {
        var f = c.newOption;
        process.env.NODE_ENV !== "production" && $e(Ne(f) || c.existing, "Empty graphic option definition"), f && (u.push(f), kBt(c, f), PBt(a, h, f), MBt(a[h], f));
      }, this), i.elements = en(a, function(c) {
        return c && delete c.$action, c != null;
      });
    }, e.prototype._flatten = function(t, r, i) {
      I(t, function(o) {
        if (o) {
          i && (o.parentOption = i), r.push(o);
          var a = o.children;
          a && a.length && this._flatten(a, r, o), delete o.children;
        }
      }, this);
    }, e.prototype.useElOptionsToUpdate = function() {
      var t = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, t;
    }, e.type = "graphic", e.defaultOption = {
      elements: []
      // parentId: null
    }, e;
  }(Pt)
), oW = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: We,
  image: Si,
  text: Nt
}, ca = It(), LBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._elMap = Ee();
    }, e.prototype.render = function(t, r, i) {
      t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i);
    }, e.prototype._updateElements = function(t) {
      var r = t.useElOptionsToUpdate();
      if (r) {
        var i = this._elMap, o = this.group, a = t.get("z"), s = t.get("zlevel");
        I(r, function(l) {
          var u = wr(l.id, null), c = u != null ? i.get(u) : null, h = wr(l.parentId, null), f = h != null ? i.get(h) : o, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && Qie(p, d, !!v, !!g)) {
            var m = Zie(p, d, !0);
            !v && m.textConfig && (v = l.textConfig = m.textConfig), !g && m.textContent && (g = m.textContent);
          }
          var y = IBt(l);
          process.env.NODE_ENV !== "production" && c && $e(f === c.parent, "Changing parent is not supported.");
          var b = l.$action || "merge", O = b === "merge", w = b === "replace";
          if (O) {
            var x = !c, S = c;
            x ? S = aW(u, f, l.type, i) : (S && (ca(S).isNew = !1), qie(S)), S && (Jw(S, y, t, {
              isInit: x
            }), sW(S, l, a, s));
          } else if (w) {
            tx(c, l, i, t);
            var _ = aW(u, f, l.type, i);
            _ && (Jw(_, y, t, {
              isInit: !0
            }), sW(_, l, a, s));
          } else
            b === "remove" && (Gie(c, l), tx(c, l, i, t));
          var C = i.get(u);
          if (C && g)
            if (O) {
              var A = C.getTextContent();
              A ? A.attr(g) : C.setTextContent(new Nt(g));
            } else
              w && C.setTextContent(new Nt(g));
          if (C) {
            var k = l.clipPath;
            if (k) {
              var P = k.type, L = void 0, x = !1;
              if (O) {
                var D = C.getClipPath();
                x = !D || ca(D).type !== P, L = x ? $D(P) : D;
              } else
                w && (x = !0, L = $D(P));
              C.setClipPath(L), Jw(L, k, t, {
                isInit: x
              }), jS(L, k.keyframeAnimation, t);
            }
            var E = ca(C);
            C.setTextConfig(v), E.option = l, RBt(C, t, l), Iv({
              el: C,
              componentModel: t,
              itemName: C.name,
              itemTooltipOption: l.tooltip
            }), jS(C, l.keyframeAnimation, t);
          }
        });
      }
    }, e.prototype._relocate = function(t, r) {
      for (var i = t.option.elements, o = this.group, a = this._elMap, s = r.getWidth(), l = r.getHeight(), u = ["x", "y"], c = 0; c < i.length; c++) {
        var h = i[c], f = wr(h.id, null), d = f != null ? a.get(f) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, g = p === o, v = ca(d), m = ca(p);
          v.width = be(v.option.width, g ? s : m.width) || 0, v.height = be(v.option.height, g ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var h = i[c], f = wr(h.id, null), d = f != null ? a.get(f) : null;
        if (d) {
          var p = d.parent, m = ca(p), y = p === o ? {
            width: s,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, b = {}, O = RC(d, h, y, null, {
            hv: h.hv,
            boundingMode: h.bounding
          }, b);
          if (!ca(d).isNew && O) {
            for (var w = h.transition, x = {}, S = 0; S < u.length; S++) {
              var _ = u[S], C = b[_];
              w && (Hf(w) || ct(w, _) >= 0) ? x[_] = C : d[_] = C;
            }
            Vt(d, x, t, 0);
          } else
            d.attr(b);
        }
      }
    }, e.prototype._clear = function() {
      var t = this, r = this._elMap;
      r.each(function(i) {
        tx(i, ca(i).option, r, t._lastGraphicModel);
      }), this._elMap = Ee();
    }, e.prototype.dispose = function() {
      this._clear();
    }, e.type = "graphic", e;
  }(Gn)
);
function $D(n) {
  process.env.NODE_ENV !== "production" && $e(n, "graphic type MUST be set");
  var e = Ce(oW, n) ? oW[n] : qR(n);
  process.env.NODE_ENV !== "production" && $e(e, "graphic type " + n + " can not be found");
  var t = new e({});
  return ca(t).type = n, t;
}
function aW(n, e, t, r) {
  var i = $D(t);
  return e.add(i), r.set(n, i), ca(i).id = n, ca(i).isNew = !0, i;
}
function tx(n, e, t, r) {
  var i = n && n.parent;
  i && (n.type === "group" && n.traverse(function(o) {
    tx(o, e, t, r);
  }), XC(n, e, r), t.removeKey(ca(n).id));
}
function sW(n, e, t, r) {
  n.isGroup || I([
    ["cursor", Ia.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", r || 0],
    ["z", t || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(i) {
    var o = i[0];
    Ce(e, o) ? n[o] = qe(e[o], i[1]) : n[o] == null && (n[o] = i[1]);
  }), I(Ot(e), function(i) {
    if (i.indexOf("on") === 0) {
      var o = e[i];
      n[i] = Le(o) ? o : null;
    }
  }), Ce(e, "draggable") && (n.draggable = e.draggable), e.name != null && (n.name = e.name), e.id != null && (n.id = e.id);
}
function IBt(n) {
  return n = re({}, n), I(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(Xee), function(e) {
    delete n[e];
  }), n;
}
function RBt(n, e, t) {
  var r = He(n).eventData;
  !n.silent && !n.ignore && !r && (r = He(n).eventData = {
    componentType: "graphic",
    componentIndex: e.componentIndex,
    name: n.name
  }), r && (r.info = t.info);
}
function NBt(n) {
  n.registerComponentModel(DBt), n.registerComponentView(LBt), n.registerPreprocessor(function(e) {
    var t = e.graphic;
    se(t) ? !t[0] || !t[0].elements ? e.graphic = [{
      elements: t
    }] : e.graphic = [e.graphic[0]] : t && !t.elements && (e.graphic = [{
      elements: [t]
    }]);
  });
}
var lW = ["x", "y", "radius", "angle", "single"], $Bt = ["cartesian2d", "polar", "singleAxis"];
function BBt(n) {
  var e = n.get("coordinateSystem");
  return ct($Bt, e) >= 0;
}
function Oc(n) {
  return process.env.NODE_ENV !== "production" && $e(n), n + "Axis";
}
function VBt(n, e) {
  var t = Ee(), r = [], i = Ee();
  n.eachComponent({
    mainType: "dataZoom",
    query: e
  }, function(c) {
    i.get(c.uid) || s(c);
  });
  var o;
  do
    o = !1, n.eachComponent("dataZoom", a);
  while (o);
  function a(c) {
    !i.get(c.uid) && l(c) && (s(c), o = !0);
  }
  function s(c) {
    i.set(c.uid, !0), r.push(c), u(c);
  }
  function l(c) {
    var h = !1;
    return c.eachTargetAxis(function(f, d) {
      var p = t.get(f);
      p && p[d] && (h = !0);
    }), h;
  }
  function u(c) {
    c.eachTargetAxis(function(h, f) {
      (t.get(h) || t.set(h, []))[f] = !0;
    });
  }
  return r;
}
function hoe(n) {
  var e = n.ecModel, t = {
    infoList: [],
    infoMap: Ee()
  };
  return n.eachTargetAxis(function(r, i) {
    var o = e.getComponent(Oc(r), i);
    if (o) {
      var a = o.getCoordSysModel();
      if (a) {
        var s = a.uid, l = t.infoMap.get(s);
        l || (l = {
          model: a,
          axisModels: []
        }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(o);
      }
    }
  }), t;
}
var Tk = (
  /** @class */
  function() {
    function n() {
      this.indexList = [], this.indexMap = [];
    }
    return n.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = !0);
    }, n;
  }()
), tb = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._autoThrottle = !0, t._noTarget = !0, t._rangePropMode = ["percent", "percent"], t;
    }
    return e.prototype.init = function(t, r, i) {
      var o = uW(t);
      this.settledOption = o, this.mergeDefaultAndTheme(t, i), this._doInit(o);
    }, e.prototype.mergeOption = function(t) {
      var r = uW(t);
      it(this.option, t, !0), it(this.settledOption, r, !0), this._doInit(r);
    }, e.prototype._doInit = function(t) {
      var r = this.option;
      this._setDefaultThrottle(t), this._updateRangeUse(t);
      var i = this.settledOption;
      I([["start", "startValue"], ["end", "endValue"]], function(o, a) {
        this._rangePropMode[a] === "value" && (r[o[0]] = i[o[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var t = this.get("orient", !0), r = this._targetAxisInfoMap = Ee(), i = this._fillSpecifiedTargetAxis(r);
      i ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(r, this._orient)), this._noTarget = !0, r.each(function(o) {
        o.indexList.length && (this._noTarget = !1);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(t) {
      var r = !1;
      return I(lW, function(i) {
        var o = this.getReferringComponents(Oc(i), kxt);
        if (o.specified) {
          r = !0;
          var a = new Tk();
          I(o.models, function(s) {
            a.add(s.componentIndex);
          }), t.set(i, a);
        }
      }, this), r;
    }, e.prototype._fillAutoTargetAxisByOrient = function(t, r) {
      var i = this.ecModel, o = !0;
      if (o) {
        var a = r === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: a + "Axis"
        });
        l(s, a);
      }
      if (o) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", !0) === r;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var h = u[0];
        if (h) {
          var f = new Tk();
          if (f.add(h.componentIndex), t.set(c, f), o = !1, c === "x" || c === "y") {
            var d = h.getReferringComponents("grid", cr).models[0];
            d && I(u, function(p) {
              h.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", cr).models[0] && f.add(p.componentIndex);
            });
          }
        }
      }
      o && I(lW, function(u) {
        if (o) {
          var c = i.findComponents({
            mainType: Oc(u),
            filter: function(f) {
              return f.get("type", !0) === "category";
            }
          });
          if (c[0]) {
            var h = new Tk();
            h.add(c[0].componentIndex), t.set(u, h), o = !1;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var t;
      return this.eachTargetAxis(function(r) {
        !t && (t = r);
      }, this), t === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(t) {
      if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var r = this.ecModel.option;
        this.option.throttle = r.animation && r.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(t) {
      var r = this._rangePropMode, i = this.get("rangeMode");
      I([["start", "startValue"], ["end", "endValue"]], function(o, a) {
        var s = t[o[0]] != null, l = t[o[1]] != null;
        s && !l ? r[a] = "percent" : !s && l ? r[a] = "value" : i ? r[a] = i[a] : s && (r[a] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var t;
      return this.eachTargetAxis(function(r, i) {
        t == null && (t = this.ecModel.getComponent(Oc(r), i));
      }, this), t;
    }, e.prototype.eachTargetAxis = function(t, r) {
      this._targetAxisInfoMap.each(function(i, o) {
        I(i.indexList, function(a) {
          t.call(r, o, a);
        });
      });
    }, e.prototype.getAxisProxy = function(t, r) {
      var i = this.getAxisModel(t, r);
      if (i)
        return i.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(t, r) {
      process.env.NODE_ENV !== "production" && $e(t && r != null);
      var i = this._targetAxisInfoMap.get(t);
      if (i && i.indexMap[r])
        return this.ecModel.getComponent(Oc(t), r);
    }, e.prototype.setRawRange = function(t) {
      var r = this.option, i = this.settledOption;
      I([["start", "startValue"], ["end", "endValue"]], function(o) {
        (t[o[0]] != null || t[o[1]] != null) && (r[o[0]] = i[o[0]] = t[o[0]], r[o[1]] = i[o[1]] = t[o[1]]);
      }, this), this._updateRangeUse(t);
    }, e.prototype.setCalculatedRange = function(t) {
      var r = this.option;
      I(["start", "startValue", "end", "endValue"], function(i) {
        r[i] = t[i];
      });
    }, e.prototype.getPercentRange = function() {
      var t = this.findRepresentativeAxisProxy();
      if (t)
        return t.getDataPercentWindow();
    }, e.prototype.getValueRange = function(t, r) {
      if (t == null && r == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i)
          return i.getDataValueWindow();
      } else
        return this.getAxisProxy(t, r).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(t) {
      if (t)
        return t.__dzAxisProxy;
      for (var r, i = this._targetAxisInfoMap.keys(), o = 0; o < i.length; o++)
        for (var a = i[o], s = this._targetAxisInfoMap.get(a), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(a, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          r || (r = u);
        }
      return r;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && $e(this._orient), this._orient;
    }, e.type = "dataZoom", e.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(Pt)
);
function uW(n) {
  var e = {};
  return I(["start", "end", "startValue", "endValue", "throttle"], function(t) {
    n.hasOwnProperty(t) && (e[t] = n[t]);
  }), e;
}
var zBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(tb)
);
const FBt = zBt;
var QBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, o) {
      this.dataZoomModel = t, this.ecModel = r, this.api = i;
    }, e.type = "dataZoom", e;
  }(Gn)
);
const b$ = QBt;
var ZBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(b$)
);
const WBt = ZBt;
var Ap = I, cW = wa, GBt = (
  /** @class */
  function() {
    function n(e, t, r, i) {
      this._dimName = e, this._axisIndex = t, this.ecModel = i, this._dataZoomModel = r;
    }
    return n.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, n.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, n.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, n.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(t) {
        if (BBt(t)) {
          var r = Oc(this._dimName), i = t.getReferringComponents(r, cr).models[0];
          i && this._axisIndex === i.componentIndex && e.push(t);
        }
      }, this), e;
    }, n.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, n.prototype.getMinMaxSpan = function() {
      return Fe(this._minMaxSpan);
    }, n.prototype.calculateDataWindow = function(e) {
      var t = this._dataExtent, r = this.getAxisModel(), i = r.axis.scale, o = this._dataZoomModel.getRangePropMode(), a = [0, 100], s = [], l = [], u;
      Ap(["start", "end"], function(f, d) {
        var p = e[f], g = e[f + "Value"];
        o[d] === "percent" ? (p == null && (p = a[d]), g = i.parse(Yt(p, a, t))) : (u = !0, g = g == null ? t[d] : i.parse(g), p = Yt(g, t, a)), l[d] = g == null || isNaN(g) ? t[d] : g, s[d] = p == null || isNaN(p) ? a[d] : p;
      }), cW(l), cW(s);
      var c = this._minMaxSpan;
      u ? h(l, s, t, a, !1) : h(s, l, a, t, !0);
      function h(f, d, p, g, v) {
        var m = v ? "Span" : "ValueSpan";
        Bd(0, f, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++)
          d[y] = Yt(f[y], p, g, !0), v && (d[y] = i.parse(d[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, n.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var t = this.getTargetSeriesModels();
        this._dataExtent = jBt(this, this._dimName, t), this._updateMinMaxSpan();
        var r = this.calculateDataWindow(e.settledOption);
        this._valueWindow = r.valueWindow, this._percentWindow = r.percentWindow, this._setAxisModel();
      }
    }, n.prototype.filterData = function(e, t) {
      if (e !== this._dataZoomModel)
        return;
      var r = this._dimName, i = this.getTargetSeriesModels(), o = e.get("filterMode"), a = this._valueWindow;
      if (o === "none")
        return;
      Ap(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(r);
        if (c.length) {
          if (o === "weakFilter") {
            var h = u.getStore(), f = le(c, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, g, v, m = 0; m < c.length; m++) {
                var y = h.get(f[m], d), b = !isNaN(y), O = y < a[0], w = y > a[1];
                if (b && !O && !w)
                  return !0;
                b && (v = !0), O && (p = !0), w && (g = !0);
              }
              return v && p && g;
            });
          } else
            Ap(c, function(d) {
              if (o === "empty")
                l.setData(u = u.map(d, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var p = {};
                p[d] = a, u.selectRange(p);
              }
            });
          Ap(c, function(d) {
            u.setApproximateExtent(a, d);
          });
        }
      });
      function s(l) {
        return l >= a[0] && l <= a[1];
      }
    }, n.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, t = this._dataZoomModel, r = this._dataExtent;
      Ap(["min", "max"], function(i) {
        var o = t.get(i + "Span"), a = t.get(i + "ValueSpan");
        a != null && (a = this.getAxisModel().axis.scale.parse(a)), a != null ? o = Yt(r[0] + a, r, [0, 100], !0) : o != null && (a = Yt(o, [0, 100], r, !0) - r[0]), e[i + "Span"] = o, e[i + "ValueSpan"] = a;
      }, this);
    }, n.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), t = this._percentWindow, r = this._valueWindow;
      if (t) {
        var i = EJ(r, [0, 500]);
        i = Math.min(i, 20);
        var o = e.axis.scale.rawExtentInfo;
        t[0] !== 0 && o.setDeterminedMinMax("min", +r[0].toFixed(i)), t[1] !== 100 && o.setDeterminedMinMax("max", +r[1].toFixed(i)), o.freeze();
      }
    }, n;
  }()
);
function jBt(n, e, t) {
  var r = [1 / 0, -1 / 0];
  Ap(t, function(a) {
    ITt(r, a.getData(), e);
  });
  var i = n.getAxisModel(), o = Tne(i.axis.scale, i, r).calculate();
  return [o.min, o.max];
}
var HBt = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(n) {
    function e(i) {
      n.eachComponent("dataZoom", function(o) {
        o.eachTargetAxis(function(a, s) {
          var l = n.getComponent(Oc(a), s);
          i(a, s, l, o);
        });
      });
    }
    e(function(i, o, a, s) {
      a.__dzAxisProxy = null;
    });
    var t = [];
    e(function(i, o, a, s) {
      a.__dzAxisProxy || (a.__dzAxisProxy = new GBt(i, o, s, n), t.push(a.__dzAxisProxy));
    });
    var r = Ee();
    return I(t, function(i) {
      I(i.getTargetSeriesModels(), function(o) {
        r.set(o.uid, o);
      });
    }), r;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(n, e) {
    n.eachComponent("dataZoom", function(t) {
      t.eachTargetAxis(function(r, i) {
        t.getAxisProxy(r, i).reset(t);
      }), t.eachTargetAxis(function(r, i) {
        t.getAxisProxy(r, i).filterData(t, e);
      });
    }), n.eachComponent("dataZoom", function(t) {
      var r = t.findRepresentativeAxisProxy();
      if (r) {
        var i = r.getDataPercentWindow(), o = r.getDataValueWindow();
        t.setCalculatedRange({
          start: i[0],
          end: i[1],
          startValue: o[0],
          endValue: o[1]
        });
      }
    });
  }
};
const qBt = HBt;
function YBt(n) {
  n.registerAction("dataZoom", function(e, t) {
    var r = VBt(t, e);
    I(r, function(i) {
      i.setRawRange({
        start: e.start,
        end: e.end,
        startValue: e.startValue,
        endValue: e.endValue
      });
    });
  });
}
var hW = !1;
function O$(n) {
  hW || (hW = !0, n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, qBt), YBt(n), n.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function XBt(n) {
  n.registerComponentModel(FBt), n.registerComponentView(WBt), O$(n);
}
var pa = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), foe = {};
function Tp(n, e) {
  foe[n] = e;
}
function doe(n) {
  return foe[n];
}
var UBt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      n.prototype.optionUpdated.apply(this, arguments);
      var t = this.ecModel;
      I(this.option.feature, function(r, i) {
        var o = doe(i);
        o && (o.getDefaultOption && (o.defaultOption = o.getDefaultOption(t)), it(r, o.defaultOption));
      });
    }, e.type = "toolbox", e.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, e.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, e;
  }(Pt)
);
const KBt = UBt;
function JBt(n, e, t) {
  var r = e.getBoxLayoutParams(), i = e.get("padding"), o = {
    width: t.getWidth(),
    height: t.getHeight()
  }, a = Cr(r, o, i);
  Gf(e.get("orient"), n, e.get("itemGap"), a.width, a.height), RC(n, r, o, i);
}
function poe(n, e) {
  var t = $v(e.get("padding")), r = e.getItemStyle(["color", "opacity"]);
  return r.fill = e.get("backgroundColor"), n = new Lt({
    shape: {
      x: n.x - t[3],
      y: n.y - t[0],
      width: n.width + t[1] + t[3],
      height: n.height + t[0] + t[2],
      r: e.get("borderRadius")
    },
    style: r,
    silent: !0,
    z2: -1
  }), n;
}
var e5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i, o) {
      var a = this.group;
      if (a.removeAll(), !t.get("show"))
        return;
      var s = +t.get("itemSize"), l = t.get("orient") === "vertical", u = t.get("feature") || {}, c = this._features || (this._features = {}), h = [];
      I(u, function(p, g) {
        h.push(g);
      }), new mu(this._featureNames || [], h).add(f).update(f).remove(Je(f, null)).execute(), this._featureNames = h;
      function f(p, g) {
        var v = h[p], m = h[g], y = u[v], b = new mn(y, t, t.ecModel), O;
        if (o && o.newTitle != null && o.featureName === v && (y.title = o.newTitle), v && !m) {
          if (t5t(v))
            O = {
              onclick: b.option.onclick,
              featureName: v
            };
          else {
            var w = doe(v);
            if (!w)
              return;
            O = new w();
          }
          c[v] = O;
        } else if (O = c[m], !O)
          return;
        O.uid = Nv("toolbox-feature"), O.model = b, O.ecModel = r, O.api = i;
        var x = O instanceof pa;
        if (!v && m) {
          x && O.dispose && O.dispose(r, i);
          return;
        }
        if (!b.get("show") || x && O.unusable) {
          x && O.remove && O.remove(r, i);
          return;
        }
        d(b, O, v), b.setIconStatus = function(S, _) {
          var C = this.option, A = this.iconPaths;
          C.iconStatus = C.iconStatus || {}, C.iconStatus[S] = _, A[S] && (_ === "emphasis" ? gu : vu)(A[S]);
        }, O instanceof pa && O.render && O.render(b, r, i, o);
      }
      function d(p, g, v) {
        var m = p.getModel("iconStyle"), y = p.getModel(["emphasis", "iconStyle"]), b = g instanceof pa && g.getIcons ? g.getIcons() : p.get("icon"), O = p.get("title") || {}, w, x;
        we(b) ? (w = {}, w[v] = b) : w = b, we(O) ? (x = {}, x[v] = O) : x = O;
        var S = p.iconPaths = {};
        I(w, function(_, C) {
          var A = Qb(_, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          A.setStyle(m.getItemStyle());
          var k = A.ensureState("emphasis");
          k.style = y.getItemStyle();
          var P = new Nt({
            style: {
              text: x[C],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: YR({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, r)
            },
            ignore: !0
          });
          A.setTextContent(P), Iv({
            el: A,
            componentModel: t,
            itemName: C,
            formatterParamsExtra: {
              title: x[C]
            }
          }), A.__title = x[C], A.on("mouseover", function() {
            var L = y.getItemStyle(), D = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
            P.setStyle({
              fill: y.get("textFill") || L.fill || L.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), A.setTextConfig({
              position: y.get("textPosition") || D
            }), P.ignore = !t.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get(["iconStatus", C]) !== "emphasis" && i.leaveEmphasis(this), P.hide();
          }), (p.get(["iconStatus", C]) === "emphasis" ? gu : vu)(A), a.add(A), A.on("click", _e(g.onclick, g, r, i, C)), S[C] = A;
        });
      }
      JBt(a, t, i), a.add(poe(a.getBoundingRect(), t)), l || a.eachChild(function(p) {
        var g = p.__title, v = p.ensureState("emphasis"), m = v.textConfig || (v.textConfig = {}), y = p.getTextContent(), b = y && y.ensureState("emphasis");
        if (b && !Le(b) && g) {
          var O = b.style || (b.style = {}), w = $b(g, Nt.makeFont(O)), x = p.x + a.x, S = p.y + a.y + s, _ = !1;
          S + w.height > i.getHeight() && (m.position = "top", _ = !0);
          var C = _ ? -5 - w.height : s + 10;
          x + w.width / 2 > i.getWidth() ? (m.position = ["100%", C], O.align = "right") : x - w.width / 2 < 0 && (m.position = [0, C], O.align = "left");
        }
      });
    }, e.prototype.updateView = function(t, r, i, o) {
      I(this._features, function(a) {
        a instanceof pa && a.updateView && a.updateView(a.model, r, i, o);
      });
    }, e.prototype.remove = function(t, r) {
      I(this._features, function(i) {
        i instanceof pa && i.remove && i.remove(t, r);
      }), this.group.removeAll();
    }, e.prototype.dispose = function(t, r) {
      I(this._features, function(i) {
        i instanceof pa && i.dispose && i.dispose(t, r);
      });
    }, e.type = "toolbox", e;
  }(Gn)
);
function t5t(n) {
  return n.indexOf("my") === 0;
}
const n5t = e5t;
var r5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      var i = this.model, o = i.get("name") || t.get("title.0.text") || "echarts", a = r.getZr().painter.getType() === "svg", s = a ? "svg" : i.get("type", !0) || "png", l = r.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = mt.browser;
      if (Le(MouseEvent) && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = o + "." + s, c.target = "_blank", c.href = l;
        var h = new MouseEvent("click", {
          // some micro front-end framework， window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        c.dispatchEvent(h);
      } else if (window.navigator.msSaveOrOpenBlob || a) {
        var f = l.split(","), d = f[0].indexOf("base64") > -1, p = a ? decodeURIComponent(f[1]) : f[1];
        d && (p = window.atob(p));
        var g = o + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; )
            m[v] = p.charCodeAt(v);
          var y = new Blob([m]);
          window.navigator.msSaveOrOpenBlob(y, g);
        } else {
          var b = document.createElement("iframe");
          document.body.appendChild(b);
          var O = b.contentWindow, w = O.document;
          w.open("image/svg+xml", "replace"), w.write(p), w.close(), O.focus(), w.execCommand("SaveAs", !0, g), document.body.removeChild(b);
        }
      } else {
        var x = i.get("lang"), S = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (x && x[0] || "") + '" /></body>', _ = window.open();
        _.document.write(S), _.document.title = o;
      }
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: t.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: t.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return r;
    }, e;
  }(pa)
);
const i5t = r5t;
var fW = "__ec_magicType_stack__", o5t = [["line", "bar"], ["stack"]], a5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getIcons = function() {
      var t = this.model, r = t.get("icon"), i = {};
      return I(t.get("type"), function(o) {
        r[o] && (i[o] = r[o]);
      }), i;
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: t.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return r;
    }, e.prototype.onclick = function(t, r, i) {
      var o = this.model, a = o.get(["seriesIndex", i]);
      if (dW[i]) {
        var s = {
          series: []
        }, l = function(h) {
          var f = h.subType, d = h.id, p = dW[i](f, d, h, o);
          p && (Be(p, h.option), s.series.push(p));
          var g = h.coordinateSystem;
          if (g && g.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var m = v.dim, y = m + "Axis", b = h.getReferringComponents(y, cr).models[0], O = b.componentIndex;
              s[y] = s[y] || [];
              for (var w = 0; w <= O; w++)
                s[y][O] = s[y][O] || {};
              s[y][O].boundaryGap = i === "bar";
            }
          }
        };
        I(o5t, function(h) {
          ct(h, i) >= 0 && I(h, function(f) {
            o.setIconStatus(f, "normal");
          });
        }), o.setIconStatus(i, "emphasis"), t.eachComponent({
          mainType: "series",
          query: a == null ? null : {
            seriesIndex: a
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = it({
          stack: o.option.title.tiled,
          tiled: o.option.title.stack
        }, o.option.title), o.get(["iconStatus", i]) !== "emphasis" && (c = "tiled")), r.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, e;
  }(pa)
), dW = {
  line: function(n, e, t, r) {
    if (n === "bar")
      return it({
        id: e,
        type: "line",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, r.get(["option", "line"]) || {}, !0);
  },
  bar: function(n, e, t, r) {
    if (n === "line")
      return it({
        id: e,
        type: "bar",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, r.get(["option", "bar"]) || {}, !0);
  },
  stack: function(n, e, t, r) {
    var i = t.get("stack") === fW;
    if (n === "line" || n === "bar")
      return r.setIconStatus("stack", i ? "normal" : "emphasis"), it({
        id: e,
        stack: i ? "" : fW
      }, r.get(["option", "stack"]) || {}, !0);
  }
};
Rl({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(n, e) {
  e.mergeOption(n.newOption);
});
const s5t = a5t;
var UC = new Array(60).join("-"), rv = "	";
function l5t(n) {
  var e = {}, t = [], r = [];
  return n.eachRawSeries(function(i) {
    var o = i.coordinateSystem;
    if (o && (o.type === "cartesian2d" || o.type === "polar")) {
      var a = o.getBaseAxis();
      if (a.type === "category") {
        var s = a.dim + "_" + a.index;
        e[s] || (e[s] = {
          categoryAxis: a,
          valueAxis: o.getOtherAxis(a),
          series: []
        }, r.push({
          axisDim: a.dim,
          axisIndex: a.index
        })), e[s].series.push(i);
      } else
        t.push(i);
    } else
      t.push(i);
  }), {
    seriesGroupByCategoryAxis: e,
    other: t,
    meta: r
  };
}
function u5t(n) {
  var e = [];
  return I(n, function(t, r) {
    var i = t.categoryAxis, o = t.valueAxis, a = o.dim, s = [" "].concat(le(t.series, function(d) {
      return d.name;
    })), l = [i.model.getCategories()];
    I(t.series, function(d) {
      var p = d.getRawData();
      l.push(d.getRawData().mapArray(p.mapDimension(a), function(g) {
        return g;
      }));
    });
    for (var u = [s.join(rv)], c = 0; c < l[0].length; c++) {
      for (var h = [], f = 0; f < l.length; f++)
        h.push(l[f][c]);
      u.push(h.join(rv));
    }
    e.push(u.join(`
`));
  }), e.join(`

` + UC + `

`);
}
function c5t(n) {
  return le(n, function(e) {
    var t = e.getRawData(), r = [e.name], i = [];
    return t.each(t.dimensions, function() {
      for (var o = arguments.length, a = arguments[o - 1], s = t.getName(a), l = 0; l < o - 1; l++)
        i[l] = arguments[l];
      r.push((s ? s + rv : "") + i.join(rv));
    }), r.join(`
`);
  }).join(`

` + UC + `

`);
}
function h5t(n) {
  var e = l5t(n);
  return {
    value: en([u5t(e.seriesGroupByCategoryAxis), c5t(e.other)], function(t) {
      return !!t.replace(/[\n\t\s]/g, "");
    }).join(`

` + UC + `

`),
    meta: e.meta
  };
}
function XS(n) {
  return n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function f5t(n) {
  var e = n.slice(0, n.indexOf(`
`));
  if (e.indexOf(rv) >= 0)
    return !0;
}
var BD = new RegExp("[" + rv + "]+", "g");
function d5t(n) {
  for (var e = n.split(/\n+/g), t = XS(e.shift()).split(BD), r = [], i = le(t, function(l) {
    return {
      name: l,
      data: []
    };
  }), o = 0; o < e.length; o++) {
    var a = XS(e[o]).split(BD);
    r.push(a.shift());
    for (var s = 0; s < a.length; s++)
      i[s] && (i[s].data[o] = a[s]);
  }
  return {
    series: i,
    categories: r
  };
}
function p5t(n) {
  for (var e = n.split(/\n+/g), t = XS(e.shift()), r = [], i = 0; i < e.length; i++) {
    var o = XS(e[i]);
    if (o) {
      var a = o.split(BD), s = "", l = void 0, u = !1;
      isNaN(a[0]) ? (u = !0, s = a[0], a = a.slice(1), r[i] = {
        name: s,
        value: []
      }, l = r[i].value) : l = r[i] = [];
      for (var c = 0; c < a.length; c++)
        l.push(+a[c]);
      l.length === 1 && (u ? r[i].value = l[0] : r[i] = l[0]);
    }
  }
  return {
    name: t,
    data: r
  };
}
function g5t(n, e) {
  var t = n.split(new RegExp(`
*` + UC + `
*`, "g")), r = {
    series: []
  };
  return I(t, function(i, o) {
    if (f5t(i)) {
      var a = d5t(i), s = e[o], l = s.axisDim + "Axis";
      s && (r[l] = r[l] || [], r[l][s.axisIndex] = {
        data: a.categories
      }, r.series = r.series.concat(a.series));
    } else {
      var a = p5t(i);
      r.series.push(a);
    }
  }), r;
}
var v5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      setTimeout(function() {
        r.dispatchAction({
          type: "hideTip"
        });
      });
      var i = r.getDom(), o = this.model;
      this._dom && i.removeChild(this._dom);
      var a = document.createElement("div");
      a.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", a.style.backgroundColor = o.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = o.get("lang") || [];
      s.innerHTML = l[0] || o.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = o.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var h = o.get("optionToContent"), f = o.get("contentToOption"), d = h5t(t);
      if (Le(h)) {
        var p = h(r.getOption());
        we(p) ? u.innerHTML = p : ud(p) && u.appendChild(p);
      } else {
        c.readOnly = o.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = o.get("textColor"), g.borderColor = o.get("textareaBorderColor"), g.backgroundColor = o.get("textareaColor"), c.value = d.value, u.appendChild(c);
      }
      var v = d.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", b = document.createElement("div"), O = document.createElement("div");
      y += ";background-color:" + o.get("buttonColor"), y += ";color:" + o.get("buttonTextColor");
      var w = this;
      function x() {
        i.removeChild(a), w._dom = null;
      }
      vM(b, "click", x), vM(O, "click", function() {
        if (f == null && h != null || f != null && h == null) {
          process.env.NODE_ENV !== "production" && $n("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), x();
          return;
        }
        var S;
        try {
          Le(f) ? S = f(u, r.getOption()) : S = g5t(c.value, v);
        } catch (_) {
          throw x(), new Error("Data view format error " + _);
        }
        S && r.dispatchAction({
          type: "changeDataView",
          newOption: S
        }), x();
      }), b.innerHTML = l[1], O.innerHTML = l[2], O.style.cssText = b.style.cssText = y, !o.get("readOnly") && m.appendChild(O), m.appendChild(b), a.appendChild(s), a.appendChild(u), a.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(a), this._dom = a;
    }, e.prototype.remove = function(t, r) {
      this._dom && r.getDom().removeChild(this._dom);
    }, e.prototype.dispose = function(t, r) {
      this.remove(t, r);
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: t.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: t.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return r;
    }, e;
  }(pa)
);
function m5t(n, e) {
  return le(n, function(t, r) {
    var i = e && e[r];
    if (Ne(i) && !se(i)) {
      var o = Ne(t) && !se(t);
      o || (t = {
        value: t
      });
      var a = i.name != null && t.name == null;
      return t = Be(t, i), a && delete t.name, t;
    } else
      return t;
  });
}
Rl({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(n, e) {
  var t = [];
  I(n.newOption.series, function(r) {
    var i = e.getSeriesByName(r.name)[0];
    if (!i)
      t.push(re({
        // Default is scatter
        type: "scatter"
      }, r));
    else {
      var o = i.get("data");
      t.push({
        name: r.name,
        data: m5t(r.data, o)
      });
    }
  }), e.mergeOption(Be({
    series: t
  }, n.newOption));
});
const y5t = v5t;
var goe = I, voe = It();
function b5t(n, e) {
  var t = w$(n);
  goe(e, function(r, i) {
    for (var o = t.length - 1; o >= 0; o--) {
      var a = t[o];
      if (a[i])
        break;
    }
    if (o < 0) {
      var s = n.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: i
      })[0];
      if (s) {
        var l = s.getPercentRange();
        t[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), t.push(e);
}
function O5t(n) {
  var e = w$(n), t = e[e.length - 1];
  e.length > 1 && e.pop();
  var r = {};
  return goe(t, function(i, o) {
    for (var a = e.length - 1; a >= 0; a--)
      if (i = e[a][o], i) {
        r[o] = i;
        break;
      }
  }), r;
}
function w5t(n) {
  voe(n).snapshots = null;
}
function x5t(n) {
  return w$(n).length;
}
function w$(n) {
  var e = voe(n);
  return e.snapshots || (e.snapshots = [{}]), e.snapshots;
}
var S5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      w5t(t), r.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: t.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return r;
    }, e;
  }(pa)
);
Rl({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(n, e) {
  e.resetOption("recreate");
});
const _5t = S5t;
var C5t = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], A5t = (
  /** @class */
  function() {
    function n(e, t, r) {
      var i = this;
      this._targetInfoList = [];
      var o = pW(t, e);
      I(T5t, function(a, s) {
        (!r || !r.include || ct(r.include, s) >= 0) && a(o, i._targetInfoList);
      });
    }
    return n.prototype.setOutputRanges = function(e, t) {
      return this.matchOutputRanges(e, t, function(r, i, o) {
        if ((r.coordRanges || (r.coordRanges = [])).push(i), !r.coordRange) {
          r.coordRange = i;
          var a = kk[r.brushType](0, o, i);
          r.__rangeOffset = {
            offset: yW[r.brushType](a.values, r.range, [1, 1]),
            xyMinMax: a.xyMinMax
          };
        }
      }), e;
    }, n.prototype.matchOutputRanges = function(e, t, r) {
      I(e, function(i) {
        var o = this.findTargetInfo(i, t);
        o && o !== !0 && I(o.coordSyses, function(a) {
          var s = kk[i.brushType](1, a, i.range, !0);
          r(i, s.values, a, t);
        });
      }, this);
    }, n.prototype.setInputRanges = function(e, t) {
      I(e, function(r) {
        var i = this.findTargetInfo(r, t);
        if (process.env.NODE_ENV !== "production" && ($e(!i || i === !0 || r.coordRange, "coordRange must be specified when coord index specified."), $e(!i || i !== !0 || r.range, "range must be specified in global brush.")), r.range = r.range || [], i && i !== !0) {
          r.panelId = i.panelId;
          var o = kk[r.brushType](0, i.coordSys, r.coordRange), a = r.__rangeOffset;
          r.range = a ? yW[r.brushType](o.values, a.offset, k5t(o.xyMinMax, a.xyMinMax)) : o.values;
        }
      }, this);
    }, n.prototype.makePanelOpts = function(e, t) {
      return le(this._targetInfoList, function(r) {
        var i = r.getPanelRect();
        return {
          panelId: r.panelId,
          defaultBrushType: t ? t(r) : null,
          clipPath: xie(i),
          isTargetByCursor: _ie(i, e, r.coordSysModel),
          getLinearBrushOtherExtent: Sie(i)
        };
      });
    }, n.prototype.controlSeries = function(e, t, r) {
      var i = this.findTargetInfo(e, r);
      return i === !0 || i && ct(i.coordSyses, t.coordinateSystem) >= 0;
    }, n.prototype.findTargetInfo = function(e, t) {
      for (var r = this._targetInfoList, i = pW(t, e), o = 0; o < r.length; o++) {
        var a = r[o], s = e.panelId;
        if (s) {
          if (a.panelId === s)
            return a;
        } else
          for (var l = 0; l < gW.length; l++)
            if (gW[l](i, a))
              return a;
      }
      return !0;
    }, n;
  }()
);
function VD(n) {
  return n[0] > n[1] && n.reverse(), n;
}
function pW(n, e) {
  return Iy(n, e, {
    includeMainTypes: C5t
  });
}
var T5t = {
  grid: function(n, e) {
    var t = n.xAxisModels, r = n.yAxisModels, i = n.gridModels, o = Ee(), a = {}, s = {};
    !t && !r && !i || (I(t, function(l) {
      var u = l.axis.grid.model;
      o.set(u.id, u), a[u.id] = !0;
    }), I(r, function(l) {
      var u = l.axis.grid.model;
      o.set(u.id, u), s[u.id] = !0;
    }), I(i, function(l) {
      o.set(l.id, l), a[l.id] = !0, s[l.id] = !0;
    }), o.each(function(l) {
      var u = l.coordinateSystem, c = [];
      I(u.getCartesians(), function(h, f) {
        (ct(t, h.getAxis("x").model) >= 0 || ct(r, h.getAxis("y").model) >= 0) && c.push(h);
      }), e.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: c[0],
        coordSyses: c,
        getPanelRect: vW.grid,
        xAxisDeclared: a[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(n, e) {
    I(n.geoModels, function(t) {
      var r = t.coordinateSystem;
      e.push({
        panelId: "geo--" + t.id,
        geoModel: t,
        coordSysModel: t,
        coordSys: r,
        coordSyses: [r],
        getPanelRect: vW.geo
      });
    });
  }
}, gW = [
  // grid
  function(n, e) {
    var t = n.xAxisModel, r = n.yAxisModel, i = n.gridModel;
    return !i && t && (i = t.axis.grid.model), !i && r && (i = r.axis.grid.model), i && i === e.gridModel;
  },
  // geo
  function(n, e) {
    var t = n.geoModel;
    return t && t === e.geoModel;
  }
], vW = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var n = this.coordSys, e = n.getBoundingRect().clone();
    return e.applyTransform(Wf(n)), e;
  }
}, kk = {
  lineX: Je(mW, 0),
  lineY: Je(mW, 1),
  rect: function(n, e, t, r) {
    var i = n ? e.pointToData([t[0][0], t[1][0]], r) : e.dataToPoint([t[0][0], t[1][0]], r), o = n ? e.pointToData([t[0][1], t[1][1]], r) : e.dataToPoint([t[0][1], t[1][1]], r), a = [VD([i[0], o[0]]), VD([i[1], o[1]])];
    return {
      values: a,
      xyMinMax: a
    };
  },
  polygon: function(n, e, t, r) {
    var i = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], o = le(t, function(a) {
      var s = n ? e.pointToData(a, r) : e.dataToPoint(a, r);
      return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
    });
    return {
      values: o,
      xyMinMax: i
    };
  }
};
function mW(n, e, t, r) {
  process.env.NODE_ENV !== "production" && $e(t.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var i = t.getAxis(["x", "y"][n]), o = VD(le([0, 1], function(s) {
    return e ? i.coordToData(i.toLocalCoord(r[s]), !0) : i.toGlobalCoord(i.dataToCoord(r[s]));
  })), a = [];
  return a[n] = o, a[1 - n] = [NaN, NaN], {
    values: o,
    xyMinMax: a
  };
}
var yW = {
  lineX: Je(bW, 0),
  lineY: Je(bW, 1),
  rect: function(n, e, t) {
    return [[n[0][0] - t[0] * e[0][0], n[0][1] - t[0] * e[0][1]], [n[1][0] - t[1] * e[1][0], n[1][1] - t[1] * e[1][1]]];
  },
  polygon: function(n, e, t) {
    return le(n, function(r, i) {
      return [r[0] - t[0] * e[i][0], r[1] - t[1] * e[i][1]];
    });
  }
};
function bW(n, e, t, r) {
  return [e[0] - r[n] * t[0], e[1] - r[n] * t[1]];
}
function k5t(n, e) {
  var t = OW(n), r = OW(e), i = [t[0] / r[0], t[1] / r[1]];
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
}
function OW(n) {
  return n ? [n[0][1] - n[0][0], n[1][1] - n[1][0]] : [NaN, NaN];
}
const x$ = A5t;
var zD = I, P5t = Sxt("toolbox-dataZoom_"), E5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i, o) {
      this._brushController || (this._brushController = new n$(i.getZr()), this._brushController.on("brush", _e(this._onBrush, this)).mount()), L5t(t, r, this, o, i), D5t(t, r);
    }, e.prototype.onclick = function(t, r, i) {
      M5t[i].call(this);
    }, e.prototype.remove = function(t, r) {
      this._brushController && this._brushController.unmount();
    }, e.prototype.dispose = function(t, r) {
      this._brushController && this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var r = t.areas;
      if (!t.isEnd || !r.length)
        return;
      var i = {}, o = this.ecModel;
      this._brushController.updateCovers([]);
      var a = new x$(S$(this.model), o, {
        include: ["grid"]
      });
      a.matchOutputRanges(r, o, function(u, c, h) {
        if (h.type === "cartesian2d") {
          var f = u.brushType;
          f === "rect" ? (s("x", h, c[0]), s("y", h, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[f], h, c);
        }
      }), b5t(o, i), this._dispatchZoomAction(i);
      function s(u, c, h) {
        var f = c.getAxis(u), d = f.model, p = l(u, d, o), g = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (h = Bd(0, h.slice(), f.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: h[0],
          endValue: h[1]
        });
      }
      function l(u, c, h) {
        var f;
        return h.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, c.componentIndex);
          p && (f = d);
        }), f;
      }
    }, e.prototype._dispatchZoomAction = function(t) {
      var r = [];
      zD(t, function(i, o) {
        r.push(Fe(i));
      }), r.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: r
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: t.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return r;
    }, e;
  }(pa)
), M5t = {
  zoom: function() {
    var n = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: n
    });
  },
  back: function() {
    this._dispatchZoomAction(O5t(this.ecModel));
  }
};
function S$(n) {
  var e = {
    xAxisIndex: n.get("xAxisIndex", !0),
    yAxisIndex: n.get("yAxisIndex", !0),
    xAxisId: n.get("xAxisId", !0),
    yAxisId: n.get("yAxisId", !0)
  };
  return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e;
}
function D5t(n, e) {
  n.setIconStatus("back", x5t(e) > 1 ? "emphasis" : "normal");
}
function L5t(n, e, t, r, i) {
  var o = t._isZoomActive;
  r && r.type === "takeGlobalCursor" && (o = r.key === "dataZoomSelect" ? r.dataZoomSelectActive : !1), t._isZoomActive = o, n.setIconStatus("zoom", o ? "emphasis" : "normal");
  var a = new x$(S$(n), e, {
    include: ["grid"]
  }), s = a.makePanelOpts(i, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  t._brushController.setPanels(s).enableBrush(o && s.length ? {
    brushType: "auto",
    brushStyle: n.getModel("brushStyle").getItemStyle()
  } : !1);
}
tCt("dataZoom", function(n) {
  var e = n.getComponent("toolbox", 0), t = ["feature", "dataZoom"];
  if (!e || e.get(t) == null)
    return;
  var r = e.getModel(t), i = [], o = S$(r), a = Iy(n, o);
  zD(a.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), zD(a.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, c) {
    var h = l.componentIndex, f = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: r.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: P5t + u + h
    };
    f[c] = h, i.push(f);
  }
  return i;
});
const I5t = E5t;
function R5t(n) {
  n.registerComponentModel(KBt), n.registerComponentView(n5t), Tp("saveAsImage", i5t), Tp("magicType", s5t), Tp("dataView", y5t), Tp("dataZoom", I5t), Tp("restore", _5t), ft(XBt);
}
var N5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "tooltip", e.dependencies = ["axisPointer"], e.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(Pt)
);
const $5t = N5t;
function moe(n) {
  var e = n.get("confine");
  return e != null ? !!e : n.get("renderMode") === "richText";
}
function yoe(n) {
  if (mt.domSupported) {
    for (var e = document.documentElement.style, t = 0, r = n.length; t < r; t++)
      if (n[t] in e)
        return n[t];
  }
}
var boe = yoe(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), B5t = yoe(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function Ooe(n, e) {
  if (!n)
    return e;
  e = qee(e, !0);
  var t = n.indexOf(e);
  return n = t === -1 ? e : "-" + n.slice(0, t) + "-" + e, n.toLowerCase();
}
function V5t(n, e) {
  var t = n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(n);
  return t ? e ? t[e] : t : null;
}
var z5t = Ooe(B5t, "transition"), _$ = Ooe(boe, "transform"), F5t = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (mt.transform3dSupported ? "will-change:transform;" : "");
function Q5t(n) {
  return n = n === "left" ? "right" : n === "right" ? "left" : n === "top" ? "bottom" : "top", n;
}
function Z5t(n, e, t) {
  if (!we(t) || t === "inside")
    return "";
  var r = n.get("backgroundColor"), i = n.get("borderWidth");
  e = gd(e);
  var o = Q5t(t), a = Math.max(Math.round(i) * 1.5, 6), s = "", l = _$ + ":", u;
  ct(["left", "right"], o) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = o === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = o === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, h = a + i, f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), d = Math.round(((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - h) / 2) * 100) / 100;
  s += ";" + o + ":-" + d + "px";
  var p = e + " solid " + i + "px;", g = ["position:absolute;width:" + a + "px;height:" + a + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + r + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function W5t(n, e) {
  var t = "cubic-bezier(0.23,1,0.32,1)", r = " " + n / 2 + "s " + t, i = "opacity" + r + ",visibility" + r;
  return e || (r = " " + n + "s " + t, i += mt.transformSupported ? "," + _$ + r : ",left" + r + ",top" + r), z5t + ":" + i;
}
function wW(n, e, t) {
  var r = n.toFixed(0) + "px", i = e.toFixed(0) + "px";
  if (!mt.transformSupported)
    return t ? "top:" + i + ";left:" + r + ";" : [["top", i], ["left", r]];
  var o = mt.transform3dSupported, a = "translate" + (o ? "3d" : "") + "(" + r + "," + i + (o ? ",0" : "") + ")";
  return t ? "top:0;left:0;" + _$ + ":" + a + ";" : [["top", 0], ["left", 0], [boe, a]];
}
function G5t(n) {
  var e = [], t = n.get("fontSize"), r = n.getTextColor();
  r && e.push("color:" + r), e.push("font:" + n.getFont()), t && e.push("line-height:" + Math.round(t * 3 / 2) + "px");
  var i = n.get("textShadowColor"), o = n.get("textShadowBlur") || 0, a = n.get("textShadowOffsetX") || 0, s = n.get("textShadowOffsetY") || 0;
  return i && o && e.push("text-shadow:" + a + "px " + s + "px " + o + "px " + i), I(["decoration", "align"], function(l) {
    var u = n.get(l);
    u && e.push("text-" + l + ":" + u);
  }), e.join(";");
}
function j5t(n, e, t) {
  var r = [], i = n.get("transitionDuration"), o = n.get("backgroundColor"), a = n.get("shadowBlur"), s = n.get("shadowColor"), l = n.get("shadowOffsetX"), u = n.get("shadowOffsetY"), c = n.getModel("textStyle"), h = Tte(n, "html"), f = l + "px " + u + "px " + a + "px " + s;
  return r.push("box-shadow:" + f), e && i && r.push(W5t(i, t)), o && r.push("background-color:" + o), I(["width", "color", "radius"], function(d) {
    var p = "border-" + d, g = qee(p), v = n.get(g);
    v != null && r.push(p + ":" + v + (d === "color" ? "" : "px"));
  }), r.push(G5t(c)), h != null && r.push("padding:" + $v(h).join("px ") + "px"), r.join(";") + ";";
}
function xW(n, e, t, r, i) {
  var o = e && e.painter;
  if (t) {
    var a = o && o.getViewportRoot();
    a && YOt(n, a, t, r, i);
  } else {
    n[0] = r, n[1] = i;
    var s = o && o.getViewportRootOffset();
    s && (n[0] += s.offsetLeft, n[1] += s.offsetTop);
  }
  n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight();
}
var H5t = (
  /** @class */
  function() {
    function n(e, t) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, mt.wxa)
        return null;
      var r = document.createElement("div");
      r.domBelongToZr = !0, this.el = r;
      var i = this._zr = e.getZr(), o = t.appendTo, a = o && (we(o) ? document.querySelector(o) : ud(o) ? o : Le(o) && o(e.getDom()));
      xW(this._styleCoord, i, a, e.getWidth() / 2, e.getHeight() / 2), (a || e.getDom()).appendChild(r), this._api = e, this._container = a;
      var s = this;
      r.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, r.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          sa(c, l, !0), u.dispatch("mousemove", l);
        }
      }, r.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return n.prototype.update = function(e) {
      if (!this._container) {
        var t = this._api.getDom(), r = V5t(t, "position"), i = t.style;
        i.position !== "absolute" && r !== "absolute" && (i.position = "relative");
      }
      var o = e.get("alwaysShowContent");
      o && this._moveIfResized(), this._alwaysShowContent = o, this.el.className = e.get("className") || "";
    }, n.prototype.show = function(e, t) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var r = this.el, i = r.style, o = this._styleCoord;
      r.innerHTML ? i.cssText = F5t + j5t(e, !this._firstShow, this._longHide) + wW(o[0], o[1], !0) + ("border-color:" + gd(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, n.prototype.setContent = function(e, t, r, i, o) {
      var a = this.el;
      if (e == null) {
        a.innerHTML = "";
        return;
      }
      var s = "";
      if (we(o) && r.get("trigger") === "item" && !moe(r) && (s = Z5t(r, i, o)), we(e))
        a.innerHTML = e + s;
      else if (e) {
        a.innerHTML = "", se(e) || (e = [e]);
        for (var l = 0; l < e.length; l++)
          ud(e[l]) && e[l].parentNode !== a && a.appendChild(e[l]);
        if (s && a.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, a.appendChild(u);
        }
      }
    }, n.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, n.prototype.getSize = function() {
      var e = this.el;
      return [e.offsetWidth, e.offsetHeight];
    }, n.prototype.moveTo = function(e, t) {
      var r = this._styleCoord;
      if (xW(r, this._zr, this._container, e, t), r[0] != null && r[1] != null) {
        var i = this.el.style, o = wW(r[0], r[1]);
        I(o, function(a) {
          i[a[0]] = a[1];
        });
      }
    }, n.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, n.prototype.hide = function() {
      var e = this, t = this.el.style;
      t.visibility = "hidden", t.opacity = "0", mt.transform3dSupported && (t.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return e._longHide = !0;
      }, 500);
    }, n.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(_e(this.hide, this), e)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var e = this.el.parentNode;
      e && e.removeChild(this.el), this.el = this._container = null;
    }, n;
  }()
);
const q5t = H5t;
var Y5t = (
  /** @class */
  function() {
    function n(e) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = e.getZr(), _W(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return n.prototype.update = function(e) {
      var t = e.get("alwaysShowContent");
      t && this._moveIfResized(), this._alwaysShowContent = t;
    }, n.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, n.prototype.setContent = function(e, t, r, i, o) {
      var a = this;
      Ne(e) && Gt(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = r.getModel("textStyle");
      this.el = new Nt({
        style: {
          rich: t.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: r.get(["textStyle", "color"]),
          padding: Tte(r, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: r.get("z")
      }), I(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        a.el.style[u] = r.get(u);
      }), I(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        a.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, n.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, n.prototype.getSize = function() {
      var e = this.el, t = this.el.getBoundingRect(), r = SW(e.style);
      return [t.width + r.left + r.right, t.height + r.top + r.bottom];
    }, n.prototype.moveTo = function(e, t) {
      var r = this.el;
      if (r) {
        var i = this._styleCoord;
        _W(i, this._zr, e, t), e = i[0], t = i[1];
        var o = r.style, a = Yu(o.borderWidth || 0), s = SW(o);
        r.x = e + a + s.left, r.y = t + a + s.top, r.markRedraw();
      }
    }, n.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, n.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, n.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(_e(this.hide, this), e)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, n;
  }()
);
function Yu(n) {
  return Math.max(0, n);
}
function SW(n) {
  var e = Yu(n.shadowBlur || 0), t = Yu(n.shadowOffsetX || 0), r = Yu(n.shadowOffsetY || 0);
  return {
    left: Yu(e - t),
    right: Yu(e + t),
    top: Yu(e - r),
    bottom: Yu(e + r)
  };
}
function _W(n, e, t, r) {
  n[0] = t, n[1] = r, n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight();
}
var X5t = new Lt({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), U5t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      if (!(mt.node || !r.getDom())) {
        var i = t.getComponent("tooltip"), o = this._renderMode = Ext(i.get("renderMode"));
        this._tooltipContent = o === "richText" ? new Y5t(r) : new q5t(r, {
          appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
        });
      }
    }, e.prototype.render = function(t, r, i) {
      if (!(mt.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = t, this._ecModel = r, this._api = i;
        var o = this._tooltipContent;
        o.update(t), o.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? Zv(this, "_updatePosition", 50, "fixRate") : Q0(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var t = this._tooltipModel, r = t.get("triggerOn");
      roe("itemTooltip", this._api, _e(function(i, o, a) {
        r !== "none" && (r.indexOf(i) >= 0 ? this._tryShow(o, a) : i === "leave" && this._hide(a));
      }, this));
    }, e.prototype._keepShow = function() {
      var t = this._tooltipModel, r = this._ecModel, i = this._api, o = t.get("triggerOn");
      if (this._lastX != null && this._lastY != null && o !== "none" && o !== "click") {
        var a = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && a.manuallyShowTip(t, r, i, {
            x: a._lastX,
            y: a._lastY,
            dataByCoordSys: a._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(t, r, i, o) {
      if (!(o.from === this.uid || mt.node || !i.getDom())) {
        var a = CW(o, i);
        this._ticket = "";
        var s = o.dataByCoordSys, l = tVt(o, r, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: o.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, a);
        } else if (o.tooltip && o.x != null && o.y != null) {
          var c = X5t;
          c.x = o.x, c.y = o.y, c.update(), He(c).tooltipConfig = {
            name: null,
            option: o.tooltip
          }, this._tryShow({
            offsetX: o.x,
            offsetY: o.y,
            target: c
          }, a);
        } else if (s)
          this._tryShow({
            offsetX: o.x,
            offsetY: o.y,
            position: o.position,
            dataByCoordSys: s,
            tooltipOption: o.tooltipOption
          }, a);
        else if (o.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, r, i, o))
            return;
          var h = ioe(o, r), f = h.point[0], d = h.point[1];
          f != null && d != null && this._tryShow({
            offsetX: f,
            offsetY: d,
            target: h.el,
            position: o.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, a);
        } else
          o.x != null && o.y != null && (i.dispatchAction({
            type: "updateAxisPointer",
            x: o.x,
            y: o.y
          }), this._tryShow({
            offsetX: o.x,
            offsetY: o.y,
            position: o.position,
            target: i.getZr().findHover(o.x, o.y).target
          }, a));
      }
    }, e.prototype.manuallyHideTip = function(t, r, i, o) {
      var a = this._tooltipContent;
      this._tooltipModel && a.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, o.from !== this.uid && this._hide(CW(o, i));
    }, e.prototype._manuallyAxisShowTip = function(t, r, i, o) {
      var a = o.seriesIndex, s = o.dataIndex, l = r.getComponent("axisPointer").coordSysAxesInfo;
      if (!(a == null || s == null || l == null)) {
        var u = r.getSeriesByIndex(a);
        if (u) {
          var c = u.getData(), h = Em([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (h.get("trigger") === "axis")
            return i.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: a,
              dataIndex: s,
              position: o.position
            }), !0;
        }
      }
    }, e.prototype._tryShow = function(t, r) {
      var i = t.target, o = this._tooltipModel;
      if (o) {
        this._lastX = t.offsetX, this._lastY = t.offsetY;
        var a = t.dataByCoordSys;
        if (a && a.length)
          this._showAxisTooltip(a, t);
        else if (i) {
          var s = He(i);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          _f(i, function(c) {
            if (He(c).dataIndex != null)
              return l = c, !0;
            if (He(c).tooltipConfig != null)
              return u = c, !0;
          }, !0), l ? this._showSeriesItemTooltip(t, l, r) : u ? this._showComponentItemTooltip(t, u, r) : this._hide(r);
        } else
          this._lastDataByCoordSys = null, this._hide(r);
      }
    }, e.prototype._showOrMove = function(t, r) {
      var i = t.get("showDelay");
      r = _e(r, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(r, i) : r();
    }, e.prototype._showAxisTooltip = function(t, r) {
      var i = this._ecModel, o = this._tooltipModel, a = [r.offsetX, r.offsetY], s = Em([r.tooltipOption], o), l = this._renderMode, u = [], c = Qr("section", {
        blocks: [],
        noHeader: !0
      }), h = [], f = new hT();
      I(t, function(y) {
        I(y.dataByAxis, function(b) {
          var O = i.getComponent(b.axisDim + "Axis", b.axisIndex), w = b.value;
          if (!(!O || w == null)) {
            var x = eoe(w, O.axis, i, b.seriesDataIndices, b.valueLabelOpt), S = Qr("section", {
              header: x,
              noHeader: !is(x),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(S), I(b.seriesDataIndices, function(_) {
              var C = i.getSeriesByIndex(_.seriesIndex), A = _.dataIndexInside, k = C.getDataParams(A);
              if (!(k.dataIndex < 0)) {
                k.axisDim = b.axisDim, k.axisIndex = b.axisIndex, k.axisType = b.axisType, k.axisId = b.axisId, k.axisValue = CN(O.axis, {
                  value: w
                }), k.axisValueLabel = x, k.marker = f.makeTooltipMarker("item", gd(k.color), l);
                var P = a6(C.formatTooltip(A, !0, null)), L = P.frag;
                if (L) {
                  var D = Em([C], o).get("valueFormatter");
                  S.blocks.push(D ? re({
                    valueFormatter: D
                  }, L) : L);
                }
                P.text && h.push(P.text), u.push(k);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var d = r.position, p = s.get("order"), g = f6(c, f, l, p, i.get("useUTC"), s.get("textStyle"));
      g && h.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", m = h.join(v);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(s, d, a[0], a[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", a[0], a[1], d, null, f);
      });
    }, e.prototype._showSeriesItemTooltip = function(t, r, i) {
      var o = this._ecModel, a = He(r), s = a.seriesIndex, l = o.getSeriesByIndex(s), u = a.dataModel || l, c = a.dataIndex, h = a.dataType, f = u.getData(h), d = this._renderMode, p = t.positionDefault, g = Em([f.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var m = u.getDataParams(c, h), y = new hT();
        m.marker = y.makeTooltipMarker("item", gd(m.color), d);
        var b = a6(u.formatTooltip(c, !1, h)), O = g.get("order"), w = g.get("valueFormatter"), x = b.frag, S = x ? f6(w ? re({
          valueFormatter: w
        }, x) : x, y, d, O, o.get("useUTC"), g.get("textStyle")) : b.text, _ = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, S, m, _, t.offsetX, t.offsetY, t.position, t.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: f.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(t, r, i) {
      var o = He(r), a = o.tooltipConfig, s = a.option || {};
      if (we(s)) {
        var l = s;
        s = {
          content: l,
          // Fixed formatter
          formatter: l
        };
      }
      var u = [s], c = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      c && u.push(c), u.push({
        formatter: s.content
      });
      var h = t.positionDefault, f = Em(u, this._tooltipModel, h ? {
        position: h
      } : null), d = f.get("content"), p = Math.random() + "", g = new hT();
      this._showOrMove(f, function() {
        var v = Fe(f.get("formatterParams") || {});
        this._showTooltipContent(f, d, v, p, t.offsetX, t.offsetY, t.position, r, g);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(t, r, i, o, a, s, l, u, c) {
      if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(t.get("enterable"));
        var f = t.get("formatter");
        l = l || t.get("position");
        var d = r, p = this._getNearestPoint([a, s], i, t.get("trigger"), t.get("borderColor")), g = p.color;
        if (f)
          if (we(f)) {
            var v = t.ecModel.get("useUTC"), m = se(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
            d = f, y && (d = EC(m.axisValue, d, v)), d = Yee(d, i, !0);
          } else if (Le(f)) {
            var b = _e(function(O, w) {
              O === this._ticket && (h.setContent(w, c, t, g, l), this._updatePosition(t, l, a, s, h, i, u));
            }, this);
            this._ticket = o, d = f(i, o, b);
          } else
            d = f;
        h.setContent(d, c, t, g, l), h.show(t, g), this._updatePosition(t, l, a, s, h, i, u);
      }
    }, e.prototype._getNearestPoint = function(t, r, i, o) {
      if (i === "axis" || se(r))
        return {
          color: o || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!se(r))
        return {
          color: o || r.color || r.borderColor
        };
    }, e.prototype._updatePosition = function(t, r, i, o, a, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      r = r || t.get("position");
      var h = a.getSize(), f = t.get("align"), d = t.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), Le(r) && (r = r([i, o], s, a.el, p, {
        viewSize: [u, c],
        contentSize: h.slice()
      })), se(r))
        i = be(r[0], u), o = be(r[1], c);
      else if (Ne(r)) {
        var g = r;
        g.width = h[0], g.height = h[1];
        var v = Cr(g, {
          width: u,
          height: c
        });
        i = v.x, o = v.y, f = null, d = null;
      } else if (we(r) && l) {
        var m = eVt(r, p, h, t.get("borderWidth"));
        i = m[0], o = m[1];
      } else {
        var m = K5t(i, o, a, u, c, f ? null : 20, d ? null : 20);
        i = m[0], o = m[1];
      }
      if (f && (i -= AW(f) ? h[0] / 2 : f === "right" ? h[0] : 0), d && (o -= AW(d) ? h[1] / 2 : d === "bottom" ? h[1] : 0), moe(t)) {
        var m = J5t(i, o, a, u, c);
        i = m[0], o = m[1];
      }
      a.moveTo(i, o);
    }, e.prototype._updateContentNotChangedOnAxis = function(t, r) {
      var i = this._lastDataByCoordSys, o = this._cbParamsList, a = !!i && i.length === t.length;
      return a && I(i, function(s, l) {
        var u = s.dataByAxis || [], c = t[l] || {}, h = c.dataByAxis || [];
        a = a && u.length === h.length, a && I(u, function(f, d) {
          var p = h[d] || {}, g = f.seriesDataIndices || [], v = p.seriesDataIndices || [];
          a = a && f.value === p.value && f.axisType === p.axisType && f.axisId === p.axisId && g.length === v.length, a && I(g, function(m, y) {
            var b = v[y];
            a = a && m.seriesIndex === b.seriesIndex && m.dataIndex === b.dataIndex;
          }), o && I(f.seriesDataIndices, function(m) {
            var y = m.seriesIndex, b = r[y], O = o[y];
            b && O && O.data !== b.data && (a = !1);
          });
        });
      }), this._lastDataByCoordSys = t, this._cbParamsList = r, !!a;
    }, e.prototype._hide = function(t) {
      this._lastDataByCoordSys = null, t({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(t, r) {
      mt.node || !r.getDom() || (Q0(this, "_updatePosition"), this._tooltipContent.dispose(), RD("itemTooltip", r));
    }, e.type = "tooltip", e;
  }(Gn)
);
function Em(n, e, t) {
  var r = e.ecModel, i;
  t ? (i = new mn(t, r, r), i = new mn(e.option, i, r)) : i = e;
  for (var o = n.length - 1; o >= 0; o--) {
    var a = n[o];
    a && (a instanceof mn && (a = a.get("tooltip", !0)), we(a) && (a = {
      formatter: a
    }), a && (i = new mn(a, i, r)));
  }
  return i;
}
function CW(n, e) {
  return n.dispatchAction || _e(e.dispatchAction, e);
}
function K5t(n, e, t, r, i, o, a) {
  var s = t.getSize(), l = s[0], u = s[1];
  return o != null && (n + l + o + 2 > r ? n -= l + o : n += o), a != null && (e + u + a > i ? e -= u + a : e += a), [n, e];
}
function J5t(n, e, t, r, i) {
  var o = t.getSize(), a = o[0], s = o[1];
  return n = Math.min(n + a, r) - a, e = Math.min(e + s, i) - s, n = Math.max(n, 0), e = Math.max(e, 0), [n, e];
}
function eVt(n, e, t, r) {
  var i = t[0], o = t[1], a = Math.ceil(Math.SQRT2 * r) + 8, s = 0, l = 0, u = e.width, c = e.height;
  switch (n) {
    case "inside":
      s = e.x + u / 2 - i / 2, l = e.y + c / 2 - o / 2;
      break;
    case "top":
      s = e.x + u / 2 - i / 2, l = e.y - o - a;
      break;
    case "bottom":
      s = e.x + u / 2 - i / 2, l = e.y + c + a;
      break;
    case "left":
      s = e.x - i - a, l = e.y + c / 2 - o / 2;
      break;
    case "right":
      s = e.x + u + a, l = e.y + c / 2 - o / 2;
  }
  return [s, l];
}
function AW(n) {
  return n === "center" || n === "middle";
}
function tVt(n, e, t) {
  var r = IR(n).queryOptionMap, i = r.keys()[0];
  if (!(!i || i === "series")) {
    var o = Bb(e, i, r.get(i), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), a = o.models[0];
    if (a) {
      var s = t.getViewOfComponentModel(a), l;
      if (s.group.traverse(function(u) {
        var c = He(u).tooltipConfig;
        if (c && c.name === n.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: i,
          componentIndex: a.componentIndex,
          el: l
        };
    }
  }
}
const nVt = U5t;
function rVt(n) {
  ft(t1), n.registerComponentModel($5t), n.registerComponentView(nVt), n.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, nr), n.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, nr);
}
var iVt = ["rect", "polygon", "keep", "clear"];
function oVt(n, e) {
  var t = an(n ? n.brush : []);
  if (t.length) {
    var r = [];
    I(t, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (r = r.concat(u));
    });
    var i = n && n.toolbox;
    se(i) && (i = i[0]), i || (i = {
      feature: {}
    }, n.toolbox = [i]);
    var o = i.feature || (i.feature = {}), a = o.brush || (o.brush = {}), s = a.type || (a.type = []);
    s.push.apply(s, r), aVt(s), e && !s.length && s.push.apply(s, iVt);
  }
}
function aVt(n) {
  var e = {};
  I(n, function(t) {
    e[t] = 1;
  }), n.length = 0, I(e, function(t, r) {
    n.push(r);
  });
}
var TW = I;
function kW(n) {
  if (n) {
    for (var e in n)
      if (n.hasOwnProperty(e))
        return !0;
  }
}
function FD(n, e, t) {
  var r = {};
  return TW(e, function(o) {
    var a = r[o] = i();
    TW(n[o], function(s, l) {
      if (mi.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        t && t(u, o), a[l] = new mi(u), l === "opacity" && (u = Fe(u), u.type = "colorAlpha", a.__hidden.__alphaForOpacity = new mi(u));
      }
    });
  }), r;
  function i() {
    var o = function() {
    };
    o.prototype.__hidden = o.prototype;
    var a = new o();
    return a;
  }
}
function woe(n, e, t) {
  var r;
  I(t, function(i) {
    e.hasOwnProperty(i) && kW(e[i]) && (r = !0);
  }), r && I(t, function(i) {
    e.hasOwnProperty(i) && kW(e[i]) ? n[i] = Fe(e[i]) : delete n[i];
  });
}
function sVt(n, e, t, r, i, o) {
  var a = {};
  I(n, function(h) {
    var f = mi.prepareVisualTypes(e[h]);
    a[h] = f;
  });
  var s;
  function l(h) {
    return pN(t, s, h);
  }
  function u(h, f) {
    $te(t, s, h, f);
  }
  o == null ? t.each(c) : t.each([o], c);
  function c(h, f) {
    s = o == null ? h : f;
    var d = t.getRawDataItem(s);
    if (!(d && d.visualMap === !1))
      for (var p = r.call(i, h), g = e[p], v = a[p], m = 0, y = v.length; m < y; m++) {
        var b = v[m];
        g[b] && g[b].applyVisual(h, l, u);
      }
  }
}
function lVt(n, e, t, r) {
  var i = {};
  return I(n, function(o) {
    var a = mi.prepareVisualTypes(e[o]);
    i[o] = a;
  }), {
    progress: function(a, s) {
      var l;
      r != null && (l = s.getDimensionIndex(r));
      function u(w) {
        return pN(s, h, w);
      }
      function c(w, x) {
        $te(s, h, w, x);
      }
      for (var h, f = s.getStore(); (h = a.next()) != null; ) {
        var d = s.getRawDataItem(h);
        if (!(d && d.visualMap === !1))
          for (var p = r != null ? f.get(l, h) : h, g = t(p), v = e[g], m = i[g], y = 0, b = m.length; y < b; y++) {
            var O = m[y];
            v[O] && v[O].applyVisual(p, u, c);
          }
      }
    }
  };
}
function uVt(n) {
  var e = n.brushType, t = {
    point: function(r) {
      return PW[e].point(r, t, n);
    },
    rect: function(r) {
      return PW[e].rect(r, t, n);
    }
  };
  return t;
}
var PW = {
  lineX: EW(0),
  lineY: EW(1),
  rect: {
    point: function(n, e, t) {
      return n && t.boundingRect.contain(n[0], n[1]);
    },
    rect: function(n, e, t) {
      return n && t.boundingRect.intersect(n);
    }
  },
  polygon: {
    point: function(n, e, t) {
      return n && t.boundingRect.contain(n[0], n[1]) && af(t.range, n[0], n[1]);
    },
    rect: function(n, e, t) {
      var r = t.range;
      if (!n || r.length <= 1)
        return !1;
      var i = n.x, o = n.y, a = n.width, s = n.height, l = r[0];
      if (af(r, i, o) || af(r, i + a, o) || af(r, i, o + s) || af(r, i + a, o + s) || ot.create(n).contain(l[0], l[1]) || Km(i, o, i + a, o, r) || Km(i, o, i, o + s, r) || Km(i + a, o, i + a, o + s, r) || Km(i, o + s, i + a, o + s, r))
        return !0;
    }
  }
};
function EW(n) {
  var e = ["x", "y"], t = ["width", "height"];
  return {
    point: function(r, i, o) {
      if (r) {
        var a = o.range, s = r[n];
        return Mm(s, a);
      }
    },
    rect: function(r, i, o) {
      if (r) {
        var a = o.range, s = [r[e[n]], r[e[n]] + r[t[n]]];
        return s[1] < s[0] && s.reverse(), Mm(s[0], a) || Mm(s[1], a) || Mm(a[0], s) || Mm(a[1], s);
      }
    }
  };
}
function Mm(n, e) {
  return e[0] <= n && n <= e[1];
}
var MW = ["inBrush", "outOfBrush"], Pk = "__ecBrushSelect", QD = "__ecInBrushSelectEvent";
function xoe(n) {
  n.eachComponent({
    mainType: "brush"
  }, function(e) {
    var t = e.brushTargetManager = new x$(e.option, n);
    t.setInputRanges(e.areas, n);
  });
}
function cVt(n, e, t) {
  var r = [], i, o;
  n.eachComponent({
    mainType: "brush"
  }, function(a) {
    t && t.type === "takeGlobalCursor" && a.setBrushOption(t.key === "brush" ? t.brushOption : {
      brushType: !1
    });
  }), xoe(n), n.eachComponent({
    mainType: "brush"
  }, function(a, s) {
    var l = {
      brushId: a.id,
      brushIndex: s,
      brushName: a.name,
      areas: Fe(a.areas),
      selected: []
    };
    r.push(l);
    var u = a.option, c = u.brushLink, h = [], f = [], d = [], p = !1;
    s || (i = u.throttleType, o = u.throttleDelay);
    var g = le(a.areas, function(w) {
      var x = pVt[w.brushType], S = Be({
        boundingRect: x ? x(w) : void 0
      }, w);
      return S.selectors = uVt(S), S;
    }), v = FD(a.option, MW, function(w) {
      w.mappingMethod = "fixed";
    });
    se(c) && I(c, function(w) {
      h[w] = 1;
    });
    function m(w) {
      return c === "all" || !!h[w];
    }
    function y(w) {
      return !!w.length;
    }
    n.eachSeries(function(w, x) {
      var S = d[x] = [];
      w.subType === "parallel" ? b(w, x) : O(w, x, S);
    });
    function b(w, x) {
      var S = w.coordinateSystem;
      p = p || S.hasAxisBrushed(), m(x) && S.eachActiveState(w.getData(), function(_, C) {
        _ === "active" && (f[C] = 1);
      });
    }
    function O(w, x, S) {
      if (!(!w.brushSelector || dVt(a, x)) && (I(g, function(C) {
        a.brushTargetManager.controlSeries(C, w, n) && S.push(C), p = p || y(S);
      }), m(x) && y(S))) {
        var _ = w.getData();
        _.each(function(C) {
          DW(w, S, _, C) && (f[C] = 1);
        });
      }
    }
    n.eachSeries(function(w, x) {
      var S = {
        seriesId: w.id,
        seriesIndex: x,
        seriesName: w.name,
        dataIndex: []
      };
      l.selected.push(S);
      var _ = d[x], C = w.getData(), A = m(x) ? function(k) {
        return f[k] ? (S.dataIndex.push(C.getRawIndex(k)), "inBrush") : "outOfBrush";
      } : function(k) {
        return DW(w, _, C, k) ? (S.dataIndex.push(C.getRawIndex(k)), "inBrush") : "outOfBrush";
      };
      (m(x) ? p : y(_)) && sVt(MW, v, C, A);
    });
  }), hVt(e, i, o, r, t);
}
function hVt(n, e, t, r, i) {
  if (i) {
    var o = n.getZr();
    if (!o[QD]) {
      o[Pk] || (o[Pk] = fVt);
      var a = Zv(o, Pk, t, e);
      a(n, r);
    }
  }
}
function fVt(n, e) {
  if (!n.isDisposed()) {
    var t = n.getZr();
    t[QD] = !0, n.dispatchAction({
      type: "brushSelect",
      batch: e
    }), t[QD] = !1;
  }
}
function DW(n, e, t, r) {
  for (var i = 0, o = e.length; i < o; i++) {
    var a = e[i];
    if (n.brushSelector(r, t, a.selectors, a))
      return !0;
  }
}
function dVt(n, e) {
  var t = n.option.seriesIndex;
  return t != null && t !== "all" && (se(t) ? ct(t, e) < 0 : e !== t);
}
var pVt = {
  rect: function(n) {
    return LW(n.range);
  },
  polygon: function(n) {
    for (var e, t = n.range, r = 0, i = t.length; r < i; r++) {
      e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var o = t[r];
      o[0] < e[0][0] && (e[0][0] = o[0]), o[0] > e[0][1] && (e[0][1] = o[0]), o[1] < e[1][0] && (e[1][0] = o[1]), o[1] > e[1][1] && (e[1][1] = o[1]);
    }
    return e && LW(e);
  }
};
function LW(n) {
  return new ot(n[0][0], n[1][0], n[0][1] - n[0][0], n[1][1] - n[1][0]);
}
var gVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      this.ecModel = t, this.api = r, this.model, (this._brushController = new n$(r.getZr())).on("brush", _e(this._onBrush, this)).mount();
    }, e.prototype.render = function(t, r, i, o) {
      this.model = t, this._updateController(t, r, i, o);
    }, e.prototype.updateTransform = function(t, r, i, o) {
      xoe(r), this._updateController(t, r, i, o);
    }, e.prototype.updateVisual = function(t, r, i, o) {
      this.updateTransform(t, r, i, o);
    }, e.prototype.updateView = function(t, r, i, o) {
      this._updateController(t, r, i, o);
    }, e.prototype._updateController = function(t, r, i, o) {
      (!o || o.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var r = this.model.id, i = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
      (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: r,
        areas: Fe(i),
        $from: r
      }), t.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: r,
        areas: Fe(i),
        $from: r
      });
    }, e.type = "brush", e;
  }(Gn)
);
const vVt = gVt;
var mVt = "#ddd", yVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.areas = [], t.brushOption = {}, t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      var i = this.option;
      !r && woe(i, t, ["inBrush", "outOfBrush"]);
      var o = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: mVt
      }, o.hasOwnProperty("liftZ") || (o.liftZ = 5);
    }, e.prototype.setAreas = function(t) {
      process.env.NODE_ENV !== "production" && ($e(se(t)), I(t, function(r) {
        $e(r.brushType, "Illegal areas");
      })), t && (this.areas = le(t, function(r) {
        return IW(this.option, r);
      }, this));
    }, e.prototype.setBrushOption = function(t) {
      this.brushOption = IW(this.option, t), this.brushType = this.brushOption.brushType;
    }, e.type = "brush", e.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], e.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, e;
  }(Pt)
);
function IW(n, e) {
  return it({
    brushType: n.brushType,
    brushMode: n.brushMode,
    transformable: n.transformable,
    brushStyle: new mn(n.brushStyle).getItemStyle(),
    removeOnClick: n.removeOnClick,
    z: n.z
  }, e, !0);
}
const bVt = yVt;
var OVt = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], wVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i) {
      var o, a, s;
      r.eachComponent({
        mainType: "brush"
      }, function(l) {
        o = l.brushType, a = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = o, this._brushMode = a, I(t.get("type", !0), function(l) {
        t.setIconStatus(l, (l === "keep" ? a === "multiple" : l === "clear" ? s : l === o) ? "emphasis" : "normal");
      });
    }, e.prototype.updateView = function(t, r, i) {
      this.render(t, r, i);
    }, e.prototype.getIcons = function() {
      var t = this.model, r = t.get("icon", !0), i = {};
      return I(t.get("type", !0), function(o) {
        r[o] && (i[o] = r[o]);
      }), i;
    }, e.prototype.onclick = function(t, r, i) {
      var o = this._brushType, a = this._brushMode;
      i === "clear" ? (r.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), r.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : r.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? o : o === i ? !1 : i,
          brushMode: i === "keep" ? a === "multiple" ? "single" : "multiple" : a
        }
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        type: OVt.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: t.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return r;
    }, e;
  }(pa)
);
const xVt = wVt;
function SVt(n) {
  n.registerComponentView(vVt), n.registerComponentModel(bVt), n.registerPreprocessor(oVt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, cVt), n.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(e, t) {
    t.eachComponent({
      mainType: "brush",
      query: e
    }, function(r) {
      r.setAreas(e.areas);
    });
  }), n.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, nr), n.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, nr), Tp("brush", xVt);
}
var _Vt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t;
    }
    return e.type = "title", e.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(Pt)
), CVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var o = this.group, a = t.getModel("textStyle"), s = t.getModel("subtextStyle"), l = t.get("textAlign"), u = qe(t.get("textBaseline"), t.get("textVerticalAlign")), c = new Nt({
          style: vn(a, {
            text: t.get("text"),
            fill: a.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = c.getBoundingRect(), f = t.get("subtext"), d = new Nt({
          style: vn(s, {
            text: f,
            fill: s.getTextColor(),
            y: h.height + t.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), p = t.get("link"), g = t.get("sublink"), v = t.get("triggerEvent", !0);
        c.silent = !p && !v, d.silent = !g && !v, p && c.on("click", function() {
          xS(p, "_" + t.get("target"));
        }), g && d.on("click", function() {
          xS(g, "_" + t.get("subtarget"));
        }), He(c).eventData = He(d).eventData = v ? {
          componentType: "title",
          componentIndex: t.componentIndex
        } : null, o.add(c), f && o.add(d);
        var m = o.getBoundingRect(), y = t.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var b = Cr(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, t.get("padding"));
        l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? b.x += b.width : l === "center" && (b.x += b.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? b.y += b.height : u === "middle" && (b.y += b.height / 2), u = u || "top"), o.x = b.x, o.y = b.y, o.markRedraw();
        var O = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(O), d.setStyle(O), m = o.getBoundingRect();
        var w = b.margin, x = t.getItemStyle(["color", "opacity"]);
        x.fill = t.get("backgroundColor");
        var S = new Lt({
          shape: {
            x: m.x - w[3],
            y: m.y - w[0],
            width: m.width + w[1] + w[3],
            height: m.height + w[0] + w[2],
            r: t.get("borderRadius")
          },
          style: x,
          subPixelOptimize: !0,
          silent: !0
        });
        o.add(S);
      }
    }, e.type = "title", e;
  }(Gn)
);
function AVt(n) {
  n.registerComponentModel(_Vt), n.registerComponentView(CVt);
}
var RW = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = "box", t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i), this._initData();
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), this._initData();
    }, e.prototype.setCurrentIndex = function(t) {
      t == null && (t = this.option.currentIndex);
      var r = this._data.count();
      this.option.loop ? t = (t % r + r) % r : (t >= r && (t = r - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
    }, e.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, e.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, e.prototype.setPlayState = function(t) {
      this.option.autoPlay = !!t;
    }, e.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, e.prototype._initData = function() {
      var t = this.option, r = t.data || [], i = t.axisType, o = this._names = [], a;
      i === "category" ? (a = [], I(r, function(u, c) {
        var h = wr(Mv(u), ""), f;
        Ne(u) ? (f = Fe(u), f.value = c) : f = c, a.push(f), o.push(h);
      })) : a = r;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new Ki([{
        name: "value",
        type: s
      }], this);
      l.initData(a, o);
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, e.type = "timeline", e.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, e;
  }(Pt)
), Soe = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline.slider", e.defaultOption = ph(RW.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), e;
  }(RW)
);
mr(Soe, uN.prototype);
const TVt = Soe;
var kVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline", e;
  }(Gn)
);
const PVt = kVt;
var EVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e(t, r, i, o) {
      var a = n.call(this, t, r, i) || this;
      return a.type = o || "value", a;
    }
    return e.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, e.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, e;
  }(As)
);
const MVt = EVt;
var Ek = Math.PI, NW = It(), DVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      this.api = r;
    }, e.prototype.render = function(t, r, i) {
      if (this.model = t, this.api = i, this.ecModel = r, this.group.removeAll(), t.get("show", !0)) {
        var o = this._layout(t, i), a = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(o, t);
        t.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return Qr("nameValue", {
            noName: !0,
            value: c
          });
        }, I(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](o, a, l, t);
        }, this), this._renderAxisLabel(o, s, l, t), this._position(o, t);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, e.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._clearTimer();
    }, e.prototype._layout = function(t, r) {
      var i = t.get(["label", "position"]), o = t.get("orient"), a = IVt(t, r), s;
      i == null || i === "auto" ? s = o === "horizontal" ? a.y + a.height / 2 < r.getHeight() / 2 ? "-" : "+" : a.x + a.width / 2 < r.getWidth() / 2 ? "+" : "-" : we(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[o][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: Ek / 2
      }, h = o === "vertical" ? a.height : a.width, f = t.getModel("controlStyle"), d = f.get("show", !0), p = d ? f.get("itemSize") : 0, g = d ? f.get("itemGap") : 0, v = p + g, m = t.get(["label", "rotate"]) || 0;
      m = m * Ek / 180;
      var y, b, O, w = f.get("position", !0), x = d && f.get("showPlayBtn", !0), S = d && f.get("showPrevBtn", !0), _ = d && f.get("showNextBtn", !0), C = 0, A = h;
      w === "left" || w === "bottom" ? (x && (y = [0, 0], C += v), S && (b = [C, 0], C += v), _ && (O = [A - p, 0], A -= v)) : (x && (y = [A - p, 0], A -= v), S && (b = [0, 0], C += v), _ && (O = [A - p, 0], A -= v));
      var k = [C, A];
      return t.get("inverse") && k.reverse(), {
        viewRect: a,
        mainLength: h,
        orient: o,
        rotation: c[o],
        labelRotation: m,
        labelPosOpt: s,
        labelAlign: t.get(["label", "align"]) || l[o],
        labelBaseline: t.get(["label", "verticalAlign"]) || t.get(["label", "baseline"]) || u[o],
        // Based on mainGroup.
        playPosition: y,
        prevBtnPosition: b,
        nextBtnPosition: O,
        axisExtent: k,
        controlSize: p,
        controlGap: g
      };
    }, e.prototype._position = function(t, r) {
      var i = this._mainGroup, o = this._labelGroup, a = t.viewRect;
      if (t.orient === "vertical") {
        var s = Ho(), l = a.x, u = a.y + a.height;
        Sl(s, s, [-l, -u]), Md(s, s, -Ek / 2), Sl(s, s, [l, u]), a = a.clone(), a.applyTransform(s);
      }
      var c = y(a), h = y(i.getBoundingRect()), f = y(o.getBoundingRect()), d = [i.x, i.y], p = [o.x, o.y];
      p[0] = d[0] = c[0][0];
      var g = t.labelPosOpt;
      if (g == null || we(g)) {
        var v = g === "+" ? 0 : 1;
        b(d, h, c, 1, v), b(p, f, c, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        b(d, h, c, 1, v), p[1] = d[1] + g;
      }
      i.setPosition(d), o.setPosition(p), i.rotation = o.rotation = t.rotation, m(i), m(o);
      function m(O) {
        O.originX = c[0][0] - O.x, O.originY = c[1][0] - O.y;
      }
      function y(O) {
        return [[O.x, O.x + O.width], [O.y, O.y + O.height]];
      }
      function b(O, w, x, S, _) {
        O[S] += x[S][_] - w[S][_];
      }
    }, e.prototype._createAxis = function(t, r) {
      var i = r.getData(), o = r.get("axisType"), a = LVt(r, o);
      a.getTicks = function() {
        return i.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      a.setExtent(s[0], s[1]), a.calcNiceTicks();
      var l = new MVt("value", a, t.axisExtent, o);
      return l.model = r, l;
    }, e.prototype._createGroup = function(t) {
      var r = this[t] = new We();
      return this.group.add(r), r;
    }, e.prototype._renderAxisLine = function(t, r, i, o) {
      var a = i.getExtent();
      if (o.get(["lineStyle", "show"])) {
        var s = new Br({
          shape: {
            x1: a[0],
            y1: 0,
            x2: a[1],
            y2: 0
          },
          style: re({
            lineCap: "round"
          }, o.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        r.add(s);
        var l = this._progressLine = new Br({
          shape: {
            x1: a[0],
            x2: this._currentPointer ? this._currentPointer.x : a[0],
            y1: 0,
            y2: 0
          },
          style: Be({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, o.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        r.add(l);
      }
    }, e.prototype._renderAxisTick = function(t, r, i, o) {
      var a = this, s = o.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], I(l, function(u) {
        var c = i.dataToCoord(u.value), h = s.getItemModel(u.value), f = h.getModel("itemStyle"), d = h.getModel(["emphasis", "itemStyle"]), p = h.getModel(["progress", "itemStyle"]), g = {
          x: c,
          y: 0,
          onclick: _e(a._changeTimeline, a, u.value)
        }, v = $W(h, f, r, g);
        v.ensureState("emphasis").style = d.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), Zf(v);
        var m = He(v);
        h.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = o) : m.dataIndex = m.dataModel = null, a._tickSymbols.push(v);
      });
    }, e.prototype._renderAxisLabel = function(t, r, i, o) {
      var a = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = o.getData(), u = i.getViewLabels();
        this._tickLabels = [], I(u, function(c) {
          var h = c.tickValue, f = l.getItemModel(h), d = f.getModel("label"), p = f.getModel(["emphasis", "label"]), g = f.getModel(["progress", "label"]), v = i.dataToCoord(c.tickValue), m = new Nt({
            x: v,
            y: 0,
            rotation: t.labelRotation - t.rotation,
            onclick: _e(a._changeTimeline, a, h),
            silent: !1,
            style: vn(d, {
              text: c.formattedLabel,
              align: t.labelAlign,
              verticalAlign: t.labelBaseline
            })
          });
          m.ensureState("emphasis").style = vn(p), m.ensureState("progress").style = vn(g), r.add(m), Zf(m), NW(m).dataIndex = h, a._tickLabels.push(m);
        });
      }
    }, e.prototype._renderControl = function(t, r, i, o) {
      var a = t.controlSize, s = t.rotation, l = o.getModel("controlStyle").getItemStyle(), u = o.getModel(["emphasis", "controlStyle"]).getItemStyle(), c = o.getPlayState(), h = o.get("inverse", !0);
      f(t.nextBtnPosition, "next", _e(this._changeTimeline, this, h ? "-" : "+")), f(t.prevBtnPosition, "prev", _e(this._changeTimeline, this, h ? "+" : "-")), f(t.playPosition, c ? "stop" : "play", _e(this._handlePlayClick, this, !c), !0);
      function f(d, p, g, v) {
        if (d) {
          var m = gs(qe(o.get(["controlStyle", p + "BtnSize"]), a), a), y = [0, -m / 2, m, m], b = RVt(o, p + "Icon", y, {
            x: d[0],
            y: d[1],
            originX: a / 2,
            originY: 0,
            rotation: v ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: g
          });
          b.ensureState("emphasis").style = u, r.add(b), Zf(b);
        }
      }
    }, e.prototype._renderCurrentPointer = function(t, r, i, o) {
      var a = o.getData(), s = o.getCurrentIndex(), l = a.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(h) {
          h.draggable = !0, h.drift = _e(u._handlePointerDrag, u), h.ondragend = _e(u._handlePointerDragend, u), BW(h, u._progressLine, s, i, o, !0);
        },
        onUpdate: function(h) {
          BW(h, u._progressLine, s, i, o);
        }
      };
      this._currentPointer = $W(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, e.prototype._handlePlayClick = function(t) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: t,
        from: this.uid
      });
    }, e.prototype._handlePointerDrag = function(t, r, i) {
      this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
    }, e.prototype._handlePointerDragend = function(t) {
      this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
    }, e.prototype._pointerChangeTimeline = function(t, r) {
      var i = this._toAxisCoord(t)[0], o = this._axis, a = wa(o.getExtent().slice());
      i > a[1] && (i = a[1]), i < a[0] && (i = a[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (r || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, e.prototype._doPlayStop = function() {
      var t = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var r = t.model;
        t._changeTimeline(r.getCurrentIndex() + (r.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, e.prototype._toAxisCoord = function(t) {
      var r = this._mainGroup.getLocalTransform();
      return cs(t, r, !0);
    }, e.prototype._findNearestTick = function(t) {
      var r = this.model.getData(), i = 1 / 0, o, a = this._axis;
      return r.each(["value"], function(s, l) {
        var u = a.dataToCoord(s), c = Math.abs(u - t);
        c < i && (i = c, o = l);
      }), o;
    }, e.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, e.prototype._changeTimeline = function(t) {
      var r = this.model.getCurrentIndex();
      t === "+" ? t = r + 1 : t === "-" && (t = r - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: t,
        from: this.uid
      });
    }, e.prototype._updateTicksStatus = function() {
      var t = this.model.getCurrentIndex(), r = this._tickSymbols, i = this._tickLabels;
      if (r)
        for (var o = 0; o < r.length; o++)
          r && r[o] && r[o].toggleState("progress", o < t);
      if (i)
        for (var o = 0; o < i.length; o++)
          i && i[o] && i[o].toggleState("progress", NW(i[o]).dataIndex <= t);
    }, e.type = "timeline.slider", e;
  }(PVt)
);
function LVt(n, e) {
  if (e = e || n.get("type"), e)
    switch (e) {
      case "category":
        return new wN({
          ordinalMeta: n.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new Cne({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new Kc();
    }
}
function IVt(n, e) {
  return Cr(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  }, n.get("padding"));
}
function RVt(n, e, t, r) {
  var i = r.style, o = Qb(n.get(["controlStyle", e]), r || {}, new ot(t[0], t[1], t[2], t[3]));
  return i && o.setStyle(i), o;
}
function $W(n, e, t, r, i, o) {
  var a = e.get("color");
  if (i)
    i.setColor(a), t.add(i), o && o.onUpdate(i);
  else {
    var s = n.get("symbol");
    i = vr(s, -1, -1, 2, 2, a), i.setStyle("strokeNoScale", !0), t.add(i), o && o.onCreate(i);
  }
  var l = e.getItemStyle(["color"]);
  i.setStyle(l), r = it({
    rectHover: !0,
    z2: 100
  }, r, !0);
  var u = Wv(n.get("symbolSize"));
  r.scaleX = u[0] / 2, r.scaleY = u[1] / 2;
  var c = Id(n.get("symbolOffset"), u);
  c && (r.x = (r.x || 0) + c[0], r.y = (r.y || 0) + c[1]);
  var h = n.get("symbolRotate");
  return r.rotation = (h || 0) * Math.PI / 180 || 0, i.attr(r), i.updateTransform(), i;
}
function BW(n, e, t, r, i, o) {
  if (!n.dragging) {
    var a = i.getModel("checkpointStyle"), s = r.dataToCoord(i.getData().get("value", t));
    if (o || !a.get("animation", !0))
      n.attr({
        x: s,
        y: 0
      }), e && e.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: a.get("animationDuration", !0),
        easing: a.get("animationEasing", !0)
      };
      n.stopAnimation(null, !0), n.animateTo({
        x: s,
        y: 0
      }, l), e && e.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
const NVt = DVt;
function $Vt(n) {
  n.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(e, t, r) {
    var i = t.getComponent("timeline");
    return i && e.currentIndex != null && (i.setCurrentIndex(e.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), r.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: e.from
    }))), t.resetOption("timeline", {
      replaceMerge: i.get("replaceMerge", !0)
    }), Be({
      currentIndex: i.option.currentIndex
    }, e);
  }), n.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(e, t) {
    var r = t.getComponent("timeline");
    r && e.playState != null && r.setPlayState(e.playState);
  });
}
function BVt(n) {
  var e = n && n.timeline;
  se(e) || (e = e ? [e] : []), I(e, function(t) {
    t && VVt(t);
  });
}
function VVt(n) {
  var e = n.type, t = {
    number: "value",
    time: "time"
  };
  if (t[e] && (n.axisType = t[e], delete n.type), VW(n), uf(n, "controlPosition")) {
    var r = n.controlStyle || (n.controlStyle = {});
    uf(r, "position") || (r.position = n.controlPosition), r.position === "none" && !uf(r, "show") && (r.show = !1, delete r.position), delete n.controlPosition;
  }
  I(n.data || [], function(i) {
    Ne(i) && !se(i) && (!uf(i, "value") && uf(i, "name") && (i.value = i.name), VW(i));
  });
}
function VW(n) {
  var e = n.itemStyle || (n.itemStyle = {}), t = e.emphasis || (e.emphasis = {}), r = n.label || n.label || {}, i = r.normal || (r.normal = {}), o = {
    normal: 1,
    emphasis: 1
  };
  I(r, function(a, s) {
    !o[s] && !uf(i, s) && (i[s] = a);
  }), t.label && !uf(r, "emphasis") && (r.emphasis = t.label, delete t.label);
}
function uf(n, e) {
  return n.hasOwnProperty(e);
}
function zVt(n) {
  n.registerComponentModel(TVt), n.registerComponentView(NVt), n.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), $Vt(n), n.registerPreprocessor(BVt);
}
function C$(n, e) {
  if (!n)
    return !1;
  for (var t = se(n) ? n : [n], r = 0; r < t.length; r++)
    if (t[r] && t[r][e])
      return !0;
  return !1;
}
function qO(n) {
  hd(n, "label", ["show"]);
}
var YO = It(), _oe = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.createdBySelf = !1, t;
    }
    return e.prototype.init = function(t, r, i) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, !1, !0);
    }, e.prototype.isAnimationEnabled = function() {
      if (mt.node)
        return !1;
      var t = this.__hostSeries;
      return this.getShallow("animation") && t && t.isAnimationEnabled();
    }, e.prototype.mergeOption = function(t, r) {
      this._mergeOption(t, r, !1, !1);
    }, e.prototype._mergeOption = function(t, r, i, o) {
      var a = this.mainType;
      i || r.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = YO(s)[a];
        if (!l || !l.data) {
          YO(s)[a] = null;
          return;
        }
        u ? u._mergeOption(l, r, !0) : (o && qO(l), I(l.data, function(c) {
          c instanceof Array ? (qO(c[0]), qO(c[1])) : qO(c);
        }), u = this.createMarkerModelFromSeries(l, this, r), re(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), YO(s)[a] = u;
      }, this);
    }, e.prototype.formatTooltip = function(t, r, i) {
      var o = this.getData(), a = this.getRawValue(t), s = o.getName(t);
      return Qr("section", {
        header: this.name,
        blocks: [Qr("nameValue", {
          name: s,
          value: a,
          noName: !s,
          noValue: a == null
        })]
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.setData = function(t) {
      this._data = t;
    }, e.getMarkerModelFromSeries = function(t, r) {
      return YO(t)[r];
    }, e.type = "marker", e.dependencies = ["series", "grid", "polar", "geo"], e;
  }(Pt)
);
mr(_oe, uN.prototype);
const th = _oe;
var FVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markPoint", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(th)
);
const QVt = FVt;
function ZD(n) {
  return !(isNaN(parseFloat(n.x)) && isNaN(parseFloat(n.y)));
}
function ZVt(n) {
  return !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
}
function XO(n, e, t, r, i, o) {
  var a = [], s = Uc(
    e,
    r
    /* , otherDataDim */
  ), l = s ? e.getCalculationInfo("stackResultDimension") : r, u = A$(e, l, n), c = e.indicesOfNearest(l, u)[0];
  a[i] = e.get(t, c), a[o] = e.get(l, c);
  var h = e.get(r, c), f = rl(e.get(r, c));
  return f = Math.min(f, 20), f >= 0 && (a[o] = +a[o].toFixed(f)), [a, h];
}
var Mk = {
  min: Je(XO, "min"),
  max: Je(XO, "max"),
  average: Je(XO, "average"),
  median: Je(XO, "median")
};
function nb(n, e) {
  if (e) {
    var t = n.getData(), r = n.coordinateSystem, i = r && r.dimensions;
    if (!ZVt(e) && !se(e.coord) && se(i)) {
      var o = Coe(e, t, r, n);
      if (e = Fe(e), e.type && Mk[e.type] && o.baseAxis && o.valueAxis) {
        var a = ct(i, o.baseAxis.dim), s = ct(i, o.valueAxis.dim), l = Mk[e.type](t, o.baseDataDim, o.valueDataDim, a, s);
        e.coord = l[0], e.value = l[1];
      } else
        e.coord = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis];
    }
    if (e.coord == null || !se(i))
      e.coord = [];
    else
      for (var u = e.coord, c = 0; c < 2; c++)
        Mk[u[c]] && (u[c] = A$(t, t.mapDimension(i[c]), u[c]));
    return e;
  }
}
function Coe(n, e, t, r) {
  var i = {};
  return n.valueIndex != null || n.valueDim != null ? (i.valueDataDim = n.valueIndex != null ? e.getDimension(n.valueIndex) : n.valueDim, i.valueAxis = t.getAxis(WVt(r, i.valueDataDim)), i.baseAxis = t.getOtherAxis(i.valueAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim)) : (i.baseAxis = r.getBaseAxis(), i.valueAxis = t.getOtherAxis(i.baseAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim), i.valueDataDim = e.mapDimension(i.valueAxis.dim)), i;
}
function WVt(n, e) {
  var t = n.getData().getDimensionInfo(e);
  return t && t.coordDim;
}
function rb(n, e) {
  return n && n.containData && e.coord && !ZD(e) ? n.containData(e.coord) : !0;
}
function GVt(n, e, t) {
  return n && n.containZone && e.coord && t.coord && !ZD(e) && !ZD(t) ? n.containZone(e.coord, t.coord) : !0;
}
function Aoe(n, e) {
  return n ? function(t, r, i, o) {
    var a = o < 2 ? t.coord && t.coord[o] : t.value;
    return Cc(a, e[o]);
  } : function(t, r, i, o) {
    return Cc(t.value, e[o]);
  };
}
function A$(n, e, t) {
  if (t === "average") {
    var r = 0, i = 0;
    return n.each(e, function(o, a) {
      isNaN(o) || (r += o, i++);
    }), r / i;
  } else
    return t === "median" ? n.getMedian(e) : n.getDataExtent(e)[t === "max" ? 1 : 0];
}
var Dk = It(), jVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this.markerGroupMap = Ee();
    }, e.prototype.render = function(t, r, i) {
      var o = this, a = this.markerGroupMap;
      a.each(function(s) {
        Dk(s).keep = !1;
      }), r.eachSeries(function(s) {
        var l = th.getMarkerModelFromSeries(s, o.type);
        l && o.renderSeries(s, l, r, i);
      }), a.each(function(s) {
        !Dk(s).keep && o.group.remove(s.group);
      });
    }, e.prototype.markKeep = function(t) {
      Dk(t).keep = !0;
    }, e.prototype.toggleBlurSeries = function(t, r) {
      var i = this;
      I(t, function(o) {
        var a = th.getMarkerModelFromSeries(o, i.type);
        if (a) {
          var s = a.getData();
          s.eachItemGraphicEl(function(l) {
            l && (r ? aee(l) : FR(l));
          });
        }
      });
    }, e.type = "marker", e;
  }(Gn)
);
const T$ = jVt;
function zW(n, e, t) {
  var r = e.coordinateSystem;
  n.each(function(i) {
    var o = n.getItemModel(i), a, s = be(o.get("x"), t.getWidth()), l = be(o.get("y"), t.getHeight());
    if (!isNaN(s) && !isNaN(l))
      a = [s, l];
    else if (e.getMarkerPosition)
      a = e.getMarkerPosition(n.getValues(n.dimensions, i));
    else if (r) {
      var u = n.get(r.dimensions[0], i), c = n.get(r.dimensions[1], i);
      a = r.dataToPoint([u, c]);
    }
    isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), n.setItemLayout(i, a);
  });
}
var HVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(o) {
        var a = th.getMarkerModelFromSeries(o, "markPoint");
        a && (zW(a.getData(), o, i), this.markerGroupMap.get(o.id).updateLayout());
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, o) {
      var a = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new qb()), h = qVt(a, t, r);
      r.setData(h), zW(r.getData(), t, o), h.each(function(f) {
        var d = h.getItemModel(f), p = d.getShallow("symbol"), g = d.getShallow("symbolSize"), v = d.getShallow("symbolRotate"), m = d.getShallow("symbolOffset"), y = d.getShallow("symbolKeepAspect");
        if (Le(p) || Le(g) || Le(v) || Le(m)) {
          var b = r.getRawValue(f), O = r.getDataParams(f);
          Le(p) && (p = p(b, O)), Le(g) && (g = g(b, O)), Le(v) && (v = v(b, O)), Le(m) && (m = m(b, O));
        }
        var w = d.getModel("itemStyle").getItemStyle(), x = Zb(l, "color");
        w.fill || (w.fill = x), h.setItemVisual(f, {
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: w
        });
      }), c.updateData(h), this.group.add(c.group), h.eachItemGraphicEl(function(f) {
        f.traverse(function(d) {
          He(d).dataModel = r;
        });
      }), this.markKeep(c), c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markPoint", e;
  }(T$)
);
function qVt(n, e, t) {
  var r;
  n ? r = le(n && n.dimensions, function(s) {
    var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {};
    return re(re({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : r = [{
    name: "value",
    type: "float"
  }];
  var i = new Ki(r, t), o = le(t.get("data"), Je(nb, e));
  n && (o = en(o, Je(rb, n)));
  var a = Aoe(!!n, r);
  return i.initData(o, null, a), i;
}
const YVt = HVt;
function XVt(n) {
  n.registerComponentModel(QVt), n.registerComponentView(YVt), n.registerPreprocessor(function(e) {
    C$(e.series, "markPoint") && (e.markPoint = e.markPoint || {});
  });
}
var UVt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markLine", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, e;
  }(th)
);
const KVt = UVt;
var UO = It(), JVt = function(n, e, t, r) {
  var i = n.getData(), o;
  if (se(r))
    o = r;
  else {
    var a = r.type;
    if (a === "min" || a === "max" || a === "average" || a === "median" || r.xAxis != null || r.yAxis != null) {
      var s = void 0, l = void 0;
      if (r.yAxis != null || r.xAxis != null)
        s = e.getAxis(r.yAxis != null ? "y" : "x"), l = ur(r.yAxis, r.xAxis);
      else {
        var u = Coe(r, i, e, n);
        s = u.valueAxis;
        var c = hne(i, u.valueDataDim);
        l = A$(i, c, a);
      }
      var h = s.dim === "x" ? 0 : 1, f = 1 - h, d = Fe(r), p = {
        coord: []
      };
      d.type = null, d.coord = [], d.coord[f] = -1 / 0, p.coord[f] = 1 / 0;
      var g = t.get("precision");
      g >= 0 && $t(l) && (l = +l.toFixed(Math.min(g, 20))), d.coord[h] = p.coord[h] = l, o = [d, p, {
        type: a,
        valueIndex: r.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      process.env.NODE_ENV !== "production" && ls("Invalid markLine data."), o = [];
  }
  var v = [nb(n, o[0]), nb(n, o[1]), re({}, o[2])];
  return v[2].type = v[2].type || null, it(v[2], v[0]), it(v[2], v[1]), v;
};
function US(n) {
  return !isNaN(n) && !isFinite(n);
}
function FW(n, e, t, r) {
  var i = 1 - n, o = r.dimensions[n];
  return US(e[i]) && US(t[i]) && e[n] === t[n] && r.getAxis(o).containData(e[n]);
}
function e4t(n, e) {
  if (n.type === "cartesian2d") {
    var t = e[0].coord, r = e[1].coord;
    if (t && r && (FW(1, t, r, n) || FW(0, t, r, n)))
      return !0;
  }
  return rb(n, e[0]) && rb(n, e[1]);
}
function Lk(n, e, t, r, i) {
  var o = r.coordinateSystem, a = n.getItemModel(e), s, l = be(a.get("x"), i.getWidth()), u = be(a.get("y"), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (r.getMarkerPosition)
      s = r.getMarkerPosition(n.getValues(n.dimensions, e));
    else {
      var c = o.dimensions, h = n.get(c[0], e), f = n.get(c[1], e);
      s = o.dataToPoint([h, f]);
    }
    if (Nd(o, "cartesian2d")) {
      var d = o.getAxis("x"), p = o.getAxis("y"), c = o.dimensions;
      US(n.get(c[0], e)) ? s[0] = d.toGlobalCoord(d.getExtent()[t ? 0 : 1]) : US(n.get(c[1], e)) && (s[1] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  n.setItemLayout(e, s);
}
var t4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(o) {
        var a = th.getMarkerModelFromSeries(o, "markLine");
        if (a) {
          var s = a.getData(), l = UO(a).from, u = UO(a).to;
          l.each(function(c) {
            Lk(l, c, !0, o, i), Lk(u, c, !1, o, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)]);
          }), this.markerGroupMap.get(o.id).updateLayout();
        }
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, o) {
      var a = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new XN());
      this.group.add(c.group);
      var h = n4t(a, t, r), f = h.from, d = h.to, p = h.line;
      UO(r).from = f, UO(r).to = d, r.setData(p);
      var g = r.get("symbol"), v = r.get("symbolSize"), m = r.get("symbolRotate"), y = r.get("symbolOffset");
      se(g) || (g = [g, g]), se(v) || (v = [v, v]), se(m) || (m = [m, m]), se(y) || (y = [y, y]), h.from.each(function(O) {
        b(f, O, !0), b(d, O, !1);
      }), p.each(function(O) {
        var w = p.getItemModel(O).getModel("lineStyle").getLineStyle();
        p.setItemLayout(O, [f.getItemLayout(O), d.getItemLayout(O)]), w.stroke == null && (w.stroke = f.getItemVisual(O, "style").fill), p.setItemVisual(O, {
          fromSymbolKeepAspect: f.getItemVisual(O, "symbolKeepAspect"),
          fromSymbolOffset: f.getItemVisual(O, "symbolOffset"),
          fromSymbolRotate: f.getItemVisual(O, "symbolRotate"),
          fromSymbolSize: f.getItemVisual(O, "symbolSize"),
          fromSymbol: f.getItemVisual(O, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(O, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(O, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(O, "symbolRotate"),
          toSymbolSize: d.getItemVisual(O, "symbolSize"),
          toSymbol: d.getItemVisual(O, "symbol"),
          style: w
        });
      }), c.updateData(p), h.line.eachItemGraphicEl(function(O) {
        He(O).dataModel = r, O.traverse(function(w) {
          He(w).dataModel = r;
        });
      });
      function b(O, w, x) {
        var S = O.getItemModel(w);
        Lk(O, w, x, t, o);
        var _ = S.getModel("itemStyle").getItemStyle();
        _.fill == null && (_.fill = Zb(l, "color")), O.setItemVisual(w, {
          symbolKeepAspect: S.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: qe(S.get("symbolOffset", !0), y[x ? 0 : 1]),
          symbolRotate: qe(S.get("symbolRotate", !0), m[x ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: qe(S.get("symbolSize"), v[x ? 0 : 1]),
          symbol: qe(S.get("symbol", !0), g[x ? 0 : 1]),
          style: _
        });
      }
      this.markKeep(c), c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markLine", e;
  }(T$)
);
function n4t(n, e, t) {
  var r;
  n ? r = le(n && n.dimensions, function(u) {
    var c = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
    return re(re({}, c), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : r = [{
    name: "value",
    type: "float"
  }];
  var i = new Ki(r, t), o = new Ki(r, t), a = new Ki([], t), s = le(t.get("data"), Je(JVt, e, n, t));
  n && (s = en(s, Je(e4t, n)));
  var l = Aoe(!!n, r);
  return i.initData(le(s, function(u) {
    return u[0];
  }), null, l), o.initData(le(s, function(u) {
    return u[1];
  }), null, l), a.initData(le(s, function(u) {
    return u[2];
  })), a.hasItemOption = !0, {
    from: i,
    to: o,
    line: a
  };
}
const r4t = t4t;
function i4t(n) {
  n.registerComponentModel(KVt), n.registerComponentView(r4t), n.registerPreprocessor(function(e) {
    C$(e.series, "markLine") && (e.markLine = e.markLine || {});
  });
}
var o4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markArea", e.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, e;
  }(th)
);
const a4t = o4t;
var KO = It(), s4t = function(n, e, t, r) {
  var i = r[0], o = r[1];
  if (!(!i || !o)) {
    var a = nb(n, i), s = nb(n, o), l = a.coord, u = s.coord;
    l[0] = ur(l[0], -1 / 0), l[1] = ur(l[1], -1 / 0), u[0] = ur(u[0], 1 / 0), u[1] = ur(u[1], 1 / 0);
    var c = xR([{}, a, s]);
    return c.coord = [a.coord, s.coord], c.x0 = a.x, c.y0 = a.y, c.x1 = s.x, c.y1 = s.y, c;
  }
};
function KS(n) {
  return !isNaN(n) && !isFinite(n);
}
function QW(n, e, t, r) {
  var i = 1 - n;
  return KS(e[i]) && KS(t[i]);
}
function l4t(n, e) {
  var t = e.coord[0], r = e.coord[1], i = {
    coord: t,
    x: e.x0,
    y: e.y0
  }, o = {
    coord: r,
    x: e.x1,
    y: e.y1
  };
  return Nd(n, "cartesian2d") ? t && r && (QW(1, t, r) || QW(0, t, r)) ? !0 : GVt(n, i, o) : rb(n, i) || rb(n, o);
}
function ZW(n, e, t, r, i) {
  var o = r.coordinateSystem, a = n.getItemModel(e), s, l = be(a.get(t[0]), i.getWidth()), u = be(a.get(t[1]), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (r.getMarkerPosition) {
      var c = n.getValues(["x0", "y0"], e), h = n.getValues(["x1", "y1"], e), f = o.clampData(c), d = o.clampData(h), p = [];
      t[0] === "x0" ? p[0] = f[0] > d[0] ? h[0] : c[0] : p[0] = f[0] > d[0] ? c[0] : h[0], t[1] === "y0" ? p[1] = f[1] > d[1] ? h[1] : c[1] : p[1] = f[1] > d[1] ? c[1] : h[1], s = r.getMarkerPosition(p, t, !0);
    } else {
      var g = n.get(t[0], e), v = n.get(t[1], e), m = [g, v];
      o.clampData && o.clampData(m, m), s = o.dataToPoint(m, !0);
    }
    if (Nd(o, "cartesian2d")) {
      var y = o.getAxis("x"), b = o.getAxis("y"), g = n.get(t[0], e), v = n.get(t[1], e);
      KS(g) ? s[0] = y.toGlobalCoord(y.getExtent()[t[0] === "x0" ? 0 : 1]) : KS(v) && (s[1] = b.toGlobalCoord(b.getExtent()[t[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var WW = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], u4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(o) {
        var a = th.getMarkerModelFromSeries(o, "markArea");
        if (a) {
          var s = a.getData();
          s.each(function(l) {
            var u = le(WW, function(h) {
              return ZW(s, l, h, o, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, o) {
      var a = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new We()
      });
      this.group.add(c.group), this.markKeep(c);
      var h = c4t(a, t, r);
      r.setData(h), h.each(function(f) {
        var d = le(WW, function(_) {
          return ZW(h, f, _, t, o);
        }), p = a.getAxis("x").scale, g = a.getAxis("y").scale, v = p.getExtent(), m = g.getExtent(), y = [p.parse(h.get("x0", f)), p.parse(h.get("x1", f))], b = [g.parse(h.get("y0", f)), g.parse(h.get("y1", f))];
        wa(y), wa(b);
        var O = !(v[0] > y[1] || v[1] < y[0] || m[0] > b[1] || m[1] < b[0]), w = !O;
        h.setItemLayout(f, {
          points: d,
          allClipped: w
        });
        var x = h.getItemModel(f).getModel("itemStyle").getItemStyle(), S = Zb(l, "color");
        x.fill || (x.fill = S, we(x.fill) && (x.fill = cS(x.fill, 0.4))), x.stroke || (x.stroke = S), h.setItemVisual(f, "style", x);
      }), h.diff(KO(c).data).add(function(f) {
        var d = h.getItemLayout(f);
        if (!d.allClipped) {
          var p = new ro({
            shape: {
              points: d.points
            }
          });
          h.setItemGraphicEl(f, p), c.group.add(p);
        }
      }).update(function(f, d) {
        var p = KO(c).data.getItemGraphicEl(d), g = h.getItemLayout(f);
        g.allClipped ? p && c.group.remove(p) : (p ? Vt(p, {
          shape: {
            points: g.points
          }
        }, r, f) : p = new ro({
          shape: {
            points: g.points
          }
        }), h.setItemGraphicEl(f, p), c.group.add(p));
      }).remove(function(f) {
        var d = KO(c).data.getItemGraphicEl(f);
        c.group.remove(d);
      }).execute(), h.eachItemGraphicEl(function(f, d) {
        var p = h.getItemModel(d), g = h.getItemVisual(d, "style");
        f.useStyle(h.getItemVisual(d, "style")), wi(f, Fr(p), {
          labelFetcher: r,
          labelDataIndex: d,
          defaultText: h.getName(d) || "",
          inheritColor: we(g.fill) ? cS(g.fill, 1) : "#000"
        }), Oi(f, p), Wn(f, null, null, p.get(["emphasis", "disabled"])), He(f).dataModel = r;
      }), KO(c).data = h, c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markArea", e;
  }(T$)
);
function c4t(n, e, t) {
  var r, i, o = ["x0", "y0", "x1", "y1"];
  if (n) {
    var a = le(n && n.dimensions, function(u) {
      var c = e.getData(), h = c.getDimensionInfo(c.mapDimension(u)) || {};
      return re(re({}, h), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    i = le(o, function(u, c) {
      return {
        name: u,
        type: a[c % 2].type
      };
    }), r = new Ki(i, t);
  } else
    i = [{
      name: "value",
      type: "float"
    }], r = new Ki(i, t);
  var s = le(t.get("data"), Je(s4t, e, n, t));
  n && (s = en(s, Je(l4t, n)));
  var l = n ? function(u, c, h, f) {
    var d = u.coord[Math.floor(f / 2)][f % 2];
    return Cc(d, i[f]);
  } : function(u, c, h, f) {
    return Cc(u.value, i[f]);
  };
  return r.initData(s, null, l), r.hasItemOption = !0, r;
}
const h4t = u4t;
function f4t(n) {
  n.registerComponentModel(a4t), n.registerComponentView(h4t), n.registerPreprocessor(function(e) {
    C$(e.series, "markArea") && (e.markArea = e.markArea || {});
  });
}
var d4t = function(n, e) {
  if (e === "all")
    return {
      type: "all",
      title: n.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (e === "inverse")
    return {
      type: "inverse",
      title: n.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, p4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), this._updateSelector(t);
    }, e.prototype._updateSelector = function(t) {
      var r = t.selector, i = this.ecModel;
      r === !0 && (r = t.selector = ["all", "inverse"]), se(r) && I(r, function(o, a) {
        we(o) && (o = {
          type: o
        }), r[a] = it(o, d4t(i, o.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var t = this._data;
      if (t[0] && this.get("selectedMode") === "single") {
        for (var r = !1, i = 0; i < t.length; i++) {
          var o = t[i].get("name");
          if (this.isSelected(o)) {
            this.select(o), r = !0;
            break;
          }
        }
        !r && this.select(t[0].get("name"));
      }
    }, e.prototype._updateData = function(t) {
      var r = [], i = [];
      t.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var h = l.legendVisualProvider, f = h.getAllNames();
          t.isSeriesFiltered(l) || (i = i.concat(f)), f.length ? r = r.concat(f) : c = !0;
        } else
          c = !0;
        c && LR(l) && r.push(l.name);
      }), this._availableNames = i;
      var o = this.get("data") || r, a = Ee(), s = le(o, function(l) {
        return (we(l) || $t(l)) && (l = {
          name: l
        }), a.get(l.name) ? null : (a.set(l.name, !0), new mn(l, this, this.ecModel));
      }, this);
      this._data = en(s, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(t) {
      var r = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var o = this._data;
        I(o, function(a) {
          r[a.get("name")] = !1;
        });
      }
      r[t] = !0;
    }, e.prototype.unSelect = function(t) {
      this.get("selectedMode") !== "single" && (this.option.selected[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      var r = this.option.selected;
      r.hasOwnProperty(t) || (r[t] = !0), this[r[t] ? "unSelect" : "select"](t);
    }, e.prototype.allSelect = function() {
      var t = this._data, r = this.option.selected;
      I(t, function(i) {
        r[i.get("name", !0)] = !0;
      });
    }, e.prototype.inverseSelect = function() {
      var t = this._data, r = this.option.selected;
      I(t, function(i) {
        var o = i.get("name", !0);
        r.hasOwnProperty(o) || (r[o] = !0), r[o] = !r[o];
      });
    }, e.prototype.isSelected = function(t) {
      var r = this.option.selected;
      return !(r.hasOwnProperty(t) && !r[t]) && ct(this._availableNames, t) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = ["series"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, e;
  }(Pt)
);
const WD = p4t;
var pp = Je, GD = I, JO = We, g4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new JO()), this.group.add(this._selectorGroup = new JO()), this._isFirstRender = !0;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(t, r, i) {
      var o = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!t.get("show", !0)) {
        var a = t.get("align"), s = t.get("orient");
        (!a || a === "auto") && (a = t.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = t.get("selector", !0), u = t.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(a, t, r, i, l, s, u);
        var c = t.getBoxLayoutParams(), h = {
          width: i.getWidth(),
          height: i.getHeight()
        }, f = t.get("padding"), d = Cr(c, h, f), p = this.layoutInner(t, a, d, o, l, u), g = Cr(Be({
          width: p.width,
          height: p.height
        }, c), h, f);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = poe(p, t));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(t, r, i, o, a, s, l) {
      var u = this.getContentGroup(), c = Ee(), h = r.get("selectedMode"), f = [];
      i.eachRawSeries(function(d) {
        !d.get("legendHoverLink") && f.push(d.id);
      }), GD(r.getData(), function(d, p) {
        var g = d.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var v = new JO();
          v.newline = !0, u.add(v);
          return;
        }
        var m = i.getSeriesByName(g)[0];
        if (!c.get(g)) {
          if (m) {
            var y = m.getData(), b = y.getVisual("legendLineStyle") || {}, O = y.getVisual("legendIcon"), w = y.getVisual("style"), x = this._createItem(m, g, p, d, r, t, b, w, O, h, o);
            x.on("click", pp(GW, g, null, o, f)).on("mouseover", pp(jD, m.name, null, o, f)).on("mouseout", pp(HD, m.name, null, o, f)), i.ssr && x.eachChild(function(S) {
              var _ = He(S);
              _.seriesIndex = m.seriesIndex, _.dataIndex = p, _.ssrType = "legend";
            }), c.set(g, !0);
          } else
            i.eachRawSeries(function(S) {
              if (!c.get(g) && S.legendVisualProvider) {
                var _ = S.legendVisualProvider;
                if (!_.containName(g))
                  return;
                var C = _.indexOfName(g), A = _.getItemVisual(C, "style"), k = _.getItemVisual(C, "legendIcon"), P = qo(A.fill);
                P && P[3] === 0 && (P[3] = 0.2, A = re(re({}, A), {
                  fill: tu(P, "rgba")
                }));
                var L = this._createItem(S, g, p, d, r, t, {}, A, k, h, o);
                L.on("click", pp(GW, null, g, o, f)).on("mouseover", pp(jD, null, g, o, f)).on("mouseout", pp(HD, null, g, o, f)), i.ssr && L.eachChild(function(D) {
                  var E = He(D);
                  E.seriesIndex = S.seriesIndex, E.dataIndex = p, E.ssrType = "legend";
                }), c.set(g, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (c.get(g) || console.warn(g + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), a && this._createSelector(a, r, o, s, l);
    }, e.prototype._createSelector = function(t, r, i, o, a) {
      var s = this.getSelectorGroup();
      GD(t, function(u) {
        var c = u.type, h = new Nt({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        s.add(h);
        var f = r.getModel("selectorLabel"), d = r.getModel(["emphasis", "selectorLabel"]);
        wi(h, {
          normal: f,
          emphasis: d
        }, {
          defaultText: u.title
        }), Zf(h);
      });
    }, e.prototype._createItem = function(t, r, i, o, a, s, l, u, c, h, f) {
      var d = t.visualDrawType, p = a.get("itemWidth"), g = a.get("itemHeight"), v = a.isSelected(r), m = o.get("symbolRotate"), y = o.get("symbolKeepAspect"), b = o.get("icon");
      c = b || c || "roundRect";
      var O = v4t(c, o, l, u, d, v, f), w = new JO(), x = o.getModel("textStyle");
      if (Le(t.getLegendIcon) && (!b || b === "inherit"))
        w.add(t.getLegendIcon({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: m,
          itemStyle: O.itemStyle,
          lineStyle: O.lineStyle,
          symbolKeepAspect: y
        }));
      else {
        var S = b === "inherit" && t.getData().getVisual("symbol") ? m === "inherit" ? t.getData().getVisual("symbolRotate") : m : 0;
        w.add(m4t({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: S,
          itemStyle: O.itemStyle,
          lineStyle: O.lineStyle,
          symbolKeepAspect: y
        }));
      }
      var _ = s === "left" ? p + 5 : -5, C = s, A = a.get("formatter"), k = r;
      we(A) && A ? k = A.replace("{name}", r ?? "") : Le(A) && (k = A(r));
      var P = v ? x.getTextColor() : o.get("inactiveColor");
      w.add(new Nt({
        style: vn(x, {
          text: k,
          x: _,
          y: g / 2,
          fill: P,
          align: C,
          verticalAlign: "middle"
        }, {
          inheritColor: P
        })
      }));
      var L = new Lt({
        shape: w.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), D = o.getModel("tooltip");
      return D.get("show") && Iv({
        el: L,
        componentModel: a,
        itemName: r,
        itemTooltipOption: D.option
      }), w.add(L), w.eachChild(function(E) {
        E.silent = !0;
      }), L.silent = !h, this.getContentGroup().add(w), Zf(w), w.__legendDataIndex = i, w;
    }, e.prototype.layoutInner = function(t, r, i, o, a, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      Gf(t.get("orient"), l, t.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), h = [-c.x, -c.y];
      if (u.markRedraw(), l.markRedraw(), a) {
        Gf(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          t.get("selectorItemGap", !0)
        );
        var f = u.getBoundingRect(), d = [-f.x, -f.y], p = t.get("selectorButtonGap", !0), g = t.getOrient().index, v = g === 0 ? "width" : "height", m = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        s === "end" ? d[g] += c[v] + p : h[g] += f[v] + p, d[1 - g] += c[m] / 2 - f[m] / 2, u.x = d[0], u.y = d[1], l.x = h[0], l.y = h[1];
        var b = {
          x: 0,
          y: 0
        };
        return b[v] = c[v] + p + f[v], b[m] = Math.max(c[m], f[m]), b[y] = Math.min(0, f[y] + d[1 - g]), b;
      } else
        return l.x = h[0], l.y = h[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, e.type = "legend.plain", e;
  }(Gn)
);
function v4t(n, e, t, r, i, o, a) {
  function s(v, m) {
    v.lineWidth === "auto" && (v.lineWidth = m.lineWidth > 0 ? 2 : 0), GD(v, function(y, b) {
      v[b] === "inherit" && (v[b] = m[b]);
    });
  }
  var l = e.getModel("itemStyle"), u = l.getItemStyle(), c = n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", h = l.getShallow("decal");
  u.decal = !h || h === "inherit" ? r.decal : Ug(h, a), u.fill === "inherit" && (u.fill = r[i]), u.stroke === "inherit" && (u.stroke = r[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? r : t).opacity), s(u, r);
  var f = e.getModel("lineStyle"), d = f.getLineStyle();
  if (s(d, t), u.fill === "auto" && (u.fill = r.fill), u.stroke === "auto" && (u.stroke = r.fill), d.stroke === "auto" && (d.stroke = r.fill), !o) {
    var p = e.get("inactiveBorderWidth"), g = u[c];
    u.lineWidth = p === "auto" ? r.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), d.stroke = f.get("inactiveColor"), d.lineWidth = f.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: d
  };
}
function m4t(n) {
  var e = n.icon || "roundRect", t = vr(e, 0, 0, n.itemWidth, n.itemHeight, n.itemStyle.fill, n.symbolKeepAspect);
  return t.setStyle(n.itemStyle), t.rotation = (n.iconRotate || 0) * Math.PI / 180, t.setOrigin([n.itemWidth / 2, n.itemHeight / 2]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t;
}
function GW(n, e, t, r) {
  HD(n, e, t, r), t.dispatchAction({
    type: "legendToggleSelect",
    name: n ?? e
  }), jD(n, e, t, r);
}
function Toe(n) {
  for (var e = n.getZr().storage.getDisplayList(), t, r = 0, i = e.length; r < i && !(t = e[r].states.emphasis); )
    r++;
  return t && t.hoverLayer;
}
function jD(n, e, t, r) {
  Toe(t) || t.dispatchAction({
    type: "highlight",
    seriesName: n,
    name: e,
    excludeSeriesId: r
  });
}
function HD(n, e, t, r) {
  Toe(t) || t.dispatchAction({
    type: "downplay",
    seriesName: n,
    name: e,
    excludeSeriesId: r
  });
}
const koe = g4t;
function y4t(n) {
  var e = n.findComponents({
    mainType: "legend"
  });
  e && e.length && n.filterSeries(function(t) {
    for (var r = 0; r < e.length; r++)
      if (!e[r].isSelected(t.name))
        return !1;
    return !0;
  });
}
function Dm(n, e, t) {
  var r = {}, i = n === "toggleSelected", o;
  return t.eachComponent("legend", function(a) {
    i && o != null ? a[o ? "select" : "unSelect"](e.name) : n === "allSelect" || n === "inverseSelect" ? a[n]() : (a[n](e.name), o = a.isSelected(e.name));
    var s = a.getData();
    I(s, function(l) {
      var u = l.get("name");
      if (!(u === `
` || u === "")) {
        var c = a.isSelected(u);
        r.hasOwnProperty(u) ? r[u] = r[u] && c : r[u] = c;
      }
    });
  }), n === "allSelect" || n === "inverseSelect" ? {
    selected: r
  } : {
    name: e.name,
    selected: r
  };
}
function b4t(n) {
  n.registerAction("legendToggleSelect", "legendselectchanged", Je(Dm, "toggleSelected")), n.registerAction("legendAllSelect", "legendselectall", Je(Dm, "allSelect")), n.registerAction("legendInverseSelect", "legendinverseselect", Je(Dm, "inverseSelect")), n.registerAction("legendSelect", "legendselected", Je(Dm, "select")), n.registerAction("legendUnSelect", "legendunselected", Je(Dm, "unSelect"));
}
function Poe(n) {
  n.registerComponentModel(WD), n.registerComponentView(koe), n.registerProcessor(n.PRIORITY.PROCESSOR.SERIES_FILTER, y4t), n.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), b4t(n);
}
var O4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.setScrollDataIndex = function(t) {
      this.option.scrollDataIndex = t;
    }, e.prototype.init = function(t, r, i) {
      var o = Bv(t);
      n.prototype.init.call(this, t, r, i), jW(this, t, o);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), jW(this, this.option, t);
    }, e.type = "legend.scroll", e.defaultOption = ph(WD.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }(WD)
);
function jW(n, e, t) {
  var r = n.getOrient(), i = [1, 1];
  i[r.index] = 0, Xc(e, t, {
    type: "box",
    ignoreSize: !!i
  });
}
const w4t = O4t;
var HW = We, Ik = ["width", "height"], Rk = ["x", "y"], x4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !0, t._currentIndex = 0, t;
    }
    return e.prototype.init = function() {
      n.prototype.init.call(this), this.group.add(this._containerGroup = new HW()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new HW());
    }, e.prototype.resetInner = function() {
      n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(t, r, i, o, a, s, l) {
      var u = this;
      n.prototype.renderInner.call(this, t, r, i, o, a, s, l);
      var c = this._controllerGroup, h = r.get("pageIconSize", !0), f = se(h) ? h : [h, h];
      p("pagePrev", 0);
      var d = r.getModel("pageTextStyle");
      c.add(new Nt({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), p("pageNext", 1);
      function p(g, v) {
        var m = g + "DataIndex", y = Qb(r.get("pageIcons", !0)[r.getOrient().name][v], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: _e(u._pageGo, u, m, r, o)
        }, {
          x: -f[0] / 2,
          y: -f[1] / 2,
          width: f[0],
          height: f[1]
        });
        y.name = g, c.add(y);
      }
    }, e.prototype.layoutInner = function(t, r, i, o, a, s) {
      var l = this.getSelectorGroup(), u = t.getOrient().index, c = Ik[u], h = Rk[u], f = Ik[1 - u], d = Rk[1 - u];
      a && Gf(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        t.get("selectorItemGap", !0)
      );
      var p = t.get("selectorButtonGap", !0), g = l.getBoundingRect(), v = [-g.x, -g.y], m = Fe(i);
      a && (m[c] = i[c] - g[c] - p);
      var y = this._layoutContentAndController(t, o, m, u, c, f, d, h);
      if (a) {
        if (s === "end")
          v[u] += y[c] + p;
        else {
          var b = g[c] + p;
          v[u] -= b, y[h] -= b;
        }
        y[c] += g[c] + p, v[1 - u] += y[d] + y[f] / 2 - g[f] / 2, y[f] = Math.max(y[f], g[f]), y[d] = Math.min(y[d], g[d] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return y;
    }, e.prototype._layoutContentAndController = function(t, r, i, o, a, s, l, u) {
      var c = this.getContentGroup(), h = this._containerGroup, f = this._controllerGroup;
      Gf(t.get("orient"), c, t.get("itemGap"), o ? i.width : null, o ? null : i.height), Gf(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        f,
        t.get("pageButtonItemGap", !0)
      );
      var d = c.getBoundingRect(), p = f.getBoundingRect(), g = this._showController = d[a] > i[a], v = [-d.x, -d.y];
      r || (v[o] = c[u]);
      var m = [0, 0], y = [-p.x, -p.y], b = qe(t.get("pageButtonGap", !0), t.get("itemGap", !0));
      if (g) {
        var O = t.get("pageButtonPosition", !0);
        O === "end" ? y[o] += i[a] - p[a] : m[o] += p[a] + b;
      }
      y[1 - o] += d[s] / 2 - p[s] / 2, c.setPosition(v), h.setPosition(m), f.setPosition(y);
      var w = {
        x: 0,
        y: 0
      };
      if (w[a] = g ? i[a] : d[a], w[s] = Math.max(d[s], p[s]), w[l] = Math.min(0, p[l] + y[1 - o]), h.__rectSize = i[a], g) {
        var x = {
          x: 0,
          y: 0
        };
        x[a] = Math.max(i[a] - p[a] - b, 0), x[s] = w[s], h.setClipPath(new Lt({
          shape: x
        })), h.__rectSize = x[a];
      } else
        f.eachChild(function(_) {
          _.attr({
            invisible: !0,
            silent: !0
          });
        });
      var S = this._getPageInfo(t);
      return S.pageIndex != null && Vt(
        c,
        {
          x: S.contentPosition[0],
          y: S.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? t : null
      ), this._updatePageInfoView(t, S), w;
    }, e.prototype._pageGo = function(t, r, i) {
      var o = this._getPageInfo(r)[t];
      o != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: o,
        legendId: r.id
      });
    }, e.prototype._updatePageInfoView = function(t, r) {
      var i = this._controllerGroup;
      I(["pagePrev", "pageNext"], function(c) {
        var h = c + "DataIndex", f = r[h] != null, d = i.childOfName(c);
        d && (d.setStyle("fill", f ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), d.cursor = f ? "pointer" : "default");
      });
      var o = i.childOfName("pageText"), a = t.get("pageFormatter"), s = r.pageIndex, l = s != null ? s + 1 : 0, u = r.pageCount;
      o && a && o.setStyle("text", we(a) ? a.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : a({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(t) {
      var r = t.get("scrollDataIndex", !0), i = this.getContentGroup(), o = this._containerGroup.__rectSize, a = t.getOrient().index, s = Ik[a], l = Rk[a], u = this._findTargetItemIndex(r), c = i.children(), h = c[u], f = c.length, d = f ? 1 : 0, p = {
        contentPosition: [i.x, i.y],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!h)
        return p;
      var g = O(h);
      p.contentPosition[a] = -g.s;
      for (var v = u + 1, m = g, y = g, b = null; v <= f; ++v)
        b = O(c[v]), // Half of the last item is out of the window.
        (!b && y.e > m.s + o || b && !w(b, m.s)) && (y.i > m.i ? m = y : m = b, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = b;
      for (var v = u - 1, m = g, y = g, b = null; v >= -1; --v)
        b = O(c[v]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!b || !w(y, b.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = b;
      return p;
      function O(x) {
        if (x) {
          var S = x.getBoundingRect(), _ = S[l] + x[l];
          return {
            s: _,
            e: _ + S[s],
            i: x.__legendDataIndex
          };
        }
      }
      function w(x, S) {
        return x.e >= S && x.s <= S + o;
      }
    }, e.prototype._findTargetItemIndex = function(t) {
      if (!this._showController)
        return 0;
      var r, i = this.getContentGroup(), o;
      return i.eachChild(function(a, s) {
        var l = a.__legendDataIndex;
        o == null && l != null && (o = s), l === t && (r = s);
      }), r ?? o;
    }, e.type = "legend.scroll", e;
  }(koe)
);
const S4t = x4t;
function _4t(n) {
  n.registerAction("legendScroll", "legendscroll", function(e, t) {
    var r = e.scrollDataIndex;
    r != null && t.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: e
    }, function(i) {
      i.setScrollDataIndex(r);
    });
  });
}
function C4t(n) {
  ft(Poe), n.registerComponentModel(w4t), n.registerComponentView(S4t), _4t(n);
}
function A4t(n) {
  ft(Poe), ft(C4t);
}
var T4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.inside", e.defaultOption = ph(tb.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), e;
  }(tb)
);
const k4t = T4t;
var k$ = It();
function P4t(n, e, t) {
  k$(n).coordSysRecordMap.each(function(r) {
    var i = r.dataZoomInfoMap.get(e.uid);
    i && (i.getRange = t);
  });
}
function E4t(n, e) {
  for (var t = k$(n).coordSysRecordMap, r = t.keys(), i = 0; i < r.length; i++) {
    var o = r[i], a = t.get(o), s = a.dataZoomInfoMap;
    if (s) {
      var l = e.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || Eoe(t, a));
    }
  }
}
function Eoe(n, e) {
  if (e) {
    n.removeKey(e.model.uid);
    var t = e.controller;
    t && t.dispose();
  }
}
function M4t(n, e) {
  var t = {
    model: e,
    containsPoint: Je(L4t, e),
    dispatchAction: Je(D4t, n),
    dataZoomInfoMap: null,
    controller: null
  }, r = t.controller = new Jb(n.getZr());
  return I(["pan", "zoom", "scrollMove"], function(i) {
    r.on(i, function(o) {
      var a = [];
      t.dataZoomInfoMap.each(function(s) {
        if (o.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, o);
          !s.model.get("disabled", !0) && u && a.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), a.length && t.dispatchAction(a);
    });
  }), t;
}
function D4t(n, e) {
  n.isDisposed() || n.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: e
  });
}
function L4t(n, e, t, r) {
  return n.coordinateSystem.containPoint([t, r]);
}
function I4t(n) {
  var e, t = "type_", r = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, i = !0;
  return n.each(function(o) {
    var a = o.model, s = a.get("disabled", !0) ? !1 : a.get("zoomLock", !0) ? "move" : !0;
    r[t + s] > r[t + e] && (e = s), i = i && a.get("preventDefaultMouseMove", !0);
  }), {
    controlType: e,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!i
    }
  };
}
function R4t(n) {
  n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, function(e, t) {
    var r = k$(t), i = r.coordSysRecordMap || (r.coordSysRecordMap = Ee());
    i.each(function(o) {
      o.dataZoomInfoMap = null;
    }), e.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(o) {
      var a = hoe(o);
      I(a.infoList, function(s) {
        var l = s.model.uid, u = i.get(l) || i.set(l, M4t(t, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = Ee());
        c.set(o.uid, {
          dzReferCoordSysInfo: s,
          model: o,
          getRange: null
        });
      });
    }), i.each(function(o) {
      var a = o.controller, s, l = o.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        Eoe(i, o);
        return;
      }
      var c = I4t(l);
      a.enable(c.controlType, c.opt), a.setPointerChecker(o.containsPoint), Zv(o, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var N4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataZoom.inside", t;
    }
    return e.prototype.render = function(t, r, i) {
      if (n.prototype.render.apply(this, arguments), t.noTarget()) {
        this._clear();
        return;
      }
      this.range = t.getPercentRange(), P4t(i, t, {
        pan: _e(Nk.pan, this),
        zoom: _e(Nk.zoom, this),
        scrollMove: _e(Nk.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      E4t(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(b$)
), Nk = {
  zoom: function(n, e, t, r) {
    var i = this.range, o = i.slice(), a = n.axisModels[0];
    if (a) {
      var s = $k[e](null, [r.originX, r.originY], a, t, n), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (o[1] - o[0]) + o[0], u = Math.max(1 / r.scale, 0);
      o[0] = (o[0] - l) * u + l, o[1] = (o[1] - l) * u + l;
      var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (Bd(0, o, [0, 100], 0, c.minSpan, c.maxSpan), this.range = o, i[0] !== o[0] || i[1] !== o[1])
        return o;
    }
  },
  pan: qW(function(n, e, t, r, i, o) {
    var a = $k[r]([o.oldX, o.oldY], [o.newX, o.newY], e, i, t);
    return a.signal * (n[1] - n[0]) * a.pixel / a.pixelLength;
  }),
  scrollMove: qW(function(n, e, t, r, i, o) {
    var a = $k[r]([0, 0], [o.scrollDelta, o.scrollDelta], e, i, t);
    return a.signal * (n[1] - n[0]) * o.scrollDelta;
  })
};
function qW(n) {
  return function(e, t, r, i) {
    var o = this.range, a = o.slice(), s = e.axisModels[0];
    if (s) {
      var l = n(a, s, e, t, r, i);
      if (Bd(l, a, [0, 100], "all"), this.range = a, o[0] !== a[0] || o[1] !== a[1])
        return a;
    }
  };
}
var $k = {
  grid: function(n, e, t, r, i) {
    var o = t.axis, a = {}, s = i.model.coordinateSystem.getRect();
    return n = n || [0, 0], o.dim === "x" ? (a.pixel = e[0] - n[0], a.pixelLength = s.width, a.pixelStart = s.x, a.signal = o.inverse ? 1 : -1) : (a.pixel = e[1] - n[1], a.pixelLength = s.height, a.pixelStart = s.y, a.signal = o.inverse ? -1 : 1), a;
  },
  polar: function(n, e, t, r, i) {
    var o = t.axis, a = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return n = n ? s.pointToCoord(n) : [0, 0], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (a.pixel = e[0] - n[0], a.pixelLength = l[1] - l[0], a.pixelStart = l[0], a.signal = o.inverse ? 1 : -1) : (a.pixel = e[1] - n[1], a.pixelLength = u[1] - u[0], a.pixelStart = u[0], a.signal = o.inverse ? -1 : 1), a;
  },
  singleAxis: function(n, e, t, r, i) {
    var o = t.axis, a = i.model.coordinateSystem.getRect(), s = {};
    return n = n || [0, 0], o.orient === "horizontal" ? (s.pixel = e[0] - n[0], s.pixelLength = a.width, s.pixelStart = a.x, s.signal = o.inverse ? 1 : -1) : (s.pixel = e[1] - n[1], s.pixelLength = a.height, s.pixelStart = a.y, s.signal = o.inverse ? -1 : 1), s;
  }
};
const $4t = N4t;
function Moe(n) {
  O$(n), n.registerComponentModel(k4t), n.registerComponentView($4t), R4t(n);
}
var B4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = ph(tb.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(tb)
);
const V4t = B4t;
var Lm = Lt, YW = 7, z4t = 1, Bk = 30, F4t = 7, Im = "horizontal", XW = "vertical", Q4t = 5, Z4t = ["line", "bar", "candlestick", "scatter"], W4t = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, G4t = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._displayables = {}, t;
    }
    return e.prototype.init = function(t, r) {
      this.api = r, this._onBrush = _e(this._onBrush, this), this._onBrushEnd = _e(this._onBrushEnd, this);
    }, e.prototype.render = function(t, r, i, o) {
      if (n.prototype.render.apply(this, arguments), Zv(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (t.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!o || o.type !== "dataZoom" || o.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      Q0(this, "_dispatchZoomAction");
      var t = this.api.getZr();
      t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var t = this.group;
      t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var r = this._displayables.sliderGroup = new We();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(r), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var t = this.dataZoomModel, r = this.api, i = t.get("brushSelect"), o = i ? F4t : 0, a = this._findCoordRect(), s = {
        width: r.getWidth(),
        height: r.getHeight()
      }, l = this._orient === Im ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: s.width - a.x - a.width,
        top: s.height - Bk - YW - o,
        width: a.width,
        height: Bk
      } : {
        right: YW,
        top: a.y,
        width: Bk,
        height: a.height
      }, u = Bv(t.option);
      I(["right", "top", "width", "height"], function(h) {
        u[h] === "ph" && (u[h] = l[h]);
      });
      var c = Cr(u, s);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [c.width, c.height], this._orient === XW && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var t = this.group, r = this._location, i = this._orient, o = this.dataZoomModel.getFirstTargetAxisModel(), a = o && o.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === Im && !a ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === Im && a ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === XW && !a ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = t.getBoundingRect([s]);
      t.x = r.x - u.x, t.y = r.y - u.y, t.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, e.prototype._renderBackground = function() {
      var t = this.dataZoomModel, r = this._size, i = this._displayables.sliderGroup, o = t.get("brushSelect");
      i.add(new Lm({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: t.get("backgroundColor")
        },
        z2: -40
      }));
      var a = new Lm({
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: _e(this._onClickPanel, this)
      }), s = this.api.getZr();
      o ? (a.on("mousedown", this._onBrushStart, this), a.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(a);
    }, e.prototype._renderDataShadow = function() {
      var t = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !t)
        return;
      var r = this._size, i = this._shadowSize || [], o = t.series, a = o.getRawData(), s = o.getShadowDim && o.getShadowDim(), l = s && a.getDimensionInfo(s) ? o.getShadowDim() : t.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (a !== this._shadowData || l !== this._shadowDim || r[0] !== i[0] || r[1] !== i[1]) {
        var h = a.getDataExtent(l), f = (h[1] - h[0]) * 0.3;
        h = [h[0] - f, h[1] + f];
        var d = [0, r[1]], p = [0, r[0]], g = [[r[0], 0], [0, 0]], v = [], m = p[1] / (a.count() - 1), y = 0, b = Math.round(a.count() / r[0]), O;
        a.each([l], function(C, A) {
          if (b > 0 && A % b) {
            y += m;
            return;
          }
          var k = C == null || isNaN(C) || C === "", P = k ? 0 : Yt(C, h, d, !0);
          k && !O && A ? (g.push([g[g.length - 1][0], 0]), v.push([v[v.length - 1][0], 0])) : !k && O && (g.push([y, 0]), v.push([y, 0])), g.push([y, P]), v.push([y, P]), y += m, O = k;
        }), u = this._shadowPolygonPts = g, c = this._shadowPolylinePts = v;
      }
      this._shadowData = a, this._shadowDim = l, this._shadowSize = [r[0], r[1]];
      var w = this.dataZoomModel;
      function x(C) {
        var A = w.getModel(C ? "selectedDataBackground" : "dataBackground"), k = new We(), P = new ro({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: A.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), L = new io({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: A.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return k.add(P), k.add(L), k;
      }
      for (var S = 0; S < 3; S++) {
        var _ = x(S === 1);
        this._displayables.sliderGroup.add(_), this._displayables.dataShadowSegs.push(_);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var t = this.dataZoomModel, r = t.get("showDataShadow");
      if (r !== !1) {
        var i, o = this.ecModel;
        return t.eachTargetAxis(function(a, s) {
          var l = t.getAxisProxy(a, s).getTargetSeriesModels();
          I(l, function(u) {
            if (!i && !(r !== !0 && ct(Z4t, u.get("type")) < 0)) {
              var c = o.getComponent(Oc(a), s).axis, h = j4t(a), f, d = u.coordinateSystem;
              h != null && d.getOtherAxis && (f = d.getOtherAxis(c).inverse), h = u.getData().mapDimension(h), i = {
                thisAxis: c,
                series: u,
                thisDim: a,
                otherDim: h,
                otherAxisInverse: f
              };
            }
          }, this);
        }, this), i;
      }
    }, e.prototype._renderHandle = function() {
      var t = this.group, r = this._displayables, i = r.handles = [null, null], o = r.handleLabels = [null, null], a = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, h = l.get("brushSelect"), f = r.filler = new Lm({
        silent: h,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      a.add(f), a.add(new Lm({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: z4t,
          fill: "rgba(0,0,0,0)"
        }
      })), I([0, 1], function(b) {
        var O = l.get("handleIcon");
        !AS[O] && O.indexOf("path://") < 0 && O.indexOf("image://") < 0 && (O = "path://" + O, process.env.NODE_ENV !== "production" && vs("handleIcon now needs 'path://' prefix when using a path string"));
        var w = vr(O, -1, 0, 2, 2, null, !0);
        w.attr({
          cursor: UW(this._orient),
          draggable: !0,
          drift: _e(this._onDragMove, this, b),
          ondragend: _e(this._onDragEnd, this),
          onmouseover: _e(this._showDataInfo, this, !0),
          onmouseout: _e(this._showDataInfo, this, !1),
          z2: 5
        });
        var x = w.getBoundingRect(), S = l.get("handleSize");
        this._handleHeight = be(S, this._size[1]), this._handleWidth = x.width / x.height * this._handleHeight, w.setStyle(l.getModel("handleStyle").getItemStyle()), w.style.strokeNoScale = !0, w.rectHover = !0, w.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), Zf(w);
        var _ = l.get("handleColor");
        _ != null && (w.style.fill = _), a.add(i[b] = w);
        var C = l.getModel("textStyle");
        t.add(o[b] = new Nt({
          silent: !0,
          invisible: !0,
          style: vn(C, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: C.getTextColor(),
            font: C.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = f;
      if (h) {
        var p = be(l.get("moveHandleSize"), s[1]), g = r.moveHandle = new Lt({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, m = r.moveHandleIcon = vr(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, "#fff", !0);
        m.silent = !0, m.y = s[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(p, 10));
        d = r.moveZone = new Lt({
          invisible: !0,
          shape: {
            y: s[1] - y,
            height: p + y
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), a.add(g), a.add(m), a.add(d);
      }
      d.attr({
        draggable: !0,
        cursor: UW(this._orient),
        drift: _e(this._onDragMove, this, "all"),
        ondragstart: _e(this._showDataInfo, this, !0),
        ondragend: _e(this._onDragEnd, this),
        onmouseover: _e(this._showDataInfo, this, !0),
        onmouseout: _e(this._showDataInfo, this, !1)
      });
    }, e.prototype._resetInterval = function() {
      var t = this._range = this.dataZoomModel.getPercentRange(), r = this._getViewExtent();
      this._handleEnds = [Yt(t[0], [0, 100], r, !0), Yt(t[1], [0, 100], r, !0)];
    }, e.prototype._updateInterval = function(t, r) {
      var i = this.dataZoomModel, o = this._handleEnds, a = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      Bd(r, o, a, i.get("zoomLock") ? "all" : t, s.minSpan != null ? Yt(s.minSpan, l, a, !0) : null, s.maxSpan != null ? Yt(s.maxSpan, l, a, !0) : null);
      var u = this._range, c = this._range = wa([Yt(o[0], a, l, !0), Yt(o[1], a, l, !0)]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, e.prototype._updateView = function(t) {
      var r = this._displayables, i = this._handleEnds, o = wa(i.slice()), a = this._size;
      I([0, 1], function(d) {
        var p = r.handles[d], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: i[d] + (d ? -1 : 1),
          y: a[1] / 2 - g / 2
        });
      }, this), r.filler.setShape({
        x: o[0],
        y: 0,
        width: o[1] - o[0],
        height: a[1]
      });
      var s = {
        x: o[0],
        width: o[1] - o[0]
      };
      r.moveHandle && (r.moveHandle.setShape(s), r.moveZone.setShape(s), r.moveZone.getBoundingRect(), r.moveHandleIcon && r.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = r.dataShadowSegs, u = [0, o[0], o[1], a[0]], c = 0; c < l.length; c++) {
        var h = l[c], f = h.getClipPath();
        f || (f = new Lt(), h.setClipPath(f)), f.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: a[1]
        });
      }
      this._updateDataInfo(t);
    }, e.prototype._updateDataInfo = function(t) {
      var r = this.dataZoomModel, i = this._displayables, o = i.handleLabels, a = this._orient, s = ["", ""];
      if (r.get("showDetail")) {
        var l = r.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, h = t ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(h[0], u), this._formatLabel(h[1], u)];
        }
      }
      var f = wa(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var g = Wf(i.handles[p].parent, this.group), v = kC(p === 0 ? "right" : "left", g), m = this._handleWidth / 2 + Q4t, y = cs([f[p] + (p === 0 ? -m : m), this._size[1] / 2], g);
        o[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: a === Im ? "middle" : v,
          align: a === Im ? v : "center",
          text: s[p]
        });
      }
    }, e.prototype._formatLabel = function(t, r) {
      var i = this.dataZoomModel, o = i.get("labelFormatter"), a = i.get("labelPrecision");
      (a == null || a === "auto") && (a = r.getPixelPrecision());
      var s = t == null || isNaN(t) ? "" : r.type === "category" || r.type === "time" ? r.scale.getLabel({
        value: Math.round(t)
      }) : t.toFixed(Math.min(a, 20));
      return Le(o) ? o(t, s) : we(o) ? o.replace("{value}", s) : s;
    }, e.prototype._showDataInfo = function(t) {
      t = this._dragging || t;
      var r = this._displayables, i = r.handleLabels;
      i[0].attr("invisible", !t), i[1].attr("invisible", !t), r.moveHandle && this.api[t ? "enterEmphasis" : "leaveEmphasis"](r.moveHandle, 1);
    }, e.prototype._onDragMove = function(t, r, i, o) {
      this._dragging = !0, du(o.event);
      var a = this._displayables.sliderGroup.getLocalTransform(), s = cs([r, i], a, !0), l = this._updateInterval(t, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, e.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var t = this.dataZoomModel.get("realtime");
      !t && this._dispatchZoomAction(!1);
    }, e.prototype._onClickPanel = function(t) {
      var r = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
      if (!(i[0] < 0 || i[0] > r[0] || i[1] < 0 || i[1] > r[1])) {
        var o = this._handleEnds, a = (o[0] + o[1]) / 2, s = this._updateInterval("all", i[0] - a);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, e.prototype._onBrushStart = function(t) {
      var r = t.offsetX, i = t.offsetY;
      this._brushStart = new nt(r, i), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(t) {
      if (this._brushing) {
        var r = this._displayables.brushRect;
        if (this._brushing = !1, !!r) {
          r.attr("ignore", !0);
          var i = r.shape, o = +/* @__PURE__ */ new Date();
          if (!(o - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var a = this._getViewExtent(), s = [0, 100];
            this._range = wa([Yt(i.x, a, s, !0), Yt(i.x + i.width, a, s, !0)]), this._handleEnds = [i.x, i.x + i.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, e.prototype._onBrush = function(t) {
      this._brushing && (du(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
    }, e.prototype._updateBrushRect = function(t, r) {
      var i = this._displayables, o = this.dataZoomModel, a = i.brushRect;
      a || (a = i.brushRect = new Lm({
        silent: !0,
        style: o.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(a)), a.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(t, r), c = l.transformCoordToLocal(s.x, s.y), h = this._size;
      u[0] = Math.max(Math.min(h[0], u[0]), 0), a.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: h[1]
      });
    }, e.prototype._dispatchZoomAction = function(t) {
      var r = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: t ? W4t : null,
        start: r[0],
        end: r[1]
      });
    }, e.prototype._findCoordRect = function() {
      var t, r = hoe(this.dataZoomModel).infoList;
      if (!t && r.length) {
        var i = r[0].model.coordinateSystem;
        t = i.getRect && i.getRect();
      }
      if (!t) {
        var o = this.api.getWidth(), a = this.api.getHeight();
        t = {
          x: o * 0.2,
          y: a * 0.2,
          width: o * 0.6,
          height: a * 0.6
        };
      }
      return t;
    }, e.type = "dataZoom.slider", e;
  }(b$)
);
function j4t(n) {
  var e = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return e[n];
}
function UW(n) {
  return n === "vertical" ? "ns-resize" : "ew-resize";
}
const H4t = G4t;
function Doe(n) {
  n.registerComponentModel(V4t), n.registerComponentView(H4t), O$(n);
}
function q4t(n) {
  ft(Moe), ft(Doe);
}
var Loe = {
  /**
   * @public
   */
  get: function(n, e, t) {
    var r = Fe((Y4t[n] || {})[e]);
    return t && se(r) ? r[r.length - 1] : r;
  }
}, Y4t = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
}, KW = mi.mapVisual, X4t = mi.eachVisual, U4t = se, JW = I, K4t = wa, J4t = Yt, JS = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.stateList = ["inRange", "outOfRange"], t.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t.dataBound = [-1 / 0, 1 / 0], t.targetVisuals = {}, t.controllerVisuals = {}, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.optionUpdated = function(t, r) {
      var i = this.option;
      !r && woe(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(t) {
      var r = this.stateList;
      t = _e(t, this), this.controllerVisuals = FD(this.option.controller, r, t), this.targetVisuals = FD(this.option.target, r, t);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var t = this.option.seriesIndex, r = [];
      return t == null || t === "all" ? this.ecModel.eachSeries(function(i, o) {
        r.push(o);
      }) : r = an(t), r;
    }, e.prototype.eachTargetSeries = function(t, r) {
      I(this.getTargetSeriesIndices(), function(i) {
        var o = this.ecModel.getSeriesByIndex(i);
        o && t.call(r, o);
      }, this);
    }, e.prototype.isTargetSeries = function(t) {
      var r = !1;
      return this.eachTargetSeries(function(i) {
        i === t && (r = !0);
      }), r;
    }, e.prototype.formatValueText = function(t, r, i) {
      var o = this.option, a = o.precision, s = this.dataBound, l = o.formatter, u;
      i = i || ["<", ">"], se(t) && (t = t.slice(), u = !0);
      var c = r ? t : u ? [h(t[0]), h(t[1])] : h(t);
      if (we(l))
        return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (Le(l))
        return u ? l(t[0], t[1]) : l(t);
      if (u)
        return t[0] === s[0] ? i[0] + " " + c[1] : t[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function h(f) {
        return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(a, 20));
      }
    }, e.prototype.resetExtent = function() {
      var t = this.option, r = K4t([t.min, t.max]);
      this._dataExtent = r;
    }, e.prototype.getDataDimensionIndex = function(t) {
      var r = this.option.dimension;
      if (r != null)
        return t.getDimensionIndex(r);
      for (var i = t.dimensions, o = i.length - 1; o >= 0; o--) {
        var a = i[o], s = t.getDimensionInfo(a);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var t = this.ecModel, r = this.option, i = {
        inRange: r.inRange,
        outOfRange: r.outOfRange
      }, o = r.target || (r.target = {}), a = r.controller || (r.controller = {});
      it(o, i), it(a, i);
      var s = this.isCategory();
      l.call(this, o), l.call(this, a), u.call(this, o, "inRange", "outOfRange"), c.call(this, a);
      function l(h) {
        U4t(r.color) && !h.inRange && (h.inRange = {
          color: r.color.slice().reverse()
        }), h.inRange = h.inRange || {
          color: t.get("gradientColor")
        };
      }
      function u(h, f, d) {
        var p = h[f], g = h[d];
        p && !g && (g = h[d] = {}, JW(p, function(v, m) {
          if (mi.isValidType(m)) {
            var y = Loe.get(m, "inactive", s);
            y != null && (g[m] = y, m === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function c(h) {
        var f = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol, d = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        JW(this.stateList, function(m) {
          var y = this.itemSize, b = h[m];
          b || (b = h[m] = {
            color: s ? p : [p]
          }), b.symbol == null && (b.symbol = f && Fe(f) || (s ? v : [v])), b.symbolSize == null && (b.symbolSize = d && Fe(d) || (s ? y[0] : [y[0], y[0]])), b.symbol = KW(b.symbol, function(x) {
            return x === "none" ? v : x;
          });
          var O = b.symbolSize;
          if (O != null) {
            var w = -1 / 0;
            X4t(O, function(x) {
              x > w && (w = x);
            }), b.symbolSize = KW(O, function(x) {
              return J4t(x, [0, w], [0, y[0]], !0);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(t) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(t) {
      return null;
    }, e.prototype.getVisualMeta = function(t) {
      return null;
    }, e.type = "visualMap", e.dependencies = ["series"], e.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // 接受数组分别设定上右下左边距，同css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 值域文字颜色
      }
    }, e;
  }(Pt)
), eG = [20, 140], ezt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      n.prototype.resetItemSize.apply(this, arguments);
      var t = this.itemSize;
      (t[0] == null || isNaN(t[0])) && (t[0] = eG[0]), (t[1] == null || isNaN(t[1])) && (t[1] = eG[1]);
    }, e.prototype._resetRange = function() {
      var t = this.getExtent(), r = this.option.range;
      !r || r.auto ? (t.auto = 1, this.option.range = t) : se(r) && (r[0] > r[1] && r.reverse(), r[0] = Math.max(r[0], t[0]), r[1] = Math.min(r[1], t[1]));
    }, e.prototype.completeVisualOption = function() {
      n.prototype.completeVisualOption.apply(this, arguments), I(this.stateList, function(t) {
        var r = this.option.controller[t].symbolSize;
        r && r[0] !== r[1] && (r[0] = r[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(t) {
      this.option.range = t.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var t = this.getExtent(), r = wa((this.get("range") || []).slice());
      return r[0] > t[1] && (r[0] = t[1]), r[1] > t[1] && (r[1] = t[1]), r[0] < t[0] && (r[0] = t[0]), r[1] < t[0] && (r[1] = t[0]), r;
    }, e.prototype.getValueState = function(t) {
      var r = this.option.range, i = this.getExtent();
      return (r[0] <= i[0] || r[0] <= t) && (r[1] >= i[1] || t <= r[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var r = [];
      return this.eachTargetSeries(function(i) {
        var o = [], a = i.getData();
        a.each(this.getDataDimensionIndex(a), function(s, l) {
          t[0] <= s && s <= t[1] && o.push(l);
        }, this), r.push({
          seriesId: i.id,
          dataIndex: o
        });
      }, this), r;
    }, e.prototype.getVisualMeta = function(t) {
      var r = tG(this, "outOfRange", this.getExtent()), i = tG(this, "inRange", this.option.range.slice()), o = [];
      function a(d, p) {
        o.push({
          value: d,
          color: t(d, p)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = r.length; l < c && (!i.length || r[l] <= i[0]); l++)
        r[l] < i[s] && a(r[l], "outOfRange");
      for (var h = 1; s < u; s++, h = 0)
        h && o.length && a(i[s], "outOfRange"), a(i[s], "inRange");
      for (var h = 1; l < c; l++)
        (!i.length || i[i.length - 1] < r[l]) && (h && (o.length && a(o[o.length - 1].value, "outOfRange"), h = 0), a(r[l], "outOfRange"));
      var f = o.length;
      return {
        stops: o,
        outerColors: [f ? o[0].color : "transparent", f ? o[f - 1].color : "transparent"]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = ph(JS.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), e;
  }(JS)
);
function tG(n, e, t) {
  if (t[0] === t[1])
    return t.slice();
  for (var r = 200, i = (t[1] - t[0]) / r, o = t[0], a = [], s = 0; s <= r && o < t[1]; s++)
    a.push(o), o += i;
  return a.push(t[1]), a;
}
const tzt = ezt;
var nzt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, t;
    }
    return e.prototype.init = function(t, r) {
      this.ecModel = t, this.api = r;
    }, e.prototype.render = function(t, r, i, o) {
      if (this.visualMapModel = t, t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(t, r, i, o);
    }, e.prototype.renderBackground = function(t) {
      var r = this.visualMapModel, i = $v(r.get("padding") || 0), o = t.getBoundingRect();
      t.add(new Lt({
        z2: -1,
        silent: !0,
        shape: {
          x: o.x - i[3],
          y: o.y - i[0],
          width: o.width + i[3] + i[1],
          height: o.height + i[0] + i[2]
        },
        style: {
          fill: r.get("backgroundColor"),
          stroke: r.get("borderColor"),
          lineWidth: r.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(t, r, i) {
      i = i || {};
      var o = i.forceState, a = this.visualMapModel, s = {};
      if (r === "color") {
        var l = a.get("contentColor");
        s.color = l;
      }
      function u(d) {
        return s[d];
      }
      function c(d, p) {
        s[d] = p;
      }
      var h = a.controllerVisuals[o || a.getValueState(t)], f = mi.prepareVisualTypes(h);
      return I(f, function(d) {
        var p = h[d];
        i.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = h.__alphaForOpacity), mi.dependsOn(d, r) && p && p.applyVisual(t, u, c);
      }), s[r];
    }, e.prototype.positionGroup = function(t) {
      var r = this.visualMapModel, i = this.api;
      RC(t, r.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, e.prototype.doRender = function(t, r, i, o) {
    }, e.type = "visualMap", e;
  }(Gn)
);
const Ioe = nzt;
var nG = [["left", "right", "width"], ["top", "bottom", "height"]];
function Roe(n, e, t) {
  var r = n.option, i = r.align;
  if (i != null && i !== "auto")
    return i;
  for (var o = {
    width: e.getWidth(),
    height: e.getHeight()
  }, a = r.orient === "horizontal" ? 1 : 0, s = nG[a], l = [0, null, 10], u = {}, c = 0; c < 3; c++)
    u[nG[1 - a][c]] = l[c], u[s[c]] = c === 2 ? t[0] : r[s[c]];
  var h = [["x", "width", 3], ["y", "height", 0]][a], f = Cr(u, o, r.padding);
  return s[(f.margin[h[2]] || 0) + f[h[0]] + f[h[1]] * 0.5 < o[h[1]] * 0.5 ? 0 : 1];
}
function nx(n, e) {
  return I(n || [], function(t) {
    t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "");
  }), n;
}
var Bs = Yt, rzt = I, rG = Math.min, Vk = Math.max, izt = 12, ozt = 6, azt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t;
    }
    return e.prototype.init = function(t, r) {
      n.prototype.init.call(this, t, r), this._hoverLinkFromSeriesMouseOver = _e(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = _e(this._hideIndicator, this);
    }, e.prototype.doRender = function(t, r, i, o) {
      (!o || o.type !== "selectDataRange" || o.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var t = this.visualMapModel, r = this.group;
      this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(r);
      var i = t.get("text");
      this._renderEndsText(r, i, 0), this._renderEndsText(r, i, 1), this._updateView(!0), this.renderBackground(r), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(r);
    }, e.prototype._renderEndsText = function(t, r, i) {
      if (r) {
        var o = r[1 - i];
        o = o != null ? o + "" : "";
        var a = this.visualMapModel, s = a.get("textGap"), l = a.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u), h = this._applyTransform(i === 0 ? "bottom" : "top", u), f = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new Nt({
          style: vn(d, {
            x: c[0],
            y: c[1],
            verticalAlign: f === "horizontal" ? "middle" : h,
            align: f === "horizontal" ? h : "center",
            text: o
          })
        }));
      }
    }, e.prototype._renderBar = function(t) {
      var r = this.visualMapModel, i = this._shapes, o = r.itemSize, a = this._orient, s = this._useHandle, l = Roe(r, this.api, o), u = i.mainGroup = this._createBarGroup(l), c = new We();
      u.add(c), c.add(i.outOfRange = iG()), c.add(i.inRange = iG(null, s ? aG(this._orient) : null, _e(this._dragHandle, this, "all", !1), _e(this._dragHandle, this, "all", !0))), c.setClipPath(new Lt({
        shape: {
          x: 0,
          y: 0,
          width: o[0],
          height: o[1],
          r: 3
        }
      }));
      var h = r.textStyleModel.getTextRect("国"), f = Vk(h.width, h.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(r, u, 0, o, f, a), this._createHandle(r, u, 1, o, f, a)), this._createIndicator(r, u, o, f, a), t.add(u);
    }, e.prototype._createHandle = function(t, r, i, o, a, s) {
      var l = _e(this._dragHandle, this, i, !1), u = _e(this._dragHandle, this, i, !0), c = gs(t.get("handleSize"), o[0]), h = vr(t.get("handleIcon"), -c / 2, -c / 2, c, c, null, !0), f = aG(this._orient);
      h.attr({
        cursor: f,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          du(m.event);
        }
      }), h.x = o[0] / 2, h.useStyle(t.getModel("handleStyle").getItemStyle()), h.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), h.style.lineWidth *= 2, h.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), xf(h, !0), r.add(h);
      var d = this.visualMapModel.textStyleModel, p = new Nt({
        cursor: f,
        draggable: !0,
        drift: l,
        onmousemove: function(m) {
          du(m.event);
        },
        ondragend: u,
        style: vn(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [c, 0], v = this._shapes;
      v.handleThumbs[i] = h, v.handleLabelPoints[i] = g, v.handleLabels[i] = p;
    }, e.prototype._createIndicator = function(t, r, i, o, a) {
      var s = gs(t.get("indicatorSize"), i[0]), l = vr(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: i[0] / 2
      });
      var u = t.getModel("indicatorStyle").getItemStyle();
      if (l instanceof Si) {
        var c = l.style;
        l.useStyle(re({
          // TODO other properties like x, y ?
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else
        l.useStyle(u);
      r.add(l);
      var h = this.visualMapModel.textStyleModel, f = new Nt({
        silent: !0,
        invisible: !0,
        style: vn(h, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(f);
      var d = [(a === "horizontal" ? o / 2 : ozt) + i[0] / 2, 0], p = this._shapes;
      p.indicator = l, p.indicatorLabel = f, p.indicatorLabelPoint = d, this._firstShowIndicator = !0;
    }, e.prototype._dragHandle = function(t, r, i, o) {
      if (this._useHandle) {
        if (this._dragging = !r, !r) {
          var a = this._applyTransform([i, o], this._shapes.mainGroup, !0);
          this._updateInterval(t, a[1]), this._hideIndicator(), this._updateView();
        }
        r === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), r ? !this._hovering && this._clearHoverLinkToSeries() : oG(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
      }
    }, e.prototype._resetInterval = function() {
      var t = this.visualMapModel, r = this._dataInterval = t.getSelected(), i = t.getExtent(), o = [0, t.itemSize[1]];
      this._handleEnds = [Bs(r[0], i, o, !0), Bs(r[1], i, o, !0)];
    }, e.prototype._updateInterval = function(t, r) {
      r = r || 0;
      var i = this.visualMapModel, o = this._handleEnds, a = [0, i.itemSize[1]];
      Bd(
        r,
        o,
        a,
        t,
        // cross is forbidden
        0
      );
      var s = i.getExtent();
      this._dataInterval = [Bs(o[0], a, s, !0), Bs(o[1], a, s, !0)];
    }, e.prototype._updateView = function(t) {
      var r = this.visualMapModel, i = r.getExtent(), o = this._shapes, a = [0, r.itemSize[1]], s = t ? a : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, a, "outOfRange");
      o.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), o.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, e.prototype._createBarVisual = function(t, r, i, o) {
      var a = {
        forceState: o,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(t, a), l = [this.getControllerVisual(t[0], "symbolSize", a), this.getControllerVisual(t[1], "symbolSize", a)], u = this._createBarPoints(i, l);
      return {
        barColor: new zb(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, e.prototype._makeColorGradient = function(t, r) {
      var i = 100, o = [], a = (t[1] - t[0]) / i;
      o.push({
        color: this.getControllerVisual(t[0], "color", r),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = t[0] + a * s;
        if (l > t[1])
          break;
        o.push({
          color: this.getControllerVisual(l, "color", r),
          offset: s / i
        });
      }
      return o.push({
        color: this.getControllerVisual(t[1], "color", r),
        offset: 1
      }), o;
    }, e.prototype._createBarPoints = function(t, r) {
      var i = this.visualMapModel.itemSize;
      return [[i[0] - r[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - r[1], t[1]]];
    }, e.prototype._createBarGroup = function(t) {
      var r = this._orient, i = this.visualMapModel.get("inverse");
      return new We(r === "horizontal" && !i ? {
        scaleX: t === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : r === "horizontal" && i ? {
        scaleX: t === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : r === "vertical" && !i ? {
        scaleX: t === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: t === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(t, r) {
      if (this._useHandle) {
        var i = this._shapes, o = this.visualMapModel, a = i.handleThumbs, s = i.handleLabels, l = o.itemSize, u = o.getExtent();
        rzt([0, 1], function(c) {
          var h = a[c];
          h.setStyle("fill", r.handlesColor[c]), h.y = t[c];
          var f = Bs(t[c], [0, l[1]], u, !0), d = this.getControllerVisual(f, "symbolSize");
          h.scaleX = h.scaleY = d / l[0], h.x = l[0] - d / 2;
          var p = cs(i.handleLabelPoints[c], Wf(h, this.group));
          s[c].setStyle({
            x: p[0],
            y: p[1],
            text: o.formatValueText(this._dataInterval[c]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(t, r, i, o) {
      var a = this.visualMapModel, s = a.getExtent(), l = a.itemSize, u = [0, l[1]], c = this._shapes, h = c.indicator;
      if (h) {
        h.attr("invisible", !1);
        var f = {
          convertOpacityToAlpha: !0
        }, d = this.getControllerVisual(t, "color", f), p = this.getControllerVisual(t, "symbolSize"), g = Bs(t, s, u, !0), v = l[0] - p / 2, m = {
          x: h.x,
          y: h.y
        };
        h.y = g, h.x = v;
        var y = cs(c.indicatorLabelPoint, Wf(h, this.group)), b = c.indicatorLabel;
        b.attr("invisible", !1);
        var O = this._applyTransform("left", c.mainGroup), w = this._orient, x = w === "horizontal";
        b.setStyle({
          text: (i || "") + a.formatValueText(r),
          verticalAlign: x ? O : "middle",
          align: x ? "center" : O
        });
        var S = {
          x: v,
          y: g,
          style: {
            fill: d
          }
        }, _ = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (a.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var C = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          h.x = m.x, h.y = m.y, h.animateTo(S, C), b.animateTo(_, C);
        } else
          h.attr(S), b.attr(_);
        this._firstShowIndicator = !1;
        var A = this._shapes.handleLabels;
        if (A)
          for (var k = 0; k < A.length; k++)
            this.api.enterBlur(A[k]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var t = this;
      this._shapes.mainGroup.on("mousemove", function(r) {
        if (t._hovering = !0, !t._dragging) {
          var i = t.visualMapModel.itemSize, o = t._applyTransform([r.offsetX, r.offsetY], t._shapes.mainGroup, !0, !0);
          o[1] = rG(Vk(0, o[1]), i[1]), t._doHoverLinkToSeries(o[1], 0 <= o[0] && o[0] <= i[0]);
        }
      }).on("mouseout", function() {
        t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var t = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(t, r) {
      var i = this.visualMapModel, o = i.itemSize;
      if (i.option.hoverLink) {
        var a = [0, o[1]], s = i.getExtent();
        t = rG(Vk(a[0], t), a[1]);
        var l = szt(i, s, a), u = [t - l, t + l], c = Bs(t, a, s, !0), h = [Bs(u[0], a, s, !0), Bs(u[1], a, s, !0)];
        u[0] < a[0] && (h[0] = -1 / 0), u[1] > a[1] && (h[1] = 1 / 0), r && (h[0] === -1 / 0 ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, "≈ ", l));
        var f = this._hoverLinkDataIndices, d = [];
        (r || oG(i)) && (d = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
        var p = Axt(f, d);
        this._dispatchHighDown("downplay", nx(p[0], i)), this._dispatchHighDown("highlight", nx(p[1], i));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(t) {
      var r;
      if (_f(t.target, function(l) {
        var u = He(l);
        if (u.dataIndex != null)
          return r = u, !0;
      }, !0), !!r) {
        var i = this.ecModel.getSeriesByIndex(r.seriesIndex), o = this.visualMapModel;
        if (o.isTargetSeries(i)) {
          var a = i.getData(r.dataType), s = a.getStore().get(o.getDataDimensionIndex(a), r.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var t = this._shapes;
      t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
      var r = this._shapes.handleLabels;
      if (r)
        for (var i = 0; i < r.length; i++)
          this.api.leaveBlur(r[i]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var t = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", nx(t, this.visualMapModel)), t.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var t = this.api.getZr();
      t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(t, r, i, o) {
      var a = Wf(r, o ? null : this.group);
      return se(t) ? cs(t, a, i) : kC(t, a, i);
    }, e.prototype._dispatchHighDown = function(t, r) {
      r && r.length && this.api.dispatchAction({
        type: t,
        batch: r
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(Ioe)
);
function iG(n, e, t, r) {
  return new ro({
    shape: {
      points: n
    },
    draggable: !!t,
    cursor: e,
    drift: t,
    onmousemove: function(i) {
      du(i.event);
    },
    ondragend: r
  });
}
function szt(n, e, t) {
  var r = izt / 2, i = n.get("hoverLinkDataSize");
  return i && (r = Bs(i, e, t, !0) / 2), r;
}
function oG(n) {
  var e = n.get("hoverLinkOnHandle");
  return !!(e ?? n.get("realtime"));
}
function aG(n) {
  return n === "vertical" ? "ns-resize" : "ew-resize";
}
const lzt = azt;
var uzt = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, czt = function(n, e) {
  e.eachComponent({
    mainType: "visualMap",
    query: n
  }, function(t) {
    t.setSelected(n.selected);
  });
}, hzt = [
  {
    createOnAllSeries: !0,
    reset: function(n, e) {
      var t = [];
      return e.eachComponent("visualMap", function(r) {
        var i = n.pipelineContext;
        !r.isTargetSeries(n) || i && i.large || t.push(lVt(r.stateList, r.targetVisuals, _e(r.getValueState, r), r.getDataDimensionIndex(n.getData())));
      }), t;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(n, e) {
      var t = n.getData(), r = [];
      e.eachComponent("visualMap", function(i) {
        if (i.isTargetSeries(n)) {
          var o = i.getVisualMeta(_e(fzt, null, n, i)) || {
            stops: [],
            outerColors: []
          }, a = i.getDataDimensionIndex(t);
          a >= 0 && (o.dimension = a, r.push(o));
        }
      }), n.getData().setVisual("visualMeta", r);
    }
  }
];
function fzt(n, e, t, r) {
  for (var i = e.targetVisuals[r], o = mi.prepareVisualTypes(i), a = {
    color: Zb(n.getData(), "color")
    // default color.
  }, s = 0, l = o.length; s < l; s++) {
    var u = o[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
    c && c.applyVisual(t, h, f);
  }
  return a.color;
  function h(d) {
    return a[d];
  }
  function f(d, p) {
    a[d] = p;
  }
}
var sG = I;
function dzt(n) {
  var e = n && n.visualMap;
  se(e) || (e = e ? [e] : []), sG(e, function(t) {
    if (t) {
      gp(t, "splitList") && !gp(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
      var r = t.pieces;
      r && se(r) && sG(r, function(i) {
        Ne(i) && (gp(i, "start") && !gp(i, "min") && (i.min = i.start), gp(i, "end") && !gp(i, "max") && (i.max = i.end));
      });
    }
  });
}
function gp(n, e) {
  return n && n.hasOwnProperty && n.hasOwnProperty(e);
}
var lG = !1;
function Noe(n) {
  lG || (lG = !0, n.registerSubTypeDefaulter("visualMap", function(e) {
    return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
  }), n.registerAction(uzt, czt), I(hzt, function(e) {
    n.registerVisual(n.PRIORITY.VISUAL.COMPONENT, e);
  }), n.registerPreprocessor(dzt));
}
function $oe(n) {
  n.registerComponentModel(tzt), n.registerComponentView(lzt), Noe(n);
}
var pzt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._pieceList = [], t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], gzt[this._mode].call(this, this._pieceList), this._resetSelected(t, r);
      var o = this.option.categories;
      this.resetVisual(function(a, s) {
        i === "categories" ? (a.mappingMethod = "category", a.categories = Fe(o)) : (a.dataExtent = this.getExtent(), a.mappingMethod = "piecewise", a.pieceList = le(this._pieceList, function(l) {
          return l = Fe(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var t = this.option, r = {}, i = mi.listVisualTypes(), o = this.isCategory();
      I(t.pieces, function(s) {
        I(i, function(l) {
          s.hasOwnProperty(l) && (r[l] = 1);
        });
      }), I(r, function(s, l) {
        var u = !1;
        I(this.stateList, function(c) {
          u = u || a(t, c, l) || a(t.target, c, l);
        }, this), !u && I(this.stateList, function(c) {
          (t[c] || (t[c] = {}))[l] = Loe.get(l, c === "inRange" ? "active" : "inactive", o);
        });
      }, this);
      function a(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      n.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(t, r) {
      var i = this.option, o = this._pieceList, a = (r ? i : t).selected || {};
      if (i.selected = a, I(o, function(l, u) {
        var c = this.getSelectedMapKey(l);
        a.hasOwnProperty(c) || (a[c] = !0);
      }, this), i.selectedMode === "single") {
        var s = !1;
        I(o, function(l, u) {
          var c = this.getSelectedMapKey(l);
          a[c] && (s ? a[c] = !1 : s = !0);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(t) {
      return this._mode === "categories" ? t.value + "" : t.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var t = this.option;
      return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(t) {
      this.option.selected = Fe(t);
    }, e.prototype.getValueState = function(t) {
      var r = mi.findPieceIndex(t, this._pieceList);
      return r != null && this.option.selected[this.getSelectedMapKey(this._pieceList[r])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var r = [], i = this._pieceList;
      return this.eachTargetSeries(function(o) {
        var a = [], s = o.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = mi.findPieceIndex(l, i);
          c === t && a.push(u);
        }, this), r.push({
          seriesId: o.id,
          dataIndex: a
        });
      }, this), r;
    }, e.prototype.getRepresentValue = function(t) {
      var r;
      if (this.isCategory())
        r = t.value;
      else if (t.value != null)
        r = t.value;
      else {
        var i = t.interval || [];
        r = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return r;
    }, e.prototype.getVisualMeta = function(t) {
      if (this.isCategory())
        return;
      var r = [], i = ["", ""], o = this;
      function a(c, h) {
        var f = o.getRepresentValue({
          interval: c
        });
        h || (h = o.getValueState(f));
        var d = t(f, h);
        c[0] === -1 / 0 ? i[0] = d : c[1] === 1 / 0 ? i[1] = d : r.push({
          value: c[0],
          color: d
        }, {
          value: c[1],
          color: d
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return I(s, function(c) {
        var h = c.interval;
        h && (h[0] > u && a([u, h[0]], "outOfRange"), a(h.slice()), u = h[1]);
      }, this), {
        stops: r,
        outerColors: i
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = ph(JS.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), e;
  }(JS)
), gzt = {
  splitNumber: function(n) {
    var e = this.option, t = Math.min(e.precision, 20), r = this.getExtent(), i = e.splitNumber;
    i = Math.max(parseInt(i, 10), 1), e.splitNumber = i;
    for (var o = (r[1] - r[0]) / i; +o.toFixed(t) !== o && t < 5; )
      t++;
    e.precision = t, o = +o.toFixed(t), e.minOpen && n.push({
      interval: [-1 / 0, r[0]],
      close: [0, 0]
    });
    for (var a = 0, s = r[0]; a < i; s += o, a++) {
      var l = a === i - 1 ? r[1] : s + o;
      n.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    e.maxOpen && n.push({
      interval: [r[1], 1 / 0],
      close: [0, 0]
    }), Yz(n), I(n, function(u, c) {
      u.index = c, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(n) {
    var e = this.option;
    I(e.categories, function(t) {
      n.push({
        text: this.formatValueText(t, !0),
        value: t
      });
    }, this), uG(e, n);
  },
  pieces: function(n) {
    var e = this.option;
    I(e.pieces, function(t, r) {
      Ne(t) || (t = {
        value: t
      });
      var i = {
        text: "",
        index: r
      };
      if (t.label != null && (i.text = t.label), t.hasOwnProperty("value")) {
        var o = i.value = t.value;
        i.interval = [o, o], i.close = [1, 1];
      } else {
        for (var a = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], c = [], h = 0; h < 2; h++) {
          for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][h], d = 0; d < 3 && a[h] == null; d++)
            a[h] = t[f[d]], s[h] = l[d], c[h] = d === 2;
          a[h] == null && (a[h] = u[h]);
        }
        c[0] && a[1] === 1 / 0 && (s[0] = 0), c[1] && a[0] === -1 / 0 && (s[1] = 0), process.env.NODE_ENV !== "production" && a[0] > a[1] && console.warn("Piece " + r + "is illegal: " + a + " lower bound should not greater then uppper bound."), a[0] === a[1] && s[0] && s[1] && (i.value = a[0]);
      }
      i.visual = mi.retrieveVisuals(t), n.push(i);
    }, this), uG(e, n), Yz(n), I(n, function(t) {
      var r = t.close, i = [["<", "≤"][r[1]], [">", "≥"][r[0]]];
      t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, i);
    }, this);
  }
};
function uG(n, e) {
  var t = n.inverse;
  (n.orient === "vertical" ? !t : t) && e.reverse();
}
const vzt = pzt;
var mzt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.doRender = function() {
      var t = this.group;
      t.removeAll();
      var r = this.visualMapModel, i = r.get("textGap"), o = r.textStyleModel, a = o.getFont(), s = o.getTextColor(), l = this._getItemAlign(), u = r.itemSize, c = this._getViewData(), h = c.endsText, f = ur(r.get("showLabel", !0), !h);
      h && this._renderEndsText(t, h[0], u, f, l), I(c.viewPieceList, function(d) {
        var p = d.piece, g = new We();
        g.onclick = _e(this._onItemClick, this, p), this._enableHoverLink(g, d.indexInModelPieceList);
        var v = r.getRepresentValue(p);
        if (this._createItemSymbol(g, v, [0, 0, u[0], u[1]]), f) {
          var m = this.visualMapModel.getValueState(v);
          g.add(new Nt({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: p.text,
              verticalAlign: "middle",
              align: l,
              font: a,
              fill: s,
              opacity: m === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        t.add(g);
      }, this), h && this._renderEndsText(t, h[1], u, f, l), Gf(r.get("orient"), t, r.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    }, e.prototype._enableHoverLink = function(t, r) {
      var i = this;
      t.on("mouseover", function() {
        return o("highlight");
      }).on("mouseout", function() {
        return o("downplay");
      });
      var o = function(a) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: a,
          batch: nx(s.findTargetDataIndices(r), s)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var t = this.visualMapModel, r = t.option;
      if (r.orient === "vertical")
        return Roe(t, this.api, t.itemSize);
      var i = r.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, e.prototype._renderEndsText = function(t, r, i, o, a) {
      if (r) {
        var s = new We(), l = this.visualMapModel.textStyleModel;
        s.add(new Nt({
          style: vn(l, {
            x: o ? a === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: o ? a : "center",
            text: r
          })
        })), t.add(s);
      }
    }, e.prototype._getViewData = function() {
      var t = this.visualMapModel, r = le(t.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = t.get("text"), o = t.get("orient"), a = t.get("inverse");
      return (o === "horizontal" ? a : !a) ? r.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: r,
        endsText: i
      };
    }, e.prototype._createItemSymbol = function(t, r, i) {
      t.add(vr(
        // symbol will be string
        this.getControllerVisual(r, "symbol"),
        i[0],
        i[1],
        i[2],
        i[3],
        // color will be string
        this.getControllerVisual(r, "color")
      ));
    }, e.prototype._onItemClick = function(t) {
      var r = this.visualMapModel, i = r.option, o = i.selectedMode;
      if (o) {
        var a = Fe(i.selected), s = r.getSelectedMapKey(t);
        o === "single" || o === !0 ? (a[s] = !0, I(a, function(l, u) {
          a[u] = u === s;
        })) : a[s] = !a[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: a
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(Ioe)
);
const yzt = mzt;
function Boe(n) {
  n.registerComponentModel(vzt), n.registerComponentView(yzt), Noe(n);
}
function bzt(n) {
  ft($oe), ft(Boe);
}
var Ozt = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, cG = It(), wzt = {};
function xzt(n, e) {
  var t = n.getModel("aria");
  if (!t.get("enabled"))
    return;
  var r = Fe(Ozt);
  it(r.label, n.getLocaleModel().get("aria"), !1), it(t.option, r, !1), i(), o();
  function i() {
    var u = t.getModel("decal"), c = u.get("show");
    if (c) {
      var h = Ee();
      n.eachSeries(function(f) {
        if (!f.isColorBySeries()) {
          var d = h.get(f.type);
          d || (d = {}, h.set(f.type, d)), cG(f).scope = d;
        }
      }), n.eachRawSeries(function(f) {
        if (n.isSeriesFiltered(f))
          return;
        if (Le(f.enableAriaDecal)) {
          f.enableAriaDecal();
          return;
        }
        var d = f.getData();
        if (f.isColorBySeries()) {
          var y = XM(f.ecModel, f.name, wzt, n.getSeriesCount()), b = d.getVisual("decal");
          d.setVisual("decal", O(b, y));
        } else {
          var p = f.getRawData(), g = {}, v = cG(f).scope;
          d.each(function(w) {
            var x = d.getRawIndex(w);
            g[x] = w;
          });
          var m = p.count();
          p.each(function(w) {
            var x = g[w], S = p.getName(w) || w + "", _ = XM(f.ecModel, S, v, m), C = d.getItemVisual(x, "decal");
            d.setItemVisual(x, "decal", O(C, _));
          });
        }
        function O(w, x) {
          var S = w ? re(re({}, x), w) : x;
          return S.dirty = !0, S;
        }
      });
    }
  }
  function o() {
    var u = n.getLocaleModel().get("aria"), c = t.getModel("label");
    if (c.option = Be(c.option, u), !!c.get("enabled")) {
      var h = e.getZr().dom;
      if (c.get("description")) {
        h.setAttribute("aria-label", c.get("description"));
        return;
      }
      var f = n.getSeriesCount(), d = c.get(["data", "maxCount"]) || 10, p = c.get(["series", "maxCount"]) || 10, g = Math.min(f, p), v;
      if (!(f < 1)) {
        var m = s();
        if (m) {
          var y = c.get(["general", "withTitle"]);
          v = a(y, {
            title: m
          });
        } else
          v = c.get(["general", "withoutTitle"]);
        var b = [], O = f > 1 ? c.get(["series", "multiple", "prefix"]) : c.get(["series", "single", "prefix"]);
        v += a(O, {
          seriesCount: f
        }), n.eachSeries(function(_, C) {
          if (C < g) {
            var A = void 0, k = _.get("name"), P = k ? "withName" : "withoutName";
            A = f > 1 ? c.get(["series", "multiple", P]) : c.get(["series", "single", P]), A = a(A, {
              seriesId: _.seriesIndex,
              seriesName: _.get("name"),
              seriesType: l(_.subType)
            });
            var L = _.getData();
            if (L.count() > d) {
              var D = c.get(["data", "partialData"]);
              A += a(D, {
                displayCnt: d
              });
            } else
              A += c.get(["data", "allData"]);
            for (var E = c.get(["data", "separator", "middle"]), M = c.get(["data", "separator", "end"]), R = [], N = 0; N < L.count(); N++)
              if (N < d) {
                var $ = L.getName(N), F = L.getValues(N), W = c.get(["data", $ ? "withName" : "withoutName"]);
                R.push(a(W, {
                  name: $,
                  value: F.join(E)
                }));
              }
            A += R.join(E) + M, b.push(A);
          }
        });
        var w = c.getModel(["series", "multiple", "separator"]), x = w.get("middle"), S = w.get("end");
        v += b.join(x) + S, h.setAttribute("aria-label", v);
      }
    }
  }
  function a(u, c) {
    if (!we(u))
      return u;
    var h = u;
    return I(c, function(f, d) {
      h = h.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), f);
    }), h;
  }
  function s() {
    var u = n.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    var c = n.getLocaleModel().get(["series", "typeNames"]);
    return c[u] || c.chart;
  }
}
function Szt(n) {
  if (!(!n || !n.aria)) {
    var e = n.aria;
    e.show != null && (e.enabled = e.show), e.label = e.label || {}, I(["description", "general", "series", "data"], function(t) {
      e[t] != null && (e.label[t] = e[t]);
    });
  }
}
function _zt(n) {
  n.registerPreprocessor(Szt), n.registerVisual(n.PRIORITY.VISUAL.ARIA, xzt);
}
var hG = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, Czt = (
  /** @class */
  function() {
    function n(e) {
      var t = this._condVal = we(e) ? new RegExp(e) : KK(e) ? e : null;
      if (t == null) {
        var r = "";
        process.env.NODE_ENV !== "production" && (r = to("Illegal regexp", e, "in")), Gt(r);
      }
    }
    return n.prototype.evaluate = function(e) {
      var t = typeof e;
      return we(t) ? this._condVal.test(e) : $t(t) ? this._condVal.test(e + "") : !1;
    }, n;
  }()
), Azt = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return this.value;
    }, n;
  }()
), Tzt = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (!e[t].evaluate())
          return !1;
      return !0;
    }, n;
  }()
), kzt = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (e[t].evaluate())
          return !0;
      return !1;
    }, n;
  }()
), Pzt = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, n;
  }()
), Ezt = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = !!this.valueParser, t = this.getValue, r = t(this.valueGetterParam), i = e ? this.valueParser(r) : null, o = 0; o < this.subCondList.length; o++)
        if (!this.subCondList[o].evaluate(e ? i : r))
          return !1;
      return !0;
    }, n;
  }()
);
function P$(n, e) {
  if (n === !0 || n === !1) {
    var t = new Azt();
    return t.value = n, t;
  }
  var r = "";
  return Voe(n) || (process.env.NODE_ENV !== "production" && (r = to("Illegal config. Expect a plain object but actually", n)), Gt(r)), n.and ? fG("and", n, e) : n.or ? fG("or", n, e) : n.not ? Mzt(n, e) : Dzt(n, e);
}
function fG(n, e, t) {
  var r = e[n], i = "";
  process.env.NODE_ENV !== "production" && (i = to('"and"/"or" condition should only be `' + n + ": [...]` and must not be empty array.", "Illegal condition:", e)), se(r) || Gt(i), r.length || Gt(i);
  var o = n === "and" ? new Tzt() : new kzt();
  return o.children = le(r, function(a) {
    return P$(a, t);
  }), o.children.length || Gt(i), o;
}
function Mzt(n, e) {
  var t = n.not, r = "";
  process.env.NODE_ENV !== "production" && (r = to('"not" condition should only be `not: {}`.', "Illegal condition:", n)), Voe(t) || Gt(r);
  var i = new Pzt();
  return i.child = P$(t, e), i.child || Gt(r), i;
}
function Dzt(n, e) {
  for (var t = "", r = e.prepareGetValue(n), i = [], o = Ot(n), a = n.parser, s = a ? pte(a) : null, l = 0; l < o.length; l++) {
    var u = o[l];
    if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
      var c = Ce(hG, u) ? hG[u] : u, h = n[u], f = s ? s(h) : h, d = zCt(c, f) || c === "reg" && new Czt(f);
      d || (process.env.NODE_ENV !== "production" && (t = to('Illegal relational operation: "' + u + '" in condition:', n)), Gt(t)), i.push(d);
    }
  }
  i.length || (process.env.NODE_ENV !== "production" && (t = to("Relational condition must have at least one operator.", "Illegal condition:", n)), Gt(t));
  var p = new Ezt();
  return p.valueGetterParam = r, p.valueParser = s, p.getValue = e.getValue, p.subCondList = i, p;
}
function Voe(n) {
  return Ne(n) && !Ni(n);
}
var Lzt = (
  /** @class */
  function() {
    function n(e, t) {
      this._cond = P$(e, t);
    }
    return n.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, n;
  }()
);
function Izt(n, e) {
  return new Lzt(n, e);
}
var Rzt = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(n) {
    for (var e = n.upstream, t, r = Izt(n.config, {
      valueGetterAttrMap: Ee({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        Ce(s, "dimension") || (process.env.NODE_ENV !== "production" && (l = to('Relation condition must has prop "dimension" specified.', "Illegal condition:", s)), Gt(l));
        var c = e.getDimensionInfo(u);
        return c || (process.env.NODE_ENV !== "production" && (l = to("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", e.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`)), Gt(l)), {
          dimIdx: c.index
        };
      },
      getValue: function(s) {
        return e.retrieveValueFromItem(t, s.dimIdx);
      }
    }), i = [], o = 0, a = e.count(); o < a; o++)
      t = e.getRawDataItem(o), r.evaluate() && i.push(t);
    return {
      data: i
    };
  }
}, qD = "";
process.env.NODE_ENV !== "production" && (qD = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var Nzt = {
  type: "echarts:sort",
  transform: function(n) {
    var e = n.upstream, t = n.config, r = "", i = an(t);
    i.length || (process.env.NODE_ENV !== "production" && (r = "Empty `config` in sort transform."), Gt(r));
    var o = [];
    I(i, function(c) {
      var h = c.dimension, f = c.order, d = c.parser, p = c.incomparable;
      if (h == null && (process.env.NODE_ENV !== "production" && (r = 'Sort transform config must has "dimension" specified.' + qD), Gt(r)), f !== "asc" && f !== "desc" && (process.env.NODE_ENV !== "production" && (r = 'Sort transform config must has "order" specified.' + qD), Gt(r)), p && p !== "min" && p !== "max") {
        var g = "";
        process.env.NODE_ENV !== "production" && (g = 'incomparable must be "min" or "max" rather than "' + p + '".'), Gt(g);
      }
      if (f !== "asc" && f !== "desc") {
        var v = "";
        process.env.NODE_ENV !== "production" && (v = 'order must be "asc" or "desc" rather than "' + f + '".'), Gt(v);
      }
      var m = e.getDimensionInfo(h);
      m || (process.env.NODE_ENV !== "production" && (r = to("Can not find dimension info via: " + h + `.
`, "Existing dimensions: ", e.cloneAllDimensionInfo(), `.
`, "Illegal config:", c, `.
`)), Gt(r));
      var y = d ? pte(d) : null;
      d && !y && (process.env.NODE_ENV !== "production" && (r = to("Invalid parser name " + d + `.
`, "Illegal config:", c, `.
`)), Gt(r)), o.push({
        dimIdx: m.index,
        parser: y,
        comparator: new vte(f, p)
      });
    });
    var a = e.sourceFormat;
    a !== $i && a !== za && (process.env.NODE_ENV !== "production" && (r = 'sourceFormat "' + a + '" is not supported yet'), Gt(r));
    for (var s = [], l = 0, u = e.count(); l < u; l++)
      s.push(e.getRawDataItem(l));
    return s.sort(function(c, h) {
      for (var f = 0; f < o.length; f++) {
        var d = o[f], p = e.retrieveValueFromItem(c, d.dimIdx), g = e.retrieveValueFromItem(h, d.dimIdx);
        d.parser && (p = d.parser(p), g = d.parser(g));
        var v = d.comparator.evaluate(p, g);
        if (v !== 0)
          return v;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function $zt(n) {
  n.registerTransform(Rzt), n.registerTransform(Nzt);
}
var Bzt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.prototype.init = function(t, r, i) {
      n.prototype.init.call(this, t, r, i), this._sourceManager = new Ote(this), c6(this);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), c6(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: pl
    }, e;
  }(Pt)
), Vzt = (
  /** @class */
  function(n) {
    H(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.type = "dataset", e;
  }(Gn)
);
function zzt(n) {
  n.registerComponentModel(Bzt), n.registerComponentView(Vzt);
}
var Rs = Al.CMD;
function Ip(n, e) {
  return Math.abs(n - e) < 1e-5;
}
function YD(n) {
  var e = n.data, t = n.len(), r = [], i, o = 0, a = 0, s = 0, l = 0;
  function u(L, D) {
    i && i.length > 2 && r.push(i), i = [L, D];
  }
  function c(L, D, E, M) {
    Ip(L, E) && Ip(D, M) || i.push(L, D, E, M, E, M);
  }
  function h(L, D, E, M, R, N) {
    var $ = Math.abs(D - L), F = Math.tan($ / 4) * 4 / 3, W = D < L ? -1 : 1, j = Math.cos(L), Y = Math.sin(L), X = Math.cos(D), ie = Math.sin(D), ae = j * R + E, ee = Y * N + M, ne = X * R + E, ye = ie * N + M, te = R * F * W, ue = N * F * W;
    i.push(ae - te * Y, ee + ue * j, ne + te * ie, ye - ue * X, ne, ye);
  }
  for (var f, d, p, g, v = 0; v < t; ) {
    var m = e[v++], y = v === 1;
    switch (y && (o = e[v], a = e[v + 1], s = o, l = a, (m === Rs.L || m === Rs.C || m === Rs.Q) && (i = [s, l])), m) {
      case Rs.M:
        o = s = e[v++], a = l = e[v++], u(s, l);
        break;
      case Rs.L:
        f = e[v++], d = e[v++], c(o, a, f, d), o = f, a = d;
        break;
      case Rs.C:
        i.push(e[v++], e[v++], e[v++], e[v++], o = e[v++], a = e[v++]);
        break;
      case Rs.Q:
        f = e[v++], d = e[v++], p = e[v++], g = e[v++], i.push(o + 2 / 3 * (f - o), a + 2 / 3 * (d - a), p + 2 / 3 * (f - p), g + 2 / 3 * (d - g), p, g), o = p, a = g;
        break;
      case Rs.A:
        var b = e[v++], O = e[v++], w = e[v++], x = e[v++], S = e[v++], _ = e[v++] + S;
        v += 1;
        var C = !e[v++];
        f = Math.cos(S) * w + b, d = Math.sin(S) * x + O, y ? (s = f, l = d, u(s, l)) : c(o, a, f, d), o = Math.cos(_) * w + b, a = Math.sin(_) * x + O;
        for (var A = (C ? -1 : 1) * Math.PI / 2, k = S; C ? k > _ : k < _; k += A) {
          var P = C ? Math.max(k + A, _) : Math.min(k + A, _);
          h(k, P, b, O, w, x);
        }
        break;
      case Rs.R:
        s = o = e[v++], l = a = e[v++], f = s + e[v++], d = l + e[v++], u(f, l), c(f, l, f, d), c(f, d, s, d), c(s, d, s, l), c(s, l, f, l);
        break;
      case Rs.Z:
        i && c(o, a, s, l), o = s, a = l;
        break;
    }
  }
  return i && i.length > 2 && r.push(i), r;
}
function XD(n, e, t, r, i, o, a, s, l, u) {
  if (Ip(n, t) && Ip(e, r) && Ip(i, a) && Ip(o, s)) {
    l.push(a, s);
    return;
  }
  var c = 2 / u, h = c * c, f = a - n, d = s - e, p = Math.sqrt(f * f + d * d);
  f /= p, d /= p;
  var g = t - n, v = r - e, m = i - a, y = o - s, b = g * g + v * v, O = m * m + y * y;
  if (b < h && O < h) {
    l.push(a, s);
    return;
  }
  var w = f * g + d * v, x = -f * m - d * y, S = b - w * w, _ = O - x * x;
  if (S < h && w >= 0 && _ < h && x >= 0) {
    l.push(a, s);
    return;
  }
  var C = [], A = [];
  Hc(n, t, i, a, 0.5, C), Hc(e, r, o, s, 0.5, A), XD(C[0], A[0], C[1], A[1], C[2], A[2], C[3], A[3], l, u), XD(C[4], A[4], C[5], A[5], C[6], A[6], C[7], A[7], l, u);
}
function Fzt(n, e) {
  var t = YD(n), r = [];
  e = e || 1;
  for (var i = 0; i < t.length; i++) {
    var o = t[i], a = [], s = o[0], l = o[1];
    a.push(s, l);
    for (var u = 2; u < o.length; ) {
      var c = o[u++], h = o[u++], f = o[u++], d = o[u++], p = o[u++], g = o[u++];
      XD(s, l, c, h, f, d, p, g, a, e), s = p, l = g;
    }
    r.push(a);
  }
  return r;
}
function zoe(n, e, t) {
  var r = n[e], i = n[1 - e], o = Math.abs(r / i), a = Math.ceil(Math.sqrt(o * t)), s = Math.floor(t / a);
  s === 0 && (s = 1, a = t);
  for (var l = [], u = 0; u < a; u++)
    l.push(s);
  var c = a * s, h = t - c;
  if (h > 0)
    for (var u = 0; u < h; u++)
      l[u % a] += 1;
  return l;
}
function dG(n, e, t) {
  for (var r = n.r0, i = n.r, o = n.startAngle, a = n.endAngle, s = Math.abs(a - o), l = s * i, u = i - r, c = l > Math.abs(u), h = zoe([l, u], c ? 0 : 1, e), f = (c ? s : u) / h.length, d = 0; d < h.length; d++)
    for (var p = (c ? u : s) / h[d], g = 0; g < h[d]; g++) {
      var v = {};
      c ? (v.startAngle = o + f * d, v.endAngle = o + f * (d + 1), v.r0 = r + p * g, v.r = r + p * (g + 1)) : (v.startAngle = o + p * g, v.endAngle = o + p * (g + 1), v.r0 = r + f * d, v.r = r + f * (d + 1)), v.clockwise = n.clockwise, v.cx = n.cx, v.cy = n.cy, t.push(v);
    }
}
function Qzt(n, e, t) {
  for (var r = n.width, i = n.height, o = r > i, a = zoe([r, i], o ? 0 : 1, e), s = o ? "width" : "height", l = o ? "height" : "width", u = o ? "x" : "y", c = o ? "y" : "x", h = n[s] / a.length, f = 0; f < a.length; f++)
    for (var d = n[l] / a[f], p = 0; p < a[f]; p++) {
      var g = {};
      g[u] = f * h, g[c] = p * d, g[s] = h, g[l] = d, g.x += n.x, g.y += n.y, t.push(g);
    }
}
function pG(n, e, t, r) {
  return n * r - t * e;
}
function Zzt(n, e, t, r, i, o, a, s) {
  var l = t - n, u = r - e, c = a - i, h = s - o, f = pG(c, h, l, u);
  if (Math.abs(f) < 1e-6)
    return null;
  var d = n - i, p = e - o, g = pG(d, p, c, h) / f;
  return g < 0 || g > 1 ? null : new nt(g * l + n, g * u + e);
}
function Wzt(n, e, t) {
  var r = new nt();
  nt.sub(r, t, e), r.normalize();
  var i = new nt();
  nt.sub(i, n, e);
  var o = i.dot(r);
  return o;
}
function vp(n, e) {
  var t = n[n.length - 1];
  t && t[0] === e[0] && t[1] === e[1] || n.push(e);
}
function Gzt(n, e, t) {
  for (var r = n.length, i = [], o = 0; o < r; o++) {
    var a = n[o], s = n[(o + 1) % r], l = Zzt(a[0], a[1], s[0], s[1], e.x, e.y, t.x, t.y);
    l && i.push({
      projPt: Wzt(l, e, t),
      pt: l,
      idx: o
    });
  }
  if (i.length < 2)
    return [{ points: n }, { points: n }];
  i.sort(function(v, m) {
    return v.projPt - m.projPt;
  });
  var u = i[0], c = i[i.length - 1];
  if (c.idx < u.idx) {
    var h = u;
    u = c, c = h;
  }
  for (var f = [u.pt.x, u.pt.y], d = [c.pt.x, c.pt.y], p = [f], g = [d], o = u.idx + 1; o <= c.idx; o++)
    vp(p, n[o].slice());
  vp(p, d), vp(p, f);
  for (var o = c.idx + 1; o <= u.idx + r; o++)
    vp(g, n[o % r].slice());
  return vp(g, f), vp(g, d), [{
    points: p
  }, {
    points: g
  }];
}
function gG(n) {
  var e = n.points, t = [], r = [];
  xC(e, t, r);
  var i = new ot(t[0], t[1], r[0] - t[0], r[1] - t[1]), o = i.width, a = i.height, s = i.x, l = i.y, u = new nt(), c = new nt();
  return o > a ? (u.x = c.x = s + o / 2, u.y = l, c.y = l + a) : (u.y = c.y = l + a / 2, u.x = s, c.x = s + o), Gzt(e, u, c);
}
function e_(n, e, t, r) {
  if (t === 1)
    r.push(e);
  else {
    var i = Math.floor(t / 2), o = n(e);
    e_(n, o[0], i, r), e_(n, o[1], t - i, r);
  }
  return r;
}
function jzt(n, e) {
  for (var t = [], r = 0; r < e; r++)
    t.push(ZR(n));
  return t;
}
function Hzt(n, e) {
  e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel;
}
function qzt(n) {
  for (var e = [], t = 0; t < n.length; )
    e.push([n[t++], n[t++]]);
  return e;
}
function Yzt(n, e) {
  var t = [], r = n.shape, i;
  switch (n.type) {
    case "rect":
      Qzt(r, e, t), i = Lt;
      break;
    case "sector":
      dG(r, e, t), i = Eo;
      break;
    case "circle":
      dG({
        r0: 0,
        r: r.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: r.cx,
        cy: r.cy
      }, e, t), i = Eo;
      break;
    default:
      var o = n.getComputedTransform(), a = o ? Math.sqrt(Math.max(o[0] * o[0] + o[1] * o[1], o[2] * o[2] + o[3] * o[3])) : 1, s = le(Fzt(n.getUpdatedPathProxy(), a), function(m) {
        return qzt(m);
      }), l = s.length;
      if (l === 0)
        e_(gG, {
          points: s[0]
        }, e, t);
      else if (l === e)
        for (var u = 0; u < l; u++)
          t.push({
            points: s[u]
          });
      else {
        var c = 0, h = le(s, function(m) {
          var y = [], b = [];
          xC(m, y, b);
          var O = (b[1] - y[1]) * (b[0] - y[0]);
          return c += O, { poly: m, area: O };
        });
        h.sort(function(m, y) {
          return y.area - m.area;
        });
        for (var f = e, u = 0; u < l; u++) {
          var d = h[u];
          if (f <= 0)
            break;
          var p = u === l - 1 ? f : Math.ceil(d.area / c * e);
          p < 0 || (e_(gG, {
            points: d.poly
          }, p, t), f -= p);
        }
      }
      i = ro;
      break;
  }
  if (!i)
    return jzt(n, e);
  for (var g = [], u = 0; u < t.length; u++) {
    var v = new i();
    v.setShape(t[u]), Hzt(n, v), g.push(v);
  }
  return g;
}
function Xzt(n, e) {
  var t = n.length, r = e.length;
  if (t === r)
    return [n, e];
  for (var i = [], o = [], a = t < r ? n : e, s = Math.min(t, r), l = Math.abs(r - t) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, h = [a[0], a[1]], f = l, d = 2; d < s; ) {
    var p = a[d - 2], g = a[d - 1], v = a[d++], m = a[d++], y = a[d++], b = a[d++], O = a[d++], w = a[d++];
    if (f <= 0) {
      h.push(v, m, y, b, O, w);
      continue;
    }
    for (var x = Math.min(f, c - 1) + 1, S = 1; S <= x; S++) {
      var _ = S / x;
      Hc(p, v, y, O, _, i), Hc(g, m, b, w, _, o), p = i[3], g = o[3], h.push(i[1], o[1], i[2], o[2], p, g), v = i[5], m = o[5], y = i[6], b = o[6];
    }
    f -= x - 1;
  }
  return a === n ? [h, e] : [n, h];
}
function vG(n, e) {
  for (var t = n.length, r = n[t - 2], i = n[t - 1], o = [], a = 0; a < e.length; )
    o[a++] = r, o[a++] = i;
  return o;
}
function Uzt(n, e) {
  for (var t, r, i, o = [], a = [], s = 0; s < Math.max(n.length, e.length); s++) {
    var l = n[s], u = e[s], c = void 0, h = void 0;
    l ? u ? (t = Xzt(l, u), c = t[0], h = t[1], r = c, i = h) : (h = vG(i || l, l), c = l) : (c = vG(r || u, u), h = u), o.push(c), a.push(h);
  }
  return [o, a];
}
function mG(n) {
  for (var e = 0, t = 0, r = 0, i = n.length, o = 0, a = i - 2; o < i; a = o, o += 2) {
    var s = n[a], l = n[a + 1], u = n[o], c = n[o + 1], h = s * c - u * l;
    e += h, t += (s + u) * h, r += (l + c) * h;
  }
  return e === 0 ? [n[0] || 0, n[1] || 0] : [t / e / 3, r / e / 3, e];
}
function Kzt(n, e, t, r) {
  for (var i = (n.length - 2) / 6, o = 1 / 0, a = 0, s = n.length, l = s - 2, u = 0; u < i; u++) {
    for (var c = u * 6, h = 0, f = 0; f < s; f += 2) {
      var d = f === 0 ? c : (c + f - 2) % l + 2, p = n[d] - t[0], g = n[d + 1] - t[1], v = e[f] - r[0], m = e[f + 1] - r[1], y = v - p, b = m - g;
      h += y * y + b * b;
    }
    h < o && (o = h, a = u);
  }
  return a;
}
function Jzt(n) {
  for (var e = [], t = n.length, r = 0; r < t; r += 2)
    e[r] = n[t - r - 2], e[r + 1] = n[t - r - 1];
  return e;
}
function eFt(n, e, t, r) {
  for (var i = [], o, a = 0; a < n.length; a++) {
    var s = n[a], l = e[a], u = mG(s), c = mG(l);
    o == null && (o = u[2] < 0 != c[2] < 0);
    var h = [], f = [], d = 0, p = 1 / 0, g = [], v = s.length;
    o && (s = Jzt(s));
    for (var m = Kzt(s, l, u, c) * 6, y = v - 2, b = 0; b < y; b += 2) {
      var O = (m + b) % y + 2;
      h[b + 2] = s[O] - u[0], h[b + 3] = s[O + 1] - u[1];
    }
    if (h[0] = s[m] - u[0], h[1] = s[m + 1] - u[1], t > 0)
      for (var w = r / t, x = -r / 2; x <= r / 2; x += w) {
        for (var S = Math.sin(x), _ = Math.cos(x), C = 0, b = 0; b < s.length; b += 2) {
          var A = h[b], k = h[b + 1], P = l[b] - c[0], L = l[b + 1] - c[1], D = P * _ - L * S, E = P * S + L * _;
          g[b] = D, g[b + 1] = E;
          var M = D - A, R = E - k;
          C += M * M + R * R;
        }
        if (C < p) {
          p = C, d = x;
          for (var N = 0; N < g.length; N++)
            f[N] = g[N];
        }
      }
    else
      for (var $ = 0; $ < v; $ += 2)
        f[$] = l[$] - c[0], f[$ + 1] = l[$ + 1] - c[1];
    i.push({
      from: h,
      to: f,
      fromCp: u,
      toCp: c,
      rotation: -d
    });
  }
  return i;
}
function t_(n) {
  return n.__isCombineMorphing;
}
var Foe = "__mOriginal_";
function n_(n, e, t) {
  var r = Foe + e, i = n[r] || n[e];
  n[r] || (n[r] = n[e]);
  var o = t.replace, a = t.after, s = t.before;
  n[e] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), o ? u = o.apply(this, l) : u = i.apply(this, l), a && a.apply(this, l), u;
  };
}
function Gy(n, e) {
  var t = Foe + e;
  n[t] && (n[e] = n[t], n[t] = null);
}
function yG(n, e) {
  for (var t = 0; t < n.length; t++)
    for (var r = n[t], i = 0; i < r.length; ) {
      var o = r[i], a = r[i + 1];
      r[i++] = e[0] * o + e[2] * a + e[4], r[i++] = e[1] * o + e[3] * a + e[5];
    }
}
function Qoe(n, e) {
  var t = n.getUpdatedPathProxy(), r = e.getUpdatedPathProxy(), i = Uzt(YD(t), YD(r)), o = i[0], a = i[1], s = n.getComputedTransform(), l = e.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && yG(o, s), l && yG(a, l), n_(e, "updateTransform", { replace: u }), e.transform = null;
  var c = eFt(o, a, 10, Math.PI), h = [];
  n_(e, "buildPath", { replace: function(f) {
    for (var d = e.__morphT, p = 1 - d, g = [], v = 0; v < c.length; v++) {
      var m = c[v], y = m.from, b = m.to, O = m.rotation * d, w = m.fromCp, x = m.toCp, S = Math.sin(O), _ = Math.cos(O);
      zw(g, w, x, d);
      for (var C = 0; C < y.length; C += 2) {
        var A = y[C], k = y[C + 1], P = b[C], L = b[C + 1], D = A * p + P * d, E = k * p + L * d;
        h[C] = D * _ - E * S + g[0], h[C + 1] = D * S + E * _ + g[1];
      }
      var M = h[0], R = h[1];
      f.moveTo(M, R);
      for (var C = 2; C < y.length; ) {
        var P = h[C++], L = h[C++], N = h[C++], $ = h[C++], F = h[C++], W = h[C++];
        M === P && R === L && N === F && $ === W ? f.lineTo(F, W) : f.bezierCurveTo(P, L, N, $, F, W), M = F, R = W;
      }
    }
  } });
}
function E$(n, e, t) {
  if (!n || !e)
    return e;
  var r = t.done, i = t.during;
  Qoe(n, e), e.__morphT = 0;
  function o() {
    Gy(e, "buildPath"), Gy(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
  }
  return e.animateTo({
    __morphT: 1
  }, Be({
    during: function(a) {
      e.dirtyShape(), i && i(a);
    },
    done: function() {
      o(), r && r();
    }
  }, t)), e;
}
function tFt(n, e, t, r, i, o) {
  var a = 16;
  n = i === t ? 0 : Math.round(32767 * (n - t) / (i - t)), e = o === r ? 0 : Math.round(32767 * (e - r) / (o - r));
  for (var s = 0, l, u = (1 << a) / 2; u > 0; u /= 2) {
    var c = 0, h = 0;
    (n & u) > 0 && (c = 1), (e & u) > 0 && (h = 1), s += u * u * (3 * c ^ h), h === 0 && (c === 1 && (n = u - 1 - n, e = u - 1 - e), l = n, n = e, e = l);
  }
  return s;
}
function r_(n) {
  var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, o = le(n, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), h = l.y + l.height / 2 + (u ? u[5] : 0);
    return e = Math.min(c, e), t = Math.min(h, t), r = Math.max(c, r), i = Math.max(h, i), [c, h];
  }), a = le(o, function(s, l) {
    return {
      cp: s,
      z: tFt(s[0], s[1], e, t, r, i),
      path: n[l]
    };
  });
  return a.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function Zoe(n) {
  return Yzt(n.path, n.count);
}
function UD() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function nFt(n, e, t) {
  var r = [];
  function i(w) {
    for (var x = 0; x < w.length; x++) {
      var S = w[x];
      t_(S) ? i(S.childrenRef()) : S instanceof gt && r.push(S);
    }
  }
  i(n);
  var o = r.length;
  if (!o)
    return UD();
  var a = t.dividePath || Zoe, s = a({
    path: e,
    count: o
  });
  if (s.length !== o)
    return console.error("Invalid morphing: unmatched splitted path"), UD();
  r = r_(r), s = r_(s);
  for (var l = t.done, u = t.during, c = t.individualDelay, h = new Yl(), f = 0; f < o; f++) {
    var d = r[f], p = s[f];
    p.parent = e, p.copyTransform(h), c || Qoe(d, p);
  }
  e.__isCombineMorphing = !0, e.childrenRef = function() {
    return s;
  };
  function g(w) {
    for (var x = 0; x < s.length; x++)
      s[x].addSelfToZr(w);
  }
  n_(e, "addSelfToZr", {
    after: function(w) {
      g(w);
    }
  }), n_(e, "removeSelfFromZr", {
    after: function(w) {
      for (var x = 0; x < s.length; x++)
        s[x].removeSelfFromZr(w);
    }
  });
  function v() {
    e.__isCombineMorphing = !1, e.__morphT = -1, e.childrenRef = null, Gy(e, "addSelfToZr"), Gy(e, "removeSelfFromZr");
  }
  var m = s.length;
  if (c)
    for (var y = m, b = function() {
      y--, y === 0 && (v(), l && l());
    }, f = 0; f < m; f++) {
      var O = c ? Be({
        delay: (t.delay || 0) + c(f, m, r[f], s[f]),
        done: b
      }, t) : t;
      E$(r[f], s[f], O);
    }
  else
    e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, Be({
      during: function(w) {
        for (var x = 0; x < m; x++) {
          var S = s[x];
          S.__morphT = e.__morphT, S.dirtyShape();
        }
        u && u(w);
      },
      done: function() {
        v();
        for (var w = 0; w < n.length; w++)
          Gy(n[w], "updateTransform");
        l && l();
      }
    }, t));
  return e.__zr && g(e.__zr), {
    fromIndividuals: r,
    toIndividuals: s,
    count: m
  };
}
function rFt(n, e, t) {
  var r = e.length, i = [], o = t.dividePath || Zoe;
  function a(d) {
    for (var p = 0; p < d.length; p++) {
      var g = d[p];
      t_(g) ? a(g.childrenRef()) : g instanceof gt && i.push(g);
    }
  }
  if (t_(n)) {
    a(n.childrenRef());
    var s = i.length;
    if (s < r)
      for (var l = 0, u = s; u < r; u++)
        i.push(ZR(i[l++ % s]));
    i.length = r;
  } else {
    i = o({ path: n, count: r });
    for (var c = n.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c);
    if (i.length !== r)
      return console.error("Invalid morphing: unmatched splitted path"), UD();
  }
  i = r_(i), e = r_(e);
  for (var h = t.individualDelay, u = 0; u < r; u++) {
    var f = h ? Be({
      delay: (t.delay || 0) + h(u, r, i[u], e[u])
    }, t) : t;
    E$(i[u], e[u], f);
  }
  return {
    fromIndividuals: i,
    toIndividuals: e,
    count: e.length
  };
}
function bG(n) {
  return se(n[0]);
}
function OG(n, e) {
  for (var t = [], r = n.length, i = 0; i < r; i++)
    t.push({
      one: n[i],
      many: []
    });
  for (var i = 0; i < e.length; i++) {
    var o = e[i].length, a = void 0;
    for (a = 0; a < o; a++)
      t[a % r].many.push(e[i][a]);
  }
  for (var s = 0, i = r - 1; i >= 0; i--)
    if (!t[i].many.length) {
      var l = t[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return t;
      var o = l.length, u = Math.ceil(o / 2);
      t[i].many = l.slice(u, o), t[s].many = l.slice(0, u), s++;
    }
  return t;
}
var iFt = {
  clone: function(n) {
    for (var e = [], t = 1 - Math.pow(1 - n.path.style.opacity, 1 / n.count), r = 0; r < n.count; r++) {
      var i = ZR(n.path);
      i.setStyle("opacity", t), e.push(i);
    }
    return e;
  },
  // Use the default divider
  split: null
};
function zk(n, e, t, r, i, o) {
  if (!n.length || !e.length)
    return;
  var a = Lv("update", r, i);
  if (!(a && a.duration > 0))
    return;
  var s = r.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, a), u, c;
  bG(n) && (u = n, c = e), bG(e) && (u = e, c = n);
  function h(m, y, b, O, w) {
    var x = m.many, S = m.one;
    if (x.length === 1 && !w) {
      var _ = y ? x[0] : S, C = y ? S : x[0];
      if (t_(_))
        h({
          many: [_],
          one: C
        }, !0, b, O, !0);
      else {
        var A = s ? Be({
          delay: s(b, O)
        }, l) : l;
        E$(_, C, A), o(_, C, _, C, A);
      }
    } else
      for (var k = Be({
        dividePath: iFt[t],
        individualDelay: s && function(R, N, $, F) {
          return s(R + b, O);
        }
      }, l), P = y ? nFt(x, S, k) : rFt(S, x, k), L = P.fromIndividuals, D = P.toIndividuals, E = L.length, M = 0; M < E; M++) {
        var A = s ? Be({
          delay: s(M, E)
        }, l) : l;
        o(L[M], D[M], y ? x[M] : m.one, y ? m.one : x[M], A);
      }
  }
  for (var f = u ? u === n : n.length > e.length, d = u ? OG(c, u) : OG(f ? e : n, [f ? n : e]), p = 0, g = 0; g < d.length; g++)
    p += d[g].many.length;
  for (var v = 0, g = 0; g < d.length; g++)
    h(d[g], f, v, p), v += d[g].many.length;
}
function Jh(n) {
  if (!n)
    return [];
  if (se(n)) {
    for (var e = [], t = 0; t < n.length; t++)
      e.push(Jh(n[t]));
    return e;
  }
  var r = [];
  return n.traverse(function(i) {
    i instanceof gt && !i.disableMorphing && !i.invisible && !i.ignore && r.push(i);
  }), r;
}
var Woe = 1e4, oFt = 0, wG = 1, xG = 2, aFt = It();
function sFt(n, e) {
  for (var t = n.dimensions, r = 0; r < t.length; r++) {
    var i = n.getDimensionInfo(t[r]);
    if (i && i.otherDims[e] === 0)
      return t[r];
  }
}
function lFt(n, e, t) {
  var r = n.getDimensionInfo(t), i = r && r.ordinalMeta;
  if (r) {
    var o = n.get(r.name, e);
    return i && i.categories[o] || o + "";
  }
}
function SG(n, e, t, r) {
  var i = r ? "itemChildGroupId" : "itemGroupId", o = sFt(n, i);
  if (o) {
    var a = lFt(n, e, o);
    return a;
  }
  var s = n.getRawDataItem(e), l = r ? "childGroupId" : "groupId";
  if (s && s[l])
    return s[l] + "";
  if (!r)
    return t || n.getId(e);
}
function _G(n) {
  var e = [];
  return I(n, function(t) {
    var r = t.data, i = t.dataGroupId;
    if (r.count() > Woe) {
      process.env.NODE_ENV !== "production" && $n("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var o = r.getIndices(), a = 0; a < o.length; a++)
      e.push({
        data: r,
        groupId: SG(r, a, i, !1),
        childGroupId: SG(r, a, i, !0),
        divide: t.divide,
        dataIndex: a
      });
  }), e;
}
function Fk(n, e, t) {
  n.traverse(function(r) {
    r instanceof gt && Cn(r, {
      style: {
        opacity: 0
      }
    }, e, {
      dataIndex: t,
      isFrom: !0
    });
  });
}
function Qk(n) {
  if (n.parent) {
    var e = n.getComputedTransform();
    n.setLocalTransform(e), n.parent.remove(n);
  }
}
function mp(n) {
  n.stopAnimation(), n.isGroup && n.traverse(function(e) {
    e.stopAnimation();
  });
}
function uFt(n, e, t) {
  var r = Lv("update", t, e);
  r && n.traverse(function(i) {
    if (i instanceof Ia) {
      var o = y_t(i);
      o && i.animateFrom({
        style: o
      }, r);
    }
  });
}
function cFt(n, e) {
  var t = n.length;
  if (t !== e.length)
    return !1;
  for (var r = 0; r < t; r++) {
    var i = n[r], o = e[r];
    if (i.data.getId(i.dataIndex) !== o.data.getId(o.dataIndex))
      return !1;
  }
  return !0;
}
function Goe(n, e, t) {
  var r = _G(n), i = _G(e);
  function o(b, O, w, x, S) {
    (w || b) && O.animateFrom({
      style: w && w !== b ? re(re({}, w.style), b.style) : b.style
    }, S);
  }
  var a = !1, s = oFt, l = Ee(), u = Ee();
  r.forEach(function(b) {
    b.groupId && l.set(b.groupId, !0), b.childGroupId && u.set(b.childGroupId, !0);
  });
  for (var c = 0; c < i.length; c++) {
    var h = i[c].groupId;
    if (u.get(h)) {
      s = wG;
      break;
    }
    var f = i[c].childGroupId;
    if (f && l.get(f)) {
      s = xG;
      break;
    }
  }
  function d(b, O) {
    return function(w) {
      var x = w.data, S = w.dataIndex;
      return O ? x.getId(S) : b ? s === wG ? w.childGroupId : w.groupId : s === xG ? w.childGroupId : w.groupId;
    };
  }
  var p = cFt(r, i), g = {};
  if (!p)
    for (var c = 0; c < i.length; c++) {
      var v = i[c], m = v.data.getItemGraphicEl(v.dataIndex);
      m && (g[m.id] = !0);
    }
  function y(b, O) {
    var w = r[O], x = i[b], S = x.data.hostModel, _ = w.data.getItemGraphicEl(w.dataIndex), C = x.data.getItemGraphicEl(x.dataIndex);
    if (_ === C) {
      C && uFt(C, x.dataIndex, S);
      return;
    }
    // We can't use the elements that already being morphed
    _ && g[_.id] || C && (mp(C), _ ? (mp(_), Qk(_), a = !0, zk(Jh(_), Jh(C), x.divide, S, b, o)) : Fk(C, S, b));
  }
  new mu(r, i, d(!0, p), d(!1, p), null, "multiple").update(y).updateManyToOne(function(b, O) {
    var w = i[b], x = w.data, S = x.hostModel, _ = x.getItemGraphicEl(w.dataIndex), C = en(le(O, function(A) {
      return r[A].data.getItemGraphicEl(r[A].dataIndex);
    }), function(A) {
      return A && A !== _ && !g[A.id];
    });
    _ && (mp(_), C.length ? (I(C, function(A) {
      mp(A), Qk(A);
    }), a = !0, zk(Jh(C), Jh(_), w.divide, S, b, o)) : Fk(_, S, w.dataIndex));
  }).updateOneToMany(function(b, O) {
    var w = r[O], x = w.data.getItemGraphicEl(w.dataIndex);
    if (!(x && g[x.id])) {
      var S = en(le(b, function(C) {
        return i[C].data.getItemGraphicEl(i[C].dataIndex);
      }), function(C) {
        return C && C !== x;
      }), _ = i[b[0]].data.hostModel;
      S.length && (I(S, function(C) {
        return mp(C);
      }), x ? (mp(x), Qk(x), a = !0, zk(
        Jh(x),
        Jh(S),
        w.divide,
        // Use divide on old.
        _,
        b[0],
        o
      )) : I(S, function(C) {
        return Fk(C, _, b[0]);
      }));
    }
  }).updateManyToMany(function(b, O) {
    new mu(O, b, function(w) {
      return r[w].data.getId(r[w].dataIndex);
    }, function(w) {
      return i[w].data.getId(i[w].dataIndex);
    }).update(function(w, x) {
      y(b[w], O[x]);
    }).execute();
  }).execute(), a && I(e, function(b) {
    var O = b.data, w = O.hostModel, x = w && t.getViewOfSeriesModel(w), S = Lv("update", w, 0);
    x && w.isAnimationEnabled() && S && S.duration > 0 && x.group.traverse(function(_) {
      _ instanceof gt && !_.animators.length && _.animateFrom({
        style: {
          opacity: 0
        }
      }, S);
    });
  });
}
function CG(n) {
  var e = n.getModel("universalTransition").get("seriesKey");
  return e || n.id;
}
function AG(n) {
  return se(n) ? n.sort().join(",") : n;
}
function nc(n) {
  if (n.hostModel)
    return n.hostModel.getModel("universalTransition").get("divideShape");
}
function hFt(n, e) {
  var t = Ee(), r = Ee(), i = Ee();
  I(n.oldSeries, function(a, s) {
    var l = n.oldDataGroupIds[s], u = n.oldData[s], c = CG(a), h = AG(c);
    r.set(h, {
      dataGroupId: l,
      data: u
    }), se(c) && I(c, function(f) {
      i.set(f, {
        key: h,
        dataGroupId: l,
        data: u
      });
    });
  });
  function o(a) {
    t.get(a) && $n("Duplicated seriesKey in universalTransition " + a);
  }
  return I(e.updatedSeries, function(a) {
    if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
      var s = a.get("dataGroupId"), l = a.getData(), u = CG(a), c = AG(u), h = r.get(c);
      if (h)
        process.env.NODE_ENV !== "production" && o(c), t.set(c, {
          oldSeries: [{
            dataGroupId: h.dataGroupId,
            divide: nc(h.data),
            data: h.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: nc(l),
            data: l
          }]
        });
      else if (se(u)) {
        process.env.NODE_ENV !== "production" && o(c);
        var f = [];
        I(u, function(g) {
          var v = r.get(g);
          v.data && f.push({
            dataGroupId: v.dataGroupId,
            divide: nc(v.data),
            data: v.data
          });
        }), f.length && t.set(c, {
          oldSeries: f,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: nc(l)
          }]
        });
      } else {
        var d = i.get(u);
        if (d) {
          var p = t.get(d.key);
          p || (p = {
            oldSeries: [{
              dataGroupId: d.dataGroupId,
              data: d.data,
              divide: nc(d.data)
            }],
            newSeries: []
          }, t.set(d.key, p)), p.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: nc(l)
          });
        }
      }
    }
  }), t;
}
function TG(n, e) {
  for (var t = 0; t < n.length; t++) {
    var r = e.seriesIndex != null && e.seriesIndex === n[t].seriesIndex || e.seriesId != null && e.seriesId === n[t].id;
    if (r)
      return t;
  }
}
function fFt(n, e, t, r) {
  var i = [], o = [];
  I(an(n.from), function(a) {
    var s = TG(e.oldSeries, a);
    s >= 0 && i.push({
      dataGroupId: e.oldDataGroupIds[s],
      data: e.oldData[s],
      // TODO can specify divideShape in transition.
      divide: nc(e.oldData[s]),
      groupIdDim: a.dimension
    });
  }), I(an(n.to), function(a) {
    var s = TG(t.updatedSeries, a);
    if (s >= 0) {
      var l = t.updatedSeries[s].getData();
      o.push({
        dataGroupId: e.oldDataGroupIds[s],
        data: l,
        divide: nc(l),
        groupIdDim: a.dimension
      });
    }
  }), i.length > 0 && o.length > 0 && Goe(i, o, r);
}
function dFt(n) {
  n.registerUpdateLifecycle("series:beforeupdate", function(e, t, r) {
    I(an(r.seriesTransition), function(i) {
      I(an(i.to), function(o) {
        for (var a = r.updatedSeries, s = 0; s < a.length; s++)
          (o.seriesIndex != null && o.seriesIndex === a[s].seriesIndex || o.seriesId != null && o.seriesId === a[s].id) && (a[s][Xw] = !0);
      });
    });
  }), n.registerUpdateLifecycle("series:transition", function(e, t, r) {
    var i = aFt(t);
    if (i.oldSeries && r.updatedSeries && r.optionChanged) {
      var o = r.seriesTransition;
      if (o)
        I(an(o), function(d) {
          fFt(d, i, r, t);
        });
      else {
        var a = hFt(i, r);
        I(a.keys(), function(d) {
          var p = a.get(d);
          Goe(p.oldSeries, p.newSeries, t);
        });
      }
      I(r.updatedSeries, function(d) {
        d[Xw] && (d[Xw] = !1);
      });
    }
    for (var s = e.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], h = 0; h < s.length; h++) {
      var f = s[h].getData();
      f.count() < Woe && (l.push(s[h]), u.push(s[h].get("dataGroupId")), c.push(f));
    }
  });
}
ft([Ukt]);
ft([Wkt]);
ft([bPt, NPt, YPt, IEt, UEt, WMt, ODt, aLt, MLt, VLt, XLt, JIt, ARt, VRt, oNt, fNt, PNt, VNt, KNt, a$t, y$t, n3t]);
ft(C3t);
ft(rBt);
ft(Vre);
ft(OBt);
ft(Cie);
ft(TBt);
ft(NBt);
ft(R5t);
ft(rVt);
ft(t1);
ft(SVt);
ft(AVt);
ft(zVt);
ft(XVt);
ft(i4t);
ft(f4t);
ft(A4t);
ft(q4t);
ft(Moe);
ft(Doe);
ft(bzt);
ft($oe);
ft(Boe);
ft(_zt);
ft($zt);
ft(zzt);
ft(dFt);
ft(ukt);
export {
  Gj as $,
  h6t as A,
  yL as B,
  er as C,
  N6t as D,
  w6t as E,
  ZFt as F,
  Ie as G,
  RFt as H,
  _d as I,
  jFt as J,
  zFt as K,
  AFt as L,
  Mn as M,
  EFt as N,
  s6t as O,
  DFt as P,
  M6t as Q,
  P6t as R,
  E6t as S,
  v6t as T,
  m6t as U,
  o1 as V,
  S6t as W,
  n6t as X,
  r6t as Y,
  Vg as Z,
  g3 as _,
  O6t as a,
  bs as a$,
  NFt as a0,
  $Ft as a1,
  qFt as a2,
  YFt as a3,
  LFt as a4,
  a6t as a5,
  zg as a6,
  d0 as a7,
  AEe as a8,
  p0 as a9,
  mL as aA,
  HFt as aB,
  tq as aC,
  Uf as aD,
  Kj as aE,
  o6t as aF,
  JFt as aG,
  Z6t as aH,
  W6t as aI,
  C6t as aJ,
  Qe as aK,
  nn as aL,
  Q6t as aM,
  IFt as aN,
  pA as aO,
  Sn as aP,
  Xy as aQ,
  Yr as aR,
  tr as aS,
  CFt as aT,
  OFt as aU,
  vb as aV,
  XFt as aW,
  d_ as aX,
  UFt as aY,
  nL as aZ,
  Qfe as a_,
  l6t as aa,
  x6t as ab,
  $6t as ac,
  sxe as ad,
  bFt as ae,
  axe as af,
  y6t as ag,
  b6t as ah,
  G6t as ai,
  t6t as aj,
  A6t as ak,
  t1e as al,
  kde as am,
  _P as an,
  VFt as ao,
  d6t as ap,
  u6t as aq,
  KFt as ar,
  v1e as as,
  j6t as at,
  SFt as au,
  pde as av,
  xFt as aw,
  QFt as ax,
  WFt as ay,
  f6t as az,
  k6t as b,
  ahe as b0,
  ax as b1,
  _Ft as b2,
  mFt as b3,
  wFt as b4,
  D6t as b5,
  ri as c,
  p6t as d,
  g6t as e,
  t0 as f,
  ga as g,
  ppe as h,
  PFt as i,
  TFt as j,
  GFt as k,
  kFt as l,
  Ppe as m,
  yFt as n,
  bt as o,
  Jj as p,
  MFt as q,
  BFt as r,
  FFt as s,
  c6t as t,
  T6t as u,
  $pe as v,
  _6t as w,
  yl as x,
  Td as y,
  v3 as z
};
