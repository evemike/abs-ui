var EL = Object.defineProperty;
var AL = (n, e, t) => e in n ? EL(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var ii = (n, e, t) => (AL(n, typeof e != "symbol" ? e + "" : e, t), t), g0 = (n, e, t) => {
  if (!e.has(n))
    throw TypeError("Cannot " + t);
};
var Q = (n, e, t) => (g0(n, e, "read from private field"), t ? t.call(n) : e.get(n)), ht = (n, e, t) => {
  if (e.has(n))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(n) : e.set(n, t);
}, Ge = (n, e, t, i) => (g0(n, e, "write to private field"), i ? i.call(n, t) : e.set(n, t), t);
var ep = (n, e, t, i) => ({
  set _(r) {
    Ge(n, e, r, t);
  },
  get _() {
    return Q(n, e, i);
  }
}), ze = (n, e, t) => (g0(n, e, "access private method"), t);
import "../css/vendor-BycN2tkO.css";
import { defineComponent as F, openBlock as R, createElementBlock as V, createElementVNode as Z, shallowRef as In, watchEffect as Fr, readonly as R1, ref as D, watch as ne, getCurrentScope as vA, onScopeDispose as N1, unref as O, getCurrentInstance as Xe, onMounted as qe, nextTick as $e, computed as $, warn as $L, isVNode as co, onBeforeUnmount as Kn, inject as ke, isRef as Zi, onBeforeMount as D1, provide as ft, renderSlot as de, mergeProps as Pi, toRef as Pr, onUnmounted as Gu, reactive as Gt, toRefs as Hr, normalizeClass as L, onUpdated as Ya, createVNode as K, Fragment as Tt, useSlots as vo, withCtx as Y, createBlock as ie, resolveDynamicComponent as yt, normalizeStyle as Qe, createTextVNode as Yn, toDisplayString as xe, createCommentVNode as G, TransitionGroup as bA, useAttrs as yA, withDirectives as it, withModifiers as Le, vShow as Qt, Transition as bo, cloneVNode as TL, Text as OA, Comment as wA, Teleport as tv, onDeactivated as _L, toRaw as Ed, vModelCheckbox as Vg, vModelRadio as xA, h as Re, resolveComponent as nt, renderList as ai, onBeforeUpdate as ML, withKeys as Ut, vModelText as L1, toHandlers as RL, createSlots as Fg, resolveDirective as nv, normalizeProps as NL, guardReactiveProps as DL, render as Na, shallowReactive as LL, customRef as IL, markRaw as BL, createApp as QL } from "vue";
var SA = typeof global == "object" && global && global.Object === Object && global, zL = typeof self == "object" && self && self.Object === Object && self, ks = SA || zL || Function("return this")(), Xr = ks.Symbol, CA = Object.prototype, jL = CA.hasOwnProperty, VL = CA.toString, Eh = Xr ? Xr.toStringTag : void 0;
function FL(n) {
  var e = jL.call(n, Eh), t = n[Eh];
  try {
    n[Eh] = void 0;
    var i = !0;
  } catch {
  }
  var r = VL.call(n);
  return i && (e ? n[Eh] = t : delete n[Eh]), r;
}
var ZL = Object.prototype, qL = ZL.toString;
function WL(n) {
  return qL.call(n);
}
var HL = "[object Null]", XL = "[object Undefined]", aS = Xr ? Xr.toStringTag : void 0;
function Ko(n) {
  return n == null ? n === void 0 ? XL : HL : aS && aS in Object(n) ? FL(n) : WL(n);
}
function Yr(n) {
  return n != null && typeof n == "object";
}
var YL = "[object Symbol]";
function uo(n) {
  return typeof n == "symbol" || Yr(n) && Ko(n) == YL;
}
function Dl(n, e) {
  for (var t = -1, i = n == null ? 0 : n.length, r = Array(i); ++t < i; )
    r[t] = e(n[t], t, n);
  return r;
}
var li = Array.isArray, UL = 1 / 0, lS = Xr ? Xr.prototype : void 0, cS = lS ? lS.toString : void 0;
function kA(n) {
  if (typeof n == "string")
    return n;
  if (li(n))
    return Dl(n, kA) + "";
  if (uo(n))
    return cS ? cS.call(n) : "";
  var e = n + "";
  return e == "0" && 1 / n == -UL ? "-0" : e;
}
var GL = /\s/;
function KL(n) {
  for (var e = n.length; e-- && GL.test(n.charAt(e)); )
    ;
  return e;
}
var JL = /^\s+/;
function eI(n) {
  return n && n.slice(0, KL(n) + 1).replace(JL, "");
}
function wn(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var uS = NaN, tI = /^[-+]0x[0-9a-f]+$/i, nI = /^0b[01]+$/i, iI = /^0o[0-7]+$/i, rI = parseInt;
function Vc(n) {
  if (typeof n == "number")
    return n;
  if (uo(n))
    return uS;
  if (wn(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = wn(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = eI(n);
  var t = nI.test(n);
  return t || iI.test(n) ? rI(n.slice(2), t ? 2 : 8) : tI.test(n) ? uS : +n;
}
var hS = 1 / 0, sI = 17976931348623157e292;
function oI(n) {
  if (!n)
    return n === 0 ? n : 0;
  if (n = Vc(n), n === hS || n === -hS) {
    var e = n < 0 ? -1 : 1;
    return e * sI;
  }
  return n === n ? n : 0;
}
function I1(n) {
  var e = oI(n), t = e % 1;
  return e === e ? t ? e - t : e : 0;
}
function Ku(n) {
  return n;
}
var aI = "[object AsyncFunction]", lI = "[object Function]", cI = "[object GeneratorFunction]", uI = "[object Proxy]";
function B1(n) {
  if (!wn(n))
    return !1;
  var e = Ko(n);
  return e == lI || e == cI || e == aI || e == uI;
}
var m0 = ks["__core-js_shared__"], dS = function() {
  var n = /[^.]+$/.exec(m0 && m0.keys && m0.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function hI(n) {
  return !!dS && dS in n;
}
var dI = Function.prototype, fI = dI.toString;
function ic(n) {
  if (n != null) {
    try {
      return fI.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var pI = /[\\^$.*+?()[\]{}|]/g, gI = /^\[object .+?Constructor\]$/, mI = Function.prototype, vI = Object.prototype, bI = mI.toString, yI = vI.hasOwnProperty, OI = RegExp(
  "^" + bI.call(yI).replace(pI, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function wI(n) {
  if (!wn(n) || hI(n))
    return !1;
  var e = B1(n) ? OI : gI;
  return e.test(ic(n));
}
function xI(n, e) {
  return n == null ? void 0 : n[e];
}
function rc(n, e) {
  var t = xI(n, e);
  return wI(t) ? t : void 0;
}
var Zb = rc(ks, "WeakMap"), fS = Object.create, SI = /* @__PURE__ */ function() {
  function n() {
  }
  return function(e) {
    if (!wn(e))
      return {};
    if (fS)
      return fS(e);
    n.prototype = e;
    var t = new n();
    return n.prototype = void 0, t;
  };
}();
function PA(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
function CI() {
}
function EA(n, e) {
  var t = -1, i = n.length;
  for (e || (e = Array(i)); ++t < i; )
    e[t] = n[t];
  return e;
}
var kI = 800, PI = 16, EI = Date.now;
function AI(n) {
  var e = 0, t = 0;
  return function() {
    var i = EI(), r = PI - (i - t);
    if (t = i, r > 0) {
      if (++e >= kI)
        return arguments[0];
    } else
      e = 0;
    return n.apply(void 0, arguments);
  };
}
function $I(n) {
  return function() {
    return n;
  };
}
var Zg = function() {
  try {
    var n = rc(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), TI = Zg ? function(n, e) {
  return Zg(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: $I(e),
    writable: !0
  });
} : Ku;
const _I = TI;
var AA = AI(_I);
function MI(n, e) {
  for (var t = -1, i = n == null ? 0 : n.length; ++t < i && e(n[t], t, n) !== !1; )
    ;
  return n;
}
function Q1(n, e, t, i) {
  for (var r = n.length, s = t + (i ? 1 : -1); i ? s-- : ++s < r; )
    if (e(n[s], s, n))
      return s;
  return -1;
}
function RI(n) {
  return n !== n;
}
function NI(n, e, t) {
  for (var i = t - 1, r = n.length; ++i < r; )
    if (n[i] === e)
      return i;
  return -1;
}
function DI(n, e, t) {
  return e === e ? NI(n, e, t) : Q1(n, RI, t);
}
function $A(n, e) {
  var t = n == null ? 0 : n.length;
  return !!t && DI(n, e, 0) > -1;
}
var LI = 9007199254740991, II = /^(?:0|[1-9]\d*)$/;
function iv(n, e) {
  var t = typeof n;
  return e = e ?? LI, !!e && (t == "number" || t != "symbol" && II.test(n)) && n > -1 && n % 1 == 0 && n < e;
}
function rv(n, e, t) {
  e == "__proto__" && Zg ? Zg(n, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : n[e] = t;
}
function Ju(n, e) {
  return n === e || n !== n && e !== e;
}
var BI = Object.prototype, QI = BI.hasOwnProperty;
function sv(n, e, t) {
  var i = n[e];
  (!(QI.call(n, e) && Ju(i, t)) || t === void 0 && !(e in n)) && rv(n, e, t);
}
function sc(n, e, t, i) {
  var r = !t;
  t || (t = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var a = e[s], l = i ? i(t[a], n[a], a, t, n) : void 0;
    l === void 0 && (l = n[a]), r ? rv(t, a, l) : sv(t, a, l);
  }
  return t;
}
var pS = Math.max;
function TA(n, e, t) {
  return e = pS(e === void 0 ? n.length - 1 : e, 0), function() {
    for (var i = arguments, r = -1, s = pS(i.length - e, 0), o = Array(s); ++r < s; )
      o[r] = i[e + r];
    r = -1;
    for (var a = Array(e + 1); ++r < e; )
      a[r] = i[r];
    return a[e] = t(o), PA(n, this, a);
  };
}
function eh(n, e) {
  return AA(TA(n, e, Ku), n + "");
}
var zI = 9007199254740991;
function z1(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= zI;
}
function Ua(n) {
  return n != null && z1(n.length) && !B1(n);
}
function Ad(n, e, t) {
  if (!wn(t))
    return !1;
  var i = typeof e;
  return (i == "number" ? Ua(t) && iv(e, t.length) : i == "string" && e in t) ? Ju(t[e], n) : !1;
}
function j1(n) {
  return eh(function(e, t) {
    var i = -1, r = t.length, s = r > 1 ? t[r - 1] : void 0, o = r > 2 ? t[2] : void 0;
    for (s = n.length > 3 && typeof s == "function" ? (r--, s) : void 0, o && Ad(t[0], t[1], o) && (s = r < 3 ? void 0 : s, r = 1), e = Object(e); ++i < r; ) {
      var a = t[i];
      a && n(e, a, i, s);
    }
    return e;
  });
}
var jI = Object.prototype;
function xf(n) {
  var e = n && n.constructor, t = typeof e == "function" && e.prototype || jI;
  return n === t;
}
function VI(n, e) {
  for (var t = -1, i = Array(n); ++t < n; )
    i[t] = e(t);
  return i;
}
var FI = "[object Arguments]";
function gS(n) {
  return Yr(n) && Ko(n) == FI;
}
var _A = Object.prototype, ZI = _A.hasOwnProperty, qI = _A.propertyIsEnumerable, cu = gS(/* @__PURE__ */ function() {
  return arguments;
}()) ? gS : function(n) {
  return Yr(n) && ZI.call(n, "callee") && !qI.call(n, "callee");
};
function WI() {
  return !1;
}
var MA = typeof exports == "object" && exports && !exports.nodeType && exports, mS = MA && typeof module == "object" && module && !module.nodeType && module, HI = mS && mS.exports === MA, vS = HI ? ks.Buffer : void 0, XI = vS ? vS.isBuffer : void 0, uu = XI || WI, YI = "[object Arguments]", UI = "[object Array]", GI = "[object Boolean]", KI = "[object Date]", JI = "[object Error]", e5 = "[object Function]", t5 = "[object Map]", n5 = "[object Number]", i5 = "[object Object]", r5 = "[object RegExp]", s5 = "[object Set]", o5 = "[object String]", a5 = "[object WeakMap]", l5 = "[object ArrayBuffer]", c5 = "[object DataView]", u5 = "[object Float32Array]", h5 = "[object Float64Array]", d5 = "[object Int8Array]", f5 = "[object Int16Array]", p5 = "[object Int32Array]", g5 = "[object Uint8Array]", m5 = "[object Uint8ClampedArray]", v5 = "[object Uint16Array]", b5 = "[object Uint32Array]", Jt = {};
Jt[u5] = Jt[h5] = Jt[d5] = Jt[f5] = Jt[p5] = Jt[g5] = Jt[m5] = Jt[v5] = Jt[b5] = !0;
Jt[YI] = Jt[UI] = Jt[l5] = Jt[GI] = Jt[c5] = Jt[KI] = Jt[JI] = Jt[e5] = Jt[t5] = Jt[n5] = Jt[i5] = Jt[r5] = Jt[s5] = Jt[o5] = Jt[a5] = !1;
function y5(n) {
  return Yr(n) && z1(n.length) && !!Jt[Ko(n)];
}
function Sf(n) {
  return function(e) {
    return n(e);
  };
}
var RA = typeof exports == "object" && exports && !exports.nodeType && exports, Jh = RA && typeof module == "object" && module && !module.nodeType && module, O5 = Jh && Jh.exports === RA, v0 = O5 && SA.process, hu = function() {
  try {
    var n = Jh && Jh.require && Jh.require("util").types;
    return n || v0 && v0.binding && v0.binding("util");
  } catch {
  }
}(), bS = hu && hu.isTypedArray, w5 = bS ? Sf(bS) : y5;
const ov = w5;
var x5 = Object.prototype, S5 = x5.hasOwnProperty;
function NA(n, e) {
  var t = li(n), i = !t && cu(n), r = !t && !i && uu(n), s = !t && !i && !r && ov(n), o = t || i || r || s, a = o ? VI(n.length, String) : [], l = a.length;
  for (var c in n)
    (e || S5.call(n, c)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    iv(c, l))) && a.push(c);
  return a;
}
function DA(n, e) {
  return function(t) {
    return n(e(t));
  };
}
var C5 = DA(Object.keys, Object), k5 = Object.prototype, P5 = k5.hasOwnProperty;
function LA(n) {
  if (!xf(n))
    return C5(n);
  var e = [];
  for (var t in Object(n))
    P5.call(n, t) && t != "constructor" && e.push(t);
  return e;
}
function th(n) {
  return Ua(n) ? NA(n) : LA(n);
}
var E5 = Object.prototype, A5 = E5.hasOwnProperty, $5 = j1(function(n, e) {
  if (xf(e) || Ua(e)) {
    sc(e, th(e), n);
    return;
  }
  for (var t in e)
    A5.call(e, t) && sv(n, t, e[t]);
});
const BGe = $5;
function T5(n) {
  var e = [];
  if (n != null)
    for (var t in Object(n))
      e.push(t);
  return e;
}
var _5 = Object.prototype, M5 = _5.hasOwnProperty;
function R5(n) {
  if (!wn(n))
    return T5(n);
  var e = xf(n), t = [];
  for (var i in n)
    i == "constructor" && (e || !M5.call(n, i)) || t.push(i);
  return t;
}
function nh(n) {
  return Ua(n) ? NA(n, !0) : R5(n);
}
var N5 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, D5 = /^\w*$/;
function V1(n, e) {
  if (li(n))
    return !1;
  var t = typeof n;
  return t == "number" || t == "symbol" || t == "boolean" || n == null || uo(n) ? !0 : D5.test(n) || !N5.test(n) || e != null && n in Object(e);
}
var $d = rc(Object, "create");
function L5() {
  this.__data__ = $d ? $d(null) : {}, this.size = 0;
}
function I5(n) {
  var e = this.has(n) && delete this.__data__[n];
  return this.size -= e ? 1 : 0, e;
}
var B5 = "__lodash_hash_undefined__", Q5 = Object.prototype, z5 = Q5.hasOwnProperty;
function j5(n) {
  var e = this.__data__;
  if ($d) {
    var t = e[n];
    return t === B5 ? void 0 : t;
  }
  return z5.call(e, n) ? e[n] : void 0;
}
var V5 = Object.prototype, F5 = V5.hasOwnProperty;
function Z5(n) {
  var e = this.__data__;
  return $d ? e[n] !== void 0 : F5.call(e, n);
}
var q5 = "__lodash_hash_undefined__";
function W5(n, e) {
  var t = this.__data__;
  return this.size += this.has(n) ? 0 : 1, t[n] = $d && e === void 0 ? q5 : e, this;
}
function Fl(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var i = n[e];
    this.set(i[0], i[1]);
  }
}
Fl.prototype.clear = L5;
Fl.prototype.delete = I5;
Fl.prototype.get = j5;
Fl.prototype.has = Z5;
Fl.prototype.set = W5;
function H5() {
  this.__data__ = [], this.size = 0;
}
function av(n, e) {
  for (var t = n.length; t--; )
    if (Ju(n[t][0], e))
      return t;
  return -1;
}
var X5 = Array.prototype, Y5 = X5.splice;
function U5(n) {
  var e = this.__data__, t = av(e, n);
  if (t < 0)
    return !1;
  var i = e.length - 1;
  return t == i ? e.pop() : Y5.call(e, t, 1), --this.size, !0;
}
function G5(n) {
  var e = this.__data__, t = av(e, n);
  return t < 0 ? void 0 : e[t][1];
}
function K5(n) {
  return av(this.__data__, n) > -1;
}
function J5(n, e) {
  var t = this.__data__, i = av(t, n);
  return i < 0 ? (++this.size, t.push([n, e])) : t[i][1] = e, this;
}
function Jo(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var i = n[e];
    this.set(i[0], i[1]);
  }
}
Jo.prototype.clear = H5;
Jo.prototype.delete = U5;
Jo.prototype.get = G5;
Jo.prototype.has = K5;
Jo.prototype.set = J5;
var Td = rc(ks, "Map");
function e8() {
  this.size = 0, this.__data__ = {
    hash: new Fl(),
    map: new (Td || Jo)(),
    string: new Fl()
  };
}
function t8(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
}
function lv(n, e) {
  var t = n.__data__;
  return t8(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function n8(n) {
  var e = lv(this, n).delete(n);
  return this.size -= e ? 1 : 0, e;
}
function i8(n) {
  return lv(this, n).get(n);
}
function r8(n) {
  return lv(this, n).has(n);
}
function s8(n, e) {
  var t = lv(this, n), i = t.size;
  return t.set(n, e), this.size += t.size == i ? 0 : 1, this;
}
function ea(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var i = n[e];
    this.set(i[0], i[1]);
  }
}
ea.prototype.clear = e8;
ea.prototype.delete = n8;
ea.prototype.get = i8;
ea.prototype.has = r8;
ea.prototype.set = s8;
var o8 = "Expected a function";
function cv(n, e) {
  if (typeof n != "function" || e != null && typeof e != "function")
    throw new TypeError(o8);
  var t = function() {
    var i = arguments, r = e ? e.apply(this, i) : i[0], s = t.cache;
    if (s.has(r))
      return s.get(r);
    var o = n.apply(this, i);
    return t.cache = s.set(r, o) || s, o;
  };
  return t.cache = new (cv.Cache || ea)(), t;
}
cv.Cache = ea;
var a8 = 500;
function l8(n) {
  var e = cv(n, function(i) {
    return t.size === a8 && t.clear(), i;
  }), t = e.cache;
  return e;
}
var c8 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, u8 = /\\(\\)?/g, h8 = l8(function(n) {
  var e = [];
  return n.charCodeAt(0) === 46 && e.push(""), n.replace(c8, function(t, i, r, s) {
    e.push(r ? s.replace(u8, "$1") : i || t);
  }), e;
});
function Cf(n) {
  return n == null ? "" : kA(n);
}
function ih(n, e) {
  return li(n) ? n : V1(n, e) ? [n] : h8(Cf(n));
}
var d8 = 1 / 0;
function rh(n) {
  if (typeof n == "string" || uo(n))
    return n;
  var e = n + "";
  return e == "0" && 1 / n == -d8 ? "-0" : e;
}
function kf(n, e) {
  e = ih(e, n);
  for (var t = 0, i = e.length; n != null && t < i; )
    n = n[rh(e[t++])];
  return t && t == i ? n : void 0;
}
function on(n, e, t) {
  var i = n == null ? void 0 : kf(n, e);
  return i === void 0 ? t : i;
}
function F1(n, e) {
  for (var t = -1, i = e.length, r = n.length; ++t < i; )
    n[r + t] = e[t];
  return n;
}
var yS = Xr ? Xr.isConcatSpreadable : void 0;
function f8(n) {
  return li(n) || cu(n) || !!(yS && n && n[yS]);
}
function oc(n, e, t, i, r) {
  var s = -1, o = n.length;
  for (t || (t = f8), r || (r = []); ++s < o; ) {
    var a = n[s];
    e > 0 && t(a) ? e > 1 ? oc(a, e - 1, t, i, r) : F1(r, a) : i || (r[r.length] = a);
  }
  return r;
}
function p8(n) {
  var e = n == null ? 0 : n.length;
  return e ? oc(n, 1) : [];
}
function IA(n) {
  return AA(TA(n, void 0, p8), n + "");
}
var Z1 = DA(Object.getPrototypeOf, Object), g8 = "[object Object]", m8 = Function.prototype, v8 = Object.prototype, BA = m8.toString, b8 = v8.hasOwnProperty, y8 = BA.call(Object);
function Ps(n) {
  if (!Yr(n) || Ko(n) != g8)
    return !1;
  var e = Z1(n);
  if (e === null)
    return !0;
  var t = b8.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && BA.call(t) == y8;
}
function q1(n, e, t) {
  var i = -1, r = n.length;
  e < 0 && (e = -e > r ? 0 : r + e), t = t > r ? r : t, t < 0 && (t += r), r = e > t ? 0 : t - e >>> 0, e >>>= 0;
  for (var s = Array(r); ++i < r; )
    s[i] = n[i + e];
  return s;
}
function O8(n, e, t) {
  var i = n.length;
  return t = t === void 0 ? i : t, !e && t >= i ? n : q1(n, e, t);
}
var w8 = "\\ud800-\\udfff", x8 = "\\u0300-\\u036f", S8 = "\\ufe20-\\ufe2f", C8 = "\\u20d0-\\u20ff", k8 = x8 + S8 + C8, P8 = "\\ufe0e\\ufe0f", E8 = "\\u200d", A8 = RegExp("[" + E8 + w8 + k8 + P8 + "]");
function QA(n) {
  return A8.test(n);
}
function $8(n) {
  return n.split("");
}
var zA = "\\ud800-\\udfff", T8 = "\\u0300-\\u036f", _8 = "\\ufe20-\\ufe2f", M8 = "\\u20d0-\\u20ff", R8 = T8 + _8 + M8, N8 = "\\ufe0e\\ufe0f", D8 = "[" + zA + "]", qb = "[" + R8 + "]", Wb = "\\ud83c[\\udffb-\\udfff]", L8 = "(?:" + qb + "|" + Wb + ")", jA = "[^" + zA + "]", VA = "(?:\\ud83c[\\udde6-\\uddff]){2}", FA = "[\\ud800-\\udbff][\\udc00-\\udfff]", I8 = "\\u200d", ZA = L8 + "?", qA = "[" + N8 + "]?", B8 = "(?:" + I8 + "(?:" + [jA, VA, FA].join("|") + ")" + qA + ZA + ")*", Q8 = qA + ZA + B8, z8 = "(?:" + [jA + qb + "?", qb, VA, FA, D8].join("|") + ")", j8 = RegExp(Wb + "(?=" + Wb + ")|" + z8 + Q8, "g");
function V8(n) {
  return n.match(j8) || [];
}
function F8(n) {
  return QA(n) ? V8(n) : $8(n);
}
function WA(n) {
  return function(e) {
    e = Cf(e);
    var t = QA(e) ? F8(e) : void 0, i = t ? t[0] : e.charAt(0), r = t ? O8(t, 1).join("") : e.slice(1);
    return i[n]() + r;
  };
}
var qg = WA("toUpperCase");
function Z8(n) {
  return qg(Cf(n).toLowerCase());
}
function q8(n, e, t, i) {
  var r = -1, s = n == null ? 0 : n.length;
  for (i && s && (t = n[++r]); ++r < s; )
    t = e(t, n[r], r, n);
  return t;
}
function W8(n) {
  return function(e) {
    return n == null ? void 0 : n[e];
  };
}
var H8 = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, X8 = W8(H8);
const Y8 = X8;
var U8 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, G8 = "\\u0300-\\u036f", K8 = "\\ufe20-\\ufe2f", J8 = "\\u20d0-\\u20ff", e6 = G8 + K8 + J8, t6 = "[" + e6 + "]", n6 = RegExp(t6, "g");
function i6(n) {
  return n = Cf(n), n && n.replace(U8, Y8).replace(n6, "");
}
var r6 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function s6(n) {
  return n.match(r6) || [];
}
var o6 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function a6(n) {
  return o6.test(n);
}
var HA = "\\ud800-\\udfff", l6 = "\\u0300-\\u036f", c6 = "\\ufe20-\\ufe2f", u6 = "\\u20d0-\\u20ff", h6 = l6 + c6 + u6, XA = "\\u2700-\\u27bf", YA = "a-z\\xdf-\\xf6\\xf8-\\xff", d6 = "\\xac\\xb1\\xd7\\xf7", f6 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", p6 = "\\u2000-\\u206f", g6 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", UA = "A-Z\\xc0-\\xd6\\xd8-\\xde", m6 = "\\ufe0e\\ufe0f", GA = d6 + f6 + p6 + g6, KA = "['’]", OS = "[" + GA + "]", v6 = "[" + h6 + "]", JA = "\\d+", b6 = "[" + XA + "]", e$ = "[" + YA + "]", t$ = "[^" + HA + GA + JA + XA + YA + UA + "]", y6 = "\\ud83c[\\udffb-\\udfff]", O6 = "(?:" + v6 + "|" + y6 + ")", w6 = "[^" + HA + "]", n$ = "(?:\\ud83c[\\udde6-\\uddff]){2}", i$ = "[\\ud800-\\udbff][\\udc00-\\udfff]", Tc = "[" + UA + "]", x6 = "\\u200d", wS = "(?:" + e$ + "|" + t$ + ")", S6 = "(?:" + Tc + "|" + t$ + ")", xS = "(?:" + KA + "(?:d|ll|m|re|s|t|ve))?", SS = "(?:" + KA + "(?:D|LL|M|RE|S|T|VE))?", r$ = O6 + "?", s$ = "[" + m6 + "]?", C6 = "(?:" + x6 + "(?:" + [w6, n$, i$].join("|") + ")" + s$ + r$ + ")*", k6 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", P6 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", E6 = s$ + r$ + C6, A6 = "(?:" + [b6, n$, i$].join("|") + ")" + E6, $6 = RegExp([
  Tc + "?" + e$ + "+" + xS + "(?=" + [OS, Tc, "$"].join("|") + ")",
  S6 + "+" + SS + "(?=" + [OS, Tc + wS, "$"].join("|") + ")",
  Tc + "?" + wS + "+" + xS,
  Tc + "+" + SS,
  P6,
  k6,
  JA,
  A6
].join("|"), "g");
function T6(n) {
  return n.match($6) || [];
}
function _6(n, e, t) {
  return n = Cf(n), e = t ? void 0 : e, e === void 0 ? a6(n) ? T6(n) : s6(n) : n.match(e) || [];
}
var M6 = "['’]", R6 = RegExp(M6, "g");
function W1(n) {
  return function(e) {
    return q8(_6(i6(e).replace(R6, "")), n, "");
  };
}
var uv = W1(function(n, e, t) {
  return e = e.toLowerCase(), n + (t ? Z8(e) : e);
});
function _d() {
  if (!arguments.length)
    return [];
  var n = arguments[0];
  return li(n) ? n : [n];
}
var N6 = Math.ceil, D6 = Math.max;
function QGe(n, e, t) {
  (t ? Ad(n, e, t) : e === void 0) ? e = 1 : e = D6(I1(e), 0);
  var i = n == null ? 0 : n.length;
  if (!i || e < 1)
    return [];
  for (var r = 0, s = 0, o = Array(N6(i / e)); r < i; )
    o[s++] = q1(n, r, r += e);
  return o;
}
function L6(n, e, t) {
  return n === n && (t !== void 0 && (n = n <= t ? n : t), e !== void 0 && (n = n >= e ? n : e)), n;
}
function rr(n, e, t) {
  return t === void 0 && (t = e, e = void 0), t !== void 0 && (t = Vc(t), t = t === t ? t : 0), e !== void 0 && (e = Vc(e), e = e === e ? e : 0), L6(Vc(n), e, t);
}
function I6() {
  this.__data__ = new Jo(), this.size = 0;
}
function B6(n) {
  var e = this.__data__, t = e.delete(n);
  return this.size = e.size, t;
}
function Q6(n) {
  return this.__data__.get(n);
}
function z6(n) {
  return this.__data__.has(n);
}
var j6 = 200;
function V6(n, e) {
  var t = this.__data__;
  if (t instanceof Jo) {
    var i = t.__data__;
    if (!Td || i.length < j6 - 1)
      return i.push([n, e]), this.size = ++t.size, this;
    t = this.__data__ = new ea(i);
  }
  return t.set(n, e), this.size = t.size, this;
}
function bs(n) {
  var e = this.__data__ = new Jo(n);
  this.size = e.size;
}
bs.prototype.clear = I6;
bs.prototype.delete = B6;
bs.prototype.get = Q6;
bs.prototype.has = z6;
bs.prototype.set = V6;
function F6(n, e) {
  return n && sc(e, th(e), n);
}
function Z6(n, e) {
  return n && sc(e, nh(e), n);
}
var o$ = typeof exports == "object" && exports && !exports.nodeType && exports, CS = o$ && typeof module == "object" && module && !module.nodeType && module, q6 = CS && CS.exports === o$, kS = q6 ? ks.Buffer : void 0, PS = kS ? kS.allocUnsafe : void 0;
function a$(n, e) {
  if (e)
    return n.slice();
  var t = n.length, i = PS ? PS(t) : new n.constructor(t);
  return n.copy(i), i;
}
function W6(n, e) {
  for (var t = -1, i = n == null ? 0 : n.length, r = 0, s = []; ++t < i; ) {
    var o = n[t];
    e(o, t, n) && (s[r++] = o);
  }
  return s;
}
function l$() {
  return [];
}
var H6 = Object.prototype, X6 = H6.propertyIsEnumerable, ES = Object.getOwnPropertySymbols, H1 = ES ? function(n) {
  return n == null ? [] : (n = Object(n), W6(ES(n), function(e) {
    return X6.call(n, e);
  }));
} : l$;
function Y6(n, e) {
  return sc(n, H1(n), e);
}
var U6 = Object.getOwnPropertySymbols, c$ = U6 ? function(n) {
  for (var e = []; n; )
    F1(e, H1(n)), n = Z1(n);
  return e;
} : l$;
function G6(n, e) {
  return sc(n, c$(n), e);
}
function u$(n, e, t) {
  var i = e(n);
  return li(n) ? i : F1(i, t(n));
}
function Hb(n) {
  return u$(n, th, H1);
}
function h$(n) {
  return u$(n, nh, c$);
}
var Xb = rc(ks, "DataView"), Yb = rc(ks, "Promise"), Fc = rc(ks, "Set"), AS = "[object Map]", K6 = "[object Object]", $S = "[object Promise]", TS = "[object Set]", _S = "[object WeakMap]", MS = "[object DataView]", J6 = ic(Xb), eB = ic(Td), tB = ic(Yb), nB = ic(Fc), iB = ic(Zb), dl = Ko;
(Xb && dl(new Xb(new ArrayBuffer(1))) != MS || Td && dl(new Td()) != AS || Yb && dl(Yb.resolve()) != $S || Fc && dl(new Fc()) != TS || Zb && dl(new Zb()) != _S) && (dl = function(n) {
  var e = Ko(n), t = e == K6 ? n.constructor : void 0, i = t ? ic(t) : "";
  if (i)
    switch (i) {
      case J6:
        return MS;
      case eB:
        return AS;
      case tB:
        return $S;
      case nB:
        return TS;
      case iB:
        return _S;
    }
  return e;
});
const du = dl;
var rB = Object.prototype, sB = rB.hasOwnProperty;
function oB(n) {
  var e = n.length, t = new n.constructor(e);
  return e && typeof n[0] == "string" && sB.call(n, "index") && (t.index = n.index, t.input = n.input), t;
}
var Wg = ks.Uint8Array;
function X1(n) {
  var e = new n.constructor(n.byteLength);
  return new Wg(e).set(new Wg(n)), e;
}
function aB(n, e) {
  var t = e ? X1(n.buffer) : n.buffer;
  return new n.constructor(t, n.byteOffset, n.byteLength);
}
var lB = /\w*$/;
function cB(n) {
  var e = new n.constructor(n.source, lB.exec(n));
  return e.lastIndex = n.lastIndex, e;
}
var RS = Xr ? Xr.prototype : void 0, NS = RS ? RS.valueOf : void 0;
function uB(n) {
  return NS ? Object(NS.call(n)) : {};
}
function d$(n, e) {
  var t = e ? X1(n.buffer) : n.buffer;
  return new n.constructor(t, n.byteOffset, n.length);
}
var hB = "[object Boolean]", dB = "[object Date]", fB = "[object Map]", pB = "[object Number]", gB = "[object RegExp]", mB = "[object Set]", vB = "[object String]", bB = "[object Symbol]", yB = "[object ArrayBuffer]", OB = "[object DataView]", wB = "[object Float32Array]", xB = "[object Float64Array]", SB = "[object Int8Array]", CB = "[object Int16Array]", kB = "[object Int32Array]", PB = "[object Uint8Array]", EB = "[object Uint8ClampedArray]", AB = "[object Uint16Array]", $B = "[object Uint32Array]";
function TB(n, e, t) {
  var i = n.constructor;
  switch (e) {
    case yB:
      return X1(n);
    case hB:
    case dB:
      return new i(+n);
    case OB:
      return aB(n, t);
    case wB:
    case xB:
    case SB:
    case CB:
    case kB:
    case PB:
    case EB:
    case AB:
    case $B:
      return d$(n, t);
    case fB:
      return new i();
    case pB:
    case vB:
      return new i(n);
    case gB:
      return cB(n);
    case mB:
      return new i();
    case bB:
      return uB(n);
  }
}
function f$(n) {
  return typeof n.constructor == "function" && !xf(n) ? SI(Z1(n)) : {};
}
var _B = "[object Map]";
function MB(n) {
  return Yr(n) && du(n) == _B;
}
var DS = hu && hu.isMap, RB = DS ? Sf(DS) : MB, NB = "[object Set]";
function DB(n) {
  return Yr(n) && du(n) == NB;
}
var LS = hu && hu.isSet, LB = LS ? Sf(LS) : DB, IB = 1, BB = 2, QB = 4, p$ = "[object Arguments]", zB = "[object Array]", jB = "[object Boolean]", VB = "[object Date]", FB = "[object Error]", g$ = "[object Function]", ZB = "[object GeneratorFunction]", qB = "[object Map]", WB = "[object Number]", m$ = "[object Object]", HB = "[object RegExp]", XB = "[object Set]", YB = "[object String]", UB = "[object Symbol]", GB = "[object WeakMap]", KB = "[object ArrayBuffer]", JB = "[object DataView]", eQ = "[object Float32Array]", tQ = "[object Float64Array]", nQ = "[object Int8Array]", iQ = "[object Int16Array]", rQ = "[object Int32Array]", sQ = "[object Uint8Array]", oQ = "[object Uint8ClampedArray]", aQ = "[object Uint16Array]", lQ = "[object Uint32Array]", Wt = {};
Wt[p$] = Wt[zB] = Wt[KB] = Wt[JB] = Wt[jB] = Wt[VB] = Wt[eQ] = Wt[tQ] = Wt[nQ] = Wt[iQ] = Wt[rQ] = Wt[qB] = Wt[WB] = Wt[m$] = Wt[HB] = Wt[XB] = Wt[YB] = Wt[UB] = Wt[sQ] = Wt[oQ] = Wt[aQ] = Wt[lQ] = !0;
Wt[FB] = Wt[g$] = Wt[GB] = !1;
function Zc(n, e, t, i, r, s) {
  var o, a = e & IB, l = e & BB, c = e & QB;
  if (t && (o = r ? t(n, i, r, s) : t(n)), o !== void 0)
    return o;
  if (!wn(n))
    return n;
  var u = li(n);
  if (u) {
    if (o = oB(n), !a)
      return EA(n, o);
  } else {
    var h = du(n), d = h == g$ || h == ZB;
    if (uu(n))
      return a$(n, a);
    if (h == m$ || h == p$ || d && !r) {
      if (o = l || d ? {} : f$(n), !a)
        return l ? G6(n, Z6(o, n)) : Y6(n, F6(o, n));
    } else {
      if (!Wt[h])
        return r ? n : {};
      o = TB(n, h, a);
    }
  }
  s || (s = new bs());
  var f = s.get(n);
  if (f)
    return f;
  s.set(n, o), LB(n) ? n.forEach(function(m) {
    o.add(Zc(m, e, t, m, n, s));
  }) : RB(n) && n.forEach(function(m, v) {
    o.set(v, Zc(m, e, t, v, n, s));
  });
  var p = c ? l ? h$ : Hb : l ? nh : th, g = u ? void 0 : p(n);
  return MI(g || n, function(m, v) {
    g && (v = m, m = n[v]), sv(o, v, Zc(m, e, t, v, n, s));
  }), o;
}
var cQ = 4;
function Md(n) {
  return Zc(n, cQ);
}
var uQ = 1, hQ = 4;
function Bt(n) {
  return Zc(n, uQ | hQ);
}
var dQ = "__lodash_hash_undefined__";
function fQ(n) {
  return this.__data__.set(n, dQ), this;
}
function pQ(n) {
  return this.__data__.has(n);
}
function fu(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.__data__ = new ea(); ++e < t; )
    this.add(n[e]);
}
fu.prototype.add = fu.prototype.push = fQ;
fu.prototype.has = pQ;
function gQ(n, e) {
  for (var t = -1, i = n == null ? 0 : n.length; ++t < i; )
    if (e(n[t], t, n))
      return !0;
  return !1;
}
function Y1(n, e) {
  return n.has(e);
}
var mQ = 1, vQ = 2;
function v$(n, e, t, i, r, s) {
  var o = t & mQ, a = n.length, l = e.length;
  if (a != l && !(o && l > a))
    return !1;
  var c = s.get(n), u = s.get(e);
  if (c && u)
    return c == e && u == n;
  var h = -1, d = !0, f = t & vQ ? new fu() : void 0;
  for (s.set(n, e), s.set(e, n); ++h < a; ) {
    var p = n[h], g = e[h];
    if (i)
      var m = o ? i(g, p, h, e, n, s) : i(p, g, h, n, e, s);
    if (m !== void 0) {
      if (m)
        continue;
      d = !1;
      break;
    }
    if (f) {
      if (!gQ(e, function(v, y) {
        if (!Y1(f, y) && (p === v || r(p, v, t, i, s)))
          return f.push(y);
      })) {
        d = !1;
        break;
      }
    } else if (!(p === g || r(p, g, t, i, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(n), s.delete(e), d;
}
function bQ(n) {
  var e = -1, t = Array(n.size);
  return n.forEach(function(i, r) {
    t[++e] = [r, i];
  }), t;
}
function U1(n) {
  var e = -1, t = Array(n.size);
  return n.forEach(function(i) {
    t[++e] = i;
  }), t;
}
var yQ = 1, OQ = 2, wQ = "[object Boolean]", xQ = "[object Date]", SQ = "[object Error]", CQ = "[object Map]", kQ = "[object Number]", PQ = "[object RegExp]", EQ = "[object Set]", AQ = "[object String]", $Q = "[object Symbol]", TQ = "[object ArrayBuffer]", _Q = "[object DataView]", IS = Xr ? Xr.prototype : void 0, b0 = IS ? IS.valueOf : void 0;
function MQ(n, e, t, i, r, s, o) {
  switch (t) {
    case _Q:
      if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
        return !1;
      n = n.buffer, e = e.buffer;
    case TQ:
      return !(n.byteLength != e.byteLength || !s(new Wg(n), new Wg(e)));
    case wQ:
    case xQ:
    case kQ:
      return Ju(+n, +e);
    case SQ:
      return n.name == e.name && n.message == e.message;
    case PQ:
    case AQ:
      return n == e + "";
    case CQ:
      var a = bQ;
    case EQ:
      var l = i & yQ;
      if (a || (a = U1), n.size != e.size && !l)
        return !1;
      var c = o.get(n);
      if (c)
        return c == e;
      i |= OQ, o.set(n, e);
      var u = v$(a(n), a(e), i, r, s, o);
      return o.delete(n), u;
    case $Q:
      if (b0)
        return b0.call(n) == b0.call(e);
  }
  return !1;
}
var RQ = 1, NQ = Object.prototype, DQ = NQ.hasOwnProperty;
function LQ(n, e, t, i, r, s) {
  var o = t & RQ, a = Hb(n), l = a.length, c = Hb(e), u = c.length;
  if (l != u && !o)
    return !1;
  for (var h = l; h--; ) {
    var d = a[h];
    if (!(o ? d in e : DQ.call(e, d)))
      return !1;
  }
  var f = s.get(n), p = s.get(e);
  if (f && p)
    return f == e && p == n;
  var g = !0;
  s.set(n, e), s.set(e, n);
  for (var m = o; ++h < l; ) {
    d = a[h];
    var v = n[d], y = e[d];
    if (i)
      var b = o ? i(y, v, d, e, n, s) : i(v, y, d, n, e, s);
    if (!(b === void 0 ? v === y || r(v, y, t, i, s) : b)) {
      g = !1;
      break;
    }
    m || (m = d == "constructor");
  }
  if (g && !m) {
    var w = n.constructor, x = e.constructor;
    w != x && "constructor" in n && "constructor" in e && !(typeof w == "function" && w instanceof w && typeof x == "function" && x instanceof x) && (g = !1);
  }
  return s.delete(n), s.delete(e), g;
}
var IQ = 1, BS = "[object Arguments]", QS = "[object Array]", tp = "[object Object]", BQ = Object.prototype, zS = BQ.hasOwnProperty;
function QQ(n, e, t, i, r, s) {
  var o = li(n), a = li(e), l = o ? QS : du(n), c = a ? QS : du(e);
  l = l == BS ? tp : l, c = c == BS ? tp : c;
  var u = l == tp, h = c == tp, d = l == c;
  if (d && uu(n)) {
    if (!uu(e))
      return !1;
    o = !0, u = !1;
  }
  if (d && !u)
    return s || (s = new bs()), o || ov(n) ? v$(n, e, t, i, r, s) : MQ(n, e, l, t, i, r, s);
  if (!(t & IQ)) {
    var f = u && zS.call(n, "__wrapped__"), p = h && zS.call(e, "__wrapped__");
    if (f || p) {
      var g = f ? n.value() : n, m = p ? e.value() : e;
      return s || (s = new bs()), r(g, m, t, i, s);
    }
  }
  return d ? (s || (s = new bs()), LQ(n, e, t, i, r, s)) : !1;
}
function hv(n, e, t, i, r) {
  return n === e ? !0 : n == null || e == null || !Yr(n) && !Yr(e) ? n !== n && e !== e : QQ(n, e, t, i, hv, r);
}
var zQ = 1, jQ = 2;
function VQ(n, e, t, i) {
  var r = t.length, s = r, o = !i;
  if (n == null)
    return !s;
  for (n = Object(n); r--; ) {
    var a = t[r];
    if (o && a[2] ? a[1] !== n[a[0]] : !(a[0] in n))
      return !1;
  }
  for (; ++r < s; ) {
    a = t[r];
    var l = a[0], c = n[l], u = a[1];
    if (o && a[2]) {
      if (c === void 0 && !(l in n))
        return !1;
    } else {
      var h = new bs();
      if (i)
        var d = i(c, u, l, n, e, h);
      if (!(d === void 0 ? hv(u, c, zQ | jQ, i, h) : d))
        return !1;
    }
  }
  return !0;
}
function b$(n) {
  return n === n && !wn(n);
}
function FQ(n) {
  for (var e = th(n), t = e.length; t--; ) {
    var i = e[t], r = n[i];
    e[t] = [i, r, b$(r)];
  }
  return e;
}
function y$(n, e) {
  return function(t) {
    return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t));
  };
}
function ZQ(n) {
  var e = FQ(n);
  return e.length == 1 && e[0][2] ? y$(e[0][0], e[0][1]) : function(t) {
    return t === n || VQ(t, n, e);
  };
}
function qQ(n, e) {
  return n != null && e in Object(n);
}
function O$(n, e, t) {
  e = ih(e, n);
  for (var i = -1, r = e.length, s = !1; ++i < r; ) {
    var o = rh(e[i]);
    if (!(s = n != null && t(n, o)))
      break;
    n = n[o];
  }
  return s || ++i != r ? s : (r = n == null ? 0 : n.length, !!r && z1(r) && iv(o, r) && (li(n) || cu(n)));
}
function w$(n, e) {
  return n != null && O$(n, e, qQ);
}
var WQ = 1, HQ = 2;
function XQ(n, e) {
  return V1(n) && b$(e) ? y$(rh(n), e) : function(t) {
    var i = on(t, n);
    return i === void 0 && i === e ? w$(t, n) : hv(e, i, WQ | HQ);
  };
}
function YQ(n) {
  return function(e) {
    return e == null ? void 0 : e[n];
  };
}
function UQ(n) {
  return function(e) {
    return kf(e, n);
  };
}
function GQ(n) {
  return V1(n) ? YQ(rh(n)) : UQ(n);
}
function sh(n) {
  return typeof n == "function" ? n : n == null ? Ku : typeof n == "object" ? li(n) ? XQ(n[0], n[1]) : ZQ(n) : GQ(n);
}
function KQ(n, e, t, i) {
  for (var r = -1, s = n == null ? 0 : n.length; ++r < s; ) {
    var o = n[r];
    e(i, o, t(o), n);
  }
  return i;
}
function JQ(n) {
  return function(e, t, i) {
    for (var r = -1, s = Object(e), o = i(e), a = o.length; a--; ) {
      var l = o[n ? a : ++r];
      if (t(s[l], l, s) === !1)
        break;
    }
    return e;
  };
}
var x$ = JQ();
function ez(n, e) {
  return n && x$(n, e, th);
}
function tz(n, e) {
  return function(t, i) {
    if (t == null)
      return t;
    if (!Ua(t))
      return n(t, i);
    for (var r = t.length, s = e ? r : -1, o = Object(t); (e ? s-- : ++s < r) && i(o[s], s, o) !== !1; )
      ;
    return t;
  };
}
var S$ = tz(ez);
function nz(n, e, t, i) {
  return S$(n, function(r, s, o) {
    e(i, r, t(r), o);
  }), i;
}
function iz(n, e) {
  return function(t, i) {
    var r = li(t) ? KQ : nz, s = e ? e() : {};
    return r(t, n, sh(i), s);
  };
}
var y0 = function() {
  return ks.Date.now();
}, rz = "Expected a function", sz = Math.max, oz = Math.min;
function zo(n, e, t) {
  var i, r, s, o, a, l, c = 0, u = !1, h = !1, d = !0;
  if (typeof n != "function")
    throw new TypeError(rz);
  e = Vc(e) || 0, wn(t) && (u = !!t.leading, h = "maxWait" in t, s = h ? sz(Vc(t.maxWait) || 0, e) : s, d = "trailing" in t ? !!t.trailing : d);
  function f(S) {
    var C = i, k = r;
    return i = r = void 0, c = S, o = n.apply(k, C), o;
  }
  function p(S) {
    return c = S, a = setTimeout(v, e), u ? f(S) : o;
  }
  function g(S) {
    var C = S - l, k = S - c, E = e - C;
    return h ? oz(E, s - k) : E;
  }
  function m(S) {
    var C = S - l, k = S - c;
    return l === void 0 || C >= e || C < 0 || h && k >= s;
  }
  function v() {
    var S = y0();
    if (m(S))
      return y(S);
    a = setTimeout(v, g(S));
  }
  function y(S) {
    return a = void 0, d && i ? f(S) : (i = r = void 0, o);
  }
  function b() {
    a !== void 0 && clearTimeout(a), c = 0, i = l = r = a = void 0;
  }
  function w() {
    return a === void 0 ? o : y(y0());
  }
  function x() {
    var S = y0(), C = m(S);
    if (i = arguments, r = this, l = S, C) {
      if (a === void 0)
        return p(l);
      if (h)
        return clearTimeout(a), a = setTimeout(v, e), f(l);
    }
    return a === void 0 && (a = setTimeout(v, e)), o;
  }
  return x.cancel = b, x.flush = w, x;
}
var C$ = Object.prototype, az = C$.hasOwnProperty, lz = eh(function(n, e) {
  n = Object(n);
  var t = -1, i = e.length, r = i > 2 ? e[2] : void 0;
  for (r && Ad(e[0], e[1], r) && (i = 1); ++t < i; )
    for (var s = e[t], o = nh(s), a = -1, l = o.length; ++a < l; ) {
      var c = o[a], u = n[c];
      (u === void 0 || Ju(u, C$[c]) && !az.call(n, c)) && (n[c] = s[c]);
    }
  return n;
});
function Ub(n, e, t) {
  (t !== void 0 && !Ju(n[e], t) || t === void 0 && !(e in n)) && rv(n, e, t);
}
function Hg(n) {
  return Yr(n) && Ua(n);
}
function Gb(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
function cz(n) {
  return sc(n, nh(n));
}
function uz(n, e, t, i, r, s, o) {
  var a = Gb(n, t), l = Gb(e, t), c = o.get(l);
  if (c) {
    Ub(n, t, c);
    return;
  }
  var u = s ? s(a, l, t + "", n, e, o) : void 0, h = u === void 0;
  if (h) {
    var d = li(l), f = !d && uu(l), p = !d && !f && ov(l);
    u = l, d || f || p ? li(a) ? u = a : Hg(a) ? u = EA(a) : f ? (h = !1, u = a$(l, !0)) : p ? (h = !1, u = d$(l, !0)) : u = [] : Ps(l) || cu(l) ? (u = a, cu(a) ? u = cz(a) : (!wn(a) || B1(a)) && (u = f$(l))) : h = !1;
  }
  h && (o.set(l, u), r(u, l, i, s, o), o.delete(l)), Ub(n, t, u);
}
function dv(n, e, t, i, r) {
  n !== e && x$(e, function(s, o) {
    if (r || (r = new bs()), wn(s))
      uz(n, e, o, t, dv, i, r);
    else {
      var a = i ? i(Gb(n, o), s, o + "", n, e, r) : void 0;
      a === void 0 && (a = s), Ub(n, o, a);
    }
  }, nh);
}
function k$(n, e, t, i, r, s) {
  return wn(n) && wn(e) && (s.set(e, n), dv(n, e, void 0, k$, s), s.delete(e)), n;
}
var hz = j1(function(n, e, t, i) {
  dv(n, e, t, i);
});
const dz = hz;
var P$ = eh(function(n) {
  return n.push(void 0, k$), PA(dz, void 0, n);
});
function E$(n, e, t) {
  for (var i = -1, r = n == null ? 0 : n.length; ++i < r; )
    if (t(e, n[i]))
      return !0;
  return !1;
}
var fz = 200;
function pz(n, e, t, i) {
  var r = -1, s = $A, o = !0, a = n.length, l = [], c = e.length;
  if (!a)
    return l;
  t && (e = Dl(e, Sf(t))), i ? (s = E$, o = !1) : e.length >= fz && (s = Y1, o = !1, e = new fu(e));
  e:
    for (; ++r < a; ) {
      var u = n[r], h = t == null ? u : t(u);
      if (u = i || u !== 0 ? u : 0, o && h === h) {
        for (var d = c; d--; )
          if (e[d] === h)
            continue e;
        l.push(u);
      } else
        s(e, h, i) || l.push(u);
    }
  return l;
}
var gz = eh(function(n, e) {
  return Hg(n) ? pz(n, oc(e, 1, Hg, !0)) : [];
});
function mz(n) {
  var e = n == null ? 0 : n.length;
  return e ? n[e - 1] : void 0;
}
var vz = Math.max;
function zGe(n, e, t) {
  var i = n == null ? 0 : n.length;
  if (!i)
    return -1;
  var r = t == null ? 0 : I1(t);
  return r < 0 && (r = vz(i + r, 0)), Q1(n, sh(e), r);
}
var bz = Math.max, yz = Math.min;
function A$(n, e, t) {
  var i = n == null ? 0 : n.length;
  if (!i)
    return -1;
  var r = i - 1;
  return t !== void 0 && (r = I1(t), r = t < 0 ? bz(i + r, 0) : yz(r, i - 1)), Q1(n, sh(e), r, !0);
}
function $$(n, e) {
  var t = -1, i = Ua(n) ? Array(n.length) : [];
  return S$(n, function(r, s, o) {
    i[++t] = e(r, s, o);
  }), i;
}
function Oz(n, e) {
  var t = li(n) ? Dl : $$;
  return t(n, sh(e));
}
function wz(n, e) {
  return oc(Oz(n, e), 1);
}
var xz = 1 / 0;
function Sz(n) {
  var e = n == null ? 0 : n.length;
  return e ? oc(n, xz) : [];
}
function Xg(n) {
  for (var e = -1, t = n == null ? 0 : n.length, i = {}; ++e < t; ) {
    var r = n[e];
    i[r[0]] = r[1];
  }
  return i;
}
var Cz = Object.prototype, kz = Cz.hasOwnProperty, jS = iz(function(n, e, t) {
  kz.call(n, t) ? n[t].push(e) : rv(n, t, [e]);
});
function Pz(n, e) {
  return n > e;
}
var Ez = Object.prototype, Az = Ez.hasOwnProperty;
function $z(n, e) {
  return n != null && Az.call(n, e);
}
function np(n, e) {
  return n != null && O$(n, e, $z);
}
function Tz(n, e) {
  return e.length < 2 ? n : kf(n, q1(e, 0, -1));
}
var _z = "[object Boolean]";
function jGe(n) {
  return n === !0 || n === !1 || Yr(n) && Ko(n) == _z;
}
var Mz = "[object Map]", Rz = "[object Set]", Nz = Object.prototype, Dz = Nz.hasOwnProperty;
function T$(n) {
  if (n == null)
    return !0;
  if (Ua(n) && (li(n) || typeof n == "string" || typeof n.splice == "function" || uu(n) || ov(n) || cu(n)))
    return !n.length;
  var e = du(n);
  if (e == Mz || e == Rz)
    return !n.size;
  if (xf(n))
    return !LA(n).length;
  for (var t in n)
    if (Dz.call(n, t))
      return !1;
  return !0;
}
function cn(n, e) {
  return hv(n, e);
}
var Lz = "[object Number]";
function VS(n) {
  return typeof n == "number" || Yr(n) && Ko(n) == Lz;
}
function Ni(n) {
  return n == null;
}
function _$(n) {
  return n === void 0;
}
var Iz = W1(function(n, e, t) {
  return n + (t ? "-" : "") + e.toLowerCase();
});
const VGe = Iz;
var Bz = WA("toLowerCase");
function Qz(n, e, t) {
  for (var i = -1, r = n.length; ++i < r; ) {
    var s = n[i], o = e(s);
    if (o != null && (a === void 0 ? o === o && !uo(o) : t(o, a)))
      var a = o, l = s;
  }
  return l;
}
function zz(n) {
  return n && n.length ? Qz(n, Ku, Pz) : void 0;
}
var On = j1(function(n, e, t) {
  dv(n, e, t);
});
function M$(n, e) {
  return e = ih(e, n), n = Tz(n, e), n == null || delete n[rh(mz(e))];
}
function jz(n) {
  return Ps(n) ? void 0 : n;
}
var Vz = 1, Fz = 2, Zz = 4, FGe = IA(function(n, e) {
  var t = {};
  if (n == null)
    return t;
  var i = !1;
  e = Dl(e, function(s) {
    return s = ih(s, n), i || (i = s.length > 1), s;
  }), sc(n, h$(n), t), i && (t = Zc(t, Vz | Fz | Zz, jz));
  for (var r = e.length; r--; )
    M$(t, e[r]);
  return t;
});
function R$(n, e, t, i) {
  if (!wn(n))
    return n;
  e = ih(e, n);
  for (var r = -1, s = e.length, o = s - 1, a = n; a != null && ++r < s; ) {
    var l = rh(e[r]), c = t;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return n;
    if (r != o) {
      var u = a[l];
      c = i ? i(u, l, a) : void 0, c === void 0 && (c = wn(u) ? u : iv(e[r + 1]) ? [] : {});
    }
    sv(a, l, c), a = a[l];
  }
  return n;
}
function qz(n, e, t) {
  for (var i = -1, r = e.length, s = {}; ++i < r; ) {
    var o = e[i], a = kf(n, o);
    t(a, o) && R$(s, ih(o, n), a);
  }
  return s;
}
function Wz(n, e) {
  var t = n.length;
  for (n.sort(e); t--; )
    n[t] = n[t].value;
  return n;
}
function Hz(n, e) {
  if (n !== e) {
    var t = n !== void 0, i = n === null, r = n === n, s = uo(n), o = e !== void 0, a = e === null, l = e === e, c = uo(e);
    if (!a && !c && !s && n > e || s && o && l && !a && !c || i && o && l || !t && l || !r)
      return 1;
    if (!i && !s && !c && n < e || c && t && r && !i && !s || a && t && r || !o && r || !l)
      return -1;
  }
  return 0;
}
function Xz(n, e, t) {
  for (var i = -1, r = n.criteria, s = e.criteria, o = r.length, a = t.length; ++i < o; ) {
    var l = Hz(r[i], s[i]);
    if (l) {
      if (i >= a)
        return l;
      var c = t[i];
      return l * (c == "desc" ? -1 : 1);
    }
  }
  return n.index - e.index;
}
function Yz(n, e, t) {
  e.length ? e = Dl(e, function(s) {
    return li(s) ? function(o) {
      return kf(o, s.length === 1 ? s[0] : s);
    } : s;
  }) : e = [Ku];
  var i = -1;
  e = Dl(e, Sf(sh));
  var r = $$(n, function(s, o, a) {
    var l = Dl(e, function(c) {
      return c(s);
    });
    return { criteria: l, index: ++i, value: s };
  });
  return Wz(r, function(s, o) {
    return Xz(s, o, t);
  });
}
function Uz(n, e) {
  return qz(n, e, function(t, i) {
    return w$(n, i);
  });
}
var Kb = IA(function(n, e) {
  return n == null ? {} : Uz(n, e);
});
function Gz(n, e, t) {
  return n == null ? n : R$(n, e, t);
}
var N$ = eh(function(n, e) {
  if (n == null)
    return [];
  var t = e.length;
  return t > 1 && Ad(n, e[0], e[1]) ? e = [] : t > 2 && Ad(e[0], e[1], e[2]) && (e = [e[0]]), Yz(n, oc(e, 1), []);
}), Kz = 4294967295, Jz = Kz - 1, ej = Math.floor, tj = Math.min;
function D$(n, e, t, i) {
  var r = 0, s = n == null ? 0 : n.length;
  if (s === 0)
    return 0;
  e = t(e);
  for (var o = e !== e, a = e === null, l = uo(e), c = e === void 0; r < s; ) {
    var u = ej((r + s) / 2), h = t(n[u]), d = h !== void 0, f = h === null, p = h === h, g = uo(h);
    if (o)
      var m = i || p;
    else
      c ? m = p && (i || d) : a ? m = p && d && (i || !f) : l ? m = p && d && !f && (i || !g) : f || g ? m = !1 : m = i ? h <= e : h < e;
    m ? r = u + 1 : s = u;
  }
  return tj(s, Jz);
}
var nj = 4294967295, ij = nj >>> 1;
function rj(n, e, t) {
  var i = 0, r = n == null ? i : n.length;
  if (typeof e == "number" && e === e && r <= ij) {
    for (; i < r; ) {
      var s = i + r >>> 1, o = n[s];
      o !== null && !uo(o) && (t ? o <= e : o < e) ? i = s + 1 : r = s;
    }
    return r;
  }
  return D$(n, e, Ku, t);
}
function sj(n, e) {
  return rj(n, e);
}
function oj(n, e, t) {
  return D$(n, e, sh(t));
}
var aj = W1(function(n, e, t) {
  return n + (t ? " " : "") + qg(e);
}), lj = "Expected a function";
function cj(n, e, t) {
  var i = !0, r = !0;
  if (typeof n != "function")
    throw new TypeError(lj);
  return wn(t) && (i = "leading" in t ? !!t.leading : i, r = "trailing" in t ? !!t.trailing : r), zo(n, e, {
    leading: i,
    maxWait: e,
    trailing: r
  });
}
var uj = 1 / 0, hj = Fc && 1 / U1(new Fc([, -0]))[1] == uj ? function(n) {
  return new Fc(n);
} : CI, dj = 200;
function L$(n, e, t) {
  var i = -1, r = $A, s = n.length, o = !0, a = [], l = a;
  if (t)
    o = !1, r = E$;
  else if (s >= dj) {
    var c = e ? null : hj(n);
    if (c)
      return U1(c);
    o = !1, r = Y1, l = new fu();
  } else
    l = e ? [] : a;
  e:
    for (; ++i < s; ) {
      var u = n[i], h = e ? e(u) : u;
      if (u = t || u !== 0 ? u : 0, o && h === h) {
        for (var d = l.length; d--; )
          if (l[d] === h)
            continue e;
        e && l.push(h), a.push(u);
      } else
        r(l, h, t) || (l !== a && l.push(h), a.push(u));
    }
  return a;
}
var FS = eh(function(n) {
  return L$(oc(n, 1, Hg, !0));
});
function I$(n) {
  return n && n.length ? L$(n) : [];
}
function ZGe(n, e) {
  return n == null ? !0 : M$(n, e);
}
/*! Element Plus Icons Vue v2.3.1 */
var fj = /* @__PURE__ */ F({
  name: "ArrowDown",
  __name: "arrow-down",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
      })
    ]));
  }
}), oh = fj, pj = /* @__PURE__ */ F({
  name: "ArrowLeft",
  __name: "arrow-left",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), G1 = pj, gj = /* @__PURE__ */ F({
  name: "ArrowRight",
  __name: "arrow-right",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), ac = gj, mj = /* @__PURE__ */ F({
  name: "ArrowUp",
  __name: "arrow-up",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
      })
    ]));
  }
}), B$ = mj, vj = /* @__PURE__ */ F({
  name: "Bottom",
  __name: "bottom",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M544 805.888V168a32 32 0 1 0-64 0v637.888L246.656 557.952a30.72 30.72 0 0 0-45.312 0 35.52 35.52 0 0 0 0 48.064l288 306.048a30.72 30.72 0 0 0 45.312 0l288-306.048a35.52 35.52 0 0 0 0-48 30.72 30.72 0 0 0-45.312 0L544 805.824z"
      })
    ]));
  }
}), qGe = vj, bj = /* @__PURE__ */ F({
  name: "CaretRight",
  __name: "caret-right",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M384 192v640l384-320.064z"
      })
    ]));
  }
}), yj = bj, Oj = /* @__PURE__ */ F({
  name: "Check",
  __name: "check",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      })
    ]));
  }
}), fv = Oj, wj = /* @__PURE__ */ F({
  name: "CircleCheck",
  __name: "circle-check",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      Z("path", {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
      })
    ]));
  }
}), K1 = wj, xj = /* @__PURE__ */ F({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
}), Q$ = xj, Sj = /* @__PURE__ */ F({
  name: "CircleClose",
  __name: "circle-close",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
      }),
      Z("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), ah = Sj, Cj = /* @__PURE__ */ F({
  name: "Close",
  __name: "close",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
}), jo = Cj, kj = /* @__PURE__ */ F({
  name: "CopyDocument",
  __name: "copy-document",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M768 832a128 128 0 0 1-128 128H192A128 128 0 0 1 64 832V384a128 128 0 0 1 128-128v64a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64z"
      }),
      Z("path", {
        fill: "currentColor",
        d: "M384 128a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64zm0-64h448a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H384a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64"
      })
    ]));
  }
}), WGe = kj, Pj = /* @__PURE__ */ F({
  name: "DArrowLeft",
  __name: "d-arrow-left",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
      })
    ]));
  }
}), Ej = Pj, Aj = /* @__PURE__ */ F({
  name: "DArrowRight",
  __name: "d-arrow-right",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
      })
    ]));
  }
}), $j = Aj, Tj = /* @__PURE__ */ F({
  name: "Delete",
  __name: "delete",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
      })
    ]));
  }
}), _j = Tj, Mj = /* @__PURE__ */ F({
  name: "Document",
  __name: "document",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
      })
    ]));
  }
}), Rj = Mj, Nj = /* @__PURE__ */ F({
  name: "Download",
  __name: "download",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64z"
      })
    ]));
  }
}), HGe = Nj, Dj = /* @__PURE__ */ F({
  name: "Drizzling",
  __name: "drizzling",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m739.328 291.328-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0 0 35.776-380.672zM959.552 480a256 256 0 0 1-256 256h-400A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 959.552 480M288 800h64v64h-64zm192 0h64v64h-64zm-96 96h64v64h-64zm192 0h64v64h-64zm96-96h64v64h-64z"
      })
    ]));
  }
}), XGe = Dj, Lj = /* @__PURE__ */ F({
  name: "Edit",
  __name: "edit",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M832 512a32 32 0 1 1 64 0v352a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h352a32 32 0 0 1 0 64H192v640h640z"
      }),
      Z("path", {
        fill: "currentColor",
        d: "m469.952 554.24 52.8-7.552L847.104 222.4a32 32 0 1 0-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 0 1 0 135.808l-331.84 331.84a32 32 0 0 1-18.112 9.088L436.8 623.68a32 32 0 0 1-36.224-36.224l15.104-105.6a32 32 0 0 1 9.024-18.112l331.904-331.84a96 96 0 0 1 135.744 0z"
      })
    ]));
  }
}), YGe = Lj, Ij = /* @__PURE__ */ F({
  name: "Files",
  __name: "files",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M128 384v448h768V384zm-32-64h832a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32m64-128h704v64H160zm96-128h512v64H256z"
      })
    ]));
  }
}), UGe = Ij, Bj = /* @__PURE__ */ F({
  name: "Filter",
  __name: "filter",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M384 523.392V928a32 32 0 0 0 46.336 28.608l192-96A32 32 0 0 0 640 832V523.392l280.768-343.104a32 32 0 1 0-49.536-40.576l-288 352A32 32 0 0 0 576 512v300.224l-128 64V512a32 32 0 0 0-7.232-20.288L195.52 192H704a32 32 0 1 0 0-64H128a32 32 0 0 0-24.768 52.288z"
      })
    ]));
  }
}), GGe = Bj, Qj = /* @__PURE__ */ F({
  name: "Fold",
  __name: "fold",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M896 192H128v128h768zm0 256H384v128h512zm0 256H128v128h768zM320 384 128 512l192 128z"
      })
    ]));
  }
}), KGe = Qj, zj = /* @__PURE__ */ F({
  name: "FullScreen",
  __name: "full-screen",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
      })
    ]));
  }
}), JGe = zj, jj = /* @__PURE__ */ F({
  name: "Help",
  __name: "help",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m759.936 805.248-90.944-91.008A254.912 254.912 0 0 1 512 768a254.912 254.912 0 0 1-156.992-53.76l-90.944 91.008A382.464 382.464 0 0 0 512 896c94.528 0 181.12-34.176 247.936-90.752m45.312-45.312A382.464 382.464 0 0 0 896 512c0-94.528-34.176-181.12-90.752-247.936l-91.008 90.944C747.904 398.4 768 452.864 768 512c0 59.136-20.096 113.6-53.76 156.992l91.008 90.944zm-45.312-541.184A382.464 382.464 0 0 0 512 128c-94.528 0-181.12 34.176-247.936 90.752l90.944 91.008A254.912 254.912 0 0 1 512 256c59.136 0 113.6 20.096 156.992 53.76l90.944-91.008zm-541.184 45.312A382.464 382.464 0 0 0 128 512c0 94.528 34.176 181.12 90.752 247.936l91.008-90.944A254.912 254.912 0 0 1 256 512c0-59.136 20.096-113.6 53.76-156.992zm417.28 394.496a194.56 194.56 0 0 0 22.528-22.528C686.912 602.56 704 559.232 704 512a191.232 191.232 0 0 0-67.968-146.56A191.296 191.296 0 0 0 512 320a191.232 191.232 0 0 0-146.56 67.968C337.088 421.44 320 464.768 320 512a191.232 191.232 0 0 0 67.968 146.56C421.44 686.912 464.768 704 512 704c47.296 0 90.56-17.088 124.032-45.44zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), eKe = jj, Vj = /* @__PURE__ */ F({
  name: "Hide",
  __name: "hide",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
      }),
      Z("path", {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
      })
    ]));
  }
}), Fj = Vj, Zj = /* @__PURE__ */ F({
  name: "InfoFilled",
  __name: "info-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
}), z$ = Zj, qj = /* @__PURE__ */ F({
  name: "Lightning",
  __name: "lightning",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M288 671.36v64.128A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 736 734.016v-64.768a192 192 0 0 0 3.328-377.92l-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 91.968 70.464 167.36 160.256 175.232z"
      }),
      Z("path", {
        fill: "currentColor",
        d: "M416 736a32 32 0 0 1-27.776-47.872l128-224a32 32 0 1 1 55.552 31.744L471.168 672H608a32 32 0 0 1 27.776 47.872l-128 224a32 32 0 1 1-55.68-31.744L552.96 736z"
      })
    ]));
  }
}), tKe = qj, Wj = /* @__PURE__ */ F({
  name: "Link",
  __name: "link",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M715.648 625.152 670.4 579.904l90.496-90.56c75.008-74.944 85.12-186.368 22.656-248.896-62.528-62.464-173.952-52.352-248.96 22.656L444.16 353.6l-45.248-45.248 90.496-90.496c100.032-99.968 251.968-110.08 339.456-22.656 87.488 87.488 77.312 239.424-22.656 339.456l-90.496 90.496zm-90.496 90.496-90.496 90.496C434.624 906.112 282.688 916.224 195.2 828.8c-87.488-87.488-77.312-239.424 22.656-339.456l90.496-90.496 45.248 45.248-90.496 90.56c-75.008 74.944-85.12 186.368-22.656 248.896 62.528 62.464 173.952 52.352 248.96-22.656l90.496-90.496zm0-362.048 45.248 45.248L398.848 670.4 353.6 625.152z"
      })
    ]));
  }
}), nKe = Wj, Hj = /* @__PURE__ */ F({
  name: "List",
  __name: "list",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M704 192h160v736H160V192h160v64h384zM288 512h448v-64H288zm0 256h448v-64H288zm96-576V96h256v96z"
      })
    ]));
  }
}), iKe = Hj, Xj = /* @__PURE__ */ F({
  name: "Loading",
  __name: "loading",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
      })
    ]));
  }
}), lc = Xj, Yj = /* @__PURE__ */ F({
  name: "MagicStick",
  __name: "magic-stick",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64h64v192h-64zm0 576h64v192h-64zM160 480v-64h192v64zm576 0v-64h192v64zM249.856 199.04l45.248-45.184L430.848 289.6 385.6 334.848 249.856 199.104zM657.152 606.4l45.248-45.248 135.744 135.744-45.248 45.248zM114.048 923.2 68.8 877.952l316.8-316.8 45.248 45.248zM702.4 334.848 657.152 289.6l135.744-135.744 45.248 45.248z"
      })
    ]));
  }
}), rKe = Yj, Uj = /* @__PURE__ */ F({
  name: "Minus",
  __name: "minus",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
      })
    ]));
  }
}), Gj = Uj, Kj = /* @__PURE__ */ F({
  name: "MoreFilled",
  __name: "more-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
      })
    ]));
  }
}), ZS = Kj, Jj = /* @__PURE__ */ F({
  name: "MostlyCloudy",
  __name: "mostly-cloudy",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M737.216 357.952 704 349.824l-11.776-32a192.064 192.064 0 0 0-367.424 23.04l-8.96 39.04-39.04 8.96A192.064 192.064 0 0 0 320 768h368a207.808 207.808 0 0 0 207.808-208 208.32 208.32 0 0 0-158.592-202.048m15.168-62.208A272.32 272.32 0 0 1 959.744 560a271.808 271.808 0 0 1-271.552 272H320a256 256 0 0 1-57.536-505.536 256.128 256.128 0 0 1 489.92-30.72"
      })
    ]));
  }
}), sKe = Jj, eV = /* @__PURE__ */ F({
  name: "Plus",
  __name: "plus",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), j$ = eV, tV = /* @__PURE__ */ F({
  name: "Promotion",
  __name: "promotion",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m64 448 832-320-128 704-446.08-243.328L832 192 242.816 545.472zm256 512V657.024L512 768z"
      })
    ]));
  }
}), oKe = tV, nV = /* @__PURE__ */ F({
  name: "QuestionFilled",
  __name: "question-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
      })
    ]));
  }
}), iV = nV, rV = /* @__PURE__ */ F({
  name: "RefreshLeft",
  __name: "refresh-left",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
      })
    ]));
  }
}), aKe = rV, sV = /* @__PURE__ */ F({
  name: "RefreshRight",
  __name: "refresh-right",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
      })
    ]));
  }
}), lKe = sV, oV = /* @__PURE__ */ F({
  name: "Refresh",
  __name: "refresh",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M771.776 794.88A384 384 0 0 1 128 512h64a320 320 0 0 0 555.712 216.448H654.72a32 32 0 1 1 0-64h149.056a32 32 0 0 1 32 32v148.928a32 32 0 1 1-64 0v-50.56zM276.288 295.616h92.992a32 32 0 0 1 0 64H220.16a32 32 0 0 1-32-32V178.56a32 32 0 0 1 64 0v50.56A384 384 0 0 1 896.128 512h-64a320 320 0 0 0-555.776-216.384z"
      })
    ]));
  }
}), cKe = oV, aV = /* @__PURE__ */ F({
  name: "RemoveFilled",
  __name: "remove-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896M288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512"
      })
    ]));
  }
}), uKe = aV, lV = /* @__PURE__ */ F({
  name: "Search",
  __name: "search",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
      })
    ]));
  }
}), cV = lV, uV = /* @__PURE__ */ F({
  name: "Select",
  __name: "select",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M77.248 415.04a64 64 0 0 1 90.496 0l226.304 226.304L846.528 188.8a64 64 0 1 1 90.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 0 1 0-90.496z"
      })
    ]));
  }
}), hKe = uV, hV = /* @__PURE__ */ F({
  name: "Stopwatch",
  __name: "stopwatch",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      Z("path", {
        fill: "currentColor",
        d: "M672 234.88c-39.168 174.464-80 298.624-122.688 372.48-64 110.848-202.624 30.848-138.624-80C453.376 453.44 540.48 355.968 672 234.816z"
      })
    ]));
  }
}), dKe = hV, dV = /* @__PURE__ */ F({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), V$ = dV, fV = /* @__PURE__ */ F({
  name: "Sunny",
  __name: "sunny",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 704a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512m0-704a32 32 0 0 1 32 32v64a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 768a32 32 0 0 1 32 32v64a32 32 0 1 1-64 0v-64a32 32 0 0 1 32-32M195.2 195.2a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 1 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm543.104 543.104a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 0 1-45.248 45.248l-45.248-45.248a32 32 0 0 1 0-45.248M64 512a32 32 0 0 1 32-32h64a32 32 0 0 1 0 64H96a32 32 0 0 1-32-32m768 0a32 32 0 0 1 32-32h64a32 32 0 1 1 0 64h-64a32 32 0 0 1-32-32M195.2 828.8a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248L240.448 828.8a32 32 0 0 1-45.248 0zm543.104-543.104a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248l-45.248 45.248a32 32 0 0 1-45.248 0"
      })
    ]));
  }
}), fKe = fV, pV = /* @__PURE__ */ F({
  name: "Tickets",
  __name: "tickets",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M192 128v768h640V128zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h192v64H320zm0 384h384v64H320z"
      })
    ]));
  }
}), pKe = pV, gV = /* @__PURE__ */ F({
  name: "Tools",
  __name: "tools",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72-166.272 96-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96 54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0 192 192 0 0 0 384 0"
      })
    ]));
  }
}), gKe = gV, mV = /* @__PURE__ */ F({
  name: "Top",
  __name: "top",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M572.235 205.282v600.365a30.118 30.118 0 1 1-60.235 0V205.282L292.382 438.633a28.913 28.913 0 0 1-42.646 0 33.43 33.43 0 0 1 0-45.236l271.058-288.045a28.913 28.913 0 0 1 42.647 0L834.5 393.397a33.43 33.43 0 0 1 0 45.176 28.913 28.913 0 0 1-42.647 0l-219.618-233.23z"
      })
    ]));
  }
}), mKe = mV, vV = /* @__PURE__ */ F({
  name: "TrendCharts",
  __name: "trend-charts",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M128 896V128h768v768zm291.712-327.296 128 102.4 180.16-201.792-47.744-42.624-139.84 156.608-128-102.4-180.16 201.792 47.744 42.624 139.84-156.608zM816 352a48 48 0 1 0-96 0 48 48 0 0 0 96 0"
      })
    ]));
  }
}), vKe = vV, bV = /* @__PURE__ */ F({
  name: "Upload",
  __name: "upload",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248z"
      })
    ]));
  }
}), bKe = bV, yV = /* @__PURE__ */ F({
  name: "View",
  __name: "view",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
      })
    ]));
  }
}), OV = yV, wV = /* @__PURE__ */ F({
  name: "WarnTriangleFilled",
  __name: "warn-triangle-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      "xml:space": "preserve",
      style: { "enable-background": "new 0 0 1024 1024" },
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M928.99 755.83 574.6 203.25c-12.89-20.16-36.76-32.58-62.6-32.58s-49.71 12.43-62.6 32.58L95.01 755.83c-12.91 20.12-12.9 44.91.01 65.03 12.92 20.12 36.78 32.51 62.59 32.49h708.78c25.82.01 49.68-12.37 62.59-32.49 12.91-20.12 12.92-44.91.01-65.03M554.67 768h-85.33v-85.33h85.33zm0-426.67v298.66h-85.33V341.32z"
      })
    ]));
  }
}), yKe = wV, xV = /* @__PURE__ */ F({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
}), J1 = xV, SV = /* @__PURE__ */ F({
  name: "ZoomIn",
  __name: "zoom-in",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), CV = SV, kV = /* @__PURE__ */ F({
  name: "ZoomOut",
  __name: "zoom-out",
  setup(n) {
    return (e, t) => (R(), V("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      Z("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
      })
    ]));
  }
}), OKe = kV;
function Sl() {
  return Sl = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Sl.apply(this, arguments);
}
function PV(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n, Rd(n, e);
}
function Jb(n) {
  return Jb = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Jb(n);
}
function Rd(n, e) {
  return Rd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, Rd(n, e);
}
function EV() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Jp(n, e, t) {
  return EV() ? Jp = Reflect.construct.bind() : Jp = function(r, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(r, a), c = new l();
    return o && Rd(c, o.prototype), c;
  }, Jp.apply(null, arguments);
}
function AV(n) {
  return Function.toString.call(n).indexOf("[native code]") !== -1;
}
function ey(n) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return ey = function(i) {
    if (i === null || !AV(i))
      return i;
    if (typeof i != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof e < "u") {
      if (e.has(i))
        return e.get(i);
      e.set(i, r);
    }
    function r() {
      return Jp(i, arguments, Jb(this).constructor);
    }
    return r.prototype = Object.create(i.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Rd(r, i);
  }, ey(n);
}
var $V = /%[sdj%]/g, F$ = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (F$ = function(e, t) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && t.every(function(i) {
    return typeof i == "string";
  }) && console.warn(e, t);
});
function ty(n) {
  if (!n || !n.length)
    return null;
  var e = {};
  return n.forEach(function(t) {
    var i = t.field;
    e[i] = e[i] || [], e[i].push(t);
  }), e;
}
function Er(n) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
    t[i - 1] = arguments[i];
  var r = 0, s = t.length;
  if (typeof n == "function")
    return n.apply(null, t);
  if (typeof n == "string") {
    var o = n.replace($V, function(a) {
      if (a === "%%")
        return "%";
      if (r >= s)
        return a;
      switch (a) {
        case "%s":
          return String(t[r++]);
        case "%d":
          return Number(t[r++]);
        case "%j":
          try {
            return JSON.stringify(t[r++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return a;
      }
    });
    return o;
  }
  return n;
}
function TV(n) {
  return n === "string" || n === "url" || n === "hex" || n === "email" || n === "date" || n === "pattern";
}
function Un(n, e) {
  return !!(n == null || e === "array" && Array.isArray(n) && !n.length || TV(e) && typeof n == "string" && !n);
}
function _V(n, e, t) {
  var i = [], r = 0, s = n.length;
  function o(a) {
    i.push.apply(i, a || []), r++, r === s && t(i);
  }
  n.forEach(function(a) {
    e(a, o);
  });
}
function qS(n, e, t) {
  var i = 0, r = n.length;
  function s(o) {
    if (o && o.length) {
      t(o);
      return;
    }
    var a = i;
    i = i + 1, a < r ? e(n[a], s) : t([]);
  }
  s([]);
}
function MV(n) {
  var e = [];
  return Object.keys(n).forEach(function(t) {
    e.push.apply(e, n[t] || []);
  }), e;
}
var WS = /* @__PURE__ */ function(n) {
  PV(e, n);
  function e(t, i) {
    var r;
    return r = n.call(this, "Async Validation Error") || this, r.errors = t, r.fields = i, r;
  }
  return e;
}(/* @__PURE__ */ ey(Error));
function RV(n, e, t, i, r) {
  if (e.first) {
    var s = new Promise(function(d, f) {
      var p = function(v) {
        return i(v), v.length ? f(new WS(v, ty(v))) : d(r);
      }, g = MV(n);
      qS(g, t, p);
    });
    return s.catch(function(d) {
      return d;
    }), s;
  }
  var o = e.firstFields === !0 ? Object.keys(n) : e.firstFields || [], a = Object.keys(n), l = a.length, c = 0, u = [], h = new Promise(function(d, f) {
    var p = function(m) {
      if (u.push.apply(u, m), c++, c === l)
        return i(u), u.length ? f(new WS(u, ty(u))) : d(r);
    };
    a.length || (i(u), d(r)), a.forEach(function(g) {
      var m = n[g];
      o.indexOf(g) !== -1 ? qS(m, t, p) : _V(m, t, p);
    });
  });
  return h.catch(function(d) {
    return d;
  }), h;
}
function NV(n) {
  return !!(n && n.message !== void 0);
}
function DV(n, e) {
  for (var t = n, i = 0; i < e.length; i++) {
    if (t == null)
      return t;
    t = t[e[i]];
  }
  return t;
}
function HS(n, e) {
  return function(t) {
    var i;
    return n.fullFields ? i = DV(e, n.fullFields) : i = e[t.field || n.fullField], NV(t) ? (t.field = t.field || n.fullField, t.fieldValue = i, t) : {
      message: typeof t == "function" ? t() : t,
      fieldValue: i,
      field: t.field || n.fullField
    };
  };
}
function XS(n, e) {
  if (e) {
    for (var t in e)
      if (e.hasOwnProperty(t)) {
        var i = e[t];
        typeof i == "object" && typeof n[t] == "object" ? n[t] = Sl({}, n[t], i) : n[t] = i;
      }
  }
  return n;
}
var Z$ = function(e, t, i, r, s, o) {
  e.required && (!i.hasOwnProperty(e.field) || Un(t, o || e.type)) && r.push(Er(s.messages.required, e.fullField));
}, LV = function(e, t, i, r, s) {
  (/^\s+$/.test(t) || t === "") && r.push(Er(s.messages.whitespace, e.fullField));
}, ip, IV = function() {
  if (ip)
    return ip;
  var n = "[a-fA-F\\d:]", e = function(w) {
    return w && w.includeBoundaries ? "(?:(?<=\\s|^)(?=" + n + ")|(?<=" + n + ")(?=\\s|$))" : "";
  }, t = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", i = "[a-fA-F\\d]{1,4}", r = (`
(?:
(?:` + i + ":){7}(?:" + i + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + i + ":){6}(?:" + t + "|:" + i + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + i + ":){5}(?::" + t + "|(?::" + i + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + i + ":){4}(?:(?::" + i + "){0,1}:" + t + "|(?::" + i + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + i + ":){3}(?:(?::" + i + "){0,2}:" + t + "|(?::" + i + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + i + ":){2}(?:(?::" + i + "){0,3}:" + t + "|(?::" + i + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + i + ":){1}(?:(?::" + i + "){0,4}:" + t + "|(?::" + i + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + i + "){0,5}:" + t + "|(?::" + i + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), s = new RegExp("(?:^" + t + "$)|(?:^" + r + "$)"), o = new RegExp("^" + t + "$"), a = new RegExp("^" + r + "$"), l = function(w) {
    return w && w.exact ? s : new RegExp("(?:" + e(w) + t + e(w) + ")|(?:" + e(w) + r + e(w) + ")", "g");
  };
  l.v4 = function(b) {
    return b && b.exact ? o : new RegExp("" + e(b) + t + e(b), "g");
  }, l.v6 = function(b) {
    return b && b.exact ? a : new RegExp("" + e(b) + r + e(b), "g");
  };
  var c = "(?:(?:[a-z]+:)?//)", u = "(?:\\S+(?::\\S*)?@)?", h = l.v4().source, d = l.v6().source, f = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", p = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", g = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", m = "(?::\\d{2,5})?", v = '(?:[/?#][^\\s"]*)?', y = "(?:" + c + "|www\\.)" + u + "(?:localhost|" + h + "|" + d + "|" + f + p + g + ")" + m + v;
  return ip = new RegExp("(?:^" + y + "$)", "i"), ip;
}, YS = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, zh = {
  integer: function(e) {
    return zh.number(e) && parseInt(e, 10) === e;
  },
  float: function(e) {
    return zh.number(e) && !zh.integer(e);
  },
  array: function(e) {
    return Array.isArray(e);
  },
  regexp: function(e) {
    if (e instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(e);
    } catch {
      return !1;
    }
  },
  date: function(e) {
    return typeof e.getTime == "function" && typeof e.getMonth == "function" && typeof e.getYear == "function" && !isNaN(e.getTime());
  },
  number: function(e) {
    return isNaN(e) ? !1 : typeof e == "number";
  },
  object: function(e) {
    return typeof e == "object" && !zh.array(e);
  },
  method: function(e) {
    return typeof e == "function";
  },
  email: function(e) {
    return typeof e == "string" && e.length <= 320 && !!e.match(YS.email);
  },
  url: function(e) {
    return typeof e == "string" && e.length <= 2048 && !!e.match(IV());
  },
  hex: function(e) {
    return typeof e == "string" && !!e.match(YS.hex);
  }
}, BV = function(e, t, i, r, s) {
  if (e.required && t === void 0) {
    Z$(e, t, i, r, s);
    return;
  }
  var o = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], a = e.type;
  o.indexOf(a) > -1 ? zh[a](t) || r.push(Er(s.messages.types[a], e.fullField, e.type)) : a && typeof t !== e.type && r.push(Er(s.messages.types[a], e.fullField, e.type));
}, QV = function(e, t, i, r, s) {
  var o = typeof e.len == "number", a = typeof e.min == "number", l = typeof e.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, u = t, h = null, d = typeof t == "number", f = typeof t == "string", p = Array.isArray(t);
  if (d ? h = "number" : f ? h = "string" : p && (h = "array"), !h)
    return !1;
  p && (u = t.length), f && (u = t.replace(c, "_").length), o ? u !== e.len && r.push(Er(s.messages[h].len, e.fullField, e.len)) : a && !l && u < e.min ? r.push(Er(s.messages[h].min, e.fullField, e.min)) : l && !a && u > e.max ? r.push(Er(s.messages[h].max, e.fullField, e.max)) : a && l && (u < e.min || u > e.max) && r.push(Er(s.messages[h].range, e.fullField, e.min, e.max));
}, Oc = "enum", zV = function(e, t, i, r, s) {
  e[Oc] = Array.isArray(e[Oc]) ? e[Oc] : [], e[Oc].indexOf(t) === -1 && r.push(Er(s.messages[Oc], e.fullField, e[Oc].join(", ")));
}, jV = function(e, t, i, r, s) {
  if (e.pattern) {
    if (e.pattern instanceof RegExp)
      e.pattern.lastIndex = 0, e.pattern.test(t) || r.push(Er(s.messages.pattern.mismatch, e.fullField, t, e.pattern));
    else if (typeof e.pattern == "string") {
      var o = new RegExp(e.pattern);
      o.test(t) || r.push(Er(s.messages.pattern.mismatch, e.fullField, t, e.pattern));
    }
  }
}, Ot = {
  required: Z$,
  whitespace: LV,
  type: BV,
  range: QV,
  enum: zV,
  pattern: jV
}, VV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t, "string") && !e.required)
      return i();
    Ot.required(e, t, r, o, s, "string"), Un(t, "string") || (Ot.type(e, t, r, o, s), Ot.range(e, t, r, o, s), Ot.pattern(e, t, r, o, s), e.whitespace === !0 && Ot.whitespace(e, t, r, o, s));
  }
  i(o);
}, FV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), t !== void 0 && Ot.type(e, t, r, o, s);
  }
  i(o);
}, ZV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (t === "" && (t = void 0), Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), t !== void 0 && (Ot.type(e, t, r, o, s), Ot.range(e, t, r, o, s));
  }
  i(o);
}, qV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), t !== void 0 && Ot.type(e, t, r, o, s);
  }
  i(o);
}, WV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), Un(t) || Ot.type(e, t, r, o, s);
  }
  i(o);
}, HV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), t !== void 0 && (Ot.type(e, t, r, o, s), Ot.range(e, t, r, o, s));
  }
  i(o);
}, XV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), t !== void 0 && (Ot.type(e, t, r, o, s), Ot.range(e, t, r, o, s));
  }
  i(o);
}, YV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (t == null && !e.required)
      return i();
    Ot.required(e, t, r, o, s, "array"), t != null && (Ot.type(e, t, r, o, s), Ot.range(e, t, r, o, s));
  }
  i(o);
}, UV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), t !== void 0 && Ot.type(e, t, r, o, s);
  }
  i(o);
}, GV = "enum", KV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s), t !== void 0 && Ot[GV](e, t, r, o, s);
  }
  i(o);
}, JV = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t, "string") && !e.required)
      return i();
    Ot.required(e, t, r, o, s), Un(t, "string") || Ot.pattern(e, t, r, o, s);
  }
  i(o);
}, eF = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t, "date") && !e.required)
      return i();
    if (Ot.required(e, t, r, o, s), !Un(t, "date")) {
      var l;
      t instanceof Date ? l = t : l = new Date(t), Ot.type(e, l, r, o, s), l && Ot.range(e, l.getTime(), r, o, s);
    }
  }
  i(o);
}, tF = function(e, t, i, r, s) {
  var o = [], a = Array.isArray(t) ? "array" : typeof t;
  Ot.required(e, t, r, o, s, a), i(o);
}, O0 = function(e, t, i, r, s) {
  var o = e.type, a = [], l = e.required || !e.required && r.hasOwnProperty(e.field);
  if (l) {
    if (Un(t, o) && !e.required)
      return i();
    Ot.required(e, t, r, a, s, o), Un(t, o) || Ot.type(e, t, r, a, s);
  }
  i(a);
}, nF = function(e, t, i, r, s) {
  var o = [], a = e.required || !e.required && r.hasOwnProperty(e.field);
  if (a) {
    if (Un(t) && !e.required)
      return i();
    Ot.required(e, t, r, o, s);
  }
  i(o);
}, ed = {
  string: VV,
  method: FV,
  number: ZV,
  boolean: qV,
  regexp: WV,
  integer: HV,
  float: XV,
  array: YV,
  object: UV,
  enum: KV,
  pattern: JV,
  date: eF,
  url: O0,
  hex: O0,
  email: O0,
  required: tF,
  any: nF
};
function ny() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var e = JSON.parse(JSON.stringify(this));
      return e.clone = this.clone, e;
    }
  };
}
var iy = ny(), Pf = /* @__PURE__ */ function() {
  function n(t) {
    this.rules = null, this._messages = iy, this.define(t);
  }
  var e = n.prototype;
  return e.define = function(i) {
    var r = this;
    if (!i)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof i != "object" || Array.isArray(i))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(i).forEach(function(s) {
      var o = i[s];
      r.rules[s] = Array.isArray(o) ? o : [o];
    });
  }, e.messages = function(i) {
    return i && (this._messages = XS(ny(), i)), this._messages;
  }, e.validate = function(i, r, s) {
    var o = this;
    r === void 0 && (r = {}), s === void 0 && (s = function() {
    });
    var a = i, l = r, c = s;
    if (typeof l == "function" && (c = l, l = {}), !this.rules || Object.keys(this.rules).length === 0)
      return c && c(null, a), Promise.resolve(a);
    function u(g) {
      var m = [], v = {};
      function y(w) {
        if (Array.isArray(w)) {
          var x;
          m = (x = m).concat.apply(x, w);
        } else
          m.push(w);
      }
      for (var b = 0; b < g.length; b++)
        y(g[b]);
      m.length ? (v = ty(m), c(m, v)) : c(null, a);
    }
    if (l.messages) {
      var h = this.messages();
      h === iy && (h = ny()), XS(h, l.messages), l.messages = h;
    } else
      l.messages = this.messages();
    var d = {}, f = l.keys || Object.keys(this.rules);
    f.forEach(function(g) {
      var m = o.rules[g], v = a[g];
      m.forEach(function(y) {
        var b = y;
        typeof b.transform == "function" && (a === i && (a = Sl({}, a)), v = a[g] = b.transform(v)), typeof b == "function" ? b = {
          validator: b
        } : b = Sl({}, b), b.validator = o.getValidationMethod(b), b.validator && (b.field = g, b.fullField = b.fullField || g, b.type = o.getType(b), d[g] = d[g] || [], d[g].push({
          rule: b,
          value: v,
          source: a,
          field: g
        }));
      });
    });
    var p = {};
    return RV(d, l, function(g, m) {
      var v = g.rule, y = (v.type === "object" || v.type === "array") && (typeof v.fields == "object" || typeof v.defaultField == "object");
      y = y && (v.required || !v.required && g.value), v.field = g.field;
      function b(S, C) {
        return Sl({}, C, {
          fullField: v.fullField + "." + S,
          fullFields: v.fullFields ? [].concat(v.fullFields, [S]) : [S]
        });
      }
      function w(S) {
        S === void 0 && (S = []);
        var C = Array.isArray(S) ? S : [S];
        !l.suppressWarning && C.length && n.warning("async-validator:", C), C.length && v.message !== void 0 && (C = [].concat(v.message));
        var k = C.map(HS(v, a));
        if (l.first && k.length)
          return p[v.field] = 1, m(k);
        if (!y)
          m(k);
        else {
          if (v.required && !g.value)
            return v.message !== void 0 ? k = [].concat(v.message).map(HS(v, a)) : l.error && (k = [l.error(v, Er(l.messages.required, v.field))]), m(k);
          var E = {};
          v.defaultField && Object.keys(g.value).map(function(T) {
            E[T] = v.defaultField;
          }), E = Sl({}, E, g.rule.fields);
          var M = {};
          Object.keys(E).forEach(function(T) {
            var B = E[T], I = Array.isArray(B) ? B : [B];
            M[T] = I.map(b.bind(null, T));
          });
          var _ = new n(M);
          _.messages(l.messages), g.rule.options && (g.rule.options.messages = l.messages, g.rule.options.error = l.error), _.validate(g.value, g.rule.options || l, function(T) {
            var B = [];
            k && k.length && B.push.apply(B, k), T && T.length && B.push.apply(B, T), m(B.length ? B : null);
          });
        }
      }
      var x;
      if (v.asyncValidator)
        x = v.asyncValidator(v, g.value, w, g.source, l);
      else if (v.validator) {
        try {
          x = v.validator(v, g.value, w, g.source, l);
        } catch (S) {
          console.error == null || console.error(S), l.suppressValidatorError || setTimeout(function() {
            throw S;
          }, 0), w(S.message);
        }
        x === !0 ? w() : x === !1 ? w(typeof v.message == "function" ? v.message(v.fullField || v.field) : v.message || (v.fullField || v.field) + " fails") : x instanceof Array ? w(x) : x instanceof Error && w(x.message);
      }
      x && x.then && x.then(function() {
        return w();
      }, function(S) {
        return w(S);
      });
    }, function(g) {
      u(g);
    }, a);
  }, e.getType = function(i) {
    if (i.type === void 0 && i.pattern instanceof RegExp && (i.type = "pattern"), typeof i.validator != "function" && i.type && !ed.hasOwnProperty(i.type))
      throw new Error(Er("Unknown rule type %s", i.type));
    return i.type || "string";
  }, e.getValidationMethod = function(i) {
    if (typeof i.validator == "function")
      return i.validator;
    var r = Object.keys(i), s = r.indexOf("message");
    return s !== -1 && r.splice(s, 1), r.length === 1 && r[0] === "required" ? ed.required : ed[this.getType(i)] || void 0;
  }, n;
}();
Pf.register = function(e, t) {
  if (typeof t != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  ed[e] = t;
};
Pf.warning = F$;
Pf.messages = iy;
Pf.validators = ed;
const iF = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', rF = (n) => process.env.NODE_ENV === "test" ? !0 : getComputedStyle(n).position === "fixed" ? !1 : n.offsetParent !== null, US = (n) => Array.from(n.querySelectorAll(iF)).filter((e) => sF(e) && rF(e)), sF = (n) => {
  if (n.tabIndex > 0 || n.tabIndex === 0 && n.getAttribute("tabIndex") !== null)
    return !0;
  if (n.disabled)
    return !1;
  switch (n.nodeName) {
    case "A":
      return !!n.href && n.rel !== "ignore";
    case "INPUT":
      return !(n.type === "hidden" || n.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return !0;
    default:
      return !1;
  }
}, q$ = (n) => !n.getAttribute("aria-owns"), W$ = (n, e, t) => {
  const { parentNode: i } = n;
  if (!i)
    return null;
  const r = i.querySelectorAll(t), s = Array.prototype.indexOf.call(r, n);
  return r[s + e] || null;
}, eg = (n) => {
  n && (n.focus(), !q$(n) && n.click());
}, Eo = (n, e, { checkForDefaultPrevented: t = !0 } = {}) => (r) => {
  const s = n == null ? void 0 : n(r);
  if (t === !1 || !s)
    return e == null ? void 0 : e(r);
};
var oF = Object.defineProperty, aF = Object.defineProperties, lF = Object.getOwnPropertyDescriptors, GS = Object.getOwnPropertySymbols, cF = Object.prototype.hasOwnProperty, uF = Object.prototype.propertyIsEnumerable, KS = (n, e, t) => e in n ? oF(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, hF = (n, e) => {
  for (var t in e || (e = {}))
    cF.call(e, t) && KS(n, t, e[t]);
  if (GS)
    for (var t of GS(e))
      uF.call(e, t) && KS(n, t, e[t]);
  return n;
}, dF = (n, e) => aF(n, lF(e));
function JS(n, e) {
  var t;
  const i = In();
  return Fr(() => {
    i.value = n();
  }, dF(hF({}, e), {
    flush: (t = e == null ? void 0 : e.flush) != null ? t : "sync"
  })), R1(i);
}
var eC;
const vt = typeof window < "u", fF = (n) => typeof n < "u", pF = (n) => typeof n == "function", gF = (n) => typeof n == "string", Yg = () => {
}, mF = vt && ((eC = window == null ? void 0 : window.navigator) == null ? void 0 : eC.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Zl(n) {
  return typeof n == "function" ? n() : O(n);
}
function vF(n, e) {
  function t(...i) {
    return new Promise((r, s) => {
      Promise.resolve(n(() => e.apply(this, i), { fn: e, thisArg: this, args: i })).then(r).catch(s);
    });
  }
  return t;
}
function bF(n, e = {}) {
  let t, i, r = Yg;
  const s = (a) => {
    clearTimeout(a), r(), r = Yg;
  };
  return (a) => {
    const l = Zl(n), c = Zl(e.maxWait);
    return t && s(t), l <= 0 || c !== void 0 && c <= 0 ? (i && (s(i), i = null), Promise.resolve(a())) : new Promise((u, h) => {
      r = e.rejectOnCancel ? h : u, c && !i && (i = setTimeout(() => {
        t && s(t), i = null, u(a());
      }, c)), t = setTimeout(() => {
        i && s(i), i = null, u(a());
      }, l);
    });
  };
}
function yF(n) {
  return n;
}
function Ef(n) {
  return vA() ? (N1(n), !0) : !1;
}
function OF(n, e = 200, t = {}) {
  return vF(bF(e, t), n);
}
function wF(n, e = 200, t = {}) {
  const i = D(n.value), r = OF(() => {
    i.value = n.value;
  }, e, t);
  return ne(n, () => r()), i;
}
function xF(n, e = !0) {
  Xe() ? qe(n) : e ? n() : $e(n);
}
function Ug(n, e, t = {}) {
  const {
    immediate: i = !0
  } = t, r = D(!1);
  let s = null;
  function o() {
    s && (clearTimeout(s), s = null);
  }
  function a() {
    r.value = !1, o();
  }
  function l(...c) {
    o(), r.value = !0, s = setTimeout(() => {
      r.value = !1, s = null, n(...c);
    }, Zl(e));
  }
  return i && (r.value = !0, vt && l()), Ef(a), {
    isPending: R1(r),
    start: l,
    stop: a
  };
}
function Gs(n) {
  var e;
  const t = Zl(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const lh = vt ? window : void 0, SF = vt ? window.document : void 0;
function qi(...n) {
  let e, t, i, r;
  if (gF(n[0]) || Array.isArray(n[0]) ? ([t, i, r] = n, e = lh) : [e, t, i, r] = n, !e)
    return Yg;
  Array.isArray(t) || (t = [t]), Array.isArray(i) || (i = [i]);
  const s = [], o = () => {
    s.forEach((u) => u()), s.length = 0;
  }, a = (u, h, d, f) => (u.addEventListener(h, d, f), () => u.removeEventListener(h, d, f)), l = ne(() => [Gs(e), Zl(r)], ([u, h]) => {
    o(), u && s.push(...t.flatMap((d) => i.map((f) => a(u, d, f, h))));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), o();
  };
  return Ef(c), c;
}
let tC = !1;
function CF(n, e, t = {}) {
  const { window: i = lh, ignore: r = [], capture: s = !0, detectIframe: o = !1 } = t;
  if (!i)
    return;
  mF && !tC && (tC = !0, Array.from(i.document.body.children).forEach((d) => d.addEventListener("click", Yg)));
  let a = !0;
  const l = (d) => r.some((f) => {
    if (typeof f == "string")
      return Array.from(i.document.querySelectorAll(f)).some((p) => p === d.target || d.composedPath().includes(p));
    {
      const p = Gs(f);
      return p && (d.target === p || d.composedPath().includes(p));
    }
  }), u = [
    qi(i, "click", (d) => {
      const f = Gs(n);
      if (!(!f || f === d.target || d.composedPath().includes(f))) {
        if (d.detail === 0 && (a = !l(d)), !a) {
          a = !0;
          return;
        }
        e(d);
      }
    }, { passive: !0, capture: s }),
    qi(i, "pointerdown", (d) => {
      const f = Gs(n);
      f && (a = !d.composedPath().includes(f) && !l(d));
    }, { passive: !0 }),
    o && qi(i, "blur", (d) => {
      var f;
      const p = Gs(n);
      ((f = i.document.activeElement) == null ? void 0 : f.tagName) === "IFRAME" && !(p != null && p.contains(i.document.activeElement)) && e(d);
    })
  ].filter(Boolean);
  return () => u.forEach((d) => d());
}
function H$(n, e = !1) {
  const t = D(), i = () => t.value = !!n();
  return i(), xF(i, e), t;
}
function kF(n) {
  return JSON.parse(JSON.stringify(n));
}
const nC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, iC = "__vueuse_ssr_handlers__";
nC[iC] = nC[iC] || {};
function PF(n, e, { window: t = lh, initialValue: i = "" } = {}) {
  const r = D(i), s = $(() => {
    var o;
    return Gs(e) || ((o = t == null ? void 0 : t.document) == null ? void 0 : o.documentElement);
  });
  return ne([s, () => Zl(n)], ([o, a]) => {
    var l;
    if (o && t) {
      const c = (l = t.getComputedStyle(o).getPropertyValue(a)) == null ? void 0 : l.trim();
      r.value = c || i;
    }
  }, { immediate: !0 }), ne(r, (o) => {
    var a;
    (a = s.value) != null && a.style && s.value.style.setProperty(Zl(n), o);
  }), r;
}
function EF({ document: n = SF } = {}) {
  if (!n)
    return D("visible");
  const e = D(n.visibilityState);
  return qi(n, "visibilitychange", () => {
    e.value = n.visibilityState;
  }), e;
}
var rC = Object.getOwnPropertySymbols, AF = Object.prototype.hasOwnProperty, $F = Object.prototype.propertyIsEnumerable, TF = (n, e) => {
  var t = {};
  for (var i in n)
    AF.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && rC)
    for (var i of rC(n))
      e.indexOf(i) < 0 && $F.call(n, i) && (t[i] = n[i]);
  return t;
};
function pn(n, e, t = {}) {
  const i = t, { window: r = lh } = i, s = TF(i, ["window"]);
  let o;
  const a = H$(() => r && "ResizeObserver" in r), l = () => {
    o && (o.disconnect(), o = void 0);
  }, c = ne(() => Gs(n), (h) => {
    l(), a.value && r && h && (o = new ResizeObserver(e), o.observe(h, s));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), c();
  };
  return Ef(u), {
    isSupported: a,
    stop: u
  };
}
var sC = Object.getOwnPropertySymbols, _F = Object.prototype.hasOwnProperty, MF = Object.prototype.propertyIsEnumerable, RF = (n, e) => {
  var t = {};
  for (var i in n)
    _F.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && sC)
    for (var i of sC(n))
      e.indexOf(i) < 0 && MF.call(n, i) && (t[i] = n[i]);
  return t;
};
function NF(n, e, t = {}) {
  const i = t, { window: r = lh } = i, s = RF(i, ["window"]);
  let o;
  const a = H$(() => r && "MutationObserver" in r), l = () => {
    o && (o.disconnect(), o = void 0);
  }, c = ne(() => Gs(n), (h) => {
    l(), a.value && r && h && (o = new MutationObserver(e), o.observe(h, s));
  }, { immediate: !0 }), u = () => {
    l(), c();
  };
  return Ef(u), {
    isSupported: a,
    stop: u
  };
}
var oC;
(function(n) {
  n.UP = "UP", n.RIGHT = "RIGHT", n.DOWN = "DOWN", n.LEFT = "LEFT", n.NONE = "NONE";
})(oC || (oC = {}));
var DF = Object.defineProperty, aC = Object.getOwnPropertySymbols, LF = Object.prototype.hasOwnProperty, IF = Object.prototype.propertyIsEnumerable, lC = (n, e, t) => e in n ? DF(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, BF = (n, e) => {
  for (var t in e || (e = {}))
    LF.call(e, t) && lC(n, t, e[t]);
  if (aC)
    for (var t of aC(e))
      IF.call(e, t) && lC(n, t, e[t]);
  return n;
};
const QF = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
BF({
  linear: yF
}, QF);
function zF(n, e, t, i = {}) {
  var r, s, o;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: c,
    deep: u = !1,
    defaultValue: h
  } = i, d = Xe(), f = t || (d == null ? void 0 : d.emit) || ((r = d == null ? void 0 : d.$emit) == null ? void 0 : r.bind(d)) || ((o = (s = d == null ? void 0 : d.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(d == null ? void 0 : d.proxy));
  let p = c;
  e || (e = "modelValue"), p = c || p || `update:${e.toString()}`;
  const g = (v) => a ? pF(a) ? a(v) : kF(v) : v, m = () => fF(n[e]) ? g(n[e]) : h;
  if (l) {
    const v = m(), y = D(v);
    return ne(() => n[e], (b) => y.value = g(b)), ne(y, (b) => {
      (b !== n[e] || u) && f(p, b);
    }, { deep: u }), y;
  } else
    return $({
      get() {
        return m();
      },
      set(v) {
        f(p, v);
      }
    });
}
function jF({ window: n = lh } = {}) {
  if (!n)
    return D(!1);
  const e = D(n.document.hasFocus());
  return qi(n, "blur", () => {
    e.value = !1;
  }), qi(n, "focus", () => {
    e.value = !0;
  }), e;
}
const X$ = () => vt && /firefox/i.test(window.navigator.userAgent), ew = (n) => {
  let e, t;
  return n.type === "touchend" ? (t = n.changedTouches[0].clientY, e = n.changedTouches[0].clientX) : n.type.startsWith("touch") ? (t = n.touches[0].clientY, e = n.touches[0].clientX) : (t = n.clientY, e = n.clientX), {
    clientX: e,
    clientY: t
  };
};
/**
* @vue/shared v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const Xt = () => {
}, Y$ = Object.assign, VF = Object.prototype.hasOwnProperty, Xi = (n, e) => VF.call(n, e), xt = Array.isArray, wt = (n) => typeof n == "function", bt = (n) => typeof n == "string", FF = (n) => typeof n == "symbol", an = (n) => n !== null && typeof n == "object", ry = (n) => (an(n) || wt(n)) && wt(n.then) && wt(n.catch), ZF = Object.prototype.toString, U$ = (n) => ZF.call(n), w0 = (n) => U$(n).slice(8, -1), cC = (n) => U$(n) === "[object Object]", G$ = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, qF = /-(\w)/g, WF = G$((n) => n.replace(qF, (e, t) => t ? t.toUpperCase() : "")), HF = G$((n) => n.charAt(0).toUpperCase() + n.slice(1)), XF = (n, e) => !Object.is(n, e), Ci = (n) => n === void 0, Ei = (n) => typeof n == "boolean", tt = (n) => typeof n == "number", Hs = (n) => !n && n !== 0 || xt(n) && n.length === 0 || an(n) && !Object.keys(n).length, Os = (n) => typeof Element > "u" ? !1 : n instanceof Element, YF = (n) => bt(n) ? !Number.isNaN(Number(n)) : !1, K$ = (n = "") => n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), Xs = (n) => HF(n), uC = (n) => Object.keys(n), UF = (n) => Object.entries(n), tg = (n, e, t) => ({
  get value() {
    return on(n, e, t);
  },
  set value(i) {
    Gz(n, e, i);
  }
});
class J$ extends Error {
  constructor(e) {
    super(e), this.name = "ElementPlusError";
  }
}
function dr(n, e) {
  throw new J$(`[${n}] ${e}`);
}
function pt(n, e) {
  if (process.env.NODE_ENV !== "production") {
    const t = bt(n) ? new J$(`[${n}] ${e}`) : n;
    console.warn(t);
  }
}
const GF = "utils/dom/style", eT = (n = "") => n.split(" ").filter((e) => !!e.trim()), qc = (n, e) => {
  if (!n || !e)
    return !1;
  if (e.includes(" "))
    throw new Error("className should not contain space.");
  return n.classList.contains(e);
}, pu = (n, e) => {
  !n || !e.trim() || n.classList.add(...eT(e));
}, Io = (n, e) => {
  !n || !e.trim() || n.classList.remove(...eT(e));
}, KF = (n, e) => {
  var t;
  if (!vt || !n || !e)
    return "";
  let i = WF(e);
  i === "float" && (i = "cssFloat");
  try {
    const r = n.style[i];
    if (r)
      return r;
    const s = (t = document.defaultView) == null ? void 0 : t.getComputedStyle(n, "");
    return s ? s[i] : "";
  } catch {
    return n.style[i];
  }
};
function ur(n, e = "px") {
  if (!n)
    return "";
  if (tt(n) || YF(n))
    return `${n}${e}`;
  if (bt(n))
    return n;
  pt(GF, "binding value must be a string or number");
}
let rp;
const JF = (n) => {
  var e;
  if (!vt)
    return 0;
  if (rp !== void 0)
    return rp;
  const t = document.createElement("div");
  t.className = `${n}-scrollbar__wrap`, t.style.visibility = "hidden", t.style.width = "100px", t.style.position = "absolute", t.style.top = "-9999px", document.body.appendChild(t);
  const i = t.offsetWidth;
  t.style.overflow = "scroll";
  const r = document.createElement("div");
  r.style.width = "100%", t.appendChild(r);
  const s = r.offsetWidth;
  return (e = t.parentNode) == null || e.removeChild(t), rp = i - s, rp;
};
function tT(n, e) {
  if (!vt)
    return;
  if (!e) {
    n.scrollTop = 0;
    return;
  }
  const t = [];
  let i = e.offsetParent;
  for (; i !== null && n !== i && n.contains(i); )
    t.push(i), i = i.offsetParent;
  const r = e.offsetTop + t.reduce((l, c) => l + c.offsetTop, 0), s = r + e.offsetHeight, o = n.scrollTop, a = o + n.clientHeight;
  r < o ? n.scrollTop = r : s > a && (n.scrollTop = s - n.clientHeight);
}
const nT = "__epPropKey", ce = (n) => n, eZ = (n) => an(n) && !!n[nT], Es = (n, e) => {
  if (!an(n) || eZ(n))
    return n;
  const { values: t, required: i, default: r, type: s, validator: o } = n, l = {
    type: s,
    required: !!i,
    validator: t || o ? (c) => {
      let u = !1, h = [];
      if (t && (h = Array.from(t), Xi(n, "default") && h.push(r), u || (u = h.includes(c))), o && (u || (u = o(c))), !u && h.length > 0) {
        const d = [...new Set(h)].map((f) => JSON.stringify(f)).join(", ");
        $L(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${d}], got value ${JSON.stringify(c)}.`);
      }
      return u;
    } : void 0,
    [nT]: !0
  };
  return Xi(n, "default") && (l.default = r), l;
}, Ee = (n) => Xg(Object.entries(n).map(([e, t]) => [
  e,
  Es(t, e)
])), Pn = ce([
  String,
  Object,
  Function
]), iT = {
  Close: jo
}, rT = {
  Close: jo,
  SuccessFilled: V$,
  InfoFilled: z$,
  WarningFilled: J1,
  CircleCloseFilled: Q$
}, gu = {
  success: V$,
  warning: J1,
  error: Q$,
  info: z$
}, tw = {
  validating: lc,
  success: K1,
  error: ah
}, Ft = (n, e) => {
  if (n.install = (t) => {
    for (const i of [n, ...Object.values(e ?? {})])
      t.component(i.name, i);
  }, e)
    for (const [t, i] of Object.entries(e))
      n[t] = i;
  return n;
}, sT = (n, e) => (n.install = (t) => {
  n._context = t._context, t.config.globalProperties[e] = n;
}, n), tZ = (n, e) => (n.install = (t) => {
  t.directive(e, n);
}, n), As = (n) => (n.install = Xt, n), nZ = (...n) => (e) => {
  n.forEach((t) => {
    wt(t) ? t(e) : t.value = e;
  });
}, dt = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, ot = "update:modelValue", Gn = "change", Ll = "input", cc = ["", "default", "small", "large"], oT = (n) => ["", ...cc].includes(n);
var ng = /* @__PURE__ */ ((n) => (n[n.TEXT = 1] = "TEXT", n[n.CLASS = 2] = "CLASS", n[n.STYLE = 4] = "STYLE", n[n.PROPS = 8] = "PROPS", n[n.FULL_PROPS = 16] = "FULL_PROPS", n[n.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", n[n.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", n[n.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", n[n.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", n[n.NEED_PATCH = 512] = "NEED_PATCH", n[n.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", n[n.HOISTED = -1] = "HOISTED", n[n.BAIL = -2] = "BAIL", n))(ng || {});
const ig = (n) => {
  const e = xt(n) ? n : [n], t = [];
  return e.forEach((i) => {
    var r;
    xt(i) ? t.push(...ig(i)) : co(i) && xt(i.children) ? t.push(...ig(i.children)) : (t.push(i), co(i) && ((r = i.component) != null && r.subTree) && t.push(...ig(i.component.subTree)));
  }), t;
}, hC = (n) => [...new Set(n)], dC = (n) => !n && n !== 0 ? [] : Array.isArray(n) ? n : [n], nw = (n) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(n), iw = (n) => vt ? window.requestAnimationFrame(n) : setTimeout(n, 16), aT = (n) => vt ? window.cancelAnimationFrame(n) : clearTimeout(n), Ur = (n) => n, iZ = ["class", "style"], rZ = /^on[A-Z]/, sZ = (n = {}) => {
  const { excludeListeners: e = !1, excludeKeys: t } = n, i = $(() => ((t == null ? void 0 : t.value) || []).concat(iZ)), r = Xe();
  return r ? $(() => {
    var s;
    return Xg(Object.entries((s = r.proxy) == null ? void 0 : s.$attrs).filter(([o]) => !i.value.includes(o) && !(e && rZ.test(o))));
  }) : (pt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), $(() => ({})));
}, ql = ({ from: n, replacement: e, scope: t, version: i, ref: r, type: s = "API" }, o) => {
  ne(() => O(o), (a) => {
    a && pt(t, `[${s}] ${n} is about to be deprecated in version ${i}, please use ${e} instead.
For more detail, please visit: ${r}
`);
  }, {
    immediate: !0
  });
}, lT = (n, e, t, i) => {
  let r = {
    offsetX: 0,
    offsetY: 0
  };
  const s = (l) => {
    const c = l.clientX, u = l.clientY, { offsetX: h, offsetY: d } = r, f = n.value.getBoundingClientRect(), p = f.left, g = f.top, m = f.width, v = f.height, y = document.documentElement.clientWidth, b = document.documentElement.clientHeight, w = -p + h, x = -g + d, S = y - p - m + h, C = b - g - v + d, k = (M) => {
      let _ = h + M.clientX - c, T = d + M.clientY - u;
      i != null && i.value || (_ = Math.min(Math.max(_, w), S), T = Math.min(Math.max(T, x), C)), r = {
        offsetX: _,
        offsetY: T
      }, n.value && (n.value.style.transform = `translate(${ur(_)}, ${ur(T)})`);
    }, E = () => {
      document.removeEventListener("mousemove", k), document.removeEventListener("mouseup", E);
    };
    document.addEventListener("mousemove", k), document.addEventListener("mouseup", E);
  }, o = () => {
    e.value && n.value && e.value.addEventListener("mousedown", s);
  }, a = () => {
    e.value && n.value && e.value.removeEventListener("mousedown", s);
  };
  qe(() => {
    Fr(() => {
      t.value ? o() : a();
    });
  }), Kn(() => {
    a();
  });
};
var oZ = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
const aZ = (n) => (e, t) => lZ(e, t, O(n)), lZ = (n, e, t) => on(t, n, n).replace(/\{(\w+)\}/g, (i, r) => {
  var s;
  return `${(s = e == null ? void 0 : e[r]) != null ? s : `{${r}}`}`;
}), cZ = (n) => {
  const e = $(() => O(n).name), t = Zi(n) ? n : D(n);
  return {
    lang: e,
    locale: t,
    t: aZ(n)
  };
}, cT = Symbol("localeContextKey"), mn = (n) => {
  const e = n || ke(cT, D());
  return cZ($(() => e.value || oZ));
};
/**
* @vue/reactivity v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function uT(n, ...e) {
  console.warn(`[Vue warn] ${n}`, ...e);
}
let uZ;
function hZ(n, e = uZ) {
  e && e.active && e.effects.push(n);
}
let td;
class dZ {
  constructor(e, t, i, r) {
    this.fn = e, this.trigger = t, this.scheduler = i, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, hZ(this, r);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1, pZ();
      for (let e = 0; e < this._depsLength; e++) {
        const t = this.deps[e];
        if (t.computed && (fZ(t.computed), this._dirtyLevel >= 4))
          break;
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), gZ();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(e) {
    this._dirtyLevel = e ? 4 : 0;
  }
  run() {
    if (this._dirtyLevel = 0, !this.active)
      return this.fn();
    let e = Il, t = td;
    try {
      return Il = !0, td = this, this._runnings++, fC(this), this.fn();
    } finally {
      pC(this), this._runnings--, td = t, Il = e;
    }
  }
  stop() {
    var e;
    this.active && (fC(this), pC(this), (e = this.onStop) == null || e.call(this), this.active = !1);
  }
}
function fZ(n) {
  return n.value;
}
function fC(n) {
  n._trackId++, n._depsLength = 0;
}
function pC(n) {
  if (n.deps.length > n._depsLength) {
    for (let e = n._depsLength; e < n.deps.length; e++)
      hT(n.deps[e], n);
    n.deps.length = n._depsLength;
  }
}
function hT(n, e) {
  const t = n.get(e);
  t !== void 0 && e._trackId !== t && (n.delete(e), n.size === 0 && n.cleanup());
}
let Il = !0, sy = 0;
const dT = [];
function pZ() {
  dT.push(Il), Il = !1;
}
function gZ() {
  const n = dT.pop();
  Il = n === void 0 ? !0 : n;
}
function mZ() {
  sy++;
}
function vZ() {
  for (sy--; !sy && oy.length; )
    oy.shift()();
}
function bZ(n, e, t) {
  var i;
  if (e.get(n) !== n._trackId) {
    e.set(n, n._trackId);
    const r = n.deps[n._depsLength];
    r !== e ? (r && hT(r, n), n.deps[n._depsLength++] = e) : n._depsLength++, process.env.NODE_ENV !== "production" && ((i = n.onTrack) == null || i.call(n, Y$({ effect: n }, t)));
  }
}
const oy = [];
function yZ(n, e, t) {
  var i;
  mZ();
  for (const r of n.keys()) {
    let s;
    r._dirtyLevel < e && (s ?? (s = n.get(r) === r._trackId)) && (r._shouldSchedule || (r._shouldSchedule = r._dirtyLevel === 0), r._dirtyLevel = e), r._shouldSchedule && (s ?? (s = n.get(r) === r._trackId)) && (process.env.NODE_ENV !== "production" && ((i = r.onTrigger) == null || i.call(r, Y$({ effect: r }, t))), r.trigger(), (!r._runnings || r.allowRecurse) && r._dirtyLevel !== 2 && (r._shouldSchedule = !1, r.scheduler && oy.push(r.scheduler)));
  }
  vZ();
}
const OZ = (n, e) => {
  const t = /* @__PURE__ */ new Map();
  return t.cleanup = n, t.computed = e, t;
};
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(FF)
);
function pv(n) {
  const e = n && n.__v_raw;
  return e ? pv(e) : n;
}
const wZ = "Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free";
class fT {
  constructor(e, t, i, r) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new dZ(
      () => e(this._value),
      () => x0(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    ), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = i;
  }
  get value() {
    const e = pv(this);
    return (!e._cacheable || e.effect.dirty) && XF(e._value, e._value = e.effect.run()) && x0(e, 4), SZ(e), e.effect._dirtyLevel >= 2 && (process.env.NODE_ENV !== "production" && uT(wZ), x0(e, 2)), e._value;
  }
  set value(e) {
    this._setter(e);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(e) {
    this.effect.dirty = e;
  }
  // #endregion
}
function xZ(n, e, t = !1) {
  let i, r;
  const s = wt(n);
  s ? (i = n, r = process.env.NODE_ENV !== "production" ? () => {
    uT("Write operation failed: computed value is readonly");
  } : Xt) : (i = n.get, r = n.set);
  const o = new fT(i, r, s || !r, t);
  return process.env.NODE_ENV !== "production" && e && !t && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;
}
function SZ(n) {
  var e;
  Il && td && (n = pv(n), bZ(
    td,
    (e = n.dep) != null ? e : n.dep = OZ(
      () => n.dep = void 0,
      n instanceof fT ? n : void 0
    ),
    process.env.NODE_ENV !== "production" ? {
      target: n,
      type: "get",
      key: "value"
    } : void 0
  ));
}
function x0(n, e = 4, t) {
  n = pv(n);
  const i = n.dep;
  i && yZ(
    i,
    e,
    process.env.NODE_ENV !== "production" ? {
      target: n,
      type: "set",
      key: "value",
      newValue: t
    } : void 0
  );
}
const nd = "el", CZ = "is-", sl = (n, e, t, i, r) => {
  let s = `${n}-${e}`;
  return t && (s += `-${t}`), i && (s += `__${i}`), r && (s += `--${r}`), s;
}, pT = Symbol("namespaceContextKey"), rw = (n) => {
  const e = n || (Xe() ? ke(pT, D(nd)) : D(nd));
  return $(() => O(e) || nd);
}, me = (n, e) => {
  const t = rw(e);
  return {
    namespace: t,
    b: (g = "") => sl(t.value, n, g, "", ""),
    e: (g) => g ? sl(t.value, n, "", g, "") : "",
    m: (g) => g ? sl(t.value, n, "", "", g) : "",
    be: (g, m) => g && m ? sl(t.value, n, g, m, "") : "",
    em: (g, m) => g && m ? sl(t.value, n, "", g, m) : "",
    bm: (g, m) => g && m ? sl(t.value, n, g, "", m) : "",
    bem: (g, m, v) => g && m && v ? sl(t.value, n, g, m, v) : "",
    is: (g, ...m) => {
      const v = m.length >= 1 ? m[0] : !0;
      return g && v ? `${CZ}${g}` : "";
    },
    cssVar: (g) => {
      const m = {};
      for (const v in g)
        g[v] && (m[`--${t.value}-${v}`] = g[v]);
      return m;
    },
    cssVarName: (g) => `--${t.value}-${g}`,
    cssVarBlock: (g) => {
      const m = {};
      for (const v in g)
        g[v] && (m[`--${t.value}-${n}-${v}`] = g[v]);
      return m;
    },
    cssVarBlockName: (g) => `--${t.value}-${n}-${g}`
  };
}, gT = (n, e = {}) => {
  Zi(n) || dr("[useLockscreen]", "You need to pass a ref param to this function");
  const t = e.ns || me("popup"), i = xZ(() => t.bm("parent", "hidden"));
  if (!vt || qc(document.body, i.value))
    return;
  let r = 0, s = !1, o = "0";
  const a = () => {
    setTimeout(() => {
      Io(document == null ? void 0 : document.body, i.value), s && document && (document.body.style.width = o);
    }, 200);
  };
  ne(n, (l) => {
    if (!l) {
      a();
      return;
    }
    s = !qc(document.body, i.value), s && (o = document.body.style.width), r = JF(t.namespace.value);
    const c = document.documentElement.clientHeight < document.body.scrollHeight, u = KF(document.body, "overflowY");
    r > 0 && (c || u === "scroll") && s && (document.body.style.width = `calc(100% - ${r}px)`), pu(document.body, i.value);
  }), N1(() => a());
}, kZ = Es({
  type: ce(Boolean),
  default: null
}), PZ = Es({
  type: ce(Function)
}), mT = (n) => {
  const e = `update:${n}`, t = `onUpdate:${n}`, i = [e], r = {
    [n]: kZ,
    [t]: PZ
  };
  return {
    useModelToggle: ({
      indicator: o,
      toggleReason: a,
      shouldHideWhenRouteChanges: l,
      shouldProceed: c,
      onShow: u,
      onHide: h
    }) => {
      const d = Xe(), { emit: f } = d, p = d.props, g = $(() => wt(p[t])), m = $(() => p[n] === null), v = (C) => {
        o.value !== !0 && (o.value = !0, a && (a.value = C), wt(u) && u(C));
      }, y = (C) => {
        o.value !== !1 && (o.value = !1, a && (a.value = C), wt(h) && h(C));
      }, b = (C) => {
        if (p.disabled === !0 || wt(c) && !c())
          return;
        const k = g.value && vt;
        k && f(e, !0), (m.value || !k) && v(C);
      }, w = (C) => {
        if (p.disabled === !0 || !vt)
          return;
        const k = g.value && vt;
        k && f(e, !1), (m.value || !k) && y(C);
      }, x = (C) => {
        Ei(C) && (p.disabled && C ? g.value && f(e, !1) : o.value !== C && (C ? v() : y()));
      }, S = () => {
        o.value ? w() : b();
      };
      return ne(() => p[n], x), l && d.appContext.config.globalProperties.$route !== void 0 && ne(() => ({
        ...d.proxy.$route
      }), () => {
        l.value && o.value && w();
      }), qe(() => {
        x(p[n]);
      }), {
        hide: w,
        show: b,
        toggle: S,
        hasUpdateHandler: g
      };
    },
    useModelToggleProps: r,
    useModelToggleEmits: i
  };
};
mT("modelValue");
const vT = (n) => {
  const e = Xe();
  return $(() => {
    var t, i;
    return (i = (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$props) == null ? void 0 : i[n];
  });
};
var or = "top", Gr = "bottom", Kr = "right", ar = "left", sw = "auto", Af = [or, Gr, Kr, ar], mu = "start", Nd = "end", EZ = "clippingParents", bT = "viewport", Ah = "popper", AZ = "reference", gC = Af.reduce(function(n, e) {
  return n.concat([e + "-" + mu, e + "-" + Nd]);
}, []), $f = [].concat(Af, [sw]).reduce(function(n, e) {
  return n.concat([e, e + "-" + mu, e + "-" + Nd]);
}, []), $Z = "beforeRead", TZ = "read", _Z = "afterRead", MZ = "beforeMain", RZ = "main", NZ = "afterMain", DZ = "beforeWrite", LZ = "write", IZ = "afterWrite", BZ = [$Z, TZ, _Z, MZ, RZ, NZ, DZ, LZ, IZ];
function ho(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function $s(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var e = n.ownerDocument;
    return e && e.defaultView || window;
  }
  return n;
}
function vu(n) {
  var e = $s(n).Element;
  return n instanceof e || n instanceof Element;
}
function Zr(n) {
  var e = $s(n).HTMLElement;
  return n instanceof e || n instanceof HTMLElement;
}
function ow(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = $s(n).ShadowRoot;
  return n instanceof e || n instanceof ShadowRoot;
}
function QZ(n) {
  var e = n.state;
  Object.keys(e.elements).forEach(function(t) {
    var i = e.styles[t] || {}, r = e.attributes[t] || {}, s = e.elements[t];
    !Zr(s) || !ho(s) || (Object.assign(s.style, i), Object.keys(r).forEach(function(o) {
      var a = r[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function zZ(n) {
  var e = n.state, t = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(i) {
      var r = e.elements[i], s = e.attributes[i] || {}, o = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]), a = o.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !Zr(r) || !ho(r) || (Object.assign(r.style, a), Object.keys(s).forEach(function(l) {
        r.removeAttribute(l);
      }));
    });
  };
}
var yT = { name: "applyStyles", enabled: !0, phase: "write", fn: QZ, effect: zZ, requires: ["computeStyles"] };
function io(n) {
  return n.split("-")[0];
}
var Bl = Math.max, Gg = Math.min, bu = Math.round;
function yu(n, e) {
  e === void 0 && (e = !1);
  var t = n.getBoundingClientRect(), i = 1, r = 1;
  if (Zr(n) && e) {
    var s = n.offsetHeight, o = n.offsetWidth;
    o > 0 && (i = bu(t.width) / o || 1), s > 0 && (r = bu(t.height) / s || 1);
  }
  return { width: t.width / i, height: t.height / r, top: t.top / r, right: t.right / i, bottom: t.bottom / r, left: t.left / i, x: t.left / i, y: t.top / r };
}
function aw(n) {
  var e = yu(n), t = n.offsetWidth, i = n.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), { x: n.offsetLeft, y: n.offsetTop, width: t, height: i };
}
function OT(n, e) {
  var t = e.getRootNode && e.getRootNode();
  if (n.contains(e))
    return !0;
  if (t && ow(t)) {
    var i = e;
    do {
      if (i && n.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Vo(n) {
  return $s(n).getComputedStyle(n);
}
function jZ(n) {
  return ["table", "td", "th"].indexOf(ho(n)) >= 0;
}
function Ga(n) {
  return ((vu(n) ? n.ownerDocument : n.document) || window.document).documentElement;
}
function gv(n) {
  return ho(n) === "html" ? n : n.assignedSlot || n.parentNode || (ow(n) ? n.host : null) || Ga(n);
}
function mC(n) {
  return !Zr(n) || Vo(n).position === "fixed" ? null : n.offsetParent;
}
function VZ(n) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, t = navigator.userAgent.indexOf("Trident") !== -1;
  if (t && Zr(n)) {
    var i = Vo(n);
    if (i.position === "fixed")
      return null;
  }
  var r = gv(n);
  for (ow(r) && (r = r.host); Zr(r) && ["html", "body"].indexOf(ho(r)) < 0; ) {
    var s = Vo(r);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return r;
    r = r.parentNode;
  }
  return null;
}
function Tf(n) {
  for (var e = $s(n), t = mC(n); t && jZ(t) && Vo(t).position === "static"; )
    t = mC(t);
  return t && (ho(t) === "html" || ho(t) === "body" && Vo(t).position === "static") ? e : t || VZ(n) || e;
}
function lw(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function id(n, e, t) {
  return Bl(n, Gg(e, t));
}
function FZ(n, e, t) {
  var i = id(n, e, t);
  return i > t ? t : i;
}
function wT() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function xT(n) {
  return Object.assign({}, wT(), n);
}
function ST(n, e) {
  return e.reduce(function(t, i) {
    return t[i] = n, t;
  }, {});
}
var ZZ = function(n, e) {
  return n = typeof n == "function" ? n(Object.assign({}, e.rects, { placement: e.placement })) : n, xT(typeof n != "number" ? n : ST(n, Af));
};
function qZ(n) {
  var e, t = n.state, i = n.name, r = n.options, s = t.elements.arrow, o = t.modifiersData.popperOffsets, a = io(t.placement), l = lw(a), c = [ar, Kr].indexOf(a) >= 0, u = c ? "height" : "width";
  if (!(!s || !o)) {
    var h = ZZ(r.padding, t), d = aw(s), f = l === "y" ? or : ar, p = l === "y" ? Gr : Kr, g = t.rects.reference[u] + t.rects.reference[l] - o[l] - t.rects.popper[u], m = o[l] - t.rects.reference[l], v = Tf(s), y = v ? l === "y" ? v.clientHeight || 0 : v.clientWidth || 0 : 0, b = g / 2 - m / 2, w = h[f], x = y - d[u] - h[p], S = y / 2 - d[u] / 2 + b, C = id(w, S, x), k = l;
    t.modifiersData[i] = (e = {}, e[k] = C, e.centerOffset = C - S, e);
  }
}
function WZ(n) {
  var e = n.state, t = n.options, i = t.element, r = i === void 0 ? "[data-popper-arrow]" : i;
  r != null && (typeof r == "string" && (r = e.elements.popper.querySelector(r), !r) || !OT(e.elements.popper, r) || (e.elements.arrow = r));
}
var HZ = { name: "arrow", enabled: !0, phase: "main", fn: qZ, effect: WZ, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function Ou(n) {
  return n.split("-")[1];
}
var XZ = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function YZ(n) {
  var e = n.x, t = n.y, i = window, r = i.devicePixelRatio || 1;
  return { x: bu(e * r) / r || 0, y: bu(t * r) / r || 0 };
}
function vC(n) {
  var e, t = n.popper, i = n.popperRect, r = n.placement, s = n.variation, o = n.offsets, a = n.position, l = n.gpuAcceleration, c = n.adaptive, u = n.roundOffsets, h = n.isFixed, d = o.x, f = d === void 0 ? 0 : d, p = o.y, g = p === void 0 ? 0 : p, m = typeof u == "function" ? u({ x: f, y: g }) : { x: f, y: g };
  f = m.x, g = m.y;
  var v = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), b = ar, w = or, x = window;
  if (c) {
    var S = Tf(t), C = "clientHeight", k = "clientWidth";
    if (S === $s(t) && (S = Ga(t), Vo(S).position !== "static" && a === "absolute" && (C = "scrollHeight", k = "scrollWidth")), S = S, r === or || (r === ar || r === Kr) && s === Nd) {
      w = Gr;
      var E = h && S === x && x.visualViewport ? x.visualViewport.height : S[C];
      g -= E - i.height, g *= l ? 1 : -1;
    }
    if (r === ar || (r === or || r === Gr) && s === Nd) {
      b = Kr;
      var M = h && S === x && x.visualViewport ? x.visualViewport.width : S[k];
      f -= M - i.width, f *= l ? 1 : -1;
    }
  }
  var _ = Object.assign({ position: a }, c && XZ), T = u === !0 ? YZ({ x: f, y: g }) : { x: f, y: g };
  if (f = T.x, g = T.y, l) {
    var B;
    return Object.assign({}, _, (B = {}, B[w] = y ? "0" : "", B[b] = v ? "0" : "", B.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + g + "px)" : "translate3d(" + f + "px, " + g + "px, 0)", B));
  }
  return Object.assign({}, _, (e = {}, e[w] = y ? g + "px" : "", e[b] = v ? f + "px" : "", e.transform = "", e));
}
function UZ(n) {
  var e = n.state, t = n.options, i = t.gpuAcceleration, r = i === void 0 ? !0 : i, s = t.adaptive, o = s === void 0 ? !0 : s, a = t.roundOffsets, l = a === void 0 ? !0 : a, c = { placement: io(e.placement), variation: Ou(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: r, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, vC(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, vC(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var CT = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: UZ, data: {} }, sp = { passive: !0 };
function GZ(n) {
  var e = n.state, t = n.instance, i = n.options, r = i.scroll, s = r === void 0 ? !0 : r, o = i.resize, a = o === void 0 ? !0 : o, l = $s(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && c.forEach(function(u) {
    u.addEventListener("scroll", t.update, sp);
  }), a && l.addEventListener("resize", t.update, sp), function() {
    s && c.forEach(function(u) {
      u.removeEventListener("scroll", t.update, sp);
    }), a && l.removeEventListener("resize", t.update, sp);
  };
}
var kT = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: GZ, data: {} }, KZ = { left: "right", right: "left", bottom: "top", top: "bottom" };
function rg(n) {
  return n.replace(/left|right|bottom|top/g, function(e) {
    return KZ[e];
  });
}
var JZ = { start: "end", end: "start" };
function bC(n) {
  return n.replace(/start|end/g, function(e) {
    return JZ[e];
  });
}
function cw(n) {
  var e = $s(n), t = e.pageXOffset, i = e.pageYOffset;
  return { scrollLeft: t, scrollTop: i };
}
function uw(n) {
  return yu(Ga(n)).left + cw(n).scrollLeft;
}
function eq(n) {
  var e = $s(n), t = Ga(n), i = e.visualViewport, r = t.clientWidth, s = t.clientHeight, o = 0, a = 0;
  return i && (r = i.width, s = i.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = i.offsetLeft, a = i.offsetTop)), { width: r, height: s, x: o + uw(n), y: a };
}
function tq(n) {
  var e, t = Ga(n), i = cw(n), r = (e = n.ownerDocument) == null ? void 0 : e.body, s = Bl(t.scrollWidth, t.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), o = Bl(t.scrollHeight, t.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -i.scrollLeft + uw(n), l = -i.scrollTop;
  return Vo(r || t).direction === "rtl" && (a += Bl(t.clientWidth, r ? r.clientWidth : 0) - s), { width: s, height: o, x: a, y: l };
}
function hw(n) {
  var e = Vo(n), t = e.overflow, i = e.overflowX, r = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + r + i);
}
function PT(n) {
  return ["html", "body", "#document"].indexOf(ho(n)) >= 0 ? n.ownerDocument.body : Zr(n) && hw(n) ? n : PT(gv(n));
}
function rd(n, e) {
  var t;
  e === void 0 && (e = []);
  var i = PT(n), r = i === ((t = n.ownerDocument) == null ? void 0 : t.body), s = $s(i), o = r ? [s].concat(s.visualViewport || [], hw(i) ? i : []) : i, a = e.concat(o);
  return r ? a : a.concat(rd(gv(o)));
}
function ay(n) {
  return Object.assign({}, n, { left: n.x, top: n.y, right: n.x + n.width, bottom: n.y + n.height });
}
function nq(n) {
  var e = yu(n);
  return e.top = e.top + n.clientTop, e.left = e.left + n.clientLeft, e.bottom = e.top + n.clientHeight, e.right = e.left + n.clientWidth, e.width = n.clientWidth, e.height = n.clientHeight, e.x = e.left, e.y = e.top, e;
}
function yC(n, e) {
  return e === bT ? ay(eq(n)) : vu(e) ? nq(e) : ay(tq(Ga(n)));
}
function iq(n) {
  var e = rd(gv(n)), t = ["absolute", "fixed"].indexOf(Vo(n).position) >= 0, i = t && Zr(n) ? Tf(n) : n;
  return vu(i) ? e.filter(function(r) {
    return vu(r) && OT(r, i) && ho(r) !== "body";
  }) : [];
}
function rq(n, e, t) {
  var i = e === "clippingParents" ? iq(n) : [].concat(e), r = [].concat(i, [t]), s = r[0], o = r.reduce(function(a, l) {
    var c = yC(n, l);
    return a.top = Bl(c.top, a.top), a.right = Gg(c.right, a.right), a.bottom = Gg(c.bottom, a.bottom), a.left = Bl(c.left, a.left), a;
  }, yC(n, s));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function ET(n) {
  var e = n.reference, t = n.element, i = n.placement, r = i ? io(i) : null, s = i ? Ou(i) : null, o = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l;
  switch (r) {
    case or:
      l = { x: o, y: e.y - t.height };
      break;
    case Gr:
      l = { x: o, y: e.y + e.height };
      break;
    case Kr:
      l = { x: e.x + e.width, y: a };
      break;
    case ar:
      l = { x: e.x - t.width, y: a };
      break;
    default:
      l = { x: e.x, y: e.y };
  }
  var c = r ? lw(r) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (s) {
      case mu:
        l[c] = l[c] - (e[u] / 2 - t[u] / 2);
        break;
      case Nd:
        l[c] = l[c] + (e[u] / 2 - t[u] / 2);
        break;
    }
  }
  return l;
}
function Dd(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, r = i === void 0 ? n.placement : i, s = t.boundary, o = s === void 0 ? EZ : s, a = t.rootBoundary, l = a === void 0 ? bT : a, c = t.elementContext, u = c === void 0 ? Ah : c, h = t.altBoundary, d = h === void 0 ? !1 : h, f = t.padding, p = f === void 0 ? 0 : f, g = xT(typeof p != "number" ? p : ST(p, Af)), m = u === Ah ? AZ : Ah, v = n.rects.popper, y = n.elements[d ? m : u], b = rq(vu(y) ? y : y.contextElement || Ga(n.elements.popper), o, l), w = yu(n.elements.reference), x = ET({ reference: w, element: v, strategy: "absolute", placement: r }), S = ay(Object.assign({}, v, x)), C = u === Ah ? S : w, k = { top: b.top - C.top + g.top, bottom: C.bottom - b.bottom + g.bottom, left: b.left - C.left + g.left, right: C.right - b.right + g.right }, E = n.modifiersData.offset;
  if (u === Ah && E) {
    var M = E[r];
    Object.keys(k).forEach(function(_) {
      var T = [Kr, Gr].indexOf(_) >= 0 ? 1 : -1, B = [or, Gr].indexOf(_) >= 0 ? "y" : "x";
      k[_] += M[B] * T;
    });
  }
  return k;
}
function sq(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, r = t.boundary, s = t.rootBoundary, o = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, c = l === void 0 ? $f : l, u = Ou(i), h = u ? a ? gC : gC.filter(function(p) {
    return Ou(p) === u;
  }) : Af, d = h.filter(function(p) {
    return c.indexOf(p) >= 0;
  });
  d.length === 0 && (d = h);
  var f = d.reduce(function(p, g) {
    return p[g] = Dd(n, { placement: g, boundary: r, rootBoundary: s, padding: o })[io(g)], p;
  }, {});
  return Object.keys(f).sort(function(p, g) {
    return f[p] - f[g];
  });
}
function oq(n) {
  if (io(n) === sw)
    return [];
  var e = rg(n);
  return [bC(n), e, bC(e)];
}
function aq(n) {
  var e = n.state, t = n.options, i = n.name;
  if (!e.modifiersData[i]._skip) {
    for (var r = t.mainAxis, s = r === void 0 ? !0 : r, o = t.altAxis, a = o === void 0 ? !0 : o, l = t.fallbackPlacements, c = t.padding, u = t.boundary, h = t.rootBoundary, d = t.altBoundary, f = t.flipVariations, p = f === void 0 ? !0 : f, g = t.allowedAutoPlacements, m = e.options.placement, v = io(m), y = v === m, b = l || (y || !p ? [rg(m)] : oq(m)), w = [m].concat(b).reduce(function(U, ae) {
      return U.concat(io(ae) === sw ? sq(e, { placement: ae, boundary: u, rootBoundary: h, padding: c, flipVariations: p, allowedAutoPlacements: g }) : ae);
    }, []), x = e.rects.reference, S = e.rects.popper, C = /* @__PURE__ */ new Map(), k = !0, E = w[0], M = 0; M < w.length; M++) {
      var _ = w[M], T = io(_), B = Ou(_) === mu, I = [or, Gr].indexOf(T) >= 0, P = I ? "width" : "height", A = Dd(e, { placement: _, boundary: u, rootBoundary: h, altBoundary: d, padding: c }), N = I ? B ? Kr : ar : B ? Gr : or;
      x[P] > S[P] && (N = rg(N));
      var q = rg(N), j = [];
      if (s && j.push(A[T] <= 0), a && j.push(A[N] <= 0, A[q] <= 0), j.every(function(U) {
        return U;
      })) {
        E = _, k = !1;
        break;
      }
      C.set(_, j);
    }
    if (k)
      for (var H = p ? 3 : 1, oe = function(U) {
        var ae = w.find(function(he) {
          var ee = C.get(he);
          if (ee)
            return ee.slice(0, U).every(function(pe) {
              return pe;
            });
        });
        if (ae)
          return E = ae, "break";
      }, te = H; te > 0; te--) {
        var W = oe(te);
        if (W === "break")
          break;
      }
    e.placement !== E && (e.modifiersData[i]._skip = !0, e.placement = E, e.reset = !0);
  }
}
var lq = { name: "flip", enabled: !0, phase: "main", fn: aq, requiresIfExists: ["offset"], data: { _skip: !1 } };
function OC(n, e, t) {
  return t === void 0 && (t = { x: 0, y: 0 }), { top: n.top - e.height - t.y, right: n.right - e.width + t.x, bottom: n.bottom - e.height + t.y, left: n.left - e.width - t.x };
}
function wC(n) {
  return [or, Kr, Gr, ar].some(function(e) {
    return n[e] >= 0;
  });
}
function cq(n) {
  var e = n.state, t = n.name, i = e.rects.reference, r = e.rects.popper, s = e.modifiersData.preventOverflow, o = Dd(e, { elementContext: "reference" }), a = Dd(e, { altBoundary: !0 }), l = OC(o, i), c = OC(a, r, s), u = wC(l), h = wC(c);
  e.modifiersData[t] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: h }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": h });
}
var uq = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: cq };
function hq(n, e, t) {
  var i = io(n), r = [ar, or].indexOf(i) >= 0 ? -1 : 1, s = typeof t == "function" ? t(Object.assign({}, e, { placement: n })) : t, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * r, [ar, Kr].indexOf(i) >= 0 ? { x: a, y: o } : { x: o, y: a };
}
function dq(n) {
  var e = n.state, t = n.options, i = n.name, r = t.offset, s = r === void 0 ? [0, 0] : r, o = $f.reduce(function(u, h) {
    return u[h] = hq(h, e.rects, s), u;
  }, {}), a = o[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[i] = o;
}
var fq = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: dq };
function pq(n) {
  var e = n.state, t = n.name;
  e.modifiersData[t] = ET({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var AT = { name: "popperOffsets", enabled: !0, phase: "read", fn: pq, data: {} };
function gq(n) {
  return n === "x" ? "y" : "x";
}
function mq(n) {
  var e = n.state, t = n.options, i = n.name, r = t.mainAxis, s = r === void 0 ? !0 : r, o = t.altAxis, a = o === void 0 ? !1 : o, l = t.boundary, c = t.rootBoundary, u = t.altBoundary, h = t.padding, d = t.tether, f = d === void 0 ? !0 : d, p = t.tetherOffset, g = p === void 0 ? 0 : p, m = Dd(e, { boundary: l, rootBoundary: c, padding: h, altBoundary: u }), v = io(e.placement), y = Ou(e.placement), b = !y, w = lw(v), x = gq(w), S = e.modifiersData.popperOffsets, C = e.rects.reference, k = e.rects.popper, E = typeof g == "function" ? g(Object.assign({}, e.rects, { placement: e.placement })) : g, M = typeof E == "number" ? { mainAxis: E, altAxis: E } : Object.assign({ mainAxis: 0, altAxis: 0 }, E), _ = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, T = { x: 0, y: 0 };
  if (S) {
    if (s) {
      var B, I = w === "y" ? or : ar, P = w === "y" ? Gr : Kr, A = w === "y" ? "height" : "width", N = S[w], q = N + m[I], j = N - m[P], H = f ? -k[A] / 2 : 0, oe = y === mu ? C[A] : k[A], te = y === mu ? -k[A] : -C[A], W = e.elements.arrow, U = f && W ? aw(W) : { width: 0, height: 0 }, ae = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : wT(), he = ae[I], ee = ae[P], pe = id(0, C[A], U[A]), be = b ? C[A] / 2 - H - pe - he - M.mainAxis : oe - pe - he - M.mainAxis, fe = b ? -C[A] / 2 + H + pe + ee + M.mainAxis : te + pe + ee + M.mainAxis, Ae = e.elements.arrow && Tf(e.elements.arrow), ut = Ae ? w === "y" ? Ae.clientTop || 0 : Ae.clientLeft || 0 : 0, zt = (B = _ == null ? void 0 : _[w]) != null ? B : 0, Jn = N + be - zt - ut, ei = N + fe - zt, Li = id(f ? Gg(q, Jn) : q, N, f ? Bl(j, ei) : j);
      S[w] = Li, T[w] = Li - N;
    }
    if (a) {
      var di, Ii = w === "x" ? or : ar, fr = w === "x" ? Gr : Kr, un = S[x], Bi = x === "y" ? "height" : "width", Ui = un + m[Ii], Qi = un - m[fr], ti = [or, ar].indexOf(v) !== -1, ge = (di = _ == null ? void 0 : _[x]) != null ? di : 0, Ke = ti ? Ui : un - C[Bi] - k[Bi] - ge + M.altAxis, Dt = ti ? un + C[Bi] + k[Bi] - ge - M.altAxis : Qi, ni = f && ti ? FZ(Ke, un, Dt) : id(f ? Ke : Ui, un, f ? Dt : Qi);
      S[x] = ni, T[x] = ni - un;
    }
    e.modifiersData[i] = T;
  }
}
var vq = { name: "preventOverflow", enabled: !0, phase: "main", fn: mq, requiresIfExists: ["offset"] };
function bq(n) {
  return { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop };
}
function yq(n) {
  return n === $s(n) || !Zr(n) ? cw(n) : bq(n);
}
function Oq(n) {
  var e = n.getBoundingClientRect(), t = bu(e.width) / n.offsetWidth || 1, i = bu(e.height) / n.offsetHeight || 1;
  return t !== 1 || i !== 1;
}
function wq(n, e, t) {
  t === void 0 && (t = !1);
  var i = Zr(e), r = Zr(e) && Oq(e), s = Ga(e), o = yu(n, r), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 };
  return (i || !i && !t) && ((ho(e) !== "body" || hw(s)) && (a = yq(e)), Zr(e) ? (l = yu(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = uw(s))), { x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height };
}
function xq(n) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), i = [];
  n.forEach(function(s) {
    e.set(s.name, s);
  });
  function r(s) {
    t.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!t.has(a)) {
        var l = e.get(a);
        l && r(l);
      }
    }), i.push(s);
  }
  return n.forEach(function(s) {
    t.has(s.name) || r(s);
  }), i;
}
function Sq(n) {
  var e = xq(n);
  return BZ.reduce(function(t, i) {
    return t.concat(e.filter(function(r) {
      return r.phase === i;
    }));
  }, []);
}
function Cq(n) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(n());
      });
    })), e;
  };
}
function kq(n) {
  var e = n.reduce(function(t, i) {
    var r = t[i.name];
    return t[i.name] = r ? Object.assign({}, r, i, { options: Object.assign({}, r.options, i.options), data: Object.assign({}, r.data, i.data) }) : i, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var xC = { placement: "bottom", modifiers: [], strategy: "absolute" };
function SC() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return !e.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function dw(n) {
  n === void 0 && (n = {});
  var e = n, t = e.defaultModifiers, i = t === void 0 ? [] : t, r = e.defaultOptions, s = r === void 0 ? xC : r;
  return function(o, a, l) {
    l === void 0 && (l = s);
    var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, xC, s), modifiersData: {}, elements: { reference: o, popper: a }, attributes: {}, styles: {} }, u = [], h = !1, d = { state: c, setOptions: function(g) {
      var m = typeof g == "function" ? g(c.options) : g;
      p(), c.options = Object.assign({}, s, c.options, m), c.scrollParents = { reference: vu(o) ? rd(o) : o.contextElement ? rd(o.contextElement) : [], popper: rd(a) };
      var v = Sq(kq([].concat(i, c.options.modifiers)));
      return c.orderedModifiers = v.filter(function(y) {
        return y.enabled;
      }), f(), d.update();
    }, forceUpdate: function() {
      if (!h) {
        var g = c.elements, m = g.reference, v = g.popper;
        if (SC(m, v)) {
          c.rects = { reference: wq(m, Tf(v), c.options.strategy === "fixed"), popper: aw(v) }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(k) {
            return c.modifiersData[k.name] = Object.assign({}, k.data);
          });
          for (var y = 0; y < c.orderedModifiers.length; y++) {
            if (c.reset === !0) {
              c.reset = !1, y = -1;
              continue;
            }
            var b = c.orderedModifiers[y], w = b.fn, x = b.options, S = x === void 0 ? {} : x, C = b.name;
            typeof w == "function" && (c = w({ state: c, options: S, name: C, instance: d }) || c);
          }
        }
      }
    }, update: Cq(function() {
      return new Promise(function(g) {
        d.forceUpdate(), g(c);
      });
    }), destroy: function() {
      p(), h = !0;
    } };
    if (!SC(o, a))
      return d;
    d.setOptions(l).then(function(g) {
      !h && l.onFirstUpdate && l.onFirstUpdate(g);
    });
    function f() {
      c.orderedModifiers.forEach(function(g) {
        var m = g.name, v = g.options, y = v === void 0 ? {} : v, b = g.effect;
        if (typeof b == "function") {
          var w = b({ state: c, name: m, instance: d, options: y }), x = function() {
          };
          u.push(w || x);
        }
      });
    }
    function p() {
      u.forEach(function(g) {
        return g();
      }), u = [];
    }
    return d;
  };
}
dw();
var Pq = [kT, AT, CT, yT];
dw({ defaultModifiers: Pq });
var Eq = [kT, AT, CT, yT, fq, lq, vq, HZ, uq], Aq = dw({ defaultModifiers: Eq });
const $q = (n, e, t = {}) => {
  const i = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const c = Tq(l);
      Object.assign(o.value, c);
    },
    requires: ["computeStyles"]
  }, r = $(() => {
    const { onFirstUpdate: l, placement: c, strategy: u, modifiers: h } = O(t);
    return {
      onFirstUpdate: l,
      placement: c || "bottom",
      strategy: u || "absolute",
      modifiers: [
        ...h || [],
        i,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), s = In(), o = D({
    styles: {
      popper: {
        position: O(r).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = () => {
    s.value && (s.value.destroy(), s.value = void 0);
  };
  return ne(r, (l) => {
    const c = O(s);
    c && c.setOptions(l);
  }, {
    deep: !0
  }), ne([n, e], ([l, c]) => {
    a(), !(!l || !c) && (s.value = Aq(l, c, O(r)));
  }), Kn(() => {
    a();
  }), {
    state: $(() => {
      var l;
      return { ...((l = O(s)) == null ? void 0 : l.state) || {} };
    }),
    styles: $(() => O(o).styles),
    attributes: $(() => O(o).attributes),
    update: () => {
      var l;
      return (l = O(s)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = O(s)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: $(() => O(s))
  };
};
function Tq(n) {
  const e = Object.keys(n.elements), t = Xg(e.map((r) => [r, n.styles[r] || {}])), i = Xg(e.map((r) => [r, n.attributes[r]]));
  return {
    styles: t,
    attributes: i
  };
}
const fw = (n) => {
  if (!n)
    return { onClick: Xt, onMousedown: Xt, onMouseup: Xt };
  let e = !1, t = !1;
  return { onClick: (o) => {
    e && t && n(o), e = t = !1;
  }, onMousedown: (o) => {
    e = o.target === o.currentTarget;
  }, onMouseup: (o) => {
    t = o.target === o.currentTarget;
  } };
};
function CC() {
  let n;
  const e = (i, r) => {
    t(), n = window.setTimeout(i, r);
  }, t = () => window.clearTimeout(n);
  return Ef(() => t()), {
    registerTimeout: e,
    cancelTimeout: t
  };
}
const ly = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, _q = Symbol("elIdInjection"), pw = () => Xe() ? ke(_q, ly) : ly, ws = (n) => {
  const e = pw();
  !vt && e === ly && pt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const t = rw();
  return $(() => O(n) || `${t.value}-id-${e.prefix}-${e.current++}`);
};
let _c = [];
const kC = (n) => {
  const e = n;
  e.key === dt.esc && _c.forEach((t) => t(e));
}, Mq = (n) => {
  qe(() => {
    _c.length === 0 && document.addEventListener("keydown", kC), vt && _c.push(n);
  }), Kn(() => {
    _c = _c.filter((e) => e !== n), _c.length === 0 && vt && document.removeEventListener("keydown", kC);
  });
};
let PC;
const $T = () => {
  const n = rw(), e = pw(), t = $(() => `${n.value}-popper-container-${e.prefix}`), i = $(() => `#${t.value}`);
  return {
    id: t,
    selector: i
  };
}, Rq = (n) => {
  const e = document.createElement("div");
  return e.id = n, document.body.appendChild(e), e;
}, Nq = () => {
  const { id: n, selector: e } = $T();
  return D1(() => {
    vt && (process.env.NODE_ENV === "test" || !PC && !document.body.querySelector(e.value)) && (PC = Rq(n.value));
  }), {
    id: n,
    selector: e
  };
}, Dq = Ee({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), Lq = ({
  showAfter: n,
  hideAfter: e,
  autoClose: t,
  open: i,
  close: r
}) => {
  const { registerTimeout: s } = CC(), {
    registerTimeout: o,
    cancelTimeout: a
  } = CC();
  return {
    onOpen: (u) => {
      s(() => {
        i(u);
        const h = O(t);
        tt(h) && h > 0 && o(() => {
          r(u);
        }, h);
      }, O(n));
    },
    onClose: (u) => {
      a(), s(() => {
        r(u);
      }, O(e));
    }
  };
}, TT = Symbol("elForwardRef"), Iq = (n) => {
  ft(TT, {
    setForwardRef: (t) => {
      n.value = t;
    }
  });
}, Bq = (n) => ({
  mounted(e) {
    n(e);
  },
  updated(e) {
    n(e);
  },
  unmounted() {
    n(null);
  }
}), EC = D(0), _T = 2e3, MT = Symbol("zIndexContextKey"), gw = (n) => {
  const e = n || (Xe() ? ke(MT, void 0) : void 0), t = $(() => {
    const s = O(e);
    return tt(s) ? s : _T;
  }), i = $(() => t.value + EC.value);
  return {
    initialZIndex: t,
    currentZIndex: i,
    nextZIndex: () => (EC.value++, i.value)
  };
};
function Qq(n) {
  const e = D();
  function t() {
    if (n.value == null)
      return;
    const { selectionStart: r, selectionEnd: s, value: o } = n.value;
    if (r == null || s == null)
      return;
    const a = o.slice(0, Math.max(0, r)), l = o.slice(Math.max(0, s));
    e.value = {
      selectionStart: r,
      selectionEnd: s,
      value: o,
      beforeTxt: a,
      afterTxt: l
    };
  }
  function i() {
    if (n.value == null || e.value == null)
      return;
    const { value: r } = n.value, { beforeTxt: s, afterTxt: o, selectionStart: a } = e.value;
    if (s == null || o == null || a == null)
      return;
    let l = r.length;
    if (r.endsWith(o))
      l = r.length - o.length;
    else if (r.startsWith(s))
      l = s.length;
    else {
      const c = s[a - 1], u = r.indexOf(c, a - 1);
      u !== -1 && (l = u + 1);
    }
    n.value.setSelectionRange(l, l);
  }
  return [t, i];
}
const zq = (n, e, t) => ig(n.subTree).filter((s) => {
  var o;
  return co(s) && ((o = s.type) == null ? void 0 : o.name) === e && !!s.component;
}).map((s) => s.component.uid).map((s) => t[s]).filter((s) => !!s), jq = (n, e) => {
  const t = {}, i = In([]);
  return {
    children: i,
    addChild: (o) => {
      t[o.uid] = o, i.value = zq(n, e, t);
    },
    removeChild: (o) => {
      delete t[o], i.value = i.value.filter((a) => a.uid !== o);
    }
  };
}, _r = Es({
  type: String,
  values: cc,
  required: !1
}), RT = Symbol("size"), Vq = () => {
  const n = ke(RT, {});
  return $(() => O(n.size) || "");
};
function mv(n, { afterFocus: e, beforeBlur: t, afterBlur: i } = {}) {
  const r = Xe(), { emit: s } = r, o = In(), a = D(!1), l = (h) => {
    a.value || (a.value = !0, s("focus", h), e == null || e());
  }, c = (h) => {
    var d;
    wt(t) && t(h) || h.relatedTarget && ((d = o.value) != null && d.contains(h.relatedTarget)) || (a.value = !1, s("blur", h), i == null || i());
  }, u = () => {
    var h;
    (h = n.value) == null || h.focus();
  };
  return ne(o, (h) => {
    h && h.setAttribute("tabindex", "-1");
  }), qi(o, "click", u), {
    wrapperRef: o,
    isFocused: a,
    handleFocus: l,
    handleBlur: c
  };
}
const NT = Symbol(), Kg = D();
function vv(n, e = void 0) {
  const t = Xe() ? ke(NT, Kg) : Kg;
  return n ? $(() => {
    var i, r;
    return (r = (i = t.value) == null ? void 0 : i[n]) != null ? r : e;
  }) : t;
}
function mw(n, e) {
  const t = vv(), i = me(n, $(() => {
    var a;
    return ((a = t.value) == null ? void 0 : a.namespace) || nd;
  })), r = mn($(() => {
    var a;
    return (a = t.value) == null ? void 0 : a.locale;
  })), s = gw($(() => {
    var a;
    return ((a = t.value) == null ? void 0 : a.zIndex) || _T;
  })), o = $(() => {
    var a;
    return O(e) || ((a = t.value) == null ? void 0 : a.size) || "";
  });
  return DT($(() => O(t) || {})), {
    ns: i,
    locale: r,
    zIndex: s,
    size: o
  };
}
const DT = (n, e, t = !1) => {
  var i;
  const r = !!Xe(), s = r ? vv() : void 0, o = (i = e == null ? void 0 : e.provide) != null ? i : r ? ft : void 0;
  if (!o) {
    pt("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const a = $(() => {
    const l = O(n);
    return s != null && s.value ? Fq(s.value, l) : l;
  });
  return o(NT, a), o(cT, $(() => a.value.locale)), o(pT, $(() => a.value.namespace)), o(MT, $(() => a.value.zIndex)), o(RT, {
    size: $(() => a.value.size || "")
  }), (t || !Kg.value) && (Kg.value = a.value), a;
}, Fq = (n, e) => {
  var t;
  const i = [.../* @__PURE__ */ new Set([...uC(n), ...uC(e)])], r = {};
  for (const s of i)
    r[s] = (t = e[s]) != null ? t : n[s];
  return r;
}, Zq = Ee({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: ce(Object)
  },
  size: _r,
  button: {
    type: ce(Object)
  },
  experimentalFeatures: {
    type: ce(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: ce(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
}), cy = {};
F({
  name: "ElConfigProvider",
  props: Zq,
  setup(n, { slots: e }) {
    ne(() => n.message, (i) => {
      Object.assign(cy, i ?? {});
    }, { immediate: !0, deep: !0 });
    const t = DT(n);
    return () => de(e, "default", { config: t == null ? void 0 : t.value });
  }
});
var Ce = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [i, r] of e)
    t[i] = r;
  return t;
};
const qq = Ee({
  size: {
    type: ce([Number, String])
  },
  color: {
    type: String
  }
}), Wq = F({
  name: "ElIcon",
  inheritAttrs: !1
}), Hq = /* @__PURE__ */ F({
  ...Wq,
  props: qq,
  setup(n) {
    const e = n, t = me("icon"), i = $(() => {
      const { size: r, color: s } = e;
      return !r && !s ? {} : {
        fontSize: Ci(r) ? void 0 : ur(r),
        "--color": s
      };
    });
    return (r, s) => (R(), V("i", Pi({
      class: O(t).b(),
      style: O(i)
    }, r.$attrs), [
      de(r.$slots, "default")
    ], 16));
  }
});
var Xq = /* @__PURE__ */ Ce(Hq, [["__file", "icon.vue"]]);
const Fe = Ft(Xq), ch = Symbol("formContextKey"), Da = Symbol("formItemContextKey"), Yi = (n, e = {}) => {
  const t = D(void 0), i = e.prop ? t : vT("size"), r = e.global ? t : Vq(), s = e.form ? { size: void 0 } : ke(ch, void 0), o = e.formItem ? { size: void 0 } : ke(Da, void 0);
  return $(() => i.value || O(n) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || r.value || "");
}, ts = (n) => {
  const e = vT("disabled"), t = ke(ch, void 0);
  return $(() => e.value || O(n) || (t == null ? void 0 : t.disabled) || !1);
}, Mr = () => {
  const n = ke(ch, void 0), e = ke(Da, void 0);
  return {
    form: n,
    formItem: e
  };
}, Ka = (n, {
  formItemContext: e,
  disableIdGeneration: t,
  disableIdManagement: i
}) => {
  t || (t = D(!1)), i || (i = D(!1));
  const r = D();
  let s;
  const o = $(() => {
    var a;
    return !!(!n.label && e && e.inputIds && ((a = e.inputIds) == null ? void 0 : a.length) <= 1);
  });
  return qe(() => {
    s = ne([Pr(n, "id"), t], ([a, l]) => {
      const c = a ?? (l ? void 0 : ws().value);
      c !== r.value && (e != null && e.removeInputId && (r.value && e.removeInputId(r.value), !(i != null && i.value) && !l && c && e.addInputId(c)), r.value = c);
    }, { immediate: !0 });
  }), Gu(() => {
    s && s(), e != null && e.removeInputId && r.value && e.removeInputId(r.value);
  }), {
    isLabeledByFormItem: o,
    inputId: r
  };
}, Yq = Ee({
  size: {
    type: String,
    values: cc
  },
  disabled: Boolean
}), Uq = Ee({
  ...Yq,
  model: Object,
  rules: {
    type: ce(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: !0
  },
  validateOnRuleChange: {
    type: Boolean,
    default: !0
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: [Object, Boolean]
  }
}), Gq = {
  validate: (n, e, t) => (xt(n) || bt(n)) && Ei(e) && bt(t)
}, Kq = "ElForm";
function Jq() {
  const n = D([]), e = $(() => {
    if (!n.value.length)
      return "0";
    const s = Math.max(...n.value);
    return s ? `${s}px` : "";
  });
  function t(s) {
    const o = n.value.indexOf(s);
    return o === -1 && e.value === "0" && pt(Kq, `unexpected width ${s}`), o;
  }
  function i(s, o) {
    if (s && o) {
      const a = t(o);
      n.value.splice(a, 1, s);
    } else
      s && n.value.push(s);
  }
  function r(s) {
    const o = t(s);
    o > -1 && n.value.splice(o, 1);
  }
  return {
    autoLabelWidth: e,
    registerLabelWidth: i,
    deregisterLabelWidth: r
  };
}
const op = (n, e) => {
  const t = _d(e);
  return t.length > 0 ? n.filter((i) => i.prop && t.includes(i.prop)) : n;
}, sg = "ElForm", e7 = F({
  name: sg
}), t7 = /* @__PURE__ */ F({
  ...e7,
  props: Uq,
  emits: Gq,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = [], s = Yi(), o = me("form"), a = $(() => {
      const { labelPosition: b, inline: w } = i;
      return [
        o.b(),
        o.m(s.value || "default"),
        {
          [o.m(`label-${b}`)]: b,
          [o.m("inline")]: w
        }
      ];
    }), l = (b) => r.find((w) => w.prop === b), c = (b) => {
      r.push(b);
    }, u = (b) => {
      b.prop && r.splice(r.indexOf(b), 1);
    }, h = (b = []) => {
      if (!i.model) {
        pt(sg, "model is required for resetFields to work.");
        return;
      }
      op(r, b).forEach((w) => w.resetField());
    }, d = (b = []) => {
      op(r, b).forEach((w) => w.clearValidate());
    }, f = $(() => {
      const b = !!i.model;
      return b || pt(sg, "model is required for validate to work."), b;
    }), p = (b) => {
      if (r.length === 0)
        return [];
      const w = op(r, b);
      return w.length ? w : (pt(sg, "please pass correct props!"), []);
    }, g = async (b) => v(void 0, b), m = async (b = []) => {
      if (!f.value)
        return !1;
      const w = p(b);
      if (w.length === 0)
        return !0;
      let x = {};
      for (const S of w)
        try {
          await S.validate("");
        } catch (C) {
          x = {
            ...x,
            ...C
          };
        }
      return Object.keys(x).length === 0 ? !0 : Promise.reject(x);
    }, v = async (b = [], w) => {
      const x = !wt(w);
      try {
        const S = await m(b);
        return S === !0 && (w == null || w(S)), S;
      } catch (S) {
        if (S instanceof Error)
          throw S;
        const C = S;
        return i.scrollToError && y(Object.keys(C)[0]), w == null || w(!1, C), x && Promise.reject(C);
      }
    }, y = (b) => {
      var w;
      const x = op(r, b)[0];
      x && ((w = x.$el) == null || w.scrollIntoView(i.scrollIntoViewOptions));
    };
    return ne(() => i.rules, () => {
      i.validateOnRuleChange && g().catch((b) => pt(b));
    }, { deep: !0 }), ft(ch, Gt({
      ...Hr(i),
      emit: t,
      resetFields: h,
      clearValidate: d,
      validateField: v,
      getField: l,
      addField: c,
      removeField: u,
      ...Jq()
    })), e({
      validate: g,
      validateField: v,
      resetFields: h,
      clearValidate: d,
      scrollToField: y
    }), (b, w) => (R(), V("form", {
      class: L(O(a))
    }, [
      de(b.$slots, "default")
    ], 2));
  }
});
var n7 = /* @__PURE__ */ Ce(t7, [["__file", "form.vue"]]);
const i7 = [
  "",
  "error",
  "validating",
  "success"
], r7 = Ee({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: ce([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: ce([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: i7
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: !0
  },
  size: {
    type: String,
    values: cc
  }
}), AC = "ElLabelWrap";
var s7 = F({
  name: AC,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(n, {
    slots: e
  }) {
    const t = ke(ch, void 0), i = ke(Da);
    i || dr(AC, "usage: <el-form-item><label-wrap /></el-form-item>");
    const r = me("form"), s = D(), o = D(0), a = () => {
      var u;
      if ((u = s.value) != null && u.firstElementChild) {
        const h = window.getComputedStyle(s.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(h));
      } else
        return 0;
    }, l = (u = "update") => {
      $e(() => {
        e.default && n.isAutoWidth && (u === "update" ? o.value = a() : u === "remove" && (t == null || t.deregisterLabelWidth(o.value)));
      });
    }, c = () => l("update");
    return qe(() => {
      c();
    }), Kn(() => {
      l("remove");
    }), Ya(() => c()), ne(o, (u, h) => {
      n.updateAll && (t == null || t.registerLabelWidth(u, h));
    }), pn($(() => {
      var u, h;
      return (h = (u = s.value) == null ? void 0 : u.firstElementChild) != null ? h : null;
    }), c), () => {
      var u, h;
      if (!e)
        return null;
      const {
        isAutoWidth: d
      } = n;
      if (d) {
        const f = t == null ? void 0 : t.autoLabelWidth, p = i == null ? void 0 : i.hasLabel, g = {};
        if (p && f && f !== "auto") {
          const m = Math.max(0, Number.parseInt(f, 10) - o.value), v = t.labelPosition === "left" ? "marginRight" : "marginLeft";
          m && (g[v] = `${m}px`);
        }
        return K("div", {
          ref: s,
          class: [r.be("item", "label-wrap")],
          style: g
        }, [(u = e.default) == null ? void 0 : u.call(e)]);
      } else
        return K(Tt, {
          ref: s
        }, [(h = e.default) == null ? void 0 : h.call(e)]);
    };
  }
});
const o7 = ["role", "aria-labelledby"], a7 = F({
  name: "ElFormItem"
}), l7 = /* @__PURE__ */ F({
  ...a7,
  props: r7,
  setup(n, { expose: e }) {
    const t = n, i = vo(), r = ke(ch, void 0), s = ke(Da, void 0), o = Yi(void 0, { formItem: !1 }), a = me("form-item"), l = ws().value, c = D([]), u = D(""), h = wF(u, 100), d = D(""), f = D();
    let p, g = !1;
    const m = $(() => {
      if ((r == null ? void 0 : r.labelPosition) === "top")
        return {};
      const ee = ur(t.labelWidth || (r == null ? void 0 : r.labelWidth) || "");
      return ee ? { width: ee } : {};
    }), v = $(() => {
      if ((r == null ? void 0 : r.labelPosition) === "top" || r != null && r.inline)
        return {};
      if (!t.label && !t.labelWidth && E)
        return {};
      const ee = ur(t.labelWidth || (r == null ? void 0 : r.labelWidth) || "");
      return !t.label && !i.label ? { marginLeft: ee } : {};
    }), y = $(() => [
      a.b(),
      a.m(o.value),
      a.is("error", u.value === "error"),
      a.is("validating", u.value === "validating"),
      a.is("success", u.value === "success"),
      a.is("required", I.value || t.required),
      a.is("no-asterisk", r == null ? void 0 : r.hideRequiredAsterisk),
      (r == null ? void 0 : r.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      { [a.m("feedback")]: r == null ? void 0 : r.statusIcon }
    ]), b = $(() => Ei(t.inlineMessage) ? t.inlineMessage : (r == null ? void 0 : r.inlineMessage) || !1), w = $(() => [
      a.e("error"),
      { [a.em("error", "inline")]: b.value }
    ]), x = $(() => t.prop ? bt(t.prop) ? t.prop : t.prop.join(".") : ""), S = $(() => !!(t.label || i.label)), C = $(() => t.for || (c.value.length === 1 ? c.value[0] : void 0)), k = $(() => !C.value && S.value), E = !!s, M = $(() => {
      const ee = r == null ? void 0 : r.model;
      if (!(!ee || !t.prop))
        return tg(ee, t.prop).value;
    }), _ = $(() => {
      const { required: ee } = t, pe = [];
      t.rules && pe.push(..._d(t.rules));
      const be = r == null ? void 0 : r.rules;
      if (be && t.prop) {
        const fe = tg(be, t.prop).value;
        fe && pe.push(..._d(fe));
      }
      if (ee !== void 0) {
        const fe = pe.map((Ae, ut) => [Ae, ut]).filter(([Ae]) => Object.keys(Ae).includes("required"));
        if (fe.length > 0)
          for (const [Ae, ut] of fe)
            Ae.required !== ee && (pe[ut] = { ...Ae, required: ee });
        else
          pe.push({ required: ee });
      }
      return pe;
    }), T = $(() => _.value.length > 0), B = (ee) => _.value.filter((be) => !be.trigger || !ee ? !0 : Array.isArray(be.trigger) ? be.trigger.includes(ee) : be.trigger === ee).map(({ trigger: be, ...fe }) => fe), I = $(() => _.value.some((ee) => ee.required)), P = $(() => {
      var ee;
      return h.value === "error" && t.showMessage && ((ee = r == null ? void 0 : r.showMessage) != null ? ee : !0);
    }), A = $(() => `${t.label || ""}${(r == null ? void 0 : r.labelSuffix) || ""}`), N = (ee) => {
      u.value = ee;
    }, q = (ee) => {
      var pe, be;
      const { errors: fe, fields: Ae } = ee;
      (!fe || !Ae) && console.error(ee), N("error"), d.value = fe ? (be = (pe = fe == null ? void 0 : fe[0]) == null ? void 0 : pe.message) != null ? be : `${t.prop} is required` : "", r == null || r.emit("validate", t.prop, !1, d.value);
    }, j = () => {
      N("success"), r == null || r.emit("validate", t.prop, !0, "");
    }, H = async (ee) => {
      const pe = x.value;
      return new Pf({
        [pe]: ee
      }).validate({ [pe]: M.value }, { firstFields: !0 }).then(() => (j(), !0)).catch((fe) => (q(fe), Promise.reject(fe)));
    }, oe = async (ee, pe) => {
      if (g || !t.prop)
        return !1;
      const be = wt(pe);
      if (!T.value)
        return pe == null || pe(!1), !1;
      const fe = B(ee);
      return fe.length === 0 ? (pe == null || pe(!0), !0) : (N("validating"), H(fe).then(() => (pe == null || pe(!0), !0)).catch((Ae) => {
        const { fields: ut } = Ae;
        return pe == null || pe(!1, ut), be ? !1 : Promise.reject(ut);
      }));
    }, te = () => {
      N(""), d.value = "", g = !1;
    }, W = async () => {
      const ee = r == null ? void 0 : r.model;
      if (!ee || !t.prop)
        return;
      const pe = tg(ee, t.prop);
      g = !0, pe.value = Md(p), await $e(), te(), g = !1;
    }, U = (ee) => {
      c.value.includes(ee) || c.value.push(ee);
    }, ae = (ee) => {
      c.value = c.value.filter((pe) => pe !== ee);
    };
    ne(() => t.error, (ee) => {
      d.value = ee || "", N(ee ? "error" : "");
    }, { immediate: !0 }), ne(() => t.validateStatus, (ee) => N(ee || ""));
    const he = Gt({
      ...Hr(t),
      $el: f,
      size: o,
      validateState: u,
      labelId: l,
      inputIds: c,
      isGroup: k,
      hasLabel: S,
      fieldValue: M,
      addInputId: U,
      removeInputId: ae,
      resetField: W,
      clearValidate: te,
      validate: oe
    });
    return ft(Da, he), qe(() => {
      t.prop && (r == null || r.addField(he), p = Md(M.value));
    }), Kn(() => {
      r == null || r.removeField(he);
    }), e({
      size: o,
      validateMessage: d,
      validateState: u,
      validate: oe,
      clearValidate: te,
      resetField: W
    }), (ee, pe) => {
      var be;
      return R(), V("div", {
        ref_key: "formItemRef",
        ref: f,
        class: L(O(y)),
        role: O(k) ? "group" : void 0,
        "aria-labelledby": O(k) ? O(l) : void 0
      }, [
        K(O(s7), {
          "is-auto-width": O(m).width === "auto",
          "update-all": ((be = O(r)) == null ? void 0 : be.labelWidth) === "auto"
        }, {
          default: Y(() => [
            O(S) ? (R(), ie(yt(O(C) ? "label" : "div"), {
              key: 0,
              id: O(l),
              for: O(C),
              class: L(O(a).e("label")),
              style: Qe(O(m))
            }, {
              default: Y(() => [
                de(ee.$slots, "label", { label: O(A) }, () => [
                  Yn(xe(O(A)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : G("v-if", !0)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        Z("div", {
          class: L(O(a).e("content")),
          style: Qe(O(v))
        }, [
          de(ee.$slots, "default"),
          K(bA, {
            name: `${O(a).namespace.value}-zoom-in-top`
          }, {
            default: Y(() => [
              O(P) ? de(ee.$slots, "error", {
                key: 0,
                error: d.value
              }, () => [
                Z("div", {
                  class: L(O(w))
                }, xe(d.value), 3)
              ]) : G("v-if", !0)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, o7);
    };
  }
});
var LT = /* @__PURE__ */ Ce(l7, [["__file", "form-item.vue"]]);
const wKe = Ft(n7, {
  FormItem: LT
}), xKe = As(LT);
let ss;
const c7 = `
  height:0 !important;
  visibility:hidden !important;
  ${X$() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, u7 = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function h7(n) {
  const e = window.getComputedStyle(n), t = e.getPropertyValue("box-sizing"), i = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top")), r = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
  return { contextStyle: u7.map((o) => `${o}:${e.getPropertyValue(o)}`).join(";"), paddingSize: i, borderSize: r, boxSizing: t };
}
function $C(n, e = 1, t) {
  var i;
  ss || (ss = document.createElement("textarea"), document.body.appendChild(ss));
  const { paddingSize: r, borderSize: s, boxSizing: o, contextStyle: a } = h7(n);
  ss.setAttribute("style", `${a};${c7}`), ss.value = n.value || n.placeholder || "";
  let l = ss.scrollHeight;
  const c = {};
  o === "border-box" ? l = l + s : o === "content-box" && (l = l - r), ss.value = "";
  const u = ss.scrollHeight - r;
  if (tt(e)) {
    let h = u * e;
    o === "border-box" && (h = h + r + s), l = Math.max(h, l), c.minHeight = `${h}px`;
  }
  if (tt(t)) {
    let h = u * t;
    o === "border-box" && (h = h + r + s), l = Math.min(h, l);
  }
  return c.height = `${l}px`, (i = ss.parentNode) == null || i.removeChild(ss), ss = void 0, c;
}
const d7 = Ee({
  id: {
    type: String,
    default: void 0
  },
  size: _r,
  disabled: Boolean,
  modelValue: {
    type: ce([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: ce([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: Pn
  },
  prefixIcon: {
    type: Pn
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: ce([Object, Array, String]),
    default: () => Ur({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
}), f7 = {
  [ot]: (n) => bt(n),
  input: (n) => bt(n),
  change: (n) => bt(n),
  focus: (n) => n instanceof FocusEvent,
  blur: (n) => n instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (n) => n instanceof MouseEvent,
  mouseenter: (n) => n instanceof MouseEvent,
  keydown: (n) => n instanceof Event,
  compositionstart: (n) => n instanceof CompositionEvent,
  compositionupdate: (n) => n instanceof CompositionEvent,
  compositionend: (n) => n instanceof CompositionEvent
}, p7 = ["role"], g7 = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], m7 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], v7 = F({
  name: "ElInput",
  inheritAttrs: !1
}), b7 = /* @__PURE__ */ F({
  ...v7,
  props: d7,
  emits: f7,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = yA(), s = vo(), o = $(() => {
      const ge = {};
      return i.containerRole === "combobox" && (ge["aria-haspopup"] = r["aria-haspopup"], ge["aria-owns"] = r["aria-owns"], ge["aria-expanded"] = r["aria-expanded"]), ge;
    }), a = $(() => [
      i.type === "textarea" ? m.b() : g.b(),
      g.m(f.value),
      g.is("disabled", p.value),
      g.is("exceed", U.value),
      {
        [g.b("group")]: s.prepend || s.append,
        [g.bm("group", "append")]: s.append,
        [g.bm("group", "prepend")]: s.prepend,
        [g.m("prefix")]: s.prefix || i.prefixIcon,
        [g.m("suffix")]: s.suffix || i.suffixIcon || i.clearable || i.showPassword,
        [g.bm("suffix", "password-clear")]: H.value && oe.value
      },
      r.class
    ]), l = $(() => [
      g.e("wrapper"),
      g.is("focus", M.value)
    ]), c = sZ({
      excludeKeys: $(() => Object.keys(o.value))
    }), { form: u, formItem: h } = Mr(), { inputId: d } = Ka(i, {
      formItemContext: h
    }), f = Yi(), p = ts(), g = me("input"), m = me("textarea"), v = In(), y = In(), b = D(!1), w = D(!1), x = D(!1), S = D(), C = In(i.inputStyle), k = $(() => v.value || y.value), { wrapperRef: E, isFocused: M, handleFocus: _, handleBlur: T } = mv(k, {
      afterBlur() {
        var ge;
        i.validateEvent && ((ge = h == null ? void 0 : h.validate) == null || ge.call(h, "blur").catch((Ke) => pt(Ke)));
      }
    }), B = $(() => {
      var ge;
      return (ge = u == null ? void 0 : u.statusIcon) != null ? ge : !1;
    }), I = $(() => (h == null ? void 0 : h.validateState) || ""), P = $(() => I.value && tw[I.value]), A = $(() => x.value ? OV : Fj), N = $(() => [
      r.style
    ]), q = $(() => [
      i.inputStyle,
      C.value,
      { resize: i.resize }
    ]), j = $(() => Ni(i.modelValue) ? "" : String(i.modelValue)), H = $(() => i.clearable && !p.value && !i.readonly && !!j.value && (M.value || b.value)), oe = $(() => i.showPassword && !p.value && !i.readonly && !!j.value && (!!j.value || M.value)), te = $(() => i.showWordLimit && !!i.maxlength && (i.type === "text" || i.type === "textarea") && !p.value && !i.readonly && !i.showPassword), W = $(() => j.value.length), U = $(() => !!te.value && W.value > Number(i.maxlength)), ae = $(() => !!s.suffix || !!i.suffixIcon || H.value || i.showPassword || te.value || !!I.value && B.value), [he, ee] = Qq(v);
    pn(y, (ge) => {
      if (fe(), !te.value || i.resize !== "both")
        return;
      const Ke = ge[0], { width: Dt } = Ke.contentRect;
      S.value = {
        right: `calc(100% - ${Dt + 15 + 6}px)`
      };
    });
    const pe = () => {
      const { type: ge, autosize: Ke } = i;
      if (!(!vt || ge !== "textarea" || !y.value))
        if (Ke) {
          const Dt = an(Ke) ? Ke.minRows : void 0, ni = an(Ke) ? Ke.maxRows : void 0, Ns = $C(y.value, Dt, ni);
          C.value = {
            overflowY: "hidden",
            ...Ns
          }, $e(() => {
            y.value.offsetHeight, C.value = Ns;
          });
        } else
          C.value = {
            minHeight: $C(y.value).minHeight
          };
    }, fe = ((ge) => {
      let Ke = !1;
      return () => {
        var Dt;
        if (Ke || !i.autosize)
          return;
        ((Dt = y.value) == null ? void 0 : Dt.offsetParent) === null || (ge(), Ke = !0);
      };
    })(pe), Ae = () => {
      const ge = k.value, Ke = i.formatter ? i.formatter(j.value) : j.value;
      !ge || ge.value === Ke || (ge.value = Ke);
    }, ut = async (ge) => {
      he();
      let { value: Ke } = ge.target;
      if (i.formatter && (Ke = i.parser ? i.parser(Ke) : Ke), !w.value) {
        if (Ke === j.value) {
          Ae();
          return;
        }
        t(ot, Ke), t("input", Ke), await $e(), Ae(), ee();
      }
    }, zt = (ge) => {
      t("change", ge.target.value);
    }, Jn = (ge) => {
      t("compositionstart", ge), w.value = !0;
    }, ei = (ge) => {
      var Ke;
      t("compositionupdate", ge);
      const Dt = (Ke = ge.target) == null ? void 0 : Ke.value, ni = Dt[Dt.length - 1] || "";
      w.value = !nw(ni);
    }, Li = (ge) => {
      t("compositionend", ge), w.value && (w.value = !1, ut(ge));
    }, di = () => {
      x.value = !x.value, Ii();
    }, Ii = async () => {
      var ge;
      await $e(), (ge = k.value) == null || ge.focus();
    }, fr = () => {
      var ge;
      return (ge = k.value) == null ? void 0 : ge.blur();
    }, un = (ge) => {
      b.value = !1, t("mouseleave", ge);
    }, Bi = (ge) => {
      b.value = !0, t("mouseenter", ge);
    }, Ui = (ge) => {
      t("keydown", ge);
    }, Qi = () => {
      var ge;
      (ge = k.value) == null || ge.select();
    }, ti = () => {
      t(ot, ""), t("change", ""), t("clear"), t("input", "");
    };
    return ne(() => i.modelValue, () => {
      var ge;
      $e(() => pe()), i.validateEvent && ((ge = h == null ? void 0 : h.validate) == null || ge.call(h, "change").catch((Ke) => pt(Ke)));
    }), ne(j, () => Ae()), ne(() => i.type, async () => {
      await $e(), Ae(), pe();
    }), qe(() => {
      !i.formatter && i.parser && pt("ElInput", "If you set the parser, you also need to set the formatter."), Ae(), $e(pe);
    }), e({
      input: v,
      textarea: y,
      ref: k,
      textareaStyle: q,
      autosize: Pr(i, "autosize"),
      focus: Ii,
      blur: fr,
      select: Qi,
      clear: ti,
      resizeTextarea: pe
    }), (ge, Ke) => it((R(), V("div", Pi(O(o), {
      class: O(a),
      style: O(N),
      role: ge.containerRole,
      onMouseenter: Bi,
      onMouseleave: un
    }), [
      G(" input "),
      ge.type !== "textarea" ? (R(), V(Tt, { key: 0 }, [
        G(" prepend slot "),
        ge.$slots.prepend ? (R(), V("div", {
          key: 0,
          class: L(O(g).be("group", "prepend"))
        }, [
          de(ge.$slots, "prepend")
        ], 2)) : G("v-if", !0),
        Z("div", {
          ref_key: "wrapperRef",
          ref: E,
          class: L(O(l))
        }, [
          G(" prefix slot "),
          ge.$slots.prefix || ge.prefixIcon ? (R(), V("span", {
            key: 0,
            class: L(O(g).e("prefix"))
          }, [
            Z("span", {
              class: L(O(g).e("prefix-inner"))
            }, [
              de(ge.$slots, "prefix"),
              ge.prefixIcon ? (R(), ie(O(Fe), {
                key: 0,
                class: L(O(g).e("icon"))
              }, {
                default: Y(() => [
                  (R(), ie(yt(ge.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : G("v-if", !0)
            ], 2)
          ], 2)) : G("v-if", !0),
          Z("input", Pi({
            id: O(d),
            ref_key: "input",
            ref: v,
            class: O(g).e("inner")
          }, O(c), {
            minlength: ge.minlength,
            maxlength: ge.maxlength,
            type: ge.showPassword ? x.value ? "text" : "password" : ge.type,
            disabled: O(p),
            readonly: ge.readonly,
            autocomplete: ge.autocomplete,
            tabindex: ge.tabindex,
            "aria-label": ge.label,
            placeholder: ge.placeholder,
            style: ge.inputStyle,
            form: ge.form,
            autofocus: ge.autofocus,
            onCompositionstart: Jn,
            onCompositionupdate: ei,
            onCompositionend: Li,
            onInput: ut,
            onFocus: Ke[0] || (Ke[0] = (...Dt) => O(_) && O(_)(...Dt)),
            onBlur: Ke[1] || (Ke[1] = (...Dt) => O(T) && O(T)(...Dt)),
            onChange: zt,
            onKeydown: Ui
          }), null, 16, g7),
          G(" suffix slot "),
          O(ae) ? (R(), V("span", {
            key: 1,
            class: L(O(g).e("suffix"))
          }, [
            Z("span", {
              class: L(O(g).e("suffix-inner"))
            }, [
              !O(H) || !O(oe) || !O(te) ? (R(), V(Tt, { key: 0 }, [
                de(ge.$slots, "suffix"),
                ge.suffixIcon ? (R(), ie(O(Fe), {
                  key: 0,
                  class: L(O(g).e("icon"))
                }, {
                  default: Y(() => [
                    (R(), ie(yt(ge.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : G("v-if", !0)
              ], 64)) : G("v-if", !0),
              O(H) ? (R(), ie(O(Fe), {
                key: 1,
                class: L([O(g).e("icon"), O(g).e("clear")]),
                onMousedown: Le(O(Xt), ["prevent"]),
                onClick: ti
              }, {
                default: Y(() => [
                  K(O(ah))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : G("v-if", !0),
              O(oe) ? (R(), ie(O(Fe), {
                key: 2,
                class: L([O(g).e("icon"), O(g).e("password")]),
                onClick: di
              }, {
                default: Y(() => [
                  (R(), ie(yt(O(A))))
                ]),
                _: 1
              }, 8, ["class"])) : G("v-if", !0),
              O(te) ? (R(), V("span", {
                key: 3,
                class: L(O(g).e("count"))
              }, [
                Z("span", {
                  class: L(O(g).e("count-inner"))
                }, xe(O(W)) + " / " + xe(ge.maxlength), 3)
              ], 2)) : G("v-if", !0),
              O(I) && O(P) && O(B) ? (R(), ie(O(Fe), {
                key: 4,
                class: L([
                  O(g).e("icon"),
                  O(g).e("validateIcon"),
                  O(g).is("loading", O(I) === "validating")
                ])
              }, {
                default: Y(() => [
                  (R(), ie(yt(O(P))))
                ]),
                _: 1
              }, 8, ["class"])) : G("v-if", !0)
            ], 2)
          ], 2)) : G("v-if", !0)
        ], 2),
        G(" append slot "),
        ge.$slots.append ? (R(), V("div", {
          key: 1,
          class: L(O(g).be("group", "append"))
        }, [
          de(ge.$slots, "append")
        ], 2)) : G("v-if", !0)
      ], 64)) : (R(), V(Tt, { key: 1 }, [
        G(" textarea "),
        Z("textarea", Pi({
          id: O(d),
          ref_key: "textarea",
          ref: y,
          class: O(m).e("inner")
        }, O(c), {
          minlength: ge.minlength,
          maxlength: ge.maxlength,
          tabindex: ge.tabindex,
          disabled: O(p),
          readonly: ge.readonly,
          autocomplete: ge.autocomplete,
          style: O(q),
          "aria-label": ge.label,
          placeholder: ge.placeholder,
          form: ge.form,
          autofocus: ge.autofocus,
          onCompositionstart: Jn,
          onCompositionupdate: ei,
          onCompositionend: Li,
          onInput: ut,
          onFocus: Ke[2] || (Ke[2] = (...Dt) => O(_) && O(_)(...Dt)),
          onBlur: Ke[3] || (Ke[3] = (...Dt) => O(T) && O(T)(...Dt)),
          onChange: zt,
          onKeydown: Ui
        }), null, 16, m7),
        O(te) ? (R(), V("span", {
          key: 0,
          style: Qe(S.value),
          class: L(O(g).e("count"))
        }, xe(O(W)) + " / " + xe(ge.maxlength), 7)) : G("v-if", !0)
      ], 64))
    ], 16, p7)), [
      [Qt, ge.type !== "hidden"]
    ]);
  }
});
var y7 = /* @__PURE__ */ Ce(b7, [["__file", "input.vue"]]);
const uc = Ft(y7), wc = 4, IT = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, O7 = ({
  move: n,
  size: e,
  bar: t
}) => ({
  [t.size]: e,
  transform: `translate${t.axis}(${n}%)`
}), vw = Symbol("scrollbarContextKey"), w7 = Ee({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), x7 = "Thumb", S7 = /* @__PURE__ */ F({
  __name: "thumb",
  props: w7,
  setup(n) {
    const e = n, t = ke(vw), i = me("scrollbar");
    t || dr(x7, "can not inject scrollbar context");
    const r = D(), s = D(), o = D({}), a = D(!1);
    let l = !1, c = !1, u = vt ? document.onselectstart : null;
    const h = $(() => IT[e.vertical ? "vertical" : "horizontal"]), d = $(() => O7({
      size: e.size,
      move: e.move,
      bar: h.value
    })), f = $(() => r.value[h.value.offset] ** 2 / t.wrapElement[h.value.scrollSize] / e.ratio / s.value[h.value.offset]), p = (S) => {
      var C;
      if (S.stopPropagation(), S.ctrlKey || [1, 2].includes(S.button))
        return;
      (C = window.getSelection()) == null || C.removeAllRanges(), m(S);
      const k = S.currentTarget;
      k && (o.value[h.value.axis] = k[h.value.offset] - (S[h.value.client] - k.getBoundingClientRect()[h.value.direction]));
    }, g = (S) => {
      if (!s.value || !r.value || !t.wrapElement)
        return;
      const C = Math.abs(S.target.getBoundingClientRect()[h.value.direction] - S[h.value.client]), k = s.value[h.value.offset] / 2, E = (C - k) * 100 * f.value / r.value[h.value.offset];
      t.wrapElement[h.value.scroll] = E * t.wrapElement[h.value.scrollSize] / 100;
    }, m = (S) => {
      S.stopImmediatePropagation(), l = !0, document.addEventListener("mousemove", v), document.addEventListener("mouseup", y), u = document.onselectstart, document.onselectstart = () => !1;
    }, v = (S) => {
      if (!r.value || !s.value || l === !1)
        return;
      const C = o.value[h.value.axis];
      if (!C)
        return;
      const k = (r.value.getBoundingClientRect()[h.value.direction] - S[h.value.client]) * -1, E = s.value[h.value.offset] - C, M = (k - E) * 100 * f.value / r.value[h.value.offset];
      t.wrapElement[h.value.scroll] = M * t.wrapElement[h.value.scrollSize] / 100;
    }, y = () => {
      l = !1, o.value[h.value.axis] = 0, document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", y), x(), c && (a.value = !1);
    }, b = () => {
      c = !1, a.value = !!e.size;
    }, w = () => {
      c = !0, a.value = l;
    };
    Kn(() => {
      x(), document.removeEventListener("mouseup", y);
    });
    const x = () => {
      document.onselectstart !== u && (document.onselectstart = u);
    };
    return qi(Pr(t, "scrollbarElement"), "mousemove", b), qi(Pr(t, "scrollbarElement"), "mouseleave", w), (S, C) => (R(), ie(bo, {
      name: O(i).b("fade"),
      persisted: ""
    }, {
      default: Y(() => [
        it(Z("div", {
          ref_key: "instance",
          ref: r,
          class: L([O(i).e("bar"), O(i).is(O(h).key)]),
          onMousedown: g
        }, [
          Z("div", {
            ref_key: "thumb",
            ref: s,
            class: L(O(i).e("thumb")),
            style: Qe(O(d)),
            onMousedown: p
          }, null, 38)
        ], 34), [
          [Qt, S.always || a.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var TC = /* @__PURE__ */ Ce(S7, [["__file", "thumb.vue"]]);
const C7 = Ee({
  always: {
    type: Boolean,
    default: !0
  },
  minSize: {
    type: Number,
    required: !0
  }
}), k7 = /* @__PURE__ */ F({
  __name: "bar",
  props: C7,
  setup(n, { expose: e }) {
    const t = n, i = ke(vw), r = D(0), s = D(0), o = D(""), a = D(""), l = D(1), c = D(1);
    return e({
      handleScroll: (d) => {
        if (d) {
          const f = d.offsetHeight - wc, p = d.offsetWidth - wc;
          s.value = d.scrollTop * 100 / f * l.value, r.value = d.scrollLeft * 100 / p * c.value;
        }
      },
      update: () => {
        const d = i == null ? void 0 : i.wrapElement;
        if (!d)
          return;
        const f = d.offsetHeight - wc, p = d.offsetWidth - wc, g = f ** 2 / d.scrollHeight, m = p ** 2 / d.scrollWidth, v = Math.max(g, t.minSize), y = Math.max(m, t.minSize);
        l.value = g / (f - g) / (v / (f - v)), c.value = m / (p - m) / (y / (p - y)), a.value = v + wc < f ? `${v}px` : "", o.value = y + wc < p ? `${y}px` : "";
      }
    }), (d, f) => (R(), V(Tt, null, [
      K(TC, {
        move: r.value,
        ratio: c.value,
        size: o.value,
        always: d.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      K(TC, {
        move: s.value,
        ratio: l.value,
        size: a.value,
        vertical: "",
        always: d.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var P7 = /* @__PURE__ */ Ce(k7, [["__file", "bar.vue"]]);
const E7 = Ee({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: ce([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
}), A7 = {
  scroll: ({
    scrollTop: n,
    scrollLeft: e
  }) => [n, e].every(tt)
}, uy = "ElScrollbar", $7 = F({
  name: uy
}), T7 = /* @__PURE__ */ F({
  ...$7,
  props: E7,
  emits: A7,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = me("scrollbar");
    let s, o;
    const a = D(), l = D(), c = D(), u = D(), h = $(() => {
      const b = {};
      return i.height && (b.height = ur(i.height)), i.maxHeight && (b.maxHeight = ur(i.maxHeight)), [i.wrapStyle, b];
    }), d = $(() => [
      i.wrapClass,
      r.e("wrap"),
      { [r.em("wrap", "hidden-default")]: !i.native }
    ]), f = $(() => [r.e("view"), i.viewClass]), p = () => {
      var b;
      l.value && ((b = u.value) == null || b.handleScroll(l.value), t("scroll", {
        scrollTop: l.value.scrollTop,
        scrollLeft: l.value.scrollLeft
      }));
    };
    function g(b, w) {
      an(b) ? l.value.scrollTo(b) : tt(b) && tt(w) && l.value.scrollTo(b, w);
    }
    const m = (b) => {
      if (!tt(b)) {
        pt(uy, "value must be a number");
        return;
      }
      l.value.scrollTop = b;
    }, v = (b) => {
      if (!tt(b)) {
        pt(uy, "value must be a number");
        return;
      }
      l.value.scrollLeft = b;
    }, y = () => {
      var b;
      (b = u.value) == null || b.update();
    };
    return ne(() => i.noresize, (b) => {
      b ? (s == null || s(), o == null || o()) : ({ stop: s } = pn(c, y), o = qi("resize", y));
    }, { immediate: !0 }), ne(() => [i.maxHeight, i.height], () => {
      i.native || $e(() => {
        var b;
        y(), l.value && ((b = u.value) == null || b.handleScroll(l.value));
      });
    }), ft(vw, Gt({
      scrollbarElement: a,
      wrapElement: l
    })), qe(() => {
      i.native || $e(() => {
        y();
      });
    }), Ya(() => y()), e({
      wrapRef: l,
      update: y,
      scrollTo: g,
      setScrollTop: m,
      setScrollLeft: v,
      handleScroll: p
    }), (b, w) => (R(), V("div", {
      ref_key: "scrollbarRef",
      ref: a,
      class: L(O(r).b())
    }, [
      Z("div", {
        ref_key: "wrapRef",
        ref: l,
        class: L(O(d)),
        style: Qe(O(h)),
        onScroll: p
      }, [
        (R(), ie(yt(b.tag), {
          id: b.id,
          ref_key: "resizeRef",
          ref: c,
          class: L(O(f)),
          style: Qe(b.viewStyle),
          role: b.role,
          "aria-label": b.ariaLabel,
          "aria-orientation": b.ariaOrientation
        }, {
          default: Y(() => [
            de(b.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      b.native ? G("v-if", !0) : (R(), ie(P7, {
        key: 0,
        ref_key: "barRef",
        ref: u,
        always: b.always,
        "min-size": b.minSize
      }, null, 8, ["always", "min-size"]))
    ], 2));
  }
});
var _7 = /* @__PURE__ */ Ce(T7, [["__file", "scrollbar.vue"]]);
const _f = Ft(_7), bw = Symbol("popper"), BT = Symbol("popperContent"), M7 = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], QT = Ee({
  role: {
    type: String,
    values: M7,
    default: "tooltip"
  }
}), R7 = F({
  name: "ElPopper",
  inheritAttrs: !1
}), N7 = /* @__PURE__ */ F({
  ...R7,
  props: QT,
  setup(n, { expose: e }) {
    const t = n, i = D(), r = D(), s = D(), o = D(), a = $(() => t.role), l = {
      triggerRef: i,
      popperInstanceRef: r,
      contentRef: s,
      referenceRef: o,
      role: a
    };
    return e(l), ft(bw, l), (c, u) => de(c.$slots, "default");
  }
});
var D7 = /* @__PURE__ */ Ce(N7, [["__file", "popper.vue"]]);
const zT = Ee({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), L7 = F({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), I7 = /* @__PURE__ */ F({
  ...L7,
  props: zT,
  setup(n, { expose: e }) {
    const t = n, i = me("popper"), { arrowOffset: r, arrowRef: s, arrowStyle: o } = ke(BT, void 0);
    return ne(() => t.arrowOffset, (a) => {
      r.value = a;
    }), Kn(() => {
      s.value = void 0;
    }), e({
      arrowRef: s
    }), (a, l) => (R(), V("span", {
      ref_key: "arrowRef",
      ref: s,
      class: L(O(i).e("arrow")),
      style: Qe(O(o)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var B7 = /* @__PURE__ */ Ce(I7, [["__file", "arrow.vue"]]);
const S0 = "ElOnlyChild", Q7 = F({
  name: S0,
  setup(n, {
    slots: e,
    attrs: t
  }) {
    var i;
    const r = ke(TT), s = Bq((i = r == null ? void 0 : r.setForwardRef) != null ? i : Xt);
    return () => {
      var o;
      const a = (o = e.default) == null ? void 0 : o.call(e, t);
      if (!a)
        return null;
      if (a.length > 1)
        return pt(S0, "requires exact only one valid child."), null;
      const l = jT(a);
      return l ? it(TL(l, t), [[s]]) : (pt(S0, "no valid child node found"), null);
    };
  }
});
function jT(n) {
  if (!n)
    return null;
  const e = n;
  for (const t of e) {
    if (an(t))
      switch (t.type) {
        case wA:
          continue;
        case OA:
        case "svg":
          return _C(t);
        case Tt:
          return jT(t.children);
        default:
          return t;
      }
    return _C(t);
  }
  return null;
}
function _C(n) {
  const e = me("only-child");
  return K("span", {
    class: e.e("content")
  }, [n]);
}
const VT = Ee({
  virtualRef: {
    type: ce(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: ce(Function)
  },
  onMouseleave: {
    type: ce(Function)
  },
  onClick: {
    type: ce(Function)
  },
  onKeydown: {
    type: ce(Function)
  },
  onFocus: {
    type: ce(Function)
  },
  onBlur: {
    type: ce(Function)
  },
  onContextmenu: {
    type: ce(Function)
  },
  id: String,
  open: Boolean
}), z7 = F({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), j7 = /* @__PURE__ */ F({
  ...z7,
  props: VT,
  setup(n, { expose: e }) {
    const t = n, { role: i, triggerRef: r } = ke(bw, void 0);
    Iq(r);
    const s = $(() => a.value ? t.id : void 0), o = $(() => {
      if (i && i.value === "tooltip")
        return t.open && t.id ? t.id : void 0;
    }), a = $(() => {
      if (i && i.value !== "tooltip")
        return i.value;
    }), l = $(() => a.value ? `${t.open}` : void 0);
    let c;
    return qe(() => {
      ne(() => t.virtualRef, (u) => {
        u && (r.value = Gs(u));
      }, {
        immediate: !0
      }), ne(r, (u, h) => {
        c == null || c(), c = void 0, Os(u) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((d) => {
          var f;
          const p = t[d];
          p && (u.addEventListener(d.slice(2).toLowerCase(), p), (f = h == null ? void 0 : h.removeEventListener) == null || f.call(h, d.slice(2).toLowerCase(), p));
        }), c = ne([s, o, a, l], (d) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((f, p) => {
            Ni(d[p]) ? u.removeAttribute(f) : u.setAttribute(f, d[p]);
          });
        }, { immediate: !0 })), Os(h) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((d) => h.removeAttribute(d));
      }, {
        immediate: !0
      });
    }), Kn(() => {
      c == null || c(), c = void 0;
    }), e({
      triggerRef: r
    }), (u, h) => u.virtualTriggering ? G("v-if", !0) : (R(), ie(O(Q7), Pi({ key: 0 }, u.$attrs, {
      "aria-controls": O(s),
      "aria-describedby": O(o),
      "aria-expanded": O(l),
      "aria-haspopup": O(a)
    }), {
      default: Y(() => [
        de(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var V7 = /* @__PURE__ */ Ce(j7, [["__file", "trigger.vue"]]);
const C0 = "focus-trap.focus-after-trapped", k0 = "focus-trap.focus-after-released", F7 = "focus-trap.focusout-prevented", MC = {
  cancelable: !0,
  bubbles: !1
}, Z7 = {
  cancelable: !0,
  bubbles: !1
}, RC = "focusAfterTrapped", NC = "focusAfterReleased", FT = Symbol("elFocusTrap"), yw = D(), bv = D(0), Ow = D(0);
let ap = 0;
const ZT = (n) => {
  const e = [], t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (i) => {
      const r = i.tagName === "INPUT" && i.type === "hidden";
      return i.disabled || i.hidden || r ? NodeFilter.FILTER_SKIP : i.tabIndex >= 0 || i === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; t.nextNode(); )
    e.push(t.currentNode);
  return e;
}, DC = (n, e) => {
  for (const t of n)
    if (!q7(t, e))
      return t;
}, q7 = (n, e) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(n).visibility === "hidden")
    return !0;
  for (; n; ) {
    if (e && n === e)
      return !1;
    if (getComputedStyle(n).display === "none")
      return !0;
    n = n.parentElement;
  }
  return !1;
}, W7 = (n) => {
  const e = ZT(n), t = DC(e, n), i = DC(e.reverse(), n);
  return [t, i];
}, H7 = (n) => n instanceof HTMLInputElement && "select" in n, la = (n, e) => {
  if (n && n.focus) {
    const t = document.activeElement;
    n.focus({ preventScroll: !0 }), Ow.value = window.performance.now(), n !== t && H7(n) && e && n.select();
  }
};
function LC(n, e) {
  const t = [...n], i = n.indexOf(e);
  return i !== -1 && t.splice(i, 1), t;
}
const X7 = () => {
  let n = [];
  return {
    push: (i) => {
      const r = n[0];
      r && i !== r && r.pause(), n = LC(n, i), n.unshift(i);
    },
    remove: (i) => {
      var r, s;
      n = LC(n, i), (s = (r = n[0]) == null ? void 0 : r.resume) == null || s.call(r);
    }
  };
}, Y7 = (n, e = !1) => {
  const t = document.activeElement;
  for (const i of n)
    if (la(i, e), document.activeElement !== t)
      return;
}, IC = X7(), U7 = () => bv.value > Ow.value, lp = () => {
  yw.value = "pointer", bv.value = window.performance.now();
}, BC = () => {
  yw.value = "keyboard", bv.value = window.performance.now();
}, G7 = () => (qe(() => {
  ap === 0 && (document.addEventListener("mousedown", lp), document.addEventListener("touchstart", lp), document.addEventListener("keydown", BC)), ap++;
}), Kn(() => {
  ap--, ap <= 0 && (document.removeEventListener("mousedown", lp), document.removeEventListener("touchstart", lp), document.removeEventListener("keydown", BC));
}), {
  focusReason: yw,
  lastUserFocusTimestamp: bv,
  lastAutomatedFocusTimestamp: Ow
}), cp = (n) => new CustomEvent(F7, {
  ...Z7,
  detail: n
}), K7 = F({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    RC,
    NC,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(n, { emit: e }) {
    const t = D();
    let i, r;
    const { focusReason: s } = G7();
    Mq((p) => {
      n.trapped && !o.paused && e("release-requested", p);
    });
    const o = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, a = (p) => {
      if (!n.loop && !n.trapped || o.paused)
        return;
      const { key: g, altKey: m, ctrlKey: v, metaKey: y, currentTarget: b, shiftKey: w } = p, { loop: x } = n, S = g === dt.tab && !m && !v && !y, C = document.activeElement;
      if (S && C) {
        const k = b, [E, M] = W7(k);
        if (E && M) {
          if (!w && C === M) {
            const T = cp({
              focusReason: s.value
            });
            e("focusout-prevented", T), T.defaultPrevented || (p.preventDefault(), x && la(E, !0));
          } else if (w && [E, k].includes(C)) {
            const T = cp({
              focusReason: s.value
            });
            e("focusout-prevented", T), T.defaultPrevented || (p.preventDefault(), x && la(M, !0));
          }
        } else if (C === k) {
          const T = cp({
            focusReason: s.value
          });
          e("focusout-prevented", T), T.defaultPrevented || p.preventDefault();
        }
      }
    };
    ft(FT, {
      focusTrapRef: t,
      onKeydown: a
    }), ne(() => n.focusTrapEl, (p) => {
      p && (t.value = p);
    }, { immediate: !0 }), ne([t], ([p], [g]) => {
      p && (p.addEventListener("keydown", a), p.addEventListener("focusin", u), p.addEventListener("focusout", h)), g && (g.removeEventListener("keydown", a), g.removeEventListener("focusin", u), g.removeEventListener("focusout", h));
    });
    const l = (p) => {
      e(RC, p);
    }, c = (p) => e(NC, p), u = (p) => {
      const g = O(t);
      if (!g)
        return;
      const m = p.target, v = p.relatedTarget, y = m && g.contains(m);
      n.trapped || v && g.contains(v) || (i = v), y && e("focusin", p), !o.paused && n.trapped && (y ? r = m : la(r, !0));
    }, h = (p) => {
      const g = O(t);
      if (!(o.paused || !g))
        if (n.trapped) {
          const m = p.relatedTarget;
          !Ni(m) && !g.contains(m) && setTimeout(() => {
            if (!o.paused && n.trapped) {
              const v = cp({
                focusReason: s.value
              });
              e("focusout-prevented", v), v.defaultPrevented || la(r, !0);
            }
          }, 0);
        } else {
          const m = p.target;
          m && g.contains(m) || e("focusout", p);
        }
    };
    async function d() {
      await $e();
      const p = O(t);
      if (p) {
        IC.push(o);
        const g = p.contains(document.activeElement) ? i : document.activeElement;
        if (i = g, !p.contains(g)) {
          const v = new Event(C0, MC);
          p.addEventListener(C0, l), p.dispatchEvent(v), v.defaultPrevented || $e(() => {
            let y = n.focusStartEl;
            bt(y) || (la(y), document.activeElement !== y && (y = "first")), y === "first" && Y7(ZT(p), !0), (document.activeElement === g || y === "container") && la(p);
          });
        }
      }
    }
    function f() {
      const p = O(t);
      if (p) {
        p.removeEventListener(C0, l);
        const g = new CustomEvent(k0, {
          ...MC,
          detail: {
            focusReason: s.value
          }
        });
        p.addEventListener(k0, c), p.dispatchEvent(g), !g.defaultPrevented && (s.value == "keyboard" || !U7() || p.contains(document.activeElement)) && la(i ?? document.body), p.removeEventListener(k0, c), IC.remove(o);
      }
    }
    return qe(() => {
      n.trapped && d(), ne(() => n.trapped, (p) => {
        p ? d() : f();
      });
    }), Kn(() => {
      n.trapped && f();
    }), {
      onKeydown: a
    };
  }
});
function J7(n, e, t, i, r, s) {
  return de(n.$slots, "default", { handleKeydown: n.onKeydown });
}
var yv = /* @__PURE__ */ Ce(K7, [["render", J7], ["__file", "focus-trap.vue"]]);
const e9 = ["fixed", "absolute"], t9 = Ee({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: ce(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: $f,
    default: "bottom"
  },
  popperOptions: {
    type: ce(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: e9,
    default: "absolute"
  }
}), qT = Ee({
  ...t9,
  id: String,
  style: {
    type: ce([String, Array, Object])
  },
  className: {
    type: ce([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: ce([String, Array, Object])
  },
  popperStyle: {
    type: ce([String, Array, Object])
  },
  referenceEl: {
    type: ce(Object)
  },
  triggerTargetEl: {
    type: ce(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), n9 = {
  mouseenter: (n) => n instanceof MouseEvent,
  mouseleave: (n) => n instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, i9 = (n, e = []) => {
  const { placement: t, strategy: i, popperOptions: r } = n, s = {
    placement: t,
    strategy: i,
    ...r,
    modifiers: [...s9(n), ...e]
  };
  return o9(s, r == null ? void 0 : r.modifiers), s;
}, r9 = (n) => {
  if (vt)
    return Gs(n);
};
function s9(n) {
  const { offset: e, gpuAcceleration: t, fallbackPlacements: i } = n;
  return [
    {
      name: "offset",
      options: {
        offset: [0, e ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: i
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: t
      }
    }
  ];
}
function o9(n, e) {
  e && (n.modifiers = [...n.modifiers, ...e ?? []]);
}
const a9 = 0, l9 = (n) => {
  const { popperInstanceRef: e, contentRef: t, triggerRef: i, role: r } = ke(bw, void 0), s = D(), o = D(), a = $(() => ({
    name: "eventListeners",
    enabled: !!n.visible
  })), l = $(() => {
    var v;
    const y = O(s), b = (v = O(o)) != null ? v : a9;
    return {
      name: "arrow",
      enabled: !_$(y),
      options: {
        element: y,
        padding: b
      }
    };
  }), c = $(() => ({
    onFirstUpdate: () => {
      p();
    },
    ...i9(n, [
      O(l),
      O(a)
    ])
  })), u = $(() => r9(n.referenceEl) || O(i)), { attributes: h, state: d, styles: f, update: p, forceUpdate: g, instanceRef: m } = $q(u, t, c);
  return ne(m, (v) => e.value = v), qe(() => {
    ne(() => {
      var v;
      return (v = O(u)) == null ? void 0 : v.getBoundingClientRect();
    }, () => {
      p();
    });
  }), {
    attributes: h,
    arrowRef: s,
    contentRef: t,
    instanceRef: m,
    state: d,
    styles: f,
    role: r,
    forceUpdate: g,
    update: p
  };
}, c9 = (n, {
  attributes: e,
  styles: t,
  role: i
}) => {
  const { nextZIndex: r } = gw(), s = me("popper"), o = $(() => O(e).popper), a = D(tt(n.zIndex) ? n.zIndex : r()), l = $(() => [
    s.b(),
    s.is("pure", n.pure),
    s.is(n.effect),
    n.popperClass
  ]), c = $(() => [
    { zIndex: O(a) },
    O(t).popper,
    n.popperStyle || {}
  ]), u = $(() => i.value === "dialog" ? "false" : void 0), h = $(() => O(t).arrow || {});
  return {
    ariaModal: u,
    arrowStyle: h,
    contentAttrs: o,
    contentClass: l,
    contentStyle: c,
    contentZIndex: a,
    updateZIndex: () => {
      a.value = tt(n.zIndex) ? n.zIndex : r();
    }
  };
}, u9 = (n, e) => {
  const t = D(!1), i = D();
  return {
    focusStartRef: i,
    trapped: t,
    onFocusAfterReleased: (c) => {
      var u;
      ((u = c.detail) == null ? void 0 : u.focusReason) !== "pointer" && (i.value = "first", e("blur"));
    },
    onFocusAfterTrapped: () => {
      e("focus");
    },
    onFocusInTrap: (c) => {
      n.visible && !t.value && (c.target && (i.value = c.target), t.value = !0);
    },
    onFocusoutPrevented: (c) => {
      n.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), t.value = !1);
    },
    onReleaseRequested: () => {
      t.value = !1, e("close");
    }
  };
}, h9 = F({
  name: "ElPopperContent"
}), d9 = /* @__PURE__ */ F({
  ...h9,
  props: qT,
  emits: n9,
  setup(n, { expose: e, emit: t }) {
    const i = n, {
      focusStartRef: r,
      trapped: s,
      onFocusAfterReleased: o,
      onFocusAfterTrapped: a,
      onFocusInTrap: l,
      onFocusoutPrevented: c,
      onReleaseRequested: u
    } = u9(i, t), { attributes: h, arrowRef: d, contentRef: f, styles: p, instanceRef: g, role: m, update: v } = l9(i), {
      ariaModal: y,
      arrowStyle: b,
      contentAttrs: w,
      contentClass: x,
      contentStyle: S,
      updateZIndex: C
    } = c9(i, {
      styles: p,
      attributes: h,
      role: m
    }), k = ke(Da, void 0), E = D();
    ft(BT, {
      arrowStyle: b,
      arrowRef: d,
      arrowOffset: E
    }), k && (k.addInputId || k.removeInputId) && ft(Da, {
      ...k,
      addInputId: Xt,
      removeInputId: Xt
    });
    let M;
    const _ = (B = !0) => {
      v(), B && C();
    }, T = () => {
      _(!1), i.visible && i.focusOnShow ? s.value = !0 : i.visible === !1 && (s.value = !1);
    };
    return qe(() => {
      ne(() => i.triggerTargetEl, (B, I) => {
        M == null || M(), M = void 0;
        const P = O(B || f.value), A = O(I || f.value);
        Os(P) && (M = ne([m, () => i.ariaLabel, y, () => i.id], (N) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((q, j) => {
            Ni(N[j]) ? P.removeAttribute(q) : P.setAttribute(q, N[j]);
          });
        }, { immediate: !0 })), A !== P && Os(A) && ["role", "aria-label", "aria-modal", "id"].forEach((N) => {
          A.removeAttribute(N);
        });
      }, { immediate: !0 }), ne(() => i.visible, T, { immediate: !0 });
    }), Kn(() => {
      M == null || M(), M = void 0;
    }), e({
      popperContentRef: f,
      popperInstanceRef: g,
      updatePopper: _,
      contentStyle: S
    }), (B, I) => (R(), V("div", Pi({
      ref_key: "contentRef",
      ref: f
    }, O(w), {
      style: O(S),
      class: O(x),
      tabindex: "-1",
      onMouseenter: I[0] || (I[0] = (P) => B.$emit("mouseenter", P)),
      onMouseleave: I[1] || (I[1] = (P) => B.$emit("mouseleave", P))
    }), [
      K(O(yv), {
        trapped: O(s),
        "trap-on-focus-in": !0,
        "focus-trap-el": O(f),
        "focus-start-el": O(r),
        onFocusAfterTrapped: O(a),
        onFocusAfterReleased: O(o),
        onFocusin: O(l),
        onFocusoutPrevented: O(c),
        onReleaseRequested: O(u)
      }, {
        default: Y(() => [
          de(B.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var f9 = /* @__PURE__ */ Ce(d9, [["__file", "content.vue"]]);
const p9 = Ft(D7), ww = Symbol("elTooltip"), mi = Ee({
  ...Dq,
  ...qT,
  appendTo: {
    type: ce([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: ce(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), Ld = Ee({
  ...VT,
  disabled: Boolean,
  trigger: {
    type: ce([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: ce(Array),
    default: () => [dt.enter, dt.space]
  }
}), {
  useModelToggleProps: g9,
  useModelToggleEmits: m9,
  useModelToggle: v9
} = mT("visible"), b9 = Ee({
  ...QT,
  ...g9,
  ...mi,
  ...Ld,
  ...zT,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), y9 = [
  ...m9,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], O9 = (n, e) => xt(n) ? n.includes(e) : n === e, xc = (n, e, t) => (i) => {
  O9(O(n), e) && t(i);
}, w9 = F({
  name: "ElTooltipTrigger"
}), x9 = /* @__PURE__ */ F({
  ...w9,
  props: Ld,
  setup(n, { expose: e }) {
    const t = n, i = me("tooltip"), { controlled: r, id: s, open: o, onOpen: a, onClose: l, onToggle: c } = ke(ww, void 0), u = D(null), h = () => {
      if (O(r) || t.disabled)
        return !0;
    }, d = Pr(t, "trigger"), f = Eo(h, xc(d, "hover", a)), p = Eo(h, xc(d, "hover", l)), g = Eo(h, xc(d, "click", (w) => {
      w.button === 0 && c(w);
    })), m = Eo(h, xc(d, "focus", a)), v = Eo(h, xc(d, "focus", l)), y = Eo(h, xc(d, "contextmenu", (w) => {
      w.preventDefault(), c(w);
    })), b = Eo(h, (w) => {
      const { code: x } = w;
      t.triggerKeys.includes(x) && (w.preventDefault(), c(w));
    });
    return e({
      triggerRef: u
    }), (w, x) => (R(), ie(O(V7), {
      id: O(s),
      "virtual-ref": w.virtualRef,
      open: O(o),
      "virtual-triggering": w.virtualTriggering,
      class: L(O(i).e("trigger")),
      onBlur: O(v),
      onClick: O(g),
      onContextmenu: O(y),
      onFocus: O(m),
      onMouseenter: O(f),
      onMouseleave: O(p),
      onKeydown: O(b)
    }, {
      default: Y(() => [
        de(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var S9 = /* @__PURE__ */ Ce(x9, [["__file", "trigger.vue"]]);
const C9 = F({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), k9 = /* @__PURE__ */ F({
  ...C9,
  props: mi,
  setup(n, { expose: e }) {
    const t = n, { selector: i } = $T(), r = me("tooltip"), s = D(null), o = D(!1), {
      controlled: a,
      id: l,
      open: c,
      trigger: u,
      onClose: h,
      onOpen: d,
      onShow: f,
      onHide: p,
      onBeforeShow: g,
      onBeforeHide: m
    } = ke(ww, void 0), v = $(() => t.transition || `${r.namespace.value}-fade-in-linear`), y = $(() => process.env.NODE_ENV === "test" ? !0 : t.persistent);
    Kn(() => {
      o.value = !0;
    });
    const b = $(() => O(y) ? !0 : O(c)), w = $(() => t.disabled ? !1 : O(c)), x = $(() => t.appendTo || i.value), S = $(() => {
      var N;
      return (N = t.style) != null ? N : {};
    }), C = $(() => !O(c)), k = () => {
      p();
    }, E = () => {
      if (O(a))
        return !0;
    }, M = Eo(E, () => {
      t.enterable && O(u) === "hover" && d();
    }), _ = Eo(E, () => {
      O(u) === "hover" && h();
    }), T = () => {
      var N, q;
      (q = (N = s.value) == null ? void 0 : N.updatePopper) == null || q.call(N), g == null || g();
    }, B = () => {
      m == null || m();
    }, I = () => {
      f(), A = CF($(() => {
        var N;
        return (N = s.value) == null ? void 0 : N.popperContentRef;
      }), () => {
        if (O(a))
          return;
        O(u) !== "hover" && h();
      });
    }, P = () => {
      t.virtualTriggering || h();
    };
    let A;
    return ne(() => O(c), (N) => {
      N || A == null || A();
    }, {
      flush: "post"
    }), ne(() => t.content, () => {
      var N, q;
      (q = (N = s.value) == null ? void 0 : N.updatePopper) == null || q.call(N);
    }), e({
      contentRef: s
    }), (N, q) => (R(), ie(tv, {
      disabled: !N.teleported,
      to: O(x)
    }, [
      K(bo, {
        name: O(v),
        onAfterLeave: k,
        onBeforeEnter: T,
        onAfterEnter: I,
        onBeforeLeave: B
      }, {
        default: Y(() => [
          O(b) ? it((R(), ie(O(f9), Pi({
            key: 0,
            id: O(l),
            ref_key: "contentRef",
            ref: s
          }, N.$attrs, {
            "aria-label": N.ariaLabel,
            "aria-hidden": O(C),
            "boundaries-padding": N.boundariesPadding,
            "fallback-placements": N.fallbackPlacements,
            "gpu-acceleration": N.gpuAcceleration,
            offset: N.offset,
            placement: N.placement,
            "popper-options": N.popperOptions,
            strategy: N.strategy,
            effect: N.effect,
            enterable: N.enterable,
            pure: N.pure,
            "popper-class": N.popperClass,
            "popper-style": [N.popperStyle, O(S)],
            "reference-el": N.referenceEl,
            "trigger-target-el": N.triggerTargetEl,
            visible: O(w),
            "z-index": N.zIndex,
            onMouseenter: O(M),
            onMouseleave: O(_),
            onBlur: P,
            onClose: O(h)
          }), {
            default: Y(() => [
              o.value ? G("v-if", !0) : de(N.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [Qt, O(w)]
          ]) : G("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var P9 = /* @__PURE__ */ Ce(k9, [["__file", "content.vue"]]);
const E9 = ["innerHTML"], A9 = { key: 1 }, $9 = F({
  name: "ElTooltip"
}), T9 = /* @__PURE__ */ F({
  ...$9,
  props: b9,
  emits: y9,
  setup(n, { expose: e, emit: t }) {
    const i = n;
    Nq();
    const r = ws(), s = D(), o = D(), a = () => {
      var v;
      const y = O(s);
      y && ((v = y.popperInstanceRef) == null || v.update());
    }, l = D(!1), c = D(), { show: u, hide: h, hasUpdateHandler: d } = v9({
      indicator: l,
      toggleReason: c
    }), { onOpen: f, onClose: p } = Lq({
      showAfter: Pr(i, "showAfter"),
      hideAfter: Pr(i, "hideAfter"),
      autoClose: Pr(i, "autoClose"),
      open: u,
      close: h
    }), g = $(() => Ei(i.visible) && !d.value);
    ft(ww, {
      controlled: g,
      id: r,
      open: R1(l),
      trigger: Pr(i, "trigger"),
      onOpen: (v) => {
        f(v);
      },
      onClose: (v) => {
        p(v);
      },
      onToggle: (v) => {
        O(l) ? p(v) : f(v);
      },
      onShow: () => {
        t("show", c.value);
      },
      onHide: () => {
        t("hide", c.value);
      },
      onBeforeShow: () => {
        t("before-show", c.value);
      },
      onBeforeHide: () => {
        t("before-hide", c.value);
      },
      updatePopper: a
    }), ne(() => i.disabled, (v) => {
      v && l.value && (l.value = !1);
    });
    const m = (v) => {
      var y, b;
      const w = (b = (y = o.value) == null ? void 0 : y.contentRef) == null ? void 0 : b.popperContentRef, x = (v == null ? void 0 : v.relatedTarget) || document.activeElement;
      return w && w.contains(x);
    };
    return _L(() => l.value && h()), e({
      popperRef: s,
      contentRef: o,
      isFocusInsideContent: m,
      updatePopper: a,
      onOpen: f,
      onClose: p,
      hide: h
    }), (v, y) => (R(), ie(O(p9), {
      ref_key: "popperRef",
      ref: s,
      role: v.role
    }, {
      default: Y(() => [
        K(S9, {
          disabled: v.disabled,
          trigger: v.trigger,
          "trigger-keys": v.triggerKeys,
          "virtual-ref": v.virtualRef,
          "virtual-triggering": v.virtualTriggering
        }, {
          default: Y(() => [
            v.$slots.default ? de(v.$slots, "default", { key: 0 }) : G("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        K(P9, {
          ref_key: "contentRef",
          ref: o,
          "aria-label": v.ariaLabel,
          "boundaries-padding": v.boundariesPadding,
          content: v.content,
          disabled: v.disabled,
          effect: v.effect,
          enterable: v.enterable,
          "fallback-placements": v.fallbackPlacements,
          "hide-after": v.hideAfter,
          "gpu-acceleration": v.gpuAcceleration,
          offset: v.offset,
          persistent: v.persistent,
          "popper-class": v.popperClass,
          "popper-style": v.popperStyle,
          placement: v.placement,
          "popper-options": v.popperOptions,
          pure: v.pure,
          "raw-content": v.rawContent,
          "reference-el": v.referenceEl,
          "trigger-target-el": v.triggerTargetEl,
          "show-after": v.showAfter,
          strategy: v.strategy,
          teleported: v.teleported,
          transition: v.transition,
          "virtual-triggering": v.virtualTriggering,
          "z-index": v.zIndex,
          "append-to": v.appendTo
        }, {
          default: Y(() => [
            de(v.$slots, "content", {}, () => [
              v.rawContent ? (R(), V("span", {
                key: 0,
                innerHTML: v.content
              }, null, 8, E9)) : (R(), V("span", A9, xe(v.content), 1))
            ]),
            v.showArrow ? (R(), ie(O(B7), {
              key: 0,
              "arrow-offset": v.arrowOffset
            }, null, 8, ["arrow-offset"])) : G("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var _9 = /* @__PURE__ */ Ce(T9, [["__file", "tooltip.vue"]]);
const Fo = Ft(_9), M9 = Ee({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
}), R9 = ["textContent"], N9 = F({
  name: "ElBadge"
}), D9 = /* @__PURE__ */ F({
  ...N9,
  props: M9,
  setup(n, { expose: e }) {
    const t = n, i = me("badge"), r = $(() => t.isDot ? "" : tt(t.value) && tt(t.max) ? t.max < t.value ? `${t.max}+` : `${t.value}` : `${t.value}`);
    return e({
      content: r
    }), (s, o) => (R(), V("div", {
      class: L(O(i).b())
    }, [
      de(s.$slots, "default"),
      K(bo, {
        name: `${O(i).namespace.value}-zoom-in-center`,
        persisted: ""
      }, {
        default: Y(() => [
          it(Z("sup", {
            class: L([
              O(i).e("content"),
              O(i).em("content", s.type),
              O(i).is("fixed", !!s.$slots.default),
              O(i).is("dot", s.isDot)
            ]),
            textContent: xe(O(r))
          }, null, 10, R9), [
            [Qt, !s.hidden && (O(r) || s.isDot)]
          ])
        ]),
        _: 1
      }, 8, ["name"])
    ], 2));
  }
});
var L9 = /* @__PURE__ */ Ce(D9, [["__file", "badge.vue"]]);
const I9 = Ft(L9), WT = Symbol("buttonGroupContextKey"), B9 = (n, e) => {
  ql({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, $(() => n.type === "text"));
  const t = ke(WT, void 0), i = vv("button"), { form: r } = Mr(), s = Yi($(() => t == null ? void 0 : t.size)), o = ts(), a = D(), l = vo(), c = $(() => n.type || (t == null ? void 0 : t.type) || ""), u = $(() => {
    var p, g, m;
    return (m = (g = n.autoInsertSpace) != null ? g : (p = i.value) == null ? void 0 : p.autoInsertSpace) != null ? m : !1;
  }), h = $(() => n.tag === "button" ? {
    ariaDisabled: o.value || n.loading,
    disabled: o.value || n.loading,
    autofocus: n.autofocus,
    type: n.nativeType
  } : {}), d = $(() => {
    var p;
    const g = (p = l.default) == null ? void 0 : p.call(l);
    if (u.value && (g == null ? void 0 : g.length) === 1) {
      const m = g[0];
      if ((m == null ? void 0 : m.type) === OA) {
        const v = m.children;
        return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(v.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: o,
    _size: s,
    _type: c,
    _ref: a,
    _props: h,
    shouldAddSpace: d,
    handleClick: (p) => {
      n.nativeType === "reset" && (r == null || r.resetFields()), e("click", p);
    }
  };
}, hy = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], Q9 = ["button", "submit", "reset"], dy = Ee({
  size: _r,
  disabled: Boolean,
  type: {
    type: String,
    values: hy,
    default: ""
  },
  icon: {
    type: Pn
  },
  nativeType: {
    type: String,
    values: Q9,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: Pn,
    default: () => lc
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: ce([String, Object]),
    default: "button"
  }
}), z9 = {
  click: (n) => n instanceof MouseEvent
};
function Ai(n, e) {
  j9(n) && (n = "100%");
  var t = V9(n);
  return n = e === 360 ? n : Math.min(e, Math.max(0, parseFloat(n))), t && (n = parseInt(String(n * e), 10) / 100), Math.abs(n - e) < 1e-6 ? 1 : (e === 360 ? n = (n < 0 ? n % e + e : n % e) / parseFloat(String(e)) : n = n % e / parseFloat(String(e)), n);
}
function up(n) {
  return Math.min(1, Math.max(0, n));
}
function j9(n) {
  return typeof n == "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function V9(n) {
  return typeof n == "string" && n.indexOf("%") !== -1;
}
function HT(n) {
  return n = parseFloat(n), (isNaN(n) || n < 0 || n > 1) && (n = 1), n;
}
function hp(n) {
  return n <= 1 ? "".concat(Number(n) * 100, "%") : n;
}
function Cl(n) {
  return n.length === 1 ? "0" + n : String(n);
}
function F9(n, e, t) {
  return {
    r: Ai(n, 255) * 255,
    g: Ai(e, 255) * 255,
    b: Ai(t, 255) * 255
  };
}
function QC(n, e, t) {
  n = Ai(n, 255), e = Ai(e, 255), t = Ai(t, 255);
  var i = Math.max(n, e, t), r = Math.min(n, e, t), s = 0, o = 0, a = (i + r) / 2;
  if (i === r)
    o = 0, s = 0;
  else {
    var l = i - r;
    switch (o = a > 0.5 ? l / (2 - i - r) : l / (i + r), i) {
      case n:
        s = (e - t) / l + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - n) / l + 2;
        break;
      case t:
        s = (n - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function P0(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * (6 * t) : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function Z9(n, e, t) {
  var i, r, s;
  if (n = Ai(n, 360), e = Ai(e, 100), t = Ai(t, 100), e === 0)
    r = t, s = t, i = t;
  else {
    var o = t < 0.5 ? t * (1 + e) : t + e - t * e, a = 2 * t - o;
    i = P0(a, o, n + 1 / 3), r = P0(a, o, n), s = P0(a, o, n - 1 / 3);
  }
  return { r: i * 255, g: r * 255, b: s * 255 };
}
function zC(n, e, t) {
  n = Ai(n, 255), e = Ai(e, 255), t = Ai(t, 255);
  var i = Math.max(n, e, t), r = Math.min(n, e, t), s = 0, o = i, a = i - r, l = i === 0 ? 0 : a / i;
  if (i === r)
    s = 0;
  else {
    switch (i) {
      case n:
        s = (e - t) / a + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - n) / a + 2;
        break;
      case t:
        s = (n - e) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function q9(n, e, t) {
  n = Ai(n, 360) * 6, e = Ai(e, 100), t = Ai(t, 100);
  var i = Math.floor(n), r = n - i, s = t * (1 - e), o = t * (1 - r * e), a = t * (1 - (1 - r) * e), l = i % 6, c = [t, o, s, s, a, t][l], u = [a, t, t, o, s, s][l], h = [s, s, a, t, t, o][l];
  return { r: c * 255, g: u * 255, b: h * 255 };
}
function jC(n, e, t, i) {
  var r = [
    Cl(Math.round(n).toString(16)),
    Cl(Math.round(e).toString(16)),
    Cl(Math.round(t).toString(16))
  ];
  return i && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("");
}
function W9(n, e, t, i, r) {
  var s = [
    Cl(Math.round(n).toString(16)),
    Cl(Math.round(e).toString(16)),
    Cl(Math.round(t).toString(16)),
    Cl(H9(i))
  ];
  return r && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function H9(n) {
  return Math.round(parseFloat(n) * 255).toString(16);
}
function VC(n) {
  return mr(n) / 255;
}
function mr(n) {
  return parseInt(n, 16);
}
function X9(n) {
  return {
    r: n >> 16,
    g: (n & 65280) >> 8,
    b: n & 255
  };
}
var fy = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function Y9(n) {
  var e = { r: 0, g: 0, b: 0 }, t = 1, i = null, r = null, s = null, o = !1, a = !1;
  return typeof n == "string" && (n = K9(n)), typeof n == "object" && (Po(n.r) && Po(n.g) && Po(n.b) ? (e = F9(n.r, n.g, n.b), o = !0, a = String(n.r).substr(-1) === "%" ? "prgb" : "rgb") : Po(n.h) && Po(n.s) && Po(n.v) ? (i = hp(n.s), r = hp(n.v), e = q9(n.h, i, r), o = !0, a = "hsv") : Po(n.h) && Po(n.s) && Po(n.l) && (i = hp(n.s), s = hp(n.l), e = Z9(n.h, i, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(n, "a") && (t = n.a)), t = HT(t), {
    ok: o,
    format: n.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: t
  };
}
var U9 = "[-\\+]?\\d+%?", G9 = "[-\\+]?\\d*\\.\\d+%?", Ca = "(?:".concat(G9, ")|(?:").concat(U9, ")"), E0 = "[\\s|\\(]+(".concat(Ca, ")[,|\\s]+(").concat(Ca, ")[,|\\s]+(").concat(Ca, ")\\s*\\)?"), A0 = "[\\s|\\(]+(".concat(Ca, ")[,|\\s]+(").concat(Ca, ")[,|\\s]+(").concat(Ca, ")[,|\\s]+(").concat(Ca, ")\\s*\\)?"), as = {
  CSS_UNIT: new RegExp(Ca),
  rgb: new RegExp("rgb" + E0),
  rgba: new RegExp("rgba" + A0),
  hsl: new RegExp("hsl" + E0),
  hsla: new RegExp("hsla" + A0),
  hsv: new RegExp("hsv" + E0),
  hsva: new RegExp("hsva" + A0),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function K9(n) {
  if (n = n.trim().toLowerCase(), n.length === 0)
    return !1;
  var e = !1;
  if (fy[n])
    n = fy[n], e = !0;
  else if (n === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var t = as.rgb.exec(n);
  return t ? { r: t[1], g: t[2], b: t[3] } : (t = as.rgba.exec(n), t ? { r: t[1], g: t[2], b: t[3], a: t[4] } : (t = as.hsl.exec(n), t ? { h: t[1], s: t[2], l: t[3] } : (t = as.hsla.exec(n), t ? { h: t[1], s: t[2], l: t[3], a: t[4] } : (t = as.hsv.exec(n), t ? { h: t[1], s: t[2], v: t[3] } : (t = as.hsva.exec(n), t ? { h: t[1], s: t[2], v: t[3], a: t[4] } : (t = as.hex8.exec(n), t ? {
    r: mr(t[1]),
    g: mr(t[2]),
    b: mr(t[3]),
    a: VC(t[4]),
    format: e ? "name" : "hex8"
  } : (t = as.hex6.exec(n), t ? {
    r: mr(t[1]),
    g: mr(t[2]),
    b: mr(t[3]),
    format: e ? "name" : "hex"
  } : (t = as.hex4.exec(n), t ? {
    r: mr(t[1] + t[1]),
    g: mr(t[2] + t[2]),
    b: mr(t[3] + t[3]),
    a: VC(t[4] + t[4]),
    format: e ? "name" : "hex8"
  } : (t = as.hex3.exec(n), t ? {
    r: mr(t[1] + t[1]),
    g: mr(t[2] + t[2]),
    b: mr(t[3] + t[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function Po(n) {
  return !!as.CSS_UNIT.exec(String(n));
}
var J9 = (
  /** @class */
  function() {
    function n(e, t) {
      e === void 0 && (e = ""), t === void 0 && (t = {});
      var i;
      if (e instanceof n)
        return e;
      typeof e == "number" && (e = X9(e)), this.originalInput = e;
      var r = Y9(e);
      this.originalInput = e, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (i = t.format) !== null && i !== void 0 ? i : r.format, this.gradientType = t.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok;
    }
    return n.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, n.prototype.isLight = function() {
      return !this.isDark();
    }, n.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
    }, n.prototype.getLuminance = function() {
      var e = this.toRgb(), t, i, r, s = e.r / 255, o = e.g / 255, a = e.b / 255;
      return s <= 0.03928 ? t = s / 12.92 : t = Math.pow((s + 0.055) / 1.055, 2.4), o <= 0.03928 ? i = o / 12.92 : i = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? r = a / 12.92 : r = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * t + 0.7152 * i + 0.0722 * r;
    }, n.prototype.getAlpha = function() {
      return this.a;
    }, n.prototype.setAlpha = function(e) {
      return this.a = HT(e), this.roundA = Math.round(100 * this.a) / 100, this;
    }, n.prototype.isMonochrome = function() {
      var e = this.toHsl().s;
      return e === 0;
    }, n.prototype.toHsv = function() {
      var e = zC(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
    }, n.prototype.toHsvString = function() {
      var e = zC(this.r, this.g, this.b), t = Math.round(e.h * 360), i = Math.round(e.s * 100), r = Math.round(e.v * 100);
      return this.a === 1 ? "hsv(".concat(t, ", ").concat(i, "%, ").concat(r, "%)") : "hsva(".concat(t, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, n.prototype.toHsl = function() {
      var e = QC(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
    }, n.prototype.toHslString = function() {
      var e = QC(this.r, this.g, this.b), t = Math.round(e.h * 360), i = Math.round(e.s * 100), r = Math.round(e.l * 100);
      return this.a === 1 ? "hsl(".concat(t, ", ").concat(i, "%, ").concat(r, "%)") : "hsla(".concat(t, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, n.prototype.toHex = function(e) {
      return e === void 0 && (e = !1), jC(this.r, this.g, this.b, e);
    }, n.prototype.toHexString = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex(e);
    }, n.prototype.toHex8 = function(e) {
      return e === void 0 && (e = !1), W9(this.r, this.g, this.b, this.a, e);
    }, n.prototype.toHex8String = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex8(e);
    }, n.prototype.toHexShortString = function(e) {
      return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
    }, n.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, n.prototype.toRgbString = function() {
      var e = Math.round(this.r), t = Math.round(this.g), i = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(e, ", ").concat(t, ", ").concat(i, ")") : "rgba(".concat(e, ", ").concat(t, ", ").concat(i, ", ").concat(this.roundA, ")");
    }, n.prototype.toPercentageRgb = function() {
      var e = function(t) {
        return "".concat(Math.round(Ai(t, 255) * 100), "%");
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      };
    }, n.prototype.toPercentageRgbString = function() {
      var e = function(t) {
        return Math.round(Ai(t, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
    }, n.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + jC(this.r, this.g, this.b, !1), t = 0, i = Object.entries(fy); t < i.length; t++) {
        var r = i[t], s = r[0], o = r[1];
        if (e === o)
          return s;
      }
      return !1;
    }, n.prototype.toString = function(e) {
      var t = !!e;
      e = e ?? this.format;
      var i = !1, r = this.a < 1 && this.a >= 0, s = !t && r && (e.startsWith("hex") || e === "name");
      return s ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (i = this.toRgbString()), e === "prgb" && (i = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (i = this.toHexString()), e === "hex3" && (i = this.toHexString(!0)), e === "hex4" && (i = this.toHex8String(!0)), e === "hex8" && (i = this.toHex8String()), e === "name" && (i = this.toName()), e === "hsl" && (i = this.toHslString()), e === "hsv" && (i = this.toHsvString()), i || this.toHexString());
    }, n.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, n.prototype.clone = function() {
      return new n(this.toString());
    }, n.prototype.lighten = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.l += e / 100, t.l = up(t.l), new n(t);
    }, n.prototype.brighten = function(e) {
      e === void 0 && (e = 10);
      var t = this.toRgb();
      return t.r = Math.max(0, Math.min(255, t.r - Math.round(255 * -(e / 100)))), t.g = Math.max(0, Math.min(255, t.g - Math.round(255 * -(e / 100)))), t.b = Math.max(0, Math.min(255, t.b - Math.round(255 * -(e / 100)))), new n(t);
    }, n.prototype.darken = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.l -= e / 100, t.l = up(t.l), new n(t);
    }, n.prototype.tint = function(e) {
      return e === void 0 && (e = 10), this.mix("white", e);
    }, n.prototype.shade = function(e) {
      return e === void 0 && (e = 10), this.mix("black", e);
    }, n.prototype.desaturate = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.s -= e / 100, t.s = up(t.s), new n(t);
    }, n.prototype.saturate = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.s += e / 100, t.s = up(t.s), new n(t);
    }, n.prototype.greyscale = function() {
      return this.desaturate(100);
    }, n.prototype.spin = function(e) {
      var t = this.toHsl(), i = (t.h + e) % 360;
      return t.h = i < 0 ? 360 + i : i, new n(t);
    }, n.prototype.mix = function(e, t) {
      t === void 0 && (t = 50);
      var i = this.toRgb(), r = new n(e).toRgb(), s = t / 100, o = {
        r: (r.r - i.r) * s + i.r,
        g: (r.g - i.g) * s + i.g,
        b: (r.b - i.b) * s + i.b,
        a: (r.a - i.a) * s + i.a
      };
      return new n(o);
    }, n.prototype.analogous = function(e, t) {
      e === void 0 && (e = 6), t === void 0 && (t = 30);
      var i = this.toHsl(), r = 360 / t, s = [this];
      for (i.h = (i.h - (r * e >> 1) + 720) % 360; --e; )
        i.h = (i.h + r) % 360, s.push(new n(i));
      return s;
    }, n.prototype.complement = function() {
      var e = this.toHsl();
      return e.h = (e.h + 180) % 360, new n(e);
    }, n.prototype.monochromatic = function(e) {
      e === void 0 && (e = 6);
      for (var t = this.toHsv(), i = t.h, r = t.s, s = t.v, o = [], a = 1 / e; e--; )
        o.push(new n({ h: i, s: r, v: s })), s = (s + a) % 1;
      return o;
    }, n.prototype.splitcomplement = function() {
      var e = this.toHsl(), t = e.h;
      return [
        this,
        new n({ h: (t + 72) % 360, s: e.s, l: e.l }),
        new n({ h: (t + 216) % 360, s: e.s, l: e.l })
      ];
    }, n.prototype.onBackground = function(e) {
      var t = this.toRgb(), i = new n(e).toRgb(), r = t.a + i.a * (1 - t.a);
      return new n({
        r: (t.r * t.a + i.r * i.a * (1 - t.a)) / r,
        g: (t.g * t.a + i.g * i.a * (1 - t.a)) / r,
        b: (t.b * t.a + i.b * i.a * (1 - t.a)) / r,
        a: r
      });
    }, n.prototype.triad = function() {
      return this.polyad(3);
    }, n.prototype.tetrad = function() {
      return this.polyad(4);
    }, n.prototype.polyad = function(e) {
      for (var t = this.toHsl(), i = t.h, r = [this], s = 360 / e, o = 1; o < e; o++)
        r.push(new n({ h: (i + o * s) % 360, s: t.s, l: t.l }));
      return r;
    }, n.prototype.equals = function(e) {
      return this.toRgbString() === new n(e).toRgbString();
    }, n;
  }()
);
function aa(n, e = 20) {
  return n.mix("#141414", e).toString();
}
function eW(n) {
  const e = ts(), t = me("button");
  return $(() => {
    let i = {};
    const r = n.color;
    if (r) {
      const s = new J9(r), o = n.dark ? s.tint(20).toString() : aa(s, 20);
      if (n.plain)
        i = t.cssVarBlock({
          "bg-color": n.dark ? aa(s, 90) : s.tint(90).toString(),
          "text-color": r,
          "border-color": n.dark ? aa(s, 50) : s.tint(50).toString(),
          "hover-text-color": `var(${t.cssVarName("color-white")})`,
          "hover-bg-color": r,
          "hover-border-color": r,
          "active-bg-color": o,
          "active-text-color": `var(${t.cssVarName("color-white")})`,
          "active-border-color": o
        }), e.value && (i[t.cssVarBlockName("disabled-bg-color")] = n.dark ? aa(s, 90) : s.tint(90).toString(), i[t.cssVarBlockName("disabled-text-color")] = n.dark ? aa(s, 50) : s.tint(50).toString(), i[t.cssVarBlockName("disabled-border-color")] = n.dark ? aa(s, 80) : s.tint(80).toString());
      else {
        const a = n.dark ? aa(s, 30) : s.tint(30).toString(), l = s.isDark() ? `var(${t.cssVarName("color-white")})` : `var(${t.cssVarName("color-black")})`;
        if (i = t.cssVarBlock({
          "bg-color": r,
          "text-color": l,
          "border-color": r,
          "hover-bg-color": a,
          "hover-text-color": l,
          "hover-border-color": a,
          "active-bg-color": o,
          "active-border-color": o
        }), e.value) {
          const c = n.dark ? aa(s, 50) : s.tint(50).toString();
          i[t.cssVarBlockName("disabled-bg-color")] = c, i[t.cssVarBlockName("disabled-text-color")] = n.dark ? "rgba(255, 255, 255, 0.5)" : `var(${t.cssVarName("color-white")})`, i[t.cssVarBlockName("disabled-border-color")] = c;
        }
      }
    }
    return i;
  });
}
const tW = F({
  name: "ElButton"
}), nW = /* @__PURE__ */ F({
  ...tW,
  props: dy,
  emits: z9,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = eW(i), s = me("button"), { _ref: o, _size: a, _type: l, _disabled: c, _props: u, shouldAddSpace: h, handleClick: d } = B9(i, t);
    return e({
      ref: o,
      size: a,
      type: l,
      disabled: c,
      shouldAddSpace: h
    }), (f, p) => (R(), ie(yt(f.tag), Pi({
      ref_key: "_ref",
      ref: o
    }, O(u), {
      class: [
        O(s).b(),
        O(s).m(O(l)),
        O(s).m(O(a)),
        O(s).is("disabled", O(c)),
        O(s).is("loading", f.loading),
        O(s).is("plain", f.plain),
        O(s).is("round", f.round),
        O(s).is("circle", f.circle),
        O(s).is("text", f.text),
        O(s).is("link", f.link),
        O(s).is("has-bg", f.bg)
      ],
      style: O(r),
      onClick: O(d)
    }), {
      default: Y(() => [
        f.loading ? (R(), V(Tt, { key: 0 }, [
          f.$slots.loading ? de(f.$slots, "loading", { key: 0 }) : (R(), ie(O(Fe), {
            key: 1,
            class: L(O(s).is("loading"))
          }, {
            default: Y(() => [
              (R(), ie(yt(f.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : f.icon || f.$slots.icon ? (R(), ie(O(Fe), { key: 1 }, {
          default: Y(() => [
            f.icon ? (R(), ie(yt(f.icon), { key: 0 })) : de(f.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : G("v-if", !0),
        f.$slots.default ? (R(), V("span", {
          key: 2,
          class: L({ [O(s).em("text", "expand")]: O(h) })
        }, [
          de(f.$slots, "default")
        ], 2)) : G("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var iW = /* @__PURE__ */ Ce(nW, [["__file", "button.vue"]]);
const rW = {
  size: dy.size,
  type: dy.type
}, sW = F({
  name: "ElButtonGroup"
}), oW = /* @__PURE__ */ F({
  ...sW,
  props: rW,
  setup(n) {
    const e = n;
    ft(WT, Gt({
      size: Pr(e, "size"),
      type: Pr(e, "type")
    }));
    const t = me("button");
    return (i, r) => (R(), V("div", {
      class: L(`${O(t).b("group")}`)
    }, [
      de(i.$slots, "default")
    ], 2));
  }
});
var XT = /* @__PURE__ */ Ce(oW, [["__file", "button-group.vue"]]);
const Wl = Ft(iW, {
  ButtonGroup: XT
});
As(XT);
var aW = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Mf(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function lW(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), t;
}
const ca = /* @__PURE__ */ new Map();
let FC;
vt && (document.addEventListener("mousedown", (n) => FC = n), document.addEventListener("mouseup", (n) => {
  for (const e of ca.values())
    for (const { documentHandler: t } of e)
      t(n, FC);
}));
function ZC(n, e) {
  let t = [];
  return Array.isArray(e.arg) ? t = e.arg : Os(e.arg) && t.push(e.arg), function(i, r) {
    const s = e.instance.popperRef, o = i.target, a = r == null ? void 0 : r.target, l = !e || !e.instance, c = !o || !a, u = n.contains(o) || n.contains(a), h = n === o, d = t.length && t.some((p) => p == null ? void 0 : p.contains(o)) || t.length && t.includes(a), f = s && (s.contains(o) || s.contains(a));
    l || c || u || h || d || f || e.value(i, r);
  };
}
const Rf = {
  beforeMount(n, e) {
    ca.has(n) || ca.set(n, []), ca.get(n).push({
      documentHandler: ZC(n, e),
      bindingFn: e.value
    });
  },
  updated(n, e) {
    ca.has(n) || ca.set(n, []);
    const t = ca.get(n), i = t.findIndex((s) => s.bindingFn === e.oldValue), r = {
      documentHandler: ZC(n, e),
      bindingFn: e.value
    };
    i >= 0 ? t.splice(i, 1, r) : t.push(r);
  },
  unmounted(n) {
    ca.delete(n);
  }
}, cW = 100, uW = 600, qC = {
  beforeMount(n, e) {
    const t = e.value, { interval: i = cW, delay: r = uW } = wt(t) ? {} : t;
    let s, o;
    const a = () => wt(t) ? t() : t.handler(), l = () => {
      o && (clearTimeout(o), o = void 0), s && (clearInterval(s), s = void 0);
    };
    n.addEventListener("mousedown", (c) => {
      c.button === 0 && (l(), a(), document.addEventListener("mouseup", () => l(), {
        once: !0
      }), o = setTimeout(() => {
        s = setInterval(() => {
          a();
        }, i);
      }, r));
    });
  }
}, py = "_trap-focus-children", kl = [], WC = (n) => {
  var e;
  if (kl.length === 0)
    return;
  const t = kl[kl.length - 1][py];
  if (t.length > 0 && n.code === dt.tab) {
    if (t.length === 1) {
      n.preventDefault(), document.activeElement !== t[0] && t[0].focus();
      return;
    }
    const i = n.shiftKey, r = n.target === t[0], s = n.target === t[t.length - 1];
    if (r && i && (n.preventDefault(), t[t.length - 1].focus()), s && !i && (n.preventDefault(), t[0].focus()), process.env.NODE_ENV === "test") {
      const o = t.indexOf(n.target);
      o !== -1 && ((e = t[i ? o - 1 : o + 1]) == null || e.focus());
    }
  }
}, hW = {
  beforeMount(n) {
    n[py] = US(n), kl.push(n), kl.length <= 1 && document.addEventListener("keydown", WC);
  },
  updated(n) {
    $e(() => {
      n[py] = US(n);
    });
  },
  unmounted() {
    kl.shift(), kl.length === 0 && document.removeEventListener("keydown", WC);
  }
};
var HC = !1, vl, gy, my, og, ag, YT, lg, vy, by, yy, UT, Oy, wy, GT, KT;
function Gi() {
  if (!HC) {
    HC = !0;
    var n = navigator.userAgent, e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(n), t = /(Mac OS X)|(Windows)|(Linux)/.exec(n);
    if (Oy = /\b(iPhone|iP[ao]d)/.exec(n), wy = /\b(iP[ao]d)/.exec(n), yy = /Android/i.exec(n), GT = /FBAN\/\w+;/i.exec(n), KT = /Mobile/i.exec(n), UT = !!/Win64/.exec(n), e) {
      vl = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN, vl && document && document.documentMode && (vl = document.documentMode);
      var i = /(?:Trident\/(\d+.\d+))/.exec(n);
      YT = i ? parseFloat(i[1]) + 4 : vl, gy = e[2] ? parseFloat(e[2]) : NaN, my = e[3] ? parseFloat(e[3]) : NaN, og = e[4] ? parseFloat(e[4]) : NaN, og ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(n), ag = e && e[1] ? parseFloat(e[1]) : NaN) : ag = NaN;
    } else
      vl = gy = my = ag = og = NaN;
    if (t) {
      if (t[1]) {
        var r = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(n);
        lg = r ? parseFloat(r[1].replace("_", ".")) : !0;
      } else
        lg = !1;
      vy = !!t[2], by = !!t[3];
    } else
      lg = vy = by = !1;
  }
}
var xy = { ie: function() {
  return Gi() || vl;
}, ieCompatibilityMode: function() {
  return Gi() || YT > vl;
}, ie64: function() {
  return xy.ie() && UT;
}, firefox: function() {
  return Gi() || gy;
}, opera: function() {
  return Gi() || my;
}, webkit: function() {
  return Gi() || og;
}, safari: function() {
  return xy.webkit();
}, chrome: function() {
  return Gi() || ag;
}, windows: function() {
  return Gi() || vy;
}, osx: function() {
  return Gi() || lg;
}, linux: function() {
  return Gi() || by;
}, iphone: function() {
  return Gi() || Oy;
}, mobile: function() {
  return Gi() || Oy || wy || yy || KT;
}, nativeApp: function() {
  return Gi() || GT;
}, android: function() {
  return Gi() || yy;
}, ipad: function() {
  return Gi() || wy;
} }, dW = xy, dp = !!(typeof window < "u" && window.document && window.document.createElement), fW = { canUseDOM: dp, canUseWorkers: typeof Worker < "u", canUseEventListeners: dp && !!(window.addEventListener || window.attachEvent), canUseViewport: dp && !!window.screen, isInWorker: !dp }, JT = fW, e_;
JT.canUseDOM && (e_ = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function pW(n, e) {
  if (!JT.canUseDOM || e && !("addEventListener" in document))
    return !1;
  var t = "on" + n, i = t in document;
  if (!i) {
    var r = document.createElement("div");
    r.setAttribute(t, "return;"), i = typeof r[t] == "function";
  }
  return !i && e_ && n === "wheel" && (i = document.implementation.hasFeature("Events.wheel", "3.0")), i;
}
var gW = pW, XC = 10, YC = 40, UC = 800;
function t_(n) {
  var e = 0, t = 0, i = 0, r = 0;
  return "detail" in n && (t = n.detail), "wheelDelta" in n && (t = -n.wheelDelta / 120), "wheelDeltaY" in n && (t = -n.wheelDeltaY / 120), "wheelDeltaX" in n && (e = -n.wheelDeltaX / 120), "axis" in n && n.axis === n.HORIZONTAL_AXIS && (e = t, t = 0), i = e * XC, r = t * XC, "deltaY" in n && (r = n.deltaY), "deltaX" in n && (i = n.deltaX), (i || r) && n.deltaMode && (n.deltaMode == 1 ? (i *= YC, r *= YC) : (i *= UC, r *= UC)), i && !e && (e = i < 1 ? -1 : 1), r && !t && (t = r < 1 ? -1 : 1), { spinX: e, spinY: t, pixelX: i, pixelY: r };
}
t_.getEventType = function() {
  return dW.firefox() ? "DOMMouseScroll" : gW("wheel") ? "wheel" : "mousewheel";
};
var mW = t_;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const vW = function(n, e) {
  if (n && n.addEventListener) {
    const t = function(i) {
      const r = mW(i);
      e && Reflect.apply(e, this, [i, r]);
    };
    n.addEventListener("wheel", t, { passive: !0 });
  }
}, bW = {
  beforeMount(n, e) {
    vW(n, e.value);
  }
}, n_ = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: _r,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, i_ = {
  [ot]: (n) => bt(n) || tt(n) || Ei(n),
  change: (n) => bt(n) || tt(n) || Ei(n)
}, uh = Symbol("checkboxGroupContextKey"), yW = ({
  model: n,
  isChecked: e
}) => {
  const t = ke(uh, void 0), i = $(() => {
    var s, o;
    const a = (s = t == null ? void 0 : t.max) == null ? void 0 : s.value, l = (o = t == null ? void 0 : t.min) == null ? void 0 : o.value;
    return !Ci(a) && n.value.length >= a && !e.value || !Ci(l) && n.value.length <= l && e.value;
  });
  return {
    isDisabled: ts($(() => (t == null ? void 0 : t.disabled.value) || i.value)),
    isLimitDisabled: i
  };
}, OW = (n, {
  model: e,
  isLimitExceeded: t,
  hasOwnLabel: i,
  isDisabled: r,
  isLabeledByFormItem: s
}) => {
  const o = ke(uh, void 0), { formItem: a } = Mr(), { emit: l } = Xe();
  function c(p) {
    var g, m;
    return p === n.trueLabel || p === !0 ? (g = n.trueLabel) != null ? g : !0 : (m = n.falseLabel) != null ? m : !1;
  }
  function u(p, g) {
    l("change", c(p), g);
  }
  function h(p) {
    if (t.value)
      return;
    const g = p.target;
    l("change", c(g.checked), p);
  }
  async function d(p) {
    t.value || !i.value && !r.value && s.value && (p.composedPath().some((v) => v.tagName === "LABEL") || (e.value = c([!1, n.falseLabel].includes(e.value)), await $e(), u(e.value, p)));
  }
  const f = $(() => (o == null ? void 0 : o.validateEvent) || n.validateEvent);
  return ne(() => n.modelValue, () => {
    f.value && (a == null || a.validate("change").catch((p) => pt(p)));
  }), {
    handleChange: h,
    onClickRoot: d
  };
}, wW = (n) => {
  const e = D(!1), { emit: t } = Xe(), i = ke(uh, void 0), r = $(() => Ci(i) === !1), s = D(!1), o = $({
    get() {
      var a, l;
      return r.value ? (a = i == null ? void 0 : i.modelValue) == null ? void 0 : a.value : (l = n.modelValue) != null ? l : e.value;
    },
    set(a) {
      var l, c;
      r.value && xt(a) ? (s.value = ((l = i == null ? void 0 : i.max) == null ? void 0 : l.value) !== void 0 && a.length > (i == null ? void 0 : i.max.value) && a.length > o.value.length, s.value === !1 && ((c = i == null ? void 0 : i.changeEvent) == null || c.call(i, a))) : (t(ot, a), e.value = a);
    }
  });
  return {
    model: o,
    isGroup: r,
    isLimitExceeded: s
  };
}, xW = (n, e, { model: t }) => {
  const i = ke(uh, void 0), r = D(!1), s = $(() => {
    const c = t.value;
    return Ei(c) ? c : xt(c) ? an(n.label) ? c.map(Ed).some((u) => cn(u, n.label)) : c.map(Ed).includes(n.label) : c != null ? c === n.trueLabel : !!c;
  }), o = Yi($(() => {
    var c;
    return (c = i == null ? void 0 : i.size) == null ? void 0 : c.value;
  }), {
    prop: !0
  }), a = Yi($(() => {
    var c;
    return (c = i == null ? void 0 : i.size) == null ? void 0 : c.value;
  })), l = $(() => !!e.default || !Ni(n.label));
  return {
    checkboxButtonSize: o,
    isChecked: s,
    isFocused: r,
    checkboxSize: a,
    hasOwnLabel: l
  };
}, SW = (n, { model: e }) => {
  function t() {
    xt(e.value) && !e.value.includes(n.label) ? e.value.push(n.label) : e.value = n.trueLabel || !0;
  }
  n.checked && t();
}, r_ = (n, e) => {
  const { formItem: t } = Mr(), { model: i, isGroup: r, isLimitExceeded: s } = wW(n), {
    isFocused: o,
    isChecked: a,
    checkboxButtonSize: l,
    checkboxSize: c,
    hasOwnLabel: u
  } = xW(n, e, { model: i }), { isDisabled: h } = yW({ model: i, isChecked: a }), { inputId: d, isLabeledByFormItem: f } = Ka(n, {
    formItemContext: t,
    disableIdGeneration: u,
    disableIdManagement: r
  }), { handleChange: p, onClickRoot: g } = OW(n, {
    model: i,
    isLimitExceeded: s,
    hasOwnLabel: u,
    isDisabled: h,
    isLabeledByFormItem: f
  });
  return SW(n, { model: i }), {
    inputId: d,
    isLabeledByFormItem: f,
    isChecked: a,
    isDisabled: h,
    isFocused: o,
    checkboxButtonSize: l,
    checkboxSize: c,
    hasOwnLabel: u,
    model: i,
    handleChange: p,
    onClickRoot: g
  };
}, CW = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], kW = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], PW = F({
  name: "ElCheckbox"
}), EW = /* @__PURE__ */ F({
  ...PW,
  props: n_,
  emits: i_,
  setup(n) {
    const e = n, t = vo(), {
      inputId: i,
      isLabeledByFormItem: r,
      isChecked: s,
      isDisabled: o,
      isFocused: a,
      checkboxSize: l,
      hasOwnLabel: c,
      model: u,
      handleChange: h,
      onClickRoot: d
    } = r_(e, t), f = me("checkbox"), p = $(() => [
      f.b(),
      f.m(l.value),
      f.is("disabled", o.value),
      f.is("bordered", e.border),
      f.is("checked", s.value)
    ]), g = $(() => [
      f.e("input"),
      f.is("disabled", o.value),
      f.is("checked", s.value),
      f.is("indeterminate", e.indeterminate),
      f.is("focus", a.value)
    ]);
    return (m, v) => (R(), ie(yt(!O(c) && O(r) ? "span" : "label"), {
      class: L(O(p)),
      "aria-controls": m.indeterminate ? m.controls : null,
      onClick: O(d)
    }, {
      default: Y(() => [
        Z("span", {
          class: L(O(g))
        }, [
          m.trueLabel || m.falseLabel ? it((R(), V("input", {
            key: 0,
            id: O(i),
            "onUpdate:modelValue": v[0] || (v[0] = (y) => Zi(u) ? u.value = y : null),
            class: L(O(f).e("original")),
            type: "checkbox",
            indeterminate: m.indeterminate,
            name: m.name,
            tabindex: m.tabindex,
            disabled: O(o),
            "true-value": m.trueLabel,
            "false-value": m.falseLabel,
            onChange: v[1] || (v[1] = (...y) => O(h) && O(h)(...y)),
            onFocus: v[2] || (v[2] = (y) => a.value = !0),
            onBlur: v[3] || (v[3] = (y) => a.value = !1),
            onClick: v[4] || (v[4] = Le(() => {
            }, ["stop"]))
          }, null, 42, CW)), [
            [Vg, O(u)]
          ]) : it((R(), V("input", {
            key: 1,
            id: O(i),
            "onUpdate:modelValue": v[5] || (v[5] = (y) => Zi(u) ? u.value = y : null),
            class: L(O(f).e("original")),
            type: "checkbox",
            indeterminate: m.indeterminate,
            disabled: O(o),
            value: m.label,
            name: m.name,
            tabindex: m.tabindex,
            onChange: v[6] || (v[6] = (...y) => O(h) && O(h)(...y)),
            onFocus: v[7] || (v[7] = (y) => a.value = !0),
            onBlur: v[8] || (v[8] = (y) => a.value = !1),
            onClick: v[9] || (v[9] = Le(() => {
            }, ["stop"]))
          }, null, 42, kW)), [
            [Vg, O(u)]
          ]),
          Z("span", {
            class: L(O(f).e("inner"))
          }, null, 2)
        ], 2),
        O(c) ? (R(), V("span", {
          key: 0,
          class: L(O(f).e("label"))
        }, [
          de(m.$slots, "default"),
          m.$slots.default ? G("v-if", !0) : (R(), V(Tt, { key: 0 }, [
            Yn(xe(m.label), 1)
          ], 64))
        ], 2)) : G("v-if", !0)
      ]),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var AW = /* @__PURE__ */ Ce(EW, [["__file", "checkbox.vue"]]);
const $W = ["name", "tabindex", "disabled", "true-value", "false-value"], TW = ["name", "tabindex", "disabled", "value"], _W = F({
  name: "ElCheckboxButton"
}), MW = /* @__PURE__ */ F({
  ..._W,
  props: n_,
  emits: i_,
  setup(n) {
    const e = n, t = vo(), {
      isFocused: i,
      isChecked: r,
      isDisabled: s,
      checkboxButtonSize: o,
      model: a,
      handleChange: l
    } = r_(e, t), c = ke(uh, void 0), u = me("checkbox"), h = $(() => {
      var f, p, g, m;
      const v = (p = (f = c == null ? void 0 : c.fill) == null ? void 0 : f.value) != null ? p : "";
      return {
        backgroundColor: v,
        borderColor: v,
        color: (m = (g = c == null ? void 0 : c.textColor) == null ? void 0 : g.value) != null ? m : "",
        boxShadow: v ? `-1px 0 0 0 ${v}` : void 0
      };
    }), d = $(() => [
      u.b("button"),
      u.bm("button", o.value),
      u.is("disabled", s.value),
      u.is("checked", r.value),
      u.is("focus", i.value)
    ]);
    return (f, p) => (R(), V("label", {
      class: L(O(d))
    }, [
      f.trueLabel || f.falseLabel ? it((R(), V("input", {
        key: 0,
        "onUpdate:modelValue": p[0] || (p[0] = (g) => Zi(a) ? a.value = g : null),
        class: L(O(u).be("button", "original")),
        type: "checkbox",
        name: f.name,
        tabindex: f.tabindex,
        disabled: O(s),
        "true-value": f.trueLabel,
        "false-value": f.falseLabel,
        onChange: p[1] || (p[1] = (...g) => O(l) && O(l)(...g)),
        onFocus: p[2] || (p[2] = (g) => i.value = !0),
        onBlur: p[3] || (p[3] = (g) => i.value = !1),
        onClick: p[4] || (p[4] = Le(() => {
        }, ["stop"]))
      }, null, 42, $W)), [
        [Vg, O(a)]
      ]) : it((R(), V("input", {
        key: 1,
        "onUpdate:modelValue": p[5] || (p[5] = (g) => Zi(a) ? a.value = g : null),
        class: L(O(u).be("button", "original")),
        type: "checkbox",
        name: f.name,
        tabindex: f.tabindex,
        disabled: O(s),
        value: f.label,
        onChange: p[6] || (p[6] = (...g) => O(l) && O(l)(...g)),
        onFocus: p[7] || (p[7] = (g) => i.value = !0),
        onBlur: p[8] || (p[8] = (g) => i.value = !1),
        onClick: p[9] || (p[9] = Le(() => {
        }, ["stop"]))
      }, null, 42, TW)), [
        [Vg, O(a)]
      ]),
      f.$slots.default || f.label ? (R(), V("span", {
        key: 2,
        class: L(O(u).be("button", "inner")),
        style: Qe(O(r) ? O(h) : void 0)
      }, [
        de(f.$slots, "default", {}, () => [
          Yn(xe(f.label), 1)
        ])
      ], 6)) : G("v-if", !0)
    ], 2));
  }
});
var s_ = /* @__PURE__ */ Ce(MW, [["__file", "checkbox-button.vue"]]);
const RW = Ee({
  modelValue: {
    type: ce(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: _r,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), NW = {
  [ot]: (n) => xt(n),
  change: (n) => xt(n)
}, DW = F({
  name: "ElCheckboxGroup"
}), LW = /* @__PURE__ */ F({
  ...DW,
  props: RW,
  emits: NW,
  setup(n, { emit: e }) {
    const t = n, i = me("checkbox"), { formItem: r } = Mr(), { inputId: s, isLabeledByFormItem: o } = Ka(t, {
      formItemContext: r
    }), a = async (c) => {
      e(ot, c), await $e(), e("change", c);
    }, l = $({
      get() {
        return t.modelValue;
      },
      set(c) {
        a(c);
      }
    });
    return ft(uh, {
      ...Kb(Hr(t), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: l,
      changeEvent: a
    }), ne(() => t.modelValue, () => {
      t.validateEvent && (r == null || r.validate("change").catch((c) => pt(c)));
    }), (c, u) => {
      var h;
      return R(), ie(yt(c.tag), {
        id: O(s),
        class: L(O(i).b("group")),
        role: "group",
        "aria-label": O(o) ? void 0 : c.label || "checkbox-group",
        "aria-labelledby": O(o) ? (h = O(r)) == null ? void 0 : h.labelId : void 0
      }, {
        default: Y(() => [
          de(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var o_ = /* @__PURE__ */ Ce(LW, [["__file", "checkbox-group.vue"]]);
const fo = Ft(AW, {
  CheckboxButton: s_,
  CheckboxGroup: o_
});
As(s_);
const IW = As(o_), a_ = Ee({
  size: _r,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
}), BW = Ee({
  ...a_,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}), l_ = {
  [ot]: (n) => bt(n) || tt(n) || Ei(n),
  [Gn]: (n) => bt(n) || tt(n) || Ei(n)
}, c_ = Symbol("radioGroupKey"), u_ = (n, e) => {
  const t = D(), i = ke(c_, void 0), r = $(() => !!i), s = $({
    get() {
      return r.value ? i.modelValue : n.modelValue;
    },
    set(u) {
      r.value ? i.changeEvent(u) : e && e(ot, u), t.value.checked = n.modelValue === n.label;
    }
  }), o = Yi($(() => i == null ? void 0 : i.size)), a = ts($(() => i == null ? void 0 : i.disabled)), l = D(!1), c = $(() => a.value || r.value && s.value !== n.label ? -1 : 0);
  return {
    radioRef: t,
    isGroup: r,
    radioGroup: i,
    focus: l,
    size: o,
    disabled: a,
    tabIndex: c,
    modelValue: s
  };
}, QW = ["value", "name", "disabled"], zW = F({
  name: "ElRadio"
}), jW = /* @__PURE__ */ F({
  ...zW,
  props: BW,
  emits: l_,
  setup(n, { emit: e }) {
    const t = n, i = me("radio"), { radioRef: r, radioGroup: s, focus: o, size: a, disabled: l, modelValue: c } = u_(t, e);
    function u() {
      $e(() => e("change", c.value));
    }
    return (h, d) => {
      var f;
      return R(), V("label", {
        class: L([
          O(i).b(),
          O(i).is("disabled", O(l)),
          O(i).is("focus", O(o)),
          O(i).is("bordered", h.border),
          O(i).is("checked", O(c) === h.label),
          O(i).m(O(a))
        ])
      }, [
        Z("span", {
          class: L([
            O(i).e("input"),
            O(i).is("disabled", O(l)),
            O(i).is("checked", O(c) === h.label)
          ])
        }, [
          it(Z("input", {
            ref_key: "radioRef",
            ref: r,
            "onUpdate:modelValue": d[0] || (d[0] = (p) => Zi(c) ? c.value = p : null),
            class: L(O(i).e("original")),
            value: h.label,
            name: h.name || ((f = O(s)) == null ? void 0 : f.name),
            disabled: O(l),
            type: "radio",
            onFocus: d[1] || (d[1] = (p) => o.value = !0),
            onBlur: d[2] || (d[2] = (p) => o.value = !1),
            onChange: u,
            onClick: d[3] || (d[3] = Le(() => {
            }, ["stop"]))
          }, null, 42, QW), [
            [xA, O(c)]
          ]),
          Z("span", {
            class: L(O(i).e("inner"))
          }, null, 2)
        ], 2),
        Z("span", {
          class: L(O(i).e("label")),
          onKeydown: d[4] || (d[4] = Le(() => {
          }, ["stop"]))
        }, [
          de(h.$slots, "default", {}, () => [
            Yn(xe(h.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var VW = /* @__PURE__ */ Ce(jW, [["__file", "radio.vue"]]);
const FW = Ee({
  ...a_,
  name: {
    type: String,
    default: ""
  }
}), ZW = ["value", "name", "disabled"], qW = F({
  name: "ElRadioButton"
}), WW = /* @__PURE__ */ F({
  ...qW,
  props: FW,
  setup(n) {
    const e = n, t = me("radio"), { radioRef: i, focus: r, size: s, disabled: o, modelValue: a, radioGroup: l } = u_(e), c = $(() => ({
      backgroundColor: (l == null ? void 0 : l.fill) || "",
      borderColor: (l == null ? void 0 : l.fill) || "",
      boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
      color: (l == null ? void 0 : l.textColor) || ""
    }));
    return (u, h) => {
      var d;
      return R(), V("label", {
        class: L([
          O(t).b("button"),
          O(t).is("active", O(a) === u.label),
          O(t).is("disabled", O(o)),
          O(t).is("focus", O(r)),
          O(t).bm("button", O(s))
        ])
      }, [
        it(Z("input", {
          ref_key: "radioRef",
          ref: i,
          "onUpdate:modelValue": h[0] || (h[0] = (f) => Zi(a) ? a.value = f : null),
          class: L(O(t).be("button", "original-radio")),
          value: u.label,
          type: "radio",
          name: u.name || ((d = O(l)) == null ? void 0 : d.name),
          disabled: O(o),
          onFocus: h[1] || (h[1] = (f) => r.value = !0),
          onBlur: h[2] || (h[2] = (f) => r.value = !1),
          onClick: h[3] || (h[3] = Le(() => {
          }, ["stop"]))
        }, null, 42, ZW), [
          [xA, O(a)]
        ]),
        Z("span", {
          class: L(O(t).be("button", "inner")),
          style: Qe(O(a) === u.label ? O(c) : {}),
          onKeydown: h[4] || (h[4] = Le(() => {
          }, ["stop"]))
        }, [
          de(u.$slots, "default", {}, () => [
            Yn(xe(u.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var h_ = /* @__PURE__ */ Ce(WW, [["__file", "radio-button.vue"]]);
const HW = Ee({
  id: {
    type: String,
    default: void 0
  },
  size: _r,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), XW = l_, YW = ["id", "aria-label", "aria-labelledby"], UW = F({
  name: "ElRadioGroup"
}), GW = /* @__PURE__ */ F({
  ...UW,
  props: HW,
  emits: XW,
  setup(n, { emit: e }) {
    const t = n, i = me("radio"), r = ws(), s = D(), { formItem: o } = Mr(), { inputId: a, isLabeledByFormItem: l } = Ka(t, {
      formItemContext: o
    }), c = (h) => {
      e(ot, h), $e(() => e("change", h));
    };
    qe(() => {
      const h = s.value.querySelectorAll("[type=radio]"), d = h[0];
      !Array.from(h).some((f) => f.checked) && d && (d.tabIndex = 0);
    });
    const u = $(() => t.name || r.value);
    return ft(c_, Gt({
      ...Hr(t),
      changeEvent: c,
      name: u
    })), ne(() => t.modelValue, () => {
      t.validateEvent && (o == null || o.validate("change").catch((h) => pt(h)));
    }), (h, d) => (R(), V("div", {
      id: O(a),
      ref_key: "radioGroupRef",
      ref: s,
      class: L(O(i).b("group")),
      role: "radiogroup",
      "aria-label": O(l) ? void 0 : h.label || "radio-group",
      "aria-labelledby": O(l) ? O(o).labelId : void 0
    }, [
      de(h.$slots, "default")
    ], 10, YW));
  }
});
var d_ = /* @__PURE__ */ Ce(GW, [["__file", "radio-group.vue"]]);
const KW = Ft(VW, {
  RadioButton: h_,
  RadioGroup: d_
}), SKe = As(d_), CKe = As(h_);
var JW = F({
  name: "NodeContent",
  setup() {
    return {
      ns: me("cascader-node")
    };
  },
  render() {
    const { ns: n } = this, { node: e, panel: t } = this.$parent, { data: i, label: r } = e, { renderLabelFn: s } = t;
    return Re("span", { class: n.e("label") }, s ? s({ node: e, data: i }) : r);
  }
});
const xw = Symbol(), eH = F({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: fo,
    ElRadio: KW,
    NodeContent: JW,
    ElIcon: Fe,
    Check: fv,
    Loading: lc,
    ArrowRight: ac
  },
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(n, { emit: e }) {
    const t = ke(xw), i = me("cascader-node"), r = $(() => t.isHoverMenu), s = $(() => t.config.multiple), o = $(() => t.config.checkStrictly), a = $(() => {
      var S;
      return (S = t.checkedNodes[0]) == null ? void 0 : S.uid;
    }), l = $(() => n.node.isDisabled), c = $(() => n.node.isLeaf), u = $(() => o.value && !c.value || !l.value), h = $(() => f(t.expandingNode)), d = $(() => o.value && t.checkedNodes.some(f)), f = (S) => {
      var C;
      const { level: k, uid: E } = n.node;
      return ((C = S == null ? void 0 : S.pathNodes[k - 1]) == null ? void 0 : C.uid) === E;
    }, p = () => {
      h.value || t.expandNode(n.node);
    }, g = (S) => {
      const { node: C } = n;
      S !== C.checked && t.handleCheckChange(C, S);
    }, m = () => {
      t.lazyLoad(n.node, () => {
        c.value || p();
      });
    }, v = (S) => {
      r.value && (y(), !c.value && e("expand", S));
    }, y = () => {
      const { node: S } = n;
      !u.value || S.loading || (S.loaded ? p() : m());
    }, b = () => {
      r.value && !c.value || (c.value && !l.value && !o.value && !s.value ? x(!0) : y());
    }, w = (S) => {
      o.value ? (g(S), n.node.loaded && p()) : x(S);
    }, x = (S) => {
      n.node.loaded ? (g(S), !o.value && p()) : m();
    };
    return {
      panel: t,
      isHoverMenu: r,
      multiple: s,
      checkStrictly: o,
      checkedNodeId: a,
      isDisabled: l,
      isLeaf: c,
      expandable: u,
      inExpandingPath: h,
      inCheckedPath: d,
      ns: i,
      handleHoverExpand: v,
      handleExpand: y,
      handleClick: b,
      handleCheck: x,
      handleSelectCheck: w
    };
  }
}), tH = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], nH = /* @__PURE__ */ Z("span", null, null, -1);
function iH(n, e, t, i, r, s) {
  const o = nt("el-checkbox"), a = nt("el-radio"), l = nt("check"), c = nt("el-icon"), u = nt("node-content"), h = nt("loading"), d = nt("arrow-right");
  return R(), V("li", {
    id: `${n.menuId}-${n.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !n.isLeaf,
    "aria-owns": n.isLeaf ? null : n.menuId,
    "aria-expanded": n.inExpandingPath,
    tabindex: n.expandable ? -1 : void 0,
    class: L([
      n.ns.b(),
      n.ns.is("selectable", n.checkStrictly),
      n.ns.is("active", n.node.checked),
      n.ns.is("disabled", !n.expandable),
      n.inExpandingPath && "in-active-path",
      n.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: e[2] || (e[2] = (...f) => n.handleHoverExpand && n.handleHoverExpand(...f)),
    onFocus: e[3] || (e[3] = (...f) => n.handleHoverExpand && n.handleHoverExpand(...f)),
    onClick: e[4] || (e[4] = (...f) => n.handleClick && n.handleClick(...f))
  }, [
    G(" prefix "),
    n.multiple ? (R(), ie(o, {
      key: 0,
      "model-value": n.node.checked,
      indeterminate: n.node.indeterminate,
      disabled: n.isDisabled,
      onClick: e[0] || (e[0] = Le(() => {
      }, ["stop"])),
      "onUpdate:modelValue": n.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : n.checkStrictly ? (R(), ie(a, {
      key: 1,
      "model-value": n.checkedNodeId,
      label: n.node.uid,
      disabled: n.isDisabled,
      "onUpdate:modelValue": n.handleSelectCheck,
      onClick: e[1] || (e[1] = Le(() => {
      }, ["stop"]))
    }, {
      default: Y(() => [
        G(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
        nH
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : n.isLeaf && n.node.checked ? (R(), ie(c, {
      key: 2,
      class: L(n.ns.e("prefix"))
    }, {
      default: Y(() => [
        K(l)
      ]),
      _: 1
    }, 8, ["class"])) : G("v-if", !0),
    G(" content "),
    K(u),
    G(" postfix "),
    n.isLeaf ? G("v-if", !0) : (R(), V(Tt, { key: 3 }, [
      n.node.loading ? (R(), ie(c, {
        key: 0,
        class: L([n.ns.is("loading"), n.ns.e("postfix")])
      }, {
        default: Y(() => [
          K(h)
        ]),
        _: 1
      }, 8, ["class"])) : (R(), ie(c, {
        key: 1,
        class: L(["arrow-right", n.ns.e("postfix")])
      }, {
        default: Y(() => [
          K(d)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64))
  ], 42, tH);
}
var rH = /* @__PURE__ */ Ce(eH, [["render", iH], ["__file", "node.vue"]]);
const sH = F({
  name: "ElCascaderMenu",
  components: {
    Loading: lc,
    ElIcon: Fe,
    ElScrollbar: _f,
    ElCascaderNode: rH
  },
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(n) {
    const e = Xe(), t = me("cascader-menu"), { t: i } = mn(), r = ws();
    let s = null, o = null;
    const a = ke(xw), l = D(null), c = $(() => !n.nodes.length), u = $(() => !a.initialLoaded), h = $(() => `${r.value}-${n.index}`), d = (m) => {
      s = m.target;
    }, f = (m) => {
      if (!(!a.isHoverMenu || !s || !l.value))
        if (s.contains(m.target)) {
          p();
          const v = e.vnode.el, { left: y } = v.getBoundingClientRect(), { offsetWidth: b, offsetHeight: w } = v, x = m.clientX - y, S = s.offsetTop, C = S + s.offsetHeight;
          l.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${x} ${S} L${b} 0 V${S} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${x} ${C} L${b} ${w} V${C} Z" />
        `;
        } else
          o || (o = window.setTimeout(g, a.config.hoverThreshold));
    }, p = () => {
      o && (clearTimeout(o), o = null);
    }, g = () => {
      l.value && (l.value.innerHTML = "", p());
    };
    return {
      ns: t,
      panel: a,
      hoverZone: l,
      isEmpty: c,
      isLoading: u,
      menuId: h,
      t: i,
      handleExpand: d,
      handleMouseMove: f,
      clearHoverZone: g
    };
  }
});
function oH(n, e, t, i, r, s) {
  const o = nt("el-cascader-node"), a = nt("loading"), l = nt("el-icon"), c = nt("el-scrollbar");
  return R(), ie(c, {
    key: n.menuId,
    tag: "ul",
    role: "menu",
    class: L(n.ns.b()),
    "wrap-class": n.ns.e("wrap"),
    "view-class": [n.ns.e("list"), n.ns.is("empty", n.isEmpty)],
    onMousemove: n.handleMouseMove,
    onMouseleave: n.clearHoverZone
  }, {
    default: Y(() => {
      var u;
      return [
        (R(!0), V(Tt, null, ai(n.nodes, (h) => (R(), ie(o, {
          key: h.uid,
          node: h,
          "menu-id": n.menuId,
          onExpand: n.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
        n.isLoading ? (R(), V("div", {
          key: 0,
          class: L(n.ns.e("empty-text"))
        }, [
          K(l, {
            size: "14",
            class: L(n.ns.is("loading"))
          }, {
            default: Y(() => [
              K(a)
            ]),
            _: 1
          }, 8, ["class"]),
          Yn(" " + xe(n.t("el.cascader.loading")), 1)
        ], 2)) : n.isEmpty ? (R(), V("div", {
          key: 1,
          class: L(n.ns.e("empty-text"))
        }, xe(n.t("el.cascader.noData")), 3)) : (u = n.panel) != null && u.isHoverMenu ? (R(), V("svg", {
          key: 2,
          ref: "hoverZone",
          class: L(n.ns.e("hover-zone"))
        }, null, 2)) : G("v-if", !0)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var aH = /* @__PURE__ */ Ce(sH, [["render", oH], ["__file", "menu.vue"]]);
let lH = 0;
const cH = (n) => {
  const e = [n];
  let { parent: t } = n;
  for (; t; )
    e.unshift(t), t = t.parent;
  return e;
};
let Sy = class Cy {
  constructor(e, t, i, r = !1) {
    this.data = e, this.config = t, this.parent = i, this.root = r, this.uid = lH++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
    const { value: s, label: o, children: a } = t, l = e[a], c = cH(this);
    this.level = r ? 0 : i ? i.level + 1 : 1, this.value = e[s], this.label = e[o], this.pathNodes = c, this.pathValues = c.map((u) => u.value), this.pathLabels = c.map((u) => u.label), this.childrenData = l, this.children = (l || []).map((u) => new Cy(u, t, this)), this.loaded = !t.lazy || this.isLeaf || !Hs(l);
  }
  get isDisabled() {
    const { data: e, parent: t, config: i } = this, { disabled: r, checkStrictly: s } = i;
    return (wt(r) ? r(e, this) : !!e[r]) || !s && (t == null ? void 0 : t.isDisabled);
  }
  get isLeaf() {
    const { data: e, config: t, childrenData: i, loaded: r } = this, { lazy: s, leaf: o } = t, a = wt(o) ? o(e, this) : e[o];
    return Ci(a) ? s && !r ? !1 : !(Array.isArray(i) && i.length) : !!a;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(e) {
    const { childrenData: t, children: i } = this, r = new Cy(e, this.config, this);
    return Array.isArray(t) ? t.push(e) : this.childrenData = [e], i.push(r), r;
  }
  calcText(e, t) {
    const i = e ? this.pathLabels.join(t) : this.label;
    return this.text = i, i;
  }
  broadcast(e, ...t) {
    const i = `onParent${Xs(e)}`;
    this.children.forEach((r) => {
      r && (r.broadcast(e, ...t), r[i] && r[i](...t));
    });
  }
  emit(e, ...t) {
    const { parent: i } = this, r = `onChild${Xs(e)}`;
    i && (i[r] && i[r](...t), i.emit(e, ...t));
  }
  onParentCheck(e) {
    this.isDisabled || this.setCheckState(e);
  }
  onChildCheck() {
    const { children: e } = this, t = e.filter((r) => !r.isDisabled), i = t.length ? t.every((r) => r.checked) : !1;
    this.setCheckState(i);
  }
  setCheckState(e) {
    const t = this.children.length, i = this.children.reduce((r, s) => {
      const o = s.checked ? 1 : s.indeterminate ? 0.5 : 0;
      return r + o;
    }, 0);
    this.checked = this.loaded && this.children.filter((r) => !r.isDisabled).every((r) => r.loaded && r.checked) && e, this.indeterminate = this.loaded && i !== t && i > 0;
  }
  doCheck(e) {
    if (this.checked === e)
      return;
    const { checkStrictly: t, multiple: i } = this.config;
    t || !i ? this.checked = e : (this.broadcast("check", e), this.setCheckState(e), this.emit("check"));
  }
};
const ky = (n, e) => n.reduce((t, i) => (i.isLeaf ? t.push(i) : (!e && t.push(i), t = t.concat(ky(i.children, e))), t), []);
let GC = class {
  constructor(e, t) {
    this.config = t;
    const i = (e || []).map((r) => new Sy(r, this.config));
    this.nodes = i, this.allNodes = ky(i, !1), this.leafNodes = ky(i, !0);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(e) {
    return e ? this.leafNodes : this.allNodes;
  }
  appendNode(e, t) {
    const i = t ? t.appendChild(e) : new Sy(e, this.config);
    t || this.nodes.push(i), this.allNodes.push(i), i.isLeaf && this.leafNodes.push(i);
  }
  appendNodes(e, t) {
    e.forEach((i) => this.appendNode(i, t));
  }
  getNodeByValue(e, t = !1) {
    return !e && e !== 0 ? null : this.getFlattedNodes(t).find((r) => cn(r.value, e) || cn(r.pathValues, e)) || null;
  }
  getSameNode(e) {
    return e && this.getFlattedNodes(!1).find(({ value: i, level: r }) => cn(e.value, i) && e.level === r) || null;
  }
};
const f_ = Ee({
  modelValue: {
    type: ce([Number, String, Array])
  },
  options: {
    type: ce(Array),
    default: () => []
  },
  props: {
    type: ce(Object),
    default: () => ({})
  }
}), uH = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: Xt,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}, hH = (n) => $(() => ({
  ...uH,
  ...n.props
})), KC = (n) => {
  if (!n)
    return 0;
  const e = n.id.split("-");
  return Number(e[e.length - 2]);
}, dH = (n) => {
  if (!n)
    return;
  const e = n.querySelector("input");
  e ? e.click() : q$(n) && n.click();
}, fH = (n, e) => {
  const t = e.slice(0), i = t.map((s) => s.uid), r = n.reduce((s, o) => {
    const a = i.indexOf(o.uid);
    return a > -1 && (s.push(o), t.splice(a, 1), i.splice(a, 1)), s;
  }, []);
  return r.push(...t), r;
}, pH = F({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: aH
  },
  props: {
    ...f_,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: Function
  },
  emits: [ot, Gn, "close", "expand-change"],
  setup(n, { emit: e, slots: t }) {
    let i = !1;
    const r = me("cascader"), s = hH(n);
    let o = null;
    const a = D(!0), l = D([]), c = D(null), u = D([]), h = D(null), d = D([]), f = $(() => s.value.expandTrigger === "hover"), p = $(() => n.renderLabel || t.default), g = () => {
      const { options: T } = n, B = s.value;
      i = !1, o = new GC(T, B), u.value = [o.getNodes()], B.lazy && Hs(n.options) ? (a.value = !1, m(void 0, (I) => {
        I && (o = new GC(I, B), u.value = [o.getNodes()]), a.value = !0, k(!1, !0);
      })) : k(!1, !0);
    }, m = (T, B) => {
      const I = s.value;
      T = T || new Sy({}, I, void 0, !0), T.loading = !0;
      const P = (A) => {
        const N = T, q = N.root ? null : N;
        A && (o == null || o.appendNodes(A, q)), N.loading = !1, N.loaded = !0, N.childrenData = N.childrenData || [], B && B(A);
      };
      I.lazyLoad(T, P);
    }, v = (T, B) => {
      var I;
      const { level: P } = T, A = u.value.slice(0, P);
      let N;
      T.isLeaf ? N = T.pathNodes[P - 2] : (N = T, A.push(T.children)), ((I = h.value) == null ? void 0 : I.uid) !== (N == null ? void 0 : N.uid) && (h.value = T, u.value = A, !B && e("expand-change", (T == null ? void 0 : T.pathValues) || []));
    }, y = (T, B, I = !0) => {
      const { checkStrictly: P, multiple: A } = s.value, N = d.value[0];
      i = !0, !A && (N == null || N.doCheck(!1)), T.doCheck(B), C(), I && !A && !P && e("close"), !I && !A && !P && b(T);
    }, b = (T) => {
      T && (T = T.parent, b(T), T && v(T));
    }, w = (T) => o == null ? void 0 : o.getFlattedNodes(T), x = (T) => {
      var B;
      return (B = w(T)) == null ? void 0 : B.filter((I) => I.checked !== !1);
    }, S = () => {
      d.value.forEach((T) => T.doCheck(!1)), C(), u.value = u.value.slice(0, 1), h.value = null, e("expand-change", []);
    }, C = () => {
      var T;
      const { checkStrictly: B, multiple: I } = s.value, P = d.value, A = x(!B), N = fH(P, A), q = N.map((j) => j.valueByOption);
      d.value = N, c.value = I ? q : (T = q[0]) != null ? T : null;
    }, k = (T = !1, B = !1) => {
      const { modelValue: I } = n, { lazy: P, multiple: A, checkStrictly: N } = s.value, q = !N;
      if (!(!a.value || i || !B && cn(I, c.value)))
        if (P && !T) {
          const H = hC(Sz(dC(I))).map((oe) => o == null ? void 0 : o.getNodeByValue(oe)).filter((oe) => !!oe && !oe.loaded && !oe.loading);
          H.length ? H.forEach((oe) => {
            m(oe, () => k(!1, B));
          }) : k(!0, B);
        } else {
          const j = A ? dC(I) : [I], H = hC(j.map((oe) => o == null ? void 0 : o.getNodeByValue(oe, q)));
          E(H, B), c.value = Bt(I);
        }
    }, E = (T, B = !0) => {
      const { checkStrictly: I } = s.value, P = d.value, A = T.filter((j) => !!j && (I || j.isLeaf)), N = o == null ? void 0 : o.getSameNode(h.value), q = B && N || A[0];
      q ? q.pathNodes.forEach((j) => v(j, !0)) : h.value = null, P.forEach((j) => j.doCheck(!1)), n.props.multiple ? Gt(A).forEach((j) => j.doCheck(!0)) : A.forEach((j) => j.doCheck(!0)), d.value = A, $e(M);
    }, M = () => {
      vt && l.value.forEach((T) => {
        const B = T == null ? void 0 : T.$el;
        if (B) {
          const I = B.querySelector(`.${r.namespace.value}-scrollbar__wrap`), P = B.querySelector(`.${r.b("node")}.${r.is("active")}`) || B.querySelector(`.${r.b("node")}.in-active-path`);
          tT(I, P);
        }
      });
    }, _ = (T) => {
      const B = T.target, { code: I } = T;
      switch (I) {
        case dt.up:
        case dt.down: {
          T.preventDefault();
          const P = I === dt.up ? -1 : 1;
          eg(W$(B, P, `.${r.b("node")}[tabindex="-1"]`));
          break;
        }
        case dt.left: {
          T.preventDefault();
          const P = l.value[KC(B) - 1], A = P == null ? void 0 : P.$el.querySelector(`.${r.b("node")}[aria-expanded="true"]`);
          eg(A);
          break;
        }
        case dt.right: {
          T.preventDefault();
          const P = l.value[KC(B) + 1], A = P == null ? void 0 : P.$el.querySelector(`.${r.b("node")}[tabindex="-1"]`);
          eg(A);
          break;
        }
        case dt.enter:
          dH(B);
          break;
      }
    };
    return ft(xw, Gt({
      config: s,
      expandingNode: h,
      checkedNodes: d,
      isHoverMenu: f,
      initialLoaded: a,
      renderLabelFn: p,
      lazyLoad: m,
      expandNode: v,
      handleCheckChange: y
    })), ne([s, () => n.options], g, {
      deep: !0,
      immediate: !0
    }), ne(() => n.modelValue, () => {
      i = !1, k();
    }, {
      deep: !0
    }), ne(() => c.value, (T) => {
      cn(T, n.modelValue) || (e(ot, T), e(Gn, T));
    }), ML(() => l.value = []), qe(() => !Hs(n.modelValue) && k()), {
      ns: r,
      menuList: l,
      menus: u,
      checkedNodes: d,
      handleKeyDown: _,
      handleCheckChange: y,
      getFlattedNodes: w,
      getCheckedNodes: x,
      clearCheckedNodes: S,
      calculateCheckedValue: C,
      scrollToExpandingNode: M
    };
  }
});
function gH(n, e, t, i, r, s) {
  const o = nt("el-cascader-menu");
  return R(), V("div", {
    class: L([n.ns.b("panel"), n.ns.is("bordered", n.border)]),
    onKeydown: e[0] || (e[0] = (...a) => n.handleKeyDown && n.handleKeyDown(...a))
  }, [
    (R(!0), V(Tt, null, ai(n.menus, (a, l) => (R(), ie(o, {
      key: l,
      ref_for: !0,
      ref: (c) => n.menuList[l] = c,
      index: l,
      nodes: [...a]
    }, null, 8, ["index", "nodes"]))), 128))
  ], 34);
}
var cg = /* @__PURE__ */ Ce(pH, [["render", gH], ["__file", "index.vue"]]);
cg.install = (n) => {
  n.component(cg.name, cg);
};
const mH = cg, Ov = Ee({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: String,
  size: {
    type: String,
    values: cc
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), vH = {
  close: (n) => n instanceof MouseEvent,
  click: (n) => n instanceof MouseEvent
}, bH = F({
  name: "ElTag"
}), yH = /* @__PURE__ */ F({
  ...bH,
  props: Ov,
  emits: vH,
  setup(n, { emit: e }) {
    const t = n, i = Yi(), r = me("tag"), s = $(() => {
      const { type: l, hit: c, effect: u, closable: h, round: d } = t;
      return [
        r.b(),
        r.is("closable", h),
        r.m(l || "primary"),
        r.m(i.value),
        r.m(u),
        r.is("hit", c),
        r.is("round", d)
      ];
    }), o = (l) => {
      e("close", l);
    }, a = (l) => {
      e("click", l);
    };
    return (l, c) => l.disableTransitions ? (R(), V("span", {
      key: 0,
      class: L(O(s)),
      style: Qe({ backgroundColor: l.color }),
      onClick: a
    }, [
      Z("span", {
        class: L(O(r).e("content"))
      }, [
        de(l.$slots, "default")
      ], 2),
      l.closable ? (R(), ie(O(Fe), {
        key: 0,
        class: L(O(r).e("close")),
        onClick: Le(o, ["stop"])
      }, {
        default: Y(() => [
          K(O(jo))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : G("v-if", !0)
    ], 6)) : (R(), ie(bo, {
      key: 1,
      name: `${O(r).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: Y(() => [
        Z("span", {
          class: L(O(s)),
          style: Qe({ backgroundColor: l.color }),
          onClick: a
        }, [
          Z("span", {
            class: L(O(r).e("content"))
          }, [
            de(l.$slots, "default")
          ], 2),
          l.closable ? (R(), ie(O(Fe), {
            key: 0,
            class: L(O(r).e("close")),
            onClick: Le(o, ["stop"])
          }, {
            default: Y(() => [
              K(O(jo))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : G("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var OH = /* @__PURE__ */ Ce(yH, [["__file", "tag.vue"]]);
const Jg = Ft(OH), wH = Ee({
  ...f_,
  size: _r,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: ce(Function),
    default: (n, e) => n.text.includes(e)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: ce(Function),
    default: () => !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: mi.teleported,
  tagType: { ...Ov.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), xH = {
  [ot]: (n) => !!n || n === null,
  [Gn]: (n) => !!n || n === null,
  focus: (n) => n instanceof FocusEvent,
  blur: (n) => n instanceof FocusEvent,
  visibleChange: (n) => Ei(n),
  expandChange: (n) => !!n,
  removeTag: (n) => !!n
}, SH = { key: 0 }, CH = ["placeholder", "onKeydown"], kH = ["onClick"], PH = "ElCascader", EH = F({
  name: PH
}), AH = /* @__PURE__ */ F({
  ...EH,
  props: wH,
  emits: xH,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: !0,
          phase: "main",
          fn: ({ state: J }) => {
            const { modifiersData: le, placement: ve } = J;
            ["right", "left", "bottom", "top"].includes(ve) || (le.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, s = yA();
    let o = 0, a = 0;
    const l = me("cascader"), c = me("input"), { t: u } = mn(), { form: h, formItem: d } = Mr(), f = D(null), p = D(null), g = D(null), m = D(null), v = D(null), y = D(!1), b = D(!1), w = D(!1), x = D(!1), S = D(""), C = D(""), k = D([]), E = D([]), M = D([]), _ = D(!1), T = $(() => s.style), B = $(() => i.disabled || (h == null ? void 0 : h.disabled)), I = $(() => i.placeholder || u("el.cascader.placeholder")), P = $(() => C.value || k.value.length > 0 || _.value ? "" : I.value), A = Yi(), N = $(() => ["small"].includes(A.value) ? "small" : "default"), q = $(() => !!i.props.multiple), j = $(() => !i.filterable || q.value), H = $(() => q.value ? C.value : S.value), oe = $(() => {
      var J;
      return ((J = m.value) == null ? void 0 : J.checkedNodes) || [];
    }), te = $(() => !i.clearable || B.value || w.value || !b.value ? !1 : !!oe.value.length), W = $(() => {
      const { showAllLevels: J, separator: le } = i, ve = oe.value;
      return ve.length ? q.value ? "" : ve[0].calcText(J, le) : "";
    }), U = $({
      get() {
        return Bt(i.modelValue);
      },
      set(J) {
        t(ot, J), t(Gn, J), i.validateEvent && (d == null || d.validate("change").catch((le) => pt(le)));
      }
    }), ae = $(() => [
      l.b(),
      l.m(A.value),
      l.is("disabled", B.value),
      s.class
    ]), he = $(() => [
      c.e("icon"),
      "icon-arrow-down",
      l.is("reverse", y.value)
    ]), ee = $(() => l.is("focus", y.value || x.value)), pe = $(() => {
      var J, le;
      return (le = (J = f.value) == null ? void 0 : J.popperRef) == null ? void 0 : le.contentRef;
    }), be = (J) => {
      var le, ve, Ue;
      B.value || (J = J ?? !y.value, J !== y.value && (y.value = J, (ve = (le = p.value) == null ? void 0 : le.input) == null || ve.setAttribute("aria-expanded", `${J}`), J ? (fe(), $e((Ue = m.value) == null ? void 0 : Ue.scrollToExpandingNode)) : i.filterable && Qi(), t("visibleChange", J)));
    }, fe = () => {
      $e(() => {
        var J;
        (J = f.value) == null || J.updatePopper();
      });
    }, Ae = () => {
      w.value = !1;
    }, ut = (J) => {
      const { showAllLevels: le, separator: ve } = i;
      return {
        node: J,
        key: J.uid,
        text: J.calcText(le, ve),
        hitState: !1,
        closable: !B.value && !J.isDisabled,
        isCollapseTag: !1
      };
    }, zt = (J) => {
      var le;
      const ve = J.node;
      ve.doCheck(!1), (le = m.value) == null || le.calculateCheckedValue(), t("removeTag", ve.valueByOption);
    }, Jn = () => {
      if (!q.value)
        return;
      const J = oe.value, le = [], ve = [];
      if (J.forEach((Ue) => ve.push(ut(Ue))), E.value = ve, J.length) {
        J.slice(0, i.maxCollapseTags).forEach((Cn) => le.push(ut(Cn)));
        const Ue = J.slice(i.maxCollapseTags), Zt = Ue.length;
        Zt && (i.collapseTags ? le.push({
          key: -1,
          text: `+ ${Zt}`,
          closable: !1,
          isCollapseTag: !0
        }) : Ue.forEach((Cn) => le.push(ut(Cn))));
      }
      k.value = le;
    }, ei = () => {
      var J, le;
      const { filterMethod: ve, showAllLevels: Ue, separator: Zt } = i, Cn = (le = (J = m.value) == null ? void 0 : J.getFlattedNodes(!i.props.checkStrictly)) == null ? void 0 : le.filter((jt) => jt.isDisabled ? !1 : (jt.calcText(Ue, Zt), ve(jt, H.value)));
      q.value && (k.value.forEach((jt) => {
        jt.hitState = !1;
      }), E.value.forEach((jt) => {
        jt.hitState = !1;
      })), w.value = !0, M.value = Cn, fe();
    }, Li = () => {
      var J;
      let le;
      w.value && v.value ? le = v.value.$el.querySelector(`.${l.e("suggestion-item")}`) : le = (J = m.value) == null ? void 0 : J.$el.querySelector(`.${l.b("node")}[tabindex="-1"]`), le && (le.focus(), !w.value && le.click());
    }, di = () => {
      var J, le;
      const ve = (J = p.value) == null ? void 0 : J.input, Ue = g.value, Zt = (le = v.value) == null ? void 0 : le.$el;
      if (!(!vt || !ve)) {
        if (Zt) {
          const Cn = Zt.querySelector(`.${l.e("suggestion-list")}`);
          Cn.style.minWidth = `${ve.offsetWidth}px`;
        }
        if (Ue) {
          const { offsetHeight: Cn } = Ue, jt = k.value.length > 0 ? `${Math.max(Cn + 6, o)}px` : `${o}px`;
          ve.style.height = jt, fe();
        }
      }
    }, Ii = (J) => {
      var le;
      return (le = m.value) == null ? void 0 : le.getCheckedNodes(J);
    }, fr = (J) => {
      fe(), t("expandChange", J);
    }, un = (J) => {
      var le;
      const ve = (le = J.target) == null ? void 0 : le.value;
      if (J.type === "compositionend")
        _.value = !1, $e(() => Te(ve));
      else {
        const Ue = ve[ve.length - 1] || "";
        _.value = !nw(Ue);
      }
    }, Bi = (J) => {
      if (!_.value)
        switch (J.code) {
          case dt.enter:
            be();
            break;
          case dt.down:
            be(!0), $e(Li), J.preventDefault();
            break;
          case dt.esc:
            y.value === !0 && (J.preventDefault(), J.stopPropagation(), be(!1));
            break;
          case dt.tab:
            be(!1);
            break;
        }
    }, Ui = () => {
      var J;
      (J = m.value) == null || J.clearCheckedNodes(), !y.value && i.filterable && Qi(), be(!1);
    }, Qi = () => {
      const { value: J } = W;
      S.value = J, C.value = J;
    }, ti = (J) => {
      var le, ve;
      const { checked: Ue } = J;
      q.value ? (le = m.value) == null || le.handleCheckChange(J, !Ue, !1) : (!Ue && ((ve = m.value) == null || ve.handleCheckChange(J, !0, !1)), be(!1));
    }, ge = (J) => {
      const le = J.target, { code: ve } = J;
      switch (ve) {
        case dt.up:
        case dt.down: {
          const Ue = ve === dt.up ? -1 : 1;
          eg(W$(le, Ue, `.${l.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case dt.enter:
          le.click();
          break;
      }
    }, Ke = () => {
      const J = k.value, le = J[J.length - 1];
      a = C.value ? 0 : a + 1, !(!le || !a || i.collapseTags && J.length > 1) && (le.hitState ? zt(le) : le.hitState = !0);
    }, Dt = (J) => {
      const le = J.target, ve = l.e("search-input");
      le.className === ve && (x.value = !0), t("focus", J);
    }, ni = (J) => {
      x.value = !1, t("blur", J);
    }, Ns = zo(() => {
      const { value: J } = H;
      if (!J)
        return;
      const le = i.beforeFilter(J);
      ry(le) ? le.then(ei).catch(() => {
      }) : le !== !1 ? ei() : Ae();
    }, i.debounce), Te = (J, le) => {
      !y.value && be(!0), !(le != null && le.isComposing) && (J ? Ns() : Ae());
    }, je = (J) => Number.parseFloat(PF(c.cssVarName("input-height"), J).value) - 2;
    return ne(w, fe), ne([oe, B], Jn), ne(k, () => {
      $e(() => di());
    }), ne(A, async () => {
      await $e();
      const J = p.value.input;
      o = je(J) || o, di();
    }), ne(W, Qi, { immediate: !0 }), qe(() => {
      const J = p.value.input, le = je(J);
      o = J.offsetHeight || le, pn(J, di);
    }), e({
      getCheckedNodes: Ii,
      cascaderPanelRef: m,
      togglePopperVisible: be,
      contentRef: pe
    }), (J, le) => (R(), ie(O(Fo), {
      ref_key: "tooltipRef",
      ref: f,
      visible: y.value,
      teleported: J.teleported,
      "popper-class": [O(l).e("dropdown"), J.popperClass],
      "popper-options": r,
      "fallback-placements": [
        "bottom-start",
        "bottom",
        "top-start",
        "top",
        "right",
        "left"
      ],
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      placement: "bottom-start",
      transition: `${O(l).namespace.value}-zoom-in-top`,
      effect: "light",
      pure: "",
      persistent: "",
      onHide: Ae
    }, {
      default: Y(() => [
        it((R(), V("div", {
          class: L(O(ae)),
          style: Qe(O(T)),
          onClick: le[5] || (le[5] = () => be(O(j) ? void 0 : !0)),
          onKeydown: Bi,
          onMouseenter: le[6] || (le[6] = (ve) => b.value = !0),
          onMouseleave: le[7] || (le[7] = (ve) => b.value = !1)
        }, [
          K(O(uc), {
            ref_key: "input",
            ref: p,
            modelValue: S.value,
            "onUpdate:modelValue": le[1] || (le[1] = (ve) => S.value = ve),
            placeholder: O(P),
            readonly: O(j),
            disabled: O(B),
            "validate-event": !1,
            size: O(A),
            class: L(O(ee)),
            tabindex: O(q) && J.filterable && !O(B) ? -1 : void 0,
            onCompositionstart: un,
            onCompositionupdate: un,
            onCompositionend: un,
            onFocus: Dt,
            onBlur: ni,
            onInput: Te
          }, {
            suffix: Y(() => [
              O(te) ? (R(), ie(O(Fe), {
                key: "clear",
                class: L([O(c).e("icon"), "icon-circle-close"]),
                onClick: Le(Ui, ["stop"])
              }, {
                default: Y(() => [
                  K(O(ah))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (R(), ie(O(Fe), {
                key: "arrow-down",
                class: L(O(he)),
                onClick: le[0] || (le[0] = Le((ve) => be(), ["stop"]))
              }, {
                default: Y(() => [
                  K(O(oh))
                ]),
                _: 1
              }, 8, ["class"]))
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]),
          O(q) ? (R(), V("div", {
            key: 0,
            ref_key: "tagWrapper",
            ref: g,
            class: L(O(l).e("tags"))
          }, [
            (R(!0), V(Tt, null, ai(k.value, (ve) => (R(), ie(O(Jg), {
              key: ve.key,
              type: J.tagType,
              size: O(N),
              hit: ve.hitState,
              closable: ve.closable,
              "disable-transitions": "",
              onClose: (Ue) => zt(ve)
            }, {
              default: Y(() => [
                ve.isCollapseTag === !1 ? (R(), V("span", SH, xe(ve.text), 1)) : (R(), ie(O(Fo), {
                  key: 1,
                  disabled: y.value || !J.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: Y(() => [
                    Z("span", null, xe(ve.text), 1)
                  ]),
                  content: Y(() => [
                    Z("div", {
                      class: L(O(l).e("collapse-tags"))
                    }, [
                      (R(!0), V(Tt, null, ai(E.value.slice(J.maxCollapseTags), (Ue, Zt) => (R(), V("div", {
                        key: Zt,
                        class: L(O(l).e("collapse-tag"))
                      }, [
                        (R(), ie(O(Jg), {
                          key: Ue.key,
                          class: "in-tooltip",
                          type: J.tagType,
                          size: O(N),
                          hit: Ue.hitState,
                          closable: Ue.closable,
                          "disable-transitions": "",
                          onClose: (Cn) => zt(Ue)
                        }, {
                          default: Y(() => [
                            Z("span", null, xe(Ue.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)),
            J.filterable && !O(B) ? it((R(), V("input", {
              key: 0,
              "onUpdate:modelValue": le[2] || (le[2] = (ve) => C.value = ve),
              type: "text",
              class: L(O(l).e("search-input")),
              placeholder: O(W) ? "" : O(I),
              onInput: le[3] || (le[3] = (ve) => Te(C.value, ve)),
              onClick: le[4] || (le[4] = Le((ve) => be(!0), ["stop"])),
              onKeydown: Ut(Ke, ["delete"]),
              onCompositionstart: un,
              onCompositionupdate: un,
              onCompositionend: un,
              onFocus: Dt,
              onBlur: ni
            }, null, 42, CH)), [
              [L1, C.value]
            ]) : G("v-if", !0)
          ], 2)) : G("v-if", !0)
        ], 38)), [
          [O(Rf), () => be(!1), O(pe)]
        ])
      ]),
      content: Y(() => [
        it(K(O(mH), {
          ref_key: "cascaderPanelRef",
          ref: m,
          modelValue: O(U),
          "onUpdate:modelValue": le[8] || (le[8] = (ve) => Zi(U) ? U.value = ve : null),
          options: J.options,
          props: i.props,
          border: !1,
          "render-label": J.$slots.default,
          onExpandChange: fr,
          onClose: le[9] || (le[9] = (ve) => J.$nextTick(() => be(!1)))
        }, null, 8, ["modelValue", "options", "props", "render-label"]), [
          [Qt, !w.value]
        ]),
        J.filterable ? it((R(), ie(O(_f), {
          key: 0,
          ref_key: "suggestionPanel",
          ref: v,
          tag: "ul",
          class: L(O(l).e("suggestion-panel")),
          "view-class": O(l).e("suggestion-list"),
          onKeydown: ge
        }, {
          default: Y(() => [
            M.value.length ? (R(!0), V(Tt, { key: 0 }, ai(M.value, (ve) => (R(), V("li", {
              key: ve.uid,
              class: L([
                O(l).e("suggestion-item"),
                O(l).is("checked", ve.checked)
              ]),
              tabindex: -1,
              onClick: (Ue) => ti(ve)
            }, [
              Z("span", null, xe(ve.text), 1),
              ve.checked ? (R(), ie(O(Fe), { key: 0 }, {
                default: Y(() => [
                  K(O(fv))
                ]),
                _: 1
              })) : G("v-if", !0)
            ], 10, kH))), 128)) : de(J.$slots, "empty", { key: 1 }, () => [
              Z("li", {
                class: L(O(l).e("empty-text"))
              }, xe(O(u)("el.cascader.noMatch")), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [Qt, w.value]
        ]) : G("v-if", !0)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "transition"]));
  }
});
var ug = /* @__PURE__ */ Ce(AH, [["__file", "cascader.vue"]]);
ug.install = (n) => {
  n.component(ug.name, ug);
};
const $H = ug, PKe = $H, JC = (n) => tt(n) || bt(n) || xt(n), TH = Ee({
  accordion: Boolean,
  modelValue: {
    type: ce([Array, String, Number]),
    default: () => Ur([])
  }
}), _H = {
  [ot]: JC,
  [Gn]: JC
}, p_ = Symbol("collapseContextKey"), MH = (n, e) => {
  const t = D(_d(n.modelValue)), i = (s) => {
    t.value = s;
    const o = n.accordion ? t.value[0] : t.value;
    e(ot, o), e(Gn, o);
  }, r = (s) => {
    if (n.accordion)
      i([t.value[0] === s ? "" : s]);
    else {
      const o = [...t.value], a = o.indexOf(s);
      a > -1 ? o.splice(a, 1) : o.push(s), i(o);
    }
  };
  return ne(() => n.modelValue, () => t.value = _d(n.modelValue), { deep: !0 }), ft(p_, {
    activeNames: t,
    handleItemClick: r
  }), {
    activeNames: t,
    setActiveNames: i
  };
}, RH = () => {
  const n = me("collapse");
  return {
    rootKls: $(() => n.b())
  };
}, NH = F({
  name: "ElCollapse"
}), DH = /* @__PURE__ */ F({
  ...NH,
  props: TH,
  emits: _H,
  setup(n, { expose: e, emit: t }) {
    const i = n, { activeNames: r, setActiveNames: s } = MH(i, t), { rootKls: o } = RH();
    return e({
      activeNames: r,
      setActiveNames: s
    }), (a, l) => (R(), V("div", {
      class: L(O(o))
    }, [
      de(a.$slots, "default")
    ], 2));
  }
});
var LH = /* @__PURE__ */ Ce(DH, [["__file", "collapse.vue"]]);
const IH = F({
  name: "ElCollapseTransition"
}), BH = /* @__PURE__ */ F({
  ...IH,
  setup(n) {
    const e = me("collapse-transition"), t = (r) => {
      r.style.maxHeight = "", r.style.overflow = r.dataset.oldOverflow, r.style.paddingTop = r.dataset.oldPaddingTop, r.style.paddingBottom = r.dataset.oldPaddingBottom;
    }, i = {
      beforeEnter(r) {
        r.dataset || (r.dataset = {}), r.dataset.oldPaddingTop = r.style.paddingTop, r.dataset.oldPaddingBottom = r.style.paddingBottom, r.style.height && (r.dataset.elExistsHeight = r.style.height), r.style.maxHeight = 0, r.style.paddingTop = 0, r.style.paddingBottom = 0;
      },
      enter(r) {
        requestAnimationFrame(() => {
          r.dataset.oldOverflow = r.style.overflow, r.dataset.elExistsHeight ? r.style.maxHeight = r.dataset.elExistsHeight : r.scrollHeight !== 0 ? r.style.maxHeight = `${r.scrollHeight}px` : r.style.maxHeight = 0, r.style.paddingTop = r.dataset.oldPaddingTop, r.style.paddingBottom = r.dataset.oldPaddingBottom, r.style.overflow = "hidden";
        });
      },
      afterEnter(r) {
        r.style.maxHeight = "", r.style.overflow = r.dataset.oldOverflow;
      },
      enterCancelled(r) {
        t(r);
      },
      beforeLeave(r) {
        r.dataset || (r.dataset = {}), r.dataset.oldPaddingTop = r.style.paddingTop, r.dataset.oldPaddingBottom = r.style.paddingBottom, r.dataset.oldOverflow = r.style.overflow, r.style.maxHeight = `${r.scrollHeight}px`, r.style.overflow = "hidden";
      },
      leave(r) {
        r.scrollHeight !== 0 && (r.style.maxHeight = 0, r.style.paddingTop = 0, r.style.paddingBottom = 0);
      },
      afterLeave(r) {
        t(r);
      },
      leaveCancelled(r) {
        t(r);
      }
    };
    return (r, s) => (R(), ie(bo, Pi({
      name: O(e).b()
    }, RL(i)), {
      default: Y(() => [
        de(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var hg = /* @__PURE__ */ Ce(BH, [["__file", "collapse-transition.vue"]]);
hg.install = (n) => {
  n.component(hg.name, hg);
};
const g_ = hg, QH = Ee({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: ce([String, Number]),
    default: void 0
  },
  disabled: Boolean
}), zH = (n) => {
  const e = ke(p_), { namespace: t } = me("collapse"), i = D(!1), r = D(!1), s = pw(), o = $(() => s.current++), a = $(() => {
    var d;
    return (d = n.name) != null ? d : `${t.value}-id-${s.prefix}-${O(o)}`;
  }), l = $(() => e == null ? void 0 : e.activeNames.value.includes(O(a)));
  return {
    focusing: i,
    id: o,
    isActive: l,
    handleFocus: () => {
      setTimeout(() => {
        r.value ? r.value = !1 : i.value = !0;
      }, 50);
    },
    handleHeaderClick: () => {
      n.disabled || (e == null || e.handleItemClick(O(a)), i.value = !1, r.value = !0);
    },
    handleEnterClick: () => {
      e == null || e.handleItemClick(O(a));
    }
  };
}, jH = (n, { focusing: e, isActive: t, id: i }) => {
  const r = me("collapse"), s = $(() => [
    r.b("item"),
    r.is("active", O(t)),
    r.is("disabled", n.disabled)
  ]), o = $(() => [
    r.be("item", "header"),
    r.is("active", O(t)),
    { focusing: O(e) && !n.disabled }
  ]), a = $(() => [
    r.be("item", "arrow"),
    r.is("active", O(t))
  ]), l = $(() => r.be("item", "wrap")), c = $(() => r.be("item", "content")), u = $(() => r.b(`content-${O(i)}`)), h = $(() => r.b(`head-${O(i)}`));
  return {
    arrowKls: a,
    headKls: o,
    rootKls: s,
    itemWrapperKls: l,
    itemContentKls: c,
    scopedContentId: u,
    scopedHeadId: h
  };
}, VH = ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex"], FH = ["id", "aria-hidden", "aria-labelledby"], ZH = F({
  name: "ElCollapseItem"
}), qH = /* @__PURE__ */ F({
  ...ZH,
  props: QH,
  setup(n, { expose: e }) {
    const t = n, {
      focusing: i,
      id: r,
      isActive: s,
      handleFocus: o,
      handleHeaderClick: a,
      handleEnterClick: l
    } = zH(t), {
      arrowKls: c,
      headKls: u,
      rootKls: h,
      itemWrapperKls: d,
      itemContentKls: f,
      scopedContentId: p,
      scopedHeadId: g
    } = jH(t, { focusing: i, isActive: s, id: r });
    return e({
      isActive: s
    }), (m, v) => (R(), V("div", {
      class: L(O(h))
    }, [
      Z("button", {
        id: O(g),
        class: L(O(u)),
        "aria-expanded": O(s),
        "aria-controls": O(p),
        "aria-describedby": O(p),
        tabindex: m.disabled ? -1 : 0,
        type: "button",
        onClick: v[0] || (v[0] = (...y) => O(a) && O(a)(...y)),
        onKeydown: v[1] || (v[1] = Ut(Le((...y) => O(l) && O(l)(...y), ["stop", "prevent"]), ["space", "enter"])),
        onFocus: v[2] || (v[2] = (...y) => O(o) && O(o)(...y)),
        onBlur: v[3] || (v[3] = (y) => i.value = !1)
      }, [
        de(m.$slots, "title", {}, () => [
          Yn(xe(m.title), 1)
        ]),
        K(O(Fe), {
          class: L(O(c))
        }, {
          default: Y(() => [
            K(O(ac))
          ]),
          _: 1
        }, 8, ["class"])
      ], 42, VH),
      K(O(g_), null, {
        default: Y(() => [
          it(Z("div", {
            id: O(p),
            role: "region",
            class: L(O(d)),
            "aria-hidden": !O(s),
            "aria-labelledby": O(g)
          }, [
            Z("div", {
              class: L(O(f))
            }, [
              de(m.$slots, "default")
            ], 2)
          ], 10, FH), [
            [Qt, O(s)]
          ])
        ]),
        _: 3
      })
    ], 2));
  }
});
var m_ = /* @__PURE__ */ Ce(qH, [["__file", "collapse-item.vue"]]);
const EKe = Ft(LH, {
  CollapseItem: m_
}), AKe = As(m_), WH = Ee({
  color: {
    type: ce(Object),
    required: !0
  },
  vertical: {
    type: Boolean,
    default: !1
  }
});
let $0 = !1;
function Id(n, e) {
  if (!vt)
    return;
  const t = function(s) {
    var o;
    (o = e.drag) == null || o.call(e, s);
  }, i = function(s) {
    var o;
    document.removeEventListener("mousemove", t), document.removeEventListener("mouseup", i), document.removeEventListener("touchmove", t), document.removeEventListener("touchend", i), document.onselectstart = null, document.ondragstart = null, $0 = !1, (o = e.end) == null || o.call(e, s);
  }, r = function(s) {
    var o;
    $0 || (s.preventDefault(), document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", t), document.addEventListener("mouseup", i), document.addEventListener("touchmove", t), document.addEventListener("touchend", i), $0 = !0, (o = e.start) == null || o.call(e, s));
  };
  n.addEventListener("mousedown", r), n.addEventListener("touchstart", r);
}
const HH = (n) => {
  const e = Xe(), t = In(), i = In();
  function r(o) {
    o.target !== t.value && s(o);
  }
  function s(o) {
    if (!i.value || !t.value)
      return;
    const l = e.vnode.el.getBoundingClientRect(), { clientX: c, clientY: u } = ew(o);
    if (n.vertical) {
      let h = u - l.top;
      h = Math.max(t.value.offsetHeight / 2, h), h = Math.min(h, l.height - t.value.offsetHeight / 2), n.color.set("alpha", Math.round((h - t.value.offsetHeight / 2) / (l.height - t.value.offsetHeight) * 100));
    } else {
      let h = c - l.left;
      h = Math.max(t.value.offsetWidth / 2, h), h = Math.min(h, l.width - t.value.offsetWidth / 2), n.color.set("alpha", Math.round((h - t.value.offsetWidth / 2) / (l.width - t.value.offsetWidth) * 100));
    }
  }
  return {
    thumb: t,
    bar: i,
    handleDrag: s,
    handleClick: r
  };
}, XH = (n, {
  bar: e,
  thumb: t,
  handleDrag: i
}) => {
  const r = Xe(), s = me("color-alpha-slider"), o = D(0), a = D(0), l = D();
  function c() {
    if (!t.value || n.vertical)
      return 0;
    const y = r.vnode.el, b = n.color.get("alpha");
    return y ? Math.round(b * (y.offsetWidth - t.value.offsetWidth / 2) / 100) : 0;
  }
  function u() {
    if (!t.value)
      return 0;
    const y = r.vnode.el;
    if (!n.vertical)
      return 0;
    const b = n.color.get("alpha");
    return y ? Math.round(b * (y.offsetHeight - t.value.offsetHeight / 2) / 100) : 0;
  }
  function h() {
    if (n.color && n.color.value) {
      const { r: y, g: b, b: w } = n.color.toRgb();
      return `linear-gradient(to right, rgba(${y}, ${b}, ${w}, 0) 0%, rgba(${y}, ${b}, ${w}, 1) 100%)`;
    }
    return "";
  }
  function d() {
    o.value = c(), a.value = u(), l.value = h();
  }
  qe(() => {
    if (!e.value || !t.value)
      return;
    const y = {
      drag: (b) => {
        i(b);
      },
      end: (b) => {
        i(b);
      }
    };
    Id(e.value, y), Id(t.value, y), d();
  }), ne(() => n.color.get("alpha"), () => d()), ne(() => n.color.value, () => d());
  const f = $(() => [s.b(), s.is("vertical", n.vertical)]), p = $(() => s.e("bar")), g = $(() => s.e("thumb")), m = $(() => ({ background: l.value })), v = $(() => ({
    left: ur(o.value),
    top: ur(a.value)
  }));
  return { rootKls: f, barKls: p, barStyle: m, thumbKls: g, thumbStyle: v, update: d };
}, YH = "ElColorAlphaSlider", UH = F({
  name: YH
}), GH = /* @__PURE__ */ F({
  ...UH,
  props: WH,
  setup(n, { expose: e }) {
    const t = n, { bar: i, thumb: r, handleDrag: s, handleClick: o } = HH(t), { rootKls: a, barKls: l, barStyle: c, thumbKls: u, thumbStyle: h, update: d } = XH(t, {
      bar: i,
      thumb: r,
      handleDrag: s
    });
    return e({
      update: d,
      bar: i,
      thumb: r
    }), (f, p) => (R(), V("div", {
      class: L(O(a))
    }, [
      Z("div", {
        ref_key: "bar",
        ref: i,
        class: L(O(l)),
        style: Qe(O(c)),
        onClick: p[0] || (p[0] = (...g) => O(o) && O(o)(...g))
      }, null, 6),
      Z("div", {
        ref_key: "thumb",
        ref: r,
        class: L(O(u)),
        style: Qe(O(h))
      }, null, 6)
    ], 2));
  }
});
var KH = /* @__PURE__ */ Ce(GH, [["__file", "alpha-slider.vue"]]);
const JH = F({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: !0
    },
    vertical: Boolean
  },
  setup(n) {
    const e = me("color-hue-slider"), t = Xe(), i = D(), r = D(), s = D(0), o = D(0), a = $(() => n.color.get("hue"));
    ne(() => a.value, () => {
      d();
    });
    function l(f) {
      f.target !== i.value && c(f);
    }
    function c(f) {
      if (!r.value || !i.value)
        return;
      const g = t.vnode.el.getBoundingClientRect(), { clientX: m, clientY: v } = ew(f);
      let y;
      if (n.vertical) {
        let b = v - g.top;
        b = Math.min(b, g.height - i.value.offsetHeight / 2), b = Math.max(i.value.offsetHeight / 2, b), y = Math.round((b - i.value.offsetHeight / 2) / (g.height - i.value.offsetHeight) * 360);
      } else {
        let b = m - g.left;
        b = Math.min(b, g.width - i.value.offsetWidth / 2), b = Math.max(i.value.offsetWidth / 2, b), y = Math.round((b - i.value.offsetWidth / 2) / (g.width - i.value.offsetWidth) * 360);
      }
      n.color.set("hue", y);
    }
    function u() {
      if (!i.value)
        return 0;
      const f = t.vnode.el;
      if (n.vertical)
        return 0;
      const p = n.color.get("hue");
      return f ? Math.round(p * (f.offsetWidth - i.value.offsetWidth / 2) / 360) : 0;
    }
    function h() {
      if (!i.value)
        return 0;
      const f = t.vnode.el;
      if (!n.vertical)
        return 0;
      const p = n.color.get("hue");
      return f ? Math.round(p * (f.offsetHeight - i.value.offsetHeight / 2) / 360) : 0;
    }
    function d() {
      s.value = u(), o.value = h();
    }
    return qe(() => {
      if (!r.value || !i.value)
        return;
      const f = {
        drag: (p) => {
          c(p);
        },
        end: (p) => {
          c(p);
        }
      };
      Id(r.value, f), Id(i.value, f), d();
    }), {
      bar: r,
      thumb: i,
      thumbLeft: s,
      thumbTop: o,
      hueValue: a,
      handleClick: l,
      update: d,
      ns: e
    };
  }
});
function eX(n, e, t, i, r, s) {
  return R(), V("div", {
    class: L([n.ns.b(), n.ns.is("vertical", n.vertical)])
  }, [
    Z("div", {
      ref: "bar",
      class: L(n.ns.e("bar")),
      onClick: e[0] || (e[0] = (...o) => n.handleClick && n.handleClick(...o))
    }, null, 2),
    Z("div", {
      ref: "thumb",
      class: L(n.ns.e("thumb")),
      style: Qe({
        left: n.thumbLeft + "px",
        top: n.thumbTop + "px"
      })
    }, null, 6)
  ], 2);
}
var tX = /* @__PURE__ */ Ce(JH, [["render", eX], ["__file", "hue-slider.vue"]]);
const nX = Ee({
  modelValue: String,
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  size: _r,
  popperClass: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  predefine: {
    type: ce(Array)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), iX = {
  [ot]: (n) => bt(n) || Ni(n),
  [Gn]: (n) => bt(n) || Ni(n),
  activeChange: (n) => bt(n) || Ni(n),
  focus: (n) => n instanceof FocusEvent,
  blur: (n) => n instanceof FocusEvent
}, v_ = Symbol("colorPickerContextKey"), ek = function(n, e, t) {
  return [
    n,
    e * t / ((n = (2 - e) * t) < 1 ? n : 2 - n) || 0,
    n / 2
  ];
}, rX = function(n) {
  return typeof n == "string" && n.includes(".") && Number.parseFloat(n) === 1;
}, sX = function(n) {
  return typeof n == "string" && n.includes("%");
}, Wc = function(n, e) {
  rX(n) && (n = "100%");
  const t = sX(n);
  return n = Math.min(e, Math.max(0, Number.parseFloat(`${n}`))), t && (n = Number.parseInt(`${n * e}`, 10) / 100), Math.abs(n - e) < 1e-6 ? 1 : n % e / Number.parseFloat(e);
}, tk = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F"
}, dg = (n) => {
  n = Math.min(Math.round(n), 255);
  const e = Math.floor(n / 16), t = n % 16;
  return `${tk[e] || e}${tk[t] || t}`;
}, nk = function({ r: n, g: e, b: t }) {
  return Number.isNaN(+n) || Number.isNaN(+e) || Number.isNaN(+t) ? "" : `#${dg(n)}${dg(e)}${dg(t)}`;
}, T0 = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, ol = function(n) {
  return n.length === 2 ? (T0[n[0].toUpperCase()] || +n[0]) * 16 + (T0[n[1].toUpperCase()] || +n[1]) : T0[n[1].toUpperCase()] || +n[1];
}, oX = function(n, e, t) {
  e = e / 100, t = t / 100;
  let i = e;
  const r = Math.max(t, 0.01);
  t *= 2, e *= t <= 1 ? t : 2 - t, i *= r <= 1 ? r : 2 - r;
  const s = (t + e) / 2, o = t === 0 ? 2 * i / (r + i) : 2 * e / (t + e);
  return {
    h: n,
    s: o * 100,
    v: s * 100
  };
}, ik = (n, e, t) => {
  n = Wc(n, 255), e = Wc(e, 255), t = Wc(t, 255);
  const i = Math.max(n, e, t), r = Math.min(n, e, t);
  let s;
  const o = i, a = i - r, l = i === 0 ? 0 : a / i;
  if (i === r)
    s = 0;
  else {
    switch (i) {
      case n: {
        s = (e - t) / a + (e < t ? 6 : 0);
        break;
      }
      case e: {
        s = (t - n) / a + 2;
        break;
      }
      case t: {
        s = (n - e) / a + 4;
        break;
      }
    }
    s /= 6;
  }
  return { h: s * 360, s: l * 100, v: o * 100 };
}, $h = function(n, e, t) {
  n = Wc(n, 360) * 6, e = Wc(e, 100), t = Wc(t, 100);
  const i = Math.floor(n), r = n - i, s = t * (1 - e), o = t * (1 - r * e), a = t * (1 - (1 - r) * e), l = i % 6, c = [t, o, s, s, a, t][l], u = [a, t, t, o, s, s][l], h = [s, s, a, t, t, o][l];
  return {
    r: Math.round(c * 255),
    g: Math.round(u * 255),
    b: Math.round(h * 255)
  };
};
let sd = class {
  constructor(e = {}) {
    this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this.enableAlpha = !1, this.format = "hex", this.value = "";
    for (const t in e)
      Xi(e, t) && (this[t] = e[t]);
    e.value ? this.fromString(e.value) : this.doOnChange();
  }
  set(e, t) {
    if (arguments.length === 1 && typeof e == "object") {
      for (const i in e)
        Xi(e, i) && this.set(i, e[i]);
      return;
    }
    this[`_${e}`] = t, this.doOnChange();
  }
  get(e) {
    return e === "alpha" ? Math.floor(this[`_${e}`]) : this[`_${e}`];
  }
  toRgb() {
    return $h(this._hue, this._saturation, this._value);
  }
  fromString(e) {
    if (!e) {
      this._hue = 0, this._saturation = 100, this._value = 100, this.doOnChange();
      return;
    }
    const t = (i, r, s) => {
      this._hue = Math.max(0, Math.min(360, i)), this._saturation = Math.max(0, Math.min(100, r)), this._value = Math.max(0, Math.min(100, s)), this.doOnChange();
    };
    if (e.includes("hsl")) {
      const i = e.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((r) => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
      if (i.length === 4 ? this._alpha = Number.parseFloat(i[3]) * 100 : i.length === 3 && (this._alpha = 100), i.length >= 3) {
        const { h: r, s, v: o } = oX(i[0], i[1], i[2]);
        t(r, s, o);
      }
    } else if (e.includes("hsv")) {
      const i = e.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((r) => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
      i.length === 4 ? this._alpha = Number.parseFloat(i[3]) * 100 : i.length === 3 && (this._alpha = 100), i.length >= 3 && t(i[0], i[1], i[2]);
    } else if (e.includes("rgb")) {
      const i = e.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((r) => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
      if (i.length === 4 ? this._alpha = Number.parseFloat(i[3]) * 100 : i.length === 3 && (this._alpha = 100), i.length >= 3) {
        const { h: r, s, v: o } = ik(i[0], i[1], i[2]);
        t(r, s, o);
      }
    } else if (e.includes("#")) {
      const i = e.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(i))
        return;
      let r, s, o;
      i.length === 3 ? (r = ol(i[0] + i[0]), s = ol(i[1] + i[1]), o = ol(i[2] + i[2])) : (i.length === 6 || i.length === 8) && (r = ol(i.slice(0, 2)), s = ol(i.slice(2, 4)), o = ol(i.slice(4, 6))), i.length === 8 ? this._alpha = ol(i.slice(6)) / 255 * 100 : (i.length === 3 || i.length === 6) && (this._alpha = 100);
      const { h: a, s: l, v: c } = ik(r, s, o);
      t(a, l, c);
    }
  }
  compare(e) {
    return Math.abs(e._hue - this._hue) < 2 && Math.abs(e._saturation - this._saturation) < 1 && Math.abs(e._value - this._value) < 1 && Math.abs(e._alpha - this._alpha) < 1;
  }
  doOnChange() {
    const { _hue: e, _saturation: t, _value: i, _alpha: r, format: s } = this;
    if (this.enableAlpha)
      switch (s) {
        case "hsl": {
          const o = ek(e, t / 100, i / 100);
          this.value = `hsla(${e}, ${Math.round(o[1] * 100)}%, ${Math.round(o[2] * 100)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hsv": {
          this.value = `hsva(${e}, ${Math.round(t)}%, ${Math.round(i)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hex": {
          this.value = `${nk($h(e, t, i))}${dg(r * 255 / 100)}`;
          break;
        }
        default: {
          const { r: o, g: a, b: l } = $h(e, t, i);
          this.value = `rgba(${o}, ${a}, ${l}, ${this.get("alpha") / 100})`;
        }
      }
    else
      switch (s) {
        case "hsl": {
          const o = ek(e, t / 100, i / 100);
          this.value = `hsl(${e}, ${Math.round(o[1] * 100)}%, ${Math.round(o[2] * 100)}%)`;
          break;
        }
        case "hsv": {
          this.value = `hsv(${e}, ${Math.round(t)}%, ${Math.round(i)}%)`;
          break;
        }
        case "rgb": {
          const { r: o, g: a, b: l } = $h(e, t, i);
          this.value = `rgb(${o}, ${a}, ${l})`;
          break;
        }
        default:
          this.value = nk($h(e, t, i));
      }
  }
};
const aX = F({
  props: {
    colors: {
      type: Array,
      required: !0
    },
    color: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = me("color-predefine"), { currentColor: t } = ke(v_), i = D(s(n.colors, n.color));
    ne(() => t.value, (o) => {
      const a = new sd();
      a.fromString(o), i.value.forEach((l) => {
        l.selected = a.compare(l);
      });
    }), Fr(() => {
      i.value = s(n.colors, n.color);
    });
    function r(o) {
      n.color.fromString(n.colors[o]);
    }
    function s(o, a) {
      return o.map((l) => {
        const c = new sd();
        return c.enableAlpha = !0, c.format = "rgba", c.fromString(l), c.selected = c.value === a.value, c;
      });
    }
    return {
      rgbaColors: i,
      handleSelect: r,
      ns: e
    };
  }
}), lX = ["onClick"];
function cX(n, e, t, i, r, s) {
  return R(), V("div", {
    class: L(n.ns.b())
  }, [
    Z("div", {
      class: L(n.ns.e("colors"))
    }, [
      (R(!0), V(Tt, null, ai(n.rgbaColors, (o, a) => (R(), V("div", {
        key: n.colors[a],
        class: L([
          n.ns.e("color-selector"),
          n.ns.is("alpha", o._alpha < 100),
          { selected: o.selected }
        ]),
        onClick: (l) => n.handleSelect(a)
      }, [
        Z("div", {
          style: Qe({ backgroundColor: o.value })
        }, null, 4)
      ], 10, lX))), 128))
    ], 2)
  ], 2);
}
var uX = /* @__PURE__ */ Ce(aX, [["render", cX], ["__file", "predefine.vue"]]);
const hX = F({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = me("color-svpanel"), t = Xe(), i = D(0), r = D(0), s = D("hsl(0, 100%, 50%)"), o = $(() => {
      const c = n.color.get("hue"), u = n.color.get("value");
      return { hue: c, value: u };
    });
    function a() {
      const c = n.color.get("saturation"), u = n.color.get("value"), h = t.vnode.el, { clientWidth: d, clientHeight: f } = h;
      r.value = c * d / 100, i.value = (100 - u) * f / 100, s.value = `hsl(${n.color.get("hue")}, 100%, 50%)`;
    }
    function l(c) {
      const h = t.vnode.el.getBoundingClientRect(), { clientX: d, clientY: f } = ew(c);
      let p = d - h.left, g = f - h.top;
      p = Math.max(0, p), p = Math.min(p, h.width), g = Math.max(0, g), g = Math.min(g, h.height), r.value = p, i.value = g, n.color.set({
        saturation: p / h.width * 100,
        value: 100 - g / h.height * 100
      });
    }
    return ne(() => o.value, () => {
      a();
    }), qe(() => {
      Id(t.vnode.el, {
        drag: (c) => {
          l(c);
        },
        end: (c) => {
          l(c);
        }
      }), a();
    }), {
      cursorTop: i,
      cursorLeft: r,
      background: s,
      colorValue: o,
      handleDrag: l,
      update: a,
      ns: e
    };
  }
}), dX = /* @__PURE__ */ Z("div", null, null, -1), fX = [
  dX
];
function pX(n, e, t, i, r, s) {
  return R(), V("div", {
    class: L(n.ns.b()),
    style: Qe({
      backgroundColor: n.background
    })
  }, [
    Z("div", {
      class: L(n.ns.e("white"))
    }, null, 2),
    Z("div", {
      class: L(n.ns.e("black"))
    }, null, 2),
    Z("div", {
      class: L(n.ns.e("cursor")),
      style: Qe({
        top: n.cursorTop + "px",
        left: n.cursorLeft + "px"
      })
    }, fX, 6)
  ], 6);
}
var gX = /* @__PURE__ */ Ce(hX, [["render", pX], ["__file", "sv-panel.vue"]]);
const mX = ["onKeydown"], vX = ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex"], bX = F({
  name: "ElColorPicker"
}), yX = /* @__PURE__ */ F({
  ...bX,
  props: nX,
  emits: iX,
  setup(n, { expose: e, emit: t }) {
    const i = n, { t: r } = mn(), s = me("color"), { formItem: o } = Mr(), a = Yi(), l = ts(), { inputId: c, isLabeledByFormItem: u } = Ka(i, {
      formItemContext: o
    }), h = D(), d = D(), f = D(), p = D(), g = D(), m = D(), {
      isFocused: v,
      handleFocus: y,
      handleBlur: b
    } = mv(g, {
      beforeBlur(fe) {
        var Ae;
        return (Ae = p.value) == null ? void 0 : Ae.isFocusInsideContent(fe);
      },
      afterBlur() {
        A(!1), H();
      }
    }), w = (fe) => {
      if (l.value)
        return be();
      y(fe);
    };
    let x = !0;
    const S = Gt(new sd({
      enableAlpha: i.showAlpha,
      format: i.colorFormat || "",
      value: i.modelValue
    })), C = D(!1), k = D(!1), E = D(""), M = $(() => !i.modelValue && !k.value ? "transparent" : P(S, i.showAlpha)), _ = $(() => !i.modelValue && !k.value ? "" : S.value), T = $(() => u.value ? void 0 : i.label || r("el.colorpicker.defaultLabel")), B = $(() => u.value ? o == null ? void 0 : o.labelId : void 0), I = $(() => [
      s.b("picker"),
      s.is("disabled", l.value),
      s.bm("picker", a.value),
      s.is("focused", v.value)
    ]);
    function P(fe, Ae) {
      if (!(fe instanceof sd))
        throw new TypeError("color should be instance of _color Class");
      const { r: ut, g: zt, b: Jn } = fe.toRgb();
      return Ae ? `rgba(${ut}, ${zt}, ${Jn}, ${fe.get("alpha") / 100})` : `rgb(${ut}, ${zt}, ${Jn})`;
    }
    function A(fe) {
      C.value = fe;
    }
    const N = zo(A, 100, { leading: !0 });
    function q() {
      l.value || A(!0);
    }
    function j() {
      N(!1), H();
    }
    function H() {
      $e(() => {
        i.modelValue ? S.fromString(i.modelValue) : (S.value = "", $e(() => {
          k.value = !1;
        }));
      });
    }
    function oe() {
      l.value || N(!C.value);
    }
    function te() {
      S.fromString(E.value);
    }
    function W() {
      const fe = S.value;
      t(ot, fe), t("change", fe), i.validateEvent && (o == null || o.validate("change").catch((Ae) => pt(Ae))), N(!1), $e(() => {
        const Ae = new sd({
          enableAlpha: i.showAlpha,
          format: i.colorFormat || "",
          value: i.modelValue
        });
        S.compare(Ae) || H();
      });
    }
    function U() {
      N(!1), t(ot, null), t("change", null), i.modelValue !== null && i.validateEvent && (o == null || o.validate("change").catch((fe) => pt(fe))), H();
    }
    function ae(fe) {
      if (C.value && (j(), v.value)) {
        const Ae = new FocusEvent("focus", fe);
        b(Ae);
      }
    }
    function he(fe) {
      fe.preventDefault(), fe.stopPropagation(), A(!1), H();
    }
    function ee(fe) {
      switch (fe.code) {
        case dt.enter:
        case dt.space:
          fe.preventDefault(), fe.stopPropagation(), q(), m.value.focus();
          break;
        case dt.esc:
          he(fe);
          break;
      }
    }
    function pe() {
      g.value.focus();
    }
    function be() {
      g.value.blur();
    }
    return qe(() => {
      i.modelValue && (E.value = _.value);
    }), ne(() => i.modelValue, (fe) => {
      fe ? fe && fe !== S.value && (x = !1, S.fromString(fe)) : k.value = !1;
    }), ne(() => _.value, (fe) => {
      E.value = fe, x && t("activeChange", fe), x = !0;
    }), ne(() => S.value, () => {
      !i.modelValue && !k.value && (k.value = !0);
    }), ne(() => C.value, () => {
      $e(() => {
        var fe, Ae, ut;
        (fe = h.value) == null || fe.update(), (Ae = d.value) == null || Ae.update(), (ut = f.value) == null || ut.update();
      });
    }), ft(v_, {
      currentColor: _
    }), e({
      color: S,
      show: q,
      hide: j,
      focus: pe,
      blur: be
    }), (fe, Ae) => (R(), ie(O(Fo), {
      ref_key: "popper",
      ref: p,
      visible: C.value,
      "show-arrow": !1,
      "fallback-placements": ["bottom", "top", "right", "left"],
      offset: 0,
      "gpu-acceleration": !1,
      "popper-class": [O(s).be("picker", "panel"), O(s).b("dropdown"), fe.popperClass],
      "stop-popper-mouse-event": !1,
      effect: "light",
      trigger: "click",
      transition: `${O(s).namespace.value}-zoom-in-top`,
      persistent: "",
      onHide: Ae[2] || (Ae[2] = (ut) => A(!1))
    }, {
      content: Y(() => [
        it((R(), V("div", {
          onKeydown: Ut(he, ["esc"])
        }, [
          Z("div", {
            class: L(O(s).be("dropdown", "main-wrapper"))
          }, [
            K(tX, {
              ref_key: "hue",
              ref: h,
              class: "hue-slider",
              color: O(S),
              vertical: ""
            }, null, 8, ["color"]),
            K(gX, {
              ref_key: "sv",
              ref: d,
              color: O(S)
            }, null, 8, ["color"])
          ], 2),
          fe.showAlpha ? (R(), ie(KH, {
            key: 0,
            ref_key: "alpha",
            ref: f,
            color: O(S)
          }, null, 8, ["color"])) : G("v-if", !0),
          fe.predefine ? (R(), ie(uX, {
            key: 1,
            ref: "predefine",
            color: O(S),
            colors: fe.predefine
          }, null, 8, ["color", "colors"])) : G("v-if", !0),
          Z("div", {
            class: L(O(s).be("dropdown", "btns"))
          }, [
            Z("span", {
              class: L(O(s).be("dropdown", "value"))
            }, [
              K(O(uc), {
                ref_key: "inputRef",
                ref: m,
                modelValue: E.value,
                "onUpdate:modelValue": Ae[0] || (Ae[0] = (ut) => E.value = ut),
                "validate-event": !1,
                size: "small",
                onKeyup: Ut(te, ["enter"]),
                onBlur: te
              }, null, 8, ["modelValue", "onKeyup"])
            ], 2),
            K(O(Wl), {
              class: L(O(s).be("dropdown", "link-btn")),
              text: "",
              size: "small",
              onClick: U
            }, {
              default: Y(() => [
                Yn(xe(O(r)("el.colorpicker.clear")), 1)
              ]),
              _: 1
            }, 8, ["class"]),
            K(O(Wl), {
              plain: "",
              size: "small",
              class: L(O(s).be("dropdown", "btn")),
              onClick: W
            }, {
              default: Y(() => [
                Yn(xe(O(r)("el.colorpicker.confirm")), 1)
              ]),
              _: 1
            }, 8, ["class"])
          ], 2)
        ], 40, mX)), [
          [O(Rf), ae]
        ])
      ]),
      default: Y(() => [
        Z("div", {
          id: O(c),
          ref_key: "triggerRef",
          ref: g,
          class: L(O(I)),
          role: "button",
          "aria-label": O(T),
          "aria-labelledby": O(B),
          "aria-description": O(r)("el.colorpicker.description", { color: fe.modelValue || "" }),
          "aria-disabled": O(l),
          tabindex: O(l) ? -1 : fe.tabindex,
          onKeydown: ee,
          onFocus: w,
          onBlur: Ae[1] || (Ae[1] = (...ut) => O(b) && O(b)(...ut))
        }, [
          O(l) ? (R(), V("div", {
            key: 0,
            class: L(O(s).be("picker", "mask"))
          }, null, 2)) : G("v-if", !0),
          Z("div", {
            class: L(O(s).be("picker", "trigger")),
            onClick: oe
          }, [
            Z("span", {
              class: L([O(s).be("picker", "color"), O(s).is("alpha", fe.showAlpha)])
            }, [
              Z("span", {
                class: L(O(s).be("picker", "color-inner")),
                style: Qe({
                  backgroundColor: O(M)
                })
              }, [
                it(K(O(Fe), {
                  class: L([O(s).be("picker", "icon"), O(s).is("icon-arrow-down")])
                }, {
                  default: Y(() => [
                    K(O(oh))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [Qt, fe.modelValue || k.value]
                ]),
                it(K(O(Fe), {
                  class: L([O(s).be("picker", "empty"), O(s).is("icon-close")])
                }, {
                  default: Y(() => [
                    K(O(jo))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [Qt, !fe.modelValue && !k.value]
                ])
              ], 6)
            ], 2)
          ], 2)
        ], 42, vX)
      ]),
      _: 1
    }, 8, ["visible", "popper-class", "transition"]));
  }
});
var OX = /* @__PURE__ */ Ce(yX, [["__file", "color-picker.vue"]]);
const TKe = Ft(OX), wX = Ee({
  mask: {
    type: Boolean,
    default: !0
  },
  customMaskEvent: {
    type: Boolean,
    default: !1
  },
  overlayClass: {
    type: ce([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: ce([String, Number])
  }
}), xX = {
  click: (n) => n instanceof MouseEvent
}, SX = "overlay";
var CX = F({
  name: "ElOverlay",
  props: wX,
  emits: xX,
  setup(n, { slots: e, emit: t }) {
    const i = me(SX), r = (l) => {
      t("click", l);
    }, { onClick: s, onMousedown: o, onMouseup: a } = fw(n.customMaskEvent ? void 0 : r);
    return () => n.mask ? K("div", {
      class: [i.b(), n.overlayClass],
      style: {
        zIndex: n.zIndex
      },
      onClick: s,
      onMousedown: o,
      onMouseup: a
    }, [de(e, "default")], ng.STYLE | ng.CLASS | ng.PROPS, ["onClick", "onMouseup", "onMousedown"]) : Re("div", {
      class: n.overlayClass,
      style: {
        zIndex: n.zIndex,
        position: "fixed",
        top: "0px",
        right: "0px",
        bottom: "0px",
        left: "0px"
      }
    }, [de(e, "default")]);
  }
});
const Sw = CX, b_ = Symbol("dialogInjectionKey"), y_ = Ee({
  center: Boolean,
  alignCenter: Boolean,
  closeIcon: {
    type: Pn
  },
  draggable: Boolean,
  overflow: Boolean,
  fullscreen: Boolean,
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
}), kX = {
  close: () => !0
}, PX = ["aria-level"], EX = ["aria-label"], AX = ["id"], $X = F({ name: "ElDialogContent" }), TX = /* @__PURE__ */ F({
  ...$X,
  props: y_,
  emits: kX,
  setup(n) {
    const e = n, { t } = mn(), { Close: i } = iT, { dialogRef: r, headerRef: s, bodyId: o, ns: a, style: l } = ke(b_), { focusTrapRef: c } = ke(FT), u = $(() => [
      a.b(),
      a.is("fullscreen", e.fullscreen),
      a.is("draggable", e.draggable),
      a.is("align-center", e.alignCenter),
      { [a.m("center")]: e.center }
    ]), h = nZ(c, r), d = $(() => e.draggable), f = $(() => e.overflow);
    return lT(r, s, d, f), (p, g) => (R(), V("div", {
      ref: O(h),
      class: L(O(u)),
      style: Qe(O(l)),
      tabindex: "-1"
    }, [
      Z("header", {
        ref_key: "headerRef",
        ref: s,
        class: L([O(a).e("header"), { "show-close": p.showClose }])
      }, [
        de(p.$slots, "header", {}, () => [
          Z("span", {
            role: "heading",
            "aria-level": p.ariaLevel,
            class: L(O(a).e("title"))
          }, xe(p.title), 11, PX)
        ]),
        p.showClose ? (R(), V("button", {
          key: 0,
          "aria-label": O(t)("el.dialog.close"),
          class: L(O(a).e("headerbtn")),
          type: "button",
          onClick: g[0] || (g[0] = (m) => p.$emit("close"))
        }, [
          K(O(Fe), {
            class: L(O(a).e("close"))
          }, {
            default: Y(() => [
              (R(), ie(yt(p.closeIcon || O(i))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, EX)) : G("v-if", !0)
      ], 2),
      Z("div", {
        id: O(o),
        class: L(O(a).e("body"))
      }, [
        de(p.$slots, "default")
      ], 10, AX),
      p.$slots.footer ? (R(), V("footer", {
        key: 0,
        class: L(O(a).e("footer"))
      }, [
        de(p.$slots, "footer")
      ], 2)) : G("v-if", !0)
    ], 6));
  }
});
var _X = /* @__PURE__ */ Ce(TX, [["__file", "dialog-content.vue"]]);
const O_ = Ee({
  ...y_,
  appendToBody: Boolean,
  appendTo: {
    type: ce(String),
    default: "body"
  },
  beforeClose: {
    type: ce(Function)
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  lockScroll: {
    type: Boolean,
    default: !0
  },
  modal: {
    type: Boolean,
    default: !0
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: !1
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), w_ = {
  open: () => !0,
  opened: () => !0,
  close: () => !0,
  closed: () => !0,
  [ot]: (n) => Ei(n),
  openAutoFocus: () => !0,
  closeAutoFocus: () => !0
}, x_ = (n, e) => {
  var t;
  const r = Xe().emit, { nextZIndex: s } = gw();
  let o = "";
  const a = ws(), l = ws(), c = D(!1), u = D(!1), h = D(!1), d = D((t = n.zIndex) != null ? t : s());
  let f, p;
  const g = vv("namespace", nd), m = $(() => {
    const P = {}, A = `--${g.value}-dialog`;
    return n.fullscreen || (n.top && (P[`${A}-margin-top`] = n.top), n.width && (P[`${A}-width`] = ur(n.width))), P;
  }), v = $(() => n.alignCenter ? { display: "flex" } : {});
  function y() {
    r("opened");
  }
  function b() {
    r("closed"), r(ot, !1), n.destroyOnClose && (h.value = !1);
  }
  function w() {
    r("close");
  }
  function x() {
    p == null || p(), f == null || f(), n.openDelay && n.openDelay > 0 ? { stop: f } = Ug(() => E(), n.openDelay) : E();
  }
  function S() {
    f == null || f(), p == null || p(), n.closeDelay && n.closeDelay > 0 ? { stop: p } = Ug(() => M(), n.closeDelay) : M();
  }
  function C() {
    function P(A) {
      A || (u.value = !0, c.value = !1);
    }
    n.beforeClose ? n.beforeClose(P) : S();
  }
  function k() {
    n.closeOnClickModal && C();
  }
  function E() {
    vt && (c.value = !0);
  }
  function M() {
    c.value = !1;
  }
  function _() {
    r("openAutoFocus");
  }
  function T() {
    r("closeAutoFocus");
  }
  function B(P) {
    var A;
    ((A = P.detail) == null ? void 0 : A.focusReason) === "pointer" && P.preventDefault();
  }
  n.lockScroll && gT(c);
  function I() {
    n.closeOnPressEscape && C();
  }
  return ne(() => n.modelValue, (P) => {
    P ? (u.value = !1, x(), h.value = !0, d.value = _$(n.zIndex) ? s() : d.value++, $e(() => {
      r("open"), e.value && (e.value.scrollTop = 0);
    })) : c.value && S();
  }), ne(() => n.fullscreen, (P) => {
    e.value && (P ? (o = e.value.style.transform, e.value.style.transform = "") : e.value.style.transform = o);
  }), qe(() => {
    n.modelValue && (c.value = !0, h.value = !0, x());
  }), {
    afterEnter: y,
    afterLeave: b,
    beforeLeave: w,
    handleClose: C,
    onModalClick: k,
    close: S,
    doClose: M,
    onOpenAutoFocus: _,
    onCloseAutoFocus: T,
    onCloseRequested: I,
    onFocusoutPrevented: B,
    titleId: a,
    bodyId: l,
    closed: u,
    style: m,
    overlayDialogStyle: v,
    rendered: h,
    visible: c,
    zIndex: d
  };
}, MX = ["aria-label", "aria-labelledby", "aria-describedby"], RX = F({
  name: "ElDialog",
  inheritAttrs: !1
}), NX = /* @__PURE__ */ F({
  ...RX,
  props: O_,
  emits: w_,
  setup(n, { expose: e }) {
    const t = n, i = vo();
    ql({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, $(() => !!i.title));
    const r = me("dialog"), s = D(), o = D(), a = D(), {
      visible: l,
      titleId: c,
      bodyId: u,
      style: h,
      overlayDialogStyle: d,
      rendered: f,
      zIndex: p,
      afterEnter: g,
      afterLeave: m,
      beforeLeave: v,
      handleClose: y,
      onModalClick: b,
      onOpenAutoFocus: w,
      onCloseAutoFocus: x,
      onCloseRequested: S,
      onFocusoutPrevented: C
    } = x_(t, s);
    ft(b_, {
      dialogRef: s,
      headerRef: o,
      bodyId: u,
      ns: r,
      rendered: f,
      style: h
    });
    const k = fw(b), E = $(() => t.draggable && !t.fullscreen);
    return e({
      visible: l,
      dialogContentRef: a
    }), (M, _) => (R(), ie(tv, {
      to: M.appendTo,
      disabled: M.appendTo !== "body" ? !1 : !M.appendToBody
    }, [
      K(bo, {
        name: "dialog-fade",
        onAfterEnter: O(g),
        onAfterLeave: O(m),
        onBeforeLeave: O(v),
        persisted: ""
      }, {
        default: Y(() => [
          it(K(O(Sw), {
            "custom-mask-event": "",
            mask: M.modal,
            "overlay-class": M.modalClass,
            "z-index": O(p)
          }, {
            default: Y(() => [
              Z("div", {
                role: "dialog",
                "aria-modal": "true",
                "aria-label": M.title || void 0,
                "aria-labelledby": M.title ? void 0 : O(c),
                "aria-describedby": O(u),
                class: L(`${O(r).namespace.value}-overlay-dialog`),
                style: Qe(O(d)),
                onClick: _[0] || (_[0] = (...T) => O(k).onClick && O(k).onClick(...T)),
                onMousedown: _[1] || (_[1] = (...T) => O(k).onMousedown && O(k).onMousedown(...T)),
                onMouseup: _[2] || (_[2] = (...T) => O(k).onMouseup && O(k).onMouseup(...T))
              }, [
                K(O(yv), {
                  loop: "",
                  trapped: O(l),
                  "focus-start-el": "container",
                  onFocusAfterTrapped: O(w),
                  onFocusAfterReleased: O(x),
                  onFocusoutPrevented: O(C),
                  onReleaseRequested: O(S)
                }, {
                  default: Y(() => [
                    O(f) ? (R(), ie(_X, Pi({
                      key: 0,
                      ref_key: "dialogContentRef",
                      ref: a
                    }, M.$attrs, {
                      center: M.center,
                      "align-center": M.alignCenter,
                      "close-icon": M.closeIcon,
                      draggable: O(E),
                      overflow: M.overflow,
                      fullscreen: M.fullscreen,
                      "show-close": M.showClose,
                      title: M.title,
                      "aria-level": M.headerAriaLevel,
                      onClose: O(y)
                    }), Fg({
                      header: Y(() => [
                        M.$slots.title ? de(M.$slots, "title", { key: 1 }) : de(M.$slots, "header", {
                          key: 0,
                          close: O(y),
                          titleId: O(c),
                          titleClass: O(r).e("title")
                        })
                      ]),
                      default: Y(() => [
                        de(M.$slots, "default")
                      ]),
                      _: 2
                    }, [
                      M.$slots.footer ? {
                        name: "footer",
                        fn: Y(() => [
                          de(M.$slots, "footer")
                        ])
                      } : void 0
                    ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : G("v-if", !0)
                  ]),
                  _: 3
                }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
              ], 46, MX)
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index"]), [
            [Qt, O(l)]
          ])
        ]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["to", "disabled"]));
  }
});
var DX = /* @__PURE__ */ Ce(NX, [["__file", "dialog.vue"]]);
const _Ke = Ft(DX), LX = Ee({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: ce(String),
    default: "solid"
  }
}), IX = F({
  name: "ElDivider"
}), BX = /* @__PURE__ */ F({
  ...IX,
  props: LX,
  setup(n) {
    const e = n, t = me("divider"), i = $(() => t.cssVar({
      "border-style": e.borderStyle
    }));
    return (r, s) => (R(), V("div", {
      class: L([O(t).b(), O(t).m(r.direction)]),
      style: Qe(O(i)),
      role: "separator"
    }, [
      r.$slots.default && r.direction !== "vertical" ? (R(), V("div", {
        key: 0,
        class: L([O(t).e("text"), O(t).is(r.contentPosition)])
      }, [
        de(r.$slots, "default")
      ], 2)) : G("v-if", !0)
    ], 6));
  }
});
var QX = /* @__PURE__ */ Ce(BX, [["__file", "divider.vue"]]);
const MKe = Ft(QX), zX = Ee({
  ...O_,
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: !0
  },
  modalFade: {
    type: Boolean,
    default: !0
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), jX = w_, VX = ["aria-label", "aria-labelledby", "aria-describedby"], FX = ["id", "aria-level"], ZX = ["aria-label"], qX = ["id"], WX = F({
  name: "ElDrawer",
  inheritAttrs: !1
}), HX = /* @__PURE__ */ F({
  ...WX,
  props: zX,
  emits: jX,
  setup(n, { expose: e }) {
    const t = n, i = vo();
    ql({
      scope: "el-drawer",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#slots"
    }, $(() => !!i.title));
    const r = D(), s = D(), o = me("drawer"), { t: a } = mn(), {
      afterEnter: l,
      afterLeave: c,
      beforeLeave: u,
      visible: h,
      rendered: d,
      titleId: f,
      bodyId: p,
      onModalClick: g,
      onOpenAutoFocus: m,
      onCloseAutoFocus: v,
      onFocusoutPrevented: y,
      onCloseRequested: b,
      handleClose: w
    } = x_(t, r), x = $(() => t.direction === "rtl" || t.direction === "ltr"), S = $(() => ur(t.size));
    return e({
      handleClose: w,
      afterEnter: l,
      afterLeave: c
    }), (C, k) => (R(), ie(tv, {
      to: "body",
      disabled: !C.appendToBody
    }, [
      K(bo, {
        name: O(o).b("fade"),
        onAfterEnter: O(l),
        onAfterLeave: O(c),
        onBeforeLeave: O(u),
        persisted: ""
      }, {
        default: Y(() => [
          it(K(O(Sw), {
            mask: C.modal,
            "overlay-class": C.modalClass,
            "z-index": C.zIndex,
            onClick: O(g)
          }, {
            default: Y(() => [
              K(O(yv), {
                loop: "",
                trapped: O(h),
                "focus-trap-el": r.value,
                "focus-start-el": s.value,
                onFocusAfterTrapped: O(m),
                onFocusAfterReleased: O(v),
                onFocusoutPrevented: O(y),
                onReleaseRequested: O(b)
              }, {
                default: Y(() => [
                  Z("div", Pi({
                    ref_key: "drawerRef",
                    ref: r,
                    "aria-modal": "true",
                    "aria-label": C.title || void 0,
                    "aria-labelledby": C.title ? void 0 : O(f),
                    "aria-describedby": O(p)
                  }, C.$attrs, {
                    class: [O(o).b(), C.direction, O(h) && "open"],
                    style: O(x) ? "width: " + O(S) : "height: " + O(S),
                    role: "dialog",
                    onClick: k[1] || (k[1] = Le(() => {
                    }, ["stop"]))
                  }), [
                    Z("span", {
                      ref_key: "focusStartRef",
                      ref: s,
                      class: L(O(o).e("sr-focus")),
                      tabindex: "-1"
                    }, null, 2),
                    C.withHeader ? (R(), V("header", {
                      key: 0,
                      class: L(O(o).e("header"))
                    }, [
                      C.$slots.title ? de(C.$slots, "title", { key: 1 }, () => [
                        G(" DEPRECATED SLOT ")
                      ]) : de(C.$slots, "header", {
                        key: 0,
                        close: O(w),
                        titleId: O(f),
                        titleClass: O(o).e("title")
                      }, () => [
                        C.$slots.title ? G("v-if", !0) : (R(), V("span", {
                          key: 0,
                          id: O(f),
                          role: "heading",
                          "aria-level": C.headerAriaLevel,
                          class: L(O(o).e("title"))
                        }, xe(C.title), 11, FX))
                      ]),
                      C.showClose ? (R(), V("button", {
                        key: 2,
                        "aria-label": O(a)("el.drawer.close"),
                        class: L(O(o).e("close-btn")),
                        type: "button",
                        onClick: k[0] || (k[0] = (...E) => O(w) && O(w)(...E))
                      }, [
                        K(O(Fe), {
                          class: L(O(o).e("close"))
                        }, {
                          default: Y(() => [
                            K(O(jo))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, ZX)) : G("v-if", !0)
                    ], 2)) : G("v-if", !0),
                    O(d) ? (R(), V("div", {
                      key: 1,
                      id: O(p),
                      class: L(O(o).e("body"))
                    }, [
                      de(C.$slots, "default")
                    ], 10, qX)) : G("v-if", !0),
                    C.$slots.footer ? (R(), V("div", {
                      key: 2,
                      class: L(O(o).e("footer"))
                    }, [
                      de(C.$slots, "footer")
                    ], 2)) : G("v-if", !0)
                  ], 16, VX)
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
            [Qt, O(h)]
          ])
        ]),
        _: 3
      }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["disabled"]));
  }
});
var XX = /* @__PURE__ */ Ce(HX, [["__file", "drawer.vue"]]);
const RKe = Ft(XX), YX = /* @__PURE__ */ F({
  inheritAttrs: !1
});
function UX(n, e, t, i, r, s) {
  return de(n.$slots, "default");
}
var GX = /* @__PURE__ */ Ce(YX, [["render", UX], ["__file", "collection.vue"]]);
const KX = /* @__PURE__ */ F({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function JX(n, e, t, i, r, s) {
  return de(n.$slots, "default");
}
var eY = /* @__PURE__ */ Ce(KX, [["render", JX], ["__file", "collection-item.vue"]]);
const tY = "data-el-collection-item", nY = (n) => {
  const e = `El${n}Collection`, t = `${e}Item`, i = Symbol(e), r = Symbol(t), s = {
    ...GX,
    name: e,
    setup() {
      const a = D(null), l = /* @__PURE__ */ new Map();
      ft(i, {
        itemMap: l,
        getItems: () => {
          const u = O(a);
          if (!u)
            return [];
          const h = Array.from(u.querySelectorAll(`[${tY}]`));
          return [...l.values()].sort((f, p) => h.indexOf(f.ref) - h.indexOf(p.ref));
        },
        collectionRef: a
      });
    }
  }, o = {
    ...eY,
    name: t,
    setup(a, { attrs: l }) {
      const c = D(null), u = ke(i, void 0);
      ft(r, {
        collectionItemRef: c
      }), qe(() => {
        const h = O(c);
        h && u.itemMap.set(h, {
          ref: h,
          ...l
        });
      }), Kn(() => {
        const h = O(c);
        u.itemMap.delete(h);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: i,
    COLLECTION_ITEM_INJECTION_KEY: r,
    ElCollection: s,
    ElCollectionItem: o
  };
}, _0 = Ee({
  trigger: Ld.trigger,
  effect: {
    ...mi.effect,
    default: "light"
  },
  type: {
    type: ce(String)
  },
  placement: {
    type: ce(String),
    default: "bottom"
  },
  popperOptions: {
    type: ce(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: ce([Number, String]),
    default: 0
  },
  maxHeight: {
    type: ce([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: ce(Object)
  },
  teleported: mi.teleported
});
Ee({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: Pn
  }
});
Ee({
  onKeydown: { type: ce(Function) }
});
nY("Dropdown");
const iY = Ee({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: _r,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (n) => n === null || tt(n) || ["min", "max"].includes(n),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (n) => n >= 0 && n === Number.parseInt(`${n}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), rY = {
  [Gn]: (n, e) => e !== n,
  blur: (n) => n instanceof FocusEvent,
  focus: (n) => n instanceof FocusEvent,
  [Ll]: (n) => tt(n) || Ni(n),
  [ot]: (n) => tt(n) || Ni(n)
}, sY = ["aria-label", "onKeydown"], oY = ["aria-label", "onKeydown"], aY = F({
  name: "ElInputNumber"
}), lY = /* @__PURE__ */ F({
  ...aY,
  props: iY,
  emits: rY,
  setup(n, { expose: e, emit: t }) {
    const i = n, { t: r } = mn(), s = me("input-number"), o = D(), a = Gt({
      currentValue: i.modelValue,
      userInput: null
    }), { formItem: l } = Mr(), c = $(() => tt(i.modelValue) && i.modelValue <= i.min), u = $(() => tt(i.modelValue) && i.modelValue >= i.max), h = $(() => {
      const P = v(i.step);
      return Ci(i.precision) ? Math.max(v(i.modelValue), P) : (P > i.precision && pt("InputNumber", "precision should not be less than the decimal places of step"), i.precision);
    }), d = $(() => i.controls && i.controlsPosition === "right"), f = Yi(), p = ts(), g = $(() => {
      if (a.userInput !== null)
        return a.userInput;
      let P = a.currentValue;
      if (Ni(P))
        return "";
      if (tt(P)) {
        if (Number.isNaN(P))
          return "";
        Ci(i.precision) || (P = P.toFixed(i.precision));
      }
      return P;
    }), m = (P, A) => {
      if (Ci(A) && (A = h.value), A === 0)
        return Math.round(P);
      let N = String(P);
      const q = N.indexOf(".");
      if (q === -1 || !N.replace(".", "").split("")[q + A])
        return P;
      const oe = N.length;
      return N.charAt(oe - 1) === "5" && (N = `${N.slice(0, Math.max(0, oe - 1))}6`), Number.parseFloat(Number(N).toFixed(A));
    }, v = (P) => {
      if (Ni(P))
        return 0;
      const A = P.toString(), N = A.indexOf(".");
      let q = 0;
      return N !== -1 && (q = A.length - N - 1), q;
    }, y = (P, A = 1) => tt(P) ? m(P + i.step * A) : a.currentValue, b = () => {
      if (i.readonly || p.value || u.value)
        return;
      const P = Number(g.value) || 0, A = y(P);
      S(A), t(Ll, a.currentValue), B();
    }, w = () => {
      if (i.readonly || p.value || c.value)
        return;
      const P = Number(g.value) || 0, A = y(P, -1);
      S(A), t(Ll, a.currentValue), B();
    }, x = (P, A) => {
      const { max: N, min: q, step: j, precision: H, stepStrictly: oe, valueOnClear: te } = i;
      N < q && dr("InputNumber", "min should not be greater than max.");
      let W = Number(P);
      if (Ni(P) || Number.isNaN(W))
        return null;
      if (P === "") {
        if (te === null)
          return null;
        W = bt(te) ? { min: q, max: N }[te] : te;
      }
      return oe && (W = m(Math.round(W / j) * j, H)), Ci(H) || (W = m(W, H)), (W > N || W < q) && (W = W > N ? N : q, A && t(ot, W)), W;
    }, S = (P, A = !0) => {
      var N;
      const q = a.currentValue, j = x(P);
      if (!A) {
        t(ot, j);
        return;
      }
      q !== j && (a.userInput = null, t(ot, j), t(Gn, j, q), i.validateEvent && ((N = l == null ? void 0 : l.validate) == null || N.call(l, "change").catch((H) => pt(H))), a.currentValue = j);
    }, C = (P) => {
      a.userInput = P;
      const A = P === "" ? null : Number(P);
      t(Ll, A), S(A, !1);
    }, k = (P) => {
      const A = P !== "" ? Number(P) : "";
      (tt(A) && !Number.isNaN(A) || P === "") && S(A), B(), a.userInput = null;
    }, E = () => {
      var P, A;
      (A = (P = o.value) == null ? void 0 : P.focus) == null || A.call(P);
    }, M = () => {
      var P, A;
      (A = (P = o.value) == null ? void 0 : P.blur) == null || A.call(P);
    }, _ = (P) => {
      t("focus", P);
    }, T = (P) => {
      var A;
      a.userInput = null, t("blur", P), i.validateEvent && ((A = l == null ? void 0 : l.validate) == null || A.call(l, "blur").catch((N) => pt(N)));
    }, B = () => {
      a.currentValue !== i.modelValue && (a.currentValue = i.modelValue);
    }, I = (P) => {
      document.activeElement === P.target && P.preventDefault();
    };
    return ne(() => i.modelValue, (P, A) => {
      const N = x(P, !0);
      a.userInput === null && N !== A && (a.currentValue = N);
    }, { immediate: !0 }), qe(() => {
      var P;
      const { min: A, max: N, modelValue: q } = i, j = (P = o.value) == null ? void 0 : P.input;
      if (j.setAttribute("role", "spinbutton"), Number.isFinite(N) ? j.setAttribute("aria-valuemax", String(N)) : j.removeAttribute("aria-valuemax"), Number.isFinite(A) ? j.setAttribute("aria-valuemin", String(A)) : j.removeAttribute("aria-valuemin"), j.setAttribute("aria-valuenow", a.currentValue || a.currentValue === 0 ? String(a.currentValue) : ""), j.setAttribute("aria-disabled", String(p.value)), !tt(q) && q != null) {
        let H = Number(q);
        Number.isNaN(H) && (H = null), t(ot, H);
      }
    }), Ya(() => {
      var P, A;
      const N = (P = o.value) == null ? void 0 : P.input;
      N == null || N.setAttribute("aria-valuenow", `${(A = a.currentValue) != null ? A : ""}`);
    }), e({
      focus: E,
      blur: M
    }), (P, A) => (R(), V("div", {
      class: L([
        O(s).b(),
        O(s).m(O(f)),
        O(s).is("disabled", O(p)),
        O(s).is("without-controls", !P.controls),
        O(s).is("controls-right", O(d))
      ]),
      onDragstart: A[0] || (A[0] = Le(() => {
      }, ["prevent"]))
    }, [
      P.controls ? it((R(), V("span", {
        key: 0,
        role: "button",
        "aria-label": O(r)("el.inputNumber.decrease"),
        class: L([O(s).e("decrease"), O(s).is("disabled", O(c))]),
        onKeydown: Ut(w, ["enter"])
      }, [
        K(O(Fe), null, {
          default: Y(() => [
            O(d) ? (R(), ie(O(oh), { key: 0 })) : (R(), ie(O(Gj), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, sY)), [
        [O(qC), w]
      ]) : G("v-if", !0),
      P.controls ? it((R(), V("span", {
        key: 1,
        role: "button",
        "aria-label": O(r)("el.inputNumber.increase"),
        class: L([O(s).e("increase"), O(s).is("disabled", O(u))]),
        onKeydown: Ut(b, ["enter"])
      }, [
        K(O(Fe), null, {
          default: Y(() => [
            O(d) ? (R(), ie(O(B$), { key: 0 })) : (R(), ie(O(j$), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, oY)), [
        [O(qC), b]
      ]) : G("v-if", !0),
      K(O(uc), {
        id: P.id,
        ref_key: "input",
        ref: o,
        type: "number",
        step: P.step,
        "model-value": O(g),
        placeholder: P.placeholder,
        readonly: P.readonly,
        disabled: O(p),
        size: O(f),
        max: P.max,
        min: P.min,
        name: P.name,
        label: P.label,
        "validate-event": !1,
        onWheel: I,
        onKeydown: [
          Ut(Le(b, ["prevent"]), ["up"]),
          Ut(Le(w, ["prevent"]), ["down"])
        ],
        onBlur: T,
        onFocus: _,
        onInput: C,
        onChange: k
      }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
    ], 34));
  }
});
var cY = /* @__PURE__ */ Ce(lY, [["__file", "input-number.vue"]]);
const NKe = Ft(cY), S_ = Symbol("elPaginationKey"), uY = Ee({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: Pn
  }
}), hY = {
  click: (n) => n instanceof MouseEvent
}, dY = ["disabled", "aria-label", "aria-disabled"], fY = { key: 0 }, pY = F({
  name: "ElPaginationPrev"
}), gY = /* @__PURE__ */ F({
  ...pY,
  props: uY,
  emits: hY,
  setup(n) {
    const e = n, { t } = mn(), i = $(() => e.disabled || e.currentPage <= 1);
    return (r, s) => (R(), V("button", {
      type: "button",
      class: "btn-prev",
      disabled: O(i),
      "aria-label": r.prevText || O(t)("el.pagination.prev"),
      "aria-disabled": O(i),
      onClick: s[0] || (s[0] = (o) => r.$emit("click", o))
    }, [
      r.prevText ? (R(), V("span", fY, xe(r.prevText), 1)) : (R(), ie(O(Fe), { key: 1 }, {
        default: Y(() => [
          (R(), ie(yt(r.prevIcon)))
        ]),
        _: 1
      }))
    ], 8, dY));
  }
});
var mY = /* @__PURE__ */ Ce(gY, [["__file", "prev.vue"]]);
const vY = Ee({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: Pn
  }
}), bY = ["disabled", "aria-label", "aria-disabled"], yY = { key: 0 }, OY = F({
  name: "ElPaginationNext"
}), wY = /* @__PURE__ */ F({
  ...OY,
  props: vY,
  emits: ["click"],
  setup(n) {
    const e = n, { t } = mn(), i = $(() => e.disabled || e.currentPage === e.pageCount || e.pageCount === 0);
    return (r, s) => (R(), V("button", {
      type: "button",
      class: "btn-next",
      disabled: O(i),
      "aria-label": r.nextText || O(t)("el.pagination.next"),
      "aria-disabled": O(i),
      onClick: s[0] || (s[0] = (o) => r.$emit("click", o))
    }, [
      r.nextText ? (R(), V("span", yY, xe(r.nextText), 1)) : (R(), ie(O(Fe), { key: 1 }, {
        default: Y(() => [
          (R(), ie(yt(r.nextIcon)))
        ]),
        _: 1
      }))
    ], 8, bY));
  }
});
var xY = /* @__PURE__ */ Ce(wY, [["__file", "next.vue"]]);
const C_ = Symbol("ElSelectGroup"), wv = Symbol("ElSelect");
function SY(n, e) {
  const t = ke(wv), i = ke(C_, { disabled: !1 }), r = $(() => t.props.multiple ? u(t.props.modelValue, n.value) : u([t.props.modelValue], n.value)), s = $(() => {
    if (t.props.multiple) {
      const f = t.props.modelValue || [];
      return !r.value && f.length >= t.props.multipleLimit && t.props.multipleLimit > 0;
    } else
      return !1;
  }), o = $(() => n.label || (an(n.value) ? "" : n.value)), a = $(() => n.value || n.label || ""), l = $(() => n.disabled || e.groupDisabled || s.value), c = Xe(), u = (f = [], p) => {
    if (an(n.value)) {
      const g = t.props.valueKey;
      return f && f.some((m) => Ed(on(m, g)) === on(p, g));
    } else
      return f && f.includes(p);
  }, h = () => {
    !n.disabled && !i.disabled && (t.states.hoveringIndex = t.optionsArray.indexOf(c.proxy));
  }, d = (f) => {
    const p = new RegExp(K$(f), "i");
    e.visible = p.test(o.value) || n.created;
  };
  return ne(() => o.value, () => {
    !n.created && !t.props.remote && t.setSelected();
  }), ne(() => n.value, (f, p) => {
    const { remote: g, valueKey: m } = t.props;
    if (cn(f, p) || (t.onOptionDestroy(p, c.proxy), t.onOptionCreate(c.proxy)), !n.created && !g) {
      if (m && an(f) && an(p) && f[m] === p[m])
        return;
      t.setSelected();
    }
  }), ne(() => i.disabled, () => {
    e.groupDisabled = i.disabled;
  }, { immediate: !0 }), {
    select: t,
    currentLabel: o,
    currentValue: a,
    itemSelected: r,
    isDisabled: l,
    hoverItem: h,
    updateOption: d
  };
}
const CY = F({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(n) {
    const e = me("select"), t = ws(), i = $(() => [
      e.be("dropdown", "item"),
      e.is("disabled", O(a)),
      e.is("selected", O(o)),
      e.is("hovering", O(d))
    ]), r = Gt({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hover: !1
    }), {
      currentLabel: s,
      itemSelected: o,
      isDisabled: a,
      select: l,
      hoverItem: c,
      updateOption: u
    } = SY(n, r), { visible: h, hover: d } = Hr(r), f = Xe().proxy;
    l.onOptionCreate(f), Kn(() => {
      const g = f.value, { selected: m } = l.states, y = (l.props.multiple ? m : [m]).some((b) => b.value === f.value);
      $e(() => {
        l.states.cachedOptions.get(g) === f && !y && l.states.cachedOptions.delete(g);
      }), l.onOptionDestroy(g, f);
    });
    function p() {
      n.disabled !== !0 && r.groupDisabled !== !0 && l.handleOptionSelect(f);
    }
    return {
      ns: e,
      id: t,
      containerKls: i,
      currentLabel: s,
      itemSelected: o,
      isDisabled: a,
      select: l,
      hoverItem: c,
      updateOption: u,
      visible: h,
      hover: d,
      selectOptionClick: p,
      states: r
    };
  }
}), kY = ["id", "aria-disabled", "aria-selected"];
function PY(n, e, t, i, r, s) {
  return it((R(), V("li", {
    id: n.id,
    class: L(n.containerKls),
    role: "option",
    "aria-disabled": n.isDisabled || void 0,
    "aria-selected": n.itemSelected,
    onMouseenter: e[0] || (e[0] = (...o) => n.hoverItem && n.hoverItem(...o)),
    onClick: e[1] || (e[1] = Le((...o) => n.selectOptionClick && n.selectOptionClick(...o), ["stop"]))
  }, [
    de(n.$slots, "default", {}, () => [
      Z("span", null, xe(n.currentLabel), 1)
    ])
  ], 42, kY)), [
    [Qt, n.visible]
  ]);
}
var Cw = /* @__PURE__ */ Ce(CY, [["render", PY], ["__file", "option.vue"]]);
const EY = F({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const n = ke(wv), e = me("select"), t = $(() => n.props.popperClass), i = $(() => n.props.multiple), r = $(() => n.props.fitInputWidth), s = D("");
    function o() {
      var a;
      s.value = `${(a = n.selectRef) == null ? void 0 : a.offsetWidth}px`;
    }
    return qe(() => {
      o(), pn(n.selectRef, o);
    }), {
      ns: e,
      minWidth: s,
      popperClass: t,
      isMultiple: i,
      isFitInputWidth: r
    };
  }
});
function AY(n, e, t, i, r, s) {
  return R(), V("div", {
    class: L([n.ns.b("dropdown"), n.ns.is("multiple", n.isMultiple), n.popperClass]),
    style: Qe({ [n.isFitInputWidth ? "width" : "minWidth"]: n.minWidth })
  }, [
    n.$slots.header ? (R(), V("div", {
      key: 0,
      class: L(n.ns.be("dropdown", "header"))
    }, [
      de(n.$slots, "header")
    ], 2)) : G("v-if", !0),
    de(n.$slots, "default"),
    n.$slots.footer ? (R(), V("div", {
      key: 1,
      class: L(n.ns.be("dropdown", "footer"))
    }, [
      de(n.$slots, "footer")
    ], 2)) : G("v-if", !0)
  ], 6);
}
var $Y = /* @__PURE__ */ Ce(EY, [["render", AY], ["__file", "select-dropdown.vue"]]);
function k_(n) {
  const e = D(!1);
  return {
    handleCompositionStart: () => {
      e.value = !0;
    },
    handleCompositionUpdate: (s) => {
      const o = s.target.value, a = o[o.length - 1] || "";
      e.value = !nw(a);
    },
    handleCompositionEnd: (s) => {
      e.value && (e.value = !1, wt(n) && n(s));
    }
  };
}
const TY = 11, _Y = (n, e) => {
  const { t } = mn(), i = ws(), r = me("select"), s = me("input"), o = Gt({
    inputValue: "",
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    optionValues: [],
    selected: n.multiple ? [] : {},
    selectionWidth: 0,
    calculatorWidth: 0,
    collapseItemWidth: 0,
    selectedLabel: "",
    hoveringIndex: -1,
    previousQuery: null,
    inputHovering: !1,
    menuVisibleOnFocus: !1,
    isBeforeHide: !1
  });
  ql({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, $(() => n.suffixTransition === !1));
  const a = D(null), l = D(null), c = D(null), u = D(null), h = D(null), d = D(null), f = D(null), p = D(null), g = D(null), m = D(null), v = D(null), y = D(null), { wrapperRef: b, isFocused: w, handleFocus: x, handleBlur: S } = mv(h, {
    afterFocus() {
      n.automaticDropdown && !C.value && (C.value = !0, o.menuVisibleOnFocus = !0);
    },
    beforeBlur(re) {
      var we, _t;
      return ((we = c.value) == null ? void 0 : we.isFocusInsideContent(re)) || ((_t = u.value) == null ? void 0 : _t.isFocusInsideContent(re));
    },
    afterBlur() {
      C.value = !1, o.menuVisibleOnFocus = !1;
    }
  }), C = D(!1), k = D(), { form: E, formItem: M } = Mr(), { inputId: _ } = Ka(n, {
    formItemContext: M
  }), T = $(() => n.disabled || (E == null ? void 0 : E.disabled)), B = $(() => n.multiple ? xt(n.modelValue) && n.modelValue.length > 0 : n.modelValue !== void 0 && n.modelValue !== null && n.modelValue !== ""), I = $(() => n.clearable && !T.value && o.inputHovering && B.value), P = $(() => n.remote && n.filterable && !n.remoteShowSuffix ? "" : n.suffixIcon), A = $(() => r.is("reverse", P.value && C.value && n.suffixTransition)), N = $(() => (M == null ? void 0 : M.validateState) || ""), q = $(() => tw[N.value]), j = $(() => n.remote ? 300 : 0), H = $(() => n.loading ? n.loadingText || t("el.select.loading") : n.remote && !o.inputValue && o.options.size === 0 ? !1 : n.filterable && o.inputValue && o.options.size > 0 && oe.value === 0 ? n.noMatchText || t("el.select.noMatch") : o.options.size === 0 ? n.noDataText || t("el.select.noData") : null), oe = $(() => te.value.filter((re) => re.visible).length), te = $(() => {
    const re = Array.from(o.options.values()), we = [];
    return o.optionValues.forEach((_t) => {
      const hn = re.findIndex((is) => is.value === _t);
      hn > -1 && we.push(re[hn]);
    }), we.length >= re.length ? we : re;
  }), W = $(() => Array.from(o.cachedOptions.values())), U = $(() => {
    const re = te.value.filter((we) => !we.created).some((we) => we.currentLabel === o.inputValue);
    return n.filterable && n.allowCreate && o.inputValue !== "" && !re;
  }), ae = () => {
    n.filterable && wt(n.filterMethod) || n.filterable && n.remote && wt(n.remoteMethod) || te.value.forEach((re) => {
      re.updateOption(o.inputValue);
    });
  }, he = Yi(), ee = $(() => ["small"].includes(he.value) ? "small" : "default"), pe = $({
    get() {
      return C.value && H.value !== !1;
    },
    set(re) {
      C.value = re;
    }
  }), be = $(() => xt(n.modelValue) ? n.modelValue.length === 0 && !o.inputValue : n.filterable ? !o.inputValue : !0), fe = $(() => {
    var re;
    const we = (re = n.placeholder) != null ? re : t("el.select.placeholder");
    return n.multiple || !B.value ? we : o.selectedLabel;
  });
  ne(() => n.modelValue, (re, we) => {
    n.multiple && n.filterable && !n.reserveKeyword && (o.inputValue = "", Ae("")), zt(), !cn(re, we) && n.validateEvent && (M == null || M.validate("change").catch((_t) => pt(_t)));
  }, {
    flush: "post",
    deep: !0
  }), ne(() => C.value, (re) => {
    re ? Ae(o.inputValue) : (o.inputValue = "", o.previousQuery = null, o.isBeforeHide = !0), e("visible-change", re);
  }), ne(() => o.options.entries(), () => {
    var re;
    if (!vt)
      return;
    const we = ((re = a.value) == null ? void 0 : re.querySelectorAll("input")) || [];
    (!n.filterable && !n.defaultFirstOption && !Ci(n.modelValue) || !Array.from(we).includes(document.activeElement)) && zt(), n.defaultFirstOption && (n.filterable || n.remote) && oe.value && ut();
  }, {
    flush: "post"
  }), ne(() => o.hoveringIndex, (re) => {
    tt(re) && re > -1 ? k.value = te.value[re] || {} : k.value = {}, te.value.forEach((we) => {
      we.hover = k.value === we;
    });
  }), Fr(() => {
    o.isBeforeHide || ae();
  });
  const Ae = (re) => {
    o.previousQuery !== re && (o.previousQuery = re, n.filterable && wt(n.filterMethod) ? n.filterMethod(re) : n.filterable && n.remote && wt(n.remoteMethod) && n.remoteMethod(re), n.defaultFirstOption && (n.filterable || n.remote) && oe.value ? $e(ut) : $e(ei));
  }, ut = () => {
    const re = te.value.filter((hn) => hn.visible && !hn.disabled && !hn.states.groupDisabled), we = re.find((hn) => hn.created), _t = re[0];
    o.hoveringIndex = Te(te.value, we || _t);
  }, zt = () => {
    if (n.multiple)
      o.selectedLabel = "";
    else {
      const we = Jn(n.modelValue);
      o.selectedLabel = we.currentLabel, o.selected = we;
      return;
    }
    const re = [];
    xt(n.modelValue) && n.modelValue.forEach((we) => {
      re.push(Jn(we));
    }), o.selected = re;
  }, Jn = (re) => {
    let we;
    const _t = w0(re).toLowerCase() === "object", hn = w0(re).toLowerCase() === "null", is = w0(re).toLowerCase() === "undefined";
    for (let rs = o.cachedOptions.size - 1; rs >= 0; rs--) {
      const Nr = W.value[rs];
      if (_t ? on(Nr.value, n.valueKey) === on(re, n.valueKey) : Nr.value === re) {
        we = {
          value: re,
          currentLabel: Nr.currentLabel,
          isDisabled: Nr.isDisabled
        };
        break;
      }
    }
    if (we)
      return we;
    const oa = _t ? re.label : !hn && !is ? re : "";
    return {
      value: re,
      currentLabel: oa
    };
  }, ei = () => {
    n.multiple ? o.selected.length > 0 ? o.hoveringIndex = Math.min(...o.selected.map((re) => te.value.findIndex((we) => sa(we) === sa(re)))) : o.hoveringIndex = -1 : o.hoveringIndex = te.value.findIndex((re) => sa(re) === sa(o.selected));
  }, Li = () => {
    o.selectionWidth = l.value.getBoundingClientRect().width;
  }, di = () => {
    o.calculatorWidth = d.value.getBoundingClientRect().width;
  }, Ii = () => {
    o.collapseItemWidth = v.value.getBoundingClientRect().width;
  }, fr = () => {
    var re, we;
    (we = (re = c.value) == null ? void 0 : re.updatePopper) == null || we.call(re);
  }, un = () => {
    var re, we;
    (we = (re = u.value) == null ? void 0 : re.updatePopper) == null || we.call(re);
  }, Bi = () => {
    o.inputValue.length > 0 && !C.value && (C.value = !0), Ae(o.inputValue);
  }, Ui = (re) => {
    if (o.inputValue = re.target.value, n.remote)
      Qi();
    else
      return Bi();
  }, Qi = zo(() => {
    Bi();
  }, j.value), ti = (re) => {
    cn(n.modelValue, re) || e(Gn, re);
  }, ge = (re) => A$(re, (we) => !o.disabledOptions.has(we)), Ke = (re) => {
    if (n.multiple && re.code !== dt.delete && re.target.value.length <= 0) {
      const we = n.modelValue.slice(), _t = ge(we);
      if (_t < 0)
        return;
      we.splice(_t, 1), e(ot, we), ti(we);
    }
  }, Dt = (re, we) => {
    const _t = o.selected.indexOf(we);
    if (_t > -1 && !T.value) {
      const hn = n.modelValue.slice();
      hn.splice(_t, 1), e(ot, hn), ti(hn), e("remove-tag", we.value);
    }
    re.stopPropagation(), Ds();
  }, ni = (re) => {
    re.stopPropagation();
    const we = n.multiple ? [] : "";
    if (!bt(we))
      for (const _t of o.selected)
        _t.isDisabled && we.push(_t.value);
    e(ot, we), ti(we), o.hoveringIndex = -1, C.value = !1, e("clear"), Ds();
  }, Ns = (re) => {
    if (n.multiple) {
      const we = (n.modelValue || []).slice(), _t = Te(we, re.value);
      _t > -1 ? we.splice(_t, 1) : (n.multipleLimit <= 0 || we.length < n.multipleLimit) && we.push(re.value), e(ot, we), ti(we), re.created && Ae(""), n.filterable && !n.reserveKeyword && (o.inputValue = "");
    } else
      e(ot, re.value), ti(re.value), C.value = !1;
    Ds(), !C.value && $e(() => {
      je(re);
    });
  }, Te = (re = [], we) => {
    if (!an(we))
      return re.indexOf(we);
    const _t = n.valueKey;
    let hn = -1;
    return re.some((is, oa) => Ed(on(is, _t)) === on(we, _t) ? (hn = oa, !0) : !1), hn;
  }, je = (re) => {
    var we, _t, hn, is, oa;
    const bc = xt(re) ? re[0] : re;
    let rs = null;
    if (bc != null && bc.value) {
      const Nr = te.value.filter((yc) => yc.value === bc.value);
      Nr.length > 0 && (rs = Nr[0].$el);
    }
    if (c.value && rs) {
      const Nr = (is = (hn = (_t = (we = c.value) == null ? void 0 : we.popperRef) == null ? void 0 : _t.contentRef) == null ? void 0 : hn.querySelector) == null ? void 0 : is.call(hn, `.${r.be("dropdown", "wrap")}`);
      Nr && tT(Nr, rs);
    }
    (oa = y.value) == null || oa.handleScroll();
  }, J = (re) => {
    o.options.set(re.value, re), o.cachedOptions.set(re.value, re), re.disabled && o.disabledOptions.set(re.value, re);
  }, le = (re, we) => {
    o.options.get(re) === we && o.options.delete(re);
  }, {
    handleCompositionStart: ve,
    handleCompositionUpdate: Ue,
    handleCompositionEnd: Zt
  } = k_((re) => Ui(re)), Cn = $(() => {
    var re, we;
    return (we = (re = c.value) == null ? void 0 : re.popperRef) == null ? void 0 : we.contentRef;
  }), jt = () => {
    $e(() => je(o.selected));
  }, Ds = () => {
    var re;
    (re = h.value) == null || re.focus();
  }, Rr = () => {
    Co();
  }, gc = (re) => {
    ni(re);
  }, Co = (re) => {
    if (C.value = !1, w.value) {
      const we = new FocusEvent("focus", re);
      $e(() => S(we));
    }
  }, mc = () => {
    o.inputValue.length > 0 ? o.inputValue = "" : C.value = !1;
  }, Gf = () => {
    T.value || (o.menuVisibleOnFocus ? o.menuVisibleOnFocus = !1 : C.value = !C.value);
  }, Ph = () => {
    C.value ? te.value[o.hoveringIndex] && Ns(te.value[o.hoveringIndex]) : Gf();
  }, sa = (re) => an(re.value) ? on(re.value, n.valueKey) : re.value, Kf = $(() => te.value.filter((re) => re.visible).every((re) => re.disabled)), u0 = $(() => n.multiple ? n.collapseTags ? o.selected.slice(0, n.maxCollapseTags) : o.selected : []), vc = $(() => n.multiple ? n.collapseTags ? o.selected.slice(n.maxCollapseTags) : [] : []), Jf = (re) => {
    if (!C.value) {
      C.value = !0;
      return;
    }
    if (!(o.options.size === 0 || oe.value === 0) && !Kf.value) {
      re === "next" ? (o.hoveringIndex++, o.hoveringIndex === o.options.size && (o.hoveringIndex = 0)) : re === "prev" && (o.hoveringIndex--, o.hoveringIndex < 0 && (o.hoveringIndex = o.options.size - 1));
      const we = te.value[o.hoveringIndex];
      (we.disabled === !0 || we.states.groupDisabled === !0 || !we.visible) && Jf(re), $e(() => je(k.value));
    }
  }, h0 = () => {
    if (!l.value)
      return 0;
    const re = window.getComputedStyle(l.value);
    return Number.parseFloat(re.gap || "6px");
  }, d0 = $(() => {
    const re = h0();
    return { maxWidth: `${v.value && n.maxCollapseTags === 1 ? o.selectionWidth - o.collapseItemWidth - re : o.selectionWidth}px` };
  }), f0 = $(() => ({ maxWidth: `${o.selectionWidth}px` })), p0 = $(() => ({
    width: `${Math.max(o.calculatorWidth, TY)}px`
  }));
  return n.multiple && !xt(n.modelValue) && e(ot, []), !n.multiple && xt(n.modelValue) && e(ot, ""), pn(l, Li), pn(d, di), pn(g, fr), pn(b, fr), pn(m, un), pn(v, Ii), qe(() => {
    zt();
  }), {
    inputId: _,
    contentId: i,
    nsSelect: r,
    nsInput: s,
    states: o,
    isFocused: w,
    expanded: C,
    optionsArray: te,
    hoverOption: k,
    selectSize: he,
    filteredOptionsCount: oe,
    resetCalculatorWidth: di,
    updateTooltip: fr,
    updateTagTooltip: un,
    debouncedOnInputChange: Qi,
    onInput: Ui,
    deletePrevTag: Ke,
    deleteTag: Dt,
    deleteSelected: ni,
    handleOptionSelect: Ns,
    scrollToOption: je,
    hasModelValue: B,
    shouldShowPlaceholder: be,
    currentPlaceholder: fe,
    showClose: I,
    iconComponent: P,
    iconReverse: A,
    validateState: N,
    validateIcon: q,
    showNewOption: U,
    updateOptions: ae,
    collapseTagSize: ee,
    setSelected: zt,
    selectDisabled: T,
    emptyText: H,
    handleCompositionStart: ve,
    handleCompositionUpdate: Ue,
    handleCompositionEnd: Zt,
    onOptionCreate: J,
    onOptionDestroy: le,
    handleMenuEnter: jt,
    handleFocus: x,
    focus: Ds,
    blur: Rr,
    handleBlur: S,
    handleClearClick: gc,
    handleClickOutside: Co,
    handleEsc: mc,
    toggleMenu: Gf,
    selectOption: Ph,
    getValueKey: sa,
    navigateOptions: Jf,
    dropdownMenuVisible: pe,
    showTagList: u0,
    collapseTagList: vc,
    tagStyle: d0,
    collapseTagStyle: f0,
    inputStyle: p0,
    popperRef: Cn,
    inputRef: h,
    tooltipRef: c,
    tagTooltipRef: u,
    calculatorRef: d,
    prefixRef: f,
    suffixRef: p,
    selectRef: a,
    wrapperRef: b,
    selectionRef: l,
    scrollbarRef: y,
    menuRef: g,
    tagMenuRef: m,
    collapseItemRef: v
  };
};
var MY = F({
  name: "ElOptions",
  setup(n, { slots: e }) {
    const t = ke(wv);
    let i = [];
    return () => {
      var r, s;
      const o = (r = e.default) == null ? void 0 : r.call(e), a = [];
      function l(c) {
        xt(c) && c.forEach((u) => {
          var h, d, f, p;
          const g = (h = (u == null ? void 0 : u.type) || {}) == null ? void 0 : h.name;
          g === "ElOptionGroup" ? l(!bt(u.children) && !xt(u.children) && wt((d = u.children) == null ? void 0 : d.default) ? (f = u.children) == null ? void 0 : f.default() : u.children) : g === "ElOption" ? a.push((p = u.props) == null ? void 0 : p.value) : xt(u.children) && l(u.children);
        });
      }
      return o.length && l((s = o[0]) == null ? void 0 : s.children), cn(a, i) || (i = a, t && (t.states.optionValues = a)), o;
    };
  }
});
const RY = Ee({
  name: String,
  id: String,
  modelValue: {
    type: [Array, String, Number, Boolean, Object],
    default: void 0
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  automaticDropdown: Boolean,
  size: _r,
  effect: {
    type: ce(String),
    default: "light"
  },
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  allowCreate: Boolean,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: ce(Object),
    default: () => ({})
  },
  remote: Boolean,
  loadingText: String,
  noMatchText: String,
  noDataText: String,
  remoteMethod: Function,
  filterMethod: Function,
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  placeholder: {
    type: String
  },
  defaultFirstOption: Boolean,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  valueKey: {
    type: String,
    default: "value"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  teleported: mi.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: Pn,
    default: ah
  },
  fitInputWidth: Boolean,
  suffixIcon: {
    type: Pn,
    default: oh
  },
  tagType: { ...Ov.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  remoteShowSuffix: Boolean,
  suffixTransition: {
    type: Boolean,
    default: !0
  },
  placement: {
    type: ce(String),
    values: $f,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ce(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  ariaLabel: {
    type: String,
    default: void 0
  }
}), rk = "ElSelect", NY = F({
  name: rk,
  componentName: rk,
  components: {
    ElInput: uc,
    ElSelectMenu: $Y,
    ElOption: Cw,
    ElOptions: MY,
    ElTag: Jg,
    ElScrollbar: _f,
    ElTooltip: Fo,
    ElIcon: Fe
  },
  directives: { ClickOutside: Rf },
  props: RY,
  emits: [
    ot,
    Gn,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(n, { emit: e }) {
    const t = _Y(n, e);
    return ft(wv, Gt({
      props: n,
      states: t.states,
      optionsArray: t.optionsArray,
      handleOptionSelect: t.handleOptionSelect,
      onOptionCreate: t.onOptionCreate,
      onOptionDestroy: t.onOptionDestroy,
      selectRef: t.selectRef,
      setSelected: t.setSelected
    })), {
      ...t
    };
  }
}), DY = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], LY = ["textContent"];
function IY(n, e, t, i, r, s) {
  const o = nt("el-tag"), a = nt("el-tooltip"), l = nt("el-icon"), c = nt("el-option"), u = nt("el-options"), h = nt("el-scrollbar"), d = nt("el-select-menu"), f = nv("click-outside");
  return it((R(), V("div", {
    ref: "selectRef",
    class: L([n.nsSelect.b(), n.nsSelect.m(n.selectSize)]),
    onMouseenter: e[14] || (e[14] = (p) => n.states.inputHovering = !0),
    onMouseleave: e[15] || (e[15] = (p) => n.states.inputHovering = !1),
    onClick: e[16] || (e[16] = Le((...p) => n.toggleMenu && n.toggleMenu(...p), ["stop"]))
  }, [
    K(a, {
      ref: "tooltipRef",
      visible: n.dropdownMenuVisible,
      placement: n.placement,
      teleported: n.teleported,
      "popper-class": [n.nsSelect.e("popper"), n.popperClass],
      "popper-options": n.popperOptions,
      "fallback-placements": n.fallbackPlacements,
      effect: n.effect,
      pure: "",
      trigger: "click",
      transition: `${n.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: n.persistent,
      onBeforeShow: n.handleMenuEnter,
      onHide: e[13] || (e[13] = (p) => n.states.isBeforeHide = !1)
    }, {
      default: Y(() => {
        var p;
        return [
          Z("div", {
            ref: "wrapperRef",
            class: L([
              n.nsSelect.e("wrapper"),
              n.nsSelect.is("focused", n.isFocused),
              n.nsSelect.is("hovering", n.states.inputHovering),
              n.nsSelect.is("filterable", n.filterable),
              n.nsSelect.is("disabled", n.selectDisabled)
            ])
          }, [
            n.$slots.prefix ? (R(), V("div", {
              key: 0,
              ref: "prefixRef",
              class: L(n.nsSelect.e("prefix"))
            }, [
              de(n.$slots, "prefix")
            ], 2)) : G("v-if", !0),
            Z("div", {
              ref: "selectionRef",
              class: L([
                n.nsSelect.e("selection"),
                n.nsSelect.is("near", n.multiple && !n.$slots.prefix && !!n.states.selected.length)
              ])
            }, [
              n.multiple ? de(n.$slots, "tag", { key: 0 }, () => [
                (R(!0), V(Tt, null, ai(n.showTagList, (g) => (R(), V("div", {
                  key: n.getValueKey(g),
                  class: L(n.nsSelect.e("selected-item"))
                }, [
                  K(o, {
                    closable: !n.selectDisabled && !g.isDisabled,
                    size: n.collapseTagSize,
                    type: n.tagType,
                    "disable-transitions": "",
                    style: Qe(n.tagStyle),
                    onClose: (m) => n.deleteTag(m, g)
                  }, {
                    default: Y(() => [
                      Z("span", {
                        class: L(n.nsSelect.e("tags-text"))
                      }, xe(g.currentLabel), 3)
                    ]),
                    _: 2
                  }, 1032, ["closable", "size", "type", "style", "onClose"])
                ], 2))), 128)),
                n.collapseTags && n.states.selected.length > n.maxCollapseTags ? (R(), ie(a, {
                  key: 0,
                  ref: "tagTooltipRef",
                  disabled: n.dropdownMenuVisible || !n.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  effect: n.effect,
                  placement: "bottom",
                  teleported: n.teleported
                }, {
                  default: Y(() => [
                    Z("div", {
                      ref: "collapseItemRef",
                      class: L(n.nsSelect.e("selected-item"))
                    }, [
                      K(o, {
                        closable: !1,
                        size: n.collapseTagSize,
                        type: n.tagType,
                        "disable-transitions": "",
                        style: Qe(n.collapseTagStyle)
                      }, {
                        default: Y(() => [
                          Z("span", {
                            class: L(n.nsSelect.e("tags-text"))
                          }, " + " + xe(n.states.selected.length - n.maxCollapseTags), 3)
                        ]),
                        _: 1
                      }, 8, ["size", "type", "style"])
                    ], 2)
                  ]),
                  content: Y(() => [
                    Z("div", {
                      ref: "tagMenuRef",
                      class: L(n.nsSelect.e("selection"))
                    }, [
                      (R(!0), V(Tt, null, ai(n.collapseTagList, (g) => (R(), V("div", {
                        key: n.getValueKey(g),
                        class: L(n.nsSelect.e("selected-item"))
                      }, [
                        K(o, {
                          class: "in-tooltip",
                          closable: !n.selectDisabled && !g.isDisabled,
                          size: n.collapseTagSize,
                          type: n.tagType,
                          "disable-transitions": "",
                          onClose: (m) => n.deleteTag(m, g)
                        }, {
                          default: Y(() => [
                            Z("span", {
                              class: L(n.nsSelect.e("tags-text"))
                            }, xe(g.currentLabel), 3)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "onClose"])
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["disabled", "effect", "teleported"])) : G("v-if", !0)
              ]) : G("v-if", !0),
              n.selectDisabled ? G("v-if", !0) : (R(), V("div", {
                key: 1,
                class: L([
                  n.nsSelect.e("selected-item"),
                  n.nsSelect.e("input-wrapper"),
                  n.nsSelect.is("hidden", !n.filterable)
                ])
              }, [
                it(Z("input", {
                  id: n.inputId,
                  ref: "inputRef",
                  "onUpdate:modelValue": e[0] || (e[0] = (g) => n.states.inputValue = g),
                  type: "text",
                  class: L([n.nsSelect.e("input"), n.nsSelect.is(n.selectSize)]),
                  disabled: n.selectDisabled,
                  autocomplete: n.autocomplete,
                  style: Qe(n.inputStyle),
                  role: "combobox",
                  readonly: !n.filterable,
                  spellcheck: "false",
                  "aria-activedescendant": ((p = n.hoverOption) == null ? void 0 : p.id) || "",
                  "aria-controls": n.contentId,
                  "aria-expanded": n.dropdownMenuVisible,
                  "aria-label": n.ariaLabel,
                  "aria-autocomplete": "none",
                  "aria-haspopup": "listbox",
                  onFocus: e[1] || (e[1] = (...g) => n.handleFocus && n.handleFocus(...g)),
                  onBlur: e[2] || (e[2] = (...g) => n.handleBlur && n.handleBlur(...g)),
                  onKeydown: [
                    e[3] || (e[3] = Ut(Le((g) => n.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                    e[4] || (e[4] = Ut(Le((g) => n.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                    e[5] || (e[5] = Ut(Le((...g) => n.handleEsc && n.handleEsc(...g), ["stop", "prevent"]), ["esc"])),
                    e[6] || (e[6] = Ut(Le((...g) => n.selectOption && n.selectOption(...g), ["stop", "prevent"]), ["enter"])),
                    e[7] || (e[7] = Ut(Le((...g) => n.deletePrevTag && n.deletePrevTag(...g), ["stop"]), ["delete"]))
                  ],
                  onCompositionstart: e[8] || (e[8] = (...g) => n.handleCompositionStart && n.handleCompositionStart(...g)),
                  onCompositionupdate: e[9] || (e[9] = (...g) => n.handleCompositionUpdate && n.handleCompositionUpdate(...g)),
                  onCompositionend: e[10] || (e[10] = (...g) => n.handleCompositionEnd && n.handleCompositionEnd(...g)),
                  onInput: e[11] || (e[11] = (...g) => n.onInput && n.onInput(...g)),
                  onClick: e[12] || (e[12] = Le((...g) => n.toggleMenu && n.toggleMenu(...g), ["stop"]))
                }, null, 46, DY), [
                  [L1, n.states.inputValue]
                ]),
                n.filterable ? (R(), V("span", {
                  key: 0,
                  ref: "calculatorRef",
                  "aria-hidden": "true",
                  class: L(n.nsSelect.e("input-calculator")),
                  textContent: xe(n.states.inputValue)
                }, null, 10, LY)) : G("v-if", !0)
              ], 2)),
              n.shouldShowPlaceholder ? (R(), V("div", {
                key: 2,
                class: L([
                  n.nsSelect.e("selected-item"),
                  n.nsSelect.e("placeholder"),
                  n.nsSelect.is("transparent", !n.hasModelValue || n.expanded && !n.states.inputValue)
                ])
              }, [
                Z("span", null, xe(n.currentPlaceholder), 1)
              ], 2)) : G("v-if", !0)
            ], 2),
            Z("div", {
              ref: "suffixRef",
              class: L(n.nsSelect.e("suffix"))
            }, [
              n.iconComponent && !n.showClose ? (R(), ie(l, {
                key: 0,
                class: L([n.nsSelect.e("caret"), n.nsSelect.e("icon"), n.iconReverse])
              }, {
                default: Y(() => [
                  (R(), ie(yt(n.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])) : G("v-if", !0),
              n.showClose && n.clearIcon ? (R(), ie(l, {
                key: 1,
                class: L([n.nsSelect.e("caret"), n.nsSelect.e("icon")]),
                onClick: n.handleClearClick
              }, {
                default: Y(() => [
                  (R(), ie(yt(n.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : G("v-if", !0),
              n.validateState && n.validateIcon ? (R(), ie(l, {
                key: 2,
                class: L([n.nsInput.e("icon"), n.nsInput.e("validateIcon")])
              }, {
                default: Y(() => [
                  (R(), ie(yt(n.validateIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : G("v-if", !0)
            ], 2)
          ], 2)
        ];
      }),
      content: Y(() => [
        K(d, { ref: "menuRef" }, {
          default: Y(() => [
            n.$slots.header ? (R(), V("div", {
              key: 0,
              class: L(n.nsSelect.be("dropdown", "header"))
            }, [
              de(n.$slots, "header")
            ], 2)) : G("v-if", !0),
            it(K(h, {
              id: n.contentId,
              ref: "scrollbarRef",
              tag: "ul",
              "wrap-class": n.nsSelect.be("dropdown", "wrap"),
              "view-class": n.nsSelect.be("dropdown", "list"),
              class: L([n.nsSelect.is("empty", n.filteredOptionsCount === 0)]),
              role: "listbox",
              "aria-label": n.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: Y(() => [
                n.showNewOption ? (R(), ie(c, {
                  key: 0,
                  value: n.states.inputValue,
                  created: !0
                }, null, 8, ["value"])) : G("v-if", !0),
                K(u, null, {
                  default: Y(() => [
                    de(n.$slots, "default")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [Qt, n.states.options.size > 0 && !n.loading]
            ]),
            n.$slots.loading && n.loading ? (R(), V("div", {
              key: 1,
              class: L(n.nsSelect.be("dropdown", "loading"))
            }, [
              de(n.$slots, "loading")
            ], 2)) : n.loading || n.filteredOptionsCount === 0 ? (R(), V("div", {
              key: 2,
              class: L(n.nsSelect.be("dropdown", "empty"))
            }, [
              de(n.$slots, "empty", {}, () => [
                Z("span", null, xe(n.emptyText), 1)
              ])
            ], 2)) : G("v-if", !0),
            n.$slots.footer ? (R(), V("div", {
              key: 3,
              class: L(n.nsSelect.be("dropdown", "footer"))
            }, [
              de(n.$slots, "footer")
            ], 2)) : G("v-if", !0)
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])
  ], 34)), [
    [f, n.handleClickOutside, n.popperRef]
  ]);
}
var BY = /* @__PURE__ */ Ce(NY, [["render", IY], ["__file", "select.vue"]]);
const QY = F({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(n) {
    const e = me("select"), t = D(null), i = Xe(), r = D([]);
    ft(C_, Gt({
      ...Hr(n)
    }));
    const s = $(() => r.value.some((l) => l.visible === !0)), o = (l) => {
      const c = [];
      return xt(l.children) && l.children.forEach((u) => {
        var h, d;
        u.type && u.type.name === "ElOption" && u.component && u.component.proxy ? c.push(u.component.proxy) : (h = u.children) != null && h.length ? c.push(...o(u)) : (d = u.component) != null && d.subTree && c.push(...o(u.component.subTree));
      }), c;
    }, a = () => {
      r.value = o(i.subTree);
    };
    return qe(() => {
      a();
    }), NF(t, a, {
      attributes: !0,
      subtree: !0,
      childList: !0
    }), {
      groupRef: t,
      visible: s,
      ns: e
    };
  }
});
function zY(n, e, t, i, r, s) {
  return it((R(), V("ul", {
    ref: "groupRef",
    class: L(n.ns.be("group", "wrap"))
  }, [
    Z("li", {
      class: L(n.ns.be("group", "title"))
    }, xe(n.label), 3),
    Z("li", null, [
      Z("ul", {
        class: L(n.ns.b("group"))
      }, [
        de(n.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [Qt, n.visible]
  ]);
}
var P_ = /* @__PURE__ */ Ce(QY, [["render", zY], ["__file", "option-group.vue"]]);
const jY = Ft(BY, {
  Option: Cw,
  OptionGroup: P_
}), VY = As(Cw);
As(P_);
const kw = () => ke(S_, {}), FY = Ee({
  pageSize: {
    type: Number,
    required: !0
  },
  pageSizes: {
    type: ce(Array),
    default: () => Ur([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String
  },
  disabled: Boolean,
  teleported: Boolean,
  size: {
    type: String,
    values: cc
  }
}), ZY = F({
  name: "ElPaginationSizes"
}), qY = /* @__PURE__ */ F({
  ...ZY,
  props: FY,
  emits: ["page-size-change"],
  setup(n, { emit: e }) {
    const t = n, { t: i } = mn(), r = me("pagination"), s = kw(), o = D(t.pageSize);
    ne(() => t.pageSizes, (c, u) => {
      if (!cn(c, u) && Array.isArray(c)) {
        const h = c.includes(t.pageSize) ? t.pageSize : t.pageSizes[0];
        e("page-size-change", h);
      }
    }), ne(() => t.pageSize, (c) => {
      o.value = c;
    });
    const a = $(() => t.pageSizes);
    function l(c) {
      var u;
      c !== o.value && (o.value = c, (u = s.handleSizeChange) == null || u.call(s, Number(c)));
    }
    return (c, u) => (R(), V("span", {
      class: L(O(r).e("sizes"))
    }, [
      K(O(jY), {
        "model-value": o.value,
        disabled: c.disabled,
        "popper-class": c.popperClass,
        size: c.size,
        teleported: c.teleported,
        "validate-event": !1,
        onChange: l
      }, {
        default: Y(() => [
          (R(!0), V(Tt, null, ai(O(a), (h) => (R(), ie(O(VY), {
            key: h,
            value: h,
            label: h + O(i)("el.pagination.pagesize")
          }, null, 8, ["value", "label"]))), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])
    ], 2));
  }
});
var WY = /* @__PURE__ */ Ce(qY, [["__file", "sizes.vue"]]);
const HY = Ee({
  size: {
    type: String,
    values: cc
  }
}), XY = ["disabled"], YY = F({
  name: "ElPaginationJumper"
}), UY = /* @__PURE__ */ F({
  ...YY,
  props: HY,
  setup(n) {
    const { t: e } = mn(), t = me("pagination"), { pageCount: i, disabled: r, currentPage: s, changeEvent: o } = kw(), a = D(), l = $(() => {
      var h;
      return (h = a.value) != null ? h : s == null ? void 0 : s.value;
    });
    function c(h) {
      a.value = h ? +h : "";
    }
    function u(h) {
      h = Math.trunc(+h), o == null || o(h), a.value = void 0;
    }
    return (h, d) => (R(), V("span", {
      class: L(O(t).e("jump")),
      disabled: O(r)
    }, [
      Z("span", {
        class: L([O(t).e("goto")])
      }, xe(O(e)("el.pagination.goto")), 3),
      K(O(uc), {
        size: h.size,
        class: L([O(t).e("editor"), O(t).is("in-pagination")]),
        min: 1,
        max: O(i),
        disabled: O(r),
        "model-value": O(l),
        "validate-event": !1,
        label: O(e)("el.pagination.page"),
        type: "number",
        "onUpdate:modelValue": c,
        onChange: u
      }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
      Z("span", {
        class: L([O(t).e("classifier")])
      }, xe(O(e)("el.pagination.pageClassifier")), 3)
    ], 10, XY));
  }
});
var GY = /* @__PURE__ */ Ce(UY, [["__file", "jumper.vue"]]);
const KY = Ee({
  total: {
    type: Number,
    default: 1e3
  }
}), JY = ["disabled"], eU = F({
  name: "ElPaginationTotal"
}), tU = /* @__PURE__ */ F({
  ...eU,
  props: KY,
  setup(n) {
    const { t: e } = mn(), t = me("pagination"), { disabled: i } = kw();
    return (r, s) => (R(), V("span", {
      class: L(O(t).e("total")),
      disabled: O(i)
    }, xe(O(e)("el.pagination.total", {
      total: r.total
    })), 11, JY));
  }
});
var nU = /* @__PURE__ */ Ce(tU, [["__file", "total.vue"]]);
const iU = Ee({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: !0
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
}), rU = ["onKeyup"], sU = ["aria-current", "aria-label", "tabindex"], oU = ["tabindex", "aria-label"], aU = ["aria-current", "aria-label", "tabindex"], lU = ["tabindex", "aria-label"], cU = ["aria-current", "aria-label", "tabindex"], uU = F({
  name: "ElPaginationPager"
}), hU = /* @__PURE__ */ F({
  ...uU,
  props: iU,
  emits: ["change"],
  setup(n, { emit: e }) {
    const t = n, i = me("pager"), r = me("icon"), { t: s } = mn(), o = D(!1), a = D(!1), l = D(!1), c = D(!1), u = D(!1), h = D(!1), d = $(() => {
      const w = t.pagerCount, x = (w - 1) / 2, S = Number(t.currentPage), C = Number(t.pageCount);
      let k = !1, E = !1;
      C > w && (S > w - x && (k = !0), S < C - x && (E = !0));
      const M = [];
      if (k && !E) {
        const _ = C - (w - 2);
        for (let T = _; T < C; T++)
          M.push(T);
      } else if (!k && E)
        for (let _ = 2; _ < w; _++)
          M.push(_);
      else if (k && E) {
        const _ = Math.floor(w / 2) - 1;
        for (let T = S - _; T <= S + _; T++)
          M.push(T);
      } else
        for (let _ = 2; _ < C; _++)
          M.push(_);
      return M;
    }), f = $(() => [
      "more",
      "btn-quickprev",
      r.b(),
      i.is("disabled", t.disabled)
    ]), p = $(() => [
      "more",
      "btn-quicknext",
      r.b(),
      i.is("disabled", t.disabled)
    ]), g = $(() => t.disabled ? -1 : 0);
    Fr(() => {
      const w = (t.pagerCount - 1) / 2;
      o.value = !1, a.value = !1, t.pageCount > t.pagerCount && (t.currentPage > t.pagerCount - w && (o.value = !0), t.currentPage < t.pageCount - w && (a.value = !0));
    });
    function m(w = !1) {
      t.disabled || (w ? l.value = !0 : c.value = !0);
    }
    function v(w = !1) {
      w ? u.value = !0 : h.value = !0;
    }
    function y(w) {
      const x = w.target;
      if (x.tagName.toLowerCase() === "li" && Array.from(x.classList).includes("number")) {
        const S = Number(x.textContent);
        S !== t.currentPage && e("change", S);
      } else
        x.tagName.toLowerCase() === "li" && Array.from(x.classList).includes("more") && b(w);
    }
    function b(w) {
      const x = w.target;
      if (x.tagName.toLowerCase() === "ul" || t.disabled)
        return;
      let S = Number(x.textContent);
      const C = t.pageCount, k = t.currentPage, E = t.pagerCount - 2;
      x.className.includes("more") && (x.className.includes("quickprev") ? S = k - E : x.className.includes("quicknext") && (S = k + E)), Number.isNaN(+S) || (S < 1 && (S = 1), S > C && (S = C)), S !== k && e("change", S);
    }
    return (w, x) => (R(), V("ul", {
      class: L(O(i).b()),
      onClick: b,
      onKeyup: Ut(y, ["enter"])
    }, [
      w.pageCount > 0 ? (R(), V("li", {
        key: 0,
        class: L([[
          O(i).is("active", w.currentPage === 1),
          O(i).is("disabled", w.disabled)
        ], "number"]),
        "aria-current": w.currentPage === 1,
        "aria-label": O(s)("el.pagination.currentPage", { pager: 1 }),
        tabindex: O(g)
      }, " 1 ", 10, sU)) : G("v-if", !0),
      o.value ? (R(), V("li", {
        key: 1,
        class: L(O(f)),
        tabindex: O(g),
        "aria-label": O(s)("el.pagination.prevPages", { pager: w.pagerCount - 2 }),
        onMouseenter: x[0] || (x[0] = (S) => m(!0)),
        onMouseleave: x[1] || (x[1] = (S) => l.value = !1),
        onFocus: x[2] || (x[2] = (S) => v(!0)),
        onBlur: x[3] || (x[3] = (S) => u.value = !1)
      }, [
        (l.value || u.value) && !w.disabled ? (R(), ie(O(Ej), { key: 0 })) : (R(), ie(O(ZS), { key: 1 }))
      ], 42, oU)) : G("v-if", !0),
      (R(!0), V(Tt, null, ai(O(d), (S) => (R(), V("li", {
        key: S,
        class: L([[
          O(i).is("active", w.currentPage === S),
          O(i).is("disabled", w.disabled)
        ], "number"]),
        "aria-current": w.currentPage === S,
        "aria-label": O(s)("el.pagination.currentPage", { pager: S }),
        tabindex: O(g)
      }, xe(S), 11, aU))), 128)),
      a.value ? (R(), V("li", {
        key: 2,
        class: L(O(p)),
        tabindex: O(g),
        "aria-label": O(s)("el.pagination.nextPages", { pager: w.pagerCount - 2 }),
        onMouseenter: x[4] || (x[4] = (S) => m()),
        onMouseleave: x[5] || (x[5] = (S) => c.value = !1),
        onFocus: x[6] || (x[6] = (S) => v()),
        onBlur: x[7] || (x[7] = (S) => h.value = !1)
      }, [
        (c.value || h.value) && !w.disabled ? (R(), ie(O($j), { key: 0 })) : (R(), ie(O(ZS), { key: 1 }))
      ], 42, lU)) : G("v-if", !0),
      w.pageCount > 1 ? (R(), V("li", {
        key: 3,
        class: L([[
          O(i).is("active", w.currentPage === w.pageCount),
          O(i).is("disabled", w.disabled)
        ], "number"]),
        "aria-current": w.currentPage === w.pageCount,
        "aria-label": O(s)("el.pagination.currentPage", { pager: w.pageCount }),
        tabindex: O(g)
      }, xe(w.pageCount), 11, cU)) : G("v-if", !0)
    ], 42, rU));
  }
});
var dU = /* @__PURE__ */ Ce(hU, [["__file", "pager.vue"]]);
const zi = (n) => typeof n != "number", fU = Ee({
  pageSize: Number,
  defaultPageSize: Number,
  total: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (n) => tt(n) && Math.trunc(n) === n && n > 4 && n < 22 && n % 2 === 1,
    default: 7
  },
  currentPage: Number,
  defaultCurrentPage: Number,
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: ce(Array),
    default: () => Ur([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: Pn,
    default: () => G1
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: Pn,
    default: () => ac
  },
  teleported: {
    type: Boolean,
    default: !0
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
}), pU = {
  "update:current-page": (n) => tt(n),
  "update:page-size": (n) => tt(n),
  "size-change": (n) => tt(n),
  change: (n, e) => tt(n) && tt(e),
  "current-change": (n) => tt(n),
  "prev-click": (n) => tt(n),
  "next-click": (n) => tt(n)
}, sk = "ElPagination";
var gU = F({
  name: sk,
  props: fU,
  emits: pU,
  setup(n, { emit: e, slots: t }) {
    const { t: i } = mn(), r = me("pagination"), s = Xe().vnode.props || {}, o = "onUpdate:currentPage" in s || "onUpdate:current-page" in s || "onCurrentChange" in s, a = "onUpdate:pageSize" in s || "onUpdate:page-size" in s || "onSizeChange" in s, l = $(() => {
      if (zi(n.total) && zi(n.pageCount) || !zi(n.currentPage) && !o)
        return !1;
      if (n.layout.includes("sizes")) {
        if (zi(n.pageCount)) {
          if (!zi(n.total) && !zi(n.pageSize) && !a)
            return !1;
        } else if (!a)
          return !1;
      }
      return !0;
    }), c = D(zi(n.defaultPageSize) ? 10 : n.defaultPageSize), u = D(zi(n.defaultCurrentPage) ? 1 : n.defaultCurrentPage), h = $({
      get() {
        return zi(n.pageSize) ? c.value : n.pageSize;
      },
      set(b) {
        zi(n.pageSize) && (c.value = b), a && (e("update:page-size", b), e("size-change", b));
      }
    }), d = $(() => {
      let b = 0;
      return zi(n.pageCount) ? zi(n.total) || (b = Math.max(1, Math.ceil(n.total / h.value))) : b = n.pageCount, b;
    }), f = $({
      get() {
        return zi(n.currentPage) ? u.value : n.currentPage;
      },
      set(b) {
        let w = b;
        b < 1 ? w = 1 : b > d.value && (w = d.value), zi(n.currentPage) && (u.value = w), o && (e("update:current-page", w), e("current-change", w));
      }
    });
    ne(d, (b) => {
      f.value > b && (f.value = b);
    }), ne([f, h], (b) => {
      e("change", ...b);
    }, { flush: "post" });
    function p(b) {
      f.value = b;
    }
    function g(b) {
      h.value = b;
      const w = d.value;
      f.value > w && (f.value = w);
    }
    function m() {
      n.disabled || (f.value -= 1, e("prev-click", f.value));
    }
    function v() {
      n.disabled || (f.value += 1, e("next-click", f.value));
    }
    function y(b, w) {
      b && (b.props || (b.props = {}), b.props.class = [b.props.class, w].join(" "));
    }
    return ft(S_, {
      pageCount: d,
      disabled: $(() => n.disabled),
      currentPage: f,
      changeEvent: p,
      handleSizeChange: g
    }), () => {
      var b, w;
      if (!l.value)
        return pt(sk, i("el.pagination.deprecationWarning")), null;
      if (!n.layout || n.hideOnSinglePage && d.value <= 1)
        return null;
      const x = [], S = [], C = Re("div", { class: r.e("rightwrapper") }, S), k = {
        prev: Re(mY, {
          disabled: n.disabled,
          currentPage: f.value,
          prevText: n.prevText,
          prevIcon: n.prevIcon,
          onClick: m
        }),
        jumper: Re(GY, {
          size: n.small ? "small" : "default"
        }),
        pager: Re(dU, {
          currentPage: f.value,
          pageCount: d.value,
          pagerCount: n.pagerCount,
          onChange: p,
          disabled: n.disabled
        }),
        next: Re(xY, {
          disabled: n.disabled,
          currentPage: f.value,
          pageCount: d.value,
          nextText: n.nextText,
          nextIcon: n.nextIcon,
          onClick: v
        }),
        sizes: Re(WY, {
          pageSize: h.value,
          pageSizes: n.pageSizes,
          popperClass: n.popperClass,
          disabled: n.disabled,
          teleported: n.teleported,
          size: n.small ? "small" : "default"
        }),
        slot: (w = (b = t == null ? void 0 : t.default) == null ? void 0 : b.call(t)) != null ? w : null,
        total: Re(nU, { total: zi(n.total) ? 0 : n.total })
      }, E = n.layout.split(",").map((_) => _.trim());
      let M = !1;
      return E.forEach((_) => {
        if (_ === "->") {
          M = !0;
          return;
        }
        M ? S.push(k[_]) : x.push(k[_]);
      }), y(x[0], r.is("first")), y(x[x.length - 1], r.is("last")), M && S.length > 0 && (y(S[0], r.is("first")), y(S[S.length - 1], r.is("last")), x.push(C)), Re("div", {
        class: [
          r.b(),
          r.is("background", n.background),
          {
            [r.m("small")]: n.small
          }
        ]
      }, x);
    };
  }
});
const DKe = Ft(gU), mU = Ee({
  title: String,
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonType: {
    type: String,
    values: hy,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: hy,
    default: "text"
  },
  icon: {
    type: Pn,
    default: () => iV
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: {
    type: Boolean,
    default: !1
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  teleported: mi.teleported,
  persistent: mi.persistent,
  width: {
    type: [String, Number],
    default: 150
  }
}), vU = {
  confirm: (n) => n instanceof MouseEvent,
  cancel: (n) => n instanceof MouseEvent
}, bU = F({
  name: "ElPopconfirm"
}), yU = /* @__PURE__ */ F({
  ...bU,
  props: mU,
  emits: vU,
  setup(n, { emit: e }) {
    const t = n, { t: i } = mn(), r = me("popconfirm"), s = D(), o = () => {
      var d, f;
      (f = (d = s.value) == null ? void 0 : d.onClose) == null || f.call(d);
    }, a = $(() => ({
      width: ur(t.width)
    })), l = (d) => {
      e("confirm", d), o();
    }, c = (d) => {
      e("cancel", d), o();
    }, u = $(() => t.confirmButtonText || i("el.popconfirm.confirmButtonText")), h = $(() => t.cancelButtonText || i("el.popconfirm.cancelButtonText"));
    return (d, f) => (R(), ie(O(Fo), Pi({
      ref_key: "tooltipRef",
      ref: s,
      trigger: "click",
      effect: "light"
    }, d.$attrs, {
      "popper-class": `${O(r).namespace.value}-popover`,
      "popper-style": O(a),
      teleported: d.teleported,
      "fallback-placements": ["bottom", "top", "right", "left"],
      "hide-after": d.hideAfter,
      persistent: d.persistent
    }), {
      content: Y(() => [
        Z("div", {
          class: L(O(r).b())
        }, [
          Z("div", {
            class: L(O(r).e("main"))
          }, [
            !d.hideIcon && d.icon ? (R(), ie(O(Fe), {
              key: 0,
              class: L(O(r).e("icon")),
              style: Qe({ color: d.iconColor })
            }, {
              default: Y(() => [
                (R(), ie(yt(d.icon)))
              ]),
              _: 1
            }, 8, ["class", "style"])) : G("v-if", !0),
            Yn(" " + xe(d.title), 1)
          ], 2),
          Z("div", {
            class: L(O(r).e("action"))
          }, [
            K(O(Wl), {
              size: "small",
              type: d.cancelButtonType === "text" ? "" : d.cancelButtonType,
              text: d.cancelButtonType === "text",
              onClick: c
            }, {
              default: Y(() => [
                Yn(xe(O(h)), 1)
              ]),
              _: 1
            }, 8, ["type", "text"]),
            K(O(Wl), {
              size: "small",
              type: d.confirmButtonType === "text" ? "" : d.confirmButtonType,
              text: d.confirmButtonType === "text",
              onClick: l
            }, {
              default: Y(() => [
                Yn(xe(O(u)), 1)
              ]),
              _: 1
            }, 8, ["type", "text"])
          ], 2)
        ], 2)
      ]),
      default: Y(() => [
        d.$slots.reference ? de(d.$slots, "reference", { key: 0 }) : G("v-if", !0)
      ]),
      _: 3
    }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]));
  }
});
var OU = /* @__PURE__ */ Ce(yU, [["__file", "popconfirm.vue"]]);
const LKe = Ft(OU), wU = Ee({
  trigger: Ld.trigger,
  placement: _0.placement,
  disabled: Ld.disabled,
  visible: mi.visible,
  transition: mi.transition,
  popperOptions: _0.popperOptions,
  tabindex: _0.tabindex,
  content: mi.content,
  popperStyle: mi.popperStyle,
  popperClass: mi.popperClass,
  enterable: {
    ...mi.enterable,
    default: !0
  },
  effect: {
    ...mi.effect,
    default: "light"
  },
  teleported: mi.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), xU = {
  "update:visible": (n) => Ei(n),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, SU = "onUpdate:visible", CU = F({
  name: "ElPopover"
}), kU = /* @__PURE__ */ F({
  ...CU,
  props: wU,
  emits: xU,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = $(() => i[SU]), s = me("popover"), o = D(), a = $(() => {
      var m;
      return (m = O(o)) == null ? void 0 : m.popperRef;
    }), l = $(() => [
      {
        width: ur(i.width)
      },
      i.popperStyle
    ]), c = $(() => [s.b(), i.popperClass, { [s.m("plain")]: !!i.content }]), u = $(() => i.transition === `${s.namespace.value}-fade-in-linear`), h = () => {
      var m;
      (m = o.value) == null || m.hide();
    }, d = () => {
      t("before-enter");
    }, f = () => {
      t("before-leave");
    }, p = () => {
      t("after-enter");
    }, g = () => {
      t("update:visible", !1), t("after-leave");
    };
    return e({
      popperRef: a,
      hide: h
    }), (m, v) => (R(), ie(O(Fo), Pi({
      ref_key: "tooltipRef",
      ref: o
    }, m.$attrs, {
      trigger: m.trigger,
      placement: m.placement,
      disabled: m.disabled,
      visible: m.visible,
      transition: m.transition,
      "popper-options": m.popperOptions,
      tabindex: m.tabindex,
      content: m.content,
      offset: m.offset,
      "show-after": m.showAfter,
      "hide-after": m.hideAfter,
      "auto-close": m.autoClose,
      "show-arrow": m.showArrow,
      "aria-label": m.title,
      effect: m.effect,
      enterable: m.enterable,
      "popper-class": O(c),
      "popper-style": O(l),
      teleported: m.teleported,
      persistent: m.persistent,
      "gpu-acceleration": O(u),
      "onUpdate:visible": O(r),
      onBeforeShow: d,
      onBeforeHide: f,
      onShow: p,
      onHide: g
    }), {
      content: Y(() => [
        m.title ? (R(), V("div", {
          key: 0,
          class: L(O(s).e("title")),
          role: "title"
        }, xe(m.title), 3)) : G("v-if", !0),
        de(m.$slots, "default", {}, () => [
          Yn(xe(m.content), 1)
        ])
      ]),
      default: Y(() => [
        m.$slots.reference ? de(m.$slots, "reference", { key: 0 }) : G("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var PU = /* @__PURE__ */ Ce(kU, [["__file", "popover.vue"]]);
const ok = (n, e) => {
  const t = e.arg || e.value, i = t == null ? void 0 : t.popperRef;
  i && (i.triggerRef = n);
};
var EU = {
  mounted(n, e) {
    ok(n, e);
  },
  updated(n, e) {
    ok(n, e);
  }
};
const AU = "popover", $U = tZ(EU, AU), IKe = Ft(PU, {
  directive: $U
}), TU = Ee({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (n) => n >= 0 && n <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: ce(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: ce([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: ce(Function),
    default: (n) => `${n}%`
  }
}), _U = ["aria-valuenow"], MU = { viewBox: "0 0 100 100" }, RU = ["d", "stroke", "stroke-linecap", "stroke-width"], NU = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], DU = { key: 0 }, LU = F({
  name: "ElProgress"
}), IU = /* @__PURE__ */ F({
  ...LU,
  props: TU,
  setup(n) {
    const e = n, t = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, i = me("progress"), r = $(() => ({
      width: `${e.percentage}%`,
      animationDuration: `${e.duration}s`,
      backgroundColor: y(e.percentage)
    })), s = $(() => (e.strokeWidth / e.width * 100).toFixed(1)), o = $(() => ["circle", "dashboard"].includes(e.type) ? Number.parseInt(`${50 - Number.parseFloat(s.value) / 2}`, 10) : 0), a = $(() => {
      const b = o.value, w = e.type === "dashboard";
      return `
          M 50 50
          m 0 ${w ? "" : "-"}${b}
          a ${b} ${b} 0 1 1 0 ${w ? "-" : ""}${b * 2}
          a ${b} ${b} 0 1 1 0 ${w ? "" : "-"}${b * 2}
          `;
    }), l = $(() => 2 * Math.PI * o.value), c = $(() => e.type === "dashboard" ? 0.75 : 1), u = $(() => `${-1 * l.value * (1 - c.value) / 2}px`), h = $(() => ({
      strokeDasharray: `${l.value * c.value}px, ${l.value}px`,
      strokeDashoffset: u.value
    })), d = $(() => ({
      strokeDasharray: `${l.value * c.value * (e.percentage / 100)}px, ${l.value}px`,
      strokeDashoffset: u.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), f = $(() => {
      let b;
      return e.color ? b = y(e.percentage) : b = t[e.status] || t.default, b;
    }), p = $(() => e.status === "warning" ? J1 : e.type === "line" ? e.status === "success" ? K1 : ah : e.status === "success" ? fv : jo), g = $(() => e.type === "line" ? 12 + e.strokeWidth * 0.4 : e.width * 0.111111 + 2), m = $(() => e.format(e.percentage));
    function v(b) {
      const w = 100 / b.length;
      return b.map((S, C) => bt(S) ? {
        color: S,
        percentage: (C + 1) * w
      } : S).sort((S, C) => S.percentage - C.percentage);
    }
    const y = (b) => {
      var w;
      const { color: x } = e;
      if (wt(x))
        return x(b);
      if (bt(x))
        return x;
      {
        const S = v(x);
        for (const C of S)
          if (C.percentage > b)
            return C.color;
        return (w = S[S.length - 1]) == null ? void 0 : w.color;
      }
    };
    return (b, w) => (R(), V("div", {
      class: L([
        O(i).b(),
        O(i).m(b.type),
        O(i).is(b.status),
        {
          [O(i).m("without-text")]: !b.showText,
          [O(i).m("text-inside")]: b.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": b.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      b.type === "line" ? (R(), V("div", {
        key: 0,
        class: L(O(i).b("bar"))
      }, [
        Z("div", {
          class: L(O(i).be("bar", "outer")),
          style: Qe({ height: `${b.strokeWidth}px` })
        }, [
          Z("div", {
            class: L([
              O(i).be("bar", "inner"),
              { [O(i).bem("bar", "inner", "indeterminate")]: b.indeterminate },
              { [O(i).bem("bar", "inner", "striped")]: b.striped },
              { [O(i).bem("bar", "inner", "striped-flow")]: b.stripedFlow }
            ]),
            style: Qe(O(r))
          }, [
            (b.showText || b.$slots.default) && b.textInside ? (R(), V("div", {
              key: 0,
              class: L(O(i).be("bar", "innerText"))
            }, [
              de(b.$slots, "default", { percentage: b.percentage }, () => [
                Z("span", null, xe(O(m)), 1)
              ])
            ], 2)) : G("v-if", !0)
          ], 6)
        ], 6)
      ], 2)) : (R(), V("div", {
        key: 1,
        class: L(O(i).b("circle")),
        style: Qe({ height: `${b.width}px`, width: `${b.width}px` })
      }, [
        (R(), V("svg", MU, [
          Z("path", {
            class: L(O(i).be("circle", "track")),
            d: O(a),
            stroke: `var(${O(i).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": b.strokeLinecap,
            "stroke-width": O(s),
            fill: "none",
            style: Qe(O(h))
          }, null, 14, RU),
          Z("path", {
            class: L(O(i).be("circle", "path")),
            d: O(a),
            stroke: O(f),
            fill: "none",
            opacity: b.percentage ? 1 : 0,
            "stroke-linecap": b.strokeLinecap,
            "stroke-width": O(s),
            style: Qe(O(d))
          }, null, 14, NU)
        ]))
      ], 6)),
      (b.showText || b.$slots.default) && !b.textInside ? (R(), V("div", {
        key: 2,
        class: L(O(i).e("text")),
        style: Qe({ fontSize: `${O(g)}px` })
      }, [
        de(b.$slots, "default", { percentage: b.percentage }, () => [
          b.status ? (R(), ie(O(Fe), { key: 1 }, {
            default: Y(() => [
              (R(), ie(yt(O(p))))
            ]),
            _: 1
          })) : (R(), V("span", DU, xe(O(m)), 1))
        ])
      ], 6)) : G("v-if", !0)
    ], 10, _U));
  }
});
var BU = /* @__PURE__ */ Ce(IU, [["__file", "progress.vue"]]);
const QU = Ft(BU);
var ak = Number.isNaN || function(e) {
  return typeof e == "number" && e !== e;
};
function zU(n, e) {
  return !!(n === e || ak(n) && ak(e));
}
function jU(n, e) {
  if (n.length !== e.length)
    return !1;
  for (var t = 0; t < n.length; t++)
    if (!zU(n[t], e[t]))
      return !1;
  return !0;
}
function VU(n, e) {
  e === void 0 && (e = jU);
  var t = null;
  function i() {
    for (var r = [], s = 0; s < arguments.length; s++)
      r[s] = arguments[s];
    if (t && t.lastThis === this && e(r, t.lastArgs))
      return t.lastResult;
    var o = n.apply(this, r);
    return t = {
      lastResult: o,
      lastArgs: r,
      lastThis: this
    }, o;
  }
  return i.clear = function() {
    t = null;
  }, i;
}
const FU = () => {
  const e = Xe().proxy.$props;
  return $(() => {
    const t = (i, r, s) => ({});
    return e.perfMode ? cv(t) : VU(t);
  });
}, ZU = 50, lk = "itemRendered", ck = "scroll", E_ = "forward", A_ = "backward", Bd = "auto", $_ = "smart", T_ = "start", em = "center", __ = "end", wu = "horizontal", Pw = "vertical", qU = "ltr", fg = "rtl", Py = "negative", M_ = "positive-ascending", R_ = "positive-descending", WU = {
  [wu]: "left",
  [Pw]: "top"
}, HU = 20, XU = {
  [wu]: "deltaX",
  [Pw]: "deltaY"
}, YU = ({ atEndEdge: n, atStartEdge: e, layout: t }, i) => {
  let r, s = 0;
  const o = (l) => l < 0 && e.value || l > 0 && n.value;
  return {
    hasReachedEdge: o,
    onWheel: (l) => {
      aT(r);
      const c = l[XU[t.value]];
      o(s) && o(s + c) || (s += c, X$() || l.preventDefault(), r = iw(() => {
        i(s), s = 0;
      }));
    }
  };
}, Ey = Es({
  type: ce([Number, Function]),
  required: !0
}), Ay = Es({
  type: Number
}), $y = Es({
  type: Number,
  default: 2
}), UU = Es({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
}), Ty = Es({
  type: Number,
  default: 0
}), tm = Es({
  type: Number,
  required: !0
}), N_ = Es({
  type: String,
  values: ["horizontal", "vertical"],
  default: Pw
}), D_ = Ee({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: ce([String, Object]),
    default: "div"
  },
  data: {
    type: ce(Array),
    default: () => Ur([])
  },
  direction: UU,
  height: {
    type: [String, Number],
    required: !0
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  style: {
    type: ce([Object, String, Array])
  },
  useIsScrolling: {
    type: Boolean,
    default: !1
  },
  width: {
    type: [Number, String],
    required: !1
  },
  perfMode: {
    type: Boolean,
    default: !0
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  }
}), GU = Ee({
  cache: $y,
  estimatedItemSize: Ay,
  layout: N_,
  initScrollOffset: Ty,
  total: tm,
  itemSize: Ey,
  ...D_
}), _y = {
  type: Number,
  default: 6
}, L_ = { type: Number, default: 0 }, I_ = { type: Number, default: 2 };
Ee({
  columnCache: $y,
  columnWidth: Ey,
  estimatedColumnWidth: Ay,
  estimatedRowHeight: Ay,
  initScrollLeft: Ty,
  initScrollTop: Ty,
  itemKey: {
    type: ce(Function),
    default: ({
      columnIndex: n,
      rowIndex: e
    }) => `${e}:${n}`
  },
  rowCache: $y,
  rowHeight: Ey,
  totalColumn: tm,
  totalRow: tm,
  hScrollbarSize: _y,
  vScrollbarSize: _y,
  scrollbarStartGap: L_,
  scrollbarEndGap: I_,
  role: String,
  ...D_
});
const KU = Ee({
  alwaysOn: Boolean,
  class: String,
  layout: N_,
  total: tm,
  ratio: {
    type: Number,
    required: !0
  },
  clientSize: {
    type: Number,
    required: !0
  },
  scrollFrom: {
    type: Number,
    required: !0
  },
  scrollbarSize: _y,
  startGap: L_,
  endGap: I_,
  visible: Boolean
}), M0 = (n, e) => n < e ? E_ : A_, Qd = (n) => n === qU || n === fg || n === wu;
let Sc = null;
function uk(n = !1) {
  if (Sc === null || n) {
    const e = document.createElement("div"), t = e.style;
    t.width = "50px", t.height = "50px", t.overflow = "scroll", t.direction = "rtl";
    const i = document.createElement("div"), r = i.style;
    return r.width = "100px", r.height = "100px", e.appendChild(i), document.body.appendChild(e), e.scrollLeft > 0 ? Sc = R_ : (e.scrollLeft = 1, e.scrollLeft === 0 ? Sc = Py : Sc = M_), document.body.removeChild(e), Sc;
  }
  return Sc;
}
function JU({ move: n, size: e, bar: t }, i) {
  const r = {}, s = `translate${t.axis}(${n}px)`;
  return r[t.size] = e, r.transform = s, r.msTransform = s, r.webkitTransform = s, i === "horizontal" ? r.height = "100%" : r.width = "100%", r;
}
const eG = F({
  name: "ElVirtualScrollBar",
  props: KU,
  emits: ["scroll", "start-move", "stop-move"],
  setup(n, { emit: e }) {
    const t = $(() => n.startGap + n.endGap), i = me("virtual-scrollbar"), r = me("scrollbar"), s = D(), o = D();
    let a = null, l = null;
    const c = Gt({
      isDragging: !1,
      traveled: 0
    }), u = $(() => IT[n.layout]), h = $(() => n.clientSize - O(t)), d = $(() => ({
      position: "absolute",
      width: `${wu === n.layout ? h.value : n.scrollbarSize}px`,
      height: `${wu === n.layout ? n.scrollbarSize : h.value}px`,
      [WU[n.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    })), f = $(() => {
      const S = n.ratio, C = n.clientSize;
      if (S >= 100)
        return Number.POSITIVE_INFINITY;
      if (S >= 50)
        return S * C / 100;
      const k = C / 3;
      return Math.floor(Math.min(Math.max(S * C, HU), k));
    }), p = $(() => {
      if (!Number.isFinite(f.value))
        return {
          display: "none"
        };
      const S = `${f.value}px`;
      return JU({
        bar: u.value,
        size: S,
        move: c.traveled
      }, n.layout);
    }), g = $(() => Math.floor(n.clientSize - f.value - O(t))), m = () => {
      window.addEventListener("mousemove", w), window.addEventListener("mouseup", b);
      const S = O(o);
      S && (l = document.onselectstart, document.onselectstart = () => !1, S.addEventListener("touchmove", w), S.addEventListener("touchend", b));
    }, v = () => {
      window.removeEventListener("mousemove", w), window.removeEventListener("mouseup", b), document.onselectstart = l, l = null;
      const S = O(o);
      S && (S.removeEventListener("touchmove", w), S.removeEventListener("touchend", b));
    }, y = (S) => {
      S.stopImmediatePropagation(), !(S.ctrlKey || [1, 2].includes(S.button)) && (c.isDragging = !0, c[u.value.axis] = S.currentTarget[u.value.offset] - (S[u.value.client] - S.currentTarget.getBoundingClientRect()[u.value.direction]), e("start-move"), m());
    }, b = () => {
      c.isDragging = !1, c[u.value.axis] = 0, e("stop-move"), v();
    }, w = (S) => {
      const { isDragging: C } = c;
      if (!C || !o.value || !s.value)
        return;
      const k = c[u.value.axis];
      if (!k)
        return;
      aT(a);
      const E = (s.value.getBoundingClientRect()[u.value.direction] - S[u.value.client]) * -1, M = o.value[u.value.offset] - k, _ = E - M;
      a = iw(() => {
        c.traveled = Math.max(n.startGap, Math.min(_, g.value)), e("scroll", _, g.value);
      });
    }, x = (S) => {
      const C = Math.abs(S.target.getBoundingClientRect()[u.value.direction] - S[u.value.client]), k = o.value[u.value.offset] / 2, E = C - k;
      c.traveled = Math.max(0, Math.min(E, g.value)), e("scroll", E, g.value);
    };
    return ne(() => n.scrollFrom, (S) => {
      c.isDragging || (c.traveled = Math.ceil(S * g.value));
    }), Kn(() => {
      v();
    }), () => Re("div", {
      role: "presentation",
      ref: s,
      class: [
        i.b(),
        n.class,
        (n.alwaysOn || c.isDragging) && "always-on"
      ],
      style: d.value,
      onMousedown: Le(x, ["stop", "prevent"]),
      onTouchstartPrevent: y
    }, Re("div", {
      ref: o,
      class: r.e("thumb"),
      style: p.value,
      onMousedown: y
    }, []));
  }
}), B_ = ({
  name: n,
  getOffset: e,
  getItemSize: t,
  getItemOffset: i,
  getEstimatedTotalSize: r,
  getStartIndexForOffset: s,
  getStopIndexForStartIndex: o,
  initCache: a,
  clearCache: l,
  validateProps: c
}) => F({
  name: n ?? "ElVirtualList",
  props: GU,
  emits: [lk, ck],
  setup(u, { emit: h, expose: d }) {
    c(u);
    const f = Xe(), p = me("vl"), g = D(a(u, f)), m = FU(), v = D(), y = D(), b = D(), w = D({
      isScrolling: !1,
      scrollDir: "forward",
      scrollOffset: tt(u.initScrollOffset) ? u.initScrollOffset : 0,
      updateRequested: !1,
      isScrollbarDragging: !1,
      scrollbarAlwaysOn: u.scrollbarAlwaysOn
    }), x = $(() => {
      const { total: W, cache: U } = u, { isScrolling: ae, scrollDir: he, scrollOffset: ee } = O(w);
      if (W === 0)
        return [0, 0, 0, 0];
      const pe = s(u, ee, O(g)), be = o(u, pe, ee, O(g)), fe = !ae || he === A_ ? Math.max(1, U) : 1, Ae = !ae || he === E_ ? Math.max(1, U) : 1;
      return [
        Math.max(0, pe - fe),
        Math.max(0, Math.min(W - 1, be + Ae)),
        pe,
        be
      ];
    }), S = $(() => r(u, O(g))), C = $(() => Qd(u.layout)), k = $(() => [
      {
        position: "relative",
        [`overflow-${C.value ? "x" : "y"}`]: "scroll",
        WebkitOverflowScrolling: "touch",
        willChange: "transform"
      },
      {
        direction: u.direction,
        height: tt(u.height) ? `${u.height}px` : u.height,
        width: tt(u.width) ? `${u.width}px` : u.width
      },
      u.style
    ]), E = $(() => {
      const W = O(S), U = O(C);
      return {
        height: U ? "100%" : `${W}px`,
        pointerEvents: O(w).isScrolling ? "none" : void 0,
        width: U ? `${W}px` : "100%"
      };
    }), M = $(() => C.value ? u.width : u.height), { onWheel: _ } = YU({
      atStartEdge: $(() => w.value.scrollOffset <= 0),
      atEndEdge: $(() => w.value.scrollOffset >= S.value),
      layout: $(() => u.layout)
    }, (W) => {
      var U, ae;
      (ae = (U = b.value).onMouseUp) == null || ae.call(U), N(Math.min(w.value.scrollOffset + W, S.value - M.value));
    }), T = () => {
      const { total: W } = u;
      if (W > 0) {
        const [ee, pe, be, fe] = O(x);
        h(lk, ee, pe, be, fe);
      }
      const { scrollDir: U, scrollOffset: ae, updateRequested: he } = O(w);
      h(ck, U, ae, he);
    }, B = (W) => {
      const { clientHeight: U, scrollHeight: ae, scrollTop: he } = W.currentTarget, ee = O(w);
      if (ee.scrollOffset === he)
        return;
      const pe = Math.max(0, Math.min(he, ae - U));
      w.value = {
        ...ee,
        isScrolling: !0,
        scrollDir: M0(ee.scrollOffset, pe),
        scrollOffset: pe,
        updateRequested: !1
      }, $e(H);
    }, I = (W) => {
      const { clientWidth: U, scrollLeft: ae, scrollWidth: he } = W.currentTarget, ee = O(w);
      if (ee.scrollOffset === ae)
        return;
      const { direction: pe } = u;
      let be = ae;
      if (pe === fg)
        switch (uk()) {
          case Py: {
            be = -ae;
            break;
          }
          case R_: {
            be = he - U - ae;
            break;
          }
        }
      be = Math.max(0, Math.min(be, he - U)), w.value = {
        ...ee,
        isScrolling: !0,
        scrollDir: M0(ee.scrollOffset, be),
        scrollOffset: be,
        updateRequested: !1
      }, $e(H);
    }, P = (W) => {
      O(C) ? I(W) : B(W), T();
    }, A = (W, U) => {
      const ae = (S.value - M.value) / U * W;
      N(Math.min(S.value - M.value, ae));
    }, N = (W) => {
      W = Math.max(W, 0), W !== O(w).scrollOffset && (w.value = {
        ...O(w),
        scrollOffset: W,
        scrollDir: M0(O(w).scrollOffset, W),
        updateRequested: !0
      }, $e(H));
    }, q = (W, U = Bd) => {
      const { scrollOffset: ae } = O(w);
      W = Math.max(0, Math.min(W, u.total - 1)), N(e(u, W, U, ae, O(g)));
    }, j = (W) => {
      const { direction: U, itemSize: ae, layout: he } = u, ee = m.value(l && ae, l && he, l && U);
      let pe;
      if (Xi(ee, String(W)))
        pe = ee[W];
      else {
        const be = i(u, W, O(g)), fe = t(u, W, O(g)), Ae = O(C), ut = U === fg, zt = Ae ? be : 0;
        ee[W] = pe = {
          position: "absolute",
          left: ut ? void 0 : `${zt}px`,
          right: ut ? `${zt}px` : void 0,
          top: Ae ? 0 : `${be}px`,
          height: Ae ? "100%" : `${fe}px`,
          width: Ae ? `${fe}px` : "100%"
        };
      }
      return pe;
    }, H = () => {
      w.value.isScrolling = !1, $e(() => {
        m.value(-1, null, null);
      });
    }, oe = () => {
      const W = v.value;
      W && (W.scrollTop = 0);
    };
    qe(() => {
      if (!vt)
        return;
      const { initScrollOffset: W } = u, U = O(v);
      tt(W) && U && (O(C) ? U.scrollLeft = W : U.scrollTop = W), T();
    }), Ya(() => {
      const { direction: W, layout: U } = u, { scrollOffset: ae, updateRequested: he } = O(w), ee = O(v);
      if (he && ee)
        if (U === wu)
          if (W === fg)
            switch (uk()) {
              case Py: {
                ee.scrollLeft = -ae;
                break;
              }
              case M_: {
                ee.scrollLeft = ae;
                break;
              }
              default: {
                const { clientWidth: pe, scrollWidth: be } = ee;
                ee.scrollLeft = be - pe - ae;
                break;
              }
            }
          else
            ee.scrollLeft = ae;
        else
          ee.scrollTop = ae;
    });
    const te = {
      ns: p,
      clientSize: M,
      estimatedTotalSize: S,
      windowStyle: k,
      windowRef: v,
      innerRef: y,
      innerStyle: E,
      itemsToRender: x,
      scrollbarRef: b,
      states: w,
      getItemStyle: j,
      onScroll: P,
      onScrollbarScroll: A,
      onWheel: _,
      scrollTo: N,
      scrollToItem: q,
      resetScrollTop: oe
    };
    return d({
      windowRef: v,
      innerRef: y,
      getItemStyleCache: m,
      scrollTo: N,
      scrollToItem: q,
      resetScrollTop: oe,
      states: w
    }), te;
  },
  render(u) {
    var h;
    const {
      $slots: d,
      className: f,
      clientSize: p,
      containerElement: g,
      data: m,
      getItemStyle: v,
      innerElement: y,
      itemsToRender: b,
      innerStyle: w,
      layout: x,
      total: S,
      onScroll: C,
      onScrollbarScroll: k,
      onWheel: E,
      states: M,
      useIsScrolling: _,
      windowStyle: T,
      ns: B
    } = u, [I, P] = b, A = yt(g), N = yt(y), q = [];
    if (S > 0)
      for (let te = I; te <= P; te++)
        q.push((h = d.default) == null ? void 0 : h.call(d, {
          data: m,
          key: te,
          index: te,
          isScrolling: _ ? M.isScrolling : void 0,
          style: v(te)
        }));
    const j = [
      Re(N, {
        style: w,
        ref: "innerRef"
      }, bt(N) ? q : {
        default: () => q
      })
    ], H = Re(eG, {
      ref: "scrollbarRef",
      clientSize: p,
      layout: x,
      onScroll: k,
      ratio: p * 100 / this.estimatedTotalSize,
      scrollFrom: M.scrollOffset / (this.estimatedTotalSize - p),
      total: S
    }), oe = Re(A, {
      class: [B.e("window"), f],
      style: T,
      onScroll: C,
      onWheel: E,
      ref: "windowRef",
      key: 0
    }, bt(A) ? [j] : { default: () => [j] });
    return Re("div", {
      key: 0,
      class: [B.e("wrapper"), M.scrollbarAlwaysOn ? "always-on" : ""]
    }, [oe, H]);
  }
}), tG = B_({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize: n }, e) => e * n,
  getItemSize: ({ itemSize: n }) => n,
  getEstimatedTotalSize: ({ total: n, itemSize: e }) => e * n,
  getOffset: ({ height: n, total: e, itemSize: t, layout: i, width: r }, s, o, a) => {
    const l = Qd(i) ? r : n;
    process.env.NODE_ENV !== "production" && bt(l) && dr("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
    const c = Math.max(0, e * t - l), u = Math.min(c, s * t), h = Math.max(0, (s + 1) * t - l);
    switch (o === $_ && (a >= h - l && a <= u + l ? o = Bd : o = em), o) {
      case T_:
        return u;
      case __:
        return h;
      case em: {
        const d = Math.round(h + (u - h) / 2);
        return d < Math.ceil(l / 2) ? 0 : d > c + Math.floor(l / 2) ? c : d;
      }
      case Bd:
      default:
        return a >= h && a <= u ? a : a < h ? h : u;
    }
  },
  getStartIndexForOffset: ({ total: n, itemSize: e }, t) => Math.max(0, Math.min(n - 1, Math.floor(t / e))),
  getStopIndexForStartIndex: ({ height: n, total: e, itemSize: t, layout: i, width: r }, s, o) => {
    const a = s * t, l = Qd(i) ? r : n, c = Math.ceil((l + o - a) / t);
    return Math.max(0, Math.min(e - 1, s + c - 1));
  },
  initCache() {
  },
  clearCache: !0,
  validateProps() {
  }
}), nG = "ElDynamicSizeList", Lc = (n, e, t) => {
  const { itemSize: i } = n, { items: r, lastVisitedIndex: s } = t;
  if (e > s) {
    let o = 0;
    if (s >= 0) {
      const a = r[s];
      o = a.offset + a.size;
    }
    for (let a = s + 1; a <= e; a++) {
      const l = i(a);
      r[a] = {
        offset: o,
        size: l
      }, o += l;
    }
    t.lastVisitedIndex = e;
  }
  return r[e];
}, iG = (n, e, t) => {
  const { items: i, lastVisitedIndex: r } = e;
  return (r > 0 ? i[r].offset : 0) >= t ? Q_(n, e, 0, r, t) : rG(n, e, Math.max(0, r), t);
}, Q_ = (n, e, t, i, r) => {
  for (; t <= i; ) {
    const s = t + Math.floor((i - t) / 2), o = Lc(n, s, e).offset;
    if (o === r)
      return s;
    o < r ? t = s + 1 : o > r && (i = s - 1);
  }
  return Math.max(0, t - 1);
}, rG = (n, e, t, i) => {
  const { total: r } = n;
  let s = 1;
  for (; t < r && Lc(n, t, e).offset < i; )
    t += s, s *= 2;
  return Q_(n, e, Math.floor(t / 2), Math.min(t, r - 1), i);
}, hk = ({ total: n }, { items: e, estimatedItemSize: t, lastVisitedIndex: i }) => {
  let r = 0;
  if (i >= n && (i = n - 1), i >= 0) {
    const a = e[i];
    r = a.offset + a.size;
  }
  const o = (n - i - 1) * t;
  return r + o;
}, sG = B_({
  name: "ElDynamicSizeList",
  getItemOffset: (n, e, t) => Lc(n, e, t).offset,
  getItemSize: (n, e, { items: t }) => t[e].size,
  getEstimatedTotalSize: hk,
  getOffset: (n, e, t, i, r) => {
    const { height: s, layout: o, width: a } = n, l = Qd(o) ? a : s, c = Lc(n, e, r), u = hk(n, r), h = Math.max(0, Math.min(u - l, c.offset)), d = Math.max(0, c.offset - l + c.size);
    switch (t === $_ && (i >= d - l && i <= h + l ? t = Bd : t = em), t) {
      case T_:
        return h;
      case __:
        return d;
      case em:
        return Math.round(d + (h - d) / 2);
      case Bd:
      default:
        return i >= d && i <= h ? i : i < d ? d : h;
    }
  },
  getStartIndexForOffset: (n, e, t) => iG(n, t, e),
  getStopIndexForStartIndex: (n, e, t, i) => {
    const { height: r, total: s, layout: o, width: a } = n, l = Qd(o) ? a : r, c = Lc(n, e, i), u = t + l;
    let h = c.offset + c.size, d = e;
    for (; d < s - 1 && h < u; )
      d++, h += Lc(n, d, i).size;
    return d;
  },
  initCache({ estimatedItemSize: n = ZU }, e) {
    const t = {
      items: {},
      estimatedItemSize: n,
      lastVisitedIndex: -1
    };
    return t.clearCacheAfterIndex = (i, r = !0) => {
      var s, o;
      t.lastVisitedIndex = Math.min(t.lastVisitedIndex, i - 1), (s = e.exposed) == null || s.getItemStyleCache(-1), r && ((o = e.proxy) == null || o.$forceUpdate());
    }, t;
  },
  clearCache: !1,
  validateProps: ({ itemSize: n }) => {
    process.env.NODE_ENV !== "production" && typeof n != "function" && dr(nG, `
          itemSize is required as function, but the given value was ${typeof n}
        `);
  }
}), oG = F({
  props: {
    item: {
      type: Object,
      required: !0
    },
    style: Object,
    height: Number
  },
  setup() {
    return {
      ns: me("select")
    };
  }
});
function aG(n, e, t, i, r, s) {
  return n.item.isTitle ? (R(), V("div", {
    key: 0,
    class: L(n.ns.be("group", "title")),
    style: Qe([n.style, { lineHeight: `${n.height}px` }])
  }, xe(n.item.label), 7)) : (R(), V("div", {
    key: 1,
    class: L(n.ns.be("group", "split")),
    style: Qe(n.style)
  }, [
    Z("span", {
      class: L(n.ns.be("group", "split-dash")),
      style: Qe({ top: `${n.height / 2}px` })
    }, null, 6)
  ], 6));
}
var lG = /* @__PURE__ */ Ce(oG, [["render", aG], ["__file", "group-item.vue"]]);
function cG(n, { emit: e }) {
  return {
    hoverItem: () => {
      n.disabled || e("hover", n.index);
    },
    selectOptionClick: () => {
      n.disabled || e("select", n.item, n.index);
    }
  };
}
const z_ = {
  label: "label",
  value: "value",
  disabled: "disabled",
  options: "options"
};
function xv(n) {
  const e = $(() => ({ ...z_, ...n.props }));
  return {
    aliasProps: e,
    getLabel: (o) => on(o, e.value.label),
    getValue: (o) => on(o, e.value.value),
    getDisabled: (o) => on(o, e.value.disabled),
    getOptions: (o) => on(o, e.value.options)
  };
}
const uG = Ee({
  allowCreate: Boolean,
  autocomplete: {
    type: ce(String),
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: Pn,
    default: ah
  },
  effect: {
    type: ce(String),
    default: "light"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 274
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  modelValue: {
    type: ce([Array, String, Number, Boolean, Object])
  },
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  options: {
    type: ce(Array),
    required: !0
  },
  placeholder: {
    type: String
  },
  teleported: mi.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: ce(Object),
    default: () => ({})
  },
  remote: Boolean,
  size: _r,
  props: {
    type: ce(Object),
    default: () => z_
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: Boolean,
  validateEvent: {
    type: Boolean,
    default: !0
  },
  placement: {
    type: ce(String),
    values: $f,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ce(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  tagType: { ...Ov.type, default: "info" },
  ariaLabel: {
    type: String,
    default: void 0
  }
}), hG = Ee({
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: {
    type: ce(Object),
    required: !0
  },
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
}), Ew = Symbol("ElSelectV2Injection"), dG = F({
  props: hG,
  emits: ["select", "hover"],
  setup(n, { emit: e }) {
    const t = ke(Ew), i = me("select"), { hoverItem: r, selectOptionClick: s } = cG(n, { emit: e }), { getLabel: o } = xv(t.props);
    return {
      ns: i,
      hoverItem: r,
      selectOptionClick: s,
      getLabel: o
    };
  }
}), fG = ["aria-selected"];
function pG(n, e, t, i, r, s) {
  return R(), V("li", {
    "aria-selected": n.selected,
    style: Qe(n.style),
    class: L([
      n.ns.be("dropdown", "item"),
      n.ns.is("selected", n.selected),
      n.ns.is("disabled", n.disabled),
      n.ns.is("created", n.created),
      n.ns.is("hovering", n.hovering)
    ]),
    onMouseenter: e[0] || (e[0] = (...o) => n.hoverItem && n.hoverItem(...o)),
    onClick: e[1] || (e[1] = Le((...o) => n.selectOptionClick && n.selectOptionClick(...o), ["stop"]))
  }, [
    de(n.$slots, "default", {
      item: n.item,
      index: n.index,
      disabled: n.disabled
    }, () => [
      Z("span", null, xe(n.getLabel(n.item)), 1)
    ])
  ], 46, fG);
}
var gG = /* @__PURE__ */ Ce(dG, [["render", pG], ["__file", "option-item.vue"]]), mG = F({
  name: "ElSelectDropdown",
  props: {
    loading: Boolean,
    data: {
      type: Array,
      required: !0
    },
    hoveringIndex: Number,
    width: Number
  },
  setup(n, {
    slots: e,
    expose: t
  }) {
    const i = ke(Ew), r = me("select"), {
      getLabel: s,
      getValue: o,
      getDisabled: a
    } = xv(i.props), l = D([]), c = D(), u = $(() => n.data.length);
    ne(() => u.value, () => {
      var _, T;
      (T = (_ = i.tooltipRef.value).updatePopper) == null || T.call(_);
    });
    const h = $(() => Ci(i.props.estimatedOptionHeight)), d = $(() => h.value ? {
      itemSize: i.props.itemHeight
    } : {
      estimatedSize: i.props.estimatedOptionHeight,
      itemSize: (_) => l.value[_]
    }), f = (_ = [], T) => {
      const {
        props: {
          valueKey: B
        }
      } = i;
      return an(T) ? _ && _.some((I) => Ed(on(I, B)) === on(T, B)) : _.includes(T);
    }, p = (_, T) => {
      if (an(T)) {
        const {
          valueKey: B
        } = i.props;
        return on(_, B) === on(T, B);
      } else
        return _ === T;
    }, g = (_, T) => i.props.multiple ? f(_, o(T)) : p(_, o(T)), m = (_, T) => {
      const {
        disabled: B,
        multiple: I,
        multipleLimit: P
      } = i.props;
      return B || !T && (I ? P > 0 && _.length >= P : !1);
    }, v = (_) => n.hoveringIndex === _;
    t({
      listRef: c,
      isSized: h,
      isItemDisabled: m,
      isItemHovering: v,
      isItemSelected: g,
      scrollToItem: (_) => {
        const T = c.value;
        T && T.scrollToItem(_);
      },
      resetScrollTop: () => {
        const _ = c.value;
        _ && _.resetScrollTop();
      }
    });
    const w = (_) => {
      const {
        index: T,
        data: B,
        style: I
      } = _, P = O(h), {
        itemSize: A,
        estimatedSize: N
      } = O(d), {
        modelValue: q
      } = i.props, {
        onSelect: j,
        onHover: H
      } = i, oe = B[T];
      if (oe.type === "Group")
        return K(lG, {
          item: oe,
          style: I,
          height: P ? A : N
        }, null);
      const te = g(q, oe), W = m(q, te), U = v(T);
      return K(gG, Pi(_, {
        selected: te,
        disabled: a(oe) || W,
        created: !!oe.created,
        hovering: U,
        item: oe,
        onSelect: j,
        onHover: H
      }), {
        default: (ae) => {
          var he;
          return ((he = e.default) == null ? void 0 : he.call(e, ae)) || K("span", null, [s(oe)]);
        }
      });
    }, {
      onKeyboardNavigate: x,
      onKeyboardSelect: S
    } = i, C = () => {
      x("forward");
    }, k = () => {
      x("backward");
    }, E = () => {
      i.expanded = !1;
    }, M = (_) => {
      const {
        code: T
      } = _, {
        tab: B,
        esc: I,
        down: P,
        up: A,
        enter: N
      } = dt;
      switch (T !== B && (_.preventDefault(), _.stopPropagation()), T) {
        case B:
        case I: {
          E();
          break;
        }
        case P: {
          C();
          break;
        }
        case A: {
          k();
          break;
        }
        case N: {
          S();
          break;
        }
      }
    };
    return () => {
      var _, T, B, I;
      const {
        data: P,
        width: A
      } = n, {
        height: N,
        multiple: q,
        scrollbarAlwaysOn: j
      } = i.props;
      if (e.loading || e.empty)
        return K("div", {
          class: r.b("dropdown"),
          style: {
            width: `${A}px`
          }
        }, [((_ = e.loading) == null ? void 0 : _.call(e)) || ((T = e.empty) == null ? void 0 : T.call(e))]);
      const H = O(h) ? tG : sG;
      return K("div", {
        class: [r.b("dropdown"), r.is("multiple", q)]
      }, [(B = e.header) == null ? void 0 : B.call(e), K(H, Pi({
        ref: c
      }, O(d), {
        className: r.be("dropdown", "list"),
        scrollbarAlwaysOn: j,
        data: P,
        height: N,
        width: A,
        total: P.length,
        onKeydown: M
      }), {
        default: (oe) => K(w, oe, null)
      }), (I = e.footer) == null ? void 0 : I.call(e)]);
    };
  }
});
function vG(n, e) {
  const { aliasProps: t, getLabel: i, getValue: r } = xv(n), s = D(0), o = D(null), a = $(() => n.allowCreate && n.filterable);
  function l(f) {
    const p = (g) => r(g) === f;
    return n.options && n.options.some(p) || e.createdOptions.some(p);
  }
  function c(f) {
    a.value && (n.multiple && f.created ? s.value++ : o.value = f);
  }
  function u(f) {
    if (a.value)
      if (f && f.length > 0) {
        if (l(f))
          return;
        const p = {
          [t.value.value]: f,
          [t.value.label]: f,
          created: !0,
          [t.value.disabled]: !1
        };
        e.createdOptions.length >= s.value ? e.createdOptions[s.value] = p : e.createdOptions.push(p);
      } else if (n.multiple)
        e.createdOptions.length = s.value;
      else {
        const p = o.value;
        e.createdOptions.length = 0, p && p.created && e.createdOptions.push(p);
      }
  }
  function h(f) {
    if (!a.value || !f || !f.created || f.created && n.reserveKeyword && e.inputValue === i(f))
      return;
    const p = e.createdOptions.findIndex((g) => r(g) === r(f));
    ~p && (e.createdOptions.splice(p, 1), s.value--);
  }
  function d() {
    a.value && (e.createdOptions.length = 0, s.value = 0);
  }
  return {
    createNewOption: u,
    removeNewOption: h,
    selectNewOption: c,
    clearAllNewOption: d
  };
}
const bG = 11, yG = (n, e) => {
  const { t } = mn(), i = me("select"), r = me("input"), { form: s, formItem: o } = Mr(), { inputId: a } = Ka(n, {
    formItemContext: o
  }), { getLabel: l, getValue: c, getDisabled: u, getOptions: h } = xv(n), d = Gt({
    inputValue: "",
    cachedOptions: [],
    createdOptions: [],
    hoveringIndex: -1,
    inputHovering: !1,
    selectionWidth: 0,
    calculatorWidth: 0,
    collapseItemWidth: 0,
    previousQuery: null,
    previousValue: void 0,
    selectedLabel: "",
    menuVisibleOnFocus: !1,
    isBeforeHide: !1
  }), f = D(-1), p = D(-1), g = D(null), m = D(null), v = D(null), y = D(null), b = D(null), w = D(null), x = D(null), S = D(null), C = D(null), k = D(null), E = D(null), { wrapperRef: M, isFocused: _, handleFocus: T, handleBlur: B } = mv(b, {
    afterFocus() {
      n.automaticDropdown && !A.value && (A.value = !0, d.menuVisibleOnFocus = !0);
    },
    beforeBlur(se) {
      var De, We;
      return ((De = v.value) == null ? void 0 : De.isFocusInsideContent(se)) || ((We = y.value) == null ? void 0 : We.isFocusInsideContent(se));
    },
    afterBlur() {
      A.value = !1, d.menuVisibleOnFocus = !1;
    }
  }), I = D([]), P = D([]), A = D(!1), N = $(() => n.disabled || (s == null ? void 0 : s.disabled)), q = $(() => {
    const se = P.value.length * n.itemHeight;
    return se > n.height ? n.height : se;
  }), j = $(() => n.multiple ? xt(n.modelValue) && n.modelValue.length > 0 : n.modelValue !== void 0 && n.modelValue !== null && n.modelValue !== ""), H = $(() => n.clearable && !N.value && d.inputHovering && j.value), oe = $(() => n.remote && n.filterable ? "" : oh), te = $(() => oe.value && i.is("reverse", A.value)), W = $(() => (o == null ? void 0 : o.validateState) || ""), U = $(() => tw[W.value]), ae = $(() => n.remote ? 300 : 0), he = $(() => n.loading ? n.loadingText || t("el.select.loading") : n.remote && !d.inputValue && I.value.length === 0 ? !1 : n.filterable && d.inputValue && I.value.length > 0 && P.value.length === 0 ? n.noMatchText || t("el.select.noMatch") : I.value.length === 0 ? n.noDataText || t("el.select.noData") : null), ee = (se) => {
    const De = (We) => {
      if (n.filterable && wt(n.filterMethod) || n.filterable && n.remote && wt(n.remoteMethod))
        return !0;
      const at = new RegExp(K$(se), "i");
      return se ? at.test(l(We) || "") : !0;
    };
    return n.loading ? [] : [...d.createdOptions, ...n.options].reduce((We, at) => {
      const Ls = h(at);
      if (xt(Ls)) {
        const ko = Ls.filter(De);
        ko.length > 0 && We.push({
          label: l(at),
          isTitle: !0,
          type: "Group"
        }, ...ko, { type: "Group" });
      } else
        (n.remote || De(at)) && We.push(at);
      return We;
    }, []);
  }, pe = () => {
    I.value = ee(""), P.value = ee(d.inputValue);
  }, be = $(() => {
    const se = /* @__PURE__ */ new Map();
    return P.value.forEach((De, We) => {
      se.set(Rr(c(De)), { option: De, index: We });
    }), se;
  }), fe = $(() => P.value.every((se) => u(se))), Ae = Yi(), ut = $(() => Ae.value === "small" ? "small" : "default"), zt = () => {
    var se;
    p.value = ((se = g.value) == null ? void 0 : se.offsetWidth) || 200;
  }, Jn = () => {
    if (!m.value)
      return 0;
    const se = window.getComputedStyle(m.value);
    return Number.parseFloat(se.gap || "6px");
  }, ei = $(() => {
    const se = Jn();
    return { maxWidth: `${E.value && n.maxCollapseTags === 1 ? d.selectionWidth - d.collapseItemWidth - se : d.selectionWidth}px` };
  }), Li = $(() => ({ maxWidth: `${d.selectionWidth}px` })), di = $(() => ({
    width: `${Math.max(d.calculatorWidth, bG)}px`
  })), Ii = $(() => xt(n.modelValue) ? n.modelValue.length === 0 && !d.inputValue : n.filterable ? !d.inputValue : !0), fr = $(() => {
    var se;
    const De = (se = n.placeholder) != null ? se : t("el.select.placeholder");
    return n.multiple || !j.value ? De : d.selectedLabel;
  }), un = $(() => {
    var se, De;
    return (De = (se = v.value) == null ? void 0 : se.popperRef) == null ? void 0 : De.contentRef;
  }), Bi = $(() => {
    if (n.multiple) {
      const se = n.modelValue.length;
      if (n.modelValue.length > 0 && be.value.has(n.modelValue[se - 1])) {
        const { index: De } = be.value.get(n.modelValue[se - 1]);
        return De;
      }
    } else if (n.modelValue && be.value.has(n.modelValue)) {
      const { index: se } = be.value.get(n.modelValue);
      return se;
    }
    return -1;
  }), Ui = $({
    get() {
      return A.value && he.value !== !1;
    },
    set(se) {
      A.value = se;
    }
  }), Qi = $(() => n.multiple ? n.collapseTags ? d.cachedOptions.slice(0, n.maxCollapseTags) : d.cachedOptions : []), ti = $(() => n.multiple ? n.collapseTags ? d.cachedOptions.slice(n.maxCollapseTags) : [] : []), {
    createNewOption: ge,
    removeNewOption: Ke,
    selectNewOption: Dt,
    clearAllNewOption: ni
  } = vG(n, d), {
    handleCompositionStart: Ns,
    handleCompositionUpdate: Te,
    handleCompositionEnd: je
  } = k_((se) => is(se)), J = () => {
    N.value || (d.menuVisibleOnFocus ? d.menuVisibleOnFocus = !1 : A.value = !A.value);
  }, le = () => {
    d.inputValue.length > 0 && !A.value && (A.value = !0), ge(d.inputValue), Ue(d.inputValue);
  }, ve = zo(le, ae.value), Ue = (se) => {
    d.previousQuery !== se && (d.previousQuery = se, n.filterable && wt(n.filterMethod) ? n.filterMethod(se) : n.filterable && n.remote && wt(n.remoteMethod) && n.remoteMethod(se), n.defaultFirstOption && (n.filterable || n.remote) && P.value.length ? $e(Zt) : $e(hn));
  }, Zt = () => {
    const se = P.value.filter((at) => !at.disabled && at.type !== "Group"), De = se.find((at) => at.created), We = se[0];
    d.hoveringIndex = Ds(P.value, De || We);
  }, Cn = (se) => {
    cn(n.modelValue, se) || e(Gn, se);
  }, jt = (se) => {
    e(ot, se), Cn(se), d.previousValue = String(se);
  }, Ds = (se = [], De) => {
    if (!an(De))
      return se.indexOf(De);
    const We = n.valueKey;
    let at = -1;
    return se.some((Ls, ko) => on(Ls, We) === on(De, We) ? (at = ko, !0) : !1), at;
  }, Rr = (se) => an(se) ? on(se, n.valueKey) : se, gc = () => {
    zt();
  }, Co = () => {
    d.selectionWidth = m.value.getBoundingClientRect().width;
  }, mc = () => {
    d.calculatorWidth = w.value.getBoundingClientRect().width;
  }, Gf = () => {
    d.collapseItemWidth = E.value.getBoundingClientRect().width;
  }, Ph = () => {
    var se, De;
    (De = (se = v.value) == null ? void 0 : se.updatePopper) == null || De.call(se);
  }, sa = () => {
    var se, De;
    (De = (se = y.value) == null ? void 0 : se.updatePopper) == null || De.call(se);
  }, Kf = (se, De) => {
    if (n.multiple) {
      let We = n.modelValue.slice();
      const at = Ds(We, c(se));
      at > -1 ? (We = [
        ...We.slice(0, at),
        ...We.slice(at + 1)
      ], d.cachedOptions.splice(at, 1), Ke(se)) : (n.multipleLimit <= 0 || We.length < n.multipleLimit) && (We = [...We, c(se)], d.cachedOptions.push(se), Dt(se)), jt(We), se.created && Ue(""), n.filterable && !n.reserveKeyword && (d.inputValue = "");
    } else
      f.value = De, d.selectedLabel = l(se), jt(c(se)), A.value = !1, Dt(se), se.created || ni();
    vc();
  }, u0 = (se, De) => {
    let We = n.modelValue.slice();
    const at = Ds(We, c(De));
    at > -1 && !N.value && (We = [
      ...n.modelValue.slice(0, at),
      ...n.modelValue.slice(at + 1)
    ], d.cachedOptions.splice(at, 1), jt(We), e("remove-tag", c(De)), Ke(De)), se.stopPropagation(), vc();
  }, vc = () => {
    var se;
    (se = b.value) == null || se.focus();
  }, Jf = () => {
    var se;
    (se = b.value) == null || se.blur();
  }, h0 = () => {
    d.inputValue.length > 0 ? d.inputValue = "" : A.value = !1;
  }, d0 = (se) => A$(se, (De) => !d.cachedOptions.some((We) => c(We) === De && u(We))), f0 = (se) => {
    if (n.multiple && se.code !== dt.delete && d.inputValue.length === 0) {
      se.preventDefault();
      const De = n.modelValue.slice(), We = d0(De);
      if (We < 0)
        return;
      De.splice(We, 1);
      const at = d.cachedOptions[We];
      d.cachedOptions.splice(We, 1), Ke(at), jt(De);
    }
  }, p0 = () => {
    let se;
    xt(n.modelValue) ? se = [] : se = void 0, n.multiple ? d.cachedOptions = [] : d.selectedLabel = "", A.value = !1, jt(se), e("clear"), ni(), vc();
  }, re = (se, De = void 0) => {
    const We = P.value;
    if (!["forward", "backward"].includes(se) || N.value || We.length <= 0 || fe.value)
      return;
    if (!A.value)
      return J();
    De === void 0 && (De = d.hoveringIndex);
    let at = -1;
    se === "forward" ? (at = De + 1, at >= We.length && (at = 0)) : se === "backward" && (at = De - 1, (at < 0 || at >= We.length) && (at = We.length - 1));
    const Ls = We[at];
    if (u(Ls) || Ls.type === "Group")
      return re(se, at);
    d.hoveringIndex = at, rs(at);
  }, we = () => {
    if (A.value)
      ~d.hoveringIndex && P.value[d.hoveringIndex] && Kf(P.value[d.hoveringIndex], d.hoveringIndex);
    else
      return J();
  }, _t = (se) => {
    d.hoveringIndex = se;
  }, hn = () => {
    n.multiple ? n.modelValue.length > 0 ? d.hoveringIndex = Math.min(...n.modelValue.map((se) => P.value.findIndex((De) => c(De) === se))) : d.hoveringIndex = -1 : d.hoveringIndex = P.value.findIndex((se) => Rr(se) === Rr(n.modelValue));
  }, is = (se) => {
    if (d.inputValue = se.target.value, n.remote)
      ve();
    else
      return le();
  }, oa = (se) => {
    if (A.value = !1, _.value) {
      const De = new FocusEvent("focus", se);
      B(De);
    }
  }, bc = () => $e(() => {
    ~Bi.value && rs(d.hoveringIndex);
  }), rs = (se) => {
    C.value.scrollToItem(se);
  }, Nr = (se) => {
    const De = Rr(se);
    if (be.value.has(De)) {
      const { option: We } = be.value.get(De);
      return We;
    }
    return {
      value: se,
      label: se
    };
  }, yc = () => {
    if (n.multiple)
      if (n.modelValue.length > 0) {
        d.cachedOptions.length = 0, d.previousValue = n.modelValue.toString();
        for (const se of n.modelValue) {
          const De = Nr(se);
          d.cachedOptions.push(De);
        }
      } else
        d.cachedOptions = [], d.previousValue = void 0;
    else if (j.value) {
      d.previousValue = n.modelValue;
      const se = P.value, De = se.findIndex((We) => Rr(c(We)) === Rr(n.modelValue));
      ~De ? d.selectedLabel = l(se[De]) : d.selectedLabel = Rr(n.modelValue);
    } else
      d.selectedLabel = "", d.previousValue = void 0;
    ni(), zt();
  };
  return ne(A, (se) => {
    se ? Ue("") : (d.inputValue = "", d.previousQuery = null, d.isBeforeHide = !0, ge("")), e("visible-change", se);
  }), ne(() => n.modelValue, (se, De) => {
    var We;
    (!se || se.toString() !== d.previousValue) && yc(), !cn(se, De) && n.validateEvent && ((We = o == null ? void 0 : o.validate) == null || We.call(o, "change").catch((at) => pt(at)));
  }, {
    deep: !0
  }), ne(() => n.options, () => {
    const se = b.value;
    (!se || se && document.activeElement !== se) && yc();
  }, {
    deep: !0,
    flush: "post"
  }), ne(() => P.value, () => C.value && $e(C.value.resetScrollTop)), Fr(() => {
    d.isBeforeHide || pe();
  }), Fr(() => {
    const { valueKey: se, options: De } = n, We = /* @__PURE__ */ new Map();
    for (const at of De) {
      const Ls = c(at);
      let ko = Ls;
      if (an(ko) && (ko = on(Ls, se)), We.get(ko)) {
        pt("ElSelectV2", "The option values you provided seem to be duplicated, which may cause some problems, please check.");
        break;
      } else
        We.set(ko, !0);
    }
  }), qe(() => {
    yc();
  }), pn(g, gc), pn(m, Co), pn(w, mc), pn(C, Ph), pn(M, Ph), pn(k, sa), pn(E, Gf), {
    inputId: a,
    collapseTagSize: ut,
    currentPlaceholder: fr,
    expanded: A,
    emptyText: he,
    popupHeight: q,
    debounce: ae,
    allOptions: I,
    filteredOptions: P,
    iconComponent: oe,
    iconReverse: te,
    tagStyle: ei,
    collapseTagStyle: Li,
    inputStyle: di,
    popperSize: p,
    dropdownMenuVisible: Ui,
    hasModelValue: j,
    shouldShowPlaceholder: Ii,
    selectDisabled: N,
    selectSize: Ae,
    showClearBtn: H,
    states: d,
    isFocused: _,
    nsSelect: i,
    nsInput: r,
    calculatorRef: w,
    inputRef: b,
    menuRef: C,
    tagMenuRef: k,
    tooltipRef: v,
    tagTooltipRef: y,
    selectRef: g,
    wrapperRef: M,
    selectionRef: m,
    prefixRef: x,
    suffixRef: S,
    collapseItemRef: E,
    popperRef: un,
    validateState: W,
    validateIcon: U,
    showTagList: Qi,
    collapseTagList: ti,
    debouncedOnInputChange: ve,
    deleteTag: u0,
    getLabel: l,
    getValue: c,
    getDisabled: u,
    getValueKey: Rr,
    handleBlur: B,
    handleClear: p0,
    handleClickOutside: oa,
    handleDel: f0,
    handleEsc: h0,
    handleFocus: T,
    focus: vc,
    blur: Jf,
    handleMenuEnter: bc,
    handleResize: gc,
    resetSelectionWidth: Co,
    resetCalculatorWidth: mc,
    updateTooltip: Ph,
    updateTagTooltip: sa,
    updateOptions: pe,
    toggleMenu: J,
    scrollTo: rs,
    onInput: is,
    onKeyboardNavigate: re,
    onKeyboardSelect: we,
    onSelect: Kf,
    onHover: _t,
    handleCompositionStart: Ns,
    handleCompositionEnd: je,
    handleCompositionUpdate: Te
  };
}, OG = F({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: mG,
    ElTag: Jg,
    ElTooltip: Fo,
    ElIcon: Fe
  },
  directives: { ClickOutside: Rf },
  props: uG,
  emits: [
    ot,
    Gn,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(n, { emit: e }) {
    const t = $(() => {
      const { modelValue: r, multiple: s } = n, o = s ? [] : void 0;
      return xt(r) ? s ? r : o : s ? o : r;
    }), i = yG(Gt({
      ...Hr(n),
      modelValue: t
    }), e);
    return ft(Ew, {
      props: Gt({
        ...Hr(n),
        height: i.popupHeight,
        modelValue: t
      }),
      tooltipRef: i.tooltipRef,
      onSelect: i.onSelect,
      onHover: i.onHover,
      onKeyboardNavigate: i.onKeyboardNavigate,
      onKeyboardSelect: i.onKeyboardSelect
    }), {
      ...i,
      modelValue: t
    };
  }
}), wG = ["id", "autocomplete", "aria-expanded", "aria-label", "disabled", "readonly", "name"], xG = ["textContent"];
function SG(n, e, t, i, r, s) {
  const o = nt("el-tag"), a = nt("el-tooltip"), l = nt("el-icon"), c = nt("el-select-menu"), u = nv("click-outside");
  return it((R(), V("div", {
    ref: "selectRef",
    class: L([n.nsSelect.b(), n.nsSelect.m(n.selectSize)]),
    onMouseenter: e[14] || (e[14] = (h) => n.states.inputHovering = !0),
    onMouseleave: e[15] || (e[15] = (h) => n.states.inputHovering = !1),
    onClick: e[16] || (e[16] = Le((...h) => n.toggleMenu && n.toggleMenu(...h), ["stop"]))
  }, [
    K(a, {
      ref: "tooltipRef",
      visible: n.dropdownMenuVisible,
      teleported: n.teleported,
      "popper-class": [n.nsSelect.e("popper"), n.popperClass],
      "gpu-acceleration": !1,
      "stop-popper-mouse-event": !1,
      "popper-options": n.popperOptions,
      "fallback-placements": n.fallbackPlacements,
      effect: n.effect,
      placement: n.placement,
      pure: "",
      transition: `${n.nsSelect.namespace.value}-zoom-in-top`,
      trigger: "click",
      persistent: n.persistent,
      onBeforeShow: n.handleMenuEnter,
      onHide: e[13] || (e[13] = (h) => n.states.isBeforeHide = !1)
    }, {
      default: Y(() => [
        Z("div", {
          ref: "wrapperRef",
          class: L([
            n.nsSelect.e("wrapper"),
            n.nsSelect.is("focused", n.isFocused),
            n.nsSelect.is("hovering", n.states.inputHovering),
            n.nsSelect.is("filterable", n.filterable),
            n.nsSelect.is("disabled", n.selectDisabled)
          ])
        }, [
          n.$slots.prefix ? (R(), V("div", {
            key: 0,
            ref: "prefixRef",
            class: L(n.nsSelect.e("prefix"))
          }, [
            de(n.$slots, "prefix")
          ], 2)) : G("v-if", !0),
          Z("div", {
            ref: "selectionRef",
            class: L([
              n.nsSelect.e("selection"),
              n.nsSelect.is("near", n.multiple && !n.$slots.prefix && !!n.modelValue.length)
            ])
          }, [
            n.multiple ? de(n.$slots, "tag", { key: 0 }, () => [
              (R(!0), V(Tt, null, ai(n.showTagList, (h) => (R(), V("div", {
                key: n.getValueKey(n.getValue(h)),
                class: L(n.nsSelect.e("selected-item"))
              }, [
                K(o, {
                  closable: !n.selectDisabled && !n.getDisabled(h),
                  size: n.collapseTagSize,
                  type: n.tagType,
                  "disable-transitions": "",
                  style: Qe(n.tagStyle),
                  onClose: (d) => n.deleteTag(d, h)
                }, {
                  default: Y(() => [
                    Z("span", {
                      class: L(n.nsSelect.e("tags-text"))
                    }, xe(n.getLabel(h)), 3)
                  ]),
                  _: 2
                }, 1032, ["closable", "size", "type", "style", "onClose"])
              ], 2))), 128)),
              n.collapseTags && n.modelValue.length > n.maxCollapseTags ? (R(), ie(a, {
                key: 0,
                ref: "tagTooltipRef",
                disabled: n.dropdownMenuVisible || !n.collapseTagsTooltip,
                "fallback-placements": ["bottom", "top", "right", "left"],
                effect: n.effect,
                placement: "bottom",
                teleported: n.teleported
              }, {
                default: Y(() => [
                  Z("div", {
                    ref: "collapseItemRef",
                    class: L(n.nsSelect.e("selected-item"))
                  }, [
                    K(o, {
                      closable: !1,
                      size: n.collapseTagSize,
                      type: n.tagType,
                      style: Qe(n.collapseTagStyle),
                      "disable-transitions": ""
                    }, {
                      default: Y(() => [
                        Z("span", {
                          class: L(n.nsSelect.e("tags-text"))
                        }, " + " + xe(n.modelValue.length - n.maxCollapseTags), 3)
                      ]),
                      _: 1
                    }, 8, ["size", "type", "style"])
                  ], 2)
                ]),
                content: Y(() => [
                  Z("div", {
                    ref: "tagMenuRef",
                    class: L(n.nsSelect.e("selection"))
                  }, [
                    (R(!0), V(Tt, null, ai(n.collapseTagList, (h) => (R(), V("div", {
                      key: n.getValueKey(n.getValue(h)),
                      class: L(n.nsSelect.e("selected-item"))
                    }, [
                      K(o, {
                        class: "in-tooltip",
                        closable: !n.selectDisabled && !n.getDisabled(h),
                        size: n.collapseTagSize,
                        type: n.tagType,
                        "disable-transitions": "",
                        onClose: (d) => n.deleteTag(d, h)
                      }, {
                        default: Y(() => [
                          Z("span", {
                            class: L(n.nsSelect.e("tags-text"))
                          }, xe(n.getLabel(h)), 3)
                        ]),
                        _: 2
                      }, 1032, ["closable", "size", "type", "onClose"])
                    ], 2))), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["disabled", "effect", "teleported"])) : G("v-if", !0)
            ]) : G("v-if", !0),
            n.selectDisabled ? G("v-if", !0) : (R(), V("div", {
              key: 1,
              class: L([
                n.nsSelect.e("selected-item"),
                n.nsSelect.e("input-wrapper"),
                n.nsSelect.is("hidden", !n.filterable)
              ])
            }, [
              it(Z("input", {
                id: n.inputId,
                ref: "inputRef",
                "onUpdate:modelValue": e[0] || (e[0] = (h) => n.states.inputValue = h),
                style: Qe(n.inputStyle),
                autocomplete: n.autocomplete,
                "aria-autocomplete": "list",
                "aria-haspopup": "listbox",
                autocapitalize: "off",
                "aria-expanded": n.expanded,
                "aria-label": n.ariaLabel,
                class: L([n.nsSelect.e("input"), n.nsSelect.is(n.selectSize)]),
                disabled: n.selectDisabled,
                role: "combobox",
                readonly: !n.filterable,
                spellcheck: "false",
                type: "text",
                name: n.name,
                onFocus: e[1] || (e[1] = (...h) => n.handleFocus && n.handleFocus(...h)),
                onBlur: e[2] || (e[2] = (...h) => n.handleBlur && n.handleBlur(...h)),
                onInput: e[3] || (e[3] = (...h) => n.onInput && n.onInput(...h)),
                onCompositionstart: e[4] || (e[4] = (...h) => n.handleCompositionStart && n.handleCompositionStart(...h)),
                onCompositionupdate: e[5] || (e[5] = (...h) => n.handleCompositionUpdate && n.handleCompositionUpdate(...h)),
                onCompositionend: e[6] || (e[6] = (...h) => n.handleCompositionEnd && n.handleCompositionEnd(...h)),
                onKeydown: [
                  e[7] || (e[7] = Ut(Le((h) => n.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                  e[8] || (e[8] = Ut(Le((h) => n.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                  e[9] || (e[9] = Ut(Le((...h) => n.onKeyboardSelect && n.onKeyboardSelect(...h), ["stop", "prevent"]), ["enter"])),
                  e[10] || (e[10] = Ut(Le((...h) => n.handleEsc && n.handleEsc(...h), ["stop", "prevent"]), ["esc"])),
                  e[11] || (e[11] = Ut(Le((...h) => n.handleDel && n.handleDel(...h), ["stop"]), ["delete"]))
                ],
                onClick: e[12] || (e[12] = Le((...h) => n.toggleMenu && n.toggleMenu(...h), ["stop"]))
              }, null, 46, wG), [
                [L1, n.states.inputValue]
              ]),
              n.filterable ? (R(), V("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: L(n.nsSelect.e("input-calculator")),
                textContent: xe(n.states.inputValue)
              }, null, 10, xG)) : G("v-if", !0)
            ], 2)),
            n.shouldShowPlaceholder ? (R(), V("div", {
              key: 2,
              class: L([
                n.nsSelect.e("selected-item"),
                n.nsSelect.e("placeholder"),
                n.nsSelect.is("transparent", !n.hasModelValue || n.expanded && !n.states.inputValue)
              ])
            }, [
              Z("span", null, xe(n.currentPlaceholder), 1)
            ], 2)) : G("v-if", !0)
          ], 2),
          Z("div", {
            ref: "suffixRef",
            class: L(n.nsSelect.e("suffix"))
          }, [
            n.iconComponent ? it((R(), ie(l, {
              key: 0,
              class: L([n.nsSelect.e("caret"), n.nsInput.e("icon"), n.iconReverse])
            }, {
              default: Y(() => [
                (R(), ie(yt(n.iconComponent)))
              ]),
              _: 1
            }, 8, ["class"])), [
              [Qt, !n.showClearBtn]
            ]) : G("v-if", !0),
            n.showClearBtn && n.clearIcon ? (R(), ie(l, {
              key: 1,
              class: L([n.nsSelect.e("caret"), n.nsInput.e("icon")]),
              onClick: Le(n.handleClear, ["prevent", "stop"])
            }, {
              default: Y(() => [
                (R(), ie(yt(n.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : G("v-if", !0),
            n.validateState && n.validateIcon ? (R(), ie(l, {
              key: 2,
              class: L([n.nsInput.e("icon"), n.nsInput.e("validateIcon")])
            }, {
              default: Y(() => [
                (R(), ie(yt(n.validateIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : G("v-if", !0)
          ], 2)
        ], 2)
      ]),
      content: Y(() => [
        K(c, {
          ref: "menuRef",
          data: n.filteredOptions,
          width: n.popperSize,
          "hovering-index": n.states.hoveringIndex,
          "scrollbar-always-on": n.scrollbarAlwaysOn
        }, Fg({
          default: Y((h) => [
            de(n.$slots, "default", NL(DL(h)))
          ]),
          _: 2
        }, [
          n.$slots.header ? {
            name: "header",
            fn: Y(() => [
              Z("div", {
                class: L(n.nsSelect.be("dropdown", "header"))
              }, [
                de(n.$slots, "header")
              ], 2)
            ])
          } : void 0,
          n.$slots.loading && n.loading ? {
            name: "loading",
            fn: Y(() => [
              Z("div", {
                class: L(n.nsSelect.be("dropdown", "loading"))
              }, [
                de(n.$slots, "loading")
              ], 2)
            ])
          } : n.loading || n.filteredOptions.length === 0 ? {
            name: "empty",
            fn: Y(() => [
              Z("div", {
                class: L(n.nsSelect.be("dropdown", "empty"))
              }, [
                de(n.$slots, "empty", {}, () => [
                  Z("span", null, xe(n.emptyText), 1)
                ])
              ], 2)
            ])
          } : void 0,
          n.$slots.footer ? {
            name: "footer",
            fn: Y(() => [
              Z("div", {
                class: L(n.nsSelect.be("dropdown", "footer"))
              }, [
                de(n.$slots, "footer")
              ], 2)
            ])
          } : void 0
        ]), 1032, ["data", "width", "hovering-index", "scrollbar-always-on"])
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "placement", "transition", "persistent", "onBeforeShow"])
  ], 34)), [
    [u, n.handleClickOutside, n.popperRef]
  ]);
}
var pg = /* @__PURE__ */ Ce(OG, [["render", SG], ["__file", "select.vue"]]);
pg.install = (n) => {
  n.component(pg.name, pg);
};
const CG = pg, BKe = CG, kG = Ee({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  size: {
    type: String,
    validator: oT
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  inactiveActionIcon: {
    type: Pn
  },
  activeActionIcon: {
    type: Pn
  },
  activeIcon: {
    type: Pn
  },
  inactiveIcon: {
    type: Pn
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  beforeChange: {
    type: ce(Function)
  },
  id: String,
  tabindex: {
    type: [String, Number]
  },
  value: {
    type: [Boolean, String, Number],
    default: !1
  },
  label: {
    type: String,
    default: void 0
  }
}), PG = {
  [ot]: (n) => Ei(n) || bt(n) || tt(n),
  [Gn]: (n) => Ei(n) || bt(n) || tt(n),
  [Ll]: (n) => Ei(n) || bt(n) || tt(n)
}, EG = ["onClick"], AG = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], $G = ["aria-hidden"], TG = ["aria-hidden"], _G = ["aria-hidden"], gg = "ElSwitch", MG = F({
  name: gg
}), RG = /* @__PURE__ */ F({
  ...MG,
  props: kG,
  emits: PG,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = Xe(), { formItem: s } = Mr(), o = Yi(), a = me("switch");
    ((k) => {
      k.forEach((E) => {
        ql({
          from: E[0],
          replacement: E[1],
          scope: gg,
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/switch.html#attributes",
          type: "Attribute"
        }, $(() => {
          var M;
          return !!((M = r.vnode.props) != null && M[E[2]]);
        }));
      });
    })([
      ['"value"', '"model-value" or "v-model"', "value"],
      ['"active-color"', "CSS var `--el-switch-on-color`", "activeColor"],
      ['"inactive-color"', "CSS var `--el-switch-off-color`", "inactiveColor"],
      ['"border-color"', "CSS var `--el-switch-border-color`", "borderColor"]
    ]);
    const { inputId: c } = Ka(i, {
      formItemContext: s
    }), u = ts($(() => i.loading)), h = D(i.modelValue !== !1), d = D(), f = D(), p = $(() => [
      a.b(),
      a.m(o.value),
      a.is("disabled", u.value),
      a.is("checked", b.value)
    ]), g = $(() => [
      a.e("label"),
      a.em("label", "left"),
      a.is("active", !b.value)
    ]), m = $(() => [
      a.e("label"),
      a.em("label", "right"),
      a.is("active", b.value)
    ]), v = $(() => ({
      width: ur(i.width)
    }));
    ne(() => i.modelValue, () => {
      h.value = !0;
    }), ne(() => i.value, () => {
      h.value = !1;
    });
    const y = $(() => h.value ? i.modelValue : i.value), b = $(() => y.value === i.activeValue);
    [i.activeValue, i.inactiveValue].includes(y.value) || (t(ot, i.inactiveValue), t(Gn, i.inactiveValue), t(Ll, i.inactiveValue)), ne(b, (k) => {
      var E;
      d.value.checked = k, i.validateEvent && ((E = s == null ? void 0 : s.validate) == null || E.call(s, "change").catch((M) => pt(M)));
    });
    const w = () => {
      const k = b.value ? i.inactiveValue : i.activeValue;
      t(ot, k), t(Gn, k), t(Ll, k), $e(() => {
        d.value.checked = b.value;
      });
    }, x = () => {
      if (u.value)
        return;
      const { beforeChange: k } = i;
      if (!k) {
        w();
        return;
      }
      const E = k();
      [
        ry(E),
        Ei(E)
      ].includes(!0) || dr(gg, "beforeChange must return type `Promise<boolean>` or `boolean`"), ry(E) ? E.then((_) => {
        _ && w();
      }).catch((_) => {
        pt(gg, `some error occurred: ${_}`);
      }) : E && w();
    }, S = $(() => a.cssVarBlock({
      ...i.activeColor ? { "on-color": i.activeColor } : null,
      ...i.inactiveColor ? { "off-color": i.inactiveColor } : null,
      ...i.borderColor ? { "border-color": i.borderColor } : null
    })), C = () => {
      var k, E;
      (E = (k = d.value) == null ? void 0 : k.focus) == null || E.call(k);
    };
    return qe(() => {
      d.value.checked = b.value;
    }), e({
      focus: C,
      checked: b
    }), (k, E) => (R(), V("div", {
      class: L(O(p)),
      style: Qe(O(S)),
      onClick: Le(x, ["prevent"])
    }, [
      Z("input", {
        id: O(c),
        ref_key: "input",
        ref: d,
        class: L(O(a).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": O(b),
        "aria-disabled": O(u),
        "aria-label": k.label,
        name: k.name,
        "true-value": k.activeValue,
        "false-value": k.inactiveValue,
        disabled: O(u),
        tabindex: k.tabindex,
        onChange: w,
        onKeydown: Ut(x, ["enter"])
      }, null, 42, AG),
      !k.inlinePrompt && (k.inactiveIcon || k.inactiveText) ? (R(), V("span", {
        key: 0,
        class: L(O(g))
      }, [
        k.inactiveIcon ? (R(), ie(O(Fe), { key: 0 }, {
          default: Y(() => [
            (R(), ie(yt(k.inactiveIcon)))
          ]),
          _: 1
        })) : G("v-if", !0),
        !k.inactiveIcon && k.inactiveText ? (R(), V("span", {
          key: 1,
          "aria-hidden": O(b)
        }, xe(k.inactiveText), 9, $G)) : G("v-if", !0)
      ], 2)) : G("v-if", !0),
      Z("span", {
        ref_key: "core",
        ref: f,
        class: L(O(a).e("core")),
        style: Qe(O(v))
      }, [
        k.inlinePrompt ? (R(), V("div", {
          key: 0,
          class: L(O(a).e("inner"))
        }, [
          k.activeIcon || k.inactiveIcon ? (R(), ie(O(Fe), {
            key: 0,
            class: L(O(a).is("icon"))
          }, {
            default: Y(() => [
              (R(), ie(yt(O(b) ? k.activeIcon : k.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : k.activeText || k.inactiveText ? (R(), V("span", {
            key: 1,
            class: L(O(a).is("text")),
            "aria-hidden": !O(b)
          }, xe(O(b) ? k.activeText : k.inactiveText), 11, TG)) : G("v-if", !0)
        ], 2)) : G("v-if", !0),
        Z("div", {
          class: L(O(a).e("action"))
        }, [
          k.loading ? (R(), ie(O(Fe), {
            key: 0,
            class: L(O(a).is("loading"))
          }, {
            default: Y(() => [
              K(O(lc))
            ]),
            _: 1
          }, 8, ["class"])) : O(b) ? de(k.$slots, "active-action", { key: 1 }, () => [
            k.activeActionIcon ? (R(), ie(O(Fe), { key: 0 }, {
              default: Y(() => [
                (R(), ie(yt(k.activeActionIcon)))
              ]),
              _: 1
            })) : G("v-if", !0)
          ]) : O(b) ? G("v-if", !0) : de(k.$slots, "inactive-action", { key: 2 }, () => [
            k.inactiveActionIcon ? (R(), ie(O(Fe), { key: 0 }, {
              default: Y(() => [
                (R(), ie(yt(k.inactiveActionIcon)))
              ]),
              _: 1
            })) : G("v-if", !0)
          ])
        ], 2)
      ], 6),
      !k.inlinePrompt && (k.activeIcon || k.activeText) ? (R(), V("span", {
        key: 1,
        class: L(O(m))
      }, [
        k.activeIcon ? (R(), ie(O(Fe), { key: 0 }, {
          default: Y(() => [
            (R(), ie(yt(k.activeIcon)))
          ]),
          _: 1
        })) : G("v-if", !0),
        !k.activeIcon && k.activeText ? (R(), V("span", {
          key: 1,
          "aria-hidden": !O(b)
        }, xe(k.activeText), 9, _G)) : G("v-if", !0)
      ], 2)) : G("v-if", !0)
    ], 14, EG));
  }
});
var NG = /* @__PURE__ */ Ce(RG, [["__file", "switch.vue"]]);
const QKe = Ft(NG), R0 = function(n) {
  var e;
  return (e = n.target) == null ? void 0 : e.closest("td");
}, DG = function(n, e, t, i, r) {
  if (!e && !i && (!r || Array.isArray(r) && !r.length))
    return n;
  typeof t == "string" ? t = t === "descending" ? -1 : 1 : t = t && t < 0 ? -1 : 1;
  const s = i ? null : function(a, l) {
    return r ? (Array.isArray(r) || (r = [r]), r.map((c) => typeof c == "string" ? on(a, c) : c(a, l, n))) : (e !== "$key" && an(a) && "$value" in a && (a = a.$value), [an(a) ? on(a, e) : a]);
  }, o = function(a, l) {
    if (i)
      return i(a.value, l.value);
    for (let c = 0, u = a.key.length; c < u; c++) {
      if (a.key[c] < l.key[c])
        return -1;
      if (a.key[c] > l.key[c])
        return 1;
    }
    return 0;
  };
  return n.map((a, l) => ({
    value: a,
    index: l,
    key: s ? s(a, l) : null
  })).sort((a, l) => {
    let c = o(a, l);
    return c || (c = a.index - l.index), c * +t;
  }).map((a) => a.value);
}, j_ = function(n, e) {
  let t = null;
  return n.columns.forEach((i) => {
    i.id === e && (t = i);
  }), t;
}, LG = function(n, e) {
  let t = null;
  for (let i = 0; i < n.columns.length; i++) {
    const r = n.columns[i];
    if (r.columnKey === e) {
      t = r;
      break;
    }
  }
  return t || dr("ElTable", `No column matching with column-key: ${e}`), t;
}, dk = function(n, e, t) {
  const i = (e.className || "").match(new RegExp(`${t}-table_[^\\s]+`, "gm"));
  return i ? j_(n, i[0]) : null;
}, wi = (n, e) => {
  if (!n)
    throw new Error("Row is required when get row identity");
  if (typeof e == "string") {
    if (!e.includes("."))
      return `${n[e]}`;
    const t = e.split(".");
    let i = n;
    for (const r of t)
      i = i[r];
    return `${i}`;
  } else if (typeof e == "function")
    return e.call(null, n);
}, Pl = function(n, e) {
  const t = {};
  return (n || []).forEach((i, r) => {
    t[wi(i, e)] = { row: i, index: r };
  }), t;
};
function IG(n, e) {
  const t = {};
  let i;
  for (i in n)
    t[i] = n[i];
  for (i in e)
    if (Xi(e, i)) {
      const r = e[i];
      typeof r < "u" && (t[i] = r);
    }
  return t;
}
function Aw(n) {
  return n === "" || n !== void 0 && (n = Number.parseInt(n, 10), Number.isNaN(n) && (n = "")), n;
}
function V_(n) {
  return n === "" || n !== void 0 && (n = Aw(n), Number.isNaN(n) && (n = 80)), n;
}
function BG(n) {
  return typeof n == "number" ? n : typeof n == "string" ? /^\d+(?:px)?$/.test(n) ? Number.parseInt(n, 10) : n : null;
}
function QG(...n) {
  return n.length === 0 ? (e) => e : n.length === 1 ? n[0] : n.reduce((e, t) => (...i) => e(t(...i)));
}
function od(n, e, t) {
  let i = !1;
  const r = n.indexOf(e), s = r !== -1, o = (a) => {
    a === "add" ? n.push(e) : n.splice(r, 1), i = !0, xt(e.children) && e.children.forEach((l) => {
      od(n, l, t ?? !s);
    });
  };
  return Ei(t) ? t && !s ? o("add") : !t && s && o("remove") : o(s ? "remove" : "add"), i;
}
function zG(n, e, t = "children", i = "hasChildren") {
  const r = (o) => !(Array.isArray(o) && o.length);
  function s(o, a, l) {
    e(o, a, l), a.forEach((c) => {
      if (c[i]) {
        e(c, null, l + 1);
        return;
      }
      const u = c[t];
      r(u) || s(c, u, l + 1);
    });
  }
  n.forEach((o) => {
    if (o[i]) {
      e(o, null, 0);
      return;
    }
    const a = o[t];
    r(a) || s(o, a, 0);
  });
}
let Dr = null;
function jG(n, e, t, i) {
  if ((Dr == null ? void 0 : Dr.trigger) === t)
    return;
  Dr == null || Dr();
  const r = i == null ? void 0 : i.refs.tableWrapper, s = r == null ? void 0 : r.dataset.prefix, o = {
    strategy: "fixed",
    ...n.popperOptions
  }, a = K(Fo, {
    content: e,
    virtualTriggering: !0,
    virtualRef: t,
    appendTo: r,
    placement: "top",
    transition: "none",
    offset: 0,
    hideAfter: 0,
    ...n,
    popperOptions: o,
    onHide: () => {
      Dr == null || Dr();
    }
  });
  a.appContext = { ...i.appContext, ...i };
  const l = document.createElement("div");
  Na(a, l), a.component.exposed.onOpen();
  const c = r == null ? void 0 : r.querySelector(`.${s}-scrollbar__wrap`);
  Dr = () => {
    Na(null, l), c == null || c.removeEventListener("scroll", Dr), Dr = null;
  }, Dr.trigger = t, c == null || c.addEventListener("scroll", Dr);
}
function F_(n) {
  return n.children ? wz(n.children, F_) : [n];
}
function fk(n, e) {
  return n + e.colSpan;
}
const Z_ = (n, e, t, i) => {
  let r = 0, s = n;
  const o = t.states.columns.value;
  if (i) {
    const l = F_(i[n]);
    r = o.slice(0, o.indexOf(l[0])).reduce(fk, 0), s = r + l.reduce(fk, 0) - 1;
  } else
    r = n;
  let a;
  switch (e) {
    case "left":
      s < t.states.fixedLeafColumnsLength.value && (a = "left");
      break;
    case "right":
      r >= o.length - t.states.rightFixedLeafColumnsLength.value && (a = "right");
      break;
    default:
      s < t.states.fixedLeafColumnsLength.value ? a = "left" : r >= o.length - t.states.rightFixedLeafColumnsLength.value && (a = "right");
  }
  return a ? {
    direction: a,
    start: r,
    after: s
  } : {};
}, $w = (n, e, t, i, r, s = 0) => {
  const o = [], { direction: a, start: l, after: c } = Z_(e, t, i, r);
  if (a) {
    const u = a === "left";
    o.push(`${n}-fixed-column--${a}`), u && c + s === i.states.fixedLeafColumnsLength.value - 1 ? o.push("is-last-column") : !u && l - s === i.states.columns.value.length - i.states.rightFixedLeafColumnsLength.value && o.push("is-first-column");
  }
  return o;
};
function pk(n, e) {
  return n + (e.realWidth === null || Number.isNaN(e.realWidth) ? Number(e.width) : e.realWidth);
}
const Tw = (n, e, t, i) => {
  const {
    direction: r,
    start: s = 0,
    after: o = 0
  } = Z_(n, e, t, i);
  if (!r)
    return;
  const a = {}, l = r === "left", c = t.states.columns.value;
  return l ? a.left = c.slice(0, s).reduce(pk, 0) : a.right = c.slice(o + 1).reverse().reduce(pk, 0), a;
}, xu = (n, e) => {
  n && (Number.isNaN(n[e]) || (n[e] = `${n[e]}px`));
};
function VG(n) {
  const e = Xe(), t = D(!1), i = D([]);
  return {
    updateExpandRows: () => {
      const l = n.data.value || [], c = n.rowKey.value;
      if (t.value)
        i.value = l.slice();
      else if (c) {
        const u = Pl(i.value, c);
        i.value = l.reduce((h, d) => {
          const f = wi(d, c);
          return u[f] && h.push(d), h;
        }, []);
      } else
        i.value = [];
    },
    toggleRowExpansion: (l, c) => {
      od(i.value, l, c) && e.emit("expand-change", l, i.value.slice());
    },
    setExpandRowKeys: (l) => {
      e.store.assertRowKey();
      const c = n.data.value || [], u = n.rowKey.value, h = Pl(c, u);
      i.value = l.reduce((d, f) => {
        const p = h[f];
        return p && d.push(p.row), d;
      }, []);
    },
    isRowExpanded: (l) => {
      const c = n.rowKey.value;
      return c ? !!Pl(i.value, c)[wi(l, c)] : i.value.includes(l);
    },
    states: {
      expandRows: i,
      defaultExpandAll: t
    }
  };
}
function FG(n) {
  const e = Xe(), t = D(null), i = D(null), r = (c) => {
    e.store.assertRowKey(), t.value = c, o(c);
  }, s = () => {
    t.value = null;
  }, o = (c) => {
    const { data: u, rowKey: h } = n;
    let d = null;
    h.value && (d = (O(u) || []).find((f) => wi(f, h.value) === c)), i.value = d, e.emit("current-change", i.value, null);
  };
  return {
    setCurrentRowKey: r,
    restoreCurrentRowKey: s,
    setCurrentRowByKey: o,
    updateCurrentRow: (c) => {
      const u = i.value;
      if (c && c !== u) {
        i.value = c, e.emit("current-change", i.value, u);
        return;
      }
      !c && u && (i.value = null, e.emit("current-change", null, u));
    },
    updateCurrentRowData: () => {
      const c = n.rowKey.value, u = n.data.value || [], h = i.value;
      if (!u.includes(h) && h) {
        if (c) {
          const d = wi(h, c);
          o(d);
        } else
          i.value = null;
        i.value === null && e.emit("current-change", null, h);
      } else
        t.value && (o(t.value), s());
    },
    states: {
      _currentRowKey: t,
      currentRow: i
    }
  };
}
function ZG(n) {
  const e = D([]), t = D({}), i = D(16), r = D(!1), s = D({}), o = D("hasChildren"), a = D("children"), l = Xe(), c = $(() => {
    if (!n.rowKey.value)
      return {};
    const v = n.data.value || [];
    return h(v);
  }), u = $(() => {
    const v = n.rowKey.value, y = Object.keys(s.value), b = {};
    return y.length && y.forEach((w) => {
      if (s.value[w].length) {
        const x = { children: [] };
        s.value[w].forEach((S) => {
          const C = wi(S, v);
          x.children.push(C), S[o.value] && !b[C] && (b[C] = { children: [] });
        }), b[w] = x;
      }
    }), b;
  }), h = (v) => {
    const y = n.rowKey.value, b = {};
    return zG(v, (w, x, S) => {
      const C = wi(w, y);
      Array.isArray(x) ? b[C] = {
        children: x.map((k) => wi(k, y)),
        level: S
      } : r.value && (b[C] = {
        children: [],
        lazy: !0,
        level: S
      });
    }, a.value, o.value), b;
  }, d = (v = !1, y = ((b) => (b = l.store) == null ? void 0 : b.states.defaultExpandAll.value)()) => {
    var b;
    const w = c.value, x = u.value, S = Object.keys(w), C = {};
    if (S.length) {
      const k = O(t), E = [], M = (T, B) => {
        if (v)
          return e.value ? y || e.value.includes(B) : !!(y || T != null && T.expanded);
        {
          const I = y || e.value && e.value.includes(B);
          return !!(T != null && T.expanded || I);
        }
      };
      S.forEach((T) => {
        const B = k[T], I = { ...w[T] };
        if (I.expanded = M(B, T), I.lazy) {
          const { loaded: P = !1, loading: A = !1 } = B || {};
          I.loaded = !!P, I.loading = !!A, E.push(T);
        }
        C[T] = I;
      });
      const _ = Object.keys(x);
      r.value && _.length && E.length && _.forEach((T) => {
        const B = k[T], I = x[T].children;
        if (E.includes(T)) {
          if (C[T].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          C[T].children = I;
        } else {
          const { loaded: P = !1, loading: A = !1 } = B || {};
          C[T] = {
            lazy: !0,
            loaded: !!P,
            loading: !!A,
            expanded: M(B, T),
            children: I,
            level: ""
          };
        }
      });
    }
    t.value = C, (b = l.store) == null || b.updateTableScrollY();
  };
  ne(() => e.value, () => {
    d(!0);
  }), ne(() => c.value, () => {
    d();
  }), ne(() => u.value, () => {
    d();
  });
  const f = (v) => {
    e.value = v, d();
  }, p = (v, y) => {
    l.store.assertRowKey();
    const b = n.rowKey.value, w = wi(v, b), x = w && t.value[w];
    if (w && x && "expanded" in x) {
      const S = x.expanded;
      y = typeof y > "u" ? !x.expanded : y, t.value[w].expanded = y, S !== y && l.emit("expand-change", v, y), l.store.updateTableScrollY();
    }
  }, g = (v) => {
    l.store.assertRowKey();
    const y = n.rowKey.value, b = wi(v, y), w = t.value[b];
    r.value && w && "loaded" in w && !w.loaded ? m(v, b, w) : p(v, void 0);
  }, m = (v, y, b) => {
    const { load: w } = l.props;
    w && !t.value[y].loaded && (t.value[y].loading = !0, w(v, b, (x) => {
      if (!Array.isArray(x))
        throw new TypeError("[ElTable] data must be an array");
      t.value[y].loading = !1, t.value[y].loaded = !0, t.value[y].expanded = !0, x.length && (s.value[y] = x), l.emit("expand-change", v, !0);
    }));
  };
  return {
    loadData: m,
    loadOrToggle: g,
    toggleTreeExpansion: p,
    updateTreeExpandKeys: f,
    updateTreeData: d,
    normalize: h,
    states: {
      expandRowKeys: e,
      treeData: t,
      indent: i,
      lazy: r,
      lazyTreeNodeMap: s,
      lazyColumnIdentifier: o,
      childrenColumnName: a
    }
  };
}
const qG = (n, e) => {
  const t = e.sortingColumn;
  return !t || typeof t.sortable == "string" ? n : DG(n, e.sortProp, e.sortOrder, t.sortMethod, t.sortBy);
}, mg = (n) => {
  const e = [];
  return n.forEach((t) => {
    t.children && t.children.length > 0 ? e.push.apply(e, mg(t.children)) : e.push(t);
  }), e;
};
function WG() {
  var n;
  const e = Xe(), { size: t } = Hr((n = e.proxy) == null ? void 0 : n.$props), i = D(null), r = D([]), s = D([]), o = D(!1), a = D([]), l = D([]), c = D([]), u = D([]), h = D([]), d = D([]), f = D([]), p = D([]), g = [], m = D(0), v = D(0), y = D(0), b = D(!1), w = D([]), x = D(!1), S = D(!1), C = D(null), k = D({}), E = D(null), M = D(null), _ = D(null), T = D(null), B = D(null);
  ne(r, () => e.state && N(!1), {
    deep: !0
  });
  const I = () => {
    if (!i.value)
      throw new Error("[ElTable] prop row-key is required");
  }, P = (Te) => {
    var je;
    (je = Te.children) == null || je.forEach((J) => {
      J.fixed = Te.fixed, P(J);
    });
  }, A = () => {
    a.value.forEach((ve) => {
      P(ve);
    }), u.value = a.value.filter((ve) => ve.fixed === !0 || ve.fixed === "left"), h.value = a.value.filter((ve) => ve.fixed === "right"), u.value.length > 0 && a.value[0] && a.value[0].type === "selection" && !a.value[0].fixed && (a.value[0].fixed = !0, u.value.unshift(a.value[0]));
    const Te = a.value.filter((ve) => !ve.fixed);
    l.value = [].concat(u.value).concat(Te).concat(h.value);
    const je = mg(Te), J = mg(u.value), le = mg(h.value);
    m.value = je.length, v.value = J.length, y.value = le.length, c.value = [].concat(J).concat(je).concat(le), o.value = u.value.length > 0 || h.value.length > 0;
  }, N = (Te, je = !1) => {
    Te && A(), je ? e.state.doLayout() : e.state.debouncedUpdateLayout();
  }, q = (Te) => w.value.includes(Te), j = () => {
    b.value = !1, w.value.length && (w.value = [], e.emit("selection-change", []));
  }, H = () => {
    let Te;
    if (i.value) {
      Te = [];
      const je = Pl(w.value, i.value), J = Pl(r.value, i.value);
      for (const le in je)
        Xi(je, le) && !J[le] && Te.push(je[le].row);
    } else
      Te = w.value.filter((je) => !r.value.includes(je));
    if (Te.length) {
      const je = w.value.filter((J) => !Te.includes(J));
      w.value = je, e.emit("selection-change", je.slice());
    }
  }, oe = () => (w.value || []).slice(), te = (Te, je = void 0, J = !0) => {
    if (od(w.value, Te, je)) {
      const ve = (w.value || []).slice();
      J && e.emit("select", ve, Te), e.emit("selection-change", ve);
    }
  }, W = () => {
    var Te, je;
    const J = S.value ? !b.value : !(b.value || w.value.length);
    b.value = J;
    let le = !1, ve = 0;
    const Ue = (je = (Te = e == null ? void 0 : e.store) == null ? void 0 : Te.states) == null ? void 0 : je.rowKey.value;
    r.value.forEach((Zt, Cn) => {
      const jt = Cn + ve;
      C.value ? C.value.call(null, Zt, jt) && od(w.value, Zt, J) && (le = !0) : od(w.value, Zt, J) && (le = !0), ve += he(wi(Zt, Ue));
    }), le && e.emit("selection-change", w.value ? w.value.slice() : []), e.emit("select-all", w.value);
  }, U = () => {
    const Te = Pl(w.value, i.value);
    r.value.forEach((je) => {
      const J = wi(je, i.value), le = Te[J];
      le && (w.value[le.index] = je);
    });
  }, ae = () => {
    var Te, je, J;
    if (((Te = r.value) == null ? void 0 : Te.length) === 0) {
      b.value = !1;
      return;
    }
    let le;
    i.value && (le = Pl(w.value, i.value));
    const ve = function(jt) {
      return le ? !!le[wi(jt, i.value)] : w.value.includes(jt);
    };
    let Ue = !0, Zt = 0, Cn = 0;
    for (let jt = 0, Ds = (r.value || []).length; jt < Ds; jt++) {
      const Rr = (J = (je = e == null ? void 0 : e.store) == null ? void 0 : je.states) == null ? void 0 : J.rowKey.value, gc = jt + Cn, Co = r.value[jt], mc = C.value && C.value.call(null, Co, gc);
      if (ve(Co))
        Zt++;
      else if (!C.value || mc) {
        Ue = !1;
        break;
      }
      Cn += he(wi(Co, Rr));
    }
    Zt === 0 && (Ue = !1), b.value = Ue;
  }, he = (Te) => {
    var je;
    if (!e || !e.store)
      return 0;
    const { treeData: J } = e.store.states;
    let le = 0;
    const ve = (je = J.value[Te]) == null ? void 0 : je.children;
    return ve && (le += ve.length, ve.forEach((Ue) => {
      le += he(Ue);
    })), le;
  }, ee = (Te, je) => {
    Array.isArray(Te) || (Te = [Te]);
    const J = {};
    return Te.forEach((le) => {
      k.value[le.id] = je, J[le.columnKey || le.id] = je;
    }), J;
  }, pe = (Te, je, J) => {
    M.value && M.value !== Te && (M.value.order = null), M.value = Te, _.value = je, T.value = J;
  }, be = () => {
    let Te = O(s);
    Object.keys(k.value).forEach((je) => {
      const J = k.value[je];
      if (!J || J.length === 0)
        return;
      const le = j_({
        columns: c.value
      }, je);
      le && le.filterMethod && (Te = Te.filter((ve) => J.some((Ue) => le.filterMethod.call(null, Ue, ve, le))));
    }), E.value = Te;
  }, fe = () => {
    r.value = qG(E.value, {
      sortingColumn: M.value,
      sortProp: _.value,
      sortOrder: T.value
    });
  }, Ae = (Te = void 0) => {
    Te && Te.filter || be(), fe();
  }, ut = (Te) => {
    const { tableHeaderRef: je } = e.refs;
    if (!je)
      return;
    const J = Object.assign({}, je.filterPanels), le = Object.keys(J);
    if (le.length)
      if (typeof Te == "string" && (Te = [Te]), Array.isArray(Te)) {
        const ve = Te.map((Ue) => LG({
          columns: c.value
        }, Ue));
        le.forEach((Ue) => {
          const Zt = ve.find((Cn) => Cn.id === Ue);
          Zt && (Zt.filteredValue = []);
        }), e.store.commit("filterChange", {
          column: ve,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        le.forEach((ve) => {
          const Ue = c.value.find((Zt) => Zt.id === ve);
          Ue && (Ue.filteredValue = []);
        }), k.value = {}, e.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, zt = () => {
    M.value && (pe(null, null, null), e.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: Jn,
    toggleRowExpansion: ei,
    updateExpandRows: Li,
    states: di,
    isRowExpanded: Ii
  } = VG({
    data: r,
    rowKey: i
  }), {
    updateTreeExpandKeys: fr,
    toggleTreeExpansion: un,
    updateTreeData: Bi,
    loadOrToggle: Ui,
    states: Qi
  } = ZG({
    data: r,
    rowKey: i
  }), {
    updateCurrentRowData: ti,
    updateCurrentRow: ge,
    setCurrentRowKey: Ke,
    states: Dt
  } = FG({
    data: r,
    rowKey: i
  });
  return {
    assertRowKey: I,
    updateColumns: A,
    scheduleLayout: N,
    isSelected: q,
    clearSelection: j,
    cleanSelection: H,
    getSelectionRows: oe,
    toggleRowSelection: te,
    _toggleAllSelection: W,
    toggleAllSelection: null,
    updateSelectionByRowKey: U,
    updateAllSelected: ae,
    updateFilters: ee,
    updateCurrentRow: ge,
    updateSort: pe,
    execFilter: be,
    execSort: fe,
    execQuery: Ae,
    clearFilter: ut,
    clearSort: zt,
    toggleRowExpansion: ei,
    setExpandRowKeysAdapter: (Te) => {
      Jn(Te), fr(Te);
    },
    setCurrentRowKey: Ke,
    toggleRowExpansionAdapter: (Te, je) => {
      c.value.some(({ type: le }) => le === "expand") ? ei(Te, je) : un(Te, je);
    },
    isRowExpanded: Ii,
    updateExpandRows: Li,
    updateCurrentRowData: ti,
    loadOrToggle: Ui,
    updateTreeData: Bi,
    states: {
      tableSize: t,
      rowKey: i,
      data: r,
      _data: s,
      isComplex: o,
      _columns: a,
      originColumns: l,
      columns: c,
      fixedColumns: u,
      rightFixedColumns: h,
      leafColumns: d,
      fixedLeafColumns: f,
      rightFixedLeafColumns: p,
      updateOrderFns: g,
      leafColumnsLength: m,
      fixedLeafColumnsLength: v,
      rightFixedLeafColumnsLength: y,
      isAllSelected: b,
      selection: w,
      reserveSelection: x,
      selectOnIndeterminate: S,
      selectable: C,
      filters: k,
      filteredData: E,
      sortingColumn: M,
      sortProp: _,
      sortOrder: T,
      hoverRow: B,
      ...di,
      ...Qi,
      ...Dt
    }
  };
}
function My(n, e) {
  return n.map((t) => {
    var i;
    return t.id === e.id ? e : ((i = t.children) != null && i.length && (t.children = My(t.children, e)), t);
  });
}
function Ry(n) {
  n.forEach((e) => {
    var t, i;
    e.no = (t = e.getColumnIndex) == null ? void 0 : t.call(e), (i = e.children) != null && i.length && Ry(e.children);
  }), n.sort((e, t) => e.no - t.no);
}
function HG() {
  const n = Xe(), e = WG();
  return {
    ns: me("table"),
    ...e,
    mutations: {
      setData(o, a) {
        const l = O(o._data) !== a;
        o.data.value = a, o._data.value = a, n.store.execQuery(), n.store.updateCurrentRowData(), n.store.updateExpandRows(), n.store.updateTreeData(n.store.states.defaultExpandAll.value), O(o.reserveSelection) ? (n.store.assertRowKey(), n.store.updateSelectionByRowKey()) : l ? n.store.clearSelection() : n.store.cleanSelection(), n.store.updateAllSelected(), n.$ready && n.store.scheduleLayout();
      },
      insertColumn(o, a, l, c) {
        const u = O(o._columns);
        let h = [];
        l ? (l && !l.children && (l.children = []), l.children.push(a), h = My(u, l)) : (u.push(a), h = u), Ry(h), o._columns.value = h, o.updateOrderFns.push(c), a.type === "selection" && (o.selectable.value = a.selectable, o.reserveSelection.value = a.reserveSelection), n.$ready && (n.store.updateColumns(), n.store.scheduleLayout());
      },
      updateColumnOrder(o, a) {
        var l;
        ((l = a.getColumnIndex) == null ? void 0 : l.call(a)) !== a.no && (Ry(o._columns.value), n.$ready && n.store.updateColumns());
      },
      removeColumn(o, a, l, c) {
        const u = O(o._columns) || [];
        if (l)
          l.children.splice(l.children.findIndex((d) => d.id === a.id), 1), $e(() => {
            var d;
            ((d = l.children) == null ? void 0 : d.length) === 0 && delete l.children;
          }), o._columns.value = My(u, l);
        else {
          const d = u.indexOf(a);
          d > -1 && (u.splice(d, 1), o._columns.value = u);
        }
        const h = o.updateOrderFns.indexOf(c);
        h > -1 && o.updateOrderFns.splice(h, 1), n.$ready && (n.store.updateColumns(), n.store.scheduleLayout());
      },
      sort(o, a) {
        const { prop: l, order: c, init: u } = a;
        if (l) {
          const h = O(o.columns).find((d) => d.property === l);
          h && (h.order = c, n.store.updateSort(h, l, c), n.store.commit("changeSortCondition", { init: u }));
        }
      },
      changeSortCondition(o, a) {
        const { sortingColumn: l, sortProp: c, sortOrder: u } = o, h = O(l), d = O(c), f = O(u);
        f === null && (o.sortingColumn.value = null, o.sortProp.value = null);
        const p = { filter: !0 };
        n.store.execQuery(p), (!a || !(a.silent || a.init)) && n.emit("sort-change", {
          column: h,
          prop: d,
          order: f
        }), n.store.updateTableScrollY();
      },
      filterChange(o, a) {
        const { column: l, values: c, silent: u } = a, h = n.store.updateFilters(l, c);
        n.store.execQuery(), u || n.emit("filter-change", h), n.store.updateTableScrollY();
      },
      toggleAllSelection() {
        n.store.toggleAllSelection();
      },
      rowSelectedChanged(o, a) {
        n.store.toggleRowSelection(a), n.store.updateAllSelected();
      },
      setHoverRow(o, a) {
        o.hoverRow.value = a;
      },
      setCurrentRow(o, a) {
        n.store.updateCurrentRow(a);
      }
    },
    commit: function(o, ...a) {
      const l = n.store.mutations;
      if (l[o])
        l[o].apply(n, [n.store.states].concat(a));
      else
        throw new Error(`Action not found: ${o}`);
    },
    updateTableScrollY: function() {
      $e(() => n.layout.updateScrollY.apply(n.layout));
    }
  };
}
const ad = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  "treeProps.hasChildren": {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  "treeProps.children": {
    key: "childrenColumnName",
    default: "children"
  }
};
function XG(n, e) {
  if (!n)
    throw new Error("Table is required.");
  const t = HG();
  return t.toggleAllSelection = zo(t._toggleAllSelection, 10), Object.keys(ad).forEach((i) => {
    q_(W_(e, i), i, t);
  }), YG(t, e), t;
}
function YG(n, e) {
  Object.keys(ad).forEach((t) => {
    ne(() => W_(e, t), (i) => {
      q_(i, t, n);
    });
  });
}
function q_(n, e, t) {
  let i = n, r = ad[e];
  typeof ad[e] == "object" && (r = r.key, i = i || ad[e].default), t.states[r].value = i;
}
function W_(n, e) {
  if (e.includes(".")) {
    const t = e.split(".");
    let i = n;
    return t.forEach((r) => {
      i = i[r];
    }), i;
  } else
    return n[e];
}
class UG {
  constructor(e) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = D(null), this.scrollX = D(!1), this.scrollY = D(!1), this.bodyWidth = D(null), this.fixedWidth = D(null), this.rightFixedWidth = D(null), this.gutterWidth = 0;
    for (const t in e)
      Xi(e, t) && (Zi(this[t]) ? this[t].value = e[t] : this[t] = e[t]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    if (this.height.value === null)
      return !1;
    const t = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (t != null && t.wrapRef)) {
      let i = !0;
      const r = this.scrollY.value;
      return i = t.wrapRef.scrollHeight > t.wrapRef.clientHeight, this.scrollY.value = i, r !== i;
    }
    return !1;
  }
  setHeight(e, t = "height") {
    if (!vt)
      return;
    const i = this.table.vnode.el;
    if (e = BG(e), this.height.value = Number(e), !i && (e || e === 0))
      return $e(() => this.setHeight(e, t));
    typeof e == "number" ? (i.style[t] = `${e}px`, this.updateElsHeight()) : typeof e == "string" && (i.style[t] = e, this.updateElsHeight());
  }
  setMaxHeight(e) {
    this.setHeight(e, "max-height");
  }
  getFlattenColumns() {
    const e = [];
    return this.table.store.states.columns.value.forEach((i) => {
      i.isColumnGroup ? e.push.apply(e, i.columns) : e.push(i);
    }), e;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(e) {
    if (!e)
      return !0;
    let t = e;
    for (; t.tagName !== "DIV"; ) {
      if (getComputedStyle(t).display === "none")
        return !0;
      t = t.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    if (!vt)
      return;
    const e = this.fit, t = this.table.vnode.el.clientWidth;
    let i = 0;
    const r = this.getFlattenColumns(), s = r.filter((l) => typeof l.width != "number");
    if (r.forEach((l) => {
      typeof l.width == "number" && l.realWidth && (l.realWidth = null);
    }), s.length > 0 && e) {
      if (r.forEach((l) => {
        i += Number(l.width || l.minWidth || 80);
      }), i <= t) {
        this.scrollX.value = !1;
        const l = t - i;
        if (s.length === 1)
          s[0].realWidth = Number(s[0].minWidth || 80) + l;
        else {
          const c = s.reduce((d, f) => d + Number(f.minWidth || 80), 0), u = l / c;
          let h = 0;
          s.forEach((d, f) => {
            if (f === 0)
              return;
            const p = Math.floor(Number(d.minWidth || 80) * u);
            h += p, d.realWidth = Number(d.minWidth || 80) + p;
          }), s[0].realWidth = Number(s[0].minWidth || 80) + l - h;
        }
      } else
        this.scrollX.value = !0, s.forEach((l) => {
          l.realWidth = Number(l.minWidth);
        });
      this.bodyWidth.value = Math.max(i, t), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      r.forEach((l) => {
        !l.width && !l.minWidth ? l.realWidth = 80 : l.realWidth = Number(l.width || l.minWidth), i += l.realWidth;
      }), this.scrollX.value = i > t, this.bodyWidth.value = i;
    const o = this.store.states.fixedColumns.value;
    if (o.length > 0) {
      let l = 0;
      o.forEach((c) => {
        l += Number(c.realWidth || c.width);
      }), this.fixedWidth.value = l;
    }
    const a = this.store.states.rightFixedColumns.value;
    if (a.length > 0) {
      let l = 0;
      a.forEach((c) => {
        l += Number(c.realWidth || c.width);
      }), this.rightFixedWidth.value = l;
    }
    this.notifyObservers("columns");
  }
  addObserver(e) {
    this.observers.push(e);
  }
  removeObserver(e) {
    const t = this.observers.indexOf(e);
    t !== -1 && this.observers.splice(t, 1);
  }
  notifyObservers(e) {
    this.observers.forEach((i) => {
      var r, s;
      switch (e) {
        case "columns":
          (r = i.state) == null || r.onColumnsChange(this);
          break;
        case "scrollable":
          (s = i.state) == null || s.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${e}.`);
      }
    });
  }
}
const { CheckboxGroup: GG } = fo, KG = F({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: fo,
    ElCheckboxGroup: GG,
    ElScrollbar: _f,
    ElTooltip: Fo,
    ElIcon: Fe,
    ArrowDown: oh,
    ArrowUp: B$
  },
  directives: { ClickOutside: Rf },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(n) {
    const e = Xe(), { t } = mn(), i = me("table-filter"), r = e == null ? void 0 : e.parent;
    r.filterPanels.value[n.column.id] || (r.filterPanels.value[n.column.id] = e);
    const s = D(!1), o = D(null), a = $(() => n.column && n.column.filters), l = $(() => n.column.filterClassName ? `${i.b()} ${n.column.filterClassName}` : i.b()), c = $({
      get: () => {
        var x;
        return (((x = n.column) == null ? void 0 : x.filteredValue) || [])[0];
      },
      set: (x) => {
        u.value && (typeof x < "u" && x !== null ? u.value.splice(0, 1, x) : u.value.splice(0, 1));
      }
    }), u = $({
      get() {
        return n.column ? n.column.filteredValue || [] : [];
      },
      set(x) {
        n.column && n.upDataColumn("filteredValue", x);
      }
    }), h = $(() => n.column ? n.column.filterMultiple : !0), d = (x) => x.value === c.value, f = () => {
      s.value = !1;
    }, p = (x) => {
      x.stopPropagation(), s.value = !s.value;
    }, g = () => {
      s.value = !1;
    }, m = () => {
      b(u.value), f();
    }, v = () => {
      u.value = [], b(u.value), f();
    }, y = (x) => {
      c.value = x, b(typeof x < "u" && x !== null ? u.value : []), f();
    }, b = (x) => {
      n.store.commit("filterChange", {
        column: n.column,
        values: x
      }), n.store.updateAllSelected();
    };
    ne(s, (x) => {
      n.column && n.upDataColumn("filterOpened", x);
    }, {
      immediate: !0
    });
    const w = $(() => {
      var x, S;
      return (S = (x = o.value) == null ? void 0 : x.popperRef) == null ? void 0 : S.contentRef;
    });
    return {
      tooltipVisible: s,
      multiple: h,
      filterClassName: l,
      filteredValue: u,
      filterValue: c,
      filters: a,
      handleConfirm: m,
      handleReset: v,
      handleSelect: y,
      isActive: d,
      t,
      ns: i,
      showFilterPanel: p,
      hideFilterPanel: g,
      popperPaneRef: w,
      tooltip: o
    };
  }
}), JG = { key: 0 }, eK = ["disabled"], tK = ["label", "onClick"];
function nK(n, e, t, i, r, s) {
  const o = nt("el-checkbox"), a = nt("el-checkbox-group"), l = nt("el-scrollbar"), c = nt("arrow-up"), u = nt("arrow-down"), h = nt("el-icon"), d = nt("el-tooltip"), f = nv("click-outside");
  return R(), ie(d, {
    ref: "tooltip",
    visible: n.tooltipVisible,
    offset: 0,
    placement: n.placement,
    "show-arrow": !1,
    "stop-popper-mouse-event": !1,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": n.filterClassName,
    persistent: ""
  }, {
    content: Y(() => [
      n.multiple ? (R(), V("div", JG, [
        Z("div", {
          class: L(n.ns.e("content"))
        }, [
          K(l, {
            "wrap-class": n.ns.e("wrap")
          }, {
            default: Y(() => [
              K(a, {
                modelValue: n.filteredValue,
                "onUpdate:modelValue": e[0] || (e[0] = (p) => n.filteredValue = p),
                class: L(n.ns.e("checkbox-group"))
              }, {
                default: Y(() => [
                  (R(!0), V(Tt, null, ai(n.filters, (p) => (R(), ie(o, {
                    key: p.value,
                    label: p.value
                  }, {
                    default: Y(() => [
                      Yn(xe(p.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["label"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        Z("div", {
          class: L(n.ns.e("bottom"))
        }, [
          Z("button", {
            class: L({ [n.ns.is("disabled")]: n.filteredValue.length === 0 }),
            disabled: n.filteredValue.length === 0,
            type: "button",
            onClick: e[1] || (e[1] = (...p) => n.handleConfirm && n.handleConfirm(...p))
          }, xe(n.t("el.table.confirmFilter")), 11, eK),
          Z("button", {
            type: "button",
            onClick: e[2] || (e[2] = (...p) => n.handleReset && n.handleReset(...p))
          }, xe(n.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (R(), V("ul", {
        key: 1,
        class: L(n.ns.e("list"))
      }, [
        Z("li", {
          class: L([
            n.ns.e("list-item"),
            {
              [n.ns.is("active")]: n.filterValue === void 0 || n.filterValue === null
            }
          ]),
          onClick: e[3] || (e[3] = (p) => n.handleSelect(null))
        }, xe(n.t("el.table.clearFilter")), 3),
        (R(!0), V(Tt, null, ai(n.filters, (p) => (R(), V("li", {
          key: p.value,
          class: L([n.ns.e("list-item"), n.ns.is("active", n.isActive(p))]),
          label: p.value,
          onClick: (g) => n.handleSelect(p.value)
        }, xe(p.text), 11, tK))), 128))
      ], 2))
    ]),
    default: Y(() => [
      it((R(), V("span", {
        class: L([
          `${n.ns.namespace.value}-table__column-filter-trigger`,
          `${n.ns.namespace.value}-none-outline`
        ]),
        onClick: e[4] || (e[4] = (...p) => n.showFilterPanel && n.showFilterPanel(...p))
      }, [
        K(h, null, {
          default: Y(() => [
            n.column.filterOpened ? (R(), ie(c, { key: 0 })) : (R(), ie(u, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [f, n.hideFilterPanel, n.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var iK = /* @__PURE__ */ Ce(KG, [["render", nK], ["__file", "filter-panel.vue"]]);
function H_(n) {
  const e = Xe();
  D1(() => {
    t.value.addObserver(e);
  }), qe(() => {
    i(t.value), r(t.value);
  }), Ya(() => {
    i(t.value), r(t.value);
  }), Gu(() => {
    t.value.removeObserver(e);
  });
  const t = $(() => {
    const s = n.layout;
    if (!s)
      throw new Error("Can not find table layout.");
    return s;
  }), i = (s) => {
    var o;
    const a = ((o = n.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col")) || [];
    if (!a.length)
      return;
    const l = s.getFlattenColumns(), c = {};
    l.forEach((u) => {
      c[u.id] = u;
    });
    for (let u = 0, h = a.length; u < h; u++) {
      const d = a[u], f = d.getAttribute("name"), p = c[f];
      p && d.setAttribute("width", p.realWidth || p.width);
    }
  }, r = (s) => {
    var o, a;
    const l = ((o = n.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let u = 0, h = l.length; u < h; u++)
      l[u].setAttribute("width", s.scrollY.value ? s.gutterWidth : "0");
    const c = ((a = n.vnode.el) == null ? void 0 : a.querySelectorAll("th.gutter")) || [];
    for (let u = 0, h = c.length; u < h; u++) {
      const d = c[u];
      d.style.width = s.scrollY.value ? `${s.gutterWidth}px` : "0", d.style.display = s.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: t.value,
    onColumnsChange: i,
    onScrollableChange: r
  };
}
const yo = Symbol("ElTable");
function rK(n, e) {
  const t = Xe(), i = ke(yo), r = (g) => {
    g.stopPropagation();
  }, s = (g, m) => {
    !m.filters && m.sortable ? p(g, m, !1) : m.filterable && !m.sortable && r(g), i == null || i.emit("header-click", m, g);
  }, o = (g, m) => {
    i == null || i.emit("header-contextmenu", m, g);
  }, a = D(null), l = D(!1), c = D({}), u = (g, m) => {
    if (vt && !(m.children && m.children.length > 0) && a.value && n.border) {
      l.value = !0;
      const v = i;
      e("set-drag-visible", !0);
      const b = (v == null ? void 0 : v.vnode.el).getBoundingClientRect().left, w = t.vnode.el.querySelector(`th.${m.id}`), x = w.getBoundingClientRect(), S = x.left - b + 30;
      pu(w, "noclick"), c.value = {
        startMouseLeft: g.clientX,
        startLeft: x.right - b,
        startColumnLeft: x.left - b,
        tableLeft: b
      };
      const C = v == null ? void 0 : v.refs.resizeProxy;
      C.style.left = `${c.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const k = (M) => {
        const _ = M.clientX - c.value.startMouseLeft, T = c.value.startLeft + _;
        C.style.left = `${Math.max(S, T)}px`;
      }, E = () => {
        if (l.value) {
          const { startColumnLeft: M, startLeft: _ } = c.value, B = Number.parseInt(C.style.left, 10) - M;
          m.width = m.realWidth = B, v == null || v.emit("header-dragend", m.width, _ - M, m, g), requestAnimationFrame(() => {
            n.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", l.value = !1, a.value = null, c.value = {}, e("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", k), document.removeEventListener("mouseup", E), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          Io(w, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", k), document.addEventListener("mouseup", E);
    }
  }, h = (g, m) => {
    if (m.children && m.children.length > 0)
      return;
    const v = g.target;
    if (!Os(v))
      return;
    const y = v == null ? void 0 : v.closest("th");
    if (!(!m || !m.resizable) && !l.value && n.border) {
      const b = y.getBoundingClientRect(), w = document.body.style;
      b.width > 12 && b.right - g.pageX < 8 ? (w.cursor = "col-resize", qc(y, "is-sortable") && (y.style.cursor = "col-resize"), a.value = m) : l.value || (w.cursor = "", qc(y, "is-sortable") && (y.style.cursor = "pointer"), a.value = null);
    }
  }, d = () => {
    vt && (document.body.style.cursor = "");
  }, f = ({ order: g, sortOrders: m }) => {
    if (g === "")
      return m[0];
    const v = m.indexOf(g || null);
    return m[v > m.length - 2 ? 0 : v + 1];
  }, p = (g, m, v) => {
    var y;
    g.stopPropagation();
    const b = m.order === v ? null : v || f(m), w = (y = g.target) == null ? void 0 : y.closest("th");
    if (w && qc(w, "noclick")) {
      Io(w, "noclick");
      return;
    }
    if (!m.sortable)
      return;
    const x = n.store.states;
    let S = x.sortProp.value, C;
    const k = x.sortingColumn.value;
    (k !== m || k === m && k.order === null) && (k && (k.order = null), x.sortingColumn.value = m, S = m.property), b ? C = m.order = b : C = m.order = null, x.sortProp.value = S, x.sortOrder.value = C, i == null || i.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: s,
    handleHeaderContextMenu: o,
    handleMouseDown: u,
    handleMouseMove: h,
    handleMouseOut: d,
    handleSortClick: p,
    handleFilterClick: r
  };
}
function sK(n) {
  const e = ke(yo), t = me("table");
  return {
    getHeaderRowStyle: (a) => {
      const l = e == null ? void 0 : e.props.headerRowStyle;
      return typeof l == "function" ? l.call(null, { rowIndex: a }) : l;
    },
    getHeaderRowClass: (a) => {
      const l = [], c = e == null ? void 0 : e.props.headerRowClassName;
      return typeof c == "string" ? l.push(c) : typeof c == "function" && l.push(c.call(null, { rowIndex: a })), l.join(" ");
    },
    getHeaderCellStyle: (a, l, c, u) => {
      var h;
      let d = (h = e == null ? void 0 : e.props.headerCellStyle) != null ? h : {};
      typeof d == "function" && (d = d.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: c,
        column: u
      }));
      const f = Tw(l, u.fixed, n.store, c);
      return xu(f, "left"), xu(f, "right"), Object.assign({}, d, f);
    },
    getHeaderCellClass: (a, l, c, u) => {
      const h = $w(t.b(), l, u.fixed, n.store, c), d = [
        u.id,
        u.order,
        u.headerAlign,
        u.className,
        u.labelClassName,
        ...h
      ];
      u.children || d.push("is-leaf"), u.sortable && d.push("is-sortable");
      const f = e == null ? void 0 : e.props.headerCellClassName;
      return typeof f == "string" ? d.push(f) : typeof f == "function" && d.push(f.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: c,
        column: u
      })), d.push(t.e("cell")), d.filter((p) => !!p).join(" ");
    }
  };
}
const X_ = (n) => {
  const e = [];
  return n.forEach((t) => {
    t.children ? (e.push(t), e.push.apply(e, X_(t.children))) : e.push(t);
  }), e;
}, oK = (n) => {
  let e = 1;
  const t = (s, o) => {
    if (o && (s.level = o.level + 1, e < s.level && (e = s.level)), s.children) {
      let a = 0;
      s.children.forEach((l) => {
        t(l, s), a += l.colSpan;
      }), s.colSpan = a;
    } else
      s.colSpan = 1;
  };
  n.forEach((s) => {
    s.level = 1, t(s, void 0);
  });
  const i = [];
  for (let s = 0; s < e; s++)
    i.push([]);
  return X_(n).forEach((s) => {
    s.children ? (s.rowSpan = 1, s.children.forEach((o) => o.isSubColumn = !0)) : s.rowSpan = e - s.level + 1, i[s.level - 1].push(s);
  }), i;
};
function aK(n) {
  const e = ke(yo), t = $(() => oK(n.store.states.originColumns.value));
  return {
    isGroup: $(() => {
      const s = t.value.length > 1;
      return s && e && (e.state.isGroup.value = !0), s;
    }),
    toggleAllSelection: (s) => {
      s.stopPropagation(), e == null || e.store.commit("toggleAllSelection");
    },
    columnRows: t
  };
}
var lK = F({
  name: "ElTableHeader",
  components: {
    ElCheckbox: fo
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(n, { emit: e }) {
    const t = Xe(), i = ke(yo), r = me("table"), s = D({}), { onColumnsChange: o, onScrollableChange: a } = H_(i);
    qe(async () => {
      await $e(), await $e();
      const { prop: S, order: C } = n.defaultSort;
      i == null || i.store.commit("sort", { prop: S, order: C, init: !0 });
    });
    const {
      handleHeaderClick: l,
      handleHeaderContextMenu: c,
      handleMouseDown: u,
      handleMouseMove: h,
      handleMouseOut: d,
      handleSortClick: f,
      handleFilterClick: p
    } = rK(n, e), {
      getHeaderRowStyle: g,
      getHeaderRowClass: m,
      getHeaderCellStyle: v,
      getHeaderCellClass: y
    } = sK(n), { isGroup: b, toggleAllSelection: w, columnRows: x } = aK(n);
    return t.state = {
      onColumnsChange: o,
      onScrollableChange: a
    }, t.filterPanels = s, {
      ns: r,
      filterPanels: s,
      onColumnsChange: o,
      onScrollableChange: a,
      columnRows: x,
      getHeaderRowClass: m,
      getHeaderRowStyle: g,
      getHeaderCellClass: y,
      getHeaderCellStyle: v,
      handleHeaderClick: l,
      handleHeaderContextMenu: c,
      handleMouseDown: u,
      handleMouseMove: h,
      handleMouseOut: d,
      handleSortClick: f,
      handleFilterClick: p,
      isGroup: b,
      toggleAllSelection: w
    };
  },
  render() {
    const {
      ns: n,
      isGroup: e,
      columnRows: t,
      getHeaderCellStyle: i,
      getHeaderCellClass: r,
      getHeaderRowClass: s,
      getHeaderRowStyle: o,
      handleHeaderClick: a,
      handleHeaderContextMenu: l,
      handleMouseDown: c,
      handleMouseMove: u,
      handleSortClick: h,
      handleMouseOut: d,
      store: f,
      $parent: p
    } = this;
    let g = 1;
    return Re("thead", {
      class: { [n.is("group")]: e }
    }, t.map((m, v) => Re("tr", {
      class: s(v),
      key: v,
      style: o(v)
    }, m.map((y, b) => (y.rowSpan > g && (g = y.rowSpan), Re("th", {
      class: r(v, b, m, y),
      colspan: y.colSpan,
      key: `${y.id}-thead`,
      rowspan: y.rowSpan,
      style: i(v, b, m, y),
      onClick: (w) => a(w, y),
      onContextmenu: (w) => l(w, y),
      onMousedown: (w) => c(w, y),
      onMousemove: (w) => u(w, y),
      onMouseout: d
    }, [
      Re("div", {
        class: [
          "cell",
          y.filteredValue && y.filteredValue.length > 0 ? "highlight" : ""
        ]
      }, [
        y.renderHeader ? y.renderHeader({
          column: y,
          $index: b,
          store: f,
          _self: p
        }) : y.label,
        y.sortable && Re("span", {
          onClick: (w) => h(w, y),
          class: "caret-wrapper"
        }, [
          Re("i", {
            onClick: (w) => h(w, y, "ascending"),
            class: "sort-caret ascending"
          }),
          Re("i", {
            onClick: (w) => h(w, y, "descending"),
            class: "sort-caret descending"
          })
        ]),
        y.filterable && Re(iK, {
          store: f,
          placement: y.filterPlacement || "bottom-start",
          column: y,
          upDataColumn: (w, x) => {
            y[w] = x;
          }
        })
      ])
    ]))))));
  }
});
function cK(n) {
  const e = ke(yo), t = D(""), i = D(Re("div")), r = (p, g, m) => {
    var v;
    const y = e, b = R0(p);
    let w;
    const x = (v = y == null ? void 0 : y.vnode.el) == null ? void 0 : v.dataset.prefix;
    b && (w = dk({
      columns: n.store.states.columns.value
    }, b, x), w && (y == null || y.emit(`cell-${m}`, g, w, b, p))), y == null || y.emit(`row-${m}`, g, w, p);
  }, s = (p, g) => {
    r(p, g, "dblclick");
  }, o = (p, g) => {
    n.store.commit("setCurrentRow", g), r(p, g, "click");
  }, a = (p, g) => {
    r(p, g, "contextmenu");
  }, l = zo((p) => {
    n.store.commit("setHoverRow", p);
  }, 30), c = zo(() => {
    n.store.commit("setHoverRow", null);
  }, 30), u = (p) => {
    const g = window.getComputedStyle(p, null), m = Number.parseInt(g.paddingLeft, 10) || 0, v = Number.parseInt(g.paddingRight, 10) || 0, y = Number.parseInt(g.paddingTop, 10) || 0, b = Number.parseInt(g.paddingBottom, 10) || 0;
    return {
      left: m,
      right: v,
      top: y,
      bottom: b
    };
  }, h = (p, g, m) => {
    let v = g.target.parentNode;
    for (; p > 1 && (v = v == null ? void 0 : v.nextSibling, !(!v || v.nodeName !== "TR")); )
      m(v, "hover-row hover-fixed-row"), p--;
  };
  return {
    handleDoubleClick: s,
    handleClick: o,
    handleContextMenu: a,
    handleMouseEnter: l,
    handleMouseLeave: c,
    handleCellMouseEnter: (p, g, m) => {
      var v;
      const y = e, b = R0(p), w = (v = y == null ? void 0 : y.vnode.el) == null ? void 0 : v.dataset.prefix;
      if (b) {
        const N = dk({
          columns: n.store.states.columns.value
        }, b, w);
        b.rowSpan > 1 && h(b.rowSpan, p, pu);
        const q = y.hoverState = { cell: b, column: N, row: g };
        y == null || y.emit("cell-mouse-enter", q.row, q.column, q.cell, p);
      }
      if (!m)
        return;
      const x = p.target.querySelector(".cell");
      if (!(qc(x, `${w}-tooltip`) && x.childNodes.length))
        return;
      const S = document.createRange();
      S.setStart(x, 0), S.setEnd(x, x.childNodes.length);
      let C = S.getBoundingClientRect().width, k = S.getBoundingClientRect().height;
      C - Math.floor(C) < 1e-3 && (C = Math.floor(C)), k - Math.floor(k) < 1e-3 && (k = Math.floor(k));
      const { top: _, left: T, right: B, bottom: I } = u(x), P = T + B, A = _ + I;
      (C + P > x.offsetWidth || k + A > x.offsetHeight || x.scrollWidth > x.offsetWidth) && jG(m, b.innerText || b.textContent, b, y);
    },
    handleCellMouseLeave: (p) => {
      const g = R0(p);
      if (!g)
        return;
      g.rowSpan > 1 && h(g.rowSpan, p, Io);
      const m = e == null ? void 0 : e.hoverState;
      e == null || e.emit("cell-mouse-leave", m == null ? void 0 : m.row, m == null ? void 0 : m.column, m == null ? void 0 : m.cell, p);
    },
    tooltipContent: t,
    tooltipTrigger: i
  };
}
function uK(n) {
  const e = ke(yo), t = me("table");
  return {
    getRowStyle: (c, u) => {
      const h = e == null ? void 0 : e.props.rowStyle;
      return typeof h == "function" ? h.call(null, {
        row: c,
        rowIndex: u
      }) : h || null;
    },
    getRowClass: (c, u) => {
      const h = [t.e("row")];
      e != null && e.props.highlightCurrentRow && c === n.store.states.currentRow.value && h.push("current-row"), n.stripe && u % 2 === 1 && h.push(t.em("row", "striped"));
      const d = e == null ? void 0 : e.props.rowClassName;
      return typeof d == "string" ? h.push(d) : typeof d == "function" && h.push(d.call(null, {
        row: c,
        rowIndex: u
      })), h;
    },
    getCellStyle: (c, u, h, d) => {
      const f = e == null ? void 0 : e.props.cellStyle;
      let p = f ?? {};
      typeof f == "function" && (p = f.call(null, {
        rowIndex: c,
        columnIndex: u,
        row: h,
        column: d
      }));
      const g = Tw(u, n == null ? void 0 : n.fixed, n.store);
      return xu(g, "left"), xu(g, "right"), Object.assign({}, p, g);
    },
    getCellClass: (c, u, h, d, f) => {
      const p = $w(t.b(), u, n == null ? void 0 : n.fixed, n.store, void 0, f), g = [d.id, d.align, d.className, ...p], m = e == null ? void 0 : e.props.cellClassName;
      return typeof m == "string" ? g.push(m) : typeof m == "function" && g.push(m.call(null, {
        rowIndex: c,
        columnIndex: u,
        row: h,
        column: d
      })), g.push(t.e("cell")), g.filter((v) => !!v).join(" ");
    },
    getSpan: (c, u, h, d) => {
      let f = 1, p = 1;
      const g = e == null ? void 0 : e.props.spanMethod;
      if (typeof g == "function") {
        const m = g({
          row: c,
          column: u,
          rowIndex: h,
          columnIndex: d
        });
        Array.isArray(m) ? (f = m[0], p = m[1]) : typeof m == "object" && (f = m.rowspan, p = m.colspan);
      }
      return { rowspan: f, colspan: p };
    },
    getColspanRealWidth: (c, u, h) => {
      if (u < 1)
        return c[h].realWidth;
      const d = c.map(({ realWidth: f, width: p }) => f || p).slice(h, h + u);
      return Number(d.reduce((f, p) => Number(f) + Number(p), -1));
    }
  };
}
function hK(n) {
  const e = ke(yo), t = me("table"), {
    handleDoubleClick: i,
    handleClick: r,
    handleContextMenu: s,
    handleMouseEnter: o,
    handleMouseLeave: a,
    handleCellMouseEnter: l,
    handleCellMouseLeave: c,
    tooltipContent: u,
    tooltipTrigger: h
  } = cK(n), {
    getRowStyle: d,
    getRowClass: f,
    getCellStyle: p,
    getCellClass: g,
    getSpan: m,
    getColspanRealWidth: v
  } = uK(n), y = $(() => n.store.states.columns.value.findIndex(({ type: C }) => C === "default")), b = (C, k) => {
    const E = e.props.rowKey;
    return E ? wi(C, E) : k;
  }, w = (C, k, E, M = !1) => {
    const { tooltipEffect: _, tooltipOptions: T, store: B } = n, { indent: I, columns: P } = B.states, A = f(C, k);
    let N = !0;
    return E && (A.push(t.em("row", `level-${E.level}`)), N = E.display), Re("tr", {
      style: [N ? null : {
        display: "none"
      }, d(C, k)],
      class: A,
      key: b(C, k),
      onDblclick: (j) => i(j, C),
      onClick: (j) => r(j, C),
      onContextmenu: (j) => s(j, C),
      onMouseenter: () => o(k),
      onMouseleave: a
    }, P.value.map((j, H) => {
      const { rowspan: oe, colspan: te } = m(C, j, k, H);
      if (!oe || !te)
        return null;
      const W = Object.assign({}, j);
      W.realWidth = v(P.value, te, H);
      const U = {
        store: n.store,
        _self: n.context || e,
        column: W,
        row: C,
        $index: k,
        cellIndex: H,
        expanded: M
      };
      H === y.value && E && (U.treeNode = {
        indent: E.level * I.value,
        level: E.level
      }, typeof E.expanded == "boolean" && (U.treeNode.expanded = E.expanded, "loading" in E && (U.treeNode.loading = E.loading), "noLazyChildren" in E && (U.treeNode.noLazyChildren = E.noLazyChildren)));
      const ae = `${k},${H}`, he = W.columnKey || W.rawColumnKey || "", ee = x(H, j, U), pe = j.showOverflowTooltip && On({
        effect: _
      }, T, j.showOverflowTooltip);
      return Re("td", {
        style: p(k, H, C, j),
        class: g(k, H, C, j, te - 1),
        key: `${he}${ae}`,
        rowspan: oe,
        colspan: te,
        onMouseenter: (be) => l(be, C, pe),
        onMouseleave: c
      }, [ee]);
    }));
  }, x = (C, k, E) => k.renderCell(E);
  return {
    wrappedRowRender: (C, k) => {
      const E = n.store, { isRowExpanded: M, assertRowKey: _ } = E, { treeData: T, lazyTreeNodeMap: B, childrenColumnName: I, rowKey: P } = E.states, A = E.states.columns.value;
      if (A.some(({ type: q }) => q === "expand")) {
        const q = M(C), j = w(C, k, void 0, q), H = e.renderExpanded;
        return q ? H ? [
          [
            j,
            Re("tr", {
              key: `expanded-row__${j.key}`
            }, [
              Re("td", {
                colspan: A.length,
                class: `${t.e("cell")} ${t.e("expanded-cell")}`
              }, [H({ row: C, $index: k, store: E, expanded: q })])
            ])
          ]
        ] : (console.error("[Element Error]renderExpanded is required."), j) : [[j]];
      } else if (Object.keys(T.value).length) {
        _();
        const q = wi(C, P.value);
        let j = T.value[q], H = null;
        j && (H = {
          expanded: j.expanded,
          level: j.level,
          display: !0
        }, typeof j.lazy == "boolean" && (typeof j.loaded == "boolean" && j.loaded && (H.noLazyChildren = !(j.children && j.children.length)), H.loading = j.loading));
        const oe = [w(C, k, H)];
        if (j) {
          let te = 0;
          const W = (ae, he) => {
            ae && ae.length && he && ae.forEach((ee) => {
              const pe = {
                display: he.display && he.expanded,
                level: he.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, be = wi(ee, P.value);
              if (be == null)
                throw new Error("For nested data item, row-key is required.");
              if (j = { ...T.value[be] }, j && (pe.expanded = j.expanded, j.level = j.level || pe.level, j.display = !!(j.expanded && pe.display), typeof j.lazy == "boolean" && (typeof j.loaded == "boolean" && j.loaded && (pe.noLazyChildren = !(j.children && j.children.length)), pe.loading = j.loading)), te++, oe.push(w(ee, k + te, pe)), j) {
                const fe = B.value[be] || ee[I.value];
                W(fe, j);
              }
            });
          };
          j.display = !0;
          const U = B.value[q] || C[I.value];
          W(U, j);
        }
        return oe;
      } else
        return w(C, k, void 0);
    },
    tooltipContent: u,
    tooltipTrigger: h
  };
}
const dK = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var fK = F({
  name: "ElTableBody",
  props: dK,
  setup(n) {
    const e = Xe(), t = ke(yo), i = me("table"), { wrappedRowRender: r, tooltipContent: s, tooltipTrigger: o } = hK(n), { onColumnsChange: a, onScrollableChange: l } = H_(t), c = [];
    return ne(n.store.states.hoverRow, (u, h) => {
      var d;
      const f = e == null ? void 0 : e.vnode.el, p = Array.from((f == null ? void 0 : f.children) || []).filter((v) => v == null ? void 0 : v.classList.contains(`${i.e("row")}`));
      let g = u;
      const m = (d = p[g]) == null ? void 0 : d.childNodes;
      m != null && m.length ? Array.from(m).reduce((y, b, w) => {
        var x, S;
        const C = ((x = m[w - 1]) == null ? void 0 : x.colSpan) > 1, k = ((S = m[w + 1]) == null ? void 0 : S.colSpan) > 1;
        return b.nodeName !== "TD" && !C && !k && y.push(w), y;
      }, []).forEach((y) => {
        for (var b; g > 0; ) {
          const w = (b = p[g - 1]) == null ? void 0 : b.childNodes;
          if (w[y] && w[y].nodeName === "TD") {
            pu(w[y], "hover-cell"), c.push(w[y]);
            break;
          }
          g--;
        }
      }) : (c.forEach((v) => Io(v, "hover-cell")), c.length = 0), !(!n.store.states.isComplex.value || !vt) && iw(() => {
        const v = p[h], y = p[u];
        v && !v.classList.contains("hover-fixed-row") && Io(v, "hover-row"), y && pu(y, "hover-row");
      });
    }), Gu(() => {
      var u;
      (u = Dr) == null || u();
    }), {
      ns: i,
      onColumnsChange: a,
      onScrollableChange: l,
      wrappedRowRender: r,
      tooltipContent: s,
      tooltipTrigger: o
    };
  },
  render() {
    const { wrappedRowRender: n, store: e } = this, t = e.states.data.value || [];
    return Re("tbody", { tabIndex: -1 }, [
      t.reduce((i, r) => i.concat(n(r, i.length)), [])
    ]);
  }
});
function pK() {
  const n = ke(yo), e = n == null ? void 0 : n.store, t = $(() => e.states.fixedLeafColumnsLength.value), i = $(() => e.states.rightFixedColumns.value.length), r = $(() => e.states.columns.value.length), s = $(() => e.states.fixedColumns.value.length), o = $(() => e.states.rightFixedColumns.value.length);
  return {
    leftFixedLeafCount: t,
    rightFixedLeafCount: i,
    columnsCount: r,
    leftFixedCount: s,
    rightFixedCount: o,
    columns: e.states.columns
  };
}
function gK(n) {
  const { columns: e } = pK(), t = me("table");
  return {
    getCellClasses: (s, o) => {
      const a = s[o], l = [
        t.e("cell"),
        a.id,
        a.align,
        a.labelClassName,
        ...$w(t.b(), o, a.fixed, n.store)
      ];
      return a.className && l.push(a.className), a.children || l.push(t.is("leaf")), l;
    },
    getCellStyles: (s, o) => {
      const a = Tw(o, s.fixed, n.store);
      return xu(a, "left"), xu(a, "right"), a;
    },
    columns: e
  };
}
var mK = F({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(n) {
    const { getCellClasses: e, getCellStyles: t, columns: i } = gK(n);
    return {
      ns: me("table"),
      getCellClasses: e,
      getCellStyles: t,
      columns: i
    };
  },
  render() {
    const { columns: n, getCellStyles: e, getCellClasses: t, summaryMethod: i, sumText: r } = this, s = this.store.states.data.value;
    let o = [];
    return i ? o = i({
      columns: n,
      data: s
    }) : n.forEach((a, l) => {
      if (l === 0) {
        o[l] = r;
        return;
      }
      const c = s.map((f) => Number(f[a.property])), u = [];
      let h = !0;
      c.forEach((f) => {
        if (!Number.isNaN(+f)) {
          h = !1;
          const p = `${f}`.split(".")[1];
          u.push(p ? p.length : 0);
        }
      });
      const d = Math.max.apply(null, u);
      h ? o[l] = "" : o[l] = c.reduce((f, p) => {
        const g = Number(p);
        return Number.isNaN(+g) ? f : Number.parseFloat((f + p).toFixed(Math.min(d, 20)));
      }, 0);
    }), Re(Re("tfoot", [
      Re("tr", {}, [
        ...n.map((a, l) => Re("td", {
          key: l,
          colspan: a.colSpan,
          rowspan: a.rowSpan,
          class: t(n, l),
          style: e(a, l)
        }, [
          Re("div", {
            class: ["cell", a.labelClassName]
          }, [o[l]])
        ]))
      ])
    ]));
  }
});
function vK(n) {
  return {
    setCurrentRow: (u) => {
      n.commit("setCurrentRow", u);
    },
    getSelectionRows: () => n.getSelectionRows(),
    toggleRowSelection: (u, h) => {
      n.toggleRowSelection(u, h, !1), n.updateAllSelected();
    },
    clearSelection: () => {
      n.clearSelection();
    },
    clearFilter: (u) => {
      n.clearFilter(u);
    },
    toggleAllSelection: () => {
      n.commit("toggleAllSelection");
    },
    toggleRowExpansion: (u, h) => {
      n.toggleRowExpansionAdapter(u, h);
    },
    clearSort: () => {
      n.clearSort();
    },
    sort: (u, h) => {
      n.commit("sort", { prop: u, order: h });
    }
  };
}
function bK(n, e, t, i) {
  const r = D(!1), s = D(null), o = D(!1), a = (j) => {
    o.value = j;
  }, l = D({
    width: null,
    height: null,
    headerHeight: null
  }), c = D(!1), u = {
    display: "inline-block",
    verticalAlign: "middle"
  }, h = D(), d = D(0), f = D(0), p = D(0), g = D(0), m = D(0);
  Fr(() => {
    e.setHeight(n.height);
  }), Fr(() => {
    e.setMaxHeight(n.maxHeight);
  }), ne(() => [n.currentRowKey, t.states.rowKey], ([j, H]) => {
    !O(H) || !O(j) || t.setCurrentRowKey(`${j}`);
  }, {
    immediate: !0
  }), ne(() => n.data, (j) => {
    i.store.commit("setData", j);
  }, {
    immediate: !0,
    deep: !0
  }), Fr(() => {
    n.expandRowKeys && t.setExpandRowKeysAdapter(n.expandRowKeys);
  });
  const v = () => {
    i.store.commit("setHoverRow", null), i.hoverState && (i.hoverState = null);
  }, y = (j, H) => {
    const { pixelX: oe, pixelY: te } = H;
    Math.abs(oe) >= Math.abs(te) && (i.refs.bodyWrapper.scrollLeft += H.pixelX / 5);
  }, b = $(() => n.height || n.maxHeight || t.states.fixedColumns.value.length > 0 || t.states.rightFixedColumns.value.length > 0), w = $(() => ({
    width: e.bodyWidth.value ? `${e.bodyWidth.value}px` : ""
  })), x = () => {
    b.value && e.updateElsHeight(), e.updateColumnsWidth(), requestAnimationFrame(E);
  };
  qe(async () => {
    await $e(), t.updateColumns(), M(), requestAnimationFrame(x);
    const j = i.vnode.el, H = i.refs.headerWrapper;
    n.flexible && j && j.parentElement && (j.parentElement.style.minWidth = "0"), l.value = {
      width: h.value = j.offsetWidth,
      height: j.offsetHeight,
      headerHeight: n.showHeader && H ? H.offsetHeight : null
    }, t.states.columns.value.forEach((oe) => {
      oe.filteredValue && oe.filteredValue.length && i.store.commit("filterChange", {
        column: oe,
        values: oe.filteredValue,
        silent: !0
      });
    }), i.$ready = !0;
  });
  const S = (j, H) => {
    if (!j)
      return;
    const oe = Array.from(j.classList).filter((te) => !te.startsWith("is-scrolling-"));
    oe.push(e.scrollX.value ? H : "is-scrolling-none"), j.className = oe.join(" ");
  }, C = (j) => {
    const { tableWrapper: H } = i.refs;
    S(H, j);
  }, k = (j) => {
    const { tableWrapper: H } = i.refs;
    return !!(H && H.classList.contains(j));
  }, E = function() {
    if (!i.refs.scrollBarRef)
      return;
    if (!e.scrollX.value) {
      const he = "is-scrolling-none";
      k(he) || C(he);
      return;
    }
    const j = i.refs.scrollBarRef.wrapRef;
    if (!j)
      return;
    const { scrollLeft: H, offsetWidth: oe, scrollWidth: te } = j, { headerWrapper: W, footerWrapper: U } = i.refs;
    W && (W.scrollLeft = H), U && (U.scrollLeft = H);
    const ae = te - oe - 1;
    H >= ae ? C("is-scrolling-right") : C(H === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, M = () => {
    i.refs.scrollBarRef && (i.refs.scrollBarRef.wrapRef && qi(i.refs.scrollBarRef.wrapRef, "scroll", E, {
      passive: !0
    }), n.fit ? pn(i.vnode.el, _) : qi(window, "resize", _), pn(i.refs.bodyWrapper, () => {
      var j, H;
      _(), (H = (j = i.refs) == null ? void 0 : j.scrollBarRef) == null || H.update();
    }));
  }, _ = () => {
    var j, H, oe, te;
    const W = i.vnode.el;
    if (!i.$ready || !W)
      return;
    let U = !1;
    const {
      width: ae,
      height: he,
      headerHeight: ee
    } = l.value, pe = h.value = W.offsetWidth;
    ae !== pe && (U = !0);
    const be = W.offsetHeight;
    (n.height || b.value) && he !== be && (U = !0);
    const fe = n.tableLayout === "fixed" ? i.refs.headerWrapper : (j = i.refs.tableHeaderRef) == null ? void 0 : j.$el;
    n.showHeader && (fe == null ? void 0 : fe.offsetHeight) !== ee && (U = !0), d.value = ((H = i.refs.tableWrapper) == null ? void 0 : H.scrollHeight) || 0, p.value = (fe == null ? void 0 : fe.scrollHeight) || 0, g.value = ((oe = i.refs.footerWrapper) == null ? void 0 : oe.offsetHeight) || 0, m.value = ((te = i.refs.appendWrapper) == null ? void 0 : te.offsetHeight) || 0, f.value = d.value - p.value - g.value - m.value, U && (l.value = {
      width: pe,
      height: be,
      headerHeight: n.showHeader && (fe == null ? void 0 : fe.offsetHeight) || 0
    }, x());
  }, T = Yi(), B = $(() => {
    const { bodyWidth: j, scrollY: H, gutterWidth: oe } = e;
    return j.value ? `${j.value - (H.value ? oe : 0)}px` : "";
  }), I = $(() => n.maxHeight ? "fixed" : n.tableLayout), P = $(() => {
    if (n.data && n.data.length)
      return null;
    let j = "100%";
    n.height && f.value && (j = `${f.value}px`);
    const H = h.value;
    return {
      width: H ? `${H}px` : "",
      height: j
    };
  }), A = $(() => n.height ? {
    height: Number.isNaN(Number(n.height)) ? n.height : `${n.height}px`
  } : n.maxHeight ? {
    maxHeight: Number.isNaN(Number(n.maxHeight)) ? n.maxHeight : `${n.maxHeight}px`
  } : {}), N = $(() => n.height ? {
    height: "100%"
  } : n.maxHeight ? Number.isNaN(Number(n.maxHeight)) ? {
    maxHeight: `calc(${n.maxHeight} - ${p.value + g.value}px)`
  } : {
    maxHeight: `${n.maxHeight - p.value - g.value}px`
  } : {});
  return {
    isHidden: r,
    renderExpanded: s,
    setDragVisible: a,
    isGroup: c,
    handleMouseLeave: v,
    handleHeaderFooterMousewheel: y,
    tableSize: T,
    emptyBlockStyle: P,
    handleFixedMousewheel: (j, H) => {
      const oe = i.refs.bodyWrapper;
      if (Math.abs(H.spinY) > 0) {
        const te = oe.scrollTop;
        H.pixelY < 0 && te !== 0 && j.preventDefault(), H.pixelY > 0 && oe.scrollHeight - oe.clientHeight > te && j.preventDefault(), oe.scrollTop += Math.ceil(H.pixelY / 5);
      } else
        oe.scrollLeft += Math.ceil(H.pixelX / 5);
    },
    resizeProxyVisible: o,
    bodyWidth: B,
    resizeState: l,
    doLayout: x,
    tableBodyStyles: w,
    tableLayout: I,
    scrollbarViewStyle: u,
    tableInnerStyle: A,
    scrollbarStyle: N
  };
}
function yK(n) {
  const e = D(), t = () => {
    const r = n.vnode.el.querySelector(".hidden-columns"), s = { childList: !0, subtree: !0 }, o = n.store.states.updateOrderFns;
    e.value = new MutationObserver(() => {
      o.forEach((a) => a());
    }), e.value.observe(r, s);
  };
  qe(() => {
    t();
  }), Gu(() => {
    var i;
    (i = e.value) == null || i.disconnect();
  });
}
var OK = {
  data: {
    type: Array,
    default: () => []
  },
  size: _r,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  },
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object]
};
function Y_(n) {
  const e = n.tableLayout === "auto";
  let t = n.columns || [];
  e && t.every((r) => r.width === void 0) && (t = []);
  const i = (r) => {
    const s = {
      key: `${n.tableLayout}_${r.id}`,
      style: {},
      name: void 0
    };
    return e ? s.style = {
      width: `${r.width}px`
    } : s.name = r.id, s;
  };
  return Re("colgroup", {}, t.map((r) => Re("col", i(r))));
}
Y_.props = ["columns", "tableLayout"];
const wK = () => {
  const n = D(), e = (s, o) => {
    const a = n.value;
    a && a.scrollTo(s, o);
  }, t = (s, o) => {
    const a = n.value;
    a && tt(o) && ["Top", "Left"].includes(s) && a[`setScroll${s}`](o);
  };
  return {
    scrollBarRef: n,
    scrollTo: e,
    setScrollTop: (s) => t("Top", s),
    setScrollLeft: (s) => t("Left", s)
  };
};
let xK = 1;
const SK = F({
  name: "ElTable",
  directives: {
    Mousewheel: bW
  },
  components: {
    TableHeader: lK,
    TableBody: fK,
    TableFooter: mK,
    ElScrollbar: _f,
    hColgroup: Y_
  },
  props: OK,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(n) {
    const { t: e } = mn(), t = me("table"), i = Xe();
    ft(yo, i);
    const r = XG(i, n);
    i.store = r;
    const s = new UG({
      store: i.store,
      table: i,
      fit: n.fit,
      showHeader: n.showHeader
    });
    i.layout = s;
    const o = $(() => (r.states.data.value || []).length === 0), {
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: c,
      clearSelection: u,
      clearFilter: h,
      toggleAllSelection: d,
      toggleRowExpansion: f,
      clearSort: p,
      sort: g
    } = vK(r), {
      isHidden: m,
      renderExpanded: v,
      setDragVisible: y,
      isGroup: b,
      handleMouseLeave: w,
      handleHeaderFooterMousewheel: x,
      tableSize: S,
      emptyBlockStyle: C,
      handleFixedMousewheel: k,
      resizeProxyVisible: E,
      bodyWidth: M,
      resizeState: _,
      doLayout: T,
      tableBodyStyles: B,
      tableLayout: I,
      scrollbarViewStyle: P,
      tableInnerStyle: A,
      scrollbarStyle: N
    } = bK(n, s, r, i), { scrollBarRef: q, scrollTo: j, setScrollLeft: H, setScrollTop: oe } = wK(), te = zo(T, 50), W = `${t.namespace.value}-table_${xK++}`;
    i.tableId = W, i.state = {
      isGroup: b,
      resizeState: _,
      doLayout: T,
      debouncedUpdateLayout: te
    };
    const U = $(() => n.sumText || e("el.table.sumText")), ae = $(() => n.emptyText || e("el.table.emptyText"));
    return yK(i), {
      ns: t,
      layout: s,
      store: r,
      handleHeaderFooterMousewheel: x,
      handleMouseLeave: w,
      tableId: W,
      tableSize: S,
      isHidden: m,
      isEmpty: o,
      renderExpanded: v,
      resizeProxyVisible: E,
      resizeState: _,
      isGroup: b,
      bodyWidth: M,
      tableBodyStyles: B,
      emptyBlockStyle: C,
      debouncedUpdateLayout: te,
      handleFixedMousewheel: k,
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: c,
      clearSelection: u,
      clearFilter: h,
      toggleAllSelection: d,
      toggleRowExpansion: f,
      clearSort: p,
      doLayout: T,
      sort: g,
      t: e,
      setDragVisible: y,
      context: i,
      computedSumText: U,
      computedEmptyText: ae,
      tableLayout: I,
      scrollbarViewStyle: P,
      tableInnerStyle: A,
      scrollbarStyle: N,
      scrollBarRef: q,
      scrollTo: j,
      setScrollLeft: H,
      setScrollTop: oe
    };
  }
}), CK = ["data-prefix"], kK = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function PK(n, e, t, i, r, s) {
  const o = nt("hColgroup"), a = nt("table-header"), l = nt("table-body"), c = nt("table-footer"), u = nt("el-scrollbar"), h = nv("mousewheel");
  return R(), V("div", {
    ref: "tableWrapper",
    class: L([
      {
        [n.ns.m("fit")]: n.fit,
        [n.ns.m("striped")]: n.stripe,
        [n.ns.m("border")]: n.border || n.isGroup,
        [n.ns.m("hidden")]: n.isHidden,
        [n.ns.m("group")]: n.isGroup,
        [n.ns.m("fluid-height")]: n.maxHeight,
        [n.ns.m("scrollable-x")]: n.layout.scrollX.value,
        [n.ns.m("scrollable-y")]: n.layout.scrollY.value,
        [n.ns.m("enable-row-hover")]: !n.store.states.isComplex.value,
        [n.ns.m("enable-row-transition")]: (n.store.states.data.value || []).length !== 0 && (n.store.states.data.value || []).length < 100,
        "has-footer": n.showSummary
      },
      n.ns.m(n.tableSize),
      n.className,
      n.ns.b(),
      n.ns.m(`layout-${n.tableLayout}`)
    ]),
    style: Qe(n.style),
    "data-prefix": n.ns.namespace.value,
    onMouseleave: e[0] || (e[0] = (...d) => n.handleMouseLeave && n.handleMouseLeave(...d))
  }, [
    Z("div", {
      class: L(n.ns.e("inner-wrapper")),
      style: Qe(n.tableInnerStyle)
    }, [
      Z("div", kK, [
        de(n.$slots, "default")
      ], 512),
      n.showHeader && n.tableLayout === "fixed" ? it((R(), V("div", {
        key: 0,
        ref: "headerWrapper",
        class: L(n.ns.e("header-wrapper"))
      }, [
        Z("table", {
          ref: "tableHeader",
          class: L(n.ns.e("header")),
          style: Qe(n.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          K(o, {
            columns: n.store.states.columns.value,
            "table-layout": n.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          K(a, {
            ref: "tableHeaderRef",
            border: n.border,
            "default-sort": n.defaultSort,
            store: n.store,
            onSetDragVisible: n.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [h, n.handleHeaderFooterMousewheel]
      ]) : G("v-if", !0),
      Z("div", {
        ref: "bodyWrapper",
        class: L(n.ns.e("body-wrapper"))
      }, [
        K(u, {
          ref: "scrollBarRef",
          "view-style": n.scrollbarViewStyle,
          "wrap-style": n.scrollbarStyle,
          always: n.scrollbarAlwaysOn
        }, {
          default: Y(() => [
            Z("table", {
              ref: "tableBody",
              class: L(n.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: Qe({
                width: n.bodyWidth,
                tableLayout: n.tableLayout
              })
            }, [
              K(o, {
                columns: n.store.states.columns.value,
                "table-layout": n.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              n.showHeader && n.tableLayout === "auto" ? (R(), ie(a, {
                key: 0,
                ref: "tableHeaderRef",
                class: L(n.ns.e("body-header")),
                border: n.border,
                "default-sort": n.defaultSort,
                store: n.store,
                onSetDragVisible: n.setDragVisible
              }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : G("v-if", !0),
              K(l, {
                context: n.context,
                highlight: n.highlightCurrentRow,
                "row-class-name": n.rowClassName,
                "tooltip-effect": n.tooltipEffect,
                "tooltip-options": n.tooltipOptions,
                "row-style": n.rowStyle,
                store: n.store,
                stripe: n.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
              n.showSummary && n.tableLayout === "auto" ? (R(), ie(c, {
                key: 1,
                class: L(n.ns.e("body-footer")),
                border: n.border,
                "default-sort": n.defaultSort,
                store: n.store,
                "sum-text": n.computedSumText,
                "summary-method": n.summaryMethod
              }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : G("v-if", !0)
            ], 6),
            n.isEmpty ? (R(), V("div", {
              key: 0,
              ref: "emptyBlock",
              style: Qe(n.emptyBlockStyle),
              class: L(n.ns.e("empty-block"))
            }, [
              Z("span", {
                class: L(n.ns.e("empty-text"))
              }, [
                de(n.$slots, "empty", {}, () => [
                  Yn(xe(n.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : G("v-if", !0),
            n.$slots.append ? (R(), V("div", {
              key: 1,
              ref: "appendWrapper",
              class: L(n.ns.e("append-wrapper"))
            }, [
              de(n.$slots, "append")
            ], 2)) : G("v-if", !0)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      n.showSummary && n.tableLayout === "fixed" ? it((R(), V("div", {
        key: 1,
        ref: "footerWrapper",
        class: L(n.ns.e("footer-wrapper"))
      }, [
        Z("table", {
          class: L(n.ns.e("footer")),
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: Qe(n.tableBodyStyles)
        }, [
          K(o, {
            columns: n.store.states.columns.value,
            "table-layout": n.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          K(c, {
            border: n.border,
            "default-sort": n.defaultSort,
            store: n.store,
            "sum-text": n.computedSumText,
            "summary-method": n.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
        ], 6)
      ], 2)), [
        [Qt, !n.isEmpty],
        [h, n.handleHeaderFooterMousewheel]
      ]) : G("v-if", !0),
      n.border || n.isGroup ? (R(), V("div", {
        key: 2,
        class: L(n.ns.e("border-left-patch"))
      }, null, 2)) : G("v-if", !0)
    ], 6),
    it(Z("div", {
      ref: "resizeProxy",
      class: L(n.ns.e("column-resize-proxy"))
    }, null, 2), [
      [Qt, n.resizeProxyVisible]
    ])
  ], 46, CK);
}
var EK = /* @__PURE__ */ Ce(SK, [["render", PK], ["__file", "table.vue"]]);
const AK = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, $K = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, TK = (n) => AK[n] || "", _K = {
  selection: {
    renderHeader({ store: n, column: e }) {
      function t() {
        return n.states.data.value && n.states.data.value.length === 0;
      }
      return Re(fo, {
        disabled: t(),
        size: n.states.tableSize.value,
        indeterminate: n.states.selection.value.length > 0 && !n.states.isAllSelected.value,
        "onUpdate:modelValue": n.toggleAllSelection,
        modelValue: n.states.isAllSelected.value,
        ariaLabel: e.label
      });
    },
    renderCell({
      row: n,
      column: e,
      store: t,
      $index: i
    }) {
      return Re(fo, {
        disabled: e.selectable ? !e.selectable.call(null, n, i) : !1,
        size: t.states.tableSize.value,
        onChange: () => {
          t.commit("rowSelectedChanged", n);
        },
        onClick: (r) => r.stopPropagation(),
        modelValue: t.isSelected(n),
        ariaLabel: e.label
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({ column: n }) {
      return n.label || "#";
    },
    renderCell({
      column: n,
      $index: e
    }) {
      let t = e + 1;
      const i = n.index;
      return typeof i == "number" ? t = e + i : typeof i == "function" && (t = i(e)), Re("div", {}, [t]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({ column: n }) {
      return n.label || "";
    },
    renderCell({
      row: n,
      store: e,
      expanded: t
    }) {
      const { ns: i } = e, r = [i.e("expand-icon")];
      return t && r.push(i.em("expand-icon", "expanded")), Re("div", {
        class: r,
        onClick: function(o) {
          o.stopPropagation(), e.toggleRowExpansion(n);
        }
      }, {
        default: () => [
          Re(Fe, null, {
            default: () => [Re(ac)]
          })
        ]
      });
    },
    sortable: !1,
    resizable: !1
  }
};
function MK({
  row: n,
  column: e,
  $index: t
}) {
  var i;
  const r = e.property, s = r && tg(n, r).value;
  return e && e.formatter ? e.formatter(n, e, s, t) : ((i = s == null ? void 0 : s.toString) == null ? void 0 : i.call(s)) || "";
}
function RK({
  row: n,
  treeNode: e,
  store: t
}, i = !1) {
  const { ns: r } = t;
  if (!e)
    return i ? [
      Re("span", {
        class: r.e("placeholder")
      })
    ] : null;
  const s = [], o = function(a) {
    a.stopPropagation(), !e.loading && t.loadOrToggle(n);
  };
  if (e.indent && s.push(Re("span", {
    class: r.e("indent"),
    style: { "padding-left": `${e.indent}px` }
  })), typeof e.expanded == "boolean" && !e.noLazyChildren) {
    const a = [
      r.e("expand-icon"),
      e.expanded ? r.em("expand-icon", "expanded") : ""
    ];
    let l = ac;
    e.loading && (l = lc), s.push(Re("div", {
      class: a,
      onClick: o
    }, {
      default: () => [
        Re(Fe, { class: { [r.is("loading")]: e.loading } }, {
          default: () => [Re(l)]
        })
      ]
    }));
  } else
    s.push(Re("span", {
      class: r.e("placeholder")
    }));
  return s;
}
function gk(n, e) {
  return n.reduce((t, i) => (t[i] = i, t), e);
}
function NK(n, e) {
  const t = Xe();
  return {
    registerComplexWatchers: () => {
      const s = ["fixed"], o = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, a = gk(s, o);
      Object.keys(a).forEach((l) => {
        const c = o[l];
        Xi(e, c) && ne(() => e[c], (u) => {
          let h = u;
          c === "width" && l === "realWidth" && (h = Aw(u)), c === "minWidth" && l === "realMinWidth" && (h = V_(u)), t.columnConfig.value[c] = h, t.columnConfig.value[l] = h;
          const d = c === "fixed";
          n.value.store.scheduleLayout(d);
        });
      });
    },
    registerNormalWatchers: () => {
      const s = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "filterClassName",
        "showOverflowTooltip"
      ], o = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, a = gk(s, o);
      Object.keys(a).forEach((l) => {
        const c = o[l];
        Xi(e, c) && ne(() => e[c], (u) => {
          t.columnConfig.value[l] = u;
        });
      });
    }
  };
}
function DK(n, e, t) {
  const i = Xe(), r = D(""), s = D(!1), o = D(), a = D(), l = me("table");
  Fr(() => {
    o.value = n.align ? `is-${n.align}` : null, o.value;
  }), Fr(() => {
    a.value = n.headerAlign ? `is-${n.headerAlign}` : o.value, a.value;
  });
  const c = $(() => {
    let w = i.vnode.vParent || i.parent;
    for (; w && !w.tableId && !w.columnId; )
      w = w.vnode.vParent || w.parent;
    return w;
  }), u = $(() => {
    const { store: w } = i.parent;
    if (!w)
      return !1;
    const { treeData: x } = w.states, S = x.value;
    return S && Object.keys(S).length > 0;
  }), h = D(Aw(n.width)), d = D(V_(n.minWidth)), f = (w) => (h.value && (w.width = h.value), d.value && (w.minWidth = d.value), !h.value && d.value && (w.width = void 0), w.minWidth || (w.minWidth = 80), w.realWidth = Number(w.width === void 0 ? w.minWidth : w.width), w), p = (w) => {
    const x = w.type, S = _K[x] || {};
    Object.keys(S).forEach((k) => {
      const E = S[k];
      k !== "className" && E !== void 0 && (w[k] = E);
    });
    const C = TK(x);
    if (C) {
      const k = `${O(l.namespace)}-${C}`;
      w.className = w.className ? `${w.className} ${k}` : k;
    }
    return w;
  }, g = (w) => {
    Array.isArray(w) ? w.forEach((S) => x(S)) : x(w);
    function x(S) {
      var C;
      ((C = S == null ? void 0 : S.type) == null ? void 0 : C.name) === "ElTableColumn" && (S.vParent = i);
    }
  };
  return {
    columnId: r,
    realAlign: o,
    isSubColumn: s,
    realHeaderAlign: a,
    columnOrTableParent: c,
    setColumnWidth: f,
    setColumnForcedProps: p,
    setColumnRenders: (w) => {
      n.renderHeader ? pt("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : w.type !== "selection" && (w.renderHeader = (S) => (i.columnConfig.value.label, de(e, "header", S, () => [w.label])));
      let x = w.renderCell;
      return w.type === "expand" ? (w.renderCell = (S) => Re("div", {
        class: "cell"
      }, [x(S)]), t.value.renderExpanded = (S) => e.default ? e.default(S) : e.default) : (x = x || MK, w.renderCell = (S) => {
        let C = null;
        if (e.default) {
          const B = e.default(S);
          C = B.some((I) => I.type !== wA) ? B : x(S);
        } else
          C = x(S);
        const { columns: k } = t.value.store.states, E = k.value.findIndex((B) => B.type === "default"), M = u.value && S.cellIndex === E, _ = RK(S, M), T = {
          class: "cell",
          style: {}
        };
        return w.showOverflowTooltip && (T.class = `${T.class} ${O(l.namespace)}-tooltip`, T.style = {
          width: `${(S.column.realWidth || Number(S.column.width)) - 1}px`
        }), g(C), Re("div", T, [_, C]);
      }), w;
    },
    getPropsData: (...w) => w.reduce((x, S) => (Array.isArray(S) && S.forEach((C) => {
      x[C] = n[C];
    }), x), {}),
    getColumnElIndex: (w, x) => Array.prototype.indexOf.call(w, x),
    updateColumnOrder: () => {
      t.value.store.commit("updateColumnOrder", i.columnConfig.value);
    }
  };
}
var LK = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  filterClassName: String,
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (n) => n.every((e) => ["ascending", "descending", null].includes(e))
  }
};
let IK = 1;
var U_ = F({
  name: "ElTableColumn",
  components: {
    ElCheckbox: fo
  },
  props: LK,
  setup(n, { slots: e }) {
    const t = Xe(), i = D({}), r = $(() => {
      let b = t.parent;
      for (; b && !b.tableId; )
        b = b.parent;
      return b;
    }), { registerNormalWatchers: s, registerComplexWatchers: o } = NK(r, n), {
      columnId: a,
      isSubColumn: l,
      realHeaderAlign: c,
      columnOrTableParent: u,
      setColumnWidth: h,
      setColumnForcedProps: d,
      setColumnRenders: f,
      getPropsData: p,
      getColumnElIndex: g,
      realAlign: m,
      updateColumnOrder: v
    } = DK(n, e, r), y = u.value;
    a.value = `${y.tableId || y.columnId}_column_${IK++}`, D1(() => {
      l.value = r.value !== y;
      const b = n.type || "default", w = n.sortable === "" ? !0 : n.sortable, x = Ci(n.showOverflowTooltip) ? y.props.showOverflowTooltip : n.showOverflowTooltip, S = {
        ...$K[b],
        id: a.value,
        type: b,
        property: n.prop || n.property,
        align: m,
        headerAlign: c,
        showOverflowTooltip: x,
        filterable: n.filters || n.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        filterClassName: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: w,
        index: n.index,
        rawColumnKey: t.vnode.key
      };
      let _ = p([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement",
        "filterClassName"
      ]);
      _ = IG(S, _), _ = QG(f, h, d)(_), i.value = _, s(), o();
    }), qe(() => {
      var b;
      const w = u.value, x = l.value ? w.vnode.el.children : (b = w.refs.hiddenColumns) == null ? void 0 : b.children, S = () => g(x || [], t.vnode.el);
      i.value.getColumnIndex = S, S() > -1 && r.value.store.commit("insertColumn", i.value, l.value ? w.columnConfig.value : null, v);
    }), Kn(() => {
      r.value.store.commit("removeColumn", i.value, l.value ? y.columnConfig.value : null, v);
    }), t.columnId = a.value, t.columnConfig = i;
  },
  render() {
    var n, e, t;
    try {
      const i = (e = (n = this.$slots).default) == null ? void 0 : e.call(n, {
        row: {},
        column: {},
        $index: -1
      }), r = [];
      if (Array.isArray(i))
        for (const o of i)
          ((t = o.type) == null ? void 0 : t.name) === "ElTableColumn" || o.shapeFlag & 2 ? r.push(o) : o.type === Tt && Array.isArray(o.children) && o.children.forEach((a) => {
            (a == null ? void 0 : a.patchFlag) !== 1024 && !bt(a == null ? void 0 : a.children) && r.push(a);
          });
      return Re("div", r);
    } catch {
      return Re("div", []);
    }
  }
});
const zKe = Ft(EK, {
  TableColumn: U_
}), jKe = As(U_), Sv = Symbol("tabsRootContextKey"), BK = Ee({
  tabs: {
    type: ce(Array),
    default: () => Ur([])
  }
}), G_ = "ElTabBar", QK = F({
  name: G_
}), zK = /* @__PURE__ */ F({
  ...QK,
  props: BK,
  setup(n, { expose: e }) {
    const t = n, i = Xe(), r = ke(Sv);
    r || dr(G_, "<el-tabs><el-tab-bar /></el-tabs>");
    const s = me("tabs"), o = D(), a = D(), l = () => {
      let u = 0, h = 0;
      const d = ["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height", f = d === "width" ? "x" : "y", p = f === "x" ? "left" : "top";
      return t.tabs.every((g) => {
        var m, v;
        const y = (v = (m = i.parent) == null ? void 0 : m.refs) == null ? void 0 : v[`tab-${g.uid}`];
        if (!y)
          return !1;
        if (!g.active)
          return !0;
        u = y[`offset${Xs(p)}`], h = y[`client${Xs(d)}`];
        const b = window.getComputedStyle(y);
        return d === "width" && (t.tabs.length > 1 && (h -= Number.parseFloat(b.paddingLeft) + Number.parseFloat(b.paddingRight)), u += Number.parseFloat(b.paddingLeft)), !1;
      }), {
        [d]: `${h}px`,
        transform: `translate${Xs(f)}(${u}px)`
      };
    }, c = () => a.value = l();
    return ne(() => t.tabs, async () => {
      await $e(), c();
    }, { immediate: !0 }), pn(o, () => c()), e({
      ref: o,
      update: c
    }), (u, h) => (R(), V("div", {
      ref_key: "barRef",
      ref: o,
      class: L([O(s).e("active-bar"), O(s).is(O(r).props.tabPosition)]),
      style: Qe(a.value)
    }, null, 6));
  }
});
var jK = /* @__PURE__ */ Ce(zK, [["__file", "tab-bar.vue"]]);
const VK = Ee({
  panes: {
    type: ce(Array),
    default: () => Ur([])
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean
}), FK = {
  tabClick: (n, e, t) => t instanceof Event,
  tabRemove: (n, e) => e instanceof Event
}, mk = "ElTabNav", ZK = F({
  name: mk,
  props: VK,
  emits: FK,
  setup(n, {
    expose: e,
    emit: t
  }) {
    const i = Xe(), r = ke(Sv);
    r || dr(mk, "<el-tabs><tab-nav /></el-tabs>");
    const s = me("tabs"), o = EF(), a = jF(), l = D(), c = D(), u = D(), h = D(), d = D(!1), f = D(0), p = D(!1), g = D(!0), m = $(() => ["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height"), v = $(() => ({
      transform: `translate${m.value === "width" ? "X" : "Y"}(-${f.value}px)`
    })), y = () => {
      if (!l.value)
        return;
      const E = l.value[`offset${Xs(m.value)}`], M = f.value;
      if (!M)
        return;
      const _ = M > E ? M - E : 0;
      f.value = _;
    }, b = () => {
      if (!l.value || !c.value)
        return;
      const E = c.value[`offset${Xs(m.value)}`], M = l.value[`offset${Xs(m.value)}`], _ = f.value;
      if (E - _ <= M)
        return;
      const T = E - _ > M * 2 ? _ + M : E - M;
      f.value = T;
    }, w = async () => {
      const E = c.value;
      if (!d.value || !u.value || !l.value || !E)
        return;
      await $e();
      const M = u.value.querySelector(".is-active");
      if (!M)
        return;
      const _ = l.value, T = ["top", "bottom"].includes(r.props.tabPosition), B = M.getBoundingClientRect(), I = _.getBoundingClientRect(), P = T ? E.offsetWidth - I.width : E.offsetHeight - I.height, A = f.value;
      let N = A;
      T ? (B.left < I.left && (N = A - (I.left - B.left)), B.right > I.right && (N = A + B.right - I.right)) : (B.top < I.top && (N = A - (I.top - B.top)), B.bottom > I.bottom && (N = A + (B.bottom - I.bottom))), N = Math.max(N, 0), f.value = Math.min(N, P);
    }, x = () => {
      var E;
      if (!c.value || !l.value)
        return;
      n.stretch && ((E = h.value) == null || E.update());
      const M = c.value[`offset${Xs(m.value)}`], _ = l.value[`offset${Xs(m.value)}`], T = f.value;
      _ < M ? (d.value = d.value || {}, d.value.prev = T, d.value.next = T + _ < M, M - T < _ && (f.value = M - _)) : (d.value = !1, T > 0 && (f.value = 0));
    }, S = (E) => {
      const M = E.code, {
        up: _,
        down: T,
        left: B,
        right: I
      } = dt;
      if (![_, T, B, I].includes(M))
        return;
      const P = Array.from(E.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)")), A = P.indexOf(E.target);
      let N;
      M === B || M === _ ? A === 0 ? N = P.length - 1 : N = A - 1 : A < P.length - 1 ? N = A + 1 : N = 0, P[N].focus({
        preventScroll: !0
      }), P[N].click(), C();
    }, C = () => {
      g.value && (p.value = !0);
    }, k = () => p.value = !1;
    return ne(o, (E) => {
      E === "hidden" ? g.value = !1 : E === "visible" && setTimeout(() => g.value = !0, 50);
    }), ne(a, (E) => {
      E ? setTimeout(() => g.value = !0, 50) : g.value = !1;
    }), pn(u, x), qe(() => setTimeout(() => w(), 0)), Ya(() => x()), e({
      scrollToActiveTab: w,
      removeFocus: k
    }), ne(() => n.panes, () => i.update(), {
      flush: "post",
      deep: !0
    }), () => {
      const E = d.value ? [K("span", {
        class: [s.e("nav-prev"), s.is("disabled", !d.value.prev)],
        onClick: y
      }, [K(Fe, null, {
        default: () => [K(G1, null, null)]
      })]), K("span", {
        class: [s.e("nav-next"), s.is("disabled", !d.value.next)],
        onClick: b
      }, [K(Fe, null, {
        default: () => [K(ac, null, null)]
      })])] : null, M = n.panes.map((_, T) => {
        var B, I, P, A;
        const N = _.uid, q = _.props.disabled, j = (I = (B = _.props.name) != null ? B : _.index) != null ? I : `${T}`, H = !q && (_.isClosable || n.editable);
        _.index = `${T}`;
        const oe = H ? K(Fe, {
          class: "is-icon-close",
          onClick: (U) => t("tabRemove", _, U)
        }, {
          default: () => [K(jo, null, null)]
        }) : null, te = ((A = (P = _.slots).label) == null ? void 0 : A.call(P)) || _.props.label, W = !q && _.active ? 0 : -1;
        return K("div", {
          ref: `tab-${N}`,
          class: [s.e("item"), s.is(r.props.tabPosition), s.is("active", _.active), s.is("disabled", q), s.is("closable", H), s.is("focus", p.value)],
          id: `tab-${j}`,
          key: `tab-${N}`,
          "aria-controls": `pane-${j}`,
          role: "tab",
          "aria-selected": _.active,
          tabindex: W,
          onFocus: () => C(),
          onBlur: () => k(),
          onClick: (U) => {
            k(), t("tabClick", _, j, U);
          },
          onKeydown: (U) => {
            H && (U.code === dt.delete || U.code === dt.backspace) && t("tabRemove", _, U);
          }
        }, [te, oe]);
      });
      return K("div", {
        ref: u,
        class: [s.e("nav-wrap"), s.is("scrollable", !!d.value), s.is(r.props.tabPosition)]
      }, [E, K("div", {
        class: s.e("nav-scroll"),
        ref: l
      }, [K("div", {
        class: [s.e("nav"), s.is(r.props.tabPosition), s.is("stretch", n.stretch && ["top", "bottom"].includes(r.props.tabPosition))],
        ref: c,
        style: v.value,
        role: "tablist",
        onKeydown: S
      }, [n.type ? null : K(jK, {
        ref: h,
        tabs: [...n.panes]
      }, null), M])])]);
    };
  }
}), qK = Ee({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  activeName: {
    type: [String, Number]
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: ce(Function),
    default: () => !0
  },
  stretch: Boolean
}), N0 = (n) => bt(n) || tt(n), WK = {
  [ot]: (n) => N0(n),
  tabClick: (n, e) => e instanceof Event,
  tabChange: (n) => N0(n),
  edit: (n, e) => ["remove", "add"].includes(e),
  tabRemove: (n) => N0(n),
  tabAdd: () => !0
}, HK = F({
  name: "ElTabs",
  props: qK,
  emits: WK,
  setup(n, {
    emit: e,
    slots: t,
    expose: i
  }) {
    var r, s;
    const o = me("tabs"), {
      children: a,
      addChild: l,
      removeChild: c
    } = jq(Xe(), "ElTabPane"), u = D(), h = D((s = (r = n.modelValue) != null ? r : n.activeName) != null ? s : "0"), d = async (m, v = !1) => {
      var y, b, w;
      if (!(h.value === m || Ci(m)))
        try {
          await ((y = n.beforeLeave) == null ? void 0 : y.call(n, m, h.value)) !== !1 && (h.value = m, v && (e(ot, m), e("tabChange", m)), (w = (b = u.value) == null ? void 0 : b.removeFocus) == null || w.call(b));
        } catch {
        }
    }, f = (m, v, y) => {
      m.props.disabled || (d(v, !0), e("tabClick", m, y));
    }, p = (m, v) => {
      m.props.disabled || Ci(m.props.name) || (v.stopPropagation(), e("edit", m.props.name, "remove"), e("tabRemove", m.props.name));
    }, g = () => {
      e("edit", void 0, "add"), e("tabAdd");
    };
    return ql({
      from: '"activeName"',
      replacement: '"model-value" or "v-model"',
      scope: "ElTabs",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
      type: "Attribute"
    }, $(() => !!n.activeName)), ql({
      from: '"addIcon"',
      replacement: '"add-icon"',
      scope: "ElTabs",
      version: "2.6.0",
      ref: "https://element-plus.org/en-US/component/tabs.html#slots",
      type: "Slot"
    }, $(() => !!t.addIcon)), ne(() => n.activeName, (m) => d(m)), ne(() => n.modelValue, (m) => d(m)), ne(h, async () => {
      var m;
      await $e(), (m = u.value) == null || m.scrollToActiveTab();
    }), ft(Sv, {
      props: n,
      currentName: h,
      registerPane: l,
      unregisterPane: c
    }), i({
      currentName: h
    }), () => {
      const m = t["add-icon"] || t.addIcon, v = m && t.addIcon, y = n.editable || n.addable ? K("span", {
        class: o.e("new-tab"),
        tabindex: "0",
        onClick: g,
        onKeydown: (x) => {
          x.code === dt.enter && g();
        }
      }, [m ? de(t, v ? "addIcon" : "add-icon") : K(Fe, {
        class: o.is("icon-plus")
      }, {
        default: () => [K(j$, null, null)]
      })]) : null, b = K("div", {
        class: [o.e("header"), o.is(n.tabPosition)]
      }, [y, K(ZK, {
        ref: u,
        currentName: h.value,
        editable: n.editable,
        type: n.type,
        panes: a.value,
        stretch: n.stretch,
        onTabClick: f,
        onTabRemove: p
      }, null)]), w = K("div", {
        class: o.e("content")
      }, [de(t, "default")]);
      return K("div", {
        class: [o.b(), o.m(n.tabPosition), {
          [o.m("card")]: n.type === "card",
          [o.m("border-card")]: n.type === "border-card"
        }]
      }, [...n.tabPosition !== "bottom" ? [b, w] : [w, b]]);
    };
  }
}), XK = Ee({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
}), YK = ["id", "aria-hidden", "aria-labelledby"], K_ = "ElTabPane", UK = F({
  name: K_
}), GK = /* @__PURE__ */ F({
  ...UK,
  props: XK,
  setup(n) {
    const e = n, t = Xe(), i = vo(), r = ke(Sv);
    r || dr(K_, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const s = me("tab-pane"), o = D(), a = $(() => e.closable || r.props.closable), l = JS(() => {
      var f;
      return r.currentName.value === ((f = e.name) != null ? f : o.value);
    }), c = D(l.value), u = $(() => {
      var f;
      return (f = e.name) != null ? f : o.value;
    }), h = JS(() => !e.lazy || c.value || l.value);
    ne(l, (f) => {
      f && (c.value = !0);
    });
    const d = Gt({
      uid: t.uid,
      slots: i,
      props: e,
      paneName: u,
      active: l,
      index: o,
      isClosable: a
    });
    return qe(() => {
      r.registerPane(d);
    }), Gu(() => {
      r.unregisterPane(d.uid);
    }), (f, p) => O(h) ? it((R(), V("div", {
      key: 0,
      id: `pane-${O(u)}`,
      class: L(O(s).b()),
      role: "tabpanel",
      "aria-hidden": !O(l),
      "aria-labelledby": `tab-${O(u)}`
    }, [
      de(f.$slots, "default")
    ], 10, YK)), [
      [Qt, O(l)]
    ]) : G("v-if", !0);
  }
});
var J_ = /* @__PURE__ */ Ce(GK, [["__file", "tab-pane.vue"]]);
const VKe = Ft(HK, {
  TabPane: J_
}), FKe = As(J_), eM = "left-check-change", tM = "right-check-change", Mc = Ee({
  data: {
    type: ce(Array),
    default: () => []
  },
  titles: {
    type: ce(Array),
    default: () => []
  },
  buttonTexts: {
    type: ce(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: ce(Function)
  },
  leftDefaultChecked: {
    type: ce(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: ce(Array),
    default: () => []
  },
  renderContent: {
    type: ce(Function)
  },
  modelValue: {
    type: ce(Array),
    default: () => []
  },
  format: {
    type: ce(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: ce(Object),
    default: () => Ur({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), Ny = (n, e) => [n, e].every(xt) || xt(n) && Ni(e), KK = {
  [Gn]: (n, e, t) => [n, t].every(xt) && ["left", "right"].includes(e),
  [ot]: (n) => xt(n),
  [eM]: Ny,
  [tM]: Ny
}, Dy = "checked-change", JK = Ee({
  data: Mc.data,
  optionRender: {
    type: ce(Function)
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: Mc.format,
  filterMethod: Mc.filterMethod,
  defaultChecked: Mc.leftDefaultChecked,
  props: Mc.props
}), eJ = {
  [Dy]: Ny
}, Nf = (n) => {
  const e = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return $(() => ({
    ...e,
    ...n.props
  }));
}, tJ = (n, e, t) => {
  const i = Nf(n), r = $(() => n.data.filter((u) => wt(n.filterMethod) ? n.filterMethod(e.query, u) : String(u[i.value.label] || u[i.value.key]).toLowerCase().includes(e.query.toLowerCase()))), s = $(() => r.value.filter((u) => !u[i.value.disabled])), o = $(() => {
    const u = e.checked.length, h = n.data.length, { noChecked: d, hasChecked: f } = n.format;
    return d && f ? u > 0 ? f.replace(/\${checked}/g, u.toString()).replace(/\${total}/g, h.toString()) : d.replace(/\${total}/g, h.toString()) : `${u}/${h}`;
  }), a = $(() => {
    const u = e.checked.length;
    return u > 0 && u < s.value.length;
  }), l = () => {
    const u = s.value.map((h) => h[i.value.key]);
    e.allChecked = u.length > 0 && u.every((h) => e.checked.includes(h));
  }, c = (u) => {
    e.checked = u ? s.value.map((h) => h[i.value.key]) : [];
  };
  return ne(() => e.checked, (u, h) => {
    if (l(), e.checkChangeByUser) {
      const d = u.concat(h).filter((f) => !u.includes(f) || !h.includes(f));
      t(Dy, u, d);
    } else
      t(Dy, u), e.checkChangeByUser = !0;
  }), ne(s, () => {
    l();
  }), ne(() => n.data, () => {
    const u = [], h = r.value.map((d) => d[i.value.key]);
    e.checked.forEach((d) => {
      h.includes(d) && u.push(d);
    }), e.checkChangeByUser = !1, e.checked = u;
  }), ne(() => n.defaultChecked, (u, h) => {
    if (h && u.length === h.length && u.every((p) => h.includes(p)))
      return;
    const d = [], f = s.value.map((p) => p[i.value.key]);
    u.forEach((p) => {
      f.includes(p) && d.push(p);
    }), e.checkChangeByUser = !1, e.checked = d;
  }, {
    immediate: !0
  }), {
    filteredData: r,
    checkableData: s,
    checkedSummary: o,
    isIndeterminate: a,
    updateAllChecked: l,
    handleAllCheckedChange: c
  };
}, nJ = (n, e) => ({
  onSourceCheckedChange: (r, s) => {
    n.leftChecked = r, s && e(eM, r, s);
  },
  onTargetCheckedChange: (r, s) => {
    n.rightChecked = r, s && e(tM, r, s);
  }
}), iJ = (n) => {
  const e = Nf(n), t = $(() => n.data.reduce((s, o) => (s[o[e.value.key]] = o) && s, {})), i = $(() => n.data.filter((s) => !n.modelValue.includes(s[e.value.key]))), r = $(() => n.targetOrder === "original" ? n.data.filter((s) => n.modelValue.includes(s[e.value.key])) : n.modelValue.reduce((s, o) => {
    const a = t.value[o];
    return a && s.push(a), s;
  }, []));
  return {
    sourceData: i,
    targetData: r
  };
}, rJ = (n, e, t) => {
  const i = Nf(n), r = (a, l, c) => {
    t(ot, a), t(Gn, a, l, c);
  };
  return {
    addToLeft: () => {
      const a = n.modelValue.slice();
      e.rightChecked.forEach((l) => {
        const c = a.indexOf(l);
        c > -1 && a.splice(c, 1);
      }), r(a, "left", e.rightChecked);
    },
    addToRight: () => {
      let a = n.modelValue.slice();
      const l = n.data.filter((c) => {
        const u = c[i.value.key];
        return e.leftChecked.includes(u) && !n.modelValue.includes(u);
      }).map((c) => c[i.value.key]);
      a = n.targetOrder === "unshift" ? l.concat(a) : a.concat(l), n.targetOrder === "original" && (a = n.data.filter((c) => a.includes(c[i.value.key])).map((c) => c[i.value.key])), r(a, "right", e.leftChecked);
    }
  };
}, sJ = F({
  name: "ElTransferPanel"
}), oJ = /* @__PURE__ */ F({
  ...sJ,
  props: JK,
  emits: eJ,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = vo(), s = ({ option: b }) => b, { t: o } = mn(), a = me("transfer"), l = Gt({
      checked: [],
      allChecked: !1,
      query: "",
      checkChangeByUser: !0
    }), c = Nf(i), {
      filteredData: u,
      checkedSummary: h,
      isIndeterminate: d,
      handleAllCheckedChange: f
    } = tJ(i, l, t), p = $(() => !Hs(l.query) && Hs(u.value)), g = $(() => !Hs(r.default()[0].children)), { checked: m, allChecked: v, query: y } = Hr(l);
    return e({
      query: y
    }), (b, w) => (R(), V("div", {
      class: L(O(a).b("panel"))
    }, [
      Z("p", {
        class: L(O(a).be("panel", "header"))
      }, [
        K(O(fo), {
          modelValue: O(v),
          "onUpdate:modelValue": w[0] || (w[0] = (x) => Zi(v) ? v.value = x : null),
          indeterminate: O(d),
          "validate-event": !1,
          onChange: O(f)
        }, {
          default: Y(() => [
            Yn(xe(b.title) + " ", 1),
            Z("span", null, xe(O(h)), 1)
          ]),
          _: 1
        }, 8, ["modelValue", "indeterminate", "onChange"])
      ], 2),
      Z("div", {
        class: L([O(a).be("panel", "body"), O(a).is("with-footer", O(g))])
      }, [
        b.filterable ? (R(), ie(O(uc), {
          key: 0,
          modelValue: O(y),
          "onUpdate:modelValue": w[1] || (w[1] = (x) => Zi(y) ? y.value = x : null),
          class: L(O(a).be("panel", "filter")),
          size: "default",
          placeholder: b.placeholder,
          "prefix-icon": O(cV),
          clearable: "",
          "validate-event": !1
        }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : G("v-if", !0),
        it(K(O(IW), {
          modelValue: O(m),
          "onUpdate:modelValue": w[2] || (w[2] = (x) => Zi(m) ? m.value = x : null),
          "validate-event": !1,
          class: L([O(a).is("filterable", b.filterable), O(a).be("panel", "list")])
        }, {
          default: Y(() => [
            (R(!0), V(Tt, null, ai(O(u), (x) => (R(), ie(O(fo), {
              key: x[O(c).key],
              class: L(O(a).be("panel", "item")),
              label: x[O(c).key],
              disabled: x[O(c).disabled],
              "validate-event": !1
            }, {
              default: Y(() => {
                var S;
                return [
                  K(s, {
                    option: (S = b.optionRender) == null ? void 0 : S.call(b, x)
                  }, null, 8, ["option"])
                ];
              }),
              _: 2
            }, 1032, ["class", "label", "disabled"]))), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "class"]), [
          [Qt, !O(p) && !O(Hs)(b.data)]
        ]),
        it(Z("p", {
          class: L(O(a).be("panel", "empty"))
        }, xe(O(p) ? O(o)("el.transfer.noMatch") : O(o)("el.transfer.noData")), 3), [
          [Qt, O(p) || O(Hs)(b.data)]
        ])
      ], 2),
      O(g) ? (R(), V("p", {
        key: 0,
        class: L(O(a).be("panel", "footer"))
      }, [
        de(b.$slots, "default")
      ], 2)) : G("v-if", !0)
    ], 2));
  }
});
var vk = /* @__PURE__ */ Ce(oJ, [["__file", "transfer-panel.vue"]]);
const aJ = { key: 0 }, lJ = { key: 0 }, cJ = F({
  name: "ElTransfer"
}), uJ = /* @__PURE__ */ F({
  ...cJ,
  props: Mc,
  emits: KK,
  setup(n, { expose: e, emit: t }) {
    const i = n, r = vo(), { t: s } = mn(), o = me("transfer"), { formItem: a } = Mr(), l = Gt({
      leftChecked: [],
      rightChecked: []
    }), c = Nf(i), { sourceData: u, targetData: h } = iJ(i), { onSourceCheckedChange: d, onTargetCheckedChange: f } = nJ(l, t), { addToLeft: p, addToRight: g } = rJ(i, l, t), m = D(), v = D(), y = (k) => {
      switch (k) {
        case "left":
          m.value.query = "";
          break;
        case "right":
          v.value.query = "";
          break;
      }
    }, b = $(() => i.buttonTexts.length === 2), w = $(() => i.titles[0] || s("el.transfer.titles.0")), x = $(() => i.titles[1] || s("el.transfer.titles.1")), S = $(() => i.filterPlaceholder || s("el.transfer.filterPlaceholder"));
    ne(() => i.modelValue, () => {
      var k;
      i.validateEvent && ((k = a == null ? void 0 : a.validate) == null || k.call(a, "change").catch((E) => pt(E)));
    });
    const C = $(() => (k) => i.renderContent ? i.renderContent(Re, k) : r.default ? r.default({ option: k }) : Re("span", k[c.value.label] || k[c.value.key]));
    return e({
      clearQuery: y,
      leftPanel: m,
      rightPanel: v
    }), (k, E) => (R(), V("div", {
      class: L(O(o).b())
    }, [
      K(vk, {
        ref_key: "leftPanel",
        ref: m,
        data: O(u),
        "option-render": O(C),
        placeholder: O(S),
        title: O(w),
        filterable: k.filterable,
        format: k.format,
        "filter-method": k.filterMethod,
        "default-checked": k.leftDefaultChecked,
        props: i.props,
        onCheckedChange: O(d)
      }, {
        default: Y(() => [
          de(k.$slots, "left-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
      Z("div", {
        class: L(O(o).e("buttons"))
      }, [
        K(O(Wl), {
          type: "primary",
          class: L([O(o).e("button"), O(o).is("with-texts", O(b))]),
          disabled: O(Hs)(l.rightChecked),
          onClick: O(p)
        }, {
          default: Y(() => [
            K(O(Fe), null, {
              default: Y(() => [
                K(O(G1))
              ]),
              _: 1
            }),
            O(Ci)(k.buttonTexts[0]) ? G("v-if", !0) : (R(), V("span", aJ, xe(k.buttonTexts[0]), 1))
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"]),
        K(O(Wl), {
          type: "primary",
          class: L([O(o).e("button"), O(o).is("with-texts", O(b))]),
          disabled: O(Hs)(l.leftChecked),
          onClick: O(g)
        }, {
          default: Y(() => [
            O(Ci)(k.buttonTexts[1]) ? G("v-if", !0) : (R(), V("span", lJ, xe(k.buttonTexts[1]), 1)),
            K(O(Fe), null, {
              default: Y(() => [
                K(O(ac))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"])
      ], 2),
      K(vk, {
        ref_key: "rightPanel",
        ref: v,
        data: O(h),
        "option-render": O(C),
        placeholder: O(S),
        filterable: k.filterable,
        format: k.format,
        "filter-method": k.filterMethod,
        title: O(x),
        "default-checked": k.rightDefaultChecked,
        props: i.props,
        onCheckedChange: O(f)
      }, {
        default: Y(() => [
          de(k.$slots, "right-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
    ], 2));
  }
});
var hJ = /* @__PURE__ */ Ce(uJ, [["__file", "transfer.vue"]]);
const ZKe = Ft(hJ), Hc = "$treeNodeId", bk = function(n, e) {
  !e || e[Hc] || Object.defineProperty(e, Hc, {
    value: n.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, _w = function(n, e) {
  return n ? e[n] : e[Hc];
}, Ly = (n, e, t) => {
  const i = n.value.currentNode;
  t();
  const r = n.value.currentNode;
  i !== r && e("current-change", r ? r.data : null, r);
}, Iy = (n) => {
  let e = !0, t = !0, i = !0;
  for (let r = 0, s = n.length; r < s; r++) {
    const o = n[r];
    (o.checked !== !0 || o.indeterminate) && (e = !1, o.disabled || (i = !1)), (o.checked !== !1 || o.indeterminate) && (t = !1);
  }
  return { all: e, none: t, allWithoutDisable: i, half: !e && !t };
}, vg = function(n) {
  if (n.childNodes.length === 0 || n.loading)
    return;
  const { all: e, none: t, half: i } = Iy(n.childNodes);
  e ? (n.checked = !0, n.indeterminate = !1) : i ? (n.checked = !1, n.indeterminate = !0) : t && (n.checked = !1, n.indeterminate = !1);
  const r = n.parent;
  !r || r.level === 0 || n.store.checkStrictly || vg(r);
}, fp = function(n, e) {
  const t = n.store.props, i = n.data || {}, r = t[e];
  if (typeof r == "function")
    return r(i, n);
  if (typeof r == "string")
    return i[r];
  if (typeof r > "u") {
    const s = i[e];
    return s === void 0 ? "" : s;
  }
};
let dJ = 0, By = class bg {
  constructor(e) {
    this.id = dJ++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const t in e)
      Xi(e, t) && (this[t] = e[t]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const e = this.store;
    if (!e)
      throw new Error("[Node]store is required!");
    e.registerNode(this);
    const t = e.props;
    if (t && typeof t.isLeaf < "u") {
      const s = fp(this, "isLeaf");
      typeof s == "boolean" && (this.isLeafByUser = s);
    }
    if (e.lazy !== !0 && this.data ? (this.setData(this.data), e.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(), Array.isArray(this.data) || bk(this, this.data), !this.data)
      return;
    const i = e.defaultExpandedKeys, r = e.key;
    r && i && i.includes(this.key) && this.expand(null, e.autoExpandParent), r && e.currentNodeKey !== void 0 && this.key === e.currentNodeKey && (e.currentNode = this, e.currentNode.isCurrent = !0), e.lazy && e._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(e) {
    Array.isArray(e) || bk(this, e), this.data = e, this.childNodes = [];
    let t;
    this.level === 0 && Array.isArray(this.data) ? t = this.data : t = fp(this, "children") || [];
    for (let i = 0, r = t.length; i < r; i++)
      this.insertChild({ data: t[i] });
  }
  get label() {
    return fp(this, "label");
  }
  get key() {
    const e = this.store.key;
    return this.data ? this.data[e] : null;
  }
  get disabled() {
    return fp(this, "disabled");
  }
  get nextSibling() {
    const e = this.parent;
    if (e) {
      const t = e.childNodes.indexOf(this);
      if (t > -1)
        return e.childNodes[t + 1];
    }
    return null;
  }
  get previousSibling() {
    const e = this.parent;
    if (e) {
      const t = e.childNodes.indexOf(this);
      if (t > -1)
        return t > 0 ? e.childNodes[t - 1] : null;
    }
    return null;
  }
  contains(e, t = !0) {
    return (this.childNodes || []).some((i) => i === e || t && i.contains(e));
  }
  remove() {
    const e = this.parent;
    e && e.removeChild(this);
  }
  insertChild(e, t, i) {
    if (!e)
      throw new Error("InsertChild error: child is required.");
    if (!(e instanceof bg)) {
      if (!i) {
        const r = this.getChildren(!0);
        r.includes(e.data) || (typeof t > "u" || t < 0 ? r.push(e.data) : r.splice(t, 0, e.data));
      }
      Object.assign(e, {
        parent: this,
        store: this.store
      }), e = Gt(new bg(e)), e instanceof bg && e.initialize();
    }
    e.level = this.level + 1, typeof t > "u" || t < 0 ? this.childNodes.push(e) : this.childNodes.splice(t, 0, e), this.updateLeafState();
  }
  insertBefore(e, t) {
    let i;
    t && (i = this.childNodes.indexOf(t)), this.insertChild(e, i);
  }
  insertAfter(e, t) {
    let i;
    t && (i = this.childNodes.indexOf(t), i !== -1 && (i += 1)), this.insertChild(e, i);
  }
  removeChild(e) {
    const t = this.getChildren() || [], i = t.indexOf(e.data);
    i > -1 && t.splice(i, 1);
    const r = this.childNodes.indexOf(e);
    r > -1 && (this.store && this.store.deregisterNode(e), e.parent = null, this.childNodes.splice(r, 1)), this.updateLeafState();
  }
  removeChildByData(e) {
    let t = null;
    for (let i = 0; i < this.childNodes.length; i++)
      if (this.childNodes[i].data === e) {
        t = this.childNodes[i];
        break;
      }
    t && this.removeChild(t);
  }
  expand(e, t) {
    const i = () => {
      if (t) {
        let r = this.parent;
        for (; r.level > 0; )
          r.expanded = !0, r = r.parent;
      }
      this.expanded = !0, e && e(), this.childNodes.forEach((r) => {
        r.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((r) => {
      Array.isArray(r) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || vg(this), i());
    }) : i();
  }
  doCreateChildren(e, t = {}) {
    e.forEach((i) => {
      this.insertChild(Object.assign({ data: i }, t), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((e) => {
      e.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const e = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !e || e.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(e, t, i, r) {
    if (this.indeterminate = e === "half", this.checked = e === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: o, allWithoutDisable: a } = Iy(this.childNodes);
      !this.isLeaf && !o && a && (this.checked = !1, e = !1);
      const l = () => {
        if (t) {
          const c = this.childNodes;
          for (let d = 0, f = c.length; d < f; d++) {
            const p = c[d];
            r = r || e !== !1;
            const g = p.disabled ? p.checked : r;
            p.setChecked(g, t, !0, r);
          }
          const { half: u, all: h } = Iy(c);
          h || (this.checked = h, this.indeterminate = u);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          l(), vg(this);
        }, {
          checked: e !== !1
        });
        return;
      } else
        l();
    }
    const s = this.parent;
    !s || s.level === 0 || i || vg(s);
  }
  getChildren(e = !1) {
    if (this.level === 0)
      return this.data;
    const t = this.data;
    if (!t)
      return null;
    const i = this.store.props;
    let r = "children";
    return i && (r = i.children || "children"), t[r] === void 0 && (t[r] = null), e && !t[r] && (t[r] = []), t[r];
  }
  updateChildren() {
    const e = this.getChildren() || [], t = this.childNodes.map((s) => s.data), i = {}, r = [];
    e.forEach((s, o) => {
      const a = s[Hc];
      !!a && t.findIndex((c) => c[Hc] === a) >= 0 ? i[a] = { index: o, data: s } : r.push({ index: o, data: s });
    }), this.store.lazy || t.forEach((s) => {
      i[s[Hc]] || this.removeChildByData(s);
    }), r.forEach(({ index: s, data: o }) => {
      this.insertChild({ data: o }, s);
    }), this.updateLeafState();
  }
  loadData(e, t = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(t).length)) {
      this.loading = !0;
      const i = (r) => {
        this.childNodes = [], this.doCreateChildren(r, t), this.loaded = !0, this.loading = !1, this.updateLeafState(), e && e.call(this, r);
      };
      this.store.load(this, i);
    } else
      e && e.call(this);
  }
};
class fJ {
  constructor(e) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const t in e)
      Xi(e, t) && (this[t] = e[t]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new By({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const e = this.load;
      e(this.root, (t) => {
        this.root.doCreateChildren(t), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(e) {
    const t = this.filterNodeMethod, i = this.lazy, r = function(s) {
      const o = s.root ? s.root.childNodes : s.childNodes;
      if (o.forEach((a) => {
        a.visible = t.call(a, e, a.data, a), r(a);
      }), !s.visible && o.length) {
        let a = !0;
        a = !o.some((l) => l.visible), s.root ? s.root.visible = a === !1 : s.visible = a === !1;
      }
      e && s.visible && !s.isLeaf && (!i || s.loaded) && s.expand();
    };
    r(this);
  }
  setData(e) {
    e !== this.root.data ? (this.root.setData(e), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(e) {
    if (e instanceof By)
      return e;
    const t = an(e) ? _w(this.key, e) : e;
    return this.nodesMap[t] || null;
  }
  insertBefore(e, t) {
    const i = this.getNode(t);
    i.parent.insertBefore({ data: e }, i);
  }
  insertAfter(e, t) {
    const i = this.getNode(t);
    i.parent.insertAfter({ data: e }, i);
  }
  remove(e) {
    const t = this.getNode(e);
    t && t.parent && (t === this.currentNode && (this.currentNode = null), t.parent.removeChild(t));
  }
  append(e, t) {
    const i = t ? this.getNode(t) : this.root;
    i && i.insertChild({ data: e });
  }
  _initDefaultCheckedNodes() {
    const e = this.defaultCheckedKeys || [], t = this.nodesMap;
    e.forEach((i) => {
      const r = t[i];
      r && r.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(e) {
    (this.defaultCheckedKeys || []).includes(e.key) && e.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(e) {
    e !== this.defaultCheckedKeys && (this.defaultCheckedKeys = e, this._initDefaultCheckedNodes());
  }
  registerNode(e) {
    const t = this.key;
    !e || !e.data || (t ? e.key !== void 0 && (this.nodesMap[e.key] = e) : this.nodesMap[e.id] = e);
  }
  deregisterNode(e) {
    !this.key || !e || !e.data || (e.childNodes.forEach((i) => {
      this.deregisterNode(i);
    }), delete this.nodesMap[e.key]);
  }
  getCheckedNodes(e = !1, t = !1) {
    const i = [], r = function(s) {
      (s.root ? s.root.childNodes : s.childNodes).forEach((a) => {
        (a.checked || t && a.indeterminate) && (!e || e && a.isLeaf) && i.push(a.data), r(a);
      });
    };
    return r(this), i;
  }
  getCheckedKeys(e = !1) {
    return this.getCheckedNodes(e).map((t) => (t || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const e = [], t = function(i) {
      (i.root ? i.root.childNodes : i.childNodes).forEach((s) => {
        s.indeterminate && e.push(s.data), t(s);
      });
    };
    return t(this), e;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((e) => (e || {})[this.key]);
  }
  _getAllNodes() {
    const e = [], t = this.nodesMap;
    for (const i in t)
      Xi(t, i) && e.push(t[i]);
    return e;
  }
  updateChildren(e, t) {
    const i = this.nodesMap[e];
    if (!i)
      return;
    const r = i.childNodes;
    for (let s = r.length - 1; s >= 0; s--) {
      const o = r[s];
      this.remove(o.data);
    }
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s];
      this.append(a, i.data);
    }
  }
  _setCheckedKeys(e, t = !1, i) {
    const r = this._getAllNodes().sort((l, c) => l.level - c.level), s = /* @__PURE__ */ Object.create(null), o = Object.keys(i);
    r.forEach((l) => l.setChecked(!1, !1));
    const a = (l) => {
      l.childNodes.forEach((c) => {
        var u;
        s[c.data[e]] = !0, (u = c.childNodes) != null && u.length && a(c);
      });
    };
    for (let l = 0, c = r.length; l < c; l++) {
      const u = r[l], h = u.data[e].toString();
      if (!o.includes(h)) {
        u.checked && !s[h] && u.setChecked(!1, !1);
        continue;
      }
      if (u.childNodes.length && a(u), u.isLeaf || this.checkStrictly) {
        u.setChecked(!0, !1);
        continue;
      }
      if (u.setChecked(!0, !0), t) {
        u.setChecked(!1, !1);
        const f = function(p) {
          p.childNodes.forEach((m) => {
            m.isLeaf || m.setChecked(!1, !1), f(m);
          });
        };
        f(u);
      }
    }
  }
  setCheckedNodes(e, t = !1) {
    const i = this.key, r = {};
    e.forEach((s) => {
      r[(s || {})[i]] = !0;
    }), this._setCheckedKeys(i, t, r);
  }
  setCheckedKeys(e, t = !1) {
    this.defaultCheckedKeys = e;
    const i = this.key, r = {};
    e.forEach((s) => {
      r[s] = !0;
    }), this._setCheckedKeys(i, t, r);
  }
  setDefaultExpandedKeys(e) {
    e = e || [], this.defaultExpandedKeys = e, e.forEach((t) => {
      const i = this.getNode(t);
      i && i.expand(null, this.autoExpandParent);
    });
  }
  setChecked(e, t, i) {
    const r = this.getNode(e);
    r && r.setChecked(!!t, i);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(e) {
    const t = this.currentNode;
    t && (t.isCurrent = !1), this.currentNode = e, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(e, t = !0) {
    const i = e[this.key], r = this.nodesMap[i];
    this.setCurrentNode(r), t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
  }
  setCurrentNodeKey(e, t = !0) {
    if (e == null) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const i = this.getNode(e);
    i && (this.setCurrentNode(i), t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
  }
}
const pJ = F({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(n) {
    const e = me("tree"), t = ke("NodeInstance"), i = ke("RootTree");
    return () => {
      const r = n.node, { data: s, store: o } = r;
      return n.renderContent ? n.renderContent(Re, { _self: t, node: r, data: s, store: o }) : de(i.ctx.slots, "default", { node: r, data: s }, () => [
        Re("span", { class: e.be("node", "label") }, [r.label])
      ]);
    };
  }
});
var gJ = /* @__PURE__ */ Ce(pJ, [["__file", "tree-node-content.vue"]]);
function nM(n) {
  const e = ke("TreeNodeMap", null), t = {
    treeNodeExpand: (i) => {
      n.node !== i && n.node.collapse();
    },
    children: []
  };
  return e && e.children.push(t), ft("TreeNodeMap", t), {
    broadcastExpanded: (i) => {
      if (n.accordion)
        for (const r of t.children)
          r.treeNodeExpand(i);
    }
  };
}
const iM = Symbol("dragEvents");
function mJ({ props: n, ctx: e, el$: t, dropIndicator$: i, store: r }) {
  const s = me("tree"), o = D({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return ft(iM, {
    treeNodeDragStart: ({ event: u, treeNode: h }) => {
      if (typeof n.allowDrag == "function" && !n.allowDrag(h.node))
        return u.preventDefault(), !1;
      u.dataTransfer.effectAllowed = "move";
      try {
        u.dataTransfer.setData("text/plain", "");
      } catch {
      }
      o.value.draggingNode = h, e.emit("node-drag-start", h.node, u);
    },
    treeNodeDragOver: ({ event: u, treeNode: h }) => {
      const d = h, f = o.value.dropNode;
      f && f.node.id !== d.node.id && Io(f.$el, s.is("drop-inner"));
      const p = o.value.draggingNode;
      if (!p || !d)
        return;
      let g = !0, m = !0, v = !0, y = !0;
      typeof n.allowDrop == "function" && (g = n.allowDrop(p.node, d.node, "prev"), y = m = n.allowDrop(p.node, d.node, "inner"), v = n.allowDrop(p.node, d.node, "next")), u.dataTransfer.dropEffect = m || g || v ? "move" : "none", (g || m || v) && (f == null ? void 0 : f.node.id) !== d.node.id && (f && e.emit("node-drag-leave", p.node, f.node, u), e.emit("node-drag-enter", p.node, d.node, u)), g || m || v ? o.value.dropNode = d : o.value.dropNode = null, d.node.nextSibling === p.node && (v = !1), d.node.previousSibling === p.node && (g = !1), d.node.contains(p.node, !1) && (m = !1), (p.node === d.node || p.node.contains(d.node)) && (g = !1, m = !1, v = !1);
      const b = d.$el.querySelector(`.${s.be("node", "content")}`).getBoundingClientRect(), w = t.value.getBoundingClientRect();
      let x;
      const S = g ? m ? 0.25 : v ? 0.45 : 1 : -1, C = v ? m ? 0.75 : g ? 0.55 : 0 : 1;
      let k = -9999;
      const E = u.clientY - b.top;
      E < b.height * S ? x = "before" : E > b.height * C ? x = "after" : m ? x = "inner" : x = "none";
      const M = d.$el.querySelector(`.${s.be("node", "expand-icon")}`).getBoundingClientRect(), _ = i.value;
      x === "before" ? k = M.top - w.top : x === "after" && (k = M.bottom - w.top), _.style.top = `${k}px`, _.style.left = `${M.right - w.left}px`, x === "inner" ? pu(d.$el, s.is("drop-inner")) : Io(d.$el, s.is("drop-inner")), o.value.showDropIndicator = x === "before" || x === "after", o.value.allowDrop = o.value.showDropIndicator || y, o.value.dropType = x, e.emit("node-drag-over", p.node, d.node, u);
    },
    treeNodeDragEnd: (u) => {
      const { draggingNode: h, dropType: d, dropNode: f } = o.value;
      if (u.preventDefault(), u.dataTransfer.dropEffect = "move", h && f) {
        const p = { data: h.node.data };
        d !== "none" && h.node.remove(), d === "before" ? f.node.parent.insertBefore(p, f.node) : d === "after" ? f.node.parent.insertAfter(p, f.node) : d === "inner" && f.node.insertChild(p), d !== "none" && r.value.registerNode(p), Io(f.$el, s.is("drop-inner")), e.emit("node-drag-end", h.node, f.node, d, u), d !== "none" && e.emit("node-drop", h.node, f.node, d, u);
      }
      h && !f && e.emit("node-drag-end", h.node, null, d, u), o.value.showDropIndicator = !1, o.value.draggingNode = null, o.value.dropNode = null, o.value.allowDrop = !0;
    }
  }), {
    dragState: o
  };
}
const vJ = F({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: g_,
    ElCheckbox: fo,
    NodeContent: gJ,
    ElIcon: Fe,
    Loading: lc
  },
  props: {
    node: {
      type: By,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(n, e) {
    const t = me("tree"), { broadcastExpanded: i } = nM(n), r = ke("RootTree"), s = D(!1), o = D(!1), a = D(null), l = D(null), c = D(null), u = ke(iM), h = Xe();
    ft("NodeInstance", h), r || pt("Tree", "Can not find node's tree."), n.node.expanded && (s.value = !0, o.value = !0);
    const d = r.props.props.children || "children";
    ne(() => {
      const E = n.node.data[d];
      return E && [...E];
    }, () => {
      n.node.updateChildren();
    }), ne(() => n.node.indeterminate, (E) => {
      g(n.node.checked, E);
    }), ne(() => n.node.checked, (E) => {
      g(E, n.node.indeterminate);
    }), ne(() => n.node.expanded, (E) => {
      $e(() => s.value = E), E && (o.value = !0);
    });
    const f = (E) => _w(r.props.nodeKey, E.data), p = (E) => {
      const M = n.props.class;
      if (!M)
        return {};
      let _;
      if (wt(M)) {
        const { data: T } = E;
        _ = M(T, E);
      } else
        _ = M;
      return bt(_) ? { [_]: !0 } : _;
    }, g = (E, M) => {
      (a.value !== E || l.value !== M) && r.ctx.emit("check-change", n.node.data, E, M), a.value = E, l.value = M;
    }, m = (E) => {
      Ly(r.store, r.ctx.emit, () => r.store.value.setCurrentNode(n.node)), r.currentNode.value = n.node, r.props.expandOnClickNode && y(), r.props.checkOnClickNode && !n.node.disabled && b(null, {
        target: { checked: !n.node.checked }
      }), r.ctx.emit("node-click", n.node.data, n.node, h, E);
    }, v = (E) => {
      r.instance.vnode.props.onNodeContextmenu && (E.stopPropagation(), E.preventDefault()), r.ctx.emit("node-contextmenu", E, n.node.data, n.node, h);
    }, y = () => {
      n.node.isLeaf || (s.value ? (r.ctx.emit("node-collapse", n.node.data, n.node, h), n.node.collapse()) : (n.node.expand(), e.emit("node-expand", n.node.data, n.node, h)));
    }, b = (E, M) => {
      n.node.setChecked(M.target.checked, !r.props.checkStrictly), $e(() => {
        const _ = r.store.value;
        r.ctx.emit("check", n.node.data, {
          checkedNodes: _.getCheckedNodes(),
          checkedKeys: _.getCheckedKeys(),
          halfCheckedNodes: _.getHalfCheckedNodes(),
          halfCheckedKeys: _.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: t,
      node$: c,
      tree: r,
      expanded: s,
      childNodeRendered: o,
      oldChecked: a,
      oldIndeterminate: l,
      getNodeKey: f,
      getNodeClass: p,
      handleSelectChange: g,
      handleClick: m,
      handleContextMenu: v,
      handleExpandIconClick: y,
      handleCheckChange: b,
      handleChildNodeExpand: (E, M, _) => {
        i(M), r.ctx.emit("node-expand", E, M, _);
      },
      handleDragStart: (E) => {
        r.props.draggable && u.treeNodeDragStart({ event: E, treeNode: n });
      },
      handleDragOver: (E) => {
        E.preventDefault(), r.props.draggable && u.treeNodeDragOver({
          event: E,
          treeNode: { $el: c.value, node: n.node }
        });
      },
      handleDrop: (E) => {
        E.preventDefault();
      },
      handleDragEnd: (E) => {
        r.props.draggable && u.treeNodeDragEnd(E);
      },
      CaretRight: yj
    };
  }
}), bJ = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], yJ = ["aria-expanded"];
function OJ(n, e, t, i, r, s) {
  const o = nt("el-icon"), a = nt("el-checkbox"), l = nt("loading"), c = nt("node-content"), u = nt("el-tree-node"), h = nt("el-collapse-transition");
  return it((R(), V("div", {
    ref: "node$",
    class: L([
      n.ns.b("node"),
      n.ns.is("expanded", n.expanded),
      n.ns.is("current", n.node.isCurrent),
      n.ns.is("hidden", !n.node.visible),
      n.ns.is("focusable", !n.node.disabled),
      n.ns.is("checked", !n.node.disabled && n.node.checked),
      n.getNodeClass(n.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": n.expanded,
    "aria-disabled": n.node.disabled,
    "aria-checked": n.node.checked,
    draggable: n.tree.props.draggable,
    "data-key": n.getNodeKey(n.node),
    onClick: e[1] || (e[1] = Le((...d) => n.handleClick && n.handleClick(...d), ["stop"])),
    onContextmenu: e[2] || (e[2] = (...d) => n.handleContextMenu && n.handleContextMenu(...d)),
    onDragstart: e[3] || (e[3] = Le((...d) => n.handleDragStart && n.handleDragStart(...d), ["stop"])),
    onDragover: e[4] || (e[4] = Le((...d) => n.handleDragOver && n.handleDragOver(...d), ["stop"])),
    onDragend: e[5] || (e[5] = Le((...d) => n.handleDragEnd && n.handleDragEnd(...d), ["stop"])),
    onDrop: e[6] || (e[6] = Le((...d) => n.handleDrop && n.handleDrop(...d), ["stop"]))
  }, [
    Z("div", {
      class: L(n.ns.be("node", "content")),
      style: Qe({ paddingLeft: (n.node.level - 1) * n.tree.props.indent + "px" })
    }, [
      n.tree.props.icon || n.CaretRight ? (R(), ie(o, {
        key: 0,
        class: L([
          n.ns.be("node", "expand-icon"),
          n.ns.is("leaf", n.node.isLeaf),
          {
            expanded: !n.node.isLeaf && n.expanded
          }
        ]),
        onClick: Le(n.handleExpandIconClick, ["stop"])
      }, {
        default: Y(() => [
          (R(), ie(yt(n.tree.props.icon || n.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : G("v-if", !0),
      n.showCheckbox ? (R(), ie(a, {
        key: 1,
        "model-value": n.node.checked,
        indeterminate: n.node.indeterminate,
        disabled: !!n.node.disabled,
        onClick: e[0] || (e[0] = Le(() => {
        }, ["stop"])),
        onChange: n.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : G("v-if", !0),
      n.node.loading ? (R(), ie(o, {
        key: 2,
        class: L([n.ns.be("node", "loading-icon"), n.ns.is("loading")])
      }, {
        default: Y(() => [
          K(l)
        ]),
        _: 1
      }, 8, ["class"])) : G("v-if", !0),
      K(c, {
        node: n.node,
        "render-content": n.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    K(h, null, {
      default: Y(() => [
        !n.renderAfterExpand || n.childNodeRendered ? it((R(), V("div", {
          key: 0,
          class: L(n.ns.be("node", "children")),
          role: "group",
          "aria-expanded": n.expanded
        }, [
          (R(!0), V(Tt, null, ai(n.node.childNodes, (d) => (R(), ie(u, {
            key: n.getNodeKey(d),
            "render-content": n.renderContent,
            "render-after-expand": n.renderAfterExpand,
            "show-checkbox": n.showCheckbox,
            node: d,
            accordion: n.accordion,
            props: n.props,
            onNodeExpand: n.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, yJ)), [
          [Qt, n.expanded]
        ]) : G("v-if", !0)
      ]),
      _: 1
    })
  ], 42, bJ)), [
    [Qt, n.node.visible]
  ]);
}
var wJ = /* @__PURE__ */ Ce(vJ, [["render", OJ], ["__file", "tree-node.vue"]]);
function xJ({ el$: n }, e) {
  const t = me("tree"), i = In([]), r = In([]);
  qe(() => {
    o();
  }), Ya(() => {
    i.value = Array.from(n.value.querySelectorAll("[role=treeitem]")), r.value = Array.from(n.value.querySelectorAll("input[type=checkbox]"));
  }), ne(r, (a) => {
    a.forEach((l) => {
      l.setAttribute("tabindex", "-1");
    });
  }), qi(n, "keydown", (a) => {
    const l = a.target;
    if (!l.className.includes(t.b("node")))
      return;
    const c = a.code;
    i.value = Array.from(n.value.querySelectorAll(`.${t.is("focusable")}[role=treeitem]`));
    const u = i.value.indexOf(l);
    let h;
    if ([dt.up, dt.down].includes(c)) {
      if (a.preventDefault(), c === dt.up) {
        h = u === -1 ? 0 : u !== 0 ? u - 1 : i.value.length - 1;
        const f = h;
        for (; !e.value.getNode(i.value[h].dataset.key).canFocus; ) {
          if (h--, h === f) {
            h = -1;
            break;
          }
          h < 0 && (h = i.value.length - 1);
        }
      } else {
        h = u === -1 ? 0 : u < i.value.length - 1 ? u + 1 : 0;
        const f = h;
        for (; !e.value.getNode(i.value[h].dataset.key).canFocus; ) {
          if (h++, h === f) {
            h = -1;
            break;
          }
          h >= i.value.length && (h = 0);
        }
      }
      h !== -1 && i.value[h].focus();
    }
    [dt.left, dt.right].includes(c) && (a.preventDefault(), l.click());
    const d = l.querySelector('[type="checkbox"]');
    [dt.enter, dt.space].includes(c) && d && (a.preventDefault(), d.click());
  });
  const o = () => {
    var a;
    i.value = Array.from(n.value.querySelectorAll(`.${t.is("focusable")}[role=treeitem]`)), r.value = Array.from(n.value.querySelectorAll("input[type=checkbox]"));
    const l = n.value.querySelectorAll(`.${t.is("checked")}[role=treeitem]`);
    if (l.length) {
      l[0].setAttribute("tabindex", "0");
      return;
    }
    (a = i.value[0]) == null || a.setAttribute("tabindex", "0");
  };
}
const SJ = F({
  name: "ElTree",
  components: { ElTreeNode: wJ },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: Pn
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(n, e) {
    const { t } = mn(), i = me("tree"), r = D(new fJ({
      key: n.nodeKey,
      data: n.data,
      lazy: n.lazy,
      props: n.props,
      load: n.load,
      currentNodeKey: n.currentNodeKey,
      checkStrictly: n.checkStrictly,
      checkDescendants: n.checkDescendants,
      defaultCheckedKeys: n.defaultCheckedKeys,
      defaultExpandedKeys: n.defaultExpandedKeys,
      autoExpandParent: n.autoExpandParent,
      defaultExpandAll: n.defaultExpandAll,
      filterNodeMethod: n.filterNodeMethod
    }));
    r.value.initialize();
    const s = D(r.value.root), o = D(null), a = D(null), l = D(null), { broadcastExpanded: c } = nM(n), { dragState: u } = mJ({
      props: n,
      ctx: e,
      el$: a,
      dropIndicator$: l,
      store: r
    });
    xJ({ el$: a }, r);
    const h = $(() => {
      const { childNodes: N } = s.value;
      return !N || N.length === 0 || N.every(({ visible: q }) => !q);
    });
    ne(() => n.currentNodeKey, (N) => {
      r.value.setCurrentNodeKey(N);
    }), ne(() => n.defaultCheckedKeys, (N) => {
      r.value.setDefaultCheckedKey(N);
    }), ne(() => n.defaultExpandedKeys, (N) => {
      r.value.setDefaultExpandedKeys(N);
    }), ne(() => n.data, (N) => {
      r.value.setData(N);
    }, { deep: !0 }), ne(() => n.checkStrictly, (N) => {
      r.value.checkStrictly = N;
    });
    const d = (N) => {
      if (!n.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      r.value.filter(N);
    }, f = (N) => _w(n.nodeKey, N.data), p = (N) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const q = r.value.getNode(N);
      if (!q)
        return [];
      const j = [q.data];
      let H = q.parent;
      for (; H && H !== s.value; )
        j.push(H.data), H = H.parent;
      return j.reverse();
    }, g = (N, q) => r.value.getCheckedNodes(N, q), m = (N) => r.value.getCheckedKeys(N), v = () => {
      const N = r.value.getCurrentNode();
      return N ? N.data : null;
    }, y = () => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const N = v();
      return N ? N[n.nodeKey] : null;
    }, b = (N, q) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      r.value.setCheckedNodes(N, q);
    }, w = (N, q) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      r.value.setCheckedKeys(N, q);
    }, x = (N, q, j) => {
      r.value.setChecked(N, q, j);
    }, S = () => r.value.getHalfCheckedNodes(), C = () => r.value.getHalfCheckedKeys(), k = (N, q = !0) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      Ly(r, e.emit, () => r.value.setUserCurrentNode(N, q));
    }, E = (N, q = !0) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      Ly(r, e.emit, () => r.value.setCurrentNodeKey(N, q));
    }, M = (N) => r.value.getNode(N), _ = (N) => {
      r.value.remove(N);
    }, T = (N, q) => {
      r.value.append(N, q);
    }, B = (N, q) => {
      r.value.insertBefore(N, q);
    }, I = (N, q) => {
      r.value.insertAfter(N, q);
    }, P = (N, q, j) => {
      c(q), e.emit("node-expand", N, q, j);
    }, A = (N, q) => {
      if (!n.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      r.value.updateChildren(N, q);
    };
    return ft("RootTree", {
      ctx: e,
      props: n,
      store: r,
      root: s,
      currentNode: o,
      instance: Xe()
    }), ft(Da, void 0), {
      ns: i,
      store: r,
      root: s,
      currentNode: o,
      dragState: u,
      el$: a,
      dropIndicator$: l,
      isEmpty: h,
      filter: d,
      getNodeKey: f,
      getNodePath: p,
      getCheckedNodes: g,
      getCheckedKeys: m,
      getCurrentNode: v,
      getCurrentKey: y,
      setCheckedNodes: b,
      setCheckedKeys: w,
      setChecked: x,
      getHalfCheckedNodes: S,
      getHalfCheckedKeys: C,
      setCurrentNode: k,
      setCurrentKey: E,
      t,
      getNode: M,
      remove: _,
      append: T,
      insertBefore: B,
      insertAfter: I,
      handleNodeExpand: P,
      updateKeyChildren: A
    };
  }
});
function CJ(n, e, t, i, r, s) {
  const o = nt("el-tree-node");
  return R(), V("div", {
    ref: "el$",
    class: L([
      n.ns.b(),
      n.ns.is("dragging", !!n.dragState.draggingNode),
      n.ns.is("drop-not-allow", !n.dragState.allowDrop),
      n.ns.is("drop-inner", n.dragState.dropType === "inner"),
      { [n.ns.m("highlight-current")]: n.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (R(!0), V(Tt, null, ai(n.root.childNodes, (a) => (R(), ie(o, {
      key: n.getNodeKey(a),
      node: a,
      props: n.props,
      accordion: n.accordion,
      "render-after-expand": n.renderAfterExpand,
      "show-checkbox": n.showCheckbox,
      "render-content": n.renderContent,
      onNodeExpand: n.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    n.isEmpty ? (R(), V("div", {
      key: 0,
      class: L(n.ns.e("empty-block"))
    }, [
      de(n.$slots, "empty", {}, () => {
        var a;
        return [
          Z("span", {
            class: L(n.ns.e("empty-text"))
          }, xe((a = n.emptyText) != null ? a : n.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : G("v-if", !0),
    it(Z("div", {
      ref: "dropIndicator$",
      class: L(n.ns.e("drop-indicator"))
    }, null, 2), [
      [Qt, n.dragState.showDropIndicator]
    ])
  ], 2);
}
var yg = /* @__PURE__ */ Ce(SJ, [["render", CJ], ["__file", "tree.vue"]]);
yg.install = (n) => {
  n.component(yg.name, yg);
};
const kJ = yg, qKe = kJ, rM = Symbol("uploadContextKey"), PJ = "ElUpload";
class EJ extends Error {
  constructor(e, t, i, r) {
    super(e), this.name = "UploadAjaxError", this.status = t, this.method = i, this.url = r;
  }
}
function yk(n, e, t) {
  let i;
  return t.response ? i = `${t.response.error || t.response}` : t.responseText ? i = `${t.responseText}` : i = `fail to ${e.method} ${n} ${t.status}`, new EJ(i, t.status, e.method, n);
}
function AJ(n) {
  const e = n.responseText || n.response;
  if (!e)
    return e;
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
}
const $J = (n) => {
  typeof XMLHttpRequest > "u" && dr(PJ, "XMLHttpRequest is undefined");
  const e = new XMLHttpRequest(), t = n.action;
  e.upload && e.upload.addEventListener("progress", (s) => {
    const o = s;
    o.percent = s.total > 0 ? s.loaded / s.total * 100 : 0, n.onProgress(o);
  });
  const i = new FormData();
  if (n.data)
    for (const [s, o] of Object.entries(n.data))
      xt(o) && o.length ? i.append(s, ...o) : i.append(s, o);
  i.append(n.filename, n.file, n.file.name), e.addEventListener("error", () => {
    n.onError(yk(t, n, e));
  }), e.addEventListener("load", () => {
    if (e.status < 200 || e.status >= 300)
      return n.onError(yk(t, n, e));
    n.onSuccess(AJ(e));
  }), e.open(n.method, t, !0), n.withCredentials && "withCredentials" in e && (e.withCredentials = !0);
  const r = n.headers || {};
  if (r instanceof Headers)
    r.forEach((s, o) => e.setRequestHeader(o, s));
  else
    for (const [s, o] of Object.entries(r))
      Ni(o) || e.setRequestHeader(s, String(o));
  return e.send(i), e;
}, sM = ["text", "picture", "picture-card"];
let TJ = 1;
const Qy = () => Date.now() + TJ++, oM = Ee({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: ce(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: ce([Object, Function, Promise]),
    default: () => Ur({})
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: !1
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: ce(Array),
    default: () => Ur([])
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: sM,
    default: "text"
  },
  httpRequest: {
    type: ce(Function),
    default: $J
  },
  disabled: Boolean,
  limit: Number
}), _J = Ee({
  ...oM,
  beforeUpload: {
    type: ce(Function),
    default: Xt
  },
  beforeRemove: {
    type: ce(Function)
  },
  onRemove: {
    type: ce(Function),
    default: Xt
  },
  onChange: {
    type: ce(Function),
    default: Xt
  },
  onPreview: {
    type: ce(Function),
    default: Xt
  },
  onSuccess: {
    type: ce(Function),
    default: Xt
  },
  onProgress: {
    type: ce(Function),
    default: Xt
  },
  onError: {
    type: ce(Function),
    default: Xt
  },
  onExceed: {
    type: ce(Function),
    default: Xt
  },
  crossorigin: {
    type: ce(String)
  }
}), MJ = Ee({
  files: {
    type: ce(Array),
    default: () => Ur([])
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  handlePreview: {
    type: ce(Function),
    default: Xt
  },
  listType: {
    type: String,
    values: sM,
    default: "text"
  },
  crossorigin: {
    type: ce(String)
  }
}), RJ = {
  remove: (n) => !!n
}, NJ = ["onKeydown"], DJ = ["src", "crossorigin"], LJ = ["onClick"], IJ = ["title"], BJ = ["onClick"], QJ = ["onClick"], zJ = F({
  name: "ElUploadList"
}), jJ = /* @__PURE__ */ F({
  ...zJ,
  props: MJ,
  emits: RJ,
  setup(n, { emit: e }) {
    const t = n, { t: i } = mn(), r = me("upload"), s = me("icon"), o = me("list"), a = ts(), l = D(!1), c = $(() => [
      r.b("list"),
      r.bm("list", t.listType),
      r.is("disabled", t.disabled)
    ]), u = (h) => {
      e("remove", h);
    };
    return (h, d) => (R(), ie(bA, {
      tag: "ul",
      class: L(O(c)),
      name: O(o).b()
    }, {
      default: Y(() => [
        (R(!0), V(Tt, null, ai(h.files, (f) => (R(), V("li", {
          key: f.uid || f.name,
          class: L([
            O(r).be("list", "item"),
            O(r).is(f.status),
            { focusing: l.value }
          ]),
          tabindex: "0",
          onKeydown: Ut((p) => !O(a) && u(f), ["delete"]),
          onFocus: d[0] || (d[0] = (p) => l.value = !0),
          onBlur: d[1] || (d[1] = (p) => l.value = !1),
          onClick: d[2] || (d[2] = (p) => l.value = !1)
        }, [
          de(h.$slots, "default", { file: f }, () => [
            h.listType === "picture" || f.status !== "uploading" && h.listType === "picture-card" ? (R(), V("img", {
              key: 0,
              class: L(O(r).be("list", "item-thumbnail")),
              src: f.url,
              crossorigin: h.crossorigin,
              alt: ""
            }, null, 10, DJ)) : G("v-if", !0),
            f.status === "uploading" || h.listType !== "picture-card" ? (R(), V("div", {
              key: 1,
              class: L(O(r).be("list", "item-info"))
            }, [
              Z("a", {
                class: L(O(r).be("list", "item-name")),
                onClick: Le((p) => h.handlePreview(f), ["prevent"])
              }, [
                K(O(Fe), {
                  class: L(O(s).m("document"))
                }, {
                  default: Y(() => [
                    K(O(Rj))
                  ]),
                  _: 1
                }, 8, ["class"]),
                Z("span", {
                  class: L(O(r).be("list", "item-file-name")),
                  title: f.name
                }, xe(f.name), 11, IJ)
              ], 10, LJ),
              f.status === "uploading" ? (R(), ie(O(QU), {
                key: 0,
                type: h.listType === "picture-card" ? "circle" : "line",
                "stroke-width": h.listType === "picture-card" ? 6 : 2,
                percentage: Number(f.percentage),
                style: Qe(h.listType === "picture-card" ? "" : "margin-top: 0.5rem")
              }, null, 8, ["type", "stroke-width", "percentage", "style"])) : G("v-if", !0)
            ], 2)) : G("v-if", !0),
            Z("label", {
              class: L(O(r).be("list", "item-status-label"))
            }, [
              h.listType === "text" ? (R(), ie(O(Fe), {
                key: 0,
                class: L([O(s).m("upload-success"), O(s).m("circle-check")])
              }, {
                default: Y(() => [
                  K(O(K1))
                ]),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(h.listType) ? (R(), ie(O(Fe), {
                key: 1,
                class: L([O(s).m("upload-success"), O(s).m("check")])
              }, {
                default: Y(() => [
                  K(O(fv))
                ]),
                _: 1
              }, 8, ["class"])) : G("v-if", !0)
            ], 2),
            O(a) ? G("v-if", !0) : (R(), ie(O(Fe), {
              key: 2,
              class: L(O(s).m("close")),
              onClick: (p) => u(f)
            }, {
              default: Y(() => [
                K(O(jo))
              ]),
              _: 2
            }, 1032, ["class", "onClick"])),
            G(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            G(" This is a bug which needs to be fixed "),
            G(" TODO: Fix the incorrect navigation interaction "),
            O(a) ? G("v-if", !0) : (R(), V("i", {
              key: 3,
              class: L(O(s).m("close-tip"))
            }, xe(O(i)("el.upload.deleteTip")), 3)),
            h.listType === "picture-card" ? (R(), V("span", {
              key: 4,
              class: L(O(r).be("list", "item-actions"))
            }, [
              Z("span", {
                class: L(O(r).be("list", "item-preview")),
                onClick: (p) => h.handlePreview(f)
              }, [
                K(O(Fe), {
                  class: L(O(s).m("zoom-in"))
                }, {
                  default: Y(() => [
                    K(O(CV))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, BJ),
              O(a) ? G("v-if", !0) : (R(), V("span", {
                key: 0,
                class: L(O(r).be("list", "item-delete")),
                onClick: (p) => u(f)
              }, [
                K(O(Fe), {
                  class: L(O(s).m("delete"))
                }, {
                  default: Y(() => [
                    K(O(_j))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, QJ))
            ], 2)) : G("v-if", !0)
          ])
        ], 42, NJ))), 128)),
        de(h.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var Ok = /* @__PURE__ */ Ce(jJ, [["__file", "upload-list.vue"]]);
const VJ = Ee({
  disabled: {
    type: Boolean,
    default: !1
  }
}), FJ = {
  file: (n) => xt(n)
}, ZJ = ["onDrop", "onDragover"], aM = "ElUploadDrag", qJ = F({
  name: aM
}), WJ = /* @__PURE__ */ F({
  ...qJ,
  props: VJ,
  emits: FJ,
  setup(n, { emit: e }) {
    const t = ke(rM);
    t || dr(aM, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const i = me("upload"), r = D(!1), s = ts(), o = (l) => {
      if (s.value)
        return;
      r.value = !1, l.stopPropagation();
      const c = Array.from(l.dataTransfer.files), u = t.accept.value;
      if (!u) {
        e("file", c);
        return;
      }
      const h = c.filter((d) => {
        const { type: f, name: p } = d, g = p.includes(".") ? `.${p.split(".").pop()}` : "", m = f.replace(/\/.*$/, "");
        return u.split(",").map((v) => v.trim()).filter((v) => v).some((v) => v.startsWith(".") ? g === v : /\/\*$/.test(v) ? m === v.replace(/\/\*$/, "") : /^[^/]+\/[^/]+$/.test(v) ? f === v : !1);
      });
      e("file", h);
    }, a = () => {
      s.value || (r.value = !0);
    };
    return (l, c) => (R(), V("div", {
      class: L([O(i).b("dragger"), O(i).is("dragover", r.value)]),
      onDrop: Le(o, ["prevent"]),
      onDragover: Le(a, ["prevent"]),
      onDragleave: c[0] || (c[0] = Le((u) => r.value = !1, ["prevent"]))
    }, [
      de(l.$slots, "default")
    ], 42, ZJ));
  }
});
var HJ = /* @__PURE__ */ Ce(WJ, [["__file", "upload-dragger.vue"]]);
const XJ = Ee({
  ...oM,
  beforeUpload: {
    type: ce(Function),
    default: Xt
  },
  onRemove: {
    type: ce(Function),
    default: Xt
  },
  onStart: {
    type: ce(Function),
    default: Xt
  },
  onSuccess: {
    type: ce(Function),
    default: Xt
  },
  onProgress: {
    type: ce(Function),
    default: Xt
  },
  onError: {
    type: ce(Function),
    default: Xt
  },
  onExceed: {
    type: ce(Function),
    default: Xt
  }
}), YJ = ["onKeydown"], UJ = ["name", "multiple", "accept"], GJ = F({
  name: "ElUploadContent",
  inheritAttrs: !1
}), KJ = /* @__PURE__ */ F({
  ...GJ,
  props: XJ,
  setup(n, { expose: e }) {
    const t = n, i = me("upload"), r = ts(), s = In({}), o = In(), a = (g) => {
      if (g.length === 0)
        return;
      const { autoUpload: m, limit: v, fileList: y, multiple: b, onStart: w, onExceed: x } = t;
      if (v && y.length + g.length > v) {
        x(g, y);
        return;
      }
      b || (g = g.slice(0, 1));
      for (const S of g) {
        const C = S;
        C.uid = Qy(), w(C), m && l(C);
      }
    }, l = async (g) => {
      if (o.value.value = "", !t.beforeUpload)
        return u(g);
      let m, v = {};
      try {
        const b = t.data, w = t.beforeUpload(g);
        v = cC(t.data) ? Bt(t.data) : t.data, m = await w, cC(t.data) && cn(b, v) && (v = Bt(t.data));
      } catch {
        m = !1;
      }
      if (m === !1) {
        t.onRemove(g);
        return;
      }
      let y = g;
      m instanceof Blob && (m instanceof File ? y = m : y = new File([m], g.name, {
        type: g.type
      })), u(Object.assign(y, {
        uid: g.uid
      }), v);
    }, c = async (g, m) => wt(g) ? g(m) : g, u = async (g, m) => {
      const {
        headers: v,
        data: y,
        method: b,
        withCredentials: w,
        name: x,
        action: S,
        onProgress: C,
        onSuccess: k,
        onError: E,
        httpRequest: M
      } = t;
      try {
        m = await c(m ?? y, g);
      } catch {
        t.onRemove(g);
        return;
      }
      const { uid: _ } = g, T = {
        headers: v || {},
        withCredentials: w,
        file: g,
        data: m,
        method: b,
        filename: x,
        action: S,
        onProgress: (I) => {
          C(I, g);
        },
        onSuccess: (I) => {
          k(I, g), delete s.value[_];
        },
        onError: (I) => {
          E(I, g), delete s.value[_];
        }
      }, B = M(T);
      s.value[_] = B, B instanceof Promise && B.then(T.onSuccess, T.onError);
    }, h = (g) => {
      const m = g.target.files;
      m && a(Array.from(m));
    }, d = () => {
      r.value || (o.value.value = "", o.value.click());
    }, f = () => {
      d();
    };
    return e({
      abort: (g) => {
        UF(s.value).filter(g ? ([v]) => String(g.uid) === v : () => !0).forEach(([v, y]) => {
          y instanceof XMLHttpRequest && y.abort(), delete s.value[v];
        });
      },
      upload: l
    }), (g, m) => (R(), V("div", {
      class: L([O(i).b(), O(i).m(g.listType), O(i).is("drag", g.drag)]),
      tabindex: "0",
      onClick: d,
      onKeydown: Ut(Le(f, ["self"]), ["enter", "space"])
    }, [
      g.drag ? (R(), ie(HJ, {
        key: 0,
        disabled: O(r),
        onFile: a
      }, {
        default: Y(() => [
          de(g.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled"])) : de(g.$slots, "default", { key: 1 }),
      Z("input", {
        ref_key: "inputRef",
        ref: o,
        class: L(O(i).e("input")),
        name: g.name,
        multiple: g.multiple,
        accept: g.accept,
        type: "file",
        onChange: h,
        onClick: m[0] || (m[0] = Le(() => {
        }, ["stop"]))
      }, null, 42, UJ)
    ], 42, YJ));
  }
});
var wk = /* @__PURE__ */ Ce(KJ, [["__file", "upload-content.vue"]]);
const xk = "ElUpload", Sk = (n) => {
  var e;
  (e = n.url) != null && e.startsWith("blob:") && URL.revokeObjectURL(n.url);
}, JJ = (n, e) => {
  const t = zF(n, "fileList", void 0, { passive: !0 }), i = (d) => t.value.find((f) => f.uid === d.uid);
  function r(d) {
    var f;
    (f = e.value) == null || f.abort(d);
  }
  function s(d = ["ready", "uploading", "success", "fail"]) {
    t.value = t.value.filter((f) => !d.includes(f.status));
  }
  const o = (d, f) => {
    const p = i(f);
    p && (console.error(d), p.status = "fail", t.value.splice(t.value.indexOf(p), 1), n.onError(d, p, t.value), n.onChange(p, t.value));
  }, a = (d, f) => {
    const p = i(f);
    p && (n.onProgress(d, p, t.value), p.status = "uploading", p.percentage = Math.round(d.percent));
  }, l = (d, f) => {
    const p = i(f);
    p && (p.status = "success", p.response = d, n.onSuccess(d, p, t.value), n.onChange(p, t.value));
  }, c = (d) => {
    Ni(d.uid) && (d.uid = Qy());
    const f = {
      name: d.name,
      percentage: 0,
      status: "ready",
      size: d.size,
      raw: d,
      uid: d.uid
    };
    if (n.listType === "picture-card" || n.listType === "picture")
      try {
        f.url = URL.createObjectURL(d);
      } catch (p) {
        pt(xk, p.message), n.onError(p, f, t.value);
      }
    t.value = [...t.value, f], n.onChange(f, t.value);
  }, u = async (d) => {
    const f = d instanceof File ? i(d) : d;
    f || dr(xk, "file to be removed not found");
    const p = (g) => {
      r(g);
      const m = t.value;
      m.splice(m.indexOf(g), 1), n.onRemove(g, m), Sk(g);
    };
    n.beforeRemove ? await n.beforeRemove(f, t.value) !== !1 && p(f) : p(f);
  };
  function h() {
    t.value.filter(({ status: d }) => d === "ready").forEach(({ raw: d }) => {
      var f;
      return d && ((f = e.value) == null ? void 0 : f.upload(d));
    });
  }
  return ne(() => n.listType, (d) => {
    d !== "picture-card" && d !== "picture" || (t.value = t.value.map((f) => {
      const { raw: p, url: g } = f;
      if (!g && p)
        try {
          f.url = URL.createObjectURL(p);
        } catch (m) {
          n.onError(m, f, t.value);
        }
      return f;
    }));
  }), ne(t, (d) => {
    for (const f of d)
      f.uid || (f.uid = Qy()), f.status || (f.status = "success");
  }, { immediate: !0, deep: !0 }), {
    uploadFiles: t,
    abort: r,
    clearFiles: s,
    handleError: o,
    handleProgress: a,
    handleStart: c,
    handleSuccess: l,
    handleRemove: u,
    submit: h,
    revokeFileObjectURL: Sk
  };
}, eee = F({
  name: "ElUpload"
}), tee = /* @__PURE__ */ F({
  ...eee,
  props: _J,
  setup(n, { expose: e }) {
    const t = n, i = ts(), r = In(), {
      abort: s,
      submit: o,
      clearFiles: a,
      uploadFiles: l,
      handleStart: c,
      handleError: u,
      handleRemove: h,
      handleSuccess: d,
      handleProgress: f,
      revokeFileObjectURL: p
    } = JJ(t, r), g = $(() => t.listType === "picture-card"), m = $(() => ({
      ...t,
      fileList: l.value,
      onStart: c,
      onProgress: f,
      onSuccess: d,
      onError: u,
      onRemove: h
    }));
    return Kn(() => {
      l.value.forEach(p);
    }), ft(rM, {
      accept: Pr(t, "accept")
    }), e({
      abort: s,
      submit: o,
      clearFiles: a,
      handleStart: c,
      handleRemove: h
    }), (v, y) => (R(), V("div", null, [
      O(g) && v.showFileList ? (R(), ie(Ok, {
        key: 0,
        disabled: O(i),
        "list-type": v.listType,
        files: O(l),
        crossorigin: v.crossorigin,
        "handle-preview": v.onPreview,
        onRemove: O(h)
      }, Fg({
        append: Y(() => [
          K(wk, Pi({
            ref_key: "uploadRef",
            ref: r
          }, O(m)), {
            default: Y(() => [
              v.$slots.trigger ? de(v.$slots, "trigger", { key: 0 }) : G("v-if", !0),
              !v.$slots.trigger && v.$slots.default ? de(v.$slots, "default", { key: 1 }) : G("v-if", !0)
            ]),
            _: 3
          }, 16)
        ]),
        _: 2
      }, [
        v.$slots.file ? {
          name: "default",
          fn: Y(({ file: b }) => [
            de(v.$slots, "file", { file: b })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : G("v-if", !0),
      !O(g) || O(g) && !v.showFileList ? (R(), ie(wk, Pi({
        key: 1,
        ref_key: "uploadRef",
        ref: r
      }, O(m)), {
        default: Y(() => [
          v.$slots.trigger ? de(v.$slots, "trigger", { key: 0 }) : G("v-if", !0),
          !v.$slots.trigger && v.$slots.default ? de(v.$slots, "default", { key: 1 }) : G("v-if", !0)
        ]),
        _: 3
      }, 16)) : G("v-if", !0),
      v.$slots.trigger ? de(v.$slots, "default", { key: 2 }) : G("v-if", !0),
      de(v.$slots, "tip"),
      !O(g) && v.showFileList ? (R(), ie(Ok, {
        key: 3,
        disabled: O(i),
        "list-type": v.listType,
        files: O(l),
        crossorigin: v.crossorigin,
        "handle-preview": v.onPreview,
        onRemove: O(h)
      }, Fg({ _: 2 }, [
        v.$slots.file ? {
          name: "default",
          fn: Y(({ file: b }) => [
            de(v.$slots, "file", { file: b })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : G("v-if", !0)
    ]));
  }
});
var nee = /* @__PURE__ */ Ce(tee, [["__file", "upload.vue"]]);
const WKe = Ft(nee), lM = ["success", "info", "warning", "error"], Ji = Ur({
  customClass: "",
  center: !1,
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: vt ? document.body : void 0
}), iee = Ee({
  customClass: {
    type: String,
    default: Ji.customClass
  },
  center: {
    type: Boolean,
    default: Ji.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: Ji.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: Ji.duration
  },
  icon: {
    type: Pn,
    default: Ji.icon
  },
  id: {
    type: String,
    default: Ji.id
  },
  message: {
    type: ce([
      String,
      Object,
      Function
    ]),
    default: Ji.message
  },
  onClose: {
    type: ce(Function),
    required: !1
  },
  showClose: {
    type: Boolean,
    default: Ji.showClose
  },
  type: {
    type: String,
    values: lM,
    default: Ji.type
  },
  offset: {
    type: Number,
    default: Ji.offset
  },
  zIndex: {
    type: Number,
    default: Ji.zIndex
  },
  grouping: {
    type: Boolean,
    default: Ji.grouping
  },
  repeatNum: {
    type: Number,
    default: Ji.repeatNum
  }
}), ree = {
  destroy: () => !0
}, gs = LL([]), see = (n) => {
  const e = gs.findIndex((r) => r.id === n), t = gs[e];
  let i;
  return e > 0 && (i = gs[e - 1]), { current: t, prev: i };
}, oee = (n) => {
  const { prev: e } = see(n);
  return e ? e.vm.exposed.bottom.value : 0;
}, aee = (n, e) => gs.findIndex((i) => i.id === n) > 0 ? 20 : e, lee = ["id"], cee = ["innerHTML"], uee = F({
  name: "ElMessage"
}), hee = /* @__PURE__ */ F({
  ...uee,
  props: iee,
  emits: ree,
  setup(n, { expose: e }) {
    const t = n, { Close: i } = rT, { ns: r, zIndex: s } = mw("message"), { currentZIndex: o, nextZIndex: a } = s, l = D(), c = D(!1), u = D(0);
    let h;
    const d = $(() => t.type ? t.type === "error" ? "danger" : t.type : "info"), f = $(() => {
      const C = t.type;
      return { [r.bm("icon", C)]: C && gu[C] };
    }), p = $(() => t.icon || gu[t.type] || ""), g = $(() => oee(t.id)), m = $(() => aee(t.id, t.offset) + g.value), v = $(() => u.value + m.value), y = $(() => ({
      top: `${m.value}px`,
      zIndex: o.value
    }));
    function b() {
      t.duration !== 0 && ({ stop: h } = Ug(() => {
        x();
      }, t.duration));
    }
    function w() {
      h == null || h();
    }
    function x() {
      c.value = !1;
    }
    function S({ code: C }) {
      C === dt.esc && x();
    }
    return qe(() => {
      b(), a(), c.value = !0;
    }), ne(() => t.repeatNum, () => {
      w(), b();
    }), qi(document, "keydown", S), pn(l, () => {
      u.value = l.value.getBoundingClientRect().height;
    }), e({
      visible: c,
      bottom: v,
      close: x
    }), (C, k) => (R(), ie(bo, {
      name: O(r).b("fade"),
      onBeforeLeave: C.onClose,
      onAfterLeave: k[0] || (k[0] = (E) => C.$emit("destroy")),
      persisted: ""
    }, {
      default: Y(() => [
        it(Z("div", {
          id: C.id,
          ref_key: "messageRef",
          ref: l,
          class: L([
            O(r).b(),
            { [O(r).m(C.type)]: C.type },
            O(r).is("center", C.center),
            O(r).is("closable", C.showClose),
            C.customClass
          ]),
          style: Qe(O(y)),
          role: "alert",
          onMouseenter: w,
          onMouseleave: b
        }, [
          C.repeatNum > 1 ? (R(), ie(O(I9), {
            key: 0,
            value: C.repeatNum,
            type: O(d),
            class: L(O(r).e("badge"))
          }, null, 8, ["value", "type", "class"])) : G("v-if", !0),
          O(p) ? (R(), ie(O(Fe), {
            key: 1,
            class: L([O(r).e("icon"), O(f)])
          }, {
            default: Y(() => [
              (R(), ie(yt(O(p))))
            ]),
            _: 1
          }, 8, ["class"])) : G("v-if", !0),
          de(C.$slots, "default", {}, () => [
            C.dangerouslyUseHTMLString ? (R(), V(Tt, { key: 1 }, [
              G(" Caution here, message could've been compromised, never use user's input as message "),
              Z("p", {
                class: L(O(r).e("content")),
                innerHTML: C.message
              }, null, 10, cee)
            ], 2112)) : (R(), V("p", {
              key: 0,
              class: L(O(r).e("content"))
            }, xe(C.message), 3))
          ]),
          C.showClose ? (R(), ie(O(Fe), {
            key: 2,
            class: L(O(r).e("closeBtn")),
            onClick: Le(x, ["stop"])
          }, {
            default: Y(() => [
              K(O(i))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : G("v-if", !0)
        ], 46, lee), [
          [Qt, c.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var dee = /* @__PURE__ */ Ce(hee, [["__file", "message.vue"]]);
let fee = 1;
const cM = (n) => {
  const e = !n || bt(n) || co(n) || wt(n) ? { message: n } : n, t = {
    ...Ji,
    ...e
  };
  if (!t.appendTo)
    t.appendTo = document.body;
  else if (bt(t.appendTo)) {
    let i = document.querySelector(t.appendTo);
    Os(i) || (pt("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), i = document.body), t.appendTo = i;
  }
  return t;
}, pee = (n) => {
  const e = gs.indexOf(n);
  if (e === -1)
    return;
  gs.splice(e, 1);
  const { handler: t } = n;
  t.close();
}, gee = ({ appendTo: n, ...e }, t) => {
  const i = `message_${fee++}`, r = e.onClose, s = document.createElement("div"), o = {
    ...e,
    id: i,
    onClose: () => {
      r == null || r(), pee(u);
    },
    onDestroy: () => {
      Na(null, s);
    }
  }, a = K(dee, o, wt(o.message) || co(o.message) ? {
    default: wt(o.message) ? o.message : () => o.message
  } : null);
  a.appContext = t || Su._context, Na(a, s), n.appendChild(s.firstElementChild);
  const l = a.component, u = {
    id: i,
    vnode: a,
    vm: l,
    handler: {
      close: () => {
        l.exposed.visible.value = !1;
      }
    },
    props: a.component.props
  };
  return u;
}, Su = (n = {}, e) => {
  if (!vt)
    return { close: () => {
    } };
  if (tt(cy.max) && gs.length >= cy.max)
    return { close: () => {
    } };
  const t = cM(n);
  if (t.grouping && gs.length) {
    const r = gs.find(({ vnode: s }) => {
      var o;
      return ((o = s.props) == null ? void 0 : o.message) === t.message;
    });
    if (r)
      return r.props.repeatNum += 1, r.props.type = t.type, r.handler;
  }
  const i = gee(t, e);
  return gs.push(i), i.handler;
};
lM.forEach((n) => {
  Su[n] = (e = {}, t) => {
    const i = cM(e);
    return Su({ ...i, type: n }, t);
  };
});
function mee(n) {
  for (const e of gs)
    (!n || n === e.props.type) && e.handler.close();
}
Su.closeAll = mee;
Su._context = null;
const HKe = sT(Su, "$message"), vee = F({
  name: "ElMessageBox",
  directives: {
    TrapFocus: hW
  },
  components: {
    ElButton: Wl,
    ElFocusTrap: yv,
    ElInput: uc,
    ElOverlay: Sw,
    ElIcon: Fe,
    ...rT
  },
  inheritAttrs: !1,
  props: {
    buttonSize: {
      type: String,
      validator: oT
    },
    modal: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    closeOnHashChange: {
      type: Boolean,
      default: !0
    },
    center: Boolean,
    draggable: Boolean,
    overflow: Boolean,
    roundButton: {
      default: !1,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(n, { emit: e }) {
    const {
      locale: t,
      zIndex: i,
      ns: r,
      size: s
    } = mw("message-box", $(() => n.buttonSize)), { t: o } = t, { nextZIndex: a } = i, l = D(!1), c = Gt({
      autofocus: !0,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: !1,
      distinguishCancelAndClose: !1,
      icon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: !0,
      modalClass: "",
      showCancelButton: !1,
      showConfirmButton: !0,
      type: "",
      title: void 0,
      showInput: !1,
      action: "",
      confirmButtonLoading: !1,
      cancelButtonLoading: !1,
      confirmButtonDisabled: !1,
      editorErrorMessage: "",
      validateError: !1,
      zIndex: a()
    }), u = $(() => {
      const A = c.type;
      return { [r.bm("icon", A)]: A && gu[A] };
    }), h = ws(), d = ws(), f = $(() => c.icon || gu[c.type] || ""), p = $(() => !!c.message), g = D(), m = D(), v = D(), y = D(), b = D(), w = $(() => c.confirmButtonClass);
    ne(() => c.inputValue, async (A) => {
      await $e(), n.boxType === "prompt" && A !== null && T();
    }, { immediate: !0 }), ne(() => l.value, (A) => {
      var N, q;
      A && (n.boxType !== "prompt" && (c.autofocus ? v.value = (q = (N = b.value) == null ? void 0 : N.$el) != null ? q : g.value : v.value = g.value), c.zIndex = a()), n.boxType === "prompt" && (A ? $e().then(() => {
        var j;
        y.value && y.value.$el && (c.autofocus ? v.value = (j = B()) != null ? j : g.value : v.value = g.value);
      }) : (c.editorErrorMessage = "", c.validateError = !1));
    });
    const x = $(() => n.draggable), S = $(() => n.overflow);
    lT(g, m, x, S), qe(async () => {
      await $e(), n.closeOnHashChange && window.addEventListener("hashchange", C);
    }), Kn(() => {
      n.closeOnHashChange && window.removeEventListener("hashchange", C);
    });
    function C() {
      l.value && (l.value = !1, $e(() => {
        c.action && e("action", c.action);
      }));
    }
    const k = () => {
      n.closeOnClickModal && _(c.distinguishCancelAndClose ? "close" : "cancel");
    }, E = fw(k), M = (A) => {
      if (c.inputType !== "textarea")
        return A.preventDefault(), _("confirm");
    }, _ = (A) => {
      var N;
      n.boxType === "prompt" && A === "confirm" && !T() || (c.action = A, c.beforeClose ? (N = c.beforeClose) == null || N.call(c, A, c, C) : C());
    }, T = () => {
      if (n.boxType === "prompt") {
        const A = c.inputPattern;
        if (A && !A.test(c.inputValue || ""))
          return c.editorErrorMessage = c.inputErrorMessage || o("el.messagebox.error"), c.validateError = !0, !1;
        const N = c.inputValidator;
        if (typeof N == "function") {
          const q = N(c.inputValue);
          if (q === !1)
            return c.editorErrorMessage = c.inputErrorMessage || o("el.messagebox.error"), c.validateError = !0, !1;
          if (typeof q == "string")
            return c.editorErrorMessage = q, c.validateError = !0, !1;
        }
      }
      return c.editorErrorMessage = "", c.validateError = !1, !0;
    }, B = () => {
      const A = y.value.$refs;
      return A.input || A.textarea;
    }, I = () => {
      _("close");
    }, P = () => {
      n.closeOnPressEscape && I();
    };
    return n.lockScroll && gT(l), {
      ...Hr(c),
      ns: r,
      overlayEvent: E,
      visible: l,
      hasMessage: p,
      typeClass: u,
      contentId: h,
      inputId: d,
      btnSize: s,
      iconComponent: f,
      confirmButtonClasses: w,
      rootRef: g,
      focusStartRef: v,
      headerRef: m,
      inputRef: y,
      confirmRef: b,
      doClose: C,
      handleClose: I,
      onCloseRequested: P,
      handleWrapperClick: k,
      handleInputEnter: M,
      handleAction: _,
      t: o
    };
  }
}), bee = ["aria-label", "aria-describedby"], yee = ["aria-label"], Oee = ["id"];
function wee(n, e, t, i, r, s) {
  const o = nt("el-icon"), a = nt("close"), l = nt("el-input"), c = nt("el-button"), u = nt("el-focus-trap"), h = nt("el-overlay");
  return R(), ie(bo, {
    name: "fade-in-linear",
    onAfterLeave: e[11] || (e[11] = (d) => n.$emit("vanish")),
    persisted: ""
  }, {
    default: Y(() => [
      it(K(h, {
        "z-index": n.zIndex,
        "overlay-class": [n.ns.is("message-box"), n.modalClass],
        mask: n.modal
      }, {
        default: Y(() => [
          Z("div", {
            role: "dialog",
            "aria-label": n.title,
            "aria-modal": "true",
            "aria-describedby": n.showInput ? void 0 : n.contentId,
            class: L(`${n.ns.namespace.value}-overlay-message-box`),
            onClick: e[8] || (e[8] = (...d) => n.overlayEvent.onClick && n.overlayEvent.onClick(...d)),
            onMousedown: e[9] || (e[9] = (...d) => n.overlayEvent.onMousedown && n.overlayEvent.onMousedown(...d)),
            onMouseup: e[10] || (e[10] = (...d) => n.overlayEvent.onMouseup && n.overlayEvent.onMouseup(...d))
          }, [
            K(u, {
              loop: "",
              trapped: n.visible,
              "focus-trap-el": n.rootRef,
              "focus-start-el": n.focusStartRef,
              onReleaseRequested: n.onCloseRequested
            }, {
              default: Y(() => [
                Z("div", {
                  ref: "rootRef",
                  class: L([
                    n.ns.b(),
                    n.customClass,
                    n.ns.is("draggable", n.draggable),
                    { [n.ns.m("center")]: n.center }
                  ]),
                  style: Qe(n.customStyle),
                  tabindex: "-1",
                  onClick: e[7] || (e[7] = Le(() => {
                  }, ["stop"]))
                }, [
                  n.title !== null && n.title !== void 0 ? (R(), V("div", {
                    key: 0,
                    ref: "headerRef",
                    class: L([n.ns.e("header"), { "show-close": n.showClose }])
                  }, [
                    Z("div", {
                      class: L(n.ns.e("title"))
                    }, [
                      n.iconComponent && n.center ? (R(), ie(o, {
                        key: 0,
                        class: L([n.ns.e("status"), n.typeClass])
                      }, {
                        default: Y(() => [
                          (R(), ie(yt(n.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : G("v-if", !0),
                      Z("span", null, xe(n.title), 1)
                    ], 2),
                    n.showClose ? (R(), V("button", {
                      key: 0,
                      type: "button",
                      class: L(n.ns.e("headerbtn")),
                      "aria-label": n.t("el.messagebox.close"),
                      onClick: e[0] || (e[0] = (d) => n.handleAction(n.distinguishCancelAndClose ? "close" : "cancel")),
                      onKeydown: e[1] || (e[1] = Ut(Le((d) => n.handleAction(n.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                    }, [
                      K(o, {
                        class: L(n.ns.e("close"))
                      }, {
                        default: Y(() => [
                          K(a)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 42, yee)) : G("v-if", !0)
                  ], 2)) : G("v-if", !0),
                  Z("div", {
                    id: n.contentId,
                    class: L(n.ns.e("content"))
                  }, [
                    Z("div", {
                      class: L(n.ns.e("container"))
                    }, [
                      n.iconComponent && !n.center && n.hasMessage ? (R(), ie(o, {
                        key: 0,
                        class: L([n.ns.e("status"), n.typeClass])
                      }, {
                        default: Y(() => [
                          (R(), ie(yt(n.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : G("v-if", !0),
                      n.hasMessage ? (R(), V("div", {
                        key: 1,
                        class: L(n.ns.e("message"))
                      }, [
                        de(n.$slots, "default", {}, () => [
                          n.dangerouslyUseHTMLString ? (R(), ie(yt(n.showInput ? "label" : "p"), {
                            key: 1,
                            for: n.showInput ? n.inputId : void 0,
                            innerHTML: n.message
                          }, null, 8, ["for", "innerHTML"])) : (R(), ie(yt(n.showInput ? "label" : "p"), {
                            key: 0,
                            for: n.showInput ? n.inputId : void 0
                          }, {
                            default: Y(() => [
                              Yn(xe(n.dangerouslyUseHTMLString ? "" : n.message), 1)
                            ]),
                            _: 1
                          }, 8, ["for"]))
                        ])
                      ], 2)) : G("v-if", !0)
                    ], 2),
                    it(Z("div", {
                      class: L(n.ns.e("input"))
                    }, [
                      K(l, {
                        id: n.inputId,
                        ref: "inputRef",
                        modelValue: n.inputValue,
                        "onUpdate:modelValue": e[2] || (e[2] = (d) => n.inputValue = d),
                        type: n.inputType,
                        placeholder: n.inputPlaceholder,
                        "aria-invalid": n.validateError,
                        class: L({ invalid: n.validateError }),
                        onKeydown: Ut(n.handleInputEnter, ["enter"])
                      }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                      Z("div", {
                        class: L(n.ns.e("errormsg")),
                        style: Qe({
                          visibility: n.editorErrorMessage ? "visible" : "hidden"
                        })
                      }, xe(n.editorErrorMessage), 7)
                    ], 2), [
                      [Qt, n.showInput]
                    ])
                  ], 10, Oee),
                  Z("div", {
                    class: L(n.ns.e("btns"))
                  }, [
                    n.showCancelButton ? (R(), ie(c, {
                      key: 0,
                      loading: n.cancelButtonLoading,
                      class: L([n.cancelButtonClass]),
                      round: n.roundButton,
                      size: n.btnSize,
                      onClick: e[3] || (e[3] = (d) => n.handleAction("cancel")),
                      onKeydown: e[4] || (e[4] = Ut(Le((d) => n.handleAction("cancel"), ["prevent"]), ["enter"]))
                    }, {
                      default: Y(() => [
                        Yn(xe(n.cancelButtonText || n.t("el.messagebox.cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "size"])) : G("v-if", !0),
                    it(K(c, {
                      ref: "confirmRef",
                      type: "primary",
                      loading: n.confirmButtonLoading,
                      class: L([n.confirmButtonClasses]),
                      round: n.roundButton,
                      disabled: n.confirmButtonDisabled,
                      size: n.btnSize,
                      onClick: e[5] || (e[5] = (d) => n.handleAction("confirm")),
                      onKeydown: e[6] || (e[6] = Ut(Le((d) => n.handleAction("confirm"), ["prevent"]), ["enter"]))
                    }, {
                      default: Y(() => [
                        Yn(xe(n.confirmButtonText || n.t("el.messagebox.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "disabled", "size"]), [
                      [Qt, n.showConfirmButton]
                    ])
                  ], 2)
                ], 6)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, bee)
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [Qt, n.visible]
      ])
    ]),
    _: 3
  });
}
var xee = /* @__PURE__ */ Ce(vee, [["render", wee], ["__file", "index.vue"]]);
const zd = /* @__PURE__ */ new Map(), See = (n) => {
  let e = document.body;
  return n.appendTo && (bt(n.appendTo) && (e = document.querySelector(n.appendTo)), Os(n.appendTo) && (e = n.appendTo), Os(e) || (pt("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body."), e = document.body)), e;
}, Cee = (n, e, t = null) => {
  const i = K(xee, n, wt(n.message) || co(n.message) ? {
    default: wt(n.message) ? n.message : () => n.message
  } : null);
  return i.appContext = t, Na(i, e), See(n).appendChild(e.firstElementChild), i.component;
}, kee = () => document.createElement("div"), Pee = (n, e) => {
  const t = kee();
  n.onVanish = () => {
    Na(null, t), zd.delete(r);
  }, n.onAction = (s) => {
    const o = zd.get(r);
    let a;
    n.showInput ? a = { value: r.inputValue, action: s } : a = s, n.callback ? n.callback(a, i.proxy) : s === "cancel" || s === "close" ? n.distinguishCancelAndClose && s !== "cancel" ? o.reject("close") : o.reject("cancel") : o.resolve(a);
  };
  const i = Cee(n, t, e), r = i.proxy;
  for (const s in n)
    Xi(n, s) && !Xi(r.$props, s) && (r[s] = n[s]);
  return r.visible = !0, r;
};
function hh(n, e = null) {
  if (!vt)
    return Promise.reject();
  let t;
  return bt(n) || co(n) ? n = {
    message: n
  } : t = n.callback, new Promise((i, r) => {
    const s = Pee(n, e ?? hh._context);
    zd.set(s, {
      options: n,
      callback: t,
      resolve: i,
      reject: r
    });
  });
}
const Eee = ["alert", "confirm", "prompt"], Aee = {
  alert: { closeOnPressEscape: !1, closeOnClickModal: !1 },
  confirm: { showCancelButton: !0 },
  prompt: { showCancelButton: !0, showInput: !0 }
};
Eee.forEach((n) => {
  hh[n] = $ee(n);
});
function $ee(n) {
  return (e, t, i, r) => {
    let s = "";
    return an(t) ? (i = t, s = "") : Ci(t) ? s = "" : s = t, hh(Object.assign({
      title: s,
      message: e,
      type: "",
      ...Aee[n]
    }, i, {
      boxType: n
    }), r);
  };
}
hh.close = () => {
  zd.forEach((n, e) => {
    e.doClose();
  }), zd.clear();
};
hh._context = null;
const ua = hh;
ua.install = (n) => {
  ua._context = n._context, n.config.globalProperties.$msgbox = ua, n.config.globalProperties.$messageBox = ua, n.config.globalProperties.$alert = ua.alert, n.config.globalProperties.$confirm = ua.confirm, n.config.globalProperties.$prompt = ua.prompt;
};
const XKe = ua, uM = [
  "success",
  "info",
  "warning",
  "error"
], Tee = Ee({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: Pn
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: ce([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: ce(Function),
    default: () => {
    }
  },
  onClose: {
    type: ce(Function),
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...uM, ""],
    default: ""
  },
  zIndex: Number
}), _ee = {
  destroy: () => !0
}, Mee = ["id"], Ree = ["textContent"], Nee = { key: 0 }, Dee = ["innerHTML"], Lee = F({
  name: "ElNotification"
}), Iee = /* @__PURE__ */ F({
  ...Lee,
  props: Tee,
  emits: _ee,
  setup(n, { expose: e }) {
    const t = n, { ns: i, zIndex: r } = mw("notification"), { nextZIndex: s, currentZIndex: o } = r, { Close: a } = iT, l = D(!1);
    let c;
    const u = $(() => {
      const b = t.type;
      return b && gu[t.type] ? i.m(b) : "";
    }), h = $(() => t.type && gu[t.type] || t.icon), d = $(() => t.position.endsWith("right") ? "right" : "left"), f = $(() => t.position.startsWith("top") ? "top" : "bottom"), p = $(() => {
      var b;
      return {
        [f.value]: `${t.offset}px`,
        zIndex: (b = t.zIndex) != null ? b : o.value
      };
    });
    function g() {
      t.duration > 0 && ({ stop: c } = Ug(() => {
        l.value && v();
      }, t.duration));
    }
    function m() {
      c == null || c();
    }
    function v() {
      l.value = !1;
    }
    function y({ code: b }) {
      b === dt.delete || b === dt.backspace ? m() : b === dt.esc ? l.value && v() : g();
    }
    return qe(() => {
      g(), s(), l.value = !0;
    }), qi(document, "keydown", y), e({
      visible: l,
      close: v
    }), (b, w) => (R(), ie(bo, {
      name: O(i).b("fade"),
      onBeforeLeave: b.onClose,
      onAfterLeave: w[1] || (w[1] = (x) => b.$emit("destroy")),
      persisted: ""
    }, {
      default: Y(() => [
        it(Z("div", {
          id: b.id,
          class: L([O(i).b(), b.customClass, O(d)]),
          style: Qe(O(p)),
          role: "alert",
          onMouseenter: m,
          onMouseleave: g,
          onClick: w[0] || (w[0] = (...x) => b.onClick && b.onClick(...x))
        }, [
          O(h) ? (R(), ie(O(Fe), {
            key: 0,
            class: L([O(i).e("icon"), O(u)])
          }, {
            default: Y(() => [
              (R(), ie(yt(O(h))))
            ]),
            _: 1
          }, 8, ["class"])) : G("v-if", !0),
          Z("div", {
            class: L(O(i).e("group"))
          }, [
            Z("h2", {
              class: L(O(i).e("title")),
              textContent: xe(b.title)
            }, null, 10, Ree),
            it(Z("div", {
              class: L(O(i).e("content")),
              style: Qe(b.title ? void 0 : { margin: 0 })
            }, [
              de(b.$slots, "default", {}, () => [
                b.dangerouslyUseHTMLString ? (R(), V(Tt, { key: 1 }, [
                  G(" Caution here, message could've been compromised, never use user's input as message "),
                  Z("p", { innerHTML: b.message }, null, 8, Dee)
                ], 2112)) : (R(), V("p", Nee, xe(b.message), 1))
              ])
            ], 6), [
              [Qt, b.message]
            ]),
            b.showClose ? (R(), ie(O(Fe), {
              key: 0,
              class: L(O(i).e("closeBtn")),
              onClick: Le(v, ["stop"])
            }, {
              default: Y(() => [
                K(O(a))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : G("v-if", !0)
          ], 2)
        ], 46, Mee), [
          [Qt, l.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var Bee = /* @__PURE__ */ Ce(Iee, [["__file", "notification.vue"]]);
const nm = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, zy = 16;
let Qee = 1;
const Cu = function(n = {}, e = null) {
  if (!vt)
    return { close: () => {
    } };
  (typeof n == "string" || co(n)) && (n = { message: n });
  const t = n.position || "top-right";
  let i = n.offset || 0;
  nm[t].forEach(({ vm: u }) => {
    var h;
    i += (((h = u.el) == null ? void 0 : h.offsetHeight) || 0) + zy;
  }), i += zy;
  const r = `notification_${Qee++}`, s = n.onClose, o = {
    ...n,
    offset: i,
    id: r,
    onClose: () => {
      zee(r, t, s);
    }
  };
  let a = document.body;
  Os(n.appendTo) ? a = n.appendTo : bt(n.appendTo) && (a = document.querySelector(n.appendTo)), Os(a) || (pt("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), a = document.body);
  const l = document.createElement("div"), c = K(Bee, o, co(o.message) ? {
    default: () => o.message
  } : null);
  return c.appContext = e ?? Cu._context, c.props.onDestroy = () => {
    Na(null, l);
  }, Na(c, l), nm[t].push({ vm: c }), a.appendChild(l.firstElementChild), {
    close: () => {
      c.component.exposed.visible.value = !1;
    }
  };
};
uM.forEach((n) => {
  Cu[n] = (e = {}) => ((typeof e == "string" || co(e)) && (e = {
    message: e
  }), Cu({
    ...e,
    type: n
  }));
});
function zee(n, e, t) {
  const i = nm[e], r = i.findIndex(({ vm: c }) => {
    var u;
    return ((u = c.component) == null ? void 0 : u.props.id) === n;
  });
  if (r === -1)
    return;
  const { vm: s } = i[r];
  if (!s)
    return;
  t == null || t(s);
  const o = s.el.offsetHeight, a = e.split("-")[0];
  i.splice(r, 1);
  const l = i.length;
  if (!(l < 1))
    for (let c = r; c < l; c++) {
      const { el: u, component: h } = i[c].vm, d = Number.parseInt(u.style[a], 10) - o - zy;
      h.props.offset = d;
    }
}
function jee() {
  for (const n of Object.values(nm))
    n.forEach(({ vm: e }) => {
      e.component.exposed.visible.value = !1;
    });
}
Cu.closeAll = jee;
Cu._context = null;
const YKe = sT(Cu, "$notify");
function Vee(n, e) {
  let t, i, r;
  const s = D(!0), o = () => {
    s.value = !0, r();
  };
  ne(n, o, { flush: "sync" });
  const a = typeof e == "function" ? e : e.get, l = typeof e == "function" ? void 0 : e.set, c = IL((u, h) => (i = u, r = h, {
    get() {
      return s.value && (t = a(), s.value = !1), i(), t;
    },
    set(d) {
      l == null || l(d);
    }
  }));
  return Object.isExtensible(c) && (c.trigger = o), c;
}
function hM(n) {
  return vA() ? (N1(n), !0) : !1;
}
function Fee(n, e) {
  if (typeof Symbol < "u") {
    const t = { ...n };
    return Object.defineProperty(t, Symbol.iterator, {
      enumerable: !1,
      value() {
        let i = 0;
        return {
          next: () => ({
            value: e[i++],
            done: i > e.length
          })
        };
      }
    }), t;
  } else
    return Object.assign([...e], n);
}
function Qr(n) {
  return typeof n == "function" ? n() : O(n);
}
const Zee = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const qee = Object.prototype.toString, Wee = (n) => qee.call(n) === "[object Object]", Hl = () => {
};
function Mw(n, e) {
  function t(...i) {
    return new Promise((r, s) => {
      Promise.resolve(n(() => e.apply(this, i), { fn: e, thisArg: this, args: i })).then(r).catch(s);
    });
  }
  return t;
}
const Hee = (n) => n();
function dM(n, e = {}) {
  let t, i, r = Hl;
  const s = (a) => {
    clearTimeout(a), r(), r = Hl;
  };
  return (a) => {
    const l = Qr(n), c = Qr(e.maxWait);
    return t && s(t), l <= 0 || c !== void 0 && c <= 0 ? (i && (s(i), i = null), Promise.resolve(a())) : new Promise((u, h) => {
      r = e.rejectOnCancel ? h : u, c && !i && (i = setTimeout(() => {
        t && s(t), i = null, u(a());
      }, c)), t = setTimeout(() => {
        i && s(i), i = null, u(a());
      }, l);
    });
  };
}
function Xee(...n) {
  let e = 0, t, i = !0, r = Hl, s, o, a, l, c;
  !Zi(n[0]) && typeof n[0] == "object" ? { delay: o, trailing: a = !0, leading: l = !0, rejectOnCancel: c = !1 } = n[0] : [o, a = !0, l = !0, c = !1] = n;
  const u = () => {
    t && (clearTimeout(t), t = void 0, r(), r = Hl);
  };
  return (d) => {
    const f = Qr(o), p = Date.now() - e, g = () => s = d();
    return u(), f <= 0 ? (e = Date.now(), g()) : (p > f && (l || !i) ? (e = Date.now(), g()) : a && (s = new Promise((m, v) => {
      r = c ? v : m, t = setTimeout(() => {
        e = Date.now(), i = !0, m(g()), u();
      }, Math.max(0, f - p));
    })), !l && !t && (t = setTimeout(() => i = !0, f)), i = !1, s);
  };
}
function Yee(n) {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}
const Uee = /-(\w)/g, Gee = Yee((n) => n.replace(Uee, (e, t) => t ? t.toUpperCase() : ""));
function Kee(n) {
  return n || Xe();
}
function fM(n, e = 200, t = {}) {
  return Mw(
    dM(e, t),
    n
  );
}
function UKe(n, e = 200, t = {}) {
  const i = D(n.value), r = fM(() => {
    i.value = n.value;
  }, e, t);
  return ne(n, () => r()), i;
}
function Jee(n, e = 200, t = !1, i = !0, r = !1) {
  return Mw(
    Xee(e, t, i, r),
    n
  );
}
function ete(n, e, t = {}) {
  const {
    eventFilter: i = Hee,
    ...r
  } = t;
  return ne(
    n,
    Mw(
      i,
      e
    ),
    r
  );
}
function Rw(n, e = !0, t) {
  Kee() ? qe(n, t) : e ? n() : $e(n);
}
function GKe(n, e, t = {}) {
  const {
    debounce: i = 0,
    maxWait: r = void 0,
    ...s
  } = t;
  return ete(
    n,
    e,
    {
      ...s,
      eventFilter: dM(i, { maxWait: r })
    }
  );
}
function KKe(n = {}) {
  const {
    inheritAttrs: e = !0
  } = n, t = In(), i = /* @__PURE__ */ F({
    setup(s, { slots: o }) {
      return () => {
        t.value = o.default;
      };
    }
  }), r = /* @__PURE__ */ F({
    inheritAttrs: e,
    setup(s, { attrs: o, slots: a }) {
      return () => {
        var l;
        if (!t.value && process.env.NODE_ENV !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const c = (l = t.value) == null ? void 0 : l.call(t, { ...tte(o), $slots: a });
        return e && (c == null ? void 0 : c.length) === 1 ? c[0] : c;
      };
    }
  });
  return Fee(
    { define: i, reuse: r },
    [i, r]
  );
}
function tte(n) {
  const e = {};
  for (const t in n)
    e[Gee(t)] = n[t];
  return e;
}
function ms(n) {
  var e;
  const t = Qr(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const dh = Zee ? window : void 0;
function Fi(...n) {
  let e, t, i, r;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([t, i, r] = n, e = dh) : [e, t, i, r] = n, !e)
    return Hl;
  Array.isArray(t) || (t = [t]), Array.isArray(i) || (i = [i]);
  const s = [], o = () => {
    s.forEach((u) => u()), s.length = 0;
  }, a = (u, h, d, f) => (u.addEventListener(h, d, f), () => u.removeEventListener(h, d, f)), l = ne(
    () => [ms(e), Qr(r)],
    ([u, h]) => {
      if (o(), !u)
        return;
      const d = Wee(h) ? { ...h } : h;
      s.push(
        ...t.flatMap((f) => i.map((p) => a(u, f, p, d)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), o();
  };
  return hM(c), c;
}
function nte() {
  const n = D(!1), e = Xe();
  return e && qe(() => {
    n.value = !0;
  }, e), n;
}
function ite(n) {
  const e = nte();
  return $(() => (e.value, !!n()));
}
function rte(n) {
  const e = Xe(), t = Vee(
    () => null,
    () => n ? ms(n) : e.proxy.$el
  );
  return Ya(t.trigger), qe(t.trigger), t;
}
function ste(n, e, t = {}) {
  const { window: i = dh, ...r } = t;
  let s;
  const o = ite(() => i && "ResizeObserver" in i), a = () => {
    s && (s.disconnect(), s = void 0);
  }, l = $(() => Array.isArray(n) ? n.map((h) => ms(h)) : [ms(n)]), c = ne(
    l,
    (h) => {
      if (a(), o.value && i) {
        s = new ResizeObserver(e);
        for (const d of h)
          d && s.observe(d, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    a(), c();
  };
  return hM(u), {
    isSupported: o,
    stop: u
  };
}
function JKe(n, e = { width: 0, height: 0 }, t = {}) {
  const { window: i = dh, box: r = "content-box" } = t, s = $(() => {
    var h, d;
    return (d = (h = ms(n)) == null ? void 0 : h.namespaceURI) == null ? void 0 : d.includes("svg");
  }), o = D(e.width), a = D(e.height), { stop: l } = ste(
    n,
    ([h]) => {
      const d = r === "border-box" ? h.borderBoxSize : r === "content-box" ? h.contentBoxSize : h.devicePixelContentBoxSize;
      if (i && s.value) {
        const f = ms(n);
        if (f) {
          const p = i.getComputedStyle(f);
          o.value = Number.parseFloat(p.width), a.value = Number.parseFloat(p.height);
        }
      } else if (d) {
        const f = Array.isArray(d) ? d : [d];
        o.value = f.reduce((p, { inlineSize: g }) => p + g, 0), a.value = f.reduce((p, { blockSize: g }) => p + g, 0);
      } else
        o.value = h.contentRect.width, a.value = h.contentRect.height;
    },
    t
  );
  Rw(() => {
    const h = ms(n);
    h && (o.value = "offsetWidth" in h ? h.offsetWidth : e.width, a.value = "offsetHeight" in h ? h.offsetHeight : e.height);
  });
  const c = ne(
    () => ms(n),
    (h) => {
      o.value = h ? e.width : 0, a.value = h ? e.height : 0;
    }
  );
  function u() {
    l(), c();
  }
  return {
    width: o,
    height: a,
    stop: u
  };
}
const Ck = 1;
function eJe(n, e = {}) {
  const {
    throttle: t = 0,
    idle: i = 200,
    onStop: r = Hl,
    onScroll: s = Hl,
    offset: o = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: a = {
      capture: !1,
      passive: !0
    },
    behavior: l = "auto",
    window: c = dh,
    onError: u = (C) => {
      console.error(C);
    }
  } = e, h = D(0), d = D(0), f = $({
    get() {
      return h.value;
    },
    set(C) {
      g(C, void 0);
    }
  }), p = $({
    get() {
      return d.value;
    },
    set(C) {
      g(void 0, C);
    }
  });
  function g(C, k) {
    var E, M, _;
    if (!c)
      return;
    const T = Qr(n);
    T && ((_ = T instanceof Document ? c.document.body : T) == null || _.scrollTo({
      top: (E = Qr(k)) != null ? E : p.value,
      left: (M = Qr(C)) != null ? M : f.value,
      behavior: Qr(l)
    }));
  }
  const m = D(!1), v = Gt({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), y = Gt({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), b = (C) => {
    m.value && (m.value = !1, y.left = !1, y.right = !1, y.top = !1, y.bottom = !1, r(C));
  }, w = fM(b, t + i), x = (C) => {
    var k;
    if (!c)
      return;
    const E = ((k = C == null ? void 0 : C.document) == null ? void 0 : k.documentElement) || (C == null ? void 0 : C.documentElement) || ms(C), { display: M, flexDirection: _ } = getComputedStyle(E), T = E.scrollLeft;
    y.left = T < h.value, y.right = T > h.value;
    const B = Math.abs(T) <= (o.left || 0), I = Math.abs(T) + E.clientWidth >= E.scrollWidth - (o.right || 0) - Ck;
    M === "flex" && _ === "row-reverse" ? (v.left = I, v.right = B) : (v.left = B, v.right = I), h.value = T;
    let P = E.scrollTop;
    C === c.document && !P && (P = c.document.body.scrollTop), y.top = P < d.value, y.bottom = P > d.value;
    const A = Math.abs(P) <= (o.top || 0), N = Math.abs(P) + E.clientHeight >= E.scrollHeight - (o.bottom || 0) - Ck;
    M === "flex" && _ === "column-reverse" ? (v.top = N, v.bottom = A) : (v.top = A, v.bottom = N), d.value = P;
  }, S = (C) => {
    var k;
    if (!c)
      return;
    const E = (k = C.target.documentElement) != null ? k : C.target;
    x(E), m.value = !0, w(C), s(C);
  };
  return Fi(
    n,
    "scroll",
    t ? Jee(S, t, !0, !1) : S,
    a
  ), Rw(() => {
    try {
      const C = Qr(n);
      if (!C)
        return;
      x(C);
    } catch (C) {
      u(C);
    }
  }), Fi(
    n,
    "scrollend",
    b,
    a
  ), {
    x: f,
    y: p,
    isScrolling: m,
    arrivedState: v,
    directions: y,
    measure() {
      const C = Qr(n);
      c && C && x(C);
    }
  };
}
const ote = {
  page: (n) => [n.pageX, n.pageY],
  client: (n) => [n.clientX, n.clientY],
  screen: (n) => [n.screenX, n.screenY],
  movement: (n) => n instanceof Touch ? null : [n.movementX, n.movementY]
};
function tJe(n = {}) {
  const {
    type: e = "page",
    touch: t = !0,
    resetOnTouchEnds: i = !1,
    initialValue: r = { x: 0, y: 0 },
    window: s = dh,
    target: o = s,
    scroll: a = !0,
    eventFilter: l
  } = n;
  let c = null;
  const u = D(r.x), h = D(r.y), d = D(null), f = typeof e == "function" ? e : ote[e], p = (x) => {
    const S = f(x);
    c = x, S && ([u.value, h.value] = S, d.value = "mouse");
  }, g = (x) => {
    if (x.touches.length > 0) {
      const S = f(x.touches[0]);
      S && ([u.value, h.value] = S, d.value = "touch");
    }
  }, m = () => {
    if (!c || !s)
      return;
    const x = f(c);
    c instanceof MouseEvent && x && (u.value = x[0] + s.scrollX, h.value = x[1] + s.scrollY);
  }, v = () => {
    u.value = r.x, h.value = r.y;
  }, y = l ? (x) => l(() => p(x), {}) : (x) => p(x), b = l ? (x) => l(() => g(x), {}) : (x) => g(x), w = l ? () => l(() => m(), {}) : () => m();
  if (o) {
    const x = { passive: !0 };
    Fi(o, ["mousemove", "dragover"], y, x), t && e !== "movement" && (Fi(o, ["touchstart", "touchmove"], b, x), i && Fi(o, "touchend", v, x)), a && e === "page" && Fi(s, "scroll", w, { passive: !0 });
  }
  return {
    x: u,
    y: h,
    sourceType: d
  };
}
function nJe(n = {}) {
  const {
    touch: e = !0,
    drag: t = !0,
    capture: i = !1,
    initialValue: r = !1,
    window: s = dh
  } = n, o = D(r), a = D(null);
  if (!s)
    return {
      pressed: o,
      sourceType: a
    };
  const l = (h) => () => {
    o.value = !0, a.value = h;
  }, c = () => {
    o.value = !1, a.value = null;
  }, u = $(() => ms(n.target) || s);
  return Fi(u, "mousedown", l("mouse"), { passive: !0, capture: i }), Fi(s, "mouseleave", c, { passive: !0, capture: i }), Fi(s, "mouseup", c, { passive: !0, capture: i }), t && (Fi(u, "dragstart", l("mouse"), { passive: !0, capture: i }), Fi(s, "drop", c, { passive: !0, capture: i }), Fi(s, "dragend", c, { passive: !0, capture: i })), e && (Fi(u, "touchstart", l("touch"), { passive: !0, capture: i }), Fi(s, "touchend", c, { passive: !0, capture: i }), Fi(s, "touchcancel", c, { passive: !0, capture: i })), {
    pressed: o,
    sourceType: a
  };
}
function iJe(n = rte()) {
  const e = In(), t = () => {
    const i = ms(n);
    i && (e.value = i.parentElement);
  };
  return Rw(t), ne(() => Qr(n), t), e;
}
var pM = { exports: {} };
/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function(n, e) {
  (function(i, r) {
    n.exports = r();
  })(aW, function() {
    return (
      /******/
      function() {
        var t = {
          /***/
          686: (
            /***/
            function(s, o, a) {
              a.d(o, {
                default: function() {
                  return (
                    /* binding */
                    oe
                  );
                }
              });
              var l = a(279), c = /* @__PURE__ */ a.n(l), u = a(370), h = /* @__PURE__ */ a.n(u), d = a(817), f = /* @__PURE__ */ a.n(d);
              function p(te) {
                try {
                  return document.execCommand(te);
                } catch {
                  return !1;
                }
              }
              var g = function(W) {
                var U = f()(W);
                return p("cut"), U;
              }, m = g;
              function v(te) {
                var W = document.documentElement.getAttribute("dir") === "rtl", U = document.createElement("textarea");
                U.style.fontSize = "12pt", U.style.border = "0", U.style.padding = "0", U.style.margin = "0", U.style.position = "absolute", U.style[W ? "right" : "left"] = "-9999px";
                var ae = window.pageYOffset || document.documentElement.scrollTop;
                return U.style.top = "".concat(ae, "px"), U.setAttribute("readonly", ""), U.value = te, U;
              }
              var y = function(W, U) {
                var ae = v(W);
                U.container.appendChild(ae);
                var he = f()(ae);
                return p("copy"), ae.remove(), he;
              }, b = function(W) {
                var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                  container: document.body
                }, ae = "";
                return typeof W == "string" ? ae = y(W, U) : W instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(W == null ? void 0 : W.type) ? ae = y(W.value, U) : (ae = f()(W), p("copy")), ae;
              }, w = b;
              function x(te) {
                "@babel/helpers - typeof";
                return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? x = function(U) {
                  return typeof U;
                } : x = function(U) {
                  return U && typeof Symbol == "function" && U.constructor === Symbol && U !== Symbol.prototype ? "symbol" : typeof U;
                }, x(te);
              }
              var S = function() {
                var W = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, U = W.action, ae = U === void 0 ? "copy" : U, he = W.container, ee = W.target, pe = W.text;
                if (ae !== "copy" && ae !== "cut")
                  throw new Error('Invalid "action" value, use either "copy" or "cut"');
                if (ee !== void 0)
                  if (ee && x(ee) === "object" && ee.nodeType === 1) {
                    if (ae === "copy" && ee.hasAttribute("disabled"))
                      throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                    if (ae === "cut" && (ee.hasAttribute("readonly") || ee.hasAttribute("disabled")))
                      throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                  } else
                    throw new Error('Invalid "target" value, use a valid Element');
                if (pe)
                  return w(pe, {
                    container: he
                  });
                if (ee)
                  return ae === "cut" ? m(ee) : w(ee, {
                    container: he
                  });
              }, C = S;
              function k(te) {
                "@babel/helpers - typeof";
                return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? k = function(U) {
                  return typeof U;
                } : k = function(U) {
                  return U && typeof Symbol == "function" && U.constructor === Symbol && U !== Symbol.prototype ? "symbol" : typeof U;
                }, k(te);
              }
              function E(te, W) {
                if (!(te instanceof W))
                  throw new TypeError("Cannot call a class as a function");
              }
              function M(te, W) {
                for (var U = 0; U < W.length; U++) {
                  var ae = W[U];
                  ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(te, ae.key, ae);
                }
              }
              function _(te, W, U) {
                return W && M(te.prototype, W), U && M(te, U), te;
              }
              function T(te, W) {
                if (typeof W != "function" && W !== null)
                  throw new TypeError("Super expression must either be null or a function");
                te.prototype = Object.create(W && W.prototype, { constructor: { value: te, writable: !0, configurable: !0 } }), W && B(te, W);
              }
              function B(te, W) {
                return B = Object.setPrototypeOf || function(ae, he) {
                  return ae.__proto__ = he, ae;
                }, B(te, W);
              }
              function I(te) {
                var W = N();
                return function() {
                  var ae = q(te), he;
                  if (W) {
                    var ee = q(this).constructor;
                    he = Reflect.construct(ae, arguments, ee);
                  } else
                    he = ae.apply(this, arguments);
                  return P(this, he);
                };
              }
              function P(te, W) {
                return W && (k(W) === "object" || typeof W == "function") ? W : A(te);
              }
              function A(te) {
                if (te === void 0)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return te;
              }
              function N() {
                if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                  return !1;
                if (typeof Proxy == "function")
                  return !0;
                try {
                  return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                  })), !0;
                } catch {
                  return !1;
                }
              }
              function q(te) {
                return q = Object.setPrototypeOf ? Object.getPrototypeOf : function(U) {
                  return U.__proto__ || Object.getPrototypeOf(U);
                }, q(te);
              }
              function j(te, W) {
                var U = "data-clipboard-".concat(te);
                if (W.hasAttribute(U))
                  return W.getAttribute(U);
              }
              var H = /* @__PURE__ */ function(te) {
                T(U, te);
                var W = I(U);
                function U(ae, he) {
                  var ee;
                  return E(this, U), ee = W.call(this), ee.resolveOptions(he), ee.listenClick(ae), ee;
                }
                return _(U, [{
                  key: "resolveOptions",
                  value: function() {
                    var he = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    this.action = typeof he.action == "function" ? he.action : this.defaultAction, this.target = typeof he.target == "function" ? he.target : this.defaultTarget, this.text = typeof he.text == "function" ? he.text : this.defaultText, this.container = k(he.container) === "object" ? he.container : document.body;
                  }
                  /**
                   * Adds a click event listener to the passed trigger.
                   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                   */
                }, {
                  key: "listenClick",
                  value: function(he) {
                    var ee = this;
                    this.listener = h()(he, "click", function(pe) {
                      return ee.onClick(pe);
                    });
                  }
                  /**
                   * Defines a new `ClipboardAction` on each click event.
                   * @param {Event} e
                   */
                }, {
                  key: "onClick",
                  value: function(he) {
                    var ee = he.delegateTarget || he.currentTarget, pe = this.action(ee) || "copy", be = C({
                      action: pe,
                      container: this.container,
                      target: this.target(ee),
                      text: this.text(ee)
                    });
                    this.emit(be ? "success" : "error", {
                      action: pe,
                      text: be,
                      trigger: ee,
                      clearSelection: function() {
                        ee && ee.focus(), window.getSelection().removeAllRanges();
                      }
                    });
                  }
                  /**
                   * Default `action` lookup function.
                   * @param {Element} trigger
                   */
                }, {
                  key: "defaultAction",
                  value: function(he) {
                    return j("action", he);
                  }
                  /**
                   * Default `target` lookup function.
                   * @param {Element} trigger
                   */
                }, {
                  key: "defaultTarget",
                  value: function(he) {
                    var ee = j("target", he);
                    if (ee)
                      return document.querySelector(ee);
                  }
                  /**
                   * Allow fire programmatically a copy action
                   * @param {String|HTMLElement} target
                   * @param {Object} options
                   * @returns Text copied.
                   */
                }, {
                  key: "defaultText",
                  /**
                   * Default `text` lookup function.
                   * @param {Element} trigger
                   */
                  value: function(he) {
                    return j("text", he);
                  }
                  /**
                   * Destroy lifecycle.
                   */
                }, {
                  key: "destroy",
                  value: function() {
                    this.listener.destroy();
                  }
                }], [{
                  key: "copy",
                  value: function(he) {
                    var ee = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                      container: document.body
                    };
                    return w(he, ee);
                  }
                  /**
                   * Allow fire programmatically a cut action
                   * @param {String|HTMLElement} target
                   * @returns Text cutted.
                   */
                }, {
                  key: "cut",
                  value: function(he) {
                    return m(he);
                  }
                  /**
                   * Returns the support of the given action, or all actions if no action is
                   * given.
                   * @param {String} [action]
                   */
                }, {
                  key: "isSupported",
                  value: function() {
                    var he = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"], ee = typeof he == "string" ? [he] : he, pe = !!document.queryCommandSupported;
                    return ee.forEach(function(be) {
                      pe = pe && !!document.queryCommandSupported(be);
                    }), pe;
                  }
                }]), U;
              }(c()), oe = H;
            }
          ),
          /***/
          828: (
            /***/
            function(s) {
              var o = 9;
              if (typeof Element < "u" && !Element.prototype.matches) {
                var a = Element.prototype;
                a.matches = a.matchesSelector || a.mozMatchesSelector || a.msMatchesSelector || a.oMatchesSelector || a.webkitMatchesSelector;
              }
              function l(c, u) {
                for (; c && c.nodeType !== o; ) {
                  if (typeof c.matches == "function" && c.matches(u))
                    return c;
                  c = c.parentNode;
                }
              }
              s.exports = l;
            }
          ),
          /***/
          438: (
            /***/
            function(s, o, a) {
              var l = a(828);
              function c(d, f, p, g, m) {
                var v = h.apply(this, arguments);
                return d.addEventListener(p, v, m), {
                  destroy: function() {
                    d.removeEventListener(p, v, m);
                  }
                };
              }
              function u(d, f, p, g, m) {
                return typeof d.addEventListener == "function" ? c.apply(null, arguments) : typeof p == "function" ? c.bind(null, document).apply(null, arguments) : (typeof d == "string" && (d = document.querySelectorAll(d)), Array.prototype.map.call(d, function(v) {
                  return c(v, f, p, g, m);
                }));
              }
              function h(d, f, p, g) {
                return function(m) {
                  m.delegateTarget = l(m.target, f), m.delegateTarget && g.call(d, m);
                };
              }
              s.exports = u;
            }
          ),
          /***/
          879: (
            /***/
            function(s, o) {
              o.node = function(a) {
                return a !== void 0 && a instanceof HTMLElement && a.nodeType === 1;
              }, o.nodeList = function(a) {
                var l = Object.prototype.toString.call(a);
                return a !== void 0 && (l === "[object NodeList]" || l === "[object HTMLCollection]") && "length" in a && (a.length === 0 || o.node(a[0]));
              }, o.string = function(a) {
                return typeof a == "string" || a instanceof String;
              }, o.fn = function(a) {
                var l = Object.prototype.toString.call(a);
                return l === "[object Function]";
              };
            }
          ),
          /***/
          370: (
            /***/
            function(s, o, a) {
              var l = a(879), c = a(438);
              function u(p, g, m) {
                if (!p && !g && !m)
                  throw new Error("Missing required arguments");
                if (!l.string(g))
                  throw new TypeError("Second argument must be a String");
                if (!l.fn(m))
                  throw new TypeError("Third argument must be a Function");
                if (l.node(p))
                  return h(p, g, m);
                if (l.nodeList(p))
                  return d(p, g, m);
                if (l.string(p))
                  return f(p, g, m);
                throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
              }
              function h(p, g, m) {
                return p.addEventListener(g, m), {
                  destroy: function() {
                    p.removeEventListener(g, m);
                  }
                };
              }
              function d(p, g, m) {
                return Array.prototype.forEach.call(p, function(v) {
                  v.addEventListener(g, m);
                }), {
                  destroy: function() {
                    Array.prototype.forEach.call(p, function(v) {
                      v.removeEventListener(g, m);
                    });
                  }
                };
              }
              function f(p, g, m) {
                return c(document.body, p, g, m);
              }
              s.exports = u;
            }
          ),
          /***/
          817: (
            /***/
            function(s) {
              function o(a) {
                var l;
                if (a.nodeName === "SELECT")
                  a.focus(), l = a.value;
                else if (a.nodeName === "INPUT" || a.nodeName === "TEXTAREA") {
                  var c = a.hasAttribute("readonly");
                  c || a.setAttribute("readonly", ""), a.select(), a.setSelectionRange(0, a.value.length), c || a.removeAttribute("readonly"), l = a.value;
                } else {
                  a.hasAttribute("contenteditable") && a.focus();
                  var u = window.getSelection(), h = document.createRange();
                  h.selectNodeContents(a), u.removeAllRanges(), u.addRange(h), l = u.toString();
                }
                return l;
              }
              s.exports = o;
            }
          ),
          /***/
          279: (
            /***/
            function(s) {
              function o() {
              }
              o.prototype = {
                on: function(a, l, c) {
                  var u = this.e || (this.e = {});
                  return (u[a] || (u[a] = [])).push({
                    fn: l,
                    ctx: c
                  }), this;
                },
                once: function(a, l, c) {
                  var u = this;
                  function h() {
                    u.off(a, h), l.apply(c, arguments);
                  }
                  return h._ = l, this.on(a, h, c);
                },
                emit: function(a) {
                  var l = [].slice.call(arguments, 1), c = ((this.e || (this.e = {}))[a] || []).slice(), u = 0, h = c.length;
                  for (u; u < h; u++)
                    c[u].fn.apply(c[u].ctx, l);
                  return this;
                },
                off: function(a, l) {
                  var c = this.e || (this.e = {}), u = c[a], h = [];
                  if (u && l)
                    for (var d = 0, f = u.length; d < f; d++)
                      u[d].fn !== l && u[d].fn._ !== l && h.push(u[d]);
                  return h.length ? c[a] = h : delete c[a], this;
                }
              }, s.exports = o, s.exports.TinyEmitter = o;
            }
          )
          /******/
        }, i = {};
        function r(s) {
          if (i[s])
            return i[s].exports;
          var o = i[s] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return t[s](o, o.exports, r), o.exports;
        }
        return function() {
          r.n = function(s) {
            var o = s && s.__esModule ? (
              /******/
              function() {
                return s.default;
              }
            ) : (
              /******/
              function() {
                return s;
              }
            );
            return r.d(o, { a: o }), o;
          };
        }(), function() {
          r.d = function(s, o) {
            for (var a in o)
              r.o(o, a) && !r.o(s, a) && Object.defineProperty(s, a, { enumerable: !0, get: o[a] });
          };
        }(), function() {
          r.o = function(s, o) {
            return Object.prototype.hasOwnProperty.call(s, o);
          };
        }(), r(686);
      }().default
    );
  });
})(pM);
var ate = pM.exports;
const rJe = /* @__PURE__ */ Mf(ate);
typeof window == "object" && window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach);
typeof window < "u" && function(n) {
  n.forEach((e) => {
    Object.prototype.hasOwnProperty.call(e, "append") || Object.defineProperty(e, "append", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value(...t) {
        const i = document.createDocumentFragment();
        t.forEach((r) => {
          const s = r instanceof Node;
          i.appendChild(s ? r : document.createTextNode(String(r)));
        }), this.appendChild(i);
      }
    });
  });
}([Element.prototype, Document.prototype, DocumentFragment.prototype]);
class Zo {
  get disposed() {
    return this._disposed === !0;
  }
  dispose() {
    this._disposed = !0;
  }
}
(function(n) {
  function e() {
    return (t, i, r) => {
      const s = r.value, o = t.__proto__;
      r.value = function(...a) {
        this.disposed || (s.call(this, ...a), o.dispose.call(this));
      };
    };
  }
  n.dispose = e;
})(Zo || (Zo = {}));
class kk {
  constructor() {
    this.isDisposed = !1, this.items = /* @__PURE__ */ new Set();
  }
  /**
   * Test whether the set has been disposed.
   */
  get disposed() {
    return this.isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    this.isDisposed || (this.isDisposed = !0, this.items.forEach((e) => {
      e.dispose();
    }), this.items.clear());
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */
  contains(e) {
    return this.items.has(e);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */
  add(e) {
    this.items.add(e);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */
  remove(e) {
    this.items.delete(e);
  }
  /**
   * Remove all items from the set.
   */
  clear() {
    this.items.clear();
  }
}
(function(n) {
  function e(t) {
    const i = new n();
    return t.forEach((r) => {
      i.add(r);
    }), i;
  }
  n.from = e;
})(kk || (kk = {}));
function gM(n, e, t) {
  if (t)
    switch (t.length) {
      case 0:
        return n.call(e);
      case 1:
        return n.call(e, t[0]);
      case 2:
        return n.call(e, t[0], t[1]);
      case 3:
        return n.call(e, t[0], t[1], t[2]);
      case 4:
        return n.call(e, t[0], t[1], t[2], t[3]);
      case 5:
        return n.call(e, t[0], t[1], t[2], t[3], t[4]);
      case 6:
        return n.call(e, t[0], t[1], t[2], t[3], t[4], t[5]);
      default:
        return n.apply(e, t);
    }
  return n.call(e);
}
function Ze(n, e, ...t) {
  return gM(n, e, t);
}
function lte(n) {
  return typeof n == "object" && n.then && typeof n.then == "function";
}
function jy(n) {
  return n != null && (n instanceof Promise || lte(n));
}
function Nw(...n) {
  const e = [];
  if (n.forEach((i) => {
    Array.isArray(i) ? e.push(...i) : e.push(i);
  }), e.some((i) => jy(i))) {
    const i = e.map((r) => jy(r) ? r : Promise.resolve(r !== !1));
    return Promise.all(i).then((r) => r.reduce((s, o) => o !== !1 && s, !0));
  }
  return e.every((i) => i !== !1);
}
function cte(...n) {
  const e = Nw(n);
  return typeof e == "boolean" ? Promise.resolve(e) : e;
}
function D0(n, e) {
  const t = [];
  for (let i = 0; i < n.length; i += 2) {
    const r = n[i], s = n[i + 1], o = Array.isArray(e) ? e : [e], a = gM(r, s, o);
    t.push(a);
  }
  return Nw(t);
}
class ute {
  constructor() {
    this.listeners = {};
  }
  on(e, t, i) {
    return t == null ? this : (this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t, i), this);
  }
  once(e, t, i) {
    const r = (...s) => (this.off(e, r), D0([t, i], s));
    return this.on(e, r, this);
  }
  off(e, t, i) {
    if (!(e || t || i))
      return this.listeners = {}, this;
    const r = this.listeners;
    return (e ? [e] : Object.keys(r)).forEach((o) => {
      const a = r[o];
      if (a) {
        if (!(t || i)) {
          delete r[o];
          return;
        }
        for (let l = a.length - 2; l >= 0; l -= 2)
          t && a[l] !== t || i && a[l + 1] !== i || a.splice(l, 2);
      }
    }), this;
  }
  trigger(e, ...t) {
    let i = !0;
    if (e !== "*") {
      const s = this.listeners[e];
      s != null && (i = D0([...s], t));
    }
    const r = this.listeners["*"];
    return r != null ? Nw([
      i,
      D0([...r], [e, ...t])
    ]) : i;
  }
  emit(e, ...t) {
    return this.trigger(e, ...t);
  }
}
function hte(n, ...e) {
  e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((i) => {
      i !== "constructor" && Object.defineProperty(n.prototype, i, Object.getOwnPropertyDescriptor(t.prototype, i));
    });
  });
}
const dte = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, e) {
  n.__proto__ = e;
} || function(n, e) {
  for (const t in e)
    Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]);
};
function fte(n, e) {
  dte(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
let pte = class {
};
const gte = /^\s*class\s+/.test(`${pte}`) || /^\s*class\s*\{/.test(`${class {
}}`);
function Dw(n, e) {
  let t;
  return gte ? t = class extends e {
  } : (t = function() {
    return e.apply(this, arguments);
  }, fte(t, e)), Object.defineProperty(t, "name", { value: n }), t;
}
function Pk(n) {
  return n === "__proto__";
}
function Lw(n, e, t = "/") {
  let i;
  const r = Array.isArray(e) ? e : e.split(t);
  if (r.length)
    for (i = n; r.length; ) {
      const s = r.shift();
      if (Object(i) === i && s && s in i)
        i = i[s];
      else
        return;
    }
  return i;
}
function fh(n, e, t, i = "/") {
  const r = Array.isArray(e) ? e : e.split(i), s = r.pop();
  if (s && !Pk(s)) {
    let o = n;
    r.forEach((a) => {
      Pk(a) || (o[a] == null && (o[a] = {}), o = o[a]);
    }), o[s] = t;
  }
  return n;
}
function Ek(n, e, t = "/") {
  const i = Array.isArray(e) ? e.slice() : e.split(t), r = i.pop();
  if (r)
    if (i.length > 0) {
      const s = Lw(n, i);
      s && delete s[r];
    } else
      delete n[r];
  return n;
}
var mte = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class gn extends ute {
  dispose() {
    this.off();
  }
}
mte([
  Zo.dispose()
], gn.prototype, "dispose", null);
(function(n) {
  n.dispose = Zo.dispose;
})(gn || (gn = {}));
hte(gn, Zo);
const mM = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, vM = mM((n) => n.replace(/\B([A-Z])/g, "-$1").toLowerCase()), Iw = mM((n) => aj(uv(n)).replace(/ /g, ""));
function L0(n) {
  let e = 2166136261, t = !1, i = n;
  for (let r = 0, s = i.length; r < s; r += 1) {
    let o = i.charCodeAt(r);
    o > 127 && !t && (i = unescape(encodeURIComponent(i)), o = i.charCodeAt(r), t = !0), e ^= o, e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
  }
  return e >>> 0;
}
function im() {
  let n = "";
  const e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  for (let t = 0, i = e.length; t < i; t += 1) {
    const r = e[t], s = Math.random() * 16 | 0, o = r === "x" ? s : r === "y" ? s & 3 | 8 : r;
    n += o.toString(16);
  }
  return n;
}
function vte(n, e, t) {
  const i = Math.min(2, Math.floor(n.length * 0.34));
  let r = Math.floor(n.length * 0.4) + 1, s, o = !1;
  const a = n.toLowerCase();
  for (const l of e) {
    const c = t(l);
    if (c !== void 0 && Math.abs(c.length - a.length) <= i) {
      const u = c.toLowerCase();
      if (u === a) {
        if (c === n)
          continue;
        return l;
      }
      if (o || c.length < 3)
        continue;
      const h = bte(a, u, r - 1);
      if (h === void 0)
        continue;
      h < 3 ? (o = !0, s = l) : (r = h, s = l);
    }
  }
  return s;
}
function bte(n, e, t) {
  let i = new Array(e.length + 1), r = new Array(e.length + 1);
  const s = t + 1;
  for (let a = 0; a <= e.length; a += 1)
    i[a] = a;
  for (let a = 1; a <= n.length; a += 1) {
    const l = n.charCodeAt(a - 1), c = a > t ? a - t : 1, u = e.length > t + a ? t + a : e.length;
    r[0] = a;
    let h = a;
    for (let f = 1; f < c; f += 1)
      r[f] = s;
    for (let f = c; f <= u; f += 1) {
      const p = l === e.charCodeAt(f - 1) ? i[f - 1] : Math.min(
        /* delete */
        i[f] + 1,
        /* insert */
        r[f - 1] + 1,
        /* substitute */
        i[f - 1] + 2
      );
      r[f] = p, h = Math.min(h, p);
    }
    for (let f = u + 1; f <= e.length; f += 1)
      r[f] = s;
    if (h > t)
      return;
    const d = i;
    i = r, r = d;
  }
  const o = i[e.length];
  return o > t ? void 0 : o;
}
function qo(n) {
  return typeof n == "string" && n.slice(-1) === "%";
}
function ys(n, e) {
  if (n == null)
    return 0;
  let t;
  if (typeof n == "string") {
    if (t = parseFloat(n), qo(n) && (t /= 100, Number.isFinite(t)))
      return t * e;
  } else
    t = n;
  return Number.isFinite(t) ? t > 0 && t < 1 ? t * e : t : 0;
}
function Xl(n) {
  if (typeof n == "object") {
    let t = 0, i = 0, r = 0, s = 0;
    return n.vertical != null && Number.isFinite(n.vertical) && (i = s = n.vertical), n.horizontal != null && Number.isFinite(n.horizontal) && (r = t = n.horizontal), n.left != null && Number.isFinite(n.left) && (t = n.left), n.top != null && Number.isFinite(n.top) && (i = n.top), n.right != null && Number.isFinite(n.right) && (r = n.right), n.bottom != null && Number.isFinite(n.bottom) && (s = n.bottom), { top: i, right: r, bottom: s, left: t };
  }
  let e = 0;
  return n != null && Number.isFinite(n) && (e = n), { top: e, right: e, bottom: e, left: e };
}
let Bw = !1, bM = !1, yM = !1, OM = !1, wM = !1, xM = !1, SM = !1, CM = !1, kM = !1, PM = !1, EM = !1, AM = !1, $M = !1, TM = !1, _M = !1, MM = !1;
if (typeof navigator == "object") {
  const n = navigator.userAgent;
  Bw = n.indexOf("Macintosh") >= 0, bM = !!n.match(/(iPad|iPhone|iPod)/g), yM = n.indexOf("Windows") >= 0, OM = n.indexOf("MSIE") >= 0, wM = !!n.match(/Trident\/7\./), xM = !!n.match(/Edge\//), SM = n.indexOf("Mozilla/") >= 0 && n.indexOf("MSIE") < 0 && n.indexOf("Edge/") < 0, kM = n.indexOf("Chrome/") >= 0 && n.indexOf("Edge/") < 0, PM = n.indexOf("Opera/") >= 0 || n.indexOf("OPR/") >= 0, EM = n.indexOf("Firefox/") >= 0, AM = n.indexOf("AppleWebKit/") >= 0 && n.indexOf("Chrome/") < 0 && n.indexOf("Edge/") < 0, typeof document == "object" && (MM = !document.createElementNS || `${document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")}` != "[object SVGForeignObjectElement]" || n.indexOf("Opera/") >= 0);
}
typeof window == "object" && (CM = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null, TM = window.PointerEvent != null && !Bw);
if (typeof document == "object") {
  $M = "ontouchstart" in document.documentElement;
  try {
    const n = Object.defineProperty({}, "passive", {
      get() {
        _M = !0;
      }
    }), e = document.createElement("div");
    e.addEventListener && e.addEventListener("click", () => {
    }, n);
  } catch {
  }
}
var La;
(function(n) {
  n.IS_MAC = Bw, n.IS_IOS = bM, n.IS_WINDOWS = yM, n.IS_IE = OM, n.IS_IE11 = wM, n.IS_EDGE = xM, n.IS_NETSCAPE = SM, n.IS_CHROME_APP = CM, n.IS_CHROME = kM, n.IS_OPERA = PM, n.IS_FIREFOX = EM, n.IS_SAFARI = AM, n.SUPPORT_TOUCH = $M, n.SUPPORT_POINTER = TM, n.SUPPORT_PASSIVE = _M, n.NO_FOREIGNOBJECT = MM, n.SUPPORT_FOREIGNOBJECT = !n.NO_FOREIGNOBJECT;
})(La || (La = {}));
(function(n) {
  function e() {
    const s = window.module;
    return s != null && s.hot != null && s.hot.status != null ? s.hot.status() : "unkonwn";
  }
  n.getHMRStatus = e;
  function t() {
    return e() === "apply";
  }
  n.isApplyingHMR = t;
  const i = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  function r(s) {
    const o = document.createElement(i[s] || "div"), a = `on${s}`;
    let l = a in o;
    return l || (o.setAttribute(a, "return;"), l = typeof o[a] == "function"), l;
  }
  n.isEventSupported = r;
})(La || (La = {}));
const Qw = /[\t\r\n\f]/g, zw = /\S+/g, ku = (n) => ` ${n} `;
function Pu(n) {
  return n && n.getAttribute && n.getAttribute("class") || "";
}
function ph(n, e) {
  if (n == null || e == null)
    return !1;
  const t = ku(Pu(n)), i = ku(e);
  return n.nodeType === 1 ? t.replace(Qw, " ").includes(i) : !1;
}
function Ye(n, e) {
  if (!(n == null || e == null)) {
    if (typeof e == "function")
      return Ye(n, e(Pu(n)));
    if (typeof e == "string" && n.nodeType === 1) {
      const t = e.match(zw) || [], i = ku(Pu(n)).replace(Qw, " ");
      let r = t.reduce((s, o) => s.indexOf(ku(o)) < 0 ? `${s}${o} ` : s, i);
      r = r.trim(), i !== r && n.setAttribute("class", r);
    }
  }
}
function Nn(n, e) {
  if (n != null) {
    if (typeof e == "function")
      return Nn(n, e(Pu(n)));
    if ((!e || typeof e == "string") && n.nodeType === 1) {
      const t = (e || "").match(zw) || [], i = ku(Pu(n)).replace(Qw, " ");
      let r = t.reduce((s, o) => {
        const a = ku(o);
        return s.indexOf(a) > -1 ? s.replace(a, " ") : s;
      }, i);
      r = e ? r.trim() : "", i !== r && n.setAttribute("class", r);
    }
  }
}
function ld(n, e, t) {
  if (!(n == null || e == null)) {
    if (t != null && typeof e == "string") {
      t ? Ye(n, e) : Nn(n, e);
      return;
    }
    if (typeof e == "function")
      return ld(n, e(Pu(n), t), t);
    typeof e == "string" && (e.match(zw) || []).forEach((r) => {
      ph(n, r) ? Nn(n, r) : Ye(n, r);
    });
  }
}
let Ak = 0;
function yte() {
  return Ak += 1, `v${Ak}`;
}
function jw(n) {
  return (n.id == null || n.id === "") && (n.id = yte()), n.id;
}
function Ia(n) {
  return n == null ? !1 : typeof n.getScreenCTM == "function" && n instanceof SVGElement;
}
const si = {
  svg: "http://www.w3.org/2000/svg",
  xmlns: "http://www.w3.org/2000/xmlns/",
  xml: "http://www.w3.org/XML/1998/namespace",
  xlink: "http://www.w3.org/1999/xlink",
  xhtml: "http://www.w3.org/1999/xhtml"
}, $k = "1.1";
function Tk(n, e = document) {
  return e.createElement(n);
}
function Vw(n, e = si.xhtml, t = document) {
  return t.createElementNS(e, n);
}
function Ts(n, e = document) {
  return Vw(n, si.svg, e);
}
function rm(n) {
  if (n) {
    const t = `<svg xmlns="${si.svg}" xmlns:xlink="${si.xlink}" version="${$k}">${n}</svg>`, { documentElement: i } = Ote(t, { async: !1 });
    return i;
  }
  const e = document.createElementNS(si.svg, "svg");
  return e.setAttributeNS(si.xmlns, "xmlns:xlink", si.xlink), e.setAttribute("version", $k), e;
}
function Ote(n, e = {}) {
  let t;
  try {
    const i = new DOMParser();
    if (e.async != null) {
      const r = i;
      r.async = e.async;
    }
    t = i.parseFromString(n, e.mimeType || "text/xml");
  } catch {
    t = void 0;
  }
  if (!t || t.getElementsByTagName("parsererror").length)
    throw new Error(`Invalid XML: ${n}`);
  return t;
}
function wte(n, e = !0) {
  const t = n.nodeName;
  return e ? t.toLowerCase() : t.toUpperCase();
}
function Fw(n) {
  let e = 0, t = n.previousSibling;
  for (; t; )
    t.nodeType === 1 && (e += 1), t = t.previousSibling;
  return e;
}
function xte(n, e) {
  return n.querySelectorAll(e);
}
function Ste(n, e) {
  return n.querySelector(e);
}
function RM(n, e, t) {
  const i = n.ownerSVGElement;
  let r = n.parentNode;
  for (; r && r !== t && r !== i; ) {
    if (ph(r, e))
      return r;
    r = r.parentNode;
  }
  return null;
}
function NM(n, e) {
  const t = e && e.parentNode;
  return n === t || !!(t && t.nodeType === 1 && n.compareDocumentPosition(t) & 16);
}
function ro(n) {
  n && (Array.isArray(n) ? n : [n]).forEach((t) => {
    t.parentNode && t.parentNode.removeChild(t);
  });
}
function Df(n) {
  for (; n.firstChild; )
    n.removeChild(n.firstChild);
}
function Ja(n, e) {
  (Array.isArray(e) ? e : [e]).forEach((i) => {
    i != null && n.appendChild(i);
  });
}
function DM(n, e) {
  const t = n.firstChild;
  return t ? Zw(t, e) : Ja(n, e);
}
function Zw(n, e) {
  const t = n.parentNode;
  t && (Array.isArray(e) ? e : [e]).forEach((r) => {
    r != null && t.insertBefore(r, n);
  });
}
function cd(n, e) {
  e != null && e.appendChild(n);
}
function _k(n) {
  try {
    return n instanceof HTMLElement;
  } catch {
    return typeof n == "object" && n.nodeType === 1 && typeof n.style == "object" && typeof n.ownerDocument == "object";
  }
}
function Cte(n, e) {
  const t = [];
  let i = n.firstChild;
  for (; i; i = i.nextSibling)
    i.nodeType === 1 && (!e || ph(i, e)) && t.push(i);
  return t;
}
const LM = [
  "viewBox",
  "attributeName",
  "attributeType",
  "repeatCount",
  "textLength",
  "lengthAdjust",
  "gradientUnits"
];
function kte(n, e) {
  return n.getAttribute(e);
}
function qw(n, e) {
  const t = BM(e);
  t.ns ? n.hasAttributeNS(t.ns, t.local) && n.removeAttributeNS(t.ns, t.local) : n.hasAttribute(e) && n.removeAttribute(e);
}
function Ww(n, e, t) {
  if (t == null)
    return qw(n, e);
  const i = BM(e);
  i.ns && typeof t == "string" ? n.setAttributeNS(i.ns, e, t) : e === "id" ? n.id = `${t}` : n.setAttribute(e, `${t}`);
}
function IM(n, e) {
  Object.keys(e).forEach((t) => {
    Ww(n, t, e[t]);
  });
}
function St(n, e, t) {
  if (e == null) {
    const i = n.attributes, r = {};
    for (let s = 0; s < i.length; s += 1)
      r[i[s].name] = i[s].value;
    return r;
  }
  if (typeof e == "string" && t === void 0)
    return n.getAttribute(e);
  typeof e == "object" ? IM(n, e) : Ww(n, e, t);
}
function BM(n) {
  if (n.indexOf(":") !== -1) {
    const e = n.split(":");
    return {
      ns: si[e[0]],
      local: e[1]
    };
  }
  return {
    ns: null,
    local: n
  };
}
function jd(n) {
  const e = {};
  return Object.keys(n).forEach((t) => {
    const i = LM.includes(t) ? t : vM(t);
    e[i] = n[t];
  }), e;
}
function pp(n) {
  const e = {};
  return n.split(";").forEach((i) => {
    const r = i.trim();
    if (r) {
      const s = r.split("=");
      s.length && (e[s[0].trim()] = s[1] ? s[1].trim() : "");
    }
  }), e;
}
function Vy(n, e) {
  return Object.keys(e).forEach((t) => {
    if (t === "class")
      n[t] = n[t] ? `${n[t]} ${e[t]}` : e[t];
    else if (t === "style") {
      const i = typeof n[t] == "object", r = typeof e[t] == "object";
      let s, o;
      i && r ? (s = n[t], o = e[t]) : i ? (s = n[t], o = pp(e[t])) : r ? (s = pp(n[t]), o = e[t]) : (s = pp(n[t]), o = pp(e[t])), n[t] = Vy(s, o);
    } else
      n[t] = e[t];
  }), n;
}
function Pte(n, e, t = {}) {
  const i = t.offset || 0, r = [], s = [];
  let o, a, l = null;
  for (let c = 0; c < n.length; c += 1) {
    o = s[c] = n[c];
    for (let u = 0, h = e.length; u < h; u += 1) {
      const d = e[u], f = d.start + i, p = d.end + i;
      c >= f && c < p && (typeof o == "string" ? o = s[c] = {
        t: n[c],
        attrs: d.attrs
      } : o.attrs = Vy(Vy({}, o.attrs), d.attrs), t.includeAnnotationIndices && (o.annotations == null && (o.annotations = []), o.annotations.push(u)));
    }
    a = s[c - 1], a ? wn(o) && wn(a) ? (l = l, JSON.stringify(o.attrs) === JSON.stringify(a.attrs) ? l.t += o.t : (r.push(l), l = o)) : wn(o) || wn(a) ? (l = l, r.push(l), l = o) : l = (l || "") + o : l = o;
  }
  return l != null && r.push(l), r;
}
function Ete(n) {
  return n.replace(/ /g, " ");
}
var Mk;
(function(n) {
  function e(c) {
    const u = "data:";
    return c.substr(0, u.length) === u;
  }
  n.isDataUrl = e;
  function t(c, u) {
    if (!c || e(c)) {
      setTimeout(() => u(null, c));
      return;
    }
    const h = () => {
      u(new Error(`Failed to load image: ${c}`));
    }, d = window.FileReader ? (
      // chrome, IE10+
      (p) => {
        if (p.status === 200) {
          const g = new FileReader();
          g.onload = (m) => {
            const v = m.target.result;
            u(null, v);
          }, g.onerror = h, g.readAsDataURL(p.response);
        } else
          h();
      }
    ) : (p) => {
      const g = (m) => {
        const y = [];
        for (let b = 0; b < m.length; b += 32768)
          y.push(String.fromCharCode.apply(null, m.subarray(b, b + 32768)));
        return y.join("");
      };
      if (p.status === 200) {
        let m = c.split(".").pop() || "png";
        m === "svg" && (m = "svg+xml");
        const v = `data:image/${m};base64,`, y = new Uint8Array(p.response), b = v + btoa(g(y));
        u(null, b);
      } else
        h();
    }, f = new XMLHttpRequest();
    f.responseType = window.FileReader ? "blob" : "arraybuffer", f.open("GET", c, !0), f.addEventListener("error", h), f.addEventListener("load", () => d(f)), f.send();
  }
  n.imageToDataUri = t;
  function i(c) {
    let u = c.replace(/\s/g, "");
    u = decodeURIComponent(u);
    const h = u.indexOf(","), d = u.slice(0, h), f = d.split(":")[1].split(";")[0], p = u.slice(h + 1);
    let g;
    d.indexOf("base64") >= 0 ? g = atob(p) : g = unescape(encodeURIComponent(p));
    const m = new Uint8Array(g.length);
    for (let v = 0; v < g.length; v += 1)
      m[v] = g.charCodeAt(v);
    return new Blob([m], { type: f });
  }
  n.dataUriToBlob = i;
  function r(c, u) {
    const h = window.navigator.msSaveBlob;
    if (h)
      h(c, u);
    else {
      const d = window.URL.createObjectURL(c), f = document.createElement("a");
      f.href = d, f.download = u, document.body.appendChild(f), f.click(), document.body.removeChild(f), window.URL.revokeObjectURL(d);
    }
  }
  n.downloadBlob = r;
  function s(c, u) {
    const h = i(c);
    r(h, u);
  }
  n.downloadDataUri = s;
  function o(c) {
    const u = c.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    return u && u[2] ? u[2].replace(/\s+/, " ").split(" ") : null;
  }
  function a(c) {
    const u = parseFloat(c);
    return Number.isNaN(u) ? null : u;
  }
  function l(c, u = {}) {
    let h = null;
    const d = (b) => (h == null && (h = o(c)), h != null ? a(h[b]) : null), f = (b) => {
      const w = c.match(b);
      return w && w[2] ? a(w[2]) : null;
    };
    let p = u.width;
    if (p == null && (p = f(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i)), p == null && (p = d(2)), p == null)
      throw new Error("Can not parse width from svg string");
    let g = u.height;
    if (g == null && (g = f(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i)), g == null && (g = d(3)), g == null)
      throw new Error("Can not parse height from svg string");
    return `data:image/svg+xml,${encodeURIComponent(c).replace(/'/g, "%27").replace(/"/g, "%22")}`;
  }
  n.svgToDataUrl = l;
})(Mk || (Mk = {}));
let bl;
const Ate = {
  px(n) {
    return n;
  },
  mm(n) {
    return bl * n;
  },
  cm(n) {
    return bl * n * 10;
  },
  in(n) {
    return bl * n * 25.4;
  },
  pt(n) {
    return bl * (25.4 * n / 72);
  },
  pc(n) {
    return bl * (25.4 * n / 6);
  }
};
var Rk;
(function(n) {
  function e(i, r, s) {
    const o = document.createElement("div"), a = o.style;
    a.display = "inline-block", a.position = "absolute", a.left = "-15000px", a.top = "-15000px", a.width = i + (s || "px"), a.height = r + (s || "px"), document.body.appendChild(o);
    const l = o.getBoundingClientRect(), c = {
      width: l.width || 0,
      height: l.height || 0
    };
    return document.body.removeChild(o), c;
  }
  n.measure = e;
  function t(i, r) {
    bl == null && (bl = e("1", "1", "mm").width);
    const s = r ? Ate[r] : null;
    return s ? s(i) : i;
  }
  n.toPx = t;
})(Rk || (Rk = {}));
const $te = /-(.)/g;
function Tte(n) {
  return n.replace($te, (e, t) => t.toUpperCase());
}
const I0 = {}, Nk = ["webkit", "ms", "moz", "o"], QM = typeof document < "u" ? document.createElement("div").style : {};
function _te(n) {
  for (let e = 0; e < Nk.length; e += 1) {
    const t = Nk[e] + n;
    if (t in QM)
      return t;
  }
  return null;
}
function Mte(n) {
  const e = Tte(n);
  if (I0[e] == null) {
    const t = e.charAt(0).toUpperCase() + e.slice(1);
    I0[e] = e in QM ? e : _te(t);
  }
  return I0[e];
}
function Dk(n, e) {
  const t = n.ownerDocument && n.ownerDocument.defaultView && n.ownerDocument.defaultView.opener ? n.ownerDocument.defaultView.getComputedStyle(n, null) : window.getComputedStyle(n, null);
  return t && e ? t.getPropertyValue(e) || t[e] : t;
}
const Rte = {
  animationIterationCount: !0,
  columnCount: !0,
  flexGrow: !0,
  flexShrink: !0,
  fontWeight: !0,
  gridArea: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnStart: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowStart: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  widows: !0,
  zIndex: !0
};
function Nte(n) {
  return /^--/.test(n);
}
function Dte(n, e, t) {
  const i = window.getComputedStyle(n, null);
  return t ? i.getPropertyValue(e) || void 0 : i[e] || n.style[e];
}
function Lte(n, e) {
  return !Rte[n] && typeof e == "number" ? `${e}px` : e;
}
function qn(n, e, t) {
  if (typeof e == "string") {
    const i = Nte(e);
    if (i || (e = Mte(e)), t === void 0)
      return Dte(n, e, i);
    i || (t = Lte(e, t));
    const r = n.style;
    i ? r.setProperty(e, t) : r[e] = t;
    return;
  }
  for (const i in e)
    qn(n, i, e[i]);
}
const sm = /* @__PURE__ */ new WeakMap();
function Lk(n, e) {
  const t = uv(e), i = sm.get(n);
  if (i)
    return i[t];
}
function Ite(n, e, t) {
  const i = uv(e), r = sm.get(n);
  r ? r[i] = t : sm.set(n, {
    [i]: t
  });
}
function Yl(n, e, t) {
  if (!e) {
    const i = {};
    return Object.keys(sm).forEach((r) => {
      i[r] = Lk(n, r);
    }), i;
  }
  if (typeof e == "string") {
    if (t === void 0)
      return Lk(n, e);
    Ite(n, e, t);
    return;
  }
  for (const i in e)
    Yl(n, i, e[i]);
}
class Je {
  get [Symbol.toStringTag]() {
    return Je.toStringTag;
  }
  get type() {
    return this.node.nodeName;
  }
  get id() {
    return this.node.id;
  }
  set id(e) {
    this.node.id = e;
  }
  constructor(e, t, i) {
    if (!e)
      throw new TypeError("Invalid element to create vector");
    let r;
    if (Je.isVector(e))
      r = e.node;
    else if (typeof e == "string")
      if (e.toLowerCase() === "svg")
        r = rm();
      else if (e[0] === "<") {
        const s = rm(e);
        r = document.importNode(s.firstChild, !0);
      } else
        r = document.createElementNS(si.svg, e);
    else
      r = e;
    this.node = r, t && this.setAttributes(t), i && this.append(i);
  }
  transform(e, t) {
    return e == null ? Eu(this.node) : (Eu(this.node, e, t), this);
  }
  translate(e, t = 0, i = {}) {
    return e == null ? Bk(this.node) : (Bk(this.node, e, t, i), this);
  }
  rotate(e, t, i, r = {}) {
    return e == null ? qy(this.node) : (qy(this.node, e, t, i, r), this);
  }
  scale(e, t) {
    return e == null ? Wy(this.node) : (Wy(this.node, e, t), this);
  }
  /**
   * Returns an SVGMatrix that specifies the transformation necessary
   * to convert this coordinate system into `target` coordinate system.
   */
  getTransformToElement(e) {
    const t = Je.toNode(e);
    return hd(this.node, t);
  }
  removeAttribute(e) {
    return qw(this.node, e), this;
  }
  getAttribute(e) {
    return kte(this.node, e);
  }
  setAttribute(e, t) {
    return Ww(this.node, e, t), this;
  }
  setAttributes(e) {
    return IM(this.node, e), this;
  }
  attr(e, t) {
    return e == null ? St(this.node) : typeof e == "string" && t === void 0 ? St(this.node, e) : (typeof e == "object" ? St(this.node, e) : St(this.node, e, t), this);
  }
  svg() {
    return this.node instanceof SVGSVGElement ? this : Je.create(this.node.ownerSVGElement);
  }
  defs() {
    const e = this.svg() || this, t = e.node.getElementsByTagName("defs")[0];
    return t ? Je.create(t) : Je.create("defs").appendTo(e);
  }
  text(e, t = {}) {
    return jM(this.node, e, t), this;
  }
  tagName() {
    return wte(this.node);
  }
  clone() {
    return Je.create(this.node.cloneNode(!0));
  }
  remove() {
    return ro(this.node), this;
  }
  empty() {
    return Df(this.node), this;
  }
  append(e) {
    return Ja(this.node, Je.toNodes(e)), this;
  }
  appendTo(e) {
    return cd(this.node, Je.isVector(e) ? e.node : e), this;
  }
  prepend(e) {
    return DM(this.node, Je.toNodes(e)), this;
  }
  before(e) {
    return Zw(this.node, Je.toNodes(e)), this;
  }
  replace(e) {
    return this.node.parentNode && this.node.parentNode.replaceChild(Je.toNode(e), this.node), Je.create(e);
  }
  first() {
    return this.node.firstChild ? Je.create(this.node.firstChild) : null;
  }
  last() {
    return this.node.lastChild ? Je.create(this.node.lastChild) : null;
  }
  get(e) {
    const t = this.node.childNodes[e];
    return t ? Je.create(t) : null;
  }
  indexOf(e) {
    return Array.prototype.slice.call(this.node.childNodes).indexOf(Je.toNode(e));
  }
  find(e) {
    const t = [], i = xte(this.node, e);
    if (i)
      for (let r = 0, s = i.length; r < s; r += 1)
        t.push(Je.create(i[r]));
    return t;
  }
  findOne(e) {
    const t = Ste(this.node, e);
    return t ? Je.create(t) : null;
  }
  findParentByClass(e, t) {
    const i = RM(this.node, e, t);
    return i ? Je.create(i) : null;
  }
  matches(e) {
    const t = this.node;
    this.node.matches;
    const i = t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector || null;
    return i && i.call(t, e);
  }
  contains(e) {
    return NM(this.node, Je.isVector(e) ? e.node : e);
  }
  wrap(e) {
    const t = Je.create(e), i = this.node.parentNode;
    return i != null && i.insertBefore(t.node, this.node), t.append(this);
  }
  parent(e) {
    let t = this;
    if (t.node.parentNode == null)
      return null;
    if (t = Je.create(t.node.parentNode), e == null)
      return t;
    do
      if (typeof e == "string" ? t.matches(e) : t instanceof e)
        return t;
    while (t = Je.create(t.node.parentNode));
    return t;
  }
  children() {
    const e = this.node.childNodes, t = [];
    for (let i = 0; i < e.length; i += 1)
      e[i].nodeType === 1 && t.push(Je.create(e[i]));
    return t;
  }
  eachChild(e, t) {
    const i = this.children();
    for (let r = 0, s = i.length; r < s; r += 1)
      e.call(i[r], i[r], r, i), t && i[r].eachChild(e, t);
    return this;
  }
  index() {
    return Fw(this.node);
  }
  hasClass(e) {
    return ph(this.node, e);
  }
  addClass(e) {
    return Ye(this.node, e), this;
  }
  removeClass(e) {
    return Nn(this.node, e), this;
  }
  toggleClass(e, t) {
    return ld(this.node, e, t), this;
  }
  toLocalPoint(e, t) {
    return ine(this.node, e, t);
  }
  /**
   * Samples the underlying SVG element (it currently works only on
   * paths - where it is most useful anyway). Returns an array of objects
   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
   * objects represent a point on the path. This basically creates a discrete
   * representation of the path (which is possible a curve). The sampling
   * interval defines the accuracy of the sampling. In other words, we travel
   * from the beginning of the path to the end by interval distance (on the
   * path, not between the resulting points) and collect the discrete points
   * on the path. This is very useful in many situations. For example, SVG
   * does not provide a built-in mechanism to find intersections between two
   * paths. Using sampling, we can just generate bunch of points for each of
   * the path and find the closest ones from each set.
   */
  sample(e = 1) {
    return this.node instanceof SVGPathElement ? jte(this.node, e) : [];
  }
  toPath() {
    return Je.create(Xte(this.node));
  }
  toPathData() {
    return qM(this.node);
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(o) {
    if (o == null)
      return !1;
    if (o instanceof n)
      return !0;
    const a = o[Symbol.toStringTag], l = o;
    return (a == null || a === n.toStringTag) && l.node instanceof SVGElement && typeof l.sample == "function" && typeof l.toPath == "function";
  }
  n.isVector = e;
  function t(o, a, l) {
    return new n(o, a, l);
  }
  n.create = t;
  function i(o) {
    if (o[0] === "<") {
      const a = rm(o), l = [];
      for (let c = 0, u = a.childNodes.length; c < u; c += 1) {
        const h = a.childNodes[c];
        l.push(t(document.importNode(h, !0)));
      }
      return l;
    }
    return [t(o)];
  }
  n.createVectors = i;
  function r(o) {
    return e(o) ? o.node : o;
  }
  n.toNode = r;
  function s(o) {
    return Array.isArray(o) ? o.map((a) => r(a)) : [r(o)];
  }
  n.toNodes = s;
})(Je || (Je = {}));
function Bte(n, e) {
  const t = Je.create(e), i = Je.create("textPath"), r = n.d;
  if (r && n["xlink:href"] === void 0) {
    const s = Je.create("path").attr("d", r).appendTo(t.defs());
    i.attr("xlink:href", `#${s.id}`);
  }
  return typeof n == "object" && i.attr(n), i.node;
}
function Qte(n, e, t) {
  const i = t.eol, r = t.baseSize, s = t.lineHeight;
  let o = 0, a;
  const l = {}, c = e.length - 1;
  for (let u = 0; u <= c; u += 1) {
    let h = e[u], d = null;
    if (typeof h == "object") {
      const f = h.attrs, p = Je.create("tspan", f);
      a = p.node;
      let g = h.t;
      i && u === c && (g += i), a.textContent = g;
      const m = f.class;
      m && p.addClass(m), t.includeAnnotationIndices && p.attr("annotations", h.annotations.join(",")), d = parseFloat(f["font-size"]), d === void 0 && (d = r), d && d > o && (o = d);
    } else
      i && u === c && (h += i), a = document.createTextNode(h || " "), r && r > o && (o = r);
    n.appendChild(a);
  }
  return o && (l.maxFontSize = o), s ? l.lineHeight = s : o && (l.lineHeight = o * 1.2), l;
}
const zM = /em$/;
function gp(n, e) {
  const t = parseFloat(n);
  return zM.test(n) ? t * e : t;
}
function zte(n, e, t, i) {
  if (!Array.isArray(e))
    return 0;
  const r = e.length;
  if (!r)
    return 0;
  let s = e[0];
  const o = gp(s.maxFontSize, t) || t;
  let a = 0;
  const l = gp(i, t);
  for (let h = 1; h < r; h += 1) {
    s = e[h];
    const d = gp(s.lineHeight, t) || l;
    a += d;
  }
  const c = gp(s.maxFontSize, t) || t;
  let u;
  switch (n) {
    case "middle":
      u = o / 2 - 0.15 * c - a / 2;
      break;
    case "bottom":
      u = -(0.25 * c) - a;
      break;
    case "top":
    default:
      u = 0.8 * o;
      break;
  }
  return u;
}
function jM(n, e, t = {}) {
  e = Ete(e);
  const i = t.eol;
  let r = t.textPath;
  const s = t.textVerticalAnchor, o = s === "middle" || s === "bottom" || s === "top";
  let a = t.x;
  a === void 0 && (a = n.getAttribute("x") || 0);
  const l = t.includeAnnotationIndices;
  let c = t.annotations;
  c && !Array.isArray(c) && (c = [c]);
  const u = t.lineHeight, h = u === "auto", d = h ? "1.5em" : u || "1em";
  let f = !0;
  const p = n.childNodes;
  if (p.length === 1) {
    const E = p[0];
    E && E.tagName.toUpperCase() === "TITLE" && (f = !1);
  }
  f && Df(n), St(n, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    "xml:space": "preserve",
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: e || t.displayEmpty ? null : "none"
  });
  const g = St(n, "font-size");
  let m = parseFloat(g);
  m || (m = 16, (o || c) && !g && St(n, "font-size", `${m}`));
  let v;
  r ? (typeof r == "string" && (r = { d: r }), v = Bte(r, n)) : v = document.createDocumentFragment();
  let y, b = 0, w;
  const x = e.split(`
`), S = [], C = x.length - 1;
  for (let E = 0; E <= C; E += 1) {
    y = d;
    let M = "v-line";
    const _ = Ts("tspan");
    let T, B = x[E];
    if (B)
      if (c) {
        const I = Pte(B, c, {
          offset: -b,
          includeAnnotationIndices: l
        });
        T = Qte(_, I, {
          eol: E !== C && i,
          baseSize: m,
          lineHeight: h ? null : d,
          includeAnnotationIndices: l
        });
        const P = T.lineHeight;
        P && h && E !== 0 && (y = P), E === 0 && (w = T.maxFontSize * 0.8);
      } else
        i && E !== C && (B += i), _.textContent = B;
    else {
      _.textContent = "-", M += " v-empty-line";
      const I = _.style;
      I.fillOpacity = 0, I.strokeOpacity = 0, c && (T = {});
    }
    T && S.push(T), E > 0 && _.setAttribute("dy", y), (E > 0 || r) && _.setAttribute("x", a), _.className.baseVal = M, v.appendChild(_), b += B.length + 1;
  }
  if (o)
    if (c)
      y = zte(s, S, m, d);
    else if (s === "top")
      y = "0.8em";
    else {
      let E;
      switch (C > 0 ? (E = parseFloat(d) || 1, E *= C, zM.test(d) || (E /= m)) : E = 0, s) {
        case "middle":
          y = `${0.3 - E / 2}em`;
          break;
        case "bottom":
          y = `${-E - 0.3}em`;
          break;
      }
    }
  else
    s === 0 ? y = "0em" : s ? y = s : (y = 0, n.getAttribute("y") == null && n.setAttribute("y", `${w || "0.8em"}`));
  v.firstChild.setAttribute("dy", y), n.appendChild(v);
}
function ud(n, e = {}) {
  const t = document.createElement("canvas").getContext("2d");
  if (!n)
    return { width: 0 };
  const i = [], r = e["font-size"] ? `${parseFloat(e["font-size"])}px` : "14px";
  return i.push(e["font-style"] || "normal"), i.push(e["font-variant"] || "normal"), i.push(e["font-weight"] || 400), i.push(r), i.push(e["font-family"] || "sans-serif"), t.font = i.join(" "), t.measureText(n);
}
function Ik(n, e, t, i = {}) {
  if (e >= t)
    return [n, ""];
  const r = n.length, s = {};
  let o = Math.round(e / t * r - 1);
  for (o < 0 && (o = 0); o >= 0 && o < r; ) {
    const a = n.slice(0, o), l = s[a] || ud(a, i).width, c = n.slice(0, o + 1), u = s[c] || ud(c, i).width;
    if (s[a] = l, s[c] = u, l > e)
      o -= 1;
    else if (u <= e)
      o += 1;
    else
      break;
  }
  return [n.slice(0, o), n.slice(o)];
}
function VM(n, e, t = {}, i = {}) {
  const r = e.width, s = e.height, o = i.eol || `
`, a = t.fontSize || 14, l = t.lineHeight ? parseFloat(t.lineHeight) : Math.ceil(a * 1.4), c = Math.floor(s / l);
  if (n.indexOf(o) > -1) {
    const m = im(), v = [];
    return n.split(o).map((y) => {
      const b = VM(y, Object.assign(Object.assign({}, e), { height: Number.MAX_SAFE_INTEGER }), t, Object.assign(Object.assign({}, i), { eol: m }));
      b && v.push(...b.split(m));
    }), v.slice(0, c).join(o);
  }
  const { width: u } = ud(n, t);
  if (u < r)
    return n;
  const h = [];
  let d = n, f = u, p = i.ellipsis, g = 0;
  p && (typeof p != "string" && (p = "…"), g = ud(p, t).width);
  for (let m = 0; m < c; m += 1)
    if (f > r)
      if (m === c - 1) {
        const [y] = Ik(d, r - g, f, t);
        h.push(p ? `${y}${p}` : y);
      } else {
        const [y, b] = Ik(d, r, f, t);
        h.push(y), d = b, f = ud(d, t).width;
      }
    else {
      h.push(d);
      break;
    }
  return h.join(o);
}
const Fy = 0.551784;
function bi(n, e, t = NaN) {
  const i = n.getAttribute(e);
  if (i == null)
    return t;
  const r = parseFloat(i);
  return Number.isNaN(r) ? t : r;
}
function jte(n, e = 1) {
  const t = n.getTotalLength(), i = [];
  let r = 0, s;
  for (; r < t; )
    s = n.getPointAtLength(r), i.push({ distance: r, x: s.x, y: s.y }), r += e;
  return i;
}
function Vte(n) {
  return [
    "M",
    bi(n, "x1"),
    bi(n, "y1"),
    "L",
    bi(n, "x2"),
    bi(n, "y2")
  ].join(" ");
}
function Fte(n) {
  const e = om(n);
  return e.length === 0 ? null : `${FM(e)} Z`;
}
function Zte(n) {
  const e = om(n);
  return e.length === 0 ? null : FM(e);
}
function FM(n) {
  return `M ${n.map((t) => `${t.x} ${t.y}`).join(" L")}`;
}
function om(n) {
  const e = [], t = n.points;
  if (t)
    for (let i = 0, r = t.numberOfItems; i < r; i += 1)
      e.push(t.getItem(i));
  return e;
}
function qte(n) {
  const e = bi(n, "cx", 0), t = bi(n, "cy", 0), i = bi(n, "r"), r = i * Fy;
  return [
    "M",
    e,
    t - i,
    "C",
    e + r,
    t - i,
    e + i,
    t - r,
    e + i,
    t,
    "C",
    e + i,
    t + r,
    e + r,
    t + i,
    e,
    t + i,
    "C",
    e - r,
    t + i,
    e - i,
    t + r,
    e - i,
    t,
    "C",
    e - i,
    t - r,
    e - r,
    t - i,
    e,
    t - i,
    "Z"
  ].join(" ");
}
function Wte(n) {
  const e = bi(n, "cx", 0), t = bi(n, "cy", 0), i = bi(n, "rx"), r = bi(n, "ry") || i, s = i * Fy, o = r * Fy;
  return [
    "M",
    e,
    t - r,
    "C",
    e + s,
    t - r,
    e + i,
    t - o,
    e + i,
    t,
    "C",
    e + i,
    t + o,
    e + s,
    t + r,
    e,
    t + r,
    "C",
    e - s,
    t + r,
    e - i,
    t + o,
    e - i,
    t,
    "C",
    e - i,
    t - o,
    e - s,
    t - r,
    e,
    t - r,
    "Z"
  ].join(" ");
}
function Hte(n) {
  return ZM({
    x: bi(n, "x", 0),
    y: bi(n, "y", 0),
    width: bi(n, "width", 0),
    height: bi(n, "height", 0),
    rx: bi(n, "rx", 0),
    ry: bi(n, "ry", 0)
  });
}
function ZM(n) {
  let e;
  const t = n.x, i = n.y, r = n.width, s = n.height, o = Math.min(n.rx || n["top-rx"] || 0, r / 2), a = Math.min(n.rx || n["bottom-rx"] || 0, r / 2), l = Math.min(n.ry || n["top-ry"] || 0, s / 2), c = Math.min(n.ry || n["bottom-ry"] || 0, s / 2);
  return o || a || l || c ? e = [
    "M",
    t,
    i + l,
    "v",
    s - l - c,
    "a",
    a,
    c,
    0,
    0,
    0,
    a,
    c,
    "h",
    r - 2 * a,
    "a",
    a,
    c,
    0,
    0,
    0,
    a,
    -c,
    "v",
    -(s - c - l),
    "a",
    o,
    l,
    0,
    0,
    0,
    -o,
    -l,
    "h",
    -(r - 2 * o),
    "a",
    o,
    l,
    0,
    0,
    0,
    -o,
    l,
    "Z"
  ] : e = ["M", t, i, "H", t + r, "V", i + s, "H", t, "V", i, "Z"], e.join(" ");
}
function Xte(n) {
  const e = Ts("path");
  St(e, St(n));
  const t = qM(n);
  return t && e.setAttribute("d", t), e;
}
function qM(n) {
  const e = n.tagName.toLowerCase();
  switch (e) {
    case "path":
      return n.getAttribute("d");
    case "line":
      return Vte(n);
    case "polygon":
      return Fte(n);
    case "polyline":
      return Zte(n);
    case "ellipse":
      return Wte(n);
    case "circle":
      return qte(n);
    case "rect":
      return Hte(n);
  }
  throw new Error(`"${e}" cannot be converted to svg path element.`);
}
const Yte = /(\w+)\(([^,)]+),?([^)]+)?\)/gi, WM = /[ ,]+/, Ute = /^(\w+)\((.*)\)/;
function Gte(n, e) {
  const i = Ts("svg").createSVGPoint();
  return i.x = n, i.y = e, i;
}
function ci(n) {
  const t = Ts("svg").createSVGMatrix();
  if (n != null) {
    const i = n, r = t;
    for (const s in i)
      r[s] = i[s];
  }
  return t;
}
function jh(n) {
  const e = Ts("svg");
  return n != null ? (n instanceof DOMMatrix || (n = ci(n)), e.createSVGTransformFromMatrix(n)) : e.createSVGTransform();
}
function Vd(n) {
  let e = ci();
  const t = n != null && n.match(Yte);
  if (!t)
    return e;
  for (let i = 0, r = t.length; i < r; i += 1) {
    const o = t[i].match(Ute);
    if (o) {
      let a, l, c, u, h, d = ci();
      const f = o[2].split(WM);
      switch (o[1].toLowerCase()) {
        case "scale":
          a = parseFloat(f[0]), l = f[1] === void 0 ? a : parseFloat(f[1]), d = d.scaleNonUniform(a, l);
          break;
        case "translate":
          c = parseFloat(f[0]), u = parseFloat(f[1]), d = d.translate(c, u);
          break;
        case "rotate":
          h = parseFloat(f[0]), c = parseFloat(f[1]) || 0, u = parseFloat(f[2]) || 0, c !== 0 || u !== 0 ? d = d.translate(c, u).rotate(h).translate(-c, -u) : d = d.rotate(h);
          break;
        case "skewx":
          h = parseFloat(f[0]), d = d.skewX(h);
          break;
        case "skewy":
          h = parseFloat(f[0]), d = d.skewY(h);
          break;
        case "matrix":
          d.a = parseFloat(f[0]), d.b = parseFloat(f[1]), d.c = parseFloat(f[2]), d.d = parseFloat(f[3]), d.e = parseFloat(f[4]), d.f = parseFloat(f[5]);
          break;
        default:
          continue;
      }
      e = e.multiply(d);
    }
  }
  return e;
}
function gh(n) {
  const e = n || {}, t = e.a != null ? e.a : 1, i = e.b != null ? e.b : 0, r = e.c != null ? e.c : 0, s = e.d != null ? e.d : 1, o = e.e != null ? e.e : 0, a = e.f != null ? e.f : 0;
  return `matrix(${t},${i},${r},${s},${o},${a})`;
}
function Cv(n) {
  let e, t, i;
  if (n) {
    const s = WM;
    if (n.trim().indexOf("matrix") >= 0) {
      const o = Vd(n), a = Kte(o);
      e = [a.translateX, a.translateY], t = [a.rotation], i = [a.scaleX, a.scaleY];
      const l = [];
      (e[0] !== 0 || e[1] !== 0) && l.push(`translate(${e.join(",")})`), (i[0] !== 1 || i[1] !== 1) && l.push(`scale(${i.join(",")})`), t[0] !== 0 && l.push(`rotate(${t[0]})`), n = l.join(" ");
    } else {
      const o = n.match(/translate\((.*?)\)/);
      o && (e = o[1].split(s));
      const a = n.match(/rotate\((.*?)\)/);
      a && (t = a[1].split(s));
      const l = n.match(/scale\((.*?)\)/);
      l && (i = l[1].split(s));
    }
  }
  const r = i && i[0] ? parseFloat(i[0]) : 1;
  return {
    raw: n || "",
    translation: {
      tx: e && e[0] ? parseInt(e[0], 10) : 0,
      ty: e && e[1] ? parseInt(e[1], 10) : 0
    },
    rotation: {
      angle: t && t[0] ? parseInt(t[0], 10) : 0,
      cx: t && t[1] ? parseInt(t[1], 10) : void 0,
      cy: t && t[2] ? parseInt(t[2], 10) : void 0
    },
    scale: {
      sx: r,
      sy: i && i[1] ? parseFloat(i[1]) : r
    }
  };
}
function Zy(n, e) {
  const t = e.x * n.a + e.y * n.c + 0, i = e.x * n.b + e.y * n.d + 0;
  return { x: t, y: i };
}
function Kte(n) {
  const e = Zy(n, { x: 0, y: 1 }), t = Zy(n, { x: 1, y: 0 }), i = 180 / Math.PI * Math.atan2(e.y, e.x) - 90, r = 180 / Math.PI * Math.atan2(t.y, t.x);
  return {
    skewX: i,
    skewY: r,
    translateX: n.e,
    translateY: n.f,
    scaleX: Math.sqrt(n.a * n.a + n.b * n.b),
    scaleY: Math.sqrt(n.c * n.c + n.d * n.d),
    rotation: i
  };
}
function Jte(n) {
  let e, t, i, r;
  return n ? (e = n.a == null ? 1 : n.a, r = n.d == null ? 1 : n.d, t = n.b, i = n.c) : e = r = 1, {
    sx: t ? Math.sqrt(e * e + t * t) : e,
    sy: i ? Math.sqrt(i * i + r * r) : r
  };
}
function ene(n) {
  let e = { x: 0, y: 1 };
  n && (e = Zy(n, e));
  const t = 180 * Math.atan2(e.y, e.x) / Math.PI % 360 - 90;
  return {
    angle: t % 360 + (t < 0 ? 360 : 0)
  };
}
function tne(n) {
  return {
    tx: n && n.e || 0,
    ty: n && n.f || 0
  };
}
function Eu(n, e, t = {}) {
  if (e == null)
    return Vd(St(n, "transform"));
  if (t.absolute) {
    n.setAttribute("transform", gh(e));
    return;
  }
  const i = n.transform, r = jh(e);
  i.baseVal.appendItem(r);
}
function Bk(n, e, t = 0, i = {}) {
  let r = St(n, "transform");
  const s = Cv(r);
  if (e == null)
    return s.translation;
  r = s.raw, r = r.replace(/translate\([^)]*\)/g, "").trim();
  const o = i.absolute ? e : s.translation.tx + e, a = i.absolute ? t : s.translation.ty + t, l = `translate(${o},${a})`;
  n.setAttribute("transform", `${l} ${r}`.trim());
}
function qy(n, e, t, i, r = {}) {
  let s = St(n, "transform");
  const o = Cv(s);
  if (e == null)
    return o.rotation;
  s = o.raw, s = s.replace(/rotate\([^)]*\)/g, "").trim(), e %= 360;
  const a = r.absolute ? e : o.rotation.angle + e, l = t != null && i != null ? `,${t},${i}` : "", c = `rotate(${a}${l})`;
  n.setAttribute("transform", `${s} ${c}`.trim());
}
function Wy(n, e, t) {
  let i = St(n, "transform");
  const r = Cv(i);
  if (e == null)
    return r.scale;
  t = t ?? e, i = r.raw, i = i.replace(/scale\([^)]*\)/g, "").trim();
  const s = `scale(${e},${t})`;
  n.setAttribute("transform", `${i} ${s}`.trim());
}
function hd(n, e) {
  if (Ia(e) && Ia(n)) {
    const t = e.getScreenCTM(), i = n.getScreenCTM();
    if (t && i)
      return t.inverse().multiply(i);
  }
  return ci();
}
function nne(n, e) {
  let t = ci();
  if (Ia(e) && Ia(n)) {
    let i = n;
    const r = [];
    for (; i && i !== e; ) {
      const s = i.getAttribute("transform") || null, o = Vd(s);
      r.push(o), i = i.parentNode;
    }
    r.reverse().forEach((s) => {
      t = t.multiply(s);
    });
  }
  return t;
}
function ine(n, e, t) {
  const i = n instanceof SVGSVGElement ? n : n.ownerSVGElement, r = i.createSVGPoint();
  r.x = e, r.y = t;
  try {
    const s = i.getScreenCTM(), o = r.matrixTransform(s.inverse()), a = hd(n, i).inverse();
    return o.matrixTransform(a);
  } catch {
    return r;
  }
}
var zr;
(function(n) {
  const e = {};
  function t(s) {
    return e[s] || {};
  }
  n.get = t;
  function i(s, o) {
    e[s] = o;
  }
  n.register = i;
  function r(s) {
    delete e[s];
  }
  n.unregister = r;
})(zr || (zr = {}));
var El;
(function(n) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(s) {
    return e.has(s) || e.set(s, { events: /* @__PURE__ */ Object.create(null) }), e.get(s);
  }
  n.ensure = t;
  function i(s) {
    return e.get(s);
  }
  n.get = i;
  function r(s) {
    return e.delete(s);
  }
  n.remove = r;
})(El || (El = {}));
var rt;
(function(n) {
  n.returnTrue = () => !0, n.returnFalse = () => !1;
  function e(r) {
    r.stopPropagation();
  }
  n.stopPropagationCallback = e;
  function t(r, s, o) {
    r.addEventListener != null && r.addEventListener(s, o);
  }
  n.addEventListener = t;
  function i(r, s, o) {
    r.removeEventListener != null && r.removeEventListener(s, o);
  }
  n.removeEventListener = i;
})(rt || (rt = {}));
(function(n) {
  const e = /[^\x20\t\r\n\f]+/g, t = /^([^.]*)(?:\.(.+)|)/;
  function i(a) {
    return (a || "").match(e) || [""];
  }
  n.splitType = i;
  function r(a) {
    const l = t.exec(a) || [];
    return {
      originType: l[1] ? l[1].trim() : l[1],
      namespaces: l[2] ? l[2].split(".").map((c) => c.trim()).sort() : []
    };
  }
  n.normalizeType = r;
  function s(a) {
    return a.nodeType === 1 || a.nodeType === 9 || !+a.nodeType;
  }
  n.isValidTarget = s;
  function o(a, l) {
    if (l) {
      const c = a;
      return c.querySelector != null && c.querySelector(l) != null;
    }
    return !0;
  }
  n.isValidSelector = o;
})(rt || (rt = {}));
(function(n) {
  let e = 0;
  const t = /* @__PURE__ */ new WeakMap();
  function i(a) {
    return t.has(a) || (t.set(a, e), e += 1), t.get(a);
  }
  n.ensureHandlerId = i;
  function r(a) {
    return t.get(a);
  }
  n.getHandlerId = r;
  function s(a) {
    return t.delete(a);
  }
  n.removeHandlerId = s;
  function o(a, l) {
    return t.set(a, l);
  }
  n.setHandlerId = o;
})(rt || (rt = {}));
(function(n) {
  function e(t, i) {
    const r = [], s = El.get(t), o = s && s.events && s.events[i.type], a = o && o.handlers || [], l = o ? o.delegateCount : 0;
    if (l > 0 && // Support: Firefox <=42 - 66+
    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    // Support: IE 11+
    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    !(i.type === "click" && typeof i.button == "number" && i.button >= 1)) {
      for (let c = i.target; c !== t; c = c.parentNode || t)
        if (c.nodeType === 1 && !(i.type === "click" && c.disabled === !0)) {
          const u = [], h = {};
          for (let d = 0; d < l; d += 1) {
            const f = a[d], p = f.selector;
            if (p != null && h[p] == null) {
              const g = t, m = [];
              g.querySelectorAll(p).forEach((v) => {
                m.push(v);
              }), h[p] = m.includes(c);
            }
            h[p] && u.push(f);
          }
          u.length && r.push({ elem: c, handlers: u });
        }
    }
    return l < a.length && r.push({ elem: t, handlers: a.slice(l) }), r;
  }
  n.getHandlerQueue = e;
})(rt || (rt = {}));
(function(n) {
  function e(t) {
    return t != null && t === t.window;
  }
  n.isWindow = e;
})(rt || (rt = {}));
(function(n) {
  function e(t, i) {
    const r = t.nodeType === 9 ? t.documentElement : t, s = i && i.parentNode;
    return t === s || !!(s && s.nodeType === 1 && // Support: IE 9 - 11+
    // IE doesn't have `contains` on SVG.
    (r.contains ? r.contains(s) : t.compareDocumentPosition && t.compareDocumentPosition(s) & 16));
  }
  n.contains = e;
})(rt || (rt = {}));
class so {
  constructor(e, t) {
    this.isDefaultPrevented = rt.returnFalse, this.isPropagationStopped = rt.returnFalse, this.isImmediatePropagationStopped = rt.returnFalse, this.isSimulated = !1, this.preventDefault = () => {
      const i = this.originalEvent;
      this.isDefaultPrevented = rt.returnTrue, i && !this.isSimulated && i.preventDefault();
    }, this.stopPropagation = () => {
      const i = this.originalEvent;
      this.isPropagationStopped = rt.returnTrue, i && !this.isSimulated && i.stopPropagation();
    }, this.stopImmediatePropagation = () => {
      const i = this.originalEvent;
      this.isImmediatePropagationStopped = rt.returnTrue, i && !this.isSimulated && i.stopImmediatePropagation(), this.stopPropagation();
    }, typeof e == "string" ? this.type = e : e.type && (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? rt.returnTrue : rt.returnFalse, this.target = e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget, this.timeStamp = e.timeStamp), t && Object.assign(this, t), this.timeStamp || (this.timeStamp = Date.now());
  }
}
(function(n) {
  function e(t) {
    return t instanceof n ? t : new n(t);
  }
  n.create = e;
})(so || (so = {}));
(function(n) {
  function e(t, i) {
    Object.defineProperty(n.prototype, t, {
      enumerable: !0,
      configurable: !0,
      get: typeof i == "function" ? (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return i(this.originalEvent);
        }
      ) : (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return this.originalEvent[t];
        }
      ),
      set(r) {
        Object.defineProperty(this, t, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: r
        });
      }
    });
  }
  n.addProperty = e;
})(so || (so = {}));
(function(n) {
  const e = {
    bubbles: !0,
    cancelable: !0,
    eventPhase: !0,
    detail: !0,
    view: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pageX: !0,
    pageY: !0,
    screenX: !0,
    screenY: !0,
    toElement: !0,
    pointerId: !0,
    pointerType: !0,
    char: !0,
    code: !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    touches: !0,
    changedTouches: !0,
    targetTouches: !0,
    which: !0,
    altKey: !0,
    ctrlKey: !0,
    metaKey: !0,
    shiftKey: !0
  };
  Object.keys(e).forEach((t) => n.addProperty(t, e[t]));
})(so || (so = {}));
(function(n) {
  zr.register("load", {
    noBubble: !0
  });
})();
(function(n) {
  zr.register("beforeunload", {
    postDispatch(e, t) {
      t.result !== void 0 && t.originalEvent && (t.originalEvent.returnValue = t.result);
    }
  });
})();
(function(n) {
  zr.register("mouseenter", {
    delegateType: "mouseover",
    bindType: "mouseover",
    handle(e, t) {
      let i;
      const r = t.relatedTarget, s = t.handleObj;
      return (!r || r !== e && !rt.contains(e, r)) && (t.type = s.originType, i = s.handler.call(e, t), t.type = "mouseover"), i;
    }
  }), zr.register("mouseleave", {
    delegateType: "mouseout",
    bindType: "mouseout",
    handle(e, t) {
      let i;
      const r = t.relatedTarget, s = t.handleObj;
      return (!r || r !== e && !rt.contains(e, r)) && (t.type = s.originType, i = s.handler.call(e, t), t.type = "mouseout"), i;
    }
  });
})();
var rne = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}, Fd;
(function(n) {
  let e;
  function t(o, a, l, c, u) {
    if (!rt.isValidTarget(o))
      return;
    let h;
    if (typeof l != "function") {
      const { handler: g, selector: m } = l, v = rne(l, ["handler", "selector"]);
      l = g, u = m, h = v;
    }
    const d = El.ensure(o);
    let f = d.handler;
    f == null && (f = d.handler = function(g, ...m) {
      return e !== g.type ? r(o, g, ...m) : void 0;
    });
    const p = rt.ensureHandlerId(l);
    rt.splitType(a).forEach((g) => {
      const { originType: m, namespaces: v } = rt.normalizeType(g);
      if (!m)
        return;
      let y = m, b = zr.get(y);
      y = (u ? b.delegateType : b.bindType) || y, b = zr.get(y);
      const w = Object.assign({
        type: y,
        originType: m,
        data: c,
        selector: u,
        guid: p,
        handler: l,
        namespace: v.join(".")
      }, h), x = d.events;
      let S = x[y];
      S || (S = x[y] = { handlers: [], delegateCount: 0 }, (!b.setup || b.setup(o, c, v, f) === !1) && rt.addEventListener(o, y, f)), b.add && (rt.removeHandlerId(w.handler), b.add(o, w), rt.setHandlerId(w.handler, p)), u ? (S.handlers.splice(S.delegateCount, 0, w), S.delegateCount += 1) : S.handlers.push(w);
    });
  }
  n.on = t;
  function i(o, a, l, c, u) {
    const h = El.get(o);
    if (!h)
      return;
    const d = h.events;
    d && (rt.splitType(a).forEach((f) => {
      const { originType: p, namespaces: g } = rt.normalizeType(f);
      if (!p) {
        Object.keys(d).forEach((x) => {
          i(o, x + f, l, c, !0);
        });
        return;
      }
      let m = p;
      const v = zr.get(m);
      m = (c ? v.delegateType : v.bindType) || m;
      const y = d[m];
      if (!y)
        return;
      const b = g.length > 0 ? new RegExp(`(^|\\.)${g.join("\\.(?:.*\\.|)")}(\\.|$)`) : null, w = y.handlers.length;
      for (let x = y.handlers.length - 1; x >= 0; x -= 1) {
        const S = y.handlers[x];
        (u || p === S.originType) && (!l || rt.getHandlerId(l) === S.guid) && (b == null || S.namespace && b.test(S.namespace)) && (c == null || c === S.selector || c === "**" && S.selector) && (y.handlers.splice(x, 1), S.selector && (y.delegateCount -= 1), v.remove && v.remove(o, S));
      }
      w && y.handlers.length === 0 && ((!v.teardown || v.teardown(o, g, h.handler) === !1) && rt.removeEventListener(o, m, h.handler), delete d[m]);
    }), Object.keys(d).length === 0 && El.remove(o));
  }
  n.off = i;
  function r(o, a, ...l) {
    const c = so.create(a);
    c.delegateTarget = o;
    const u = zr.get(c.type);
    if (u.preDispatch && u.preDispatch(o, c) === !1)
      return;
    const h = rt.getHandlerQueue(o, c);
    for (let d = 0, f = h.length; d < f && !c.isPropagationStopped(); d += 1) {
      const p = h[d];
      c.currentTarget = p.elem;
      for (let g = 0, m = p.handlers.length; g < m && !c.isImmediatePropagationStopped(); g += 1) {
        const v = p.handlers[g];
        if (c.rnamespace == null || v.namespace && c.rnamespace.test(v.namespace)) {
          c.handleObj = v, c.data = v.data;
          const y = zr.get(v.originType).handle, b = y ? y(p.elem, c, ...l) : v.handler.call(p.elem, c, ...l);
          b !== void 0 && (c.result = b, b === !1 && (c.preventDefault(), c.stopPropagation()));
        }
      }
    }
    return u.postDispatch && u.postDispatch(o, c), c.result;
  }
  n.dispatch = r;
  function s(o, a, l, c) {
    let u = o, h = typeof o == "string" ? o : o.type, d = typeof o == "string" || u.namespace == null ? [] : u.namespace.split(".");
    const f = l;
    if (f.nodeType === 3 || f.nodeType === 8)
      return;
    h.indexOf(".") > -1 && (d = h.split("."), h = d.shift(), d.sort());
    const p = h.indexOf(":") < 0 && `on${h}`;
    u = o instanceof so ? o : new so(h, typeof o == "object" ? o : null), u.namespace = d.join("."), u.rnamespace = u.namespace ? new RegExp(`(^|\\.)${d.join("\\.(?:.*\\.|)")}(\\.|$)`) : null, u.result = void 0, u.target || (u.target = f);
    const g = [u];
    Array.isArray(a) ? g.push(...a) : g.push(a);
    const m = zr.get(h);
    if (!c && m.trigger && m.trigger(f, u, a) === !1)
      return;
    let v;
    const y = [f];
    if (!c && !m.noBubble && !rt.isWindow(f)) {
      v = m.delegateType || h;
      let w = f, x = f.parentNode;
      for (; x != null; )
        y.push(x), w = x, x = x.parentNode;
      const S = f.ownerDocument || document;
      if (w === S) {
        const C = w.defaultView || w.parentWindow || window;
        y.push(C);
      }
    }
    let b = f;
    for (let w = 0, x = y.length; w < x && !u.isPropagationStopped(); w += 1) {
      const S = y[w];
      b = S, u.type = w > 1 ? v : m.bindType || h;
      const C = El.get(S);
      C && C.events[u.type] && C.handler && C.handler.call(S, ...g);
      const k = p && S[p] || null;
      k && rt.isValidTarget(S) && (u.result = k.call(S, ...g), u.result === !1 && u.preventDefault());
    }
    if (u.type = h, !c && !u.isDefaultPrevented()) {
      const w = m.preventDefault;
      if ((w == null || w(y.pop(), u, a) === !1) && rt.isValidTarget(f) && p && typeof f[h] == "function" && !rt.isWindow(f)) {
        const x = f[p];
        x && (f[p] = null), e = h, u.isPropagationStopped() && b.addEventListener(h, rt.stopPropagationCallback), f[h](), u.isPropagationStopped() && b.removeEventListener(h, rt.stopPropagationCallback), e = void 0, x && (f[p] = x);
      }
    }
    return u.result;
  }
  n.trigger = s;
})(Fd || (Fd = {}));
var vi;
(function(n) {
  function e(s, o, a, l, c) {
    return dd.on(s, o, a, l, c), s;
  }
  n.on = e;
  function t(s, o, a, l, c) {
    return dd.on(s, o, a, l, c, !0), s;
  }
  n.once = t;
  function i(s, o, a, l) {
    return dd.off(s, o, a, l), s;
  }
  n.off = i;
  function r(s, o, a, l) {
    return Fd.trigger(o, a, s, l), s;
  }
  n.trigger = r;
})(vi || (vi = {}));
var dd;
(function(n) {
  function e(i, r, s, o, a, l) {
    if (typeof r == "object") {
      typeof s != "string" && (o = o || s, s = void 0), Object.keys(r).forEach((c) => e(i, c, s, o, r[c], l));
      return;
    }
    if (o == null && a == null ? (a = s, o = s = void 0) : a == null && (typeof s == "string" ? (a = o, o = void 0) : (a = o, o = s, s = void 0)), a === !1)
      a = rt.returnFalse;
    else if (!a)
      return;
    if (l) {
      const c = a;
      a = function(u, ...h) {
        return n.off(i, u), c.call(this, u, ...h);
      }, rt.setHandlerId(a, rt.ensureHandlerId(c));
    }
    Fd.on(i, r, a, o, s);
  }
  n.on = e;
  function t(i, r, s, o) {
    const a = r;
    if (a && a.preventDefault != null && a.handleObj != null) {
      const l = a.handleObj;
      t(a.delegateTarget, l.namespace ? `${l.originType}.${l.namespace}` : l.originType, l.selector, l.handler);
      return;
    }
    if (typeof r == "object") {
      const l = r;
      Object.keys(l).forEach((c) => t(i, c, s, l[c]));
      return;
    }
    (s === !1 || typeof s == "function") && (o = s, s = void 0), o === !1 && (o = rt.returnFalse), Fd.off(i, r, o, s);
  }
  n.off = t;
})(dd || (dd = {}));
class HM {
  constructor(e, t, i) {
    this.animationFrameId = 0, this.deltaX = 0, this.deltaY = 0, this.eventName = La.isEventSupported("wheel") ? "wheel" : "mousewheel", this.target = e, this.onWheelCallback = t, this.onWheelGuard = i, this.onWheel = this.onWheel.bind(this), this.didWheel = this.didWheel.bind(this);
  }
  enable() {
    this.target.addEventListener(this.eventName, this.onWheel, {
      passive: !1
    });
  }
  disable() {
    this.target.removeEventListener(this.eventName, this.onWheel);
  }
  onWheel(e) {
    if (this.onWheelGuard != null && !this.onWheelGuard(e))
      return;
    this.deltaX += e.deltaX, this.deltaY += e.deltaY, e.preventDefault();
    let t;
    (this.deltaX !== 0 || this.deltaY !== 0) && (e.stopPropagation(), t = !0), t === !0 && this.animationFrameId === 0 && (this.animationFrameId = requestAnimationFrame(() => {
      this.didWheel(e);
    }));
  }
  didWheel(e) {
    this.animationFrameId = 0, this.onWheelCallback(e, this.deltaX, this.deltaY), this.deltaX = 0, this.deltaY = 0;
  }
}
function Hy(n) {
  const e = n.getBoundingClientRect(), t = n.ownerDocument.defaultView;
  return {
    top: e.top + t.pageYOffset,
    left: e.left + t.pageXOffset
  };
}
function sne(n) {
  return n.getBoundingClientRect().width;
}
function one(n) {
  return n.getBoundingClientRect().height;
}
function XM(n, e = 60) {
  let t = null;
  return (...i) => {
    t && clearTimeout(t), t = window.setTimeout(() => {
      n.apply(this, i);
    }, e);
  };
}
function ane(n) {
  let e = null, t = [];
  const i = () => {
    if (getComputedStyle(n).position === "static") {
      const c = n.style;
      c.position = "relative";
    }
    const l = document.createElement("object");
    return l.onload = () => {
      l.contentDocument.defaultView.addEventListener("resize", r), r();
    }, l.style.display = "block", l.style.position = "absolute", l.style.top = "0", l.style.left = "0", l.style.height = "100%", l.style.width = "100%", l.style.overflow = "hidden", l.style.pointerEvents = "none", l.style.zIndex = "-1", l.style.opacity = "0", l.setAttribute("tabindex", "-1"), l.type = "text/html", n.appendChild(l), l.data = "about:blank", l;
  }, r = XM(() => {
    t.forEach((l) => l(n));
  }), s = (l) => {
    e || (e = i()), t.indexOf(l) === -1 && t.push(l);
  }, o = () => {
    e && e.parentNode && (e.contentDocument && e.contentDocument.defaultView.removeEventListener("resize", r), e.parentNode.removeChild(e), e = null, t = []);
  };
  return {
    element: n,
    bind: s,
    destroy: o,
    unbind: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), t.length === 0 && e && o();
    }
  };
}
function lne(n) {
  let e = null, t = [];
  const i = XM(() => {
    t.forEach((l) => {
      l(n);
    });
  }), r = () => {
    const l = new ResizeObserver(i);
    return l.observe(n), i(), l;
  }, s = (l) => {
    e || (e = r()), t.indexOf(l) === -1 && t.push(l);
  }, o = () => {
    e && (e.disconnect(), t = [], e = null);
  };
  return {
    element: n,
    bind: s,
    destroy: o,
    unbind: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), t.length === 0 && e && o();
    }
  };
}
const cne = typeof ResizeObserver < "u" ? lne : ane;
var am;
(function(n) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(r) {
    let s = e.get(r);
    return s || (s = cne(r), e.set(r, s), s);
  }
  function i(r) {
    r.destroy(), e.delete(r.element);
  }
  n.bind = (r, s) => {
    const o = t(r);
    return o.bind(s), () => o.unbind(s);
  }, n.clear = (r) => {
    const s = t(r);
    i(s);
  };
})(am || (am = {}));
class Zd {
  constructor(e = {}) {
    this.comparator = e.comparator || Zd.defaultComparator, this.index = {}, this.data = e.data || [], this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */
  isEmpty() {
    return this.data.length === 0;
  }
  /**
   * Inserts a value with priority to the queue. Optionally pass a unique
   * id of this item. Passing unique IDs for each item you insert allows
   * you to use the `updatePriority()` operation.
   * @param priority
   * @param value
   * @param id
   */
  insert(e, t, i) {
    const r = { priority: e, value: t }, s = this.data.length;
    return i && (r.id = i, this.index[i] = s), this.data.push(r), this.bubbleUp(s), this;
  }
  /**
   * Returns the value of an item with the highest priority.
   */
  peek() {
    return this.data[0] ? this.data[0].value : null;
  }
  /**
   * Returns the highest priority in the queue.
   */
  peekPriority() {
    return this.data[0] ? this.data[0].priority : null;
  }
  updatePriority(e, t) {
    const i = this.index[e];
    if (typeof i > "u")
      throw new Error(`Node with id '${e}' was not found in the heap.`);
    const r = this.data, s = r[i].priority, o = this.comparator(t, s);
    o < 0 ? (r[i].priority = t, this.bubbleUp(i)) : o > 0 && (r[i].priority = t, this.bubbleDown(i));
  }
  /**
   * Removes the item with the highest priority from the queue
   *
   * @returns The value of the removed item.
   */
  remove() {
    const e = this.data, t = e[0], i = e.pop();
    return t.id && delete this.index[t.id], e.length > 0 && (e[0] = i, i.id && (this.index[i.id] = 0), this.bubbleDown(0)), t ? t.value : null;
  }
  heapify() {
    for (let e = 0; e < this.data.length; e += 1)
      this.bubbleUp(e);
  }
  bubbleUp(e) {
    const t = this.data;
    let i, r, s = e;
    for (; s > 0 && (r = s - 1 >>> 1, this.comparator(t[s].priority, t[r].priority) < 0); ) {
      i = t[r], t[r] = t[s];
      let o = t[s].id;
      o != null && (this.index[o] = r), t[s] = i, o = t[s].id, o != null && (this.index[o] = s), s = r;
    }
  }
  bubbleDown(e) {
    const t = this.data, i = t.length - 1;
    let r = e;
    for (; ; ) {
      const s = (r << 1) + 1, o = s + 1;
      let a = r;
      if (s <= i && this.comparator(t[s].priority, t[a].priority) < 0 && (a = s), o <= i && this.comparator(t[o].priority, t[a].priority) < 0 && (a = o), a !== r) {
        const l = t[a];
        t[a] = t[r];
        let c = t[r].id;
        c != null && (this.index[c] = a), t[r] = l, c = t[r].id, c != null && (this.index[c] = r), r = a;
      } else
        break;
    }
  }
}
(function(n) {
  n.defaultComparator = (e, t) => e - t;
})(Zd || (Zd = {}));
var Xy;
(function(n) {
  function e(t, i, r = (s, o) => 1) {
    const s = {}, o = {}, a = {}, l = new Zd();
    for (s[i] = 0, Object.keys(t).forEach((c) => {
      c !== i && (s[c] = 1 / 0), l.insert(s[c], c, c);
    }); !l.isEmpty(); ) {
      const c = l.remove();
      a[c] = !0;
      const u = t[c] || [];
      for (let h = 0; h < u.length; h += 1) {
        const d = u[h];
        if (!a[d]) {
          const f = s[c] + r(c, d);
          f < s[d] && (s[d] = f, o[d] = c, l.updatePriority(d, f));
        }
      }
    }
    return o;
  }
  n.run = e;
})(Xy || (Xy = {}));
class Lo {
  constructor(e, t, i, r) {
    if (e == null)
      return this.set(255, 255, 255, 1);
    if (typeof e == "number")
      return this.set(e, t, i, r);
    if (typeof e == "string")
      return Lo.fromString(e) || this;
    if (Array.isArray(e))
      return this.set(e);
    this.set(e.r, e.g, e.b, e.a == null ? 1 : e.a);
  }
  blend(e, t, i) {
    this.set(e.r + (t.r - e.r) * i, e.g + (t.g - e.g) * i, e.b + (t.b - e.b) * i, e.a + (t.a - e.a) * i);
  }
  lighten(e) {
    const t = Lo.lighten(this.toArray(), e);
    this.r = t[0], this.g = t[1], this.b = t[2], this.a = t[3];
  }
  darken(e) {
    this.lighten(-e);
  }
  set(e, t, i, r) {
    const s = Array.isArray(e) ? e[0] : e, o = Array.isArray(e) ? e[1] : t, a = Array.isArray(e) ? e[2] : i, l = Array.isArray(e) ? e[3] : r;
    return this.r = Math.round(rr(s, 0, 255)), this.g = Math.round(rr(o, 0, 255)), this.b = Math.round(rr(a, 0, 255)), this.a = l == null ? 1 : rr(l, 0, 1), this;
  }
  toHex() {
    return `#${["r", "g", "b"].map((t) => {
      const i = this[t].toString(16);
      return i.length < 2 ? `0${i}` : i;
    }).join("")}`;
  }
  toRGBA() {
    return this.toArray();
  }
  toHSLA() {
    return Lo.rgba2hsla(this.r, this.g, this.b, this.a);
  }
  toCSS(e) {
    const t = `${this.r},${this.g},${this.b},`;
    return e ? `rgb(${t})` : `rgba(${t},${this.a})`;
  }
  toGrey() {
    return Lo.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toString() {
    return this.toCSS();
  }
}
(function(n) {
  function e(b) {
    return new n(b);
  }
  n.fromArray = e;
  function t(b) {
    return new n([...p(b), 1]);
  }
  n.fromHex = t;
  function i(b) {
    const w = b.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
    if (w) {
      const x = w[1].split(/\s*,\s*/).map((S) => parseInt(S, 10));
      return new n(x);
    }
    return null;
  }
  n.fromRGBA = i;
  function r(b, w, x) {
    x < 0 && ++x, x > 1 && --x;
    const S = 6 * x;
    return S < 1 ? b + (w - b) * S : 2 * x < 1 ? w : 3 * x < 2 ? b + (w - b) * (2 / 3 - x) * 6 : b;
  }
  function s(b) {
    const w = b.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
    if (w) {
      const x = w[2].split(/\s*,\s*/), S = (parseFloat(x[0]) % 360 + 360) % 360 / 360, C = parseFloat(x[1]) / 100, k = parseFloat(x[2]) / 100, E = x[3] == null ? 1 : parseInt(x[3], 10);
      return new n(c(S, C, k, E));
    }
    return null;
  }
  n.fromHSLA = s;
  function o(b) {
    if (b.startsWith("#"))
      return t(b);
    if (b.startsWith("rgb"))
      return i(b);
    const w = n.named[b];
    return w ? t(w) : s(b);
  }
  n.fromString = o;
  function a(b, w) {
    return n.fromArray([b, b, b, w]);
  }
  n.makeGrey = a;
  function l(b, w, x, S) {
    const C = Array.isArray(b) ? b[0] : b, k = Array.isArray(b) ? b[1] : w, E = Array.isArray(b) ? b[2] : x, M = Array.isArray(b) ? b[3] : S, _ = Math.max(C, k, E), T = Math.min(C, k, E), B = (_ + T) / 2;
    let I = 0, P = 0;
    if (T !== _) {
      const A = _ - T;
      switch (P = B > 0.5 ? A / (2 - _ - T) : A / (_ + T), _) {
        case C:
          I = (k - E) / A + (k < E ? 6 : 0);
          break;
        case k:
          I = (E - C) / A + 2;
          break;
        case E:
          I = (C - k) / A + 4;
          break;
      }
      I /= 6;
    }
    return [I, P, B, M ?? 1];
  }
  n.rgba2hsla = l;
  function c(b, w, x, S) {
    const C = Array.isArray(b) ? b[0] : b, k = Array.isArray(b) ? b[1] : w, E = Array.isArray(b) ? b[2] : x, M = Array.isArray(b) ? b[3] : S, _ = E <= 0.5 ? E * (k + 1) : E + k - E * k, T = 2 * E - _;
    return [
      r(T, _, C + 1 / 3) * 256,
      r(T, _, C) * 256,
      r(T, _, C - 1 / 3) * 256,
      M ?? 1
    ];
  }
  n.hsla2rgba = c;
  function u(b) {
    return new n(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), b ? void 0 : parseFloat(Math.random().toFixed(2)));
  }
  n.random = u;
  function h() {
    const b = "0123456789ABCDEF";
    let w = "#";
    for (let x = 0; x < 6; x += 1)
      w += b[Math.floor(Math.random() * 16)];
    return w;
  }
  n.randomHex = h;
  function d(b) {
    return u(b).toString();
  }
  n.randomRGBA = d;
  function f(b, w) {
    if (typeof b == "string") {
      const E = b[0] === "#", [M, _, T] = p(b);
      return w ? M * 0.299 + _ * 0.587 + T * 0.114 > 186 ? "#000000" : "#ffffff" : `${E ? "#" : ""}${g(255 - M, 255 - _, 255 - T)}`;
    }
    const x = b[0], S = b[1], C = b[2], k = b[3];
    return w ? x * 0.299 + S * 0.587 + C * 0.114 > 186 ? [0, 0, 0, k] : [255, 255, 255, k] : [255 - x, 255 - S, 255 - C, k];
  }
  n.invert = f;
  function p(b) {
    const w = b.indexOf("#") === 0 ? b : `#${b}`;
    let x = +`0x${w.substr(1)}`;
    if (!(w.length === 4 || w.length === 7) || Number.isNaN(x))
      throw new Error("Invalid hex color.");
    const S = w.length === 4 ? 4 : 8, C = (1 << S) - 1, k = ["b", "g", "r"].map(() => {
      const E = x & C;
      return x >>= S, S === 4 ? 17 * E : E;
    });
    return [k[2], k[1], k[0]];
  }
  function g(b, w, x) {
    const S = (C) => C.length < 2 ? `0${C}` : C;
    return `${S(b.toString(16))}${S(w.toString(16))}${S(x.toString(16))}`;
  }
  function m(b, w) {
    return y(b, w);
  }
  n.lighten = m;
  function v(b, w) {
    return y(b, -w);
  }
  n.darken = v;
  function y(b, w) {
    if (typeof b == "string") {
      const C = b[0] === "#", k = parseInt(C ? b.substr(1) : b, 16), E = rr((k >> 16) + w, 0, 255), M = rr((k >> 8 & 255) + w, 0, 255), _ = rr((k & 255) + w, 0, 255);
      return `${C ? "#" : ""}${(_ | M << 8 | E << 16).toString(16)}`;
    }
    const x = g(b[0], b[1], b[2]), S = p(y(x, w));
    return [S[0], S[1], S[2], b[3]];
  }
})(Lo || (Lo = {}));
(function(n) {
  n.named = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    burntsienna: "#ea7e5d",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
})(Lo || (Lo = {}));
class Yy {
  constructor() {
    this.clear();
  }
  clear() {
    this.map = /* @__PURE__ */ new WeakMap(), this.arr = [];
  }
  has(e) {
    return this.map.has(e);
  }
  get(e) {
    return this.map.get(e);
  }
  set(e, t) {
    this.map.set(e, t), this.arr.push(e);
  }
  delete(e) {
    const t = this.arr.indexOf(e);
    t >= 0 && this.arr.splice(t, 1);
    const i = this.map.get(e);
    return this.map.delete(e), i;
  }
  each(e) {
    this.arr.forEach((t) => {
      const i = this.map.get(t);
      e(i, t);
    });
  }
  dispose() {
    this.clear();
  }
}
var Ba;
(function(n) {
  function e(r) {
    const s = [], o = [];
    return Array.isArray(r) ? s.push(...r) : r.split("|").forEach((a) => {
      a.indexOf("&") === -1 ? s.push(a) : o.push(...a.split("&"));
    }), { or: s, and: o };
  }
  n.parse = e;
  function t(r, s) {
    if (r != null && s != null) {
      const o = e(r), a = e(s), l = o.or.sort(), c = a.or.sort(), u = o.and.sort(), h = a.and.sort(), d = (f, p) => f.length === p.length && (f.length === 0 || f.every((g, m) => g === p[m]));
      return d(l, c) && d(u, h);
    }
    return r == null && s == null;
  }
  n.equals = t;
  function i(r, s, o) {
    if (s == null || Array.isArray(s) && s.length === 0)
      return o ? r.altKey !== !0 && r.ctrlKey !== !0 && r.metaKey !== !0 && r.shiftKey !== !0 : !0;
    const { or: a, and: l } = e(s), c = (u) => {
      const h = `${u.toLowerCase()}Key`;
      return r[h] === !0;
    };
    return a.some((u) => c(u)) && l.every((u) => c(u));
  }
  n.isMatch = i;
})(Ba || (Ba = {}));
var Ul;
(function(n) {
  n.linear = (e) => e, n.quad = (e) => e * e, n.cubic = (e) => e * e * e, n.inout = (e) => {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const t = e * e, i = t * e;
    return 4 * (e < 0.5 ? i : 3 * (e - t) + i - 0.75);
  }, n.exponential = (e) => Math.pow(2, 10 * (e - 1)), n.bounce = (e) => {
    for (let t = 0, i = 1; ; t += i, i /= 2)
      if (e >= (7 - 4 * t) / 11) {
        const r = (11 - 6 * t - 11 * e) / 4;
        return -r * r + i * i;
      }
  };
})(Ul || (Ul = {}));
(function(n) {
  n.decorators = {
    reverse(e) {
      return (t) => 1 - e(1 - t);
    },
    reflect(e) {
      return (t) => 0.5 * (t < 0.5 ? e(2 * t) : 2 - e(2 - 2 * t));
    },
    clamp(e, t = 0, i = 1) {
      return (r) => {
        const s = e(r);
        return s < t ? t : s > i ? i : s;
      };
    },
    back(e = 1.70158) {
      return (t) => t * t * ((e + 1) * t - e);
    },
    elastic(e = 1.5) {
      return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * e / 3 * t);
    }
  };
})(Ul || (Ul = {}));
(function(n) {
  function e(P) {
    return -1 * Math.cos(P * (Math.PI / 2)) + 1;
  }
  n.easeInSine = e;
  function t(P) {
    return Math.sin(P * (Math.PI / 2));
  }
  n.easeOutSine = t;
  function i(P) {
    return -0.5 * (Math.cos(Math.PI * P) - 1);
  }
  n.easeInOutSine = i;
  function r(P) {
    return P * P;
  }
  n.easeInQuad = r;
  function s(P) {
    return P * (2 - P);
  }
  n.easeOutQuad = s;
  function o(P) {
    return P < 0.5 ? 2 * P * P : -1 + (4 - 2 * P) * P;
  }
  n.easeInOutQuad = o;
  function a(P) {
    return P * P * P;
  }
  n.easeInCubic = a;
  function l(P) {
    const A = P - 1;
    return A * A * A + 1;
  }
  n.easeOutCubic = l;
  function c(P) {
    return P < 0.5 ? 4 * P * P * P : (P - 1) * (2 * P - 2) * (2 * P - 2) + 1;
  }
  n.easeInOutCubic = c;
  function u(P) {
    return P * P * P * P;
  }
  n.easeInQuart = u;
  function h(P) {
    const A = P - 1;
    return 1 - A * A * A * A;
  }
  n.easeOutQuart = h;
  function d(P) {
    const A = P - 1;
    return P < 0.5 ? 8 * P * P * P * P : 1 - 8 * A * A * A * A;
  }
  n.easeInOutQuart = d;
  function f(P) {
    return P * P * P * P * P;
  }
  n.easeInQuint = f;
  function p(P) {
    const A = P - 1;
    return 1 + A * A * A * A * A;
  }
  n.easeOutQuint = p;
  function g(P) {
    const A = P - 1;
    return P < 0.5 ? 16 * P * P * P * P * P : 1 + 16 * A * A * A * A * A;
  }
  n.easeInOutQuint = g;
  function m(P) {
    return P === 0 ? 0 : Math.pow(2, 10 * (P - 1));
  }
  n.easeInExpo = m;
  function v(P) {
    return P === 1 ? 1 : -Math.pow(2, -10 * P) + 1;
  }
  n.easeOutExpo = v;
  function y(P) {
    if (P === 0 || P === 1)
      return P;
    const A = P * 2, N = A - 1;
    return A < 1 ? 0.5 * Math.pow(2, 10 * N) : 0.5 * (-Math.pow(2, -10 * N) + 2);
  }
  n.easeInOutExpo = y;
  function b(P) {
    const A = P / 1;
    return -1 * (Math.sqrt(1 - A * P) - 1);
  }
  n.easeInCirc = b;
  function w(P) {
    const A = P - 1;
    return Math.sqrt(1 - A * A);
  }
  n.easeOutCirc = w;
  function x(P) {
    const A = P * 2, N = A - 2;
    return A < 1 ? -0.5 * (Math.sqrt(1 - A * A) - 1) : 0.5 * (Math.sqrt(1 - N * N) + 1);
  }
  n.easeInOutCirc = x;
  function S(P, A = 1.70158) {
    return P * P * ((A + 1) * P - A);
  }
  n.easeInBack = S;
  function C(P, A = 1.70158) {
    const N = P / 1 - 1;
    return N * N * ((A + 1) * N + A) + 1;
  }
  n.easeOutBack = C;
  function k(P, A = 1.70158) {
    const N = P * 2, q = N - 2, j = A * 1.525;
    return N < 1 ? 0.5 * N * N * ((j + 1) * N - j) : 0.5 * (q * q * ((j + 1) * q + j) + 2);
  }
  n.easeInOutBack = k;
  function E(P, A = 0.7) {
    if (P === 0 || P === 1)
      return P;
    const q = P / 1 - 1, j = 1 - A, H = j / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * q) * // eslint-disable-line
    Math.sin((q - H) * (2 * Math.PI) / j));
  }
  n.easeInElastic = E;
  function M(P, A = 0.7) {
    const N = 1 - A, q = P * 2;
    if (P === 0 || P === 1)
      return P;
    const j = N / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * q) * // eslint-disable-line
    Math.sin((q - j) * (2 * Math.PI) / N) + 1;
  }
  n.easeOutElastic = M;
  function _(P, A = 0.65) {
    const N = 1 - A;
    if (P === 0 || P === 1)
      return P;
    const q = P * 2, j = q - 1, H = N / (2 * Math.PI) * Math.asin(1);
    return q < 1 ? -0.5 * (Math.pow(2, 10 * j) * // eslint-disable-line
    Math.sin((j - H) * (2 * Math.PI) / N)) : Math.pow(2, -10 * j) * // eslint-disable-line
    Math.sin((j - H) * (2 * Math.PI) / N) * 0.5 + 1;
  }
  n.easeInOutElastic = _;
  function T(P) {
    const A = P / 1;
    if (A < 1 / 2.75)
      return 7.5625 * A * A;
    if (A < 2 / 2.75) {
      const N = A - 0.5454545454545454;
      return 7.5625 * N * N + 0.75;
    }
    if (A < 2.5 / 2.75) {
      const N = A - 0.8181818181818182;
      return 7.5625 * N * N + 0.9375;
    }
    {
      const N = A - 0.9545454545454546;
      return 7.5625 * N * N + 0.984375;
    }
  }
  n.easeOutBounce = T;
  function B(P) {
    return 1 - T(1 - P);
  }
  n.easeInBounce = B;
  function I(P) {
    return P < 0.5 ? B(P * 2) * 0.5 : T(P * 2 - 1) * 0.5 + 0.5;
  }
  n.easeInOutBounce = I;
})(Ul || (Ul = {}));
var Al;
(function(n) {
  n.number = (e, t) => {
    const i = t - e;
    return (r) => e + i * r;
  }, n.object = (e, t) => {
    const i = Object.keys(e);
    return (r) => {
      const s = {};
      for (let o = i.length - 1; o !== -1; o -= 1) {
        const a = i[o];
        s[a] = e[a] + (t[a] - e[a]) * r;
      }
      return s;
    };
  }, n.unit = (e, t) => {
    const i = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/, r = i.exec(e), s = i.exec(t), o = s ? s[1] : "", a = r ? +r[1] : 0, l = s ? +s[1] : 0, c = o.indexOf("."), u = c > 0 ? o[1].length - c - 1 : 0, h = l - a, d = r ? r[2] : "";
    return (f) => (a + h * f).toFixed(u) + d;
  }, n.color = (e, t) => {
    const i = parseInt(e.slice(1), 16), r = parseInt(t.slice(1), 16), s = i & 255, o = (r & 255) - s, a = i & 65280, l = (r & 65280) - a, c = i & 16711680, u = (r & 16711680) - c;
    return (h) => {
      const d = s + o * h & 255, f = a + l * h & 65280, p = c + u * h & 16711680;
      return `#${(1 << 24 | d | f | p).toString(16).slice(1)}`;
    };
  };
})(Al || (Al = {}));
const fd = [];
function kv(n, e) {
  const t = fd.find((i) => i.name === n);
  if (!(t && (t.loadTimes += 1, t.loadTimes > 1)) && !La.isApplyingHMR()) {
    const i = document.createElement("style");
    i.setAttribute("type", "text/css"), i.textContent = e;
    const r = document.querySelector("head");
    r && r.insertBefore(i, r.firstChild), fd.push({
      name: n,
      loadTimes: 1,
      styleElement: i
    });
  }
}
function Pv(n) {
  const e = fd.findIndex((t) => t.name === n);
  if (e > -1) {
    const t = fd[e];
    if (t.loadTimes -= 1, t.loadTimes > 0)
      return;
    let i = t.styleElement;
    i && i.parentNode && i.parentNode.removeChild(i), i = null, fd.splice(e, 1);
  }
}
var Pt;
(function(n) {
  function e(i) {
    return 180 * i / Math.PI % 360;
  }
  n.toDeg = e, n.toRad = function(i, r = !1) {
    return (r ? i : i % 360) * Math.PI / 180;
  };
  function t(i) {
    return i % 360 + (i < 0 ? 360 : 0);
  }
  n.normalize = t;
})(Pt || (Pt = {}));
var At;
(function(n) {
  function e(a, l = 0) {
    return Number.isInteger(a) ? a : +a.toFixed(l);
  }
  n.round = e;
  function t(a, l) {
    let c, u;
    if (l == null ? (u = a ?? 1, c = 0) : (u = l, c = a ?? 0), u < c) {
      const h = c;
      c = u, u = h;
    }
    return Math.floor(Math.random() * (u - c + 1) + c);
  }
  n.random = t;
  function i(a, l, c) {
    return Number.isNaN(a) ? NaN : Number.isNaN(l) || Number.isNaN(c) ? 0 : l < c ? a < l ? l : a > c ? c : a : a < c ? c : a > l ? l : a;
  }
  n.clamp = i;
  function r(a, l) {
    return l * Math.round(a / l);
  }
  n.snapToGrid = r;
  function s(a, l) {
    return l != null && a != null && l.x >= a.x && l.x <= a.x + a.width && l.y >= a.y && l.y <= a.y + a.height;
  }
  n.containsPoint = s;
  function o(a, l) {
    const c = a.x - l.x, u = a.y - l.y;
    return c * c + u * u;
  }
  n.squaredLength = o;
})(At || (At = {}));
class el {
  valueOf() {
    return this.toJSON();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class z extends el {
  constructor(e, t) {
    super(), this.x = e ?? 0, this.y = t ?? 0;
  }
  /**
   * Rounds the point to the given precision.
   */
  round(e = 0) {
    return this.x = At.round(this.x, e), this.y = At.round(this.y, e), this;
  }
  add(e, t) {
    const i = z.create(e, t);
    return this.x += i.x, this.y += i.y, this;
  }
  update(e, t) {
    const i = z.create(e, t);
    return this.x = i.x, this.y = i.y, this;
  }
  translate(e, t) {
    const i = z.create(e, t);
    return this.x += i.x, this.y += i.y, this;
  }
  /**
   * Rotate the point by `degree` around `center`.
   */
  rotate(e, t) {
    const i = z.rotate(this, e, t);
    return this.x = i.x, this.y = i.y, this;
  }
  /**
   * Scale point by `sx` and `sy` around the given `origin`. If origin is
   * not specified, the point is scaled around `0, 0`.
   */
  scale(e, t, i = new z()) {
    const r = z.create(i);
    return this.x = r.x + e * (this.x - r.x), this.y = r.y + t * (this.y - r.y), this;
  }
  /**
   * Chooses the point closest to this point from among `points`. If `points`
   * is an empty array, `null` is returned.
   */
  closest(e) {
    if (e.length === 1)
      return z.create(e[0]);
    let t = null, i = 1 / 0;
    return e.forEach((r) => {
      const s = this.squaredDistance(r);
      s < i && (t = r, i = s);
    }), t ? z.create(t) : null;
  }
  /**
   * Returns the distance between the point and another point `p`.
   */
  distance(e) {
    return Math.sqrt(this.squaredDistance(e));
  }
  /**
   * Returns the squared distance between the point and another point `p`.
   *
   * Useful for distance comparisons in which real distance is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredDistance(e) {
    const t = z.create(e), i = this.x - t.x, r = this.y - t.y;
    return i * i + r * r;
  }
  manhattanDistance(e) {
    const t = z.create(e);
    return Math.abs(t.x - this.x) + Math.abs(t.y - this.y);
  }
  /**
   * Returns the magnitude of the point vector.
   *
   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
   */
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p` and
   * the x-axis.
   */
  theta(e = new z()) {
    const t = z.create(e), i = -(t.y - this.y), r = t.x - this.x;
    let s = Math.atan2(i, r);
    return s < 0 && (s = 2 * Math.PI + s), 180 * s / Math.PI;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p1` and
   * the vector from this point to `p2`.
   *
   * The ordering of points `p1` and `p2` is important.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from `p1` to `p2`) is clockwise, and a value between `180` and
   * `360` when the angle is counterclockwise.
   *
   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
   */
  angleBetween(e, t) {
    if (this.equals(e) || this.equals(t))
      return NaN;
    let i = this.theta(t) - this.theta(e);
    return i < 0 && (i += 360), i;
  }
  /**
   * Returns the angle(in degrees) between the line from `(0,0)` and this point
   * and the line from `(0,0)` to `p`.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from this point to `p`) is clockwise, and a value between `180`
   * and `360` when the angle is counterclockwise. Returns `NaN` if called from
   * point `(0,0)` or if `p` is `(0,0)`.
   */
  vectorAngle(e) {
    return new z(0, 0).angleBetween(this, e);
  }
  /**
   * Converts rectangular to polar coordinates.
   */
  toPolar(e) {
    return this.update(z.toPolar(this, e)), this;
  }
  /**
   * Returns the change in angle(in degrees) that is the result of moving the
   * point from its previous position to its current position.
   *
   * More specifically, this function computes the angle between the line from
   * the ref point to the previous position of this point(i.e. current position
   * `-dx`, `-dy`) and the line from the `ref` point to the current position of
   * this point.
   *
   * The function returns a positive value between `0` and `180` when the angle
   * (in the direction from previous position of this point to its current
   * position) is clockwise, and a negative value between `0` and `-180` when
   * the angle is counterclockwise.
   *
   * The function returns `0` if the previous and current positions of this
   * point are the same (i.e. both `dx` and `dy` are `0`).
   */
  changeInAngle(e, t, i = new z()) {
    return this.clone().translate(-e, -t).theta(i) - this.theta(i);
  }
  /**
   * If the point lies outside the rectangle `rect`, adjust the point so that
   * it becomes the nearest point on the boundary of `rect`.
   */
  adhereToRect(e) {
    return At.containsPoint(e, this) || (this.x = Math.min(Math.max(this.x, e.x), e.x + e.width), this.y = Math.min(Math.max(this.y, e.y), e.y + e.height)), this;
  }
  /**
   * Returns the bearing(cardinal direction) between me and the given point.
   *
   * @see https://en.wikipedia.org/wiki/Cardinal_direction
   */
  bearing(e) {
    const t = z.create(e), i = Pt.toRad(this.y), r = Pt.toRad(t.y), s = this.x, o = t.x, a = Pt.toRad(o - s), l = Math.sin(a) * Math.cos(r), c = Math.cos(i) * Math.sin(r) - Math.sin(i) * Math.cos(r) * Math.cos(a), u = Pt.toDeg(Math.atan2(l, c)), h = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
    let d = u - 22.5;
    return d < 0 && (d += 360), d = parseInt(d / 45, 10), h[d];
  }
  /**
   * Returns the cross product of the vector from me to `p1` and the vector
   * from me to `p2`.
   *
   * The left-hand rule is used because the coordinate system is left-handed.
   */
  cross(e, t) {
    if (e != null && t != null) {
      const i = z.create(e), r = z.create(t);
      return (r.x - this.x) * (i.y - this.y) - (r.y - this.y) * (i.x - this.x);
    }
    return NaN;
  }
  /**
   * Returns the dot product of this point with given other point.
   */
  dot(e) {
    const t = z.create(e);
    return this.x * t.x + this.y * t.y;
  }
  diff(e, t) {
    if (typeof e == "number")
      return new z(this.x - e, this.y - t);
    const i = z.create(e);
    return new z(this.x - i.x, this.y - i.y);
  }
  /**
   * Returns an interpolation between me and point `p` for a parametert in
   * the closed interval `[0, 1]`.
   */
  lerp(e, t) {
    const i = z.create(e);
    return new z((1 - t) * this.x + t * i.x, (1 - t) * this.y + t * i.y);
  }
  /**
   * Normalize the point vector, scale the line segment between `(0, 0)`
   * and the point in order for it to have the given length. If length is
   * not specified, it is considered to be `1`; in that case, a unit vector
   * is computed.
   */
  normalize(e = 1) {
    const t = e / this.magnitude();
    return this.scale(t, t);
  }
  /**
   * Moves this point along the line starting from `ref` to this point by a
   * certain `distance`.
   */
  move(e, t) {
    const i = z.create(e), r = Pt.toRad(i.theta(this));
    return this.translate(Math.cos(r) * t, -Math.sin(r) * t);
  }
  /**
   * Returns a point that is the reflection of me with the center of inversion
   * in `ref` point.
   */
  reflection(e) {
    return z.create(e).move(this, this.distance(e));
  }
  snapToGrid(e, t) {
    return this.x = At.snapToGrid(this.x, e), this.y = At.snapToGrid(this.y, t ?? e), this;
  }
  equals(e) {
    const t = z.create(e);
    return t != null && t.x === this.x && t.y === this.y;
  }
  clone() {
    return z.clone(this);
  }
  /**
   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
   */
  toJSON() {
    return z.toJSON(this);
  }
  serialize() {
    return `${this.x} ${this.y}`;
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isPoint = e;
})(z || (z = {}));
(function(n) {
  function e(i) {
    return i != null && typeof i == "object" && typeof i.x == "number" && typeof i.y == "number";
  }
  n.isPointLike = e;
  function t(i) {
    return i != null && Array.isArray(i) && i.length === 2 && typeof i[0] == "number" && typeof i[1] == "number";
  }
  n.isPointData = t;
})(z || (z = {}));
(function(n) {
  function e(h, d) {
    return h == null || typeof h == "number" ? new n(h, d) : t(h);
  }
  n.create = e;
  function t(h) {
    return n.isPoint(h) ? new n(h.x, h.y) : Array.isArray(h) ? new n(h[0], h[1]) : new n(h.x, h.y);
  }
  n.clone = t;
  function i(h) {
    return n.isPoint(h) ? { x: h.x, y: h.y } : Array.isArray(h) ? { x: h[0], y: h[1] } : { x: h.x, y: h.y };
  }
  n.toJSON = i;
  function r(h, d, f = new n()) {
    let p = Math.abs(h * Math.cos(d)), g = Math.abs(h * Math.sin(d));
    const m = t(f), v = Pt.normalize(Pt.toDeg(d));
    return v < 90 ? g = -g : v < 180 ? (p = -p, g = -g) : v < 270 && (p = -p), new n(m.x + p, m.y + g);
  }
  n.fromPolar = r;
  function s(h, d = new n()) {
    const f = t(h), p = t(d), g = f.x - p.x, m = f.y - p.y;
    return new n(
      Math.sqrt(g * g + m * m),
      // r
      Pt.toRad(p.theta(f))
    );
  }
  n.toPolar = s;
  function o(h, d) {
    return h === d ? !0 : h != null && d != null ? h.x === d.x && h.y === d.y : !1;
  }
  n.equals = o;
  function a(h, d) {
    if (h == null && d != null || h != null && d == null || h != null && d != null && h.length !== d.length)
      return !1;
    if (h != null && d != null) {
      for (let f = 0, p = h.length; f < p; f += 1)
        if (!o(h[f], d[f]))
          return !1;
    }
    return !0;
  }
  n.equalPoints = a;
  function l(h, d, f, p) {
    return new n(At.random(h, d), At.random(f, p));
  }
  n.random = l;
  function c(h, d, f) {
    const p = Pt.toRad(Pt.normalize(-d)), g = Math.sin(p), m = Math.cos(p);
    return u(h, m, g, f);
  }
  n.rotate = c;
  function u(h, d, f, p = new n()) {
    const g = t(h), m = t(p), v = g.x - m.x, y = g.y - m.y, b = v * d - y * f, w = y * d + v * f;
    return new n(b + m.x, w + m.y);
  }
  n.rotateEx = u;
})(z || (z = {}));
class ye extends el {
  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.width;
  }
  get bottom() {
    return this.y + this.height;
  }
  get origin() {
    return new z(this.x, this.y);
  }
  get topLeft() {
    return new z(this.x, this.y);
  }
  get topCenter() {
    return new z(this.x + this.width / 2, this.y);
  }
  get topRight() {
    return new z(this.x + this.width, this.y);
  }
  get center() {
    return new z(this.x + this.width / 2, this.y + this.height / 2);
  }
  get bottomLeft() {
    return new z(this.x, this.y + this.height);
  }
  get bottomCenter() {
    return new z(this.x + this.width / 2, this.y + this.height);
  }
  get bottomRight() {
    return new z(this.x + this.width, this.y + this.height);
  }
  get corner() {
    return new z(this.x + this.width, this.y + this.height);
  }
  get rightMiddle() {
    return new z(this.x + this.width, this.y + this.height / 2);
  }
  get leftMiddle() {
    return new z(this.x, this.y + this.height / 2);
  }
  get topLine() {
    return new Ie(this.topLeft, this.topRight);
  }
  get rightLine() {
    return new Ie(this.topRight, this.bottomRight);
  }
  get bottomLine() {
    return new Ie(this.bottomLeft, this.bottomRight);
  }
  get leftLine() {
    return new Ie(this.topLeft, this.bottomLeft);
  }
  constructor(e, t, i, r) {
    super(), this.x = e ?? 0, this.y = t ?? 0, this.width = i ?? 0, this.height = r ?? 0;
  }
  getOrigin() {
    return this.origin;
  }
  getTopLeft() {
    return this.topLeft;
  }
  getTopCenter() {
    return this.topCenter;
  }
  getTopRight() {
    return this.topRight;
  }
  getCenter() {
    return this.center;
  }
  getCenterX() {
    return this.x + this.width / 2;
  }
  getCenterY() {
    return this.y + this.height / 2;
  }
  getBottomLeft() {
    return this.bottomLeft;
  }
  getBottomCenter() {
    return this.bottomCenter;
  }
  getBottomRight() {
    return this.bottomRight;
  }
  getCorner() {
    return this.corner;
  }
  getRightMiddle() {
    return this.rightMiddle;
  }
  getLeftMiddle() {
    return this.leftMiddle;
  }
  getTopLine() {
    return this.topLine;
  }
  getRightLine() {
    return this.rightLine;
  }
  getBottomLine() {
    return this.bottomLine;
  }
  getLeftLine() {
    return this.leftLine;
  }
  /**
   * Returns a rectangle that is the bounding box of the rectangle.
   *
   * If `angle` is specified, the bounding box calculation will take into
   * account the rotation of the rectangle by angle degrees around its center.
   */
  bbox(e) {
    if (!e)
      return this.clone();
    const t = Pt.toRad(e), i = Math.abs(Math.sin(t)), r = Math.abs(Math.cos(t)), s = this.width * r + this.height * i, o = this.width * i + this.height * r;
    return new ye(this.x + (this.width - s) / 2, this.y + (this.height - o) / 2, s, o);
  }
  round(e = 0) {
    return this.x = At.round(this.x, e), this.y = At.round(this.y, e), this.width = At.round(this.width, e), this.height = At.round(this.height, e), this;
  }
  add(e, t, i, r) {
    const s = ye.create(e, t, i, r), o = Math.min(this.x, s.x), a = Math.min(this.y, s.y), l = Math.max(this.x + this.width, s.x + s.width), c = Math.max(this.y + this.height, s.y + s.height);
    return this.x = o, this.y = a, this.width = l - o, this.height = c - a, this;
  }
  update(e, t, i, r) {
    const s = ye.create(e, t, i, r);
    return this.x = s.x, this.y = s.y, this.width = s.width, this.height = s.height, this;
  }
  inflate(e, t) {
    const i = e, r = t ?? e;
    return this.x -= i, this.y -= r, this.width += 2 * i, this.height += 2 * r, this;
  }
  snapToGrid(e, t) {
    const i = this.origin.snapToGrid(e, t), r = this.corner.snapToGrid(e, t);
    return this.x = i.x, this.y = i.y, this.width = r.x - i.x, this.height = r.y - i.y, this;
  }
  translate(e, t) {
    const i = z.create(e, t);
    return this.x += i.x, this.y += i.y, this;
  }
  scale(e, t, i = new z()) {
    const r = this.origin.scale(e, t, i);
    return this.x = r.x, this.y = r.y, this.width *= e, this.height *= t, this;
  }
  rotate(e, t = this.getCenter()) {
    if (e !== 0) {
      const i = Pt.toRad(e), r = Math.cos(i), s = Math.sin(i);
      let o = this.getOrigin(), a = this.getTopRight(), l = this.getBottomRight(), c = this.getBottomLeft();
      o = z.rotateEx(o, r, s, t), a = z.rotateEx(a, r, s, t), l = z.rotateEx(l, r, s, t), c = z.rotateEx(c, r, s, t);
      const u = new ye(o.x, o.y, 0, 0);
      u.add(a.x, a.y, 0, 0), u.add(l.x, l.y, 0, 0), u.add(c.x, c.y, 0, 0), this.update(u);
    }
    return this;
  }
  rotate90() {
    const e = (this.width - this.height) / 2;
    this.x += e, this.y -= e;
    const t = this.width;
    return this.width = this.height, this.height = t, this;
  }
  /**
   * Translates the rectangle by `rect.x` and `rect.y` and expand it by
   * `rect.width` and `rect.height`.
   */
  moveAndExpand(e) {
    const t = ye.clone(e);
    return this.x += t.x || 0, this.y += t.y || 0, this.width += t.width || 0, this.height += t.height || 0, this;
  }
  /**
   * Returns an object where `sx` and `sy` give the maximum scaling that can be
   * applied to the rectangle so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxScaleToFit(e, t = this.center) {
    const i = ye.clone(e), r = t.x, s = t.y;
    let o = 1 / 0, a = 1 / 0, l = 1 / 0, c = 1 / 0, u = 1 / 0, h = 1 / 0, d = 1 / 0, f = 1 / 0;
    const p = i.topLeft;
    p.x < r && (o = (this.x - r) / (p.x - r)), p.y < s && (u = (this.y - s) / (p.y - s));
    const g = i.bottomRight;
    g.x > r && (a = (this.x + this.width - r) / (g.x - r)), g.y > s && (h = (this.y + this.height - s) / (g.y - s));
    const m = i.topRight;
    m.x > r && (l = (this.x + this.width - r) / (m.x - r)), m.y < s && (d = (this.y - s) / (m.y - s));
    const v = i.bottomLeft;
    return v.x < r && (c = (this.x - r) / (v.x - r)), v.y > s && (f = (this.y + this.height - s) / (v.y - s)), {
      sx: Math.min(o, a, l, c),
      sy: Math.min(u, h, d, f)
    };
  }
  /**
   * Returns a number that specifies the maximum scaling that can be applied to
   * the rectangle along both axes so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxUniformScaleToFit(e, t = this.center) {
    const i = this.getMaxScaleToFit(e, t);
    return Math.min(i.sx, i.sy);
  }
  containsPoint(e, t) {
    return At.containsPoint(this, z.create(e, t));
  }
  containsRect(e, t, i, r) {
    const s = ye.create(e, t, i, r), o = this.x, a = this.y, l = this.width, c = this.height, u = s.x, h = s.y, d = s.width, f = s.height;
    return l === 0 || c === 0 || d === 0 || f === 0 ? !1 : u >= o && h >= a && u + d <= o + l && h + f <= a + c;
  }
  /**
   * Returns an array of the intersection points of the rectangle and the line.
   * Return `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [
      this.topLine,
      this.rightLine,
      this.bottomLine,
      this.leftLine
    ], i = [], r = [];
    return t.forEach((s) => {
      const o = e.intersectsWithLine(s);
      o !== null && r.indexOf(o.toString()) < 0 && (i.push(o), r.push(o.toString()));
    }), i.length > 0 ? i : null;
  }
  /**
   * Returns the point on the boundary of the rectangle that is the intersection
   * of the rectangle with a line starting in the center the rectangle ending in
   * the point `p`.
   *
   * If `angle` is specified, the intersection will take into account the
   * rotation of the rectangle by `angle` degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t) {
    const i = z.clone(e), r = this.center;
    let s = null;
    t != null && t !== 0 && i.rotate(t, r);
    const o = [this.topLine, this.rightLine, this.bottomLine, this.leftLine], a = new Ie(r, i);
    for (let l = o.length - 1; l >= 0; l -= 1) {
      const c = o[l].intersectsWithLine(a);
      if (c !== null) {
        s = c;
        break;
      }
    }
    return s && t != null && t !== 0 && s.rotate(-t, r), s;
  }
  intersectsWithRect(e, t, i, r) {
    const s = ye.create(e, t, i, r);
    if (!this.isIntersectWithRect(s))
      return null;
    const o = this.origin, a = this.corner, l = s.origin, c = s.corner, u = Math.max(o.x, l.x), h = Math.max(o.y, l.y);
    return new ye(u, h, Math.min(a.x, c.x) - u, Math.min(a.y, c.y) - h);
  }
  isIntersectWithRect(e, t, i, r) {
    const s = ye.create(e, t, i, r), o = this.origin, a = this.corner, l = s.origin, c = s.corner;
    return !(c.x <= o.x || c.y <= o.y || l.x >= a.x || l.y >= a.y);
  }
  /**
   * Normalize the rectangle, i.e. make it so that it has non-negative
   * width and height. If width is less than `0`, the function swaps left and
   * right corners and if height is less than `0`, the top and bottom corners
   * are swapped.
   */
  normalize() {
    let e = this.x, t = this.y, i = this.width, r = this.height;
    return this.width < 0 && (e = this.x + this.width, i = -this.width), this.height < 0 && (t = this.y + this.height, r = -this.height), this.x = e, this.y = t, this.width = i, this.height = r, this;
  }
  /**
   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
   */
  union(e) {
    const t = ye.clone(e), i = this.origin, r = this.corner, s = t.origin, o = t.corner, a = Math.min(i.x, s.x), l = Math.min(i.y, s.y), c = Math.max(r.x, o.x), u = Math.max(r.y, o.y);
    return new ye(a, l, c - a, u - l);
  }
  /**
   * Returns a string ("top", "left", "right" or "bottom") denoting the side of
   * the rectangle which is nearest to the point `p`.
   */
  getNearestSideToPoint(e) {
    const t = z.clone(e), i = t.x - this.x, r = this.x + this.width - t.x, s = t.y - this.y, o = this.y + this.height - t.y;
    let a = i, l = "left";
    return r < a && (a = r, l = "right"), s < a && (a = s, l = "top"), o < a && (l = "bottom"), l;
  }
  /**
   * Returns a point on the boundary of the rectangle nearest to the point `p`.
   */
  getNearestPointToPoint(e) {
    const t = z.clone(e);
    if (this.containsPoint(t)) {
      const i = this.getNearestSideToPoint(t);
      if (i === "left")
        return new z(this.x, t.y);
      if (i === "top")
        return new z(t.x, this.y);
      if (i === "right")
        return new z(this.x + this.width, t.y);
      if (i === "bottom")
        return new z(t.x, this.y + this.height);
    }
    return t.adhereToRect(this);
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.width === this.width && e.height === this.height;
  }
  clone() {
    return new ye(this.x, this.y, this.width, this.height);
  }
  toJSON() {
    return { x: this.x, y: this.y, width: this.width, height: this.height };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.width} ${this.height}`;
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isRectangle = e;
})(ye || (ye = {}));
(function(n) {
  function e(t) {
    return t != null && typeof t == "object" && typeof t.x == "number" && typeof t.y == "number" && typeof t.width == "number" && typeof t.height == "number";
  }
  n.isRectangleLike = e;
})(ye || (ye = {}));
(function(n) {
  function e(o, a, l, c) {
    return o == null || typeof o == "number" ? new n(o, a, l, c) : t(o);
  }
  n.create = e;
  function t(o) {
    return n.isRectangle(o) ? o.clone() : Array.isArray(o) ? new n(o[0], o[1], o[2], o[3]) : new n(o.x, o.y, o.width, o.height);
  }
  n.clone = t;
  function i(o) {
    return new n(o.x - o.a, o.y - o.b, 2 * o.a, 2 * o.b);
  }
  n.fromEllipse = i;
  function r(o) {
    return new n(0, 0, o.width, o.height);
  }
  n.fromSize = r;
  function s(o, a) {
    return new n(o.x, o.y, a.width, a.height);
  }
  n.fromPositionAndSize = s;
})(ye || (ye = {}));
let Ie = class ls extends el {
  get center() {
    return new z((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }
  constructor(e, t, i, r) {
    super(), typeof e == "number" && typeof t == "number" ? (this.start = new z(e, t), this.end = new z(i, r)) : (this.start = z.create(e), this.end = z.create(t));
  }
  getCenter() {
    return this.center;
  }
  /**
   * Rounds the line to the given `precision`.
   */
  round(e = 0) {
    return this.start.round(e), this.end.round(e), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.end.translate(e)), this;
  }
  /**
   * Rotate the line by `angle` around `origin`.
   */
  rotate(e, t) {
    return this.start.rotate(e, t), this.end.rotate(e, t), this;
  }
  /**
   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
   * specified, the line is scaled around `0,0`.
   */
  scale(e, t, i) {
    return this.start.scale(e, t, i), this.end.scale(e, t, i), this;
  }
  /**
   * Returns the length of the line.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Useful for distance comparisons in which real length is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredLength() {
    const e = this.start.x - this.end.x, t = this.start.y - this.end.y;
    return e * e + t * t;
  }
  /**
   * Scale the line so that it has the requested length. The start point of
   * the line is preserved.
   */
  setLength(e) {
    const t = this.length();
    if (!t)
      return this;
    const i = e / t;
    return this.scale(i, i, this.start);
  }
  parallel(e) {
    const t = this.clone();
    if (!t.isDifferentiable())
      return t;
    const { start: i, end: r } = t, s = i.clone().rotate(270, r), o = r.clone().rotate(90, i);
    return i.move(o, e), r.move(s, e), t;
  }
  /**
   * Returns the vector of the line with length equal to length of the line.
   */
  vector() {
    return new z(this.end.x - this.start.x, this.end.y - this.start.y);
  }
  /**
   * Returns the angle of incline of the line.
   *
   * The function returns `NaN` if the start and end endpoints of the line
   * both lie at the same coordinates(it is impossible to determine the angle
   * of incline of a line that appears to be a point). The
   * `line.isDifferentiable()` function may be used in advance to determine
   * whether the angle of incline can be computed for a given line.
   */
  angle() {
    const e = new z(this.start.x + 1, this.start.y);
    return this.start.angleBetween(this.end, e);
  }
  /**
   * Returns a rectangle that is the bounding box of the line.
   */
  bbox() {
    const e = Math.min(this.start.x, this.end.x), t = Math.min(this.start.y, this.end.y), i = Math.max(this.start.x, this.end.x), r = Math.max(this.start.y, this.end.y);
    return new ye(e, t, i - e, r - t);
  }
  /**
   * Returns the bearing (cardinal direction) of the line.
   *
   * The return value is one of the following strings:
   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
   *
   * The function returns 'N' if the two endpoints of the line are coincident.
   */
  bearing() {
    return this.start.bearing(this.end);
  }
  /**
   * Returns the point on the line that lies closest to point `p`.
   */
  closestPoint(e) {
    return this.pointAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the length of the line up to the point that lies closest to point `p`.
   */
  closestPointLength(e) {
    return this.closestPointNormalizedLength(e) * this.length();
  }
  /**
   * Returns a line that is tangent to the line at the point that lies closest
   * to point `p`.
   */
  closestPointTangent(e) {
    return this.tangentAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the normalized length (distance from the start of the line / total
   * line length) of the line up to the point that lies closest to point.
   */
  closestPointNormalizedLength(e) {
    const t = this.vector().dot(new ls(this.start, e).vector()), i = Math.min(1, Math.max(0, t / this.squaredLength()));
    return Number.isNaN(i) ? 0 : i;
  }
  /**
   * Returns a point on the line that lies `rate` (normalized length) away from
   * the beginning of the line.
   */
  pointAt(e) {
    const t = this.start, i = this.end;
    return e <= 0 ? t.clone() : e >= 1 ? i.clone() : t.lerp(i, e);
  }
  /**
   * Returns a point on the line that lies length away from the beginning of
   * the line.
   */
  pointAtLength(e) {
    const t = this.start, i = this.end;
    let r = !0;
    e < 0 && (r = !1, e = -e);
    const s = this.length();
    if (e >= s)
      return r ? i.clone() : t.clone();
    const o = (r ? e : s - e) / s;
    return this.pointAt(o);
  }
  /**
   * Divides the line into two lines at the point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  divideAt(e) {
    const t = this.pointAt(e);
    return [
      new ls(this.start, t),
      new ls(t, this.end)
    ];
  }
  /**
   * Divides the line into two lines at the point that lies length away from
   * the beginning of the line.
   */
  divideAtLength(e) {
    const t = this.pointAtLength(e);
    return [
      new ls(this.start, t),
      new ls(t, this.end)
    ];
  }
  /**
   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
   */
  containsPoint(e) {
    const t = this.start, i = this.end;
    if (t.cross(e, i) !== 0)
      return !1;
    const r = this.length();
    return !(new ls(t, e).length() > r || new ls(e, i).length() > r);
  }
  intersect(e, t) {
    const i = e.intersectsWithLine(this, t);
    return i ? Array.isArray(i) ? i : [i] : null;
  }
  /**
   * Returns the intersection point of the line with another line. Returns
   * `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = new z(this.end.x - this.start.x, this.end.y - this.start.y), i = new z(e.end.x - e.start.x, e.end.y - e.start.y), r = t.x * i.y - t.y * i.x, s = new z(e.start.x - this.start.x, e.start.y - this.start.y), o = s.x * i.y - s.y * i.x, a = s.x * t.y - s.y * t.x;
    if (r === 0 || o * r < 0 || a * r < 0)
      return null;
    if (r > 0) {
      if (o > r || a > r)
        return null;
    } else if (o < r || a < r)
      return null;
    return new z(this.start.x + o * t.x / r, this.start.y + o * t.y / r);
  }
  /**
   * Returns `true` if a tangent line can be found for the line.
   *
   * Tangents cannot be found if both of the line endpoints are coincident
   * (the line appears to be a point).
   */
  isDifferentiable() {
    return !this.start.equals(this.end);
  }
  /**
   * Returns the perpendicular distance between the line and point. The
   * distance is positive if the point lies to the right of the line, negative
   * if the point lies to the left of the line, and `0` if the point lies on
   * the line.
   */
  pointOffset(e) {
    const t = z.clone(e), i = this.start, r = this.end;
    return ((r.x - i.x) * (t.y - i.y) - (r.y - i.y) * (t.x - i.x)) / this.length();
  }
  pointSquaredDistance(e, t) {
    const i = z.create(e, t);
    return this.closestPoint(i).squaredDistance(i);
  }
  pointDistance(e, t) {
    const i = z.create(e, t);
    return this.closestPoint(i).distance(i);
  }
  /**
   * Returns a line tangent to the line at point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  tangentAt(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, i = this.end, r = this.pointAt(e), s = new ls(t, i);
    return s.translate(r.x - t.x, r.y - t.y), s;
  }
  /**
   * Returns a line tangent to the line at point that lies `length` away from
   * the beginning of the line.
   */
  tangentAtLength(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, i = this.end, r = this.pointAtLength(e), s = new ls(t, i);
    return s.translate(r.x - t.x, r.y - t.y), s;
  }
  relativeCcw(e, t) {
    const i = z.create(e, t);
    let r = i.x - this.start.x, s = i.y - this.start.y;
    const o = this.end.x - this.start.x, a = this.end.y - this.start.y;
    let l = r * a - s * o;
    return l === 0 && (l = r * o + s * a, l > 0 && (r -= o, s -= a, l = r * o + s * a, l < 0 && (l = 0))), l < 0 ? -1 : l > 0 ? 1 : 0;
  }
  /**
   * Return `true` if the line equals the other line.
   */
  equals(e) {
    return e != null && this.start.x === e.start.x && this.start.y === e.start.y && this.end.x === e.end.x && this.end.y === e.end.y;
  }
  /**
   * Returns another line which is a clone of the line.
   */
  clone() {
    return new ls(this.start, this.end);
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  serialize() {
    return [this.start.serialize(), this.end.serialize()].join(" ");
  }
};
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isLine = e;
})(Ie || (Ie = {}));
class xs extends el {
  get center() {
    return new z(this.x, this.y);
  }
  constructor(e, t, i, r) {
    super(), this.x = e ?? 0, this.y = t ?? 0, this.a = i ?? 0, this.b = r ?? 0;
  }
  /**
   * Returns a rectangle that is the bounding box of the ellipse.
   */
  bbox() {
    return ye.fromEllipse(this);
  }
  /**
   * Returns a point that is the center of the ellipse.
   */
  getCenter() {
    return this.center;
  }
  inflate(e, t) {
    const i = e, r = t ?? e;
    return this.a += 2 * i, this.b += 2 * r, this;
  }
  normalizedDistance(e, t) {
    const i = z.create(e, t), r = i.x - this.x, s = i.y - this.y, o = this.a, a = this.b;
    return r * r / (o * o) + s * s / (a * a);
  }
  containsPoint(e, t) {
    return this.normalizedDistance(e, t) <= 1;
  }
  /**
   * Returns an array of the intersection points of the ellipse and the line.
   * Returns `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [], i = this.a, r = this.b, s = e.start, o = e.end, a = e.vector(), l = s.diff(new z(this.x, this.y)), c = new z(a.x / (i * i), a.y / (r * r)), u = new z(l.x / (i * i), l.y / (r * r)), h = a.dot(c), d = a.dot(u), f = l.dot(u) - 1, p = d * d - h * f;
    if (p < 0)
      return null;
    if (p > 0) {
      const g = Math.sqrt(p), m = (-d - g) / h, v = (-d + g) / h;
      if ((m < 0 || m > 1) && (v < 0 || v > 1))
        return null;
      m >= 0 && m <= 1 && t.push(s.lerp(o, m)), v >= 0 && v <= 1 && t.push(s.lerp(o, v));
    } else {
      const g = -d / h;
      if (g >= 0 && g <= 1)
        t.push(s.lerp(o, g));
      else
        return null;
    }
    return t;
  }
  /**
   * Returns the point on the boundary of the ellipse that is the
   * intersection of the ellipse with a line starting in the center
   * of the ellipse ending in the point `p`.
   *
   * If angle is specified, the intersection will take into account
   * the rotation of the ellipse by angle degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t = 0) {
    const i = z.clone(e);
    t && i.rotate(t, this.getCenter());
    const r = i.x - this.x, s = i.y - this.y;
    let o;
    if (r === 0)
      return o = this.bbox().getNearestPointToPoint(i), t ? o.rotate(-t, this.getCenter()) : o;
    const a = s / r, l = a * a, c = this.a * this.a, u = this.b * this.b;
    let h = Math.sqrt(1 / (1 / c + l / u));
    h = r < 0 ? -h : h;
    const d = a * h;
    return o = new z(this.x + h, this.y + d), t ? o.rotate(-t, this.getCenter()) : o;
  }
  /**
   * Returns the angle between the x-axis and the tangent from a point. It is
   * valid for points lying on the ellipse boundary only.
   */
  tangentTheta(e) {
    const t = z.clone(e), i = t.x, r = t.y, s = this.a, o = this.b, a = this.bbox().center, l = a.x, c = a.y, u = 30, h = i > a.x + s / 2, d = i < a.x - s / 2;
    let f, p;
    return h || d ? (p = i > a.x ? r - u : r + u, f = s * s / (i - l) - s * s * (r - c) * (p - c) / (o * o * (i - l)) + l) : (f = r > a.y ? i + u : i - u, p = o * o / (r - c) - o * o * (i - l) * (f - l) / (s * s * (r - c)) + c), new z(f, p).theta(t);
  }
  scale(e, t) {
    return this.a *= e, this.b *= t, this;
  }
  rotate(e, t) {
    const i = ye.fromEllipse(this);
    i.rotate(e, t);
    const r = xs.fromRect(i);
    return this.a = r.a, this.b = r.b, this.x = r.x, this.y = r.y, this;
  }
  translate(e, t) {
    const i = z.create(e, t);
    return this.x += i.x, this.y += i.y, this;
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.a === this.a && e.b === this.b;
  }
  clone() {
    return new xs(this.x, this.y, this.a, this.b);
  }
  toJSON() {
    return { x: this.x, y: this.y, a: this.a, b: this.b };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.a} ${this.b}`;
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isEllipse = e;
})(xs || (xs = {}));
(function(n) {
  function e(r, s, o, a) {
    return r == null || typeof r == "number" ? new n(r, s, o, a) : t(r);
  }
  n.create = e;
  function t(r) {
    return n.isEllipse(r) ? r.clone() : Array.isArray(r) ? new n(r[0], r[1], r[2], r[3]) : new n(r.x, r.y, r.a, r.b);
  }
  n.parse = t;
  function i(r) {
    const s = r.center;
    return new n(s.x, s.y, r.width / 2, r.height / 2);
  }
  n.fromRect = i;
})(xs || (xs = {}));
const une = new RegExp("^[\\s\\dLMCZz,.]*$");
function hne(n) {
  return typeof n != "string" ? !1 : une.test(n);
}
function B0(n, e) {
  return (n % e + e) % e;
}
function dne(n, e, t, i, r) {
  const s = [], o = n[n.length - 1], a = e != null && e > 0, l = e || 0;
  if (i && a) {
    n = n.slice();
    const h = n[0], d = new z(o.x + (h.x - o.x) / 2, o.y + (h.y - o.y) / 2);
    n.splice(0, 0, d);
  }
  let c = n[0], u = 1;
  for (t ? s.push("M", c.x, c.y) : s.push("L", c.x, c.y); u < (i ? n.length : n.length - 1); ) {
    let h = n[B0(u, n.length)], d = c.x - h.x, f = c.y - h.y;
    if (a && (d !== 0 || f !== 0) && (r == null || r.indexOf(u - 1) < 0)) {
      let p = Math.sqrt(d * d + f * f);
      const g = d * Math.min(l, p / 2) / p, m = f * Math.min(l, p / 2) / p, v = h.x + g, y = h.y + m;
      s.push("L", v, y);
      let b = n[B0(u + 1, n.length)];
      for (; u < n.length - 2 && Math.round(b.x - h.x) === 0 && Math.round(b.y - h.y) === 0; )
        b = n[B0(u + 2, n.length)], u += 1;
      d = b.x - h.x, f = b.y - h.y, p = Math.max(1, Math.sqrt(d * d + f * f));
      const w = d * Math.min(l, p / 2) / p, x = f * Math.min(l, p / 2) / p, S = h.x + w, C = h.y + x;
      s.push("Q", h.x, h.y, S, C), h = new z(S, C);
    } else
      s.push("L", h.x, h.y);
    c = h, u += 1;
  }
  return i ? s.push("Z") : s.push("L", o.x, o.y), s.map((h) => typeof h == "string" ? h : +h.toFixed(3)).join(" ");
}
function YM(n, e = {}) {
  const t = [];
  return n && n.length && n.forEach((i) => {
    Array.isArray(i) ? t.push({ x: i[0], y: i[1] }) : t.push({ x: i.x, y: i.y });
  }), dne(t, e.round, e.initialMove == null || e.initialMove, e.close, e.exclude);
}
function lm(n, e, t, i, r = 0, s = 0, o = 0, a, l) {
  if (t === 0 || i === 0)
    return [];
  a -= n, l -= e, t = Math.abs(t), i = Math.abs(i);
  const c = -a / 2, u = -l / 2, h = Math.cos(r * Math.PI / 180), d = Math.sin(r * Math.PI / 180), f = h * c + d * u, p = -1 * d * c + h * u, g = f * f, m = p * p, v = t * t, y = i * i, b = g / v + m / y;
  let w;
  if (b > 1)
    t = Math.sqrt(b) * t, i = Math.sqrt(b) * i, w = 0;
  else {
    let ee = 1;
    s === o && (ee = -1), w = ee * Math.sqrt((v * y - v * m - y * g) / (v * m + y * g));
  }
  const x = w * t * p / i, S = -1 * w * i * f / t, C = h * x - d * S + a / 2, k = d * x + h * S + l / 2;
  let E = Math.atan2((p - S) / i, (f - x) / t) - Math.atan2(0, 1), M = E >= 0 ? E : 2 * Math.PI + E;
  E = Math.atan2((-p - S) / i, (-f - x) / t) - Math.atan2((p - S) / i, (f - x) / t);
  let _ = E >= 0 ? E : 2 * Math.PI + E;
  o === 0 && _ > 0 ? _ -= 2 * Math.PI : o !== 0 && _ < 0 && (_ += 2 * Math.PI);
  const T = _ * 2 / Math.PI, B = Math.ceil(T < 0 ? -1 * T : T), I = _ / B, P = 8 / 3 * Math.sin(I / 4) * Math.sin(I / 4) / Math.sin(I / 2), A = h * t, N = h * i, q = d * t, j = d * i;
  let H = Math.cos(M), oe = Math.sin(M), te = -P * (A * oe + j * H), W = -P * (q * oe - N * H), U = 0, ae = 0;
  const he = [];
  for (let ee = 0; ee < B; ee += 1) {
    M += I, H = Math.cos(M), oe = Math.sin(M), U = A * H - j * oe + C, ae = q * H + N * oe + k;
    const pe = -P * (A * oe + j * H), be = -P * (q * oe - N * H), fe = ee * 6;
    he[fe] = Number(te + n), he[fe + 1] = Number(W + e), he[fe + 2] = Number(U - pe + n), he[fe + 3] = Number(ae - be + e), he[fe + 4] = Number(U + n), he[fe + 5] = Number(ae + e), te = U + pe, W = ae + be;
  }
  return he.map((ee) => +ee.toFixed(2));
}
function fne(n, e, t, i, r = 0, s = 0, o = 0, a, l) {
  const c = [], u = lm(n, e, t, i, r, s, o, a, l);
  if (u != null)
    for (let h = 0, d = u.length; h < d; h += 6)
      c.push("C", u[h], u[h + 1], u[h + 2], u[h + 3], u[h + 4], u[h + 5]);
  return c.join(" ");
}
class En extends el {
  get start() {
    return this.points[0] || null;
  }
  get end() {
    return this.points[this.points.length - 1] || null;
  }
  constructor(e) {
    if (super(), e != null) {
      if (typeof e == "string")
        return En.parse(e);
      this.points = e.map((t) => z.create(t));
    } else
      this.points = [];
  }
  scale(e, t, i = new z()) {
    return this.points.forEach((r) => r.scale(e, t, i)), this;
  }
  rotate(e, t) {
    return this.points.forEach((i) => i.rotate(e, t)), this;
  }
  translate(e, t) {
    const i = z.create(e, t);
    return this.points.forEach((r) => r.translate(i.x, i.y)), this;
  }
  round(e = 0) {
    return this.points.forEach((t) => t.round(e)), this;
  }
  bbox() {
    if (this.points.length === 0)
      return new ye();
    let e = 1 / 0, t = -1 / 0, i = 1 / 0, r = -1 / 0;
    const s = this.points;
    for (let o = 0, a = s.length; o < a; o += 1) {
      const l = s[o], c = l.x, u = l.y;
      c < e && (e = c), c > t && (t = c), u < i && (i = u), u > r && (r = u);
    }
    return new ye(e, i, t - e, r - i);
  }
  closestPoint(e) {
    const t = this.closestPointLength(e);
    return this.pointAtLength(t);
  }
  closestPointLength(e) {
    const t = this.points, i = t.length;
    if (i === 0 || i === 1)
      return 0;
    let r = 0, s = 0, o = 1 / 0;
    for (let a = 0, l = i - 1; a < l; a += 1) {
      const c = new Ie(t[a], t[a + 1]), u = c.length(), h = c.closestPointNormalizedLength(e), f = c.pointAt(h).squaredDistance(e);
      f < o && (o = f, s = r + h * u), r += u;
    }
    return s;
  }
  closestPointNormalizedLength(e) {
    const t = this.length();
    return t === 0 ? 0 : this.closestPointLength(e) / t;
  }
  closestPointTangent(e) {
    const t = this.closestPointLength(e);
    return this.tangentAtLength(t);
  }
  containsPoint(e) {
    if (this.points.length === 0)
      return !1;
    const t = z.clone(e), i = t.x, r = t.y, s = this.points, o = s.length;
    let a = o - 1, l = 0;
    for (let c = 0; c < o; c += 1) {
      const u = s[a], h = s[c];
      if (t.equals(u))
        return !0;
      const d = new Ie(u, h);
      if (d.containsPoint(e))
        return !0;
      if (r <= u.y && r > h.y || r > u.y && r <= h.y) {
        const f = u.x - i > h.x - i ? u.x - i : h.x - i;
        if (f >= 0) {
          const p = new z(i + f, r), g = new Ie(e, p);
          d.intersectsWithLine(g) && (l += 1);
        }
      }
      a = c;
    }
    return l % 2 === 1;
  }
  intersectsWithLine(e) {
    const t = [];
    for (let i = 0, r = this.points.length - 1; i < r; i += 1) {
      const s = this.points[i], o = this.points[i + 1], a = e.intersectsWithLine(new Ie(s, o));
      a && t.push(a);
    }
    return t.length > 0 ? t : null;
  }
  isDifferentiable() {
    for (let e = 0, t = this.points.length - 1; e < t; e += 1) {
      const i = this.points[e], r = this.points[e + 1];
      if (new Ie(i, r).isDifferentiable())
        return !0;
    }
    return !1;
  }
  length() {
    let e = 0;
    for (let t = 0, i = this.points.length - 1; t < i; t += 1) {
      const r = this.points[t], s = this.points[t + 1];
      e += r.distance(s);
    }
    return e;
  }
  pointAt(e) {
    const t = this.points, i = t.length;
    if (i === 0)
      return null;
    if (i === 1 || e <= 0)
      return t[0].clone();
    if (e >= 1)
      return t[i - 1].clone();
    const s = this.length() * e;
    return this.pointAtLength(s);
  }
  pointAtLength(e) {
    const t = this.points, i = t.length;
    if (i === 0)
      return null;
    if (i === 1)
      return t[0].clone();
    let r = !0;
    e < 0 && (r = !1, e = -e);
    let s = 0;
    for (let a = 0, l = i - 1; a < l; a += 1) {
      const c = r ? a : l - 1 - a, u = t[c], h = t[c + 1], d = new Ie(u, h), f = u.distance(h);
      if (e <= s + f)
        return d.pointAtLength((r ? 1 : -1) * (e - s));
      s += f;
    }
    return (r ? t[i - 1] : t[0]).clone();
  }
  tangentAt(e) {
    const i = this.points.length;
    if (i === 0 || i === 1)
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const s = this.length() * e;
    return this.tangentAtLength(s);
  }
  tangentAtLength(e) {
    const t = this.points, i = t.length;
    if (i === 0 || i === 1)
      return null;
    let r = !0;
    e < 0 && (r = !1, e = -e);
    let s, o = 0;
    for (let a = 0, l = i - 1; a < l; a += 1) {
      const c = r ? a : l - 1 - a, u = t[c], h = t[c + 1], d = new Ie(u, h), f = u.distance(h);
      if (d.isDifferentiable()) {
        if (e <= o + f)
          return d.tangentAtLength((r ? 1 : -1) * (e - o));
        s = d;
      }
      o += f;
    }
    if (s) {
      const a = r ? 1 : 0;
      return s.tangentAt(a);
    }
    return null;
  }
  simplify(e = {}) {
    const t = this.points;
    if (t.length < 3)
      return this;
    const i = e.threshold || 0;
    let r = 0;
    for (; t[r + 2]; ) {
      const s = r, o = r + 1, a = r + 2, l = t[s], c = t[o], u = t[a];
      new Ie(l, u).closestPoint(c).distance(c) <= i ? t.splice(o, 1) : r += 1;
    }
    return this;
  }
  toHull() {
    const e = this.points, t = e.length;
    if (t === 0)
      return new En();
    let i = e[0];
    for (let d = 1; d < t; d += 1)
      (e[d].y < i.y || e[d].y === i.y && e[d].x > i.x) && (i = e[d]);
    const r = [];
    for (let d = 0; d < t; d += 1) {
      let f = i.theta(e[d]);
      f === 0 && (f = 360), r.push([e[d], d, f]);
    }
    if (r.sort((d, f) => {
      let p = d[2] - f[2];
      return p === 0 && (p = f[1] - d[1]), p;
    }), r.length > 2) {
      const d = r[r.length - 1];
      r.unshift(d);
    }
    const s = {}, o = [], a = (d) => `${d[0].toString()}@${d[1]}`;
    for (; r.length !== 0; ) {
      const d = r.pop(), f = d[0];
      if (s[a(d)])
        continue;
      let p = !1;
      for (; !p; )
        if (o.length < 2)
          o.push(d), p = !0;
        else {
          const g = o.pop(), m = g[0], v = o.pop(), y = v[0], b = y.cross(m, f);
          if (b < 0)
            o.push(v), o.push(g), o.push(d), p = !0;
          else if (b === 0) {
            const x = m.angleBetween(y, f);
            Math.abs(x - 180) < 1e-10 || m.equals(f) || y.equals(m) ? (s[a(g)] = m, o.push(v)) : Math.abs((x + 1) % 360 - 1) < 1e-10 && (o.push(v), r.push(g));
          } else
            s[a(g)] = m, o.push(v);
        }
    }
    o.length > 2 && o.pop();
    let l, c = -1;
    for (let d = 0, f = o.length; d < f; d += 1) {
      const p = o[d][1];
      (l === void 0 || p < l) && (l = p, c = d);
    }
    let u = [];
    if (c > 0) {
      const d = o.slice(c), f = o.slice(0, c);
      u = d.concat(f);
    } else
      u = o;
    const h = [];
    for (let d = 0, f = u.length; d < f; d += 1)
      h.push(u[d][0]);
    return new En(h);
  }
  equals(e) {
    return e == null || e.points.length !== this.points.length ? !1 : e.points.every((t, i) => t.equals(this.points[i]));
  }
  clone() {
    return new En(this.points.map((e) => e.clone()));
  }
  toJSON() {
    return this.points.map((e) => e.toJSON());
  }
  serialize() {
    return this.points.map((e) => `${e.serialize()}`).join(" ");
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isPolyline = e;
})(En || (En = {}));
(function(n) {
  function e(t) {
    const i = t.trim();
    if (i === "")
      return new n();
    const r = [], s = i.split(/\s*,\s*|\s+/);
    for (let o = 0, a = s.length; o < a; o += 2)
      r.push({ x: +s[o], y: +s[o + 1] });
    return new n(r);
  }
  n.parse = e;
})(En || (En = {}));
class yn extends el {
  constructor(e, t, i, r) {
    super(), this.PRECISION = 3, this.start = z.create(e), this.controlPoint1 = z.create(t), this.controlPoint2 = z.create(i), this.end = z.create(r);
  }
  bbox() {
    const e = this.start, t = this.controlPoint1, i = this.controlPoint2, r = this.end, s = e.x, o = e.y, a = t.x, l = t.y, c = i.x, u = i.y, h = r.x, d = r.y, f = [], p = [[], []];
    let g, m, v, y, b, w, x, S;
    for (let A = 0; A < 2; A += 1) {
      if (A === 0 ? (m = 6 * s - 12 * a + 6 * c, g = -3 * s + 9 * a - 9 * c + 3 * h, v = 3 * a - 3 * s) : (m = 6 * o - 12 * l + 6 * u, g = -3 * o + 9 * l - 9 * u + 3 * d, v = 3 * l - 3 * o), Math.abs(g) < 1e-12) {
        if (Math.abs(m) < 1e-12)
          continue;
        y = -v / m, y > 0 && y < 1 && f.push(y);
        continue;
      }
      x = m * m - 4 * v * g, S = Math.sqrt(x), !(x < 0) && (b = (-m + S) / (2 * g), b > 0 && b < 1 && f.push(b), w = (-m - S) / (2 * g), w > 0 && w < 1 && f.push(w));
    }
    let C, k, E, M = f.length;
    const _ = M;
    for (; M; )
      M -= 1, y = f[M], E = 1 - y, C = E * E * E * s + 3 * E * E * y * a + 3 * E * y * y * c + y * y * y * h, p[0][M] = C, k = E * E * E * o + 3 * E * E * y * l + 3 * E * y * y * u + y * y * y * d, p[1][M] = k;
    f[_] = 0, f[_ + 1] = 1, p[0][_] = s, p[1][_] = o, p[0][_ + 1] = h, p[1][_ + 1] = d, f.length = _ + 2, p[0].length = _ + 2, p[1].length = _ + 2;
    const T = Math.min.apply(null, p[0]), B = Math.min.apply(null, p[1]), I = Math.max.apply(null, p[0]), P = Math.max.apply(null, p[1]);
    return new ye(T, B, I - T, P - B);
  }
  closestPoint(e, t = {}) {
    return this.pointAtT(this.closestPointT(e, t));
  }
  closestPointLength(e, t = {}) {
    const i = this.getOptions(t);
    return this.lengthAtT(this.closestPointT(e, i), i);
  }
  closestPointNormalizedLength(e, t = {}) {
    const i = this.getOptions(t), r = this.closestPointLength(e, i);
    if (!r)
      return 0;
    const s = this.length(i);
    return s === 0 ? 0 : r / s;
  }
  closestPointT(e, t = {}) {
    const i = this.getPrecision(t), r = this.getDivisions(t), s = Math.pow(10, -i);
    let o = null, a = 0, l = 0, c = 0, u = 0, h = 0, d = null;
    const f = r.length;
    let p = f > 0 ? 1 / f : 0;
    for (r.forEach((g, m) => {
      const v = g.start.distance(e), y = g.end.distance(e), b = v + y;
      (d == null || b < d) && (o = g, a = m * p, l = (m + 1) * p, c = v, u = y, d = b, h = g.endpointDistance());
    }); ; ) {
      const g = c ? Math.abs(c - u) / c : 0, m = u != null ? Math.abs(c - u) / u : 0, v = g < s || m < s, y = c ? c < h * s : !0, b = u ? u < h * s : !0;
      if (v || (y || b))
        return c <= u ? a : l;
      const x = o.divide(0.5);
      p /= 2;
      const S = x[0].start.distance(e), C = x[0].end.distance(e), k = S + C, E = x[1].start.distance(e), M = x[1].end.distance(e), _ = E + M;
      k <= _ ? (o = x[0], l -= p, c = S, u = C) : (o = x[1], a += p, c = E, u = M);
    }
  }
  closestPointTangent(e, t = {}) {
    return this.tangentAtT(this.closestPointT(e, t));
  }
  containsPoint(e, t = {}) {
    return this.toPolyline(t).containsPoint(e);
  }
  divideAt(e, t = {}) {
    if (e <= 0)
      return this.divideAtT(0);
    if (e >= 1)
      return this.divideAtT(1);
    const i = this.tAt(e, t);
    return this.divideAtT(i);
  }
  divideAtLength(e, t = {}) {
    const i = this.tAtLength(e, t);
    return this.divideAtT(i);
  }
  divide(e) {
    return this.divideAtT(e);
  }
  divideAtT(e) {
    const t = this.start, i = this.controlPoint1, r = this.controlPoint2, s = this.end;
    if (e <= 0)
      return [
        new yn(t, t, t, t),
        new yn(t, i, r, s)
      ];
    if (e >= 1)
      return [
        new yn(t, i, r, s),
        new yn(s, s, s, s)
      ];
    const o = this.getSkeletonPoints(e), a = o.startControlPoint1, l = o.startControlPoint2, c = o.divider, u = o.dividerControlPoint1, h = o.dividerControlPoint2;
    return [
      new yn(t, a, l, c),
      new yn(c, u, h, s)
    ];
  }
  endpointDistance() {
    return this.start.distance(this.end);
  }
  getSkeletonPoints(e) {
    const t = this.start, i = this.controlPoint1, r = this.controlPoint2, s = this.end;
    if (e <= 0)
      return {
        startControlPoint1: t.clone(),
        startControlPoint2: t.clone(),
        divider: t.clone(),
        dividerControlPoint1: i.clone(),
        dividerControlPoint2: r.clone()
      };
    if (e >= 1)
      return {
        startControlPoint1: i.clone(),
        startControlPoint2: r.clone(),
        divider: s.clone(),
        dividerControlPoint1: s.clone(),
        dividerControlPoint2: s.clone()
      };
    const o = new Ie(t, i).pointAt(e), a = new Ie(i, r).pointAt(e), l = new Ie(r, s).pointAt(e), c = new Ie(o, a).pointAt(e), u = new Ie(a, l).pointAt(e), h = new Ie(c, u).pointAt(e);
    return {
      startControlPoint1: o,
      startControlPoint2: c,
      divider: h,
      dividerControlPoint1: u,
      dividerControlPoint2: l
    };
  }
  getSubdivisions(e = {}) {
    const t = this.getPrecision(e);
    let i = [
      new yn(this.start, this.controlPoint1, this.controlPoint2, this.end)
    ];
    if (t === 0)
      return i;
    let r = this.endpointDistance();
    const s = Math.pow(10, -t);
    let o = 0;
    for (; ; ) {
      o += 1;
      const a = [];
      i.forEach((u) => {
        const h = u.divide(0.5);
        a.push(h[0], h[1]);
      });
      const l = a.reduce((u, h) => u + h.endpointDistance(), 0), c = l !== 0 ? (l - r) / l : 0;
      if (o > 1 && c < s)
        return a;
      i = a, r = l;
    }
  }
  length(e = {}) {
    return this.getDivisions(e).reduce((i, r) => i + r.endpointDistance(), 0);
  }
  lengthAtT(e, t = {}) {
    if (e <= 0)
      return 0;
    const i = t.precision === void 0 ? this.PRECISION : t.precision;
    return this.divide(e)[0].length({ precision: i });
  }
  pointAt(e, t = {}) {
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const i = this.tAt(e, t);
    return this.pointAtT(i);
  }
  pointAtLength(e, t = {}) {
    const i = this.tAtLength(e, t);
    return this.pointAtT(i);
  }
  pointAtT(e) {
    return e <= 0 ? this.start.clone() : e >= 1 ? this.end.clone() : this.getSkeletonPoints(e).divider;
  }
  isDifferentiable() {
    const e = this.start, t = this.controlPoint1, i = this.controlPoint2, r = this.end;
    return !(e.equals(t) && t.equals(i) && i.equals(r));
  }
  tangentAt(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    e < 0 ? e = 0 : e > 1 && (e = 1);
    const i = this.tAt(e, t);
    return this.tangentAtT(i);
  }
  tangentAtLength(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    const i = this.tAtLength(e, t);
    return this.tangentAtT(i);
  }
  tangentAtT(e) {
    if (!this.isDifferentiable())
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const t = this.getSkeletonPoints(e), i = t.startControlPoint2, r = t.dividerControlPoint1, s = t.divider, o = new Ie(i, r);
    return o.translate(s.x - i.x, s.y - i.y), o;
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getDivisions(e = {}) {
    if (e.subdivisions != null)
      return e.subdivisions;
    const t = this.getPrecision(e);
    return this.getSubdivisions({ precision: t });
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), i = this.getDivisions(e);
    return { precision: t, subdivisions: i };
  }
  tAt(e, t = {}) {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const i = this.getOptions(t), s = this.length(i) * e;
    return this.tAtLength(s, i);
  }
  tAtLength(e, t = {}) {
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.getPrecision(t), s = this.getDivisions(t), o = { precision: r, subdivisions: s };
    let a = null, l, c, u = 0, h = 0, d = 0;
    const f = s.length;
    let p = f > 0 ? 1 / f : 0;
    for (let v = 0; v < f; v += 1) {
      const y = i ? v : f - 1 - v, b = s[v], w = b.endpointDistance();
      if (e <= d + w) {
        a = b, l = y * p, c = (y + 1) * p, u = i ? e - d : w + d - e, h = i ? w + d - e : e - d;
        break;
      }
      d += w;
    }
    if (a == null)
      return i ? 1 : 0;
    const g = this.length(o), m = Math.pow(10, -r);
    for (; ; ) {
      let v;
      if (v = g !== 0 ? u / g : 0, v < m)
        return l;
      if (v = g !== 0 ? h / g : 0, v < m)
        return c;
      let y, b;
      const w = a.divide(0.5);
      p /= 2;
      const x = w[0].endpointDistance(), S = w[1].endpointDistance();
      u <= x ? (a = w[0], c -= p, y = u, b = x - y) : (a = w[1], l += p, y = u - x, b = S - y), u = y, h = b;
    }
  }
  toPoints(e = {}) {
    const t = this.getDivisions(e), i = [t[0].start.clone()];
    return t.forEach((r) => i.push(r.end.clone())), i;
  }
  toPolyline(e = {}) {
    return new En(this.toPoints(e));
  }
  scale(e, t, i) {
    return this.start.scale(e, t, i), this.controlPoint1.scale(e, t, i), this.controlPoint2.scale(e, t, i), this.end.scale(e, t, i), this;
  }
  rotate(e, t) {
    return this.start.rotate(e, t), this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return e != null && this.start.equals(e.start) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2) && this.end.equals(e.end);
  }
  clone() {
    return new yn(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return [
      this.start.serialize(),
      this.controlPoint1.serialize(),
      this.controlPoint2.serialize(),
      this.end.serialize()
    ].join(" ");
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isCurve = e;
})(yn || (yn = {}));
(function(n) {
  function e(r) {
    const s = r.length, o = [], a = [];
    let l = 2;
    o[0] = r[0] / l;
    for (let c = 1; c < s; c += 1)
      a[c] = 1 / l, l = (c < s - 1 ? 4 : 3.5) - a[c], o[c] = (r[c] - o[c - 1]) / l;
    for (let c = 1; c < s; c += 1)
      o[s - c - 1] -= a[s - c] * o[s - c];
    return o;
  }
  function t(r) {
    const s = r.map((d) => z.clone(d)), o = [], a = [], l = s.length - 1;
    if (l === 1)
      return o[0] = new z((2 * s[0].x + s[1].x) / 3, (2 * s[0].y + s[1].y) / 3), a[0] = new z(2 * o[0].x - s[0].x, 2 * o[0].y - s[0].y), [o, a];
    const c = [];
    for (let d = 1; d < l - 1; d += 1)
      c[d] = 4 * s[d].x + 2 * s[d + 1].x;
    c[0] = s[0].x + 2 * s[1].x, c[l - 1] = (8 * s[l - 1].x + s[l].x) / 2;
    const u = e(c);
    for (let d = 1; d < l - 1; d += 1)
      c[d] = 4 * s[d].y + 2 * s[d + 1].y;
    c[0] = s[0].y + 2 * s[1].y, c[l - 1] = (8 * s[l - 1].y + s[l].y) / 2;
    const h = e(c);
    for (let d = 0; d < l; d += 1)
      o.push(new z(u[d], h[d])), d < l - 1 ? a.push(new z(2 * s[d + 1].x - u[d + 1], 2 * s[d + 1].y - h[d + 1])) : a.push(new z((s[l].x + u[l - 1]) / 2, (s[l].y + h[l - 1]) / 2));
    return [o, a];
  }
  function i(r) {
    if (r == null || Array.isArray(r) && r.length < 2)
      throw new Error("At least 2 points are required");
    const s = t(r), o = [];
    for (let a = 0, l = s[0].length; a < l; a += 1) {
      const c = new z(s[0][a].x, s[0][a].y), u = new z(s[1][a].x, s[1][a].y);
      o.push(new n(r[a], c, u, r[a + 1]));
    }
    return o;
  }
  n.throughPoints = i;
})(yn || (yn = {}));
class Ev extends el {
  constructor() {
    super(...arguments), this.isVisible = !0, this.isSegment = !0, this.isSubpathStart = !1;
  }
  get end() {
    return this.endPoint;
  }
  get start() {
    if (this.previousSegment == null)
      throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");
    return this.previousSegment.end;
  }
  closestPointT(e, t) {
    if (this.closestPointNormalizedLength)
      return this.closestPointNormalizedLength(e);
    throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.");
  }
  // eslint-disable-next-line
  lengthAtT(e, t) {
    if (e <= 0)
      return 0;
    const i = this.length();
    return e >= 1 ? i : i * e;
  }
  divideAtT(e) {
    if (this.divideAt)
      return this.divideAt(e);
    throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.");
  }
  pointAtT(e) {
    if (this.pointAt)
      return this.pointAt(e);
    throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.");
  }
  tangentAtT(e) {
    if (this.tangentAt)
      return this.tangentAt(e);
    throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.");
  }
}
class Mi extends Ev {
  constructor(e, t) {
    super(), Ie.isLine(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = z.create(e, t).round(2);
  }
  get type() {
    return "L";
  }
  get line() {
    return new Ie(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [new Mi(t[0]), new Mi(t[1])];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [new Mi(t[0]), new Mi(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return this.previousSegment == null ? !1 : !this.start.equals(this.end);
  }
  clone() {
    return new Mi(this.end);
  }
  scale(e, t, i) {
    return this.end.scale(e, t, i), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return `${this.type} ${e.x} ${e.y}`;
  }
}
(function(n) {
  function e(...t) {
    const i = t.length, r = t[0];
    if (Ie.isLine(r))
      return new n(r);
    if (z.isPointLike(r))
      return i === 1 ? new n(r) : t.map((o) => new n(o));
    if (i === 2)
      return new n(+t[0], +t[1]);
    const s = [];
    for (let o = 0; o < i; o += 2) {
      const a = +t[o], l = +t[o + 1];
      s.push(new n(a, l));
    }
    return s;
  }
  n.create = e;
})(Mi || (Mi = {}));
class Au extends Ev {
  get end() {
    if (!this.subpathStartSegment)
      throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");
    return this.subpathStartSegment.end;
  }
  get type() {
    return "Z";
  }
  get line() {
    return new Ie(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [
      // do not actually cut into the segment, first divided part can stay as Z
      t[1].isDifferentiable() ? new Mi(t[0]) : this.clone(),
      new Mi(t[1])
    ];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [
      t[1].isDifferentiable() ? new Mi(t[0]) : this.clone(),
      new Mi(t[1])
    ];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return !this.previousSegment || !this.subpathStartSegment ? !1 : !this.start.equals(this.end);
  }
  scale() {
    return this;
  }
  rotate() {
    return this;
  }
  translate() {
    return this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  clone() {
    return new Au();
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return this.type;
  }
}
(function(n) {
  function e() {
    return new n();
  }
  n.create = e;
})(Au || (Au = {}));
class $u extends Ev {
  constructor(e, t) {
    super(), this.isVisible = !1, this.isSubpathStart = !0, Ie.isLine(e) || yn.isCurve(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = z.create(e, t).round(2);
  }
  get start() {
    throw new Error("Illegal access. Moveto segments should not need a start property.");
  }
  get type() {
    return "M";
  }
  bbox() {
    return null;
  }
  closestPoint() {
    return this.end.clone();
  }
  closestPointLength() {
    return 0;
  }
  closestPointNormalizedLength() {
    return 0;
  }
  closestPointT() {
    return 1;
  }
  closestPointTangent() {
    return null;
  }
  length() {
    return 0;
  }
  lengthAtT() {
    return 0;
  }
  divideAt() {
    return [this.clone(), this.clone()];
  }
  divideAtLength() {
    return [this.clone(), this.clone()];
  }
  getSubdivisions() {
    return [];
  }
  pointAt() {
    return this.end.clone();
  }
  pointAtLength() {
    return this.end.clone();
  }
  pointAtT() {
    return this.end.clone();
  }
  tangentAt() {
    return null;
  }
  tangentAtLength() {
    return null;
  }
  tangentAtT() {
    return null;
  }
  isDifferentiable() {
    return !1;
  }
  scale(e, t, i) {
    return this.end.scale(e, t, i), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  clone() {
    return new $u(this.end);
  }
  equals(e) {
    return this.type === e.type && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return `${this.type} ${e.x} ${e.y}`;
  }
}
(function(n) {
  function e(...t) {
    const i = t.length, r = t[0];
    if (Ie.isLine(r))
      return new n(r);
    if (yn.isCurve(r))
      return new n(r);
    if (z.isPointLike(r)) {
      if (i === 1)
        return new n(r);
      const o = [];
      for (let a = 0; a < i; a += 1)
        a === 0 ? o.push(new n(t[a])) : o.push(new Mi(t[a]));
      return o;
    }
    if (i === 2)
      return new n(+t[0], +t[1]);
    const s = [];
    for (let o = 0; o < i; o += 2) {
      const a = +t[o], l = +t[o + 1];
      o === 0 ? s.push(new n(a, l)) : s.push(new Mi(a, l));
    }
    return s;
  }
  n.create = e;
})($u || ($u = {}));
class Br extends Ev {
  constructor(e, t, i, r, s, o) {
    super(), yn.isCurve(e) ? (this.controlPoint1 = e.controlPoint1.clone().round(2), this.controlPoint2 = e.controlPoint2.clone().round(2), this.endPoint = e.end.clone().round(2)) : typeof e == "number" ? (this.controlPoint1 = new z(e, t).round(2), this.controlPoint2 = new z(i, r).round(2), this.endPoint = new z(s, o).round(2)) : (this.controlPoint1 = z.create(e).round(2), this.controlPoint2 = z.create(t).round(2), this.endPoint = z.create(i).round(2));
  }
  get type() {
    return "C";
  }
  get curve() {
    return new yn(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  bbox() {
    return this.curve.bbox();
  }
  closestPoint(e) {
    return this.curve.closestPoint(e);
  }
  closestPointLength(e) {
    return this.curve.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.curve.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.curve.closestPointTangent(e);
  }
  length() {
    return this.curve.length();
  }
  divideAt(e, t = {}) {
    const i = this.curve.divideAt(e, t);
    return [new Br(i[0]), new Br(i[1])];
  }
  divideAtLength(e, t = {}) {
    const i = this.curve.divideAtLength(e, t);
    return [new Br(i[0]), new Br(i[1])];
  }
  divideAtT(e) {
    const t = this.curve.divideAtT(e);
    return [new Br(t[0]), new Br(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.curve.pointAt(e);
  }
  pointAtLength(e) {
    return this.curve.pointAtLength(e);
  }
  tangentAt(e) {
    return this.curve.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.curve.tangentAtLength(e);
  }
  isDifferentiable() {
    if (!this.previousSegment)
      return !1;
    const e = this.start, t = this.controlPoint1, i = this.controlPoint2, r = this.end;
    return !(e.equals(t) && t.equals(i) && i.equals(r));
  }
  scale(e, t, i) {
    return this.controlPoint1.scale(e, t, i), this.controlPoint2.scale(e, t, i), this.end.scale(e, t, i), this;
  }
  rotate(e, t) {
    return this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return this.start.equals(e.start) && this.end.equals(e.end) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2);
  }
  clone() {
    return new Br(this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.controlPoint1, t = this.controlPoint2, i = this.end;
    return [this.type, e.x, e.y, t.x, t.y, i.x, i.y].join(" ");
  }
}
(function(n) {
  function e(...t) {
    const i = t.length, r = t[0];
    if (yn.isCurve(r))
      return new n(r);
    if (z.isPointLike(r)) {
      if (i === 3)
        return new n(t[0], t[1], t[2]);
      const o = [];
      for (let a = 0; a < i; a += 3)
        o.push(new n(t[a], t[a + 1], t[a + 2]));
      return o;
    }
    if (i === 6)
      return new n(t[0], t[1], t[2], t[3], t[4], t[5]);
    const s = [];
    for (let o = 0; o < i; o += 6)
      s.push(new n(t[o], t[o + 1], t[o + 2], t[o + 3], t[o + 4], t[o + 5]));
    return s;
  }
  n.create = e;
})(Br || (Br = {}));
function mp(n, e, t) {
  return {
    x: n * Math.cos(t) - e * Math.sin(t),
    y: n * Math.sin(t) + e * Math.cos(t)
  };
}
function Qk(n, e, t, i, r, s) {
  const o = 0.3333333333333333, a = 2 / 3;
  return [
    o * n + a * t,
    o * e + a * i,
    o * r + a * t,
    o * s + a * i,
    r,
    s
  ];
}
function UM(n, e, t, i, r, s, o, a, l, c) {
  const u = Math.PI * 120 / 180, h = Math.PI / 180 * (+r || 0);
  let d = [], f, p, g, m, v;
  if (c)
    p = c[0], g = c[1], m = c[2], v = c[3];
  else {
    f = mp(n, e, -h), n = f.x, e = f.y, f = mp(a, l, -h), a = f.x, l = f.y;
    const I = (n - a) / 2, P = (e - l) / 2;
    let A = I * I / (t * t) + P * P / (i * i);
    A > 1 && (A = Math.sqrt(A), t = A * t, i = A * i);
    const N = t * t, q = i * i, j = (s === o ? -1 : 1) * Math.sqrt(Math.abs((N * q - N * P * P - q * I * I) / (N * P * P + q * I * I)));
    m = j * t * P / i + (n + a) / 2, v = j * -i * I / t + (e + l) / 2, p = Math.asin((e - v) / i), g = Math.asin((l - v) / i), p = n < m ? Math.PI - p : p, g = a < m ? Math.PI - g : g, p < 0 && (p = Math.PI * 2 + p), g < 0 && (g = Math.PI * 2 + g), o && p > g && (p -= Math.PI * 2), !o && g > p && (g -= Math.PI * 2);
  }
  let y = g - p;
  if (Math.abs(y) > u) {
    const I = g, P = a, A = l;
    g = p + u * (o && g > p ? 1 : -1), a = m + t * Math.cos(g), l = v + i * Math.sin(g), d = UM(a, l, t, i, r, 0, o, P, A, [
      g,
      I,
      m,
      v
    ]);
  }
  y = g - p;
  const b = Math.cos(p), w = Math.sin(p), x = Math.cos(g), S = Math.sin(g), C = Math.tan(y / 4), k = 4 / 3 * (t * C), E = 4 / 3 * (i * C), M = [n, e], _ = [n + k * w, e - E * b], T = [a + k * S, l - E * x], B = [a, l];
  if (_[0] = 2 * M[0] - _[0], _[1] = 2 * M[1] - _[1], c)
    return [_, T, B].concat(d);
  {
    d = [_, T, B].concat(d).join().split(",");
    const I = [], P = d.length;
    for (let A = 0; A < P; A += 1)
      I[A] = A % 2 ? mp(+d[A - 1], +d[A], h).y : mp(+d[A], +d[A + 1], h).x;
    return I;
  }
}
function pne(n) {
  if (!n)
    return null;
  const e = `	
\v\f\r   ᠎             　\u2028\u2029`, t = new RegExp(
    `([a-z])[${e},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${e}]*,?[${e}]*)+)`,
    // eslint-disable-line
    "ig"
  ), i = new RegExp(
    // eslint-disable-next-line
    `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${e}]*,?[${e}]*`,
    "ig"
  ), r = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  }, s = [];
  return n.replace(t, (o, a, l) => {
    const c = [];
    let u = a.toLowerCase();
    l.replace(i, (d, f) => (f && c.push(+f), d)), u === "m" && c.length > 2 && (s.push([a, ...c.splice(0, 2)]), u = "l", a = a === "m" ? "l" : "L");
    const h = r[u];
    for (; c.length >= h && (s.push([a, ...c.splice(0, h)]), !!h); )
      ;
    return o;
  }), s;
}
function gne(n) {
  const e = pne(n);
  if (!e || !e.length)
    return [["M", 0, 0]];
  let t = 0, i = 0, r = 0, s = 0;
  const o = [];
  for (let a = 0, l = e.length; a < l; a += 1) {
    const c = [];
    o.push(c);
    const u = e[a], h = u[0];
    if (h !== h.toUpperCase())
      switch (c[0] = h.toUpperCase(), c[0]) {
        case "A":
          c[1] = u[1], c[2] = u[2], c[3] = u[3], c[4] = u[4], c[5] = u[5], c[6] = +u[6] + t, c[7] = +u[7] + i;
          break;
        case "V":
          c[1] = +u[1] + i;
          break;
        case "H":
          c[1] = +u[1] + t;
          break;
        case "M":
          r = +u[1] + t, s = +u[2] + i;
          for (let d = 1, f = u.length; d < f; d += 1)
            c[d] = +u[d] + (d % 2 ? t : i);
          break;
        default:
          for (let d = 1, f = u.length; d < f; d += 1)
            c[d] = +u[d] + (d % 2 ? t : i);
          break;
      }
    else
      for (let d = 0, f = u.length; d < f; d += 1)
        c[d] = u[d];
    switch (c[0]) {
      case "Z":
        t = +r, i = +s;
        break;
      case "H":
        t = c[1];
        break;
      case "V":
        i = c[1];
        break;
      case "M":
        r = c[c.length - 2], s = c[c.length - 1], t = c[c.length - 2], i = c[c.length - 1];
        break;
      default:
        t = c[c.length - 2], i = c[c.length - 1];
        break;
    }
  }
  return o;
}
function mne(n) {
  const e = gne(n), t = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
  function i(l, c, u) {
    let h, d;
    if (!l)
      return ["C", c.x, c.y, c.x, c.y, c.x, c.y];
    switch (l[0] in { T: 1, Q: 1 } || (c.qx = null, c.qy = null), l[0]) {
      case "M":
        c.X = l[1], c.Y = l[2];
        break;
      case "A":
        return parseFloat(l[1]) === 0 || parseFloat(l[2]) === 0 ? ["L", l[6], l[7]] : ["C"].concat(UM.apply(0, [c.x, c.y].concat(l.slice(1))));
      case "S":
        return u === "C" || u === "S" ? (h = c.x * 2 - c.bx, d = c.y * 2 - c.by) : (h = c.x, d = c.y), ["C", h, d].concat(l.slice(1));
      case "T":
        return u === "Q" || u === "T" ? (c.qx = c.x * 2 - c.qx, c.qy = c.y * 2 - c.qy) : (c.qx = c.x, c.qy = c.y), ["C"].concat(Qk(c.x, c.y, c.qx, c.qy, l[1], l[2]));
      case "Q":
        return c.qx = l[1], c.qy = l[2], ["C"].concat(Qk(c.x, c.y, l[1], l[2], l[3], l[4]));
      case "H":
        return ["L"].concat(l[1], c.y);
      case "V":
        return ["L"].concat(c.x, l[1]);
    }
    return l;
  }
  function r(l, c) {
    if (l[c].length > 7) {
      l[c].shift();
      const u = l[c];
      for (; u.length; )
        s[c] = "A", c += 1, l.splice(c, 0, ["C"].concat(u.splice(0, 6)));
      l.splice(c, 1), a = e.length;
    }
  }
  const s = [];
  let o = "", a = e.length;
  for (let l = 0; l < a; l += 1) {
    let c = "";
    e[l] && (c = e[l][0]), c !== "C" && (s[l] = c, l > 0 && (o = s[l - 1])), e[l] = i(e[l], t, o), s[l] !== "A" && c === "C" && (s[l] = "C"), r(e, l);
    const u = e[l], h = u.length;
    t.x = u[h - 2], t.y = u[h - 1], t.bx = parseFloat(u[h - 4]) || t.x, t.by = parseFloat(u[h - 3]) || t.y;
  }
  return (!e[0][0] || e[0][0] !== "M") && e.unshift(["M", 0, 0]), e;
}
function vne(n) {
  return mne(n).map((e) => e.map((t) => typeof t == "string" ? t : At.round(t, 2))).join(",").split(",").join(" ");
}
class Be extends el {
  constructor(e) {
    if (super(), this.PRECISION = 3, this.segments = [], Array.isArray(e))
      if (Ie.isLine(e[0]) || yn.isCurve(e[0])) {
        let t = null;
        e.forEach((r, s) => {
          s === 0 && this.appendSegment(Be.createSegment("M", r.start)), t != null && !t.end.equals(r.start) && this.appendSegment(Be.createSegment("M", r.start)), Ie.isLine(r) ? this.appendSegment(Be.createSegment("L", r.end)) : yn.isCurve(r) && this.appendSegment(Be.createSegment("C", r.controlPoint1, r.controlPoint2, r.end)), t = r;
        });
      } else
        e.forEach((i) => {
          i.isSegment && this.appendSegment(i);
        });
    else
      e != null && (Ie.isLine(e) ? (this.appendSegment(Be.createSegment("M", e.start)), this.appendSegment(Be.createSegment("L", e.end))) : yn.isCurve(e) ? (this.appendSegment(Be.createSegment("M", e.start)), this.appendSegment(Be.createSegment("C", e.controlPoint1, e.controlPoint2, e.end))) : En.isPolyline(e) ? e.points && e.points.length && e.points.forEach((t, i) => {
        const r = i === 0 ? Be.createSegment("M", t) : Be.createSegment("L", t);
        this.appendSegment(r);
      }) : e.isSegment && this.appendSegment(e));
  }
  get start() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let i = 0; i < t; i += 1) {
      const r = e[i];
      if (r.isVisible)
        return r.start;
    }
    return e[t - 1].end;
  }
  get end() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let i = t - 1; i >= 0; i -= 1) {
      const r = e[i];
      if (r.isVisible)
        return r.end;
    }
    return e[t - 1].end;
  }
  moveTo(...e) {
    return this.appendSegment($u.create.call(null, ...e));
  }
  lineTo(...e) {
    return this.appendSegment(Mi.create.call(null, ...e));
  }
  curveTo(...e) {
    return this.appendSegment(Br.create.call(null, ...e));
  }
  arcTo(e, t, i, r, s, o, a) {
    const l = this.end || new z(), c = typeof o == "number" ? lm(l.x, l.y, e, t, i, r, s, o, a) : lm(l.x, l.y, e, t, i, r, s, o.x, o.y);
    if (c != null)
      for (let u = 0, h = c.length; u < h; u += 6)
        this.curveTo(c[u], c[u + 1], c[u + 2], c[u + 3], c[u + 4], c[u + 5]);
    return this;
  }
  quadTo(e, t, i, r) {
    const s = this.end || new z(), o = ["M", s.x, s.y];
    if (typeof e == "number")
      o.push("Q", e, t, i, r);
    else {
      const l = t;
      o.push("Q", e.x, e.y, l.x, l.y);
    }
    const a = Be.parse(o.join(" "));
    return this.appendSegment(a.segments.slice(1)), this;
  }
  close() {
    return this.appendSegment(Au.create());
  }
  drawPoints(e, t = {}) {
    const i = YM(e, t), r = Be.parse(i);
    r && r.segments && this.appendSegment(r.segments);
  }
  bbox() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    let i;
    for (let s = 0; s < t; s += 1) {
      const o = e[s];
      if (o.isVisible) {
        const a = o.bbox();
        a != null && (i = i ? i.union(a) : a);
      }
    }
    if (i != null)
      return i;
    const r = e[t - 1];
    return new ye(r.end.x, r.end.y, 0, 0);
  }
  appendSegment(e) {
    const t = this.segments.length;
    let i = t !== 0 ? this.segments[t - 1] : null, r;
    const s = null;
    if (Array.isArray(e))
      for (let o = 0, a = e.length; o < a; o += 1) {
        const l = e[o];
        r = this.prepareSegment(l, i, s), this.segments.push(r), i = r;
      }
    else
      e != null && e.isSegment && (r = this.prepareSegment(e, i, s), this.segments.push(r));
    return this;
  }
  insertSegment(e, t) {
    const i = this.segments.length;
    if (e < 0 && (e = i + e + 1), e > i || e < 0)
      throw new Error("Index out of range.");
    let r, s = null, o = null;
    if (i !== 0 && (e >= 1 ? (s = this.segments[e - 1], o = s.nextSegment) : (s = null, o = this.segments[0])), !Array.isArray(t))
      r = this.prepareSegment(t, s, o), this.segments.splice(e, 0, r);
    else
      for (let a = 0, l = t.length; a < l; a += 1) {
        const c = t[a];
        r = this.prepareSegment(c, s, o), this.segments.splice(e + a, 0, r), s = r;
      }
    return this;
  }
  removeSegment(e) {
    const t = this.fixIndex(e), i = this.segments.splice(t, 1)[0], r = i.previousSegment, s = i.nextSegment;
    return r && (r.nextSegment = s), s && (s.previousSegment = r), i.isSubpathStart && s && this.updateSubpathStartSegment(s), i;
  }
  replaceSegment(e, t) {
    const i = this.fixIndex(e);
    let r;
    const s = this.segments[i];
    let o = s.previousSegment;
    const a = s.nextSegment;
    let l = s.isSubpathStart;
    if (!Array.isArray(t))
      r = this.prepareSegment(t, o, a), this.segments.splice(i, 1, r), l && r.isSubpathStart && (l = !1);
    else {
      this.segments.splice(e, 1);
      for (let c = 0, u = t.length; c < u; c += 1) {
        const h = t[c];
        r = this.prepareSegment(h, o, a), this.segments.splice(e + c, 0, r), o = r, l && r.isSubpathStart && (l = !1);
      }
    }
    l && a && this.updateSubpathStartSegment(a);
  }
  getSegment(e) {
    const t = this.fixIndex(e);
    return this.segments[t];
  }
  fixIndex(e) {
    const t = this.segments.length;
    if (t === 0)
      throw new Error("Path has no segments.");
    let i = e;
    for (; i < 0; )
      i = t + i;
    if (i >= t || i < 0)
      throw new Error("Index out of range.");
    return i;
  }
  segmentAt(e, t = {}) {
    const i = this.segmentIndexAt(e, t);
    return i ? this.getSegment(i) : null;
  }
  segmentAtLength(e, t = {}) {
    const i = this.segmentIndexAtLength(e, t);
    return i ? this.getSegment(i) : null;
  }
  segmentIndexAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const i = At.clamp(e, 0, 1), r = this.getOptions(t), o = this.length(r) * i;
    return this.segmentIndexAtLength(o, r);
  }
  segmentIndexAtLength(e, t = {}) {
    const i = this.segments.length;
    if (i === 0)
      return null;
    let r = !0;
    e < 0 && (r = !1, e = -e);
    const s = this.getPrecision(t), o = this.getSubdivisions(t);
    let a = 0, l = null;
    for (let c = 0; c < i; c += 1) {
      const u = r ? c : i - 1 - c, h = this.segments[u], d = o[u], f = h.length({ precision: s, subdivisions: d });
      if (h.isVisible) {
        if (e <= a + f)
          return u;
        l = u;
      }
      a += f;
    }
    return l;
  }
  getSegmentSubdivisions(e = {}) {
    const t = this.getPrecision(e), i = [];
    for (let r = 0, s = this.segments.length; r < s; r += 1) {
      const a = this.segments[r].getSubdivisions({ precision: t });
      i.push(a);
    }
    return i;
  }
  updateSubpathStartSegment(e) {
    let t = e.previousSegment, i = e;
    for (; i && !i.isSubpathStart; )
      t != null ? i.subpathStartSegment = t.subpathStartSegment : i.subpathStartSegment = null, t = i, i = i.nextSegment;
  }
  prepareSegment(e, t, i) {
    e.previousSegment = t, e.nextSegment = i, t != null && (t.nextSegment = e), i != null && (i.previousSegment = e);
    let r = e;
    return e.isSubpathStart && (e.subpathStartSegment = e, r = i), r != null && this.updateSubpathStartSegment(r), e;
  }
  closestPoint(e, t = {}) {
    const i = this.closestPointT(e, t);
    return i ? this.pointAtT(i) : null;
  }
  closestPointLength(e, t = {}) {
    const i = this.getOptions(t), r = this.closestPointT(e, i);
    return r ? this.lengthAtT(r, i) : 0;
  }
  closestPointNormalizedLength(e, t = {}) {
    const i = this.getOptions(t), r = this.closestPointLength(e, i);
    if (r === 0)
      return 0;
    const s = this.length(i);
    return s === 0 ? 0 : r / s;
  }
  closestPointT(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let s, o = 1 / 0;
    for (let a = 0, l = this.segments.length; a < l; a += 1) {
      const c = this.segments[a], u = r[a];
      if (c.isVisible) {
        const h = c.closestPointT(e, {
          precision: i,
          subdivisions: u
        }), d = c.pointAtT(h), f = At.squaredLength(d, e);
        f < o && (s = { segmentIndex: a, value: h }, o = f);
      }
    }
    return s || { segmentIndex: this.segments.length - 1, value: 1 };
  }
  closestPointTangent(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let s, o = 1 / 0;
    for (let a = 0, l = this.segments.length; a < l; a += 1) {
      const c = this.segments[a], u = r[a];
      if (c.isDifferentiable()) {
        const h = c.closestPointT(e, {
          precision: i,
          subdivisions: u
        }), d = c.pointAtT(h), f = At.squaredLength(d, e);
        f < o && (s = c.tangentAtT(h), o = f);
      }
    }
    return s || null;
  }
  containsPoint(e, t = {}) {
    const i = this.toPolylines(t);
    if (!i)
      return !1;
    let r = 0;
    for (let s = 0, o = i.length; s < o; s += 1)
      i[s].containsPoint(e) && (r += 1);
    return r % 2 === 1;
  }
  pointAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const i = this.getOptions(t), s = this.length(i) * e;
    return this.pointAtLength(s, i);
  }
  pointAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e === 0)
      return this.start.clone();
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.getPrecision(t), s = this.getSubdivisions(t);
    let o, a = 0;
    for (let c = 0, u = this.segments.length; c < u; c += 1) {
      const h = i ? c : u - 1 - c, d = this.segments[h], f = s[h], p = d.length({
        precision: r,
        subdivisions: f
      });
      if (d.isVisible) {
        if (e <= a + p)
          return d.pointAtLength((i ? 1 : -1) * (e - a), {
            precision: r,
            subdivisions: f
          });
        o = d;
      }
      a += p;
    }
    return o ? i ? o.end : o.start : this.segments[this.segments.length - 1].end.clone();
  }
  pointAtT(e) {
    const t = this.segments, i = t.length;
    if (i === 0)
      return null;
    const r = e.segmentIndex;
    if (r < 0)
      return t[0].pointAtT(0);
    if (r >= i)
      return t[i - 1].pointAtT(1);
    const s = At.clamp(e.value, 0, 1);
    return t[r].pointAtT(s);
  }
  divideAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const i = At.clamp(e, 0, 1), r = this.getOptions(t), o = this.length(r) * i;
    return this.divideAtLength(o, r);
  }
  divideAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.getPrecision(t), s = this.getSubdivisions(t);
    let o = 0, a, l, c, u, h;
    for (let x = 0, S = this.segments.length; x < S; x += 1) {
      const C = i ? x : S - 1 - x, k = this.getSegment(C), E = s[C], M = { precision: r, subdivisions: E }, _ = k.length(M);
      if (k.isDifferentiable() && (c = k, u = C, e <= o + _)) {
        l = C, a = k.divideAtLength((i ? 1 : -1) * (e - o), M);
        break;
      }
      o += _;
    }
    if (!c)
      return null;
    a || (l = u, h = i ? 1 : 0, a = c.divideAtT(h));
    const d = this.clone(), f = l;
    d.replaceSegment(f, a);
    const p = f;
    let g = f + 1, m = f + 2;
    a[0].isDifferentiable() || (d.removeSegment(p), g -= 1, m -= 1);
    const v = d.getSegment(g).start;
    d.insertSegment(g, Be.createSegment("M", v)), m += 1, a[1].isDifferentiable() || (d.removeSegment(m - 1), m -= 1);
    const y = m - p - 1;
    for (let x = m, S = d.segments.length; x < S; x += 1) {
      const C = this.getSegment(x - y), k = d.getSegment(x);
      if (k.type === "Z" && !C.subpathStartSegment.end.equals(k.subpathStartSegment.end)) {
        const E = Be.createSegment("L", C.end);
        d.replaceSegment(x, E);
      }
    }
    const b = new Be(d.segments.slice(0, g)), w = new Be(d.segments.slice(g));
    return [b, w];
  }
  intersectsWithLine(e, t = {}) {
    const i = this.toPolylines(t);
    if (i == null)
      return null;
    let r = null;
    for (let s = 0, o = i.length; s < o; s += 1) {
      const a = i[s], l = e.intersect(a);
      l && (r == null && (r = []), Array.isArray(l) ? r.push(...l) : r.push(l));
    }
    return r;
  }
  isDifferentiable() {
    for (let e = 0, t = this.segments.length; e < t; e += 1)
      if (this.segments[e].isDifferentiable())
        return !0;
    return !1;
  }
  isValid() {
    const e = this.segments;
    return e.length === 0 || e[0].type === "M";
  }
  length(e = {}) {
    if (this.segments.length === 0)
      return 0;
    const t = this.getSubdivisions(e);
    let i = 0;
    for (let r = 0, s = this.segments.length; r < s; r += 1) {
      const o = this.segments[r], a = t[r];
      i += o.length({ subdivisions: a });
    }
    return i;
  }
  lengthAtT(e, t = {}) {
    const i = this.segments.length;
    if (i === 0)
      return 0;
    let r = e.segmentIndex;
    if (r < 0)
      return 0;
    let s = At.clamp(e.value, 0, 1);
    r >= i && (r = i - 1, s = 1);
    const o = this.getPrecision(t), a = this.getSubdivisions(t);
    let l = 0;
    for (let h = 0; h < r; h += 1) {
      const d = this.segments[h], f = a[h];
      l += d.length({ precision: o, subdivisions: f });
    }
    const c = this.segments[r], u = a[r];
    return l += c.lengthAtT(s, { precision: o, subdivisions: u }), l;
  }
  tangentAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const i = At.clamp(e, 0, 1), r = this.getOptions(t), o = this.length(r) * i;
    return this.tangentAtLength(o, r);
  }
  tangentAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.getPrecision(t), s = this.getSubdivisions(t);
    let o, a = 0;
    for (let l = 0, c = this.segments.length; l < c; l += 1) {
      const u = i ? l : c - 1 - l, h = this.segments[u], d = s[u], f = h.length({ precision: r, subdivisions: d });
      if (h.isDifferentiable()) {
        if (e <= a + f)
          return h.tangentAtLength((i ? 1 : -1) * (e - a), {
            precision: r,
            subdivisions: d
          });
        o = h;
      }
      a += f;
    }
    if (o) {
      const l = i ? 1 : 0;
      return o.tangentAtT(l);
    }
    return null;
  }
  tangentAtT(e) {
    const t = this.segments.length;
    if (t === 0)
      return null;
    const i = e.segmentIndex;
    if (i < 0)
      return this.segments[0].tangentAtT(0);
    if (i >= t)
      return this.segments[t - 1].tangentAtT(1);
    const r = At.clamp(e.value, 0, 1);
    return this.segments[i].tangentAtT(r);
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getSubdivisions(e = {}) {
    if (e.segmentSubdivisions == null) {
      const t = this.getPrecision(e);
      return this.getSegmentSubdivisions({ precision: t });
    }
    return e.segmentSubdivisions;
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), i = this.getSubdivisions(e);
    return { precision: t, segmentSubdivisions: i };
  }
  toPoints(e = {}) {
    const t = this.segments, i = t.length;
    if (i === 0)
      return null;
    const r = this.getSubdivisions(e), s = [];
    let o = [];
    for (let a = 0; a < i; a += 1) {
      const l = t[a];
      if (l.isVisible) {
        const c = r[a];
        c.length > 0 ? c.forEach((u) => o.push(u.start)) : o.push(l.start);
      } else
        o.length > 0 && (o.push(t[a - 1].end), s.push(o), o = []);
    }
    return o.length > 0 && (o.push(this.end), s.push(o)), s;
  }
  toPolylines(e = {}) {
    const t = this.toPoints(e);
    return t ? t.map((i) => new En(i)) : null;
  }
  scale(e, t, i) {
    return this.segments.forEach((r) => r.scale(e, t, i)), this;
  }
  rotate(e, t) {
    return this.segments.forEach((i) => i.rotate(e, t)), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.segments.forEach((i) => i.translate(e, t)) : this.segments.forEach((i) => i.translate(e)), this;
  }
  clone() {
    const e = new Be();
    return this.segments.forEach((t) => e.appendSegment(t.clone())), e;
  }
  equals(e) {
    if (e == null)
      return !1;
    const t = this.segments, i = e.segments, r = t.length;
    if (i.length !== r)
      return !1;
    for (let s = 0; s < r; s += 1) {
      const o = t[s], a = i[s];
      if (o.type !== a.type || !o.equals(a))
        return !1;
    }
    return !0;
  }
  toJSON() {
    return this.segments.map((e) => e.toJSON());
  }
  serialize() {
    if (!this.isValid())
      throw new Error("Invalid path segments.");
    return this.segments.map((e) => e.serialize()).join(" ");
  }
  toString() {
    return this.serialize();
  }
}
(function(n) {
  function e(t) {
    return t != null && t instanceof n;
  }
  n.isPath = e;
})(Be || (Be = {}));
(function(n) {
  function e(i) {
    if (!i)
      return new n();
    const r = new n(), s = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g, o = n.normalize(i).match(s);
    if (o != null)
      for (let a = 0, l = o.length; a < l; a += 1) {
        const c = o[a], u = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g, h = c.match(u);
        if (h != null) {
          const d = h[0], f = h.slice(1).map((g) => +g), p = t.call(null, d, ...f);
          r.appendSegment(p);
        }
      }
    return r;
  }
  n.parse = e;
  function t(i, ...r) {
    if (i === "M")
      return $u.create.call(null, ...r);
    if (i === "L")
      return Mi.create.call(null, ...r);
    if (i === "C")
      return Br.create.call(null, ...r);
    if (i === "z" || i === "Z")
      return Au.create();
    throw new Error(`Invalid path segment type "${i}"`);
  }
  n.createSegment = t;
})(Be || (Be = {}));
(function(n) {
  n.normalize = vne, n.isValid = hne, n.drawArc = fne, n.drawPoints = YM, n.arcToCurves = lm;
})(Be || (Be = {}));
class $n {
  constructor(e) {
    this.options = Object.assign({}, e), this.data = this.options.data || {}, this.register = this.register.bind(this), this.unregister = this.unregister.bind(this);
  }
  get names() {
    return Object.keys(this.data);
  }
  register(e, t, i = !1) {
    if (typeof e == "object") {
      Object.entries(e).forEach(([o, a]) => {
        this.register(o, a, t);
      });
      return;
    }
    this.exist(e) && !i && !La.isApplyingHMR() && this.onDuplicated(e);
    const r = this.options.process, s = r ? Ze(r, this, e, t) : t;
    return this.data[e] = s, s;
  }
  unregister(e) {
    const t = e ? this.data[e] : null;
    return delete this.data[e], t;
  }
  get(e) {
    return e ? this.data[e] : null;
  }
  exist(e) {
    return e ? this.data[e] != null : !1;
  }
  onDuplicated(e) {
    try {
      throw this.options.onConflict && Ze(this.options.onConflict, this, e), new Error(`${qg(this.options.type)} with name '${e}' already registered.`);
    } catch (t) {
      throw t;
    }
  }
  onNotFound(e, t) {
    throw new Error(this.getSpellingSuggestion(e, t));
  }
  getSpellingSuggestion(e, t) {
    const i = this.getSpellingSuggestionForName(e), r = t ? `${t} ${Bz(this.options.type)}` : this.options.type;
    return (
      // eslint-disable-next-line
      `${qg(r)} with name '${e}' does not exist.${i ? ` Did you mean '${i}'?` : ""}`
    );
  }
  getSpellingSuggestionForName(e) {
    return vte(e, Object.keys(this.data), (t) => t);
  }
}
(function(n) {
  function e(t) {
    return new n(t);
  }
  n.create = e;
})($n || ($n = {}));
const bne = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(n, e) {
    const t = e.thickness * e.sx, i = e.thickness * e.sy;
    St(n, {
      width: t,
      height: i,
      rx: t,
      ry: i,
      fill: e.color
    });
  }
}, yne = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(n, e) {
    const t = e.sx <= 1 ? e.thickness * e.sx : e.thickness;
    St(n, {
      width: t,
      height: t,
      rx: t,
      ry: t,
      fill: e.color
    });
  }
}, One = {
  color: "rgba(224,224,224,1)",
  thickness: 1,
  markup: "path",
  update(n, e) {
    let t;
    const i = e.width, r = e.height, s = e.thickness;
    i - s >= 0 && r - s >= 0 ? t = ["M", i, 0, "H0 M0 0 V0", r].join(" ") : t = "M 0 0 0 0", St(n, {
      d: t,
      stroke: e.color,
      "stroke-width": e.thickness
    });
  }
}, wne = [
  {
    color: "rgba(224,224,224,1)",
    thickness: 1,
    markup: "path",
    update(n, e) {
      let t;
      const i = e.width, r = e.height, s = e.thickness;
      i - s >= 0 && r - s >= 0 ? t = ["M", i, 0, "H0 M0 0 V0", r].join(" ") : t = "M 0 0 0 0", St(n, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  },
  {
    color: "rgba(224,224,224,0.2)",
    thickness: 3,
    factor: 4,
    markup: "path",
    update(n, e) {
      let t;
      const i = e.factor || 1, r = e.width * i, s = e.height * i, o = e.thickness;
      r - o >= 0 && s - o >= 0 ? t = ["M", r, 0, "H0 M0 0 V0", s].join(" ") : t = "M 0 0 0 0", e.width = r, e.height = s, St(n, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  }
], xne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dot: bne,
  doubleMesh: wne,
  fixedDot: yne,
  mesh: One
}, Symbol.toStringTag, { value: "Module" }));
class ka {
  constructor() {
    this.patterns = {}, this.root = Je.create(rm(), {
      width: "100%",
      height: "100%"
    }, [Ts("defs")]).node;
  }
  add(e, t) {
    const i = this.root.childNodes[0];
    i && i.appendChild(t), this.patterns[e] = t, Je.create("rect", {
      width: "100%",
      height: "100%",
      fill: `url(#${e})`
    }).appendTo(this.root);
  }
  get(e) {
    return this.patterns[e];
  }
  has(e) {
    return this.patterns[e] != null;
  }
}
(function(n) {
  n.presets = xne, n.registry = $n.create({
    type: "grid"
  }), n.registry.register(n.presets, !0);
})(ka || (ka = {}));
const GM = function(n) {
  const e = document.createElement("canvas"), t = n.width, i = n.height;
  e.width = t * 2, e.height = i;
  const r = e.getContext("2d");
  return r.drawImage(n, 0, 0, t, i), r.translate(2 * t, 0), r.scale(-1, 1), r.drawImage(n, 0, 0, t, i), e;
}, KM = function(n) {
  const e = document.createElement("canvas"), t = n.width, i = n.height;
  e.width = t, e.height = i * 2;
  const r = e.getContext("2d");
  return r.drawImage(n, 0, 0, t, i), r.translate(0, 2 * i), r.scale(1, -1), r.drawImage(n, 0, 0, t, i), e;
}, JM = function(n) {
  const e = document.createElement("canvas"), t = n.width, i = n.height;
  e.width = 2 * t, e.height = 2 * i;
  const r = e.getContext("2d");
  return r.drawImage(n, 0, 0, t, i), r.setTransform(-1, 0, 0, -1, e.width, e.height), r.drawImage(n, 0, 0, t, i), r.setTransform(-1, 0, 0, 1, e.width, 0), r.drawImage(n, 0, 0, t, i), r.setTransform(1, 0, 0, -1, 0, e.height), r.drawImage(n, 0, 0, t, i), e;
}, Sne = function(n, e) {
  const t = n.width, i = n.height, r = document.createElement("canvas");
  r.width = t * 3, r.height = i * 3;
  const s = r.getContext("2d"), o = e.angle != null ? -e.angle : -20, a = Pt.toRad(o), l = r.width / 4, c = r.height / 4;
  for (let u = 0; u < 4; u += 1)
    for (let h = 0; h < 4; h += 1)
      (u + h) % 2 > 0 && (s.setTransform(1, 0, 0, 1, (2 * u - 1) * l, (2 * h - 1) * c), s.rotate(a), s.drawImage(n, -t / 2, -i / 2, t, i));
  return r;
}, Cne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  flipX: GM,
  flipXY: JM,
  flipY: KM,
  watermark: Sne
}, Symbol.toStringTag, { value: "Module" }));
var qd;
(function(n) {
  n.presets = Object.assign({}, Cne), n.presets["flip-x"] = GM, n.presets["flip-y"] = KM, n.presets["flip-xy"] = JM, n.registry = $n.create({
    type: "background pattern"
  }), n.registry.register(n.presets, !0);
})(qd || (qd = {}));
function Hw(n, e) {
  return n ?? e;
}
function oi(n, e) {
  return n != null && Number.isFinite(n) ? n : e;
}
function kne(n = {}) {
  const e = Hw(n.color, "blue"), t = oi(n.width, 1), i = oi(n.margin, 2), r = oi(n.opacity, 1), s = i, o = i + t;
  return `
    <filter>
      <feFlood flood-color="${e}" flood-opacity="${r}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${o}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${s}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}
function Pne(n = {}) {
  const e = Hw(n.color, "red"), t = oi(n.blur, 0), i = oi(n.width, 1), r = oi(n.opacity, 1);
  return `
      <filter>
        <feFlood flood-color="${e}" flood-opacity="${r}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${i}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${t}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}
function Ene(n = {}) {
  const e = oi(n.x, 2);
  return `
    <filter>
      <feGaussianBlur stdDeviation="${n.y != null && Number.isFinite(n.y) ? [e, n.y] : e}"/>
    </filter>
  `.trim();
}
function Ane(n = {}) {
  const e = oi(n.dx, 0), t = oi(n.dy, 0), i = Hw(n.color, "black"), r = oi(n.blur, 4), s = oi(n.opacity, 1);
  return "SVGFEDropShadowElement" in window ? `<filter>
         <feDropShadow stdDeviation="${r}" dx="${e}" dy="${t}" flood-color="${i}" flood-opacity="${s}" />
       </filter>`.trim() : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${r}" />
         <feOffset dx="${e}" dy="${t}" result="offsetblur" />
         <feFlood flood-color="${i}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${s}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}
function $ne(n = {}) {
  const e = oi(n.amount, 1), t = 0.2126 + 0.7874 * (1 - e), i = 0.7152 - 0.7152 * (1 - e), r = 0.0722 - 0.0722 * (1 - e), s = 0.2126 - 0.2126 * (1 - e), o = 0.7152 + 0.2848 * (1 - e), a = 0.0722 - 0.0722 * (1 - e), l = 0.2126 - 0.2126 * (1 - e), c = 0.0722 + 0.9278 * (1 - e);
  return `
    <filter>
      <feColorMatrix type="matrix" values="${t} ${i} ${r} 0 0 ${s} ${o} ${a} 0 0 ${l} ${i} ${c} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}
function Tne(n = {}) {
  const e = oi(n.amount, 1), t = 0.393 + 0.607 * (1 - e), i = 0.769 - 0.769 * (1 - e), r = 0.189 - 0.189 * (1 - e), s = 0.349 - 0.349 * (1 - e), o = 0.686 + 0.314 * (1 - e), a = 0.168 - 0.168 * (1 - e), l = 0.272 - 0.272 * (1 - e), c = 0.534 - 0.534 * (1 - e), u = 0.131 + 0.869 * (1 - e);
  return `
      <filter>
        <feColorMatrix type="matrix" values="${t} ${i} ${r} 0 0 ${s} ${o} ${a} 0 0 ${l} ${c} ${u} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}
function _ne(n = {}) {
  return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - oi(n.amount, 1)}"/>
      </filter>
    `.trim();
}
function Mne(n = {}) {
  return `
      <filter>
        <feColorMatrix type="hueRotate" values="${oi(n.angle, 0)}"/>
      </filter>
    `.trim();
}
function Rne(n = {}) {
  const e = oi(n.amount, 1), t = 1 - e;
  return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${e} ${t}"/>
          <feFuncG type="table" tableValues="${e} ${t}"/>
          <feFuncB type="table" tableValues="${e} ${t}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}
function Nne(n = {}) {
  const e = oi(n.amount, 1);
  return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${e}"/>
        <feFuncG type="linear" slope="${e}"/>
        <feFuncB type="linear" slope="${e}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}
function Dne(n = {}) {
  const e = oi(n.amount, 1), t = 0.5 - e / 2;
  return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${e}" intercept="${t}"/>
        <feFuncG type="linear" slope="${e}" intercept="${t}"/>
        <feFuncB type="linear" slope="${e}" intercept="${t}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}
const Lne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  blur: Ene,
  brightness: Nne,
  contrast: Dne,
  dropShadow: Ane,
  grayScale: $ne,
  highlight: Pne,
  hueRotate: Mne,
  invert: Rne,
  outline: kne,
  saturate: _ne,
  sepia: Tne
}, Symbol.toStringTag, { value: "Module" }));
var Tu;
(function(n) {
  n.presets = Lne, n.registry = $n.create({
    type: "filter"
  }), n.registry.register(n.presets, !0);
})(Tu || (Tu = {}));
const Ine = {
  xlinkHref: "xlink:href",
  xlinkShow: "xlink:show",
  xlinkRole: "xlink:role",
  xlinkType: "xlink:type",
  xlinkArcrole: "xlink:arcrole",
  xlinkTitle: "xlink:title",
  xlinkActuate: "xlink:actuate",
  xmlSpace: "xml:space",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  preserveAspectRatio: "preserveAspectRatio",
  requiredExtension: "requiredExtension",
  requiredFeatures: "requiredFeatures",
  systemLanguage: "systemLanguage",
  externalResourcesRequired: "externalResourceRequired"
}, Bne = {
  // We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
}, eR = {
  position: Av("x", "width", "origin")
}, tR = {
  position: Av("y", "height", "origin")
}, Qne = {
  position: Av("x", "width", "corner")
}, zne = {
  position: Av("y", "height", "corner")
}, nR = {
  set: Qa("width", "width")
}, iR = {
  set: Qa("height", "height")
}, jne = {
  set: Qa("rx", "width")
}, Vne = {
  set: Qa("ry", "height")
}, rR = {
  set: ((n) => {
    const e = Qa(n, "width"), t = Qa(n, "height");
    return function(i, r) {
      const s = r.refBBox, o = s.height > s.width ? e : t;
      return Ze(o, this, i, r);
    };
  })("r")
}, Fne = {
  set(n, { refBBox: e }) {
    let t = parseFloat(n);
    const i = qo(n);
    i && (t /= 100);
    const r = Math.sqrt(e.height * e.height + e.width * e.width);
    let s;
    return Number.isFinite(t) && (i || t >= 0 && t <= 1 ? s = t * r : s = Math.max(t + r, 0)), { r: s };
  }
}, Zne = {
  set: Qa("cx", "width")
}, qne = {
  set: Qa("cy", "height")
}, sR = {
  set: lR({ resetOffset: !0 })
}, Wne = {
  set: lR({ resetOffset: !1 })
}, oR = {
  set: cR({ resetOffset: !0 })
}, Hne = {
  set: cR({ resetOffset: !1 })
}, Xne = rR, Yne = sR, Une = oR, Gne = eR, Kne = tR, Jne = nR, eie = iR;
function Av(n, e, t) {
  return (i, { refBBox: r }) => {
    if (i == null)
      return null;
    let s = parseFloat(i);
    const o = qo(i);
    o && (s /= 100);
    let a;
    if (Number.isFinite(s)) {
      const c = r[t];
      o || s > 0 && s < 1 ? a = c[n] + r[e] * s : a = c[n] + s;
    }
    const l = new z();
    return l[n] = a || 0, l;
  };
}
function Qa(n, e) {
  return function(t, { refBBox: i }) {
    let r = parseFloat(t);
    const s = qo(t);
    s && (r /= 100);
    const o = {};
    if (Number.isFinite(r)) {
      const a = s || r >= 0 && r <= 1 ? r * i[e] : Math.max(r + i[e], 0);
      o[n] = a;
    }
    return o;
  };
}
function aR(n, e) {
  const t = "x6-shape", i = e && e.resetOffset;
  return function(r, { elem: s, refBBox: o }) {
    let a = Yl(s, t);
    if (!a || a.value !== r) {
      const g = n(r);
      a = {
        value: r,
        shape: g,
        shapeBBox: g.bbox()
      }, Yl(s, t, a);
    }
    const l = a.shape.clone(), c = a.shapeBBox.clone(), u = c.getOrigin(), h = o.getOrigin();
    c.x = h.x, c.y = h.y;
    const d = o.getMaxScaleToFit(c, h), f = c.width === 0 || o.width === 0 ? 1 : d.sx, p = c.height === 0 || o.height === 0 ? 1 : d.sy;
    return l.scale(f, p, u), i && l.translate(-u.x, -u.y), l;
  };
}
function lR(n) {
  function e(i) {
    return Be.parse(i);
  }
  const t = aR(e, n);
  return (i, r) => ({
    d: t(i, r).serialize()
  });
}
function cR(n) {
  const e = aR((t) => new En(t), n);
  return (t, i) => ({
    points: e(t, i).serialize()
  });
}
const tie = {
  qualify: Ps,
  set(n, { view: e }) {
    return `url(#${e.graph.defineGradient(n)})`;
  }
}, nie = {
  qualify: Ps,
  set(n, { view: e }) {
    const t = e.cell, i = Object.assign({}, n);
    if (t.isEdge() && i.type === "linearGradient") {
      const r = e, s = r.sourcePoint, o = r.targetPoint;
      i.id = `gradient-${i.type}-${t.id}`, i.attrs = Object.assign(Object.assign({}, i.attrs), { x1: s.x, y1: s.y, x2: o.x, y2: o.y, gradientUnits: "userSpaceOnUse" }), e.graph.defs.remove(i.id);
    }
    return `url(#${e.graph.defineGradient(i)})`;
  }
}, uR = {
  qualify(n, { attrs: e }) {
    return e.textWrap == null || !Ps(e.textWrap);
  },
  set(n, { view: e, elem: t, attrs: i }) {
    const r = "x6-text", s = Yl(t, r), o = (u) => {
      try {
        return JSON.parse(u);
      } catch {
        return u;
      }
    }, a = {
      x: i.x,
      eol: i.eol,
      annotations: o(i.annotations),
      textPath: o(i["text-path"] || i.textPath),
      textVerticalAnchor: i["text-vertical-anchor"] || i.textVerticalAnchor,
      displayEmpty: (i["display-empty"] || i.displayEmpty) === "true",
      lineHeight: i["line-height"] || i.lineHeight
    }, l = i["font-size"] || i.fontSize, c = JSON.stringify([n, a]);
    if (l && t.setAttribute("font-size", l), s == null || s !== c) {
      const u = a.textPath;
      if (u != null && typeof u == "object") {
        const h = u.selector;
        if (typeof h == "string") {
          const d = e.find(h)[0];
          d instanceof SVGPathElement && (jw(d), a.textPath = Object.assign({ "xlink:href": `#${d.id}` }, u));
        }
      }
      jM(t, `${n}`, a), Yl(t, r, c);
    }
  }
}, iie = {
  qualify: Ps,
  set(n, { view: e, elem: t, attrs: i, refBBox: r }) {
    const s = n, o = s.width || 0;
    qo(o) ? r.width *= parseFloat(o) / 100 : o <= 0 ? r.width += o : r.width = o;
    const a = s.height || 0;
    qo(a) ? r.height *= parseFloat(a) / 100 : a <= 0 ? r.height += a : r.height = a;
    let l, c = s.text;
    c == null && (c = i.text || (t == null ? void 0 : t.textContent)), c != null ? l = VM(`${c}`, r, {
      "font-weight": i["font-weight"] || i.fontWeight,
      "font-size": i["font-size"] || i.fontSize,
      "font-family": i["font-family"] || i.fontFamily,
      lineHeight: i.lineHeight
    }, {
      // svgDocument: view.graph.view.svg,
      ellipsis: s.ellipsis
      // hyphen: info.hyphen as string,
      // breakWord: info.breakWord as boolean,
    }) : l = "", Ze(uR.set, this, l, {
      view: e,
      elem: t,
      attrs: i,
      refBBox: r,
      cell: e.cell
    });
  }
}, mh = (n, { attrs: e }) => e.text !== void 0, rie = {
  qualify: mh
}, sie = {
  qualify: mh
}, oie = {
  qualify: mh
}, aie = {
  qualify: mh
}, lie = {
  qualify: mh
}, cie = {
  qualify: mh
}, uie = {
  qualify(n, { elem: e }) {
    return e instanceof SVGElement;
  },
  set(n, { elem: e }) {
    const t = "x6-title", i = `${n}`, r = Yl(e, t);
    if (r == null || r !== i) {
      Yl(e, t, i);
      const s = e.firstChild;
      if (s && s.tagName.toUpperCase() === "TITLE") {
        const o = s;
        o.textContent = i;
      } else {
        const o = document.createElementNS(e.namespaceURI, "title");
        o.textContent = i, e.insertBefore(o, s);
      }
    }
  }
}, hie = {
  offset: hR("x", "width", "right")
}, die = {
  offset: hR("y", "height", "bottom")
}, fie = {
  offset(n, { refBBox: e }) {
    return n ? { x: -e.x, y: -e.y } : { x: 0, y: 0 };
  }
};
function hR(n, e, t) {
  return (i, { refBBox: r }) => {
    const s = new z();
    let o;
    return i === "middle" ? o = r[e] / 2 : i === t ? o = r[e] : typeof i == "number" && Number.isFinite(i) ? o = i > -1 && i < 1 ? -r[e] * i : -i : qo(i) ? o = r[e] * parseFloat(i) / 100 : o = 0, s[n] = -(r[n] + o), s;
  };
}
const pie = {
  qualify: Ps,
  set(n, { elem: e }) {
    qn(e, n);
  }
}, gie = {
  set(n, { elem: e }) {
    e.innerHTML = `${n}`;
  }
}, mie = {
  qualify: Ps,
  set(n, { view: e }) {
    return `url(#${e.graph.defineFilter(n)})`;
  }
}, vie = {
  set(n) {
    return n != null && typeof n == "object" && n.id ? n.id : n;
  }
};
function tl(n, e, t) {
  let i, r;
  typeof e == "object" ? (i = e.x, r = e.y) : (i = e, r = t);
  const s = Be.parse(n), o = s.bbox();
  if (o) {
    let a = -o.height / 2 - o.y, l = -o.width / 2 - o.x;
    typeof i == "number" && (l -= i), typeof r == "number" && (a -= r), s.translate(l, a);
  }
  return s.serialize();
}
var dR = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const bie = (n) => {
  var { size: e, width: t, height: i, offset: r, open: s } = n, o = dR(n, ["size", "width", "height", "offset", "open"]);
  return fR({ size: e, width: t, height: i, offset: r }, s === !0, !0, void 0, o);
}, yie = (n) => {
  var { size: e, width: t, height: i, offset: r, factor: s } = n, o = dR(n, ["size", "width", "height", "offset", "factor"]);
  return fR({ size: e, width: t, height: i, offset: r }, !1, !1, s, o);
};
function fR(n, e, t, i = 3 / 4, r = {}) {
  const s = n.size || 10, o = n.width || s, a = n.height || s, l = new Be(), c = {};
  if (e)
    l.moveTo(o, 0).lineTo(0, a / 2).lineTo(o, a), c.fill = "none";
  else {
    if (l.moveTo(0, a / 2), l.lineTo(o, 0), !t) {
      const u = rr(i, 0, 1);
      l.lineTo(o * u, a / 2);
    }
    l.lineTo(o, a), l.close();
  }
  return Object.assign(Object.assign(Object.assign({}, c), r), { tagName: "path", d: tl(l.serialize(), {
    x: n.offset != null ? n.offset : -o / 2
  }) });
}
var Oie = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const wie = (n) => {
  var { size: e, width: t, height: i, offset: r } = n, s = Oie(n, ["size", "width", "height", "offset"]);
  const o = e || 10, a = t || o, l = i || o, c = new Be();
  return c.moveTo(0, l / 2).lineTo(a / 2, 0).lineTo(a, l / 2).lineTo(a / 2, l).close(), Object.assign(Object.assign({}, s), { tagName: "path", d: tl(c.serialize(), r ?? -a / 2) });
};
var xie = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const Sie = (n) => {
  var { d: e, offsetX: t, offsetY: i } = n, r = xie(n, ["d", "offsetX", "offsetY"]);
  return Object.assign(Object.assign({}, r), { tagName: "path", d: tl(e, t, i) });
};
var Cie = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const kie = (n) => {
  var { size: e, width: t, height: i, offset: r } = n, s = Cie(n, ["size", "width", "height", "offset"]);
  const o = e || 10, a = t || o, l = i || o, c = new Be();
  return c.moveTo(0, 0).lineTo(a, l).moveTo(0, l).lineTo(a, 0), Object.assign(Object.assign({}, s), { tagName: "path", fill: "none", d: tl(c.serialize(), r || -a / 2) });
};
var Pie = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const Eie = (n) => {
  var { width: e, height: t, offset: i, open: r, flip: s } = n, o = Pie(n, ["width", "height", "offset", "open", "flip"]);
  let a = t || 6;
  const l = e || 10, c = r === !0, u = s === !0, h = Object.assign(Object.assign({}, o), { tagName: "path" });
  u && (a = -a);
  const d = new Be();
  return d.moveTo(0, a).lineTo(l, 0), c ? h.fill = "none" : (d.lineTo(l, a), d.close()), h.d = tl(d.serialize(), {
    x: i || -l / 2,
    y: a / 2
  }), h;
};
var pR = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const gR = (n) => {
  var { r: e } = n, t = pR(n, ["r"]);
  const i = e || 5;
  return Object.assign(Object.assign({ cx: i }, t), { tagName: "circle", r: i });
}, Aie = (n) => {
  var { r: e } = n, t = pR(n, ["r"]);
  const i = e || 5, r = new Be();
  return r.moveTo(i, 0).lineTo(i, i * 2), r.moveTo(0, i).lineTo(i * 2, i), {
    children: [
      Object.assign(Object.assign({}, gR({ r: i })), { fill: "none" }),
      Object.assign(Object.assign({}, t), { tagName: "path", d: tl(r.serialize(), -i) })
    ]
  };
};
var $ie = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const Tie = (n) => {
  var { rx: e, ry: t } = n, i = $ie(n, ["rx", "ry"]);
  const r = e || 5, s = t || 5;
  return Object.assign(Object.assign({ cx: r }, i), { tagName: "ellipse", rx: r, ry: s });
}, _ie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  async: Eie,
  block: bie,
  circle: gR,
  circlePlus: Aie,
  classic: yie,
  cross: kie,
  diamond: wie,
  ellipse: Tie,
  path: Sie
}, Symbol.toStringTag, { value: "Module" }));
var za;
(function(n) {
  n.presets = _ie, n.registry = $n.create({
    type: "marker"
  }), n.registry.register(n.presets, !0);
})(za || (za = {}));
(function(n) {
  n.normalize = tl;
})(za || (za = {}));
var Mie = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
function Xw(n) {
  return typeof n == "string" || Ps(n);
}
const Rie = {
  qualify: Xw,
  set(n, { view: e, attrs: t }) {
    return Yw("marker-start", n, e, t);
  }
}, Nie = {
  qualify: Xw,
  set(n, { view: e, attrs: t }) {
    return Yw("marker-end", n, e, t, {
      transform: "rotate(180)"
    });
  }
}, Die = {
  qualify: Xw,
  set(n, { view: e, attrs: t }) {
    return Yw("marker-mid", n, e, t);
  }
};
function Yw(n, e, t, i, r = {}) {
  const s = typeof e == "string" ? { name: e } : e, { name: o, args: a } = s, l = Mie(s, ["name", "args"]);
  let c = l;
  if (o && typeof o == "string") {
    const h = za.registry.get(o);
    if (h)
      c = h(Object.assign(Object.assign({}, l), a));
    else
      return za.registry.onNotFound(o);
  }
  const u = Object.assign(Object.assign(Object.assign({}, Lie(i, n)), r), c);
  return {
    [n]: `url(#${t.graph.defineMarker(u)})`
  };
}
function Lie(n, e) {
  const t = {}, i = n.stroke;
  typeof i == "string" && (t.stroke = i, t.fill = i);
  let r = n.strokeOpacity;
  if (r == null && (r = n["stroke-opacity"]), r == null && (r = n.opacity), r != null && (t["stroke-opacity"] = r, t["fill-opacity"] = r), e !== "marker-mid") {
    const s = parseFloat(n.strokeWidth || n["stroke-width"]);
    if (Number.isFinite(s) && s > 1) {
      const o = Math.ceil(s / 2);
      t.refX = e === "marker-start" ? o : -o;
    }
  }
  return t;
}
const Lf = (n, { view: e }) => e.cell.isEdge(), Iie = {
  qualify: Lf,
  set(n, e) {
    var t, i, r, s;
    const o = e.view, a = n.reverse || !1, l = n.stubs || 0;
    let c;
    if (Number.isFinite(l) && l !== 0)
      if (a) {
        let u, h;
        const d = o.getConnectionLength() || 0;
        l < 0 ? (u = (d + l) / 2, h = -l) : (u = l, h = d - l * 2);
        const f = o.getConnection();
        c = (s = (r = (i = (t = f == null ? void 0 : f.divideAtLength(u)) === null || t === void 0 ? void 0 : t[1]) === null || i === void 0 ? void 0 : i.divideAtLength(h)) === null || r === void 0 ? void 0 : r[0]) === null || s === void 0 ? void 0 : s.serialize();
      } else {
        let u;
        l < 0 ? u = ((o.getConnectionLength() || 0) + l) / 2 : u = l;
        const h = o.getConnection();
        if (h) {
          const d = h.divideAtLength(u), f = h.divideAtLength(-u);
          d && f && (c = `${d[0].serialize()} ${f[1].serialize()}`);
        }
      }
    return { d: c || o.getConnectionPathData() };
  }
}, mR = {
  qualify: Lf,
  set: $v("getTangentAtLength", { rotate: !0 })
}, Bie = {
  qualify: Lf,
  set: $v("getTangentAtLength", { rotate: !1 })
}, vR = {
  qualify: Lf,
  set: $v("getTangentAtRatio", { rotate: !0 })
}, Qie = {
  qualify: Lf,
  set: $v("getTangentAtRatio", { rotate: !1 })
}, zie = mR, jie = vR;
function $v(n, e) {
  const t = { x: 1, y: 0 };
  return (i, r) => {
    let s, o;
    const a = r.view, l = a[n](Number(i));
    return l ? (o = e.rotate ? l.vector().vectorAngle(t) : 0, s = l.start) : (s = a.path.start, o = 0), o === 0 ? { transform: `translate(${s.x},${s.y}')` } : {
      transform: `translate(${s.x},${s.y}') rotate(${o})`
    };
  };
}
const Vie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotations: aie,
  atConnectionLength: zie,
  atConnectionLengthIgnoreGradient: Bie,
  atConnectionLengthKeepGradient: mR,
  atConnectionRatio: jie,
  atConnectionRatioIgnoreGradient: Qie,
  atConnectionRatioKeepGradient: vR,
  connection: Iie,
  displayEmpty: cie,
  eol: lie,
  fill: tie,
  filter: mie,
  html: gie,
  lineHeight: rie,
  port: vie,
  ref: Bne,
  refCx: Zne,
  refCy: qne,
  refD: Yne,
  refDKeepOffset: Wne,
  refDResetOffset: sR,
  refDx: Qne,
  refDy: zne,
  refHeight: iR,
  refHeight2: eie,
  refPoints: Une,
  refPointsKeepOffset: Hne,
  refPointsResetOffset: oR,
  refR: Xne,
  refRCircumscribed: Fne,
  refRInscribed: rR,
  refRx: jne,
  refRy: Vne,
  refWidth: nR,
  refWidth2: Jne,
  refX: eR,
  refX2: Gne,
  refY: tR,
  refY2: Kne,
  resetOffset: fie,
  sourceMarker: Rie,
  stroke: nie,
  style: pie,
  targetMarker: Nie,
  text: uR,
  textPath: oie,
  textVerticalAnchor: sie,
  textWrap: iie,
  title: uie,
  vertexMarker: Die,
  xAlign: hie,
  yAlign: die
}, Symbol.toStringTag, { value: "Module" }));
var po;
(function(n) {
  function e(t, i, r) {
    return !!(t != null && (typeof t == "string" || typeof t.qualify != "function" || Ze(t.qualify, this, i, r)));
  }
  n.isValidDefinition = e;
})(po || (po = {}));
(function(n) {
  n.presets = Object.assign(Object.assign({}, Ine), Vie), n.registry = $n.create({
    type: "attribute definition"
  }), n.registry.register(n.presets, !0);
})(po || (po = {}));
const Jr = {
  prefixCls: "x6",
  autoInsertCSS: !0,
  useCSSSelector: !0,
  prefix(n) {
    return `${Jr.prefixCls}-${n}`;
  }
}, zk = Jr.prefix("highlighted"), Fie = {
  highlight(n, e, t) {
    const i = t && t.className || zk;
    Ye(e, i);
  },
  unhighlight(n, e, t) {
    const i = t && t.className || zk;
    Nn(e, i);
  }
}, jk = Jr.prefix("highlight-opacity"), Zie = {
  highlight(n, e) {
    Ye(e, jk);
  },
  unhighlight(n, e) {
    Nn(e, jk);
  }
};
var It;
(function(n) {
  n.normalizeMarker = tl;
  function e(d, f) {
    const p = Gte(d.x, d.y).matrixTransform(f);
    return new z(p.x, p.y);
  }
  n.transformPoint = e;
  function t(d, f) {
    return new Ie(e(d.start, f), e(d.end, f));
  }
  n.transformLine = t;
  function i(d, f) {
    let p = d instanceof En ? d.points : d;
    return Array.isArray(p) || (p = []), new En(p.map((g) => e(g, f)));
  }
  n.transformPolyline = i;
  function r(d, f) {
    const g = Ts("svg").createSVGPoint();
    g.x = d.x, g.y = d.y;
    const m = g.matrixTransform(f);
    g.x = d.x + d.width, g.y = d.y;
    const v = g.matrixTransform(f);
    g.x = d.x + d.width, g.y = d.y + d.height;
    const y = g.matrixTransform(f);
    g.x = d.x, g.y = d.y + d.height;
    const b = g.matrixTransform(f), w = Math.min(m.x, v.x, y.x, b.x), x = Math.max(m.x, v.x, y.x, b.x), S = Math.min(m.y, v.y, y.y, b.y), C = Math.max(m.y, v.y, y.y, b.y);
    return new ye(w, S, x - w, C - S);
  }
  n.transformRectangle = r;
  function s(d, f, p) {
    let g;
    const m = d.ownerSVGElement;
    if (!m)
      return new ye(0, 0, 0, 0);
    try {
      g = d.getBBox();
    } catch {
      g = {
        x: d.clientLeft,
        y: d.clientTop,
        width: d.clientWidth,
        height: d.clientHeight
      };
    }
    if (f)
      return ye.create(g);
    const v = hd(d, p || m);
    return r(g, v);
  }
  n.bbox = s;
  function o(d, f = {}) {
    let p;
    if (!d.ownerSVGElement || !Ia(d)) {
      if (_k(d)) {
        const { left: y, top: b, width: w, height: x } = a(d);
        return new ye(y, b, w, x);
      }
      return new ye(0, 0, 0, 0);
    }
    let m = f.target;
    if (!f.recursive) {
      try {
        p = d.getBBox();
      } catch {
        p = {
          x: d.clientLeft,
          y: d.clientTop,
          width: d.clientWidth,
          height: d.clientHeight
        };
      }
      if (!m)
        return ye.create(p);
      const y = hd(d, m);
      return r(p, y);
    }
    {
      const y = d.childNodes, b = y.length;
      if (b === 0)
        return o(d, {
          target: m
        });
      m || (m = d);
      for (let w = 0; w < b; w += 1) {
        const x = y[w];
        let S;
        x.childNodes.length === 0 ? S = o(x, {
          target: m
        }) : S = o(x, {
          target: m,
          recursive: !0
        }), p ? p = p.union(S) : p = S;
      }
      return p;
    }
  }
  n.getBBox = o;
  function a(d) {
    let f = 0, p = 0, g = 0, m = 0;
    if (d) {
      let v = d;
      for (; v; )
        f += v.offsetLeft, p += v.offsetTop, v = v.offsetParent, v && (f += parseInt(Dk(v, "borderLeft"), 10), p += parseInt(Dk(v, "borderTop"), 10));
      g = d.offsetWidth, m = d.offsetHeight;
    }
    return {
      left: f,
      top: p,
      width: g,
      height: m
    };
  }
  n.getBoundingOffsetRect = a;
  function l(d) {
    const f = (p) => {
      const g = d.getAttribute(p), m = g ? parseFloat(g) : 0;
      return Number.isNaN(m) ? 0 : m;
    };
    switch (d instanceof SVGElement && d.nodeName.toLowerCase()) {
      case "rect":
        return new ye(f("x"), f("y"), f("width"), f("height"));
      case "circle":
        return new xs(f("cx"), f("cy"), f("r"), f("r"));
      case "ellipse":
        return new xs(f("cx"), f("cy"), f("rx"), f("ry"));
      case "polyline": {
        const p = om(d);
        return new En(p);
      }
      case "polygon": {
        const p = om(d);
        return p.length > 1 && p.push(p[0]), new En(p);
      }
      case "path": {
        let p = d.getAttribute("d");
        return Be.isValid(p) || (p = Be.normalize(p)), Be.parse(p);
      }
      case "line":
        return new Ie(f("x1"), f("y1"), f("x2"), f("y2"));
    }
    return o(d);
  }
  n.toGeometryShape = l;
  function c(d, f, p, g) {
    const m = z.create(f), v = z.create(p);
    g || (g = d instanceof SVGSVGElement ? d : d.ownerSVGElement);
    const y = Wy(d);
    d.setAttribute("transform", "");
    const b = o(d, {
      target: g
    }).scale(y.sx, y.sy), w = jh();
    w.setTranslate(-b.x - b.width / 2, -b.y - b.height / 2);
    const x = jh(), S = m.angleBetween(v, m.clone().translate(1, 0));
    S && x.setRotate(S, 0, 0);
    const C = jh(), k = m.clone().move(v, b.width / 2);
    C.setTranslate(2 * m.x - k.x, 2 * m.y - k.y);
    const E = hd(d, g), M = jh();
    M.setMatrix(C.matrix.multiply(x.matrix.multiply(w.matrix.multiply(E.scale(y.sx, y.sy))))), d.setAttribute("transform", gh(M.matrix));
  }
  n.translateAndAutoOrient = c;
  function u(d) {
    if (d == null)
      return null;
    let f = d;
    do {
      let p = f.tagName;
      if (typeof p != "string")
        return null;
      if (p = p.toUpperCase(), ph(f, "x6-port"))
        f = f.nextElementSibling;
      else if (p === "G")
        f = f.firstElementChild;
      else if (p === "TITLE")
        f = f.nextElementSibling;
      else
        break;
    } while (f);
    return f;
  }
  n.findShapeNode = u;
  function h(d) {
    const f = u(d);
    if (!Ia(f)) {
      if (_k(d)) {
        const { left: m, top: v, width: y, height: b } = a(d);
        return new ye(m, v, y, b);
      }
      return new ye(0, 0, 0, 0);
    }
    return l(f).bbox() || ye.create();
  }
  n.getBBoxV2 = h;
})(It || (It = {}));
const qie = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    "stroke-width": 3,
    stroke: "#FEB663"
  }
}, Wie = {
  highlight(n, e, t) {
    const i = pa.getHighlighterId(e, t);
    if (pa.hasCache(i))
      return;
    t = P$({}, t, qie);
    const r = Je.create(e);
    let s, o;
    try {
      s = r.toPathData();
    } catch {
      o = It.bbox(r.node, !0), s = ZM(Object.assign(Object.assign({}, t), o));
    }
    const a = Ts("path");
    if (St(a, Object.assign({ d: s, "pointer-events": "none", "vector-effect": "non-scaling-stroke", fill: "none" }, t.attrs ? jd(t.attrs) : null)), n.isEdgeElement(e))
      St(a, "d", n.getConnectionPathData());
    else {
      let u = r.getTransformToElement(n.container);
      const h = t.padding;
      if (h) {
        o == null && (o = It.bbox(r.node, !0));
        const d = o.x + o.width / 2, f = o.y + o.height / 2;
        o = It.transformRectangle(o, u);
        const p = Math.max(o.width, 1), g = Math.max(o.height, 1), m = (p + h) / p, v = (g + h) / g, y = ci({
          a: m,
          b: 0,
          c: 0,
          d: v,
          e: d - m * d,
          f: f - v * f
        });
        u = u.multiply(y);
      }
      Eu(a, u);
    }
    Ye(a, Jr.prefix("highlight-stroke"));
    const l = n.cell, c = () => pa.removeHighlighter(i);
    l.on("removed", c), l.model && l.model.on("reseted", c), n.container.appendChild(a), pa.setCache(i, a);
  },
  unhighlight(n, e, t) {
    pa.removeHighlighter(pa.getHighlighterId(e, t));
  }
};
var pa;
(function(n) {
  function e(o, a) {
    return jw(o), o.id + JSON.stringify(a);
  }
  n.getHighlighterId = e;
  const t = {};
  function i(o, a) {
    t[o] = a;
  }
  n.setCache = i;
  function r(o) {
    return t[o] != null;
  }
  n.hasCache = r;
  function s(o) {
    const a = t[o];
    a && (ro(a), delete t[o]);
  }
  n.removeHighlighter = s;
})(pa || (pa = {}));
const Hie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  className: Fie,
  opacity: Zie,
  stroke: Wie
}, Symbol.toStringTag, { value: "Module" }));
var Bo;
(function(n) {
  function e(t, i) {
    if (typeof i.highlight != "function")
      throw new Error(`Highlighter '${t}' is missing required \`highlight()\` method`);
    if (typeof i.unhighlight != "function")
      throw new Error(`Highlighter '${t}' is missing required \`unhighlight()\` method`);
  }
  n.check = e;
})(Bo || (Bo = {}));
(function(n) {
  n.presets = Hie, n.registry = $n.create({
    type: "highlighter"
  }), n.registry.register(n.presets, !0);
})(Bo || (Bo = {}));
function Uy(n, e = {}) {
  return new z(ys(e.x, n.width), ys(e.y, n.height));
}
function Uw(n, e, t) {
  return Object.assign({ angle: e, position: n.toJSON() }, t);
}
const Xie = (n, e) => n.map(({ x: t, y: i, angle: r }) => Uw(Uy(e, { x: t, y: i }), r || 0)), Yie = (n, e, t) => {
  const i = t.start || 0, r = t.step || 20;
  return bR(n, e, i, (s, o) => (s + 0.5 - o / 2) * r);
}, Uie = (n, e, t) => {
  const i = t.start || 0, r = t.step || 360 / n.length;
  return bR(n, e, i, (s) => s * r);
};
function bR(n, e, t, i) {
  const r = e.getCenter(), s = e.getTopCenter(), o = e.width / e.height, a = xs.fromRect(e), l = n.length;
  return n.map((c, u) => {
    const h = t + i(u, l), d = s.clone().rotate(-h, r).scale(o, 1, r), f = c.compensateRotate ? -a.tangentTheta(d) : 0;
    return (c.dx || c.dy) && d.translate(c.dx || 0, c.dy || 0), c.dr && d.move(r, c.dr), Uw(d.round(), f, c);
  });
}
var Gie = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const Kie = (n, e, t) => {
  const i = Uy(e, t.start || e.getOrigin()), r = Uy(e, t.end || e.getCorner());
  return If(n, i, r, t);
}, Jie = (n, e, t) => If(n, e.getTopLeft(), e.getBottomLeft(), t), ere = (n, e, t) => If(n, e.getTopRight(), e.getBottomRight(), t), tre = (n, e, t) => If(n, e.getTopLeft(), e.getTopRight(), t), nre = (n, e, t) => If(n, e.getBottomLeft(), e.getBottomRight(), t);
function If(n, e, t, i) {
  const r = new Ie(e, t), s = n.length;
  return n.map((o, a) => {
    var { strict: l } = o, c = Gie(o, ["strict"]);
    const u = l || i.strict ? (a + 1) / (s + 1) : (a + 0.5) / s, h = r.pointAt(u);
    return (c.dx || c.dy) && h.translate(c.dx || 0, c.dy || 0), Uw(h.round(), 0, c);
  });
}
const ire = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  absolute: Xie,
  bottom: nre,
  ellipse: Yie,
  ellipseSpread: Uie,
  left: Jie,
  line: Kie,
  right: ere,
  top: tre
}, Symbol.toStringTag, { value: "Module" }));
var Ql;
(function(n) {
  n.presets = ire, n.registry = $n.create({
    type: "port layout"
  }), n.registry.register(n.presets, !0);
})(Ql || (Ql = {}));
const rre = {
  position: { x: 0, y: 0 },
  angle: 0,
  attrs: {
    ".": {
      y: "0",
      "text-anchor": "start"
    }
  }
};
function nl(n, e) {
  const { x: t, y: i, angle: r, attrs: s } = e || {};
  return P$({}, { angle: r, attrs: s, position: { x: t, y: i } }, n, rre);
}
const sre = (n, e, t) => nl({ position: e.getTopLeft() }, t), ore = (n, e, t) => nl({
  position: { x: -15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "end" } }
}, t), are = (n, e, t) => nl({
  position: { x: 15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "start" } }
}, t), lre = (n, e, t) => nl({
  position: { x: 0, y: -15 },
  attrs: { ".": { "text-anchor": "middle" } }
}, t), cre = (n, e, t) => nl({
  position: { x: 0, y: 15 },
  attrs: { ".": { y: ".6em", "text-anchor": "middle" } }
}, t), ure = (n, e, t) => yR(n, e, !1, t), hre = (n, e, t) => yR(n, e, !0, t), dre = (n, e, t) => OR(n, e, !1, t), fre = (n, e, t) => OR(n, e, !0, t);
function yR(n, e, t, i) {
  const r = i.offset != null ? i.offset : 15, s = e.getCenter().theta(n), o = wR(e);
  let a, l, c, u, h = 0;
  return s < o[1] || s > o[2] ? (a = ".3em", l = r, c = 0, u = "start") : s < o[0] ? (a = "0", l = 0, c = -r, t ? (h = -90, u = "start") : u = "middle") : s < o[3] ? (a = ".3em", l = -r, c = 0, u = "end") : (a = ".6em", l = 0, c = r, t ? (h = 90, u = "start") : u = "middle"), nl({
    position: {
      x: Math.round(l),
      y: Math.round(c)
    },
    angle: h,
    attrs: {
      ".": {
        y: a,
        "text-anchor": u
      }
    }
  }, i);
}
function OR(n, e, t, i) {
  const r = i.offset != null ? i.offset : 15, s = e.getCenter().theta(n), o = wR(e);
  let a, l, c, u, h = 0;
  return s < o[1] || s > o[2] ? (a = ".3em", l = -r, c = 0, u = "end") : s < o[0] ? (a = ".6em", l = 0, c = r, t ? (h = 90, u = "start") : u = "middle") : s < o[3] ? (a = ".3em", l = r, c = 0, u = "start") : (a = "0em", l = 0, c = -r, t ? (h = -90, u = "start") : u = "middle"), nl({
    position: {
      x: Math.round(l),
      y: Math.round(c)
    },
    angle: h,
    attrs: {
      ".": {
        y: a,
        "text-anchor": u
      }
    }
  }, i);
}
function wR(n) {
  const e = n.getCenter(), t = e.theta(n.getTopLeft()), i = e.theta(n.getBottomLeft()), r = e.theta(n.getBottomRight()), s = e.theta(n.getTopRight());
  return [t, s, r, i];
}
const pre = (n, e, t) => xR(n.diff(e.getCenter()), !1, t), gre = (n, e, t) => xR(n.diff(e.getCenter()), !0, t);
function xR(n, e, t) {
  const i = t.offset != null ? t.offset : 20, r = new z(0, 0), s = -n.theta(r), o = n.clone().move(r, i).diff(n).round();
  let a = ".3em", l, c = s;
  return (s + 90) % 180 === 0 ? (l = e ? "end" : "middle", !e && s === -270 && (a = "0em")) : s > -270 && s < -90 ? (l = "start", c = s - 180) : l = "end", nl({
    position: o.round().toJSON(),
    angle: e ? c : 0,
    attrs: {
      ".": {
        y: a,
        "text-anchor": l
      }
    }
  }, t);
}
const mre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: cre,
  inside: dre,
  insideOriented: fre,
  left: ore,
  manual: sre,
  outside: ure,
  outsideOriented: hre,
  radial: pre,
  radialOriented: gre,
  right: are,
  top: lre
}, Symbol.toStringTag, { value: "Module" }));
var _u;
(function(n) {
  n.presets = mre, n.registry = $n.create({
    type: "port label layout"
  }), n.registry.register(n.presets, !0);
})(_u || (_u = {}));
var vre = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Rt extends gn {
  get priority() {
    return 2;
  }
  /** If need remove `this.container` DOM */
  get disposeContainer() {
    return !0;
  }
  constructor() {
    super(), this.cid = Gy.uniqueId(), Rt.views[this.cid] = this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t) {
    return 0;
  }
  empty(e = this.container) {
    return Df(e), this;
  }
  unmount(e = this.container) {
    return ro(e), this;
  }
  remove(e = this.container) {
    return e === this.container ? (this.removeEventListeners(document), this.onRemove(), delete Rt.views[this.cid], this.disposeContainer && this.unmount(e)) : this.unmount(e), this;
  }
  onRemove() {
  }
  setClass(e, t = this.container) {
    t.classList.value = Array.isArray(e) ? e.join(" ") : e;
  }
  addClass(e, t = this.container) {
    return Ye(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  removeClass(e, t = this.container) {
    return Nn(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  setStyle(e, t = this.container) {
    return qn(t, e), this;
  }
  setAttrs(e, t = this.container) {
    return e != null && t != null && St(t, e), this;
  }
  /**
   * Returns the value of the specified attribute of `node`.
   *
   * If the node does not set a value for attribute, start recursing up
   * the DOM tree from node to lookup for attribute at the ancestors of
   * node. If the recursion reaches CellView's root node and attribute
   * is not found even there, return `null`.
   */
  findAttr(e, t = this.container) {
    let i = t;
    for (; i && i.nodeType === 1; ) {
      const r = i.getAttribute(e);
      if (r != null)
        return r;
      if (i === this.container)
        return null;
      i = i.parentNode;
    }
    return null;
  }
  find(e, t = this.container, i = this.selectors) {
    return Rt.find(e, t, i).elems;
  }
  findOne(e, t = this.container, i = this.selectors) {
    const r = this.find(e, t, i);
    return r.length > 0 ? r[0] : null;
  }
  findByAttr(e, t = this.container) {
    let i = t;
    for (; i && i.getAttribute; ) {
      const r = i.getAttribute(e);
      if ((r != null || i === this.container) && r !== "false")
        return i;
      i = i.parentNode;
    }
    return null;
  }
  getSelector(e, t) {
    let i;
    if (e === this.container)
      return typeof t == "string" && (i = `> ${t}`), i;
    if (e) {
      const r = Fw(e) + 1;
      i = `${e.tagName.toLowerCase()}:nth-child(${r})`, t && (i += ` > ${t}`), i = this.getSelector(e.parentNode, i);
    }
    return i;
  }
  prefixClassName(e) {
    return Jr.prefix(e);
  }
  delegateEvents(e, t) {
    if (e == null)
      return this;
    t || this.undelegateEvents();
    const i = /^(\S+)\s*(.*)$/;
    return Object.keys(e).forEach((r) => {
      const s = r.match(i);
      if (s == null)
        return;
      const o = this.getEventHandler(e[r]);
      typeof o == "function" && this.delegateEvent(s[1], s[2], o);
    }), this;
  }
  undelegateEvents() {
    return vi.off(this.container, this.getEventNamespace()), this;
  }
  delegateDocumentEvents(e, t) {
    return this.addEventListeners(document, e, t), this;
  }
  undelegateDocumentEvents() {
    return this.removeEventListeners(document), this;
  }
  delegateEvent(e, t, i) {
    return vi.on(this.container, e + this.getEventNamespace(), t, i), this;
  }
  undelegateEvent(e, t, i) {
    const r = e + this.getEventNamespace();
    return t == null ? vi.off(this.container, r) : typeof t == "string" ? vi.off(this.container, r, t, i) : vi.off(this.container, r, t), this;
  }
  addEventListeners(e, t, i) {
    if (t == null)
      return this;
    const r = this.getEventNamespace();
    return Object.keys(t).forEach((s) => {
      const o = this.getEventHandler(t[s]);
      typeof o == "function" && vi.on(e, s + r, i, o);
    }), this;
  }
  removeEventListeners(e) {
    return e != null && vi.off(e, this.getEventNamespace()), this;
  }
  getEventNamespace() {
    return `.${Jr.prefixCls}-event-${this.cid}`;
  }
  // eslint-disable-next-line
  getEventHandler(e) {
    let t;
    if (typeof e == "string") {
      const i = this[e];
      typeof i == "function" && (t = (...r) => i.call(this, ...r));
    } else
      t = (...i) => e.call(this, ...i);
    return t;
  }
  getEventTarget(e, t = {}) {
    const { target: i, type: r, clientX: s = 0, clientY: o = 0 } = e;
    return t.fromPoint || r === "touchmove" || r === "touchend" ? document.elementFromPoint(s, o) : i;
  }
  stopPropagation(e) {
    return this.setEventData(e, { propagationStopped: !0 }), this;
  }
  isPropagationStopped(e) {
    return this.getEventData(e).propagationStopped === !0;
  }
  getEventData(e) {
    return this.eventData(e);
  }
  setEventData(e, t) {
    return this.eventData(e, t);
  }
  eventData(e, t) {
    if (e == null)
      throw new TypeError("Event object required");
    let i = e.data;
    const r = `__${this.cid}__`;
    return t == null ? i == null ? {} : i[r] || {} : (i == null && (i = e.data = {}), i[r] == null ? i[r] = Object.assign({}, t) : i[r] = Object.assign(Object.assign({}, i[r]), t), i[r]);
  }
  normalizeEvent(e) {
    return Rt.normalizeEvent(e);
  }
  dispose() {
    this.remove();
  }
}
vre([
  Rt.dispose()
], Rt.prototype, "dispose", null);
(function(n) {
  function e(r, s) {
    return s ? Ts(r || "g") : Vw(r || "div");
  }
  n.createElement = e;
  function t(r, s, o) {
    if (!r || r === ".")
      return { elems: [s] };
    if (o) {
      const a = o[r];
      if (a)
        return { elems: Array.isArray(a) ? a : [a] };
    }
    {
      const a = r.includes(">") ? `:scope ${r}` : r;
      return {
        isCSSSelector: !0,
        // $(rootElem).find(selector).toArray() as Element[]
        elems: Array.prototype.slice.call(s.querySelectorAll(a))
      };
    }
  }
  n.find = t;
  function i(r) {
    let s = r;
    const o = r.originalEvent, a = o && o.changedTouches && o.changedTouches[0];
    if (a) {
      for (const l in r)
        a[l] === void 0 && (a[l] = r[l]);
      s = a;
    }
    return s;
  }
  n.normalizeEvent = i;
})(Rt || (Rt = {}));
(function(n) {
  n.views = {};
  function e(t) {
    return n.views[t] || null;
  }
  n.getView = e;
})(Rt || (Rt = {}));
var Gy;
(function(n) {
  let e = 0;
  function t() {
    const i = `v${e}`;
    return e += 1, i;
  }
  n.uniqueId = t;
})(Gy || (Gy = {}));
class bre {
  constructor(e) {
    this.view = e, this.clean();
  }
  clean() {
    this.elemCache && this.elemCache.dispose(), this.elemCache = new Yy(), this.pathCache = {};
  }
  get(e) {
    return this.elemCache.has(e) || this.elemCache.set(e, {}), this.elemCache.get(e);
  }
  getData(e) {
    const t = this.get(e);
    return t.data || (t.data = {}), t.data;
  }
  getMatrix(e) {
    const t = this.get(e);
    if (t.matrix == null) {
      const i = this.view.container;
      t.matrix = nne(e, i);
    }
    return ci(t.matrix);
  }
  getShape(e) {
    const t = this.get(e);
    return t.shape == null && (t.shape = It.toGeometryShape(e)), t.shape.clone();
  }
  getBoundingRect(e) {
    const t = this.get(e);
    return t.boundingRect == null && (t.boundingRect = It.getBBoxV2(e)), t.boundingRect.clone();
  }
}
var Yt;
(function(n) {
  function e(c) {
    return c != null && !t(c);
  }
  n.isJSONMarkup = e;
  function t(c) {
    return c != null && typeof c == "string";
  }
  n.isStringMarkup = t;
  function i(c) {
    return c == null || t(c) ? c : Bt(c);
  }
  n.clone = i;
  function r(c) {
    return `${c}`.trim().replace(/[\r|\n]/g, " ").replace(/>\s+</g, "><");
  }
  n.sanitize = r;
  function s(c, u = { ns: si.svg }) {
    const h = document.createDocumentFragment(), d = {}, f = {}, p = [
      {
        markup: Array.isArray(c) ? c : [c],
        parent: h,
        ns: u.ns
      }
    ];
    for (; p.length > 0; ) {
      const g = p.pop();
      let m = g.ns || si.svg;
      const v = g.markup, y = g.parent;
      v.forEach((b) => {
        const w = b.tagName;
        if (!w)
          throw new TypeError("Invalid tagName");
        b.ns && (m = b.ns);
        const x = m ? Vw(w, m) : Tk(w), S = b.attrs;
        S && St(x, jd(S));
        const C = b.style;
        C && qn(x, C);
        const k = b.className;
        k != null && x.setAttribute("class", Array.isArray(k) ? k.join(" ") : k), b.textContent && (x.textContent = b.textContent);
        const E = b.selector;
        if (E != null) {
          if (f[E])
            throw new TypeError("Selector must be unique");
          f[E] = x;
        }
        if (b.groupSelector) {
          let _ = b.groupSelector;
          Array.isArray(_) || (_ = [_]), _.forEach((T) => {
            d[T] || (d[T] = []), d[T].push(x);
          });
        }
        y.appendChild(x);
        const M = b.children;
        Array.isArray(M) && p.push({ ns: m, markup: M, parent: x });
      });
    }
    return Object.keys(d).forEach((g) => {
      if (f[g])
        throw new Error("Ambiguous group selector");
      f[g] = d[g];
    }), { fragment: h, selectors: f, groups: d };
  }
  n.parseJSONMarkup = s;
  function o(c) {
    return c instanceof SVGElement ? Ts("g") : Tk("div");
  }
  function a(c) {
    if (t(c)) {
      const f = Je.createVectors(c), p = f.length;
      if (p === 1)
        return {
          elem: f[0].node
        };
      if (p > 1) {
        const g = o(f[0].node);
        return f.forEach((m) => {
          g.appendChild(m.node);
        }), { elem: g };
      }
      return {};
    }
    const u = s(c), h = u.fragment;
    let d = null;
    return h.childNodes.length > 1 ? (d = o(h.firstChild), d.appendChild(h)) : d = h.firstChild, { elem: d, selectors: u.selectors };
  }
  n.renderMarkup = a;
  function l(c) {
    const u = Je.createVectors(c), h = document.createDocumentFragment();
    for (let d = 0, f = u.length; d < f; d += 1) {
      const p = u[d].node;
      h.appendChild(p);
    }
    return { fragment: h, selectors: {} };
  }
  n.parseLabelStringMarkup = l;
})(Yt || (Yt = {}));
(function(n) {
  function e(t, i, r) {
    if (t != null) {
      let s;
      const o = t.tagName.toLowerCase();
      if (t === i)
        return typeof r == "string" ? s = `> ${o} > ${r}` : s = `> ${o}`, s;
      const a = t.parentNode;
      if (a && a.childNodes.length > 1) {
        const l = Fw(t) + 1;
        s = `${o}:nth-child(${l})`;
      } else
        s = o;
      return r && (s += ` > ${r}`), e(t.parentNode, i, s);
    }
    return r;
  }
  n.getSelector = e;
})(Yt || (Yt = {}));
(function(n) {
  function e() {
    return "g";
  }
  n.getPortContainerMarkup = e;
  function t() {
    return {
      tagName: "circle",
      selector: "circle",
      attrs: {
        r: 10,
        fill: "#FFFFFF",
        stroke: "#000000"
      }
    };
  }
  n.getPortMarkup = t;
  function i() {
    return {
      tagName: "text",
      selector: "text",
      attrs: {
        fill: "#000000"
      }
    };
  }
  n.getPortLabelMarkup = i;
})(Yt || (Yt = {}));
(function(n) {
  function e() {
    return [
      {
        tagName: "path",
        selector: "wrap",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          cursor: "pointer",
          stroke: "transparent",
          strokeLinecap: "round"
        }
      },
      {
        tagName: "path",
        selector: "line",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          pointerEvents: "none"
        }
      }
    ];
  }
  n.getEdgeMarkup = e;
})(Yt || (Yt = {}));
(function(n) {
  function e(t = !1) {
    return {
      tagName: "foreignObject",
      selector: "fo",
      children: [
        {
          ns: si.xhtml,
          tagName: "body",
          selector: "foBody",
          attrs: {
            xmlns: si.xhtml
          },
          style: {
            width: "100%",
            height: "100%",
            background: "transparent"
          },
          children: t ? [] : [
            {
              tagName: "div",
              selector: "foContent",
              style: {
                width: "100%",
                height: "100%"
              }
            }
          ]
        }
      ]
    };
  }
  n.getForeignObjectMarkup = e;
})(Yt || (Yt = {}));
class SR {
  constructor(e) {
    this.view = e;
  }
  get cell() {
    return this.view.cell;
  }
  getDefinition(e) {
    return this.cell.getAttrDefinition(e);
  }
  processAttrs(e, t) {
    let i, r, s, o;
    const a = [];
    return Object.keys(t).forEach((l) => {
      const c = t[l], u = this.getDefinition(l), h = Ze(po.isValidDefinition, this.view, u, c, {
        elem: e,
        attrs: t,
        cell: this.cell,
        view: this.view
      });
      if (u && h)
        typeof u == "string" ? (i == null && (i = {}), i[u] = c) : c !== null && a.push({ name: l, definition: u });
      else {
        i == null && (i = {});
        const d = LM.includes(l) ? l : vM(l);
        i[d] = c;
      }
    }), a.forEach(({ name: l, definition: c }) => {
      const u = t[l];
      typeof c.set == "function" && (r == null && (r = {}), r[l] = u), typeof c.offset == "function" && (s == null && (s = {}), s[l] = u), typeof c.position == "function" && (o == null && (o = {}), o[l] = u);
    }), {
      raw: t,
      normal: i,
      set: r,
      offset: s,
      position: o
    };
  }
  mergeProcessedAttrs(e, t) {
    e.set = Object.assign(Object.assign({}, e.set), t.set), e.position = Object.assign(Object.assign({}, e.position), t.position), e.offset = Object.assign(Object.assign({}, e.offset), t.offset);
    const i = e.normal && e.normal.transform;
    i != null && t.normal && (t.normal.transform = i), e.normal = t.normal;
  }
  findAttrs(e, t, i, r) {
    const s = [], o = new Yy();
    return Object.keys(e).forEach((a) => {
      const l = e[a];
      if (!Ps(l))
        return;
      const { isCSSSelector: c, elems: u } = Rt.find(a, t, r);
      i[a] = u;
      for (let h = 0, d = u.length; h < d; h += 1) {
        const f = u[h], p = r && r[a] === f, g = o.get(f);
        if (g) {
          g.array || (s.push(f), g.array = !0, g.attrs = [g.attrs], g.priority = [g.priority]);
          const m = g.attrs, v = g.priority;
          if (p)
            m.unshift(l), v.unshift(-1);
          else {
            const y = sj(v, c ? -1 : d);
            m.splice(y, 0, l), v.splice(y, 0, d);
          }
        } else
          o.set(f, {
            elem: f,
            attrs: l,
            priority: p ? -1 : d,
            array: !1
          });
      }
    }), s.forEach((a) => {
      const l = o.get(a), c = l.attrs;
      l.attrs = c.reduceRight((u, h) => On(u, h), {});
    }), o;
  }
  updateRelativeAttrs(e, t, i) {
    const r = t.raw || {};
    let s = t.normal || {};
    const o = t.set, a = t.position, l = t.offset, c = () => ({
      elem: e,
      cell: this.cell,
      view: this.view,
      attrs: r,
      refBBox: i.clone()
    });
    if (o != null && Object.keys(o).forEach((m) => {
      const v = o[m], y = this.getDefinition(m);
      if (y != null) {
        const b = Ze(y.set, this.view, v, c());
        typeof b == "object" ? s = Object.assign(Object.assign({}, s), b) : b != null && (s[m] = b);
      }
    }), e instanceof HTMLElement) {
      this.view.setAttrs(s, e);
      return;
    }
    const u = s.transform, h = u ? `${u}` : null, d = Vd(h), f = new z(d.e, d.f);
    u && (delete s.transform, d.e = 0, d.f = 0);
    let p = !1;
    a != null && Object.keys(a).forEach((m) => {
      const v = a[m], y = this.getDefinition(m);
      if (y != null) {
        const b = Ze(y.position, this.view, v, c());
        b != null && (p = !0, f.translate(z.create(b)));
      }
    }), this.view.setAttrs(s, e);
    let g = !1;
    if (l != null) {
      const m = this.view.getBoundingRectOfElement(e);
      if (m.width > 0 && m.height > 0) {
        const v = It.transformRectangle(m, d);
        Object.keys(l).forEach((y) => {
          const b = l[y], w = this.getDefinition(y);
          if (w != null) {
            const x = Ze(w.offset, this.view, b, {
              elem: e,
              cell: this.cell,
              view: this.view,
              attrs: r,
              refBBox: v
            });
            x != null && (g = !0, f.translate(z.create(x)));
          }
        });
      }
    }
    (u != null || p || g) && (f.round(1), d.e = f.x, d.f = f.y, e.setAttribute("transform", gh(d)));
  }
  update(e, t, i) {
    const r = {}, s = this.findAttrs(i.attrs || t, e, r, i.selectors), o = i.attrs ? this.findAttrs(t, e, r, i.selectors) : s, a = [];
    s.each((u) => {
      const h = u.elem, d = u.attrs, f = this.processAttrs(h, d);
      if (f.set == null && f.position == null && f.offset == null)
        this.view.setAttrs(f.normal, h);
      else {
        const p = o.get(h), g = p ? p.attrs : null, m = g && d.ref == null ? g.ref : d.ref;
        let v;
        if (m) {
          if (v = (r[m] || this.view.find(m, e, i.selectors))[0], !v)
            throw new Error(`"${m}" reference does not exist.`);
        } else
          v = null;
        const y = {
          node: h,
          refNode: v,
          attributes: g,
          processedAttributes: f
        }, b = a.findIndex((w) => w.refNode === h);
        b > -1 ? a.splice(b, 0, y) : a.push(y);
      }
    });
    const l = new Yy();
    let c;
    a.forEach((u) => {
      const h = u.node, d = u.refNode;
      let f;
      const p = d != null && i.rotatableNode != null && NM(i.rotatableNode, d);
      if (d && (f = l.get(d)), !f) {
        const v = p ? i.rotatableNode : e;
        f = d ? It.getBBox(d, { target: v }) : i.rootBBox, d && l.set(d, f);
      }
      let g;
      i.attrs && u.attributes ? (g = this.processAttrs(h, u.attributes), this.mergeProcessedAttrs(g, u.processedAttributes)) : g = u.processedAttributes;
      let m = f;
      p && i.rotatableNode != null && !i.rotatableNode.contains(h) && (c || (c = Vd(St(i.rotatableNode, "transform"))), m = It.transformRectangle(f, c)), this.updateRelativeAttrs(h, g, m);
    });
  }
}
class CR {
  get cell() {
    return this.view.cell;
  }
  constructor(e, t, i = []) {
    this.view = e;
    const r = {}, s = {};
    let o = 0;
    Object.keys(t).forEach((l) => {
      let c = t[l];
      Array.isArray(c) || (c = [c]), c.forEach((u) => {
        let h = r[u];
        h || (o += 1, h = r[u] = 1 << o), s[l] |= h;
      });
    });
    let a = i;
    if (Array.isArray(a) || (a = [a]), a.forEach((l) => {
      r[l] || (o += 1, r[l] = 1 << o);
    }), o > 25)
      throw new Error("Maximum number of flags exceeded.");
    this.flags = r, this.attrs = s, this.bootstrap = i;
  }
  getFlag(e) {
    const t = this.flags;
    return t == null ? 0 : Array.isArray(e) ? e.reduce((i, r) => i | t[r], 0) : t[e] | 0;
  }
  hasAction(e, t) {
    return e & this.getFlag(t);
  }
  removeAction(e, t) {
    return e ^ e & this.getFlag(t);
  }
  getBootstrapFlag() {
    return this.getFlag(this.bootstrap);
  }
  getChangedFlag() {
    let e = 0;
    return this.attrs && Object.keys(this.attrs).forEach((t) => {
      this.cell.hasChanged(t) && (e |= this.attrs[t]);
    }), e;
  }
}
var yre = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}, Ore = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class An extends Rt {
  static getDefaults() {
    return this.defaults;
  }
  static config(e) {
    this.defaults = this.getOptions(e);
  }
  static getOptions(e) {
    const t = (c, u) => u != null ? I$([
      ...Array.isArray(c) ? c : [c],
      ...Array.isArray(u) ? u : [u]
    ]) : Array.isArray(c) ? [...c] : [c], i = Bt(this.getDefaults()), { bootstrap: r, actions: s, events: o, documentEvents: a } = e, l = Ore(e, ["bootstrap", "actions", "events", "documentEvents"]);
    return r && (i.bootstrap = t(i.bootstrap, r)), s && Object.entries(s).forEach(([c, u]) => {
      const h = i.actions[c];
      u && h ? i.actions[c] = t(h, u) : u && (i.actions[c] = t(u));
    }), o && (i.events = Object.assign(Object.assign({}, i.events), o)), e.documentEvents && (i.documentEvents = Object.assign(Object.assign({}, i.documentEvents), a)), On(i, l);
  }
  get [Symbol.toStringTag]() {
    return An.toStringTag;
  }
  constructor(e, t = {}) {
    super(), this.cell = e, this.options = this.ensureOptions(t), this.graph = this.options.graph, this.attr = new SR(this), this.flag = new CR(this, this.options.actions, this.options.bootstrap), this.cache = new bre(this), this.setContainer(this.ensureContainer()), this.setup(), this.init();
  }
  init() {
  }
  onRemove() {
    this.removeTools();
  }
  get priority() {
    return this.options.priority;
  }
  get rootSelector() {
    return this.options.rootSelector;
  }
  getConstructor() {
    return this.constructor;
  }
  ensureOptions(e) {
    return this.getConstructor().getOptions(e);
  }
  getContainerTagName() {
    return this.options.isSvgElement ? "g" : "div";
  }
  getContainerStyle() {
  }
  getContainerAttrs() {
    return {
      "data-cell-id": this.cell.id,
      "data-shape": this.cell.shape
    };
  }
  getContainerClassName() {
    return this.prefixClassName("cell");
  }
  ensureContainer() {
    return Rt.createElement(this.getContainerTagName(), this.options.isSvgElement);
  }
  setContainer(e) {
    if (this.container !== e) {
      this.undelegateEvents(), this.container = e, this.options.events != null && this.delegateEvents(this.options.events);
      const t = this.getContainerAttrs();
      t != null && this.setAttrs(t, e);
      const i = this.getContainerStyle();
      i != null && this.setStyle(i, e);
      const r = this.getContainerClassName();
      r != null && this.addClass(r, e);
    }
    return this;
  }
  isNodeView() {
    return !1;
  }
  isEdgeView() {
    return !1;
  }
  render() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t = {}) {
    return 0;
  }
  getBootstrapFlag() {
    return this.flag.getBootstrapFlag();
  }
  getFlag(e) {
    return this.flag.getFlag(e);
  }
  hasAction(e, t) {
    return this.flag.hasAction(e, t);
  }
  removeAction(e, t) {
    return this.flag.removeAction(e, t);
  }
  handleAction(e, t, i, r) {
    if (this.hasAction(e, t)) {
      i();
      const s = [t];
      return r && (typeof r == "string" ? s.push(r) : s.push(...r)), this.removeAction(e, s);
    }
    return e;
  }
  setup() {
    this.cell.on("changed", this.onCellChanged, this);
  }
  onCellChanged({ options: e }) {
    this.onAttrsChange(e);
  }
  onAttrsChange(e) {
    let t = this.flag.getChangedFlag();
    e.updated || !t || (e.dirty && this.hasAction(t, "update") && (t |= this.getFlag("render")), e.toolId && (e.async = !1), this.graph != null && this.graph.renderer.requestViewUpdate(this, t, e));
  }
  parseJSONMarkup(e, t) {
    const i = Yt.parseJSONMarkup(e), r = i.selectors, s = this.rootSelector;
    if (t && s) {
      if (r[s])
        throw new Error("Invalid root selector");
      r[s] = t;
    }
    return i;
  }
  can(e) {
    let t = this.graph.options.interacting;
    if (typeof t == "function" && (t = Ze(t, this.graph, this)), typeof t == "object") {
      let i = t[e];
      return typeof i == "function" && (i = Ze(i, this.graph, this)), i !== !1;
    }
    return typeof t == "boolean" ? t : !1;
  }
  cleanCache() {
    return this.cache.clean(), this;
  }
  getCache(e) {
    return this.cache.get(e);
  }
  getDataOfElement(e) {
    return this.cache.getData(e);
  }
  getMatrixOfElement(e) {
    return this.cache.getMatrix(e);
  }
  getShapeOfElement(e) {
    return this.cache.getShape(e);
  }
  getBoundingRectOfElement(e) {
    return this.cache.getBoundingRect(e);
  }
  getBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), i = this.getMatrixOfElement(e), r = this.getRootRotatedMatrix(), s = this.getRootTranslatedMatrix();
    return It.transformRectangle(t, s.multiply(r).multiply(i));
  }
  getUnrotatedBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), i = this.getMatrixOfElement(e), r = this.getRootTranslatedMatrix();
    return It.transformRectangle(t, r.multiply(i));
  }
  getBBox(e = {}) {
    let t;
    if (e.useCellGeometry) {
      const i = this.cell, r = i.isNode() ? i.getAngle() : 0;
      t = i.getBBox().bbox(r);
    } else
      t = this.getBBoxOfElement(this.container);
    return this.graph.coord.localToGraphRect(t);
  }
  getRootTranslatedMatrix() {
    const e = this.cell, t = e.isNode() ? e.getPosition() : { x: 0, y: 0 };
    return ci().translate(t.x, t.y);
  }
  getRootRotatedMatrix() {
    let e = ci();
    const t = this.cell, i = t.isNode() ? t.getAngle() : 0;
    if (i) {
      const r = t.getBBox(), s = r.width / 2, o = r.height / 2;
      e = e.translate(s, o).rotate(i).translate(-s, -o);
    }
    return e;
  }
  findMagnet(e = this.container) {
    return this.findByAttr("magnet", e);
  }
  updateAttrs(e, t, i = {}) {
    i.rootBBox == null && (i.rootBBox = new ye()), i.selectors == null && (i.selectors = this.selectors), this.attr.update(e, t, i);
  }
  isEdgeElement(e) {
    return this.cell.isEdge() && (e == null || e === this.container);
  }
  // #region highlight
  prepareHighlight(e, t = {}) {
    const i = e || this.container;
    return t.partial = i === this.container, i;
  }
  highlight(e, t = {}) {
    const i = this.prepareHighlight(e, t);
    return this.notify("cell:highlight", {
      magnet: i,
      options: t,
      view: this,
      cell: this.cell
    }), this.isEdgeView() ? this.notify("edge:highlight", {
      magnet: i,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }) : this.isNodeView() && this.notify("node:highlight", {
      magnet: i,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }), this;
  }
  unhighlight(e, t = {}) {
    const i = this.prepareHighlight(e, t);
    return this.notify("cell:unhighlight", {
      magnet: i,
      options: t,
      view: this,
      cell: this.cell
    }), this.isNodeView() ? this.notify("node:unhighlight", {
      magnet: i,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }) : this.isEdgeView() && this.notify("edge:unhighlight", {
      magnet: i,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }), this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  notifyUnhighlight(e, t) {
  }
  // #endregion
  getEdgeTerminal(e, t, i, r, s) {
    const o = this.cell, a = this.findAttr("port", e), l = e.getAttribute("data-selector"), c = { cell: o.id };
    return l != null && (c.magnet = l), a != null ? (c.port = a, o.isNode() && !o.hasPort(a) && l == null && (c.selector = this.getSelector(e))) : l == null && this.container !== e && (c.selector = this.getSelector(e)), c;
  }
  getMagnetFromEdgeTerminal(e) {
    const t = this.cell, i = this.container, r = e.port;
    let s = e.magnet, o;
    return r != null && t.isNode() && t.hasPort(r) ? o = this.findPortElem(r, s) || i : (s || (s = e.selector), !s && r != null && (s = `[port="${r}"]`), o = this.findOne(s, i, this.selectors)), o;
  }
  hasTools(e) {
    const t = this.tools;
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  addTools(e) {
    if (this.removeTools(), e) {
      if (!this.can("toolsAddable"))
        return this;
      const t = Bn.isToolsView(e) ? e : new Bn(e);
      this.tools = t, t.config({ view: this }), t.mount();
    }
    return this;
  }
  updateTools(e = {}) {
    return this.tools && this.tools.update(e), this;
  }
  removeTools() {
    return this.tools && (this.tools.remove(), this.tools = null), this;
  }
  hideTools() {
    return this.tools && this.tools.hide(), this;
  }
  showTools() {
    return this.tools && this.tools.show(), this;
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  notify(e, t) {
    return this.trigger(e, t), this.graph.trigger(e, t), this;
  }
  getEventArgs(e, t, i) {
    const r = this, s = r.cell;
    return t == null || i == null ? { e, view: r, cell: s } : { e, x: t, y: i, view: r, cell: s };
  }
  onClick(e, t, i) {
    this.notify("cell:click", this.getEventArgs(e, t, i));
  }
  onDblClick(e, t, i) {
    this.notify("cell:dblclick", this.getEventArgs(e, t, i));
  }
  onContextMenu(e, t, i) {
    this.notify("cell:contextmenu", this.getEventArgs(e, t, i));
  }
  onMouseDown(e, t, i) {
    this.cell.model && (this.cachedModelForMouseEvent = this.cell.model, this.cachedModelForMouseEvent.startBatch("mouse")), this.notify("cell:mousedown", this.getEventArgs(e, t, i));
  }
  onMouseUp(e, t, i) {
    this.notify("cell:mouseup", this.getEventArgs(e, t, i)), this.cachedModelForMouseEvent && (this.cachedModelForMouseEvent.stopBatch("mouse", { cell: this.cell }), this.cachedModelForMouseEvent = null);
  }
  onMouseMove(e, t, i) {
    this.notify("cell:mousemove", this.getEventArgs(e, t, i));
  }
  onMouseOver(e) {
    this.notify("cell:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    this.notify("cell:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    this.notify("cell:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    this.notify("cell:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, i, r) {
    this.notify("cell:mousewheel", Object.assign({ delta: r }, this.getEventArgs(e, t, i)));
  }
  onCustomEvent(e, t, i, r) {
    this.notify("cell:customevent", Object.assign({ name: t }, this.getEventArgs(e, i, r))), this.notify(t, Object.assign({}, this.getEventArgs(e, i, r)));
  }
  onMagnetMouseDown(e, t, i, r) {
  }
  onMagnetDblClick(e, t, i, r) {
  }
  onMagnetContextMenu(e, t, i, r) {
  }
  onLabelMouseDown(e, t, i) {
  }
  checkMouseleave(e) {
    const t = this.getEventTarget(e, { fromPoint: !0 }), i = this.graph.findViewByElem(t);
    i !== this && (this.onMouseLeave(e), i && i.onMouseEnter(e));
  }
  dispose() {
    this.cell.off("changed", this.onCellChanged, this);
  }
}
An.defaults = {
  isSvgElement: !0,
  rootSelector: "root",
  priority: 0,
  bootstrap: [],
  actions: {}
};
yre([
  An.dispose()
], An.prototype, "dispose", null);
(function(n) {
  n.Flag = CR, n.Attr = SR;
})(An || (An = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && typeof r.isNodeView == "function" && typeof r.isEdgeView == "function" && typeof r.confirmUpdate == "function";
  }
  n.isCellView = e;
})(An || (An = {}));
(function(n) {
  function e(i) {
    return function(r) {
      r.config({ priority: i });
    };
  }
  n.priority = e;
  function t(i) {
    return function(r) {
      r.config({ bootstrap: i });
    };
  }
  n.bootstrap = t;
})(An || (An = {}));
(function(n) {
  n.registry = $n.create({
    type: "view"
  });
})(An || (An = {}));
class Bn extends Rt {
  get name() {
    return this.options.name;
  }
  get graph() {
    return this.cellView.graph;
  }
  get cell() {
    return this.cellView.cell;
  }
  get [Symbol.toStringTag]() {
    return Bn.toStringTag;
  }
  constructor(e = {}) {
    super(), this.svgContainer = this.createContainer(!0, e), this.htmlContainer = this.createContainer(!1, e), this.config(e);
  }
  createContainer(e, t) {
    const i = e ? Rt.createElement("g", !0) : Rt.createElement("div", !1);
    return Ye(i, this.prefixClassName("cell-tools")), t.className && Ye(i, t.className), i;
  }
  config(e) {
    if (this.options = Object.assign(Object.assign({}, this.options), e), !An.isCellView(e.view) || e.view === this.cellView)
      return this;
    this.cellView = e.view, this.cell.isEdge() ? (Ye(this.svgContainer, this.prefixClassName("edge-tools")), Ye(this.htmlContainer, this.prefixClassName("edge-tools"))) : this.cell.isNode() && (Ye(this.svgContainer, this.prefixClassName("node-tools")), Ye(this.htmlContainer, this.prefixClassName("node-tools"))), this.svgContainer.setAttribute("data-cell-id", this.cell.id), this.htmlContainer.setAttribute("data-cell-id", this.cell.id), this.name && (this.svgContainer.setAttribute("data-tools-name", this.name), this.htmlContainer.setAttribute("data-tools-name", this.name));
    const t = this.options.items;
    if (!Array.isArray(t))
      return this;
    this.tools = [];
    const i = [];
    t.forEach((r) => {
      Bn.ToolItem.isToolItem(r) ? r.name === "vertices" ? i.unshift(r) : i.push(r) : (typeof r == "object" ? r.name : r) === "vertices" ? i.unshift(r) : i.push(r);
    });
    for (let r = 0; r < i.length; r += 1) {
      const s = i[r];
      let o;
      if (Bn.ToolItem.isToolItem(s))
        o = s;
      else {
        const a = typeof s == "object" ? s.name : s, l = typeof s == "object" ? s.args || {} : {};
        if (a) {
          if (this.cell.isNode()) {
            const c = Ru.registry.get(a);
            if (c)
              o = new c(l);
            else
              return Ru.registry.onNotFound(a);
          } else if (this.cell.isEdge()) {
            const c = Nu.registry.get(a);
            if (c)
              o = new c(l);
            else
              return Nu.registry.onNotFound(a);
          }
        }
      }
      o && (o.config(this.cellView, this), o.render(), (o.options.isSVGElement !== !1 ? this.svgContainer : this.htmlContainer).appendChild(o.container), this.tools.push(o));
    }
    return this;
  }
  update(e = {}) {
    const t = this.tools;
    return t && t.forEach((i) => {
      e.toolId !== i.cid && i.isVisible() && i.update();
    }), this;
  }
  focus(e) {
    const t = this.tools;
    return t && t.forEach((i) => {
      e === i ? i.show() : i.hide();
    }), this;
  }
  blur(e) {
    const t = this.tools;
    return t && t.forEach((i) => {
      i !== e && !i.isVisible() && (i.show(), i.update());
    }), this;
  }
  hide() {
    return this.focus(null);
  }
  show() {
    return this.blur(null);
  }
  remove() {
    const e = this.tools;
    return e && (e.forEach((t) => t.remove()), this.tools = null), ro(this.svgContainer), ro(this.htmlContainer), super.remove();
  }
  mount() {
    const e = this.tools, t = this.cellView;
    if (t && e) {
      const i = e.some((s) => s.options.isSVGElement !== !1), r = e.some((s) => s.options.isSVGElement === !1);
      i && (this.options.local ? t.container : t.graph.view.decorator).appendChild(this.svgContainer), r && this.graph.container.appendChild(this.htmlContainer);
    }
    return this;
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && r.graph != null && r.cell != null && typeof r.config == "function" && typeof r.update == "function" && typeof r.focus == "function" && typeof r.blur == "function" && typeof r.show == "function" && typeof r.hide == "function";
  }
  n.isToolsView = e;
})(Bn || (Bn = {}));
(function(n) {
  class e extends Rt {
    static getDefaults() {
      return this.defaults;
    }
    static config(i) {
      this.defaults = this.getOptions(i);
    }
    static getOptions(i) {
      return On(Bt(this.getDefaults()), i);
    }
    get graph() {
      return this.cellView.graph;
    }
    get cell() {
      return this.cellView.cell;
    }
    get name() {
      return this.options.name;
    }
    get [Symbol.toStringTag]() {
      return e.toStringTag;
    }
    constructor(i = {}) {
      super(), this.visible = !0, this.options = this.getOptions(i), this.container = Rt.createElement(this.options.tagName || "g", this.options.isSVGElement !== !1), Ye(this.container, this.prefixClassName("cell-tool")), typeof this.options.className == "string" && Ye(this.container, this.options.className), this.init();
    }
    init() {
    }
    getOptions(i) {
      return this.constructor.getOptions(i);
    }
    delegateEvents() {
      return this.options.events && super.delegateEvents(this.options.events), this;
    }
    config(i, r) {
      return this.cellView = i, this.parent = r, this.stamp(this.container), this.cell.isEdge() ? Ye(this.container, this.prefixClassName("edge-tool")) : this.cell.isNode() && Ye(this.container, this.prefixClassName("node-tool")), this.name && this.container.setAttribute("data-tool-name", this.name), this.delegateEvents(), this;
    }
    render() {
      this.empty();
      const i = this.options.markup;
      if (i) {
        const r = Yt.parseJSONMarkup(i);
        this.container.appendChild(r.fragment), this.childNodes = r.selectors;
      }
      return this.onRender(), this;
    }
    onRender() {
    }
    update() {
      return this;
    }
    stamp(i) {
      i && i.setAttribute("data-cell-id", this.cellView.cell.id);
    }
    show() {
      return this.container.style.display = "", this.visible = !0, this;
    }
    hide() {
      return this.container.style.display = "none", this.visible = !1, this;
    }
    isVisible() {
      return this.visible;
    }
    focus() {
      const i = this.options.focusOpacity;
      return i != null && Number.isFinite(i) && (this.container.style.opacity = `${i}`), this.parent.focus(this), this;
    }
    blur() {
      return this.container.style.opacity = "", this.parent.blur(this), this;
    }
    guard(i) {
      return this.graph == null || this.cellView == null ? !0 : this.graph.view.guard(i, this.cellView);
    }
  }
  e.defaults = {
    isSVGElement: !0,
    tagName: "g"
  }, n.ToolItem = e, function(t) {
    let i = 0;
    function r(o) {
      return o ? Iw(o) : (i += 1, `CustomTool${i}`);
    }
    function s(o) {
      const a = Dw(r(o.name), this);
      return a.config(o), a;
    }
    t.define = s;
  }(e = n.ToolItem || (n.ToolItem = {})), function(t) {
    t.toStringTag = `X6.${t.name}`;
    function i(r) {
      if (r == null)
        return !1;
      if (r instanceof t)
        return !0;
      const s = r[Symbol.toStringTag], o = r;
      return (s == null || s === t.toStringTag) && o.graph != null && o.cell != null && typeof o.config == "function" && typeof o.update == "function" && typeof o.focus == "function" && typeof o.blur == "function" && typeof o.show == "function" && typeof o.hide == "function" && typeof o.isVisible == "function";
    }
    t.isToolItem = i;
  }(e = n.ToolItem || (n.ToolItem = {}));
})(Bn || (Bn = {}));
const wre = (n) => n;
function Vk(n, e) {
  return e === 0 ? "0%" : `${Math.round(n / e * 100)}%`;
}
function kR(n) {
  return (t, i, r, s) => i.isEdgeElement(r) ? Sre(n, t, i, r, s) : xre(n, t, i, r, s);
}
function xre(n, e, t, i, r) {
  const s = t.cell, o = s.getAngle(), a = t.getUnrotatedBBoxOfElement(i), l = s.getBBox().getCenter(), c = z.create(r).rotate(o, l);
  let u = c.x - a.x, h = c.y - a.y;
  return n && (u = Vk(u, a.width), h = Vk(h, a.height)), e.anchor = {
    name: "topLeft",
    args: {
      dx: u,
      dy: h,
      rotate: !0
    }
  }, e;
}
function Sre(n, e, t, i, r) {
  const s = t.getConnection();
  if (!s)
    return e;
  const o = s.closestPointLength(r);
  if (n) {
    const a = s.length();
    e.anchor = {
      name: "ratio",
      args: {
        ratio: o / a
      }
    };
  } else
    e.anchor = {
      name: "length",
      args: {
        length: o
      }
    };
  return e;
}
const Cre = kR(!0), kre = kR(!1), Pre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  noop: wre,
  pinAbsolute: kre,
  pinRelative: Cre
}, Symbol.toStringTag, { value: "Module" }));
var Ky;
(function(n) {
  n.presets = Pre, n.registry = $n.create({
    type: "connection strategy"
  }), n.registry.register(n.presets, !0);
})(Ky || (Ky = {}));
function PR(n, e, t, i) {
  return Ze(Ky.presets.pinRelative, this.graph, {}, e, t, n, this.cell, i, {}).anchor;
}
function ER(n, e) {
  return e ? n.cell.getBBox() : n.cell.isEdge() ? n.getConnection().bbox() : n.getUnrotatedBBoxOfElement(n.container);
}
class ja extends Bn.ToolItem {
  onRender() {
    Ye(this.container, this.prefixClassName("cell-tool-button")), this.update();
  }
  update() {
    return this.updatePosition(), this;
  }
  updatePosition() {
    const t = this.cellView.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
    Eu(this.container, t, { absolute: !0 });
  }
  getNodeMatrix() {
    const e = this.cellView, t = this.options;
    let { x: i = 0, y: r = 0 } = t;
    const { offset: s, useCellGeometry: o, rotate: a } = t;
    let l = ER(e, o);
    const c = e.cell.getAngle();
    a || (l = l.bbox(c));
    let u = 0, h = 0;
    typeof s == "number" ? (u = s, h = s) : typeof s == "object" && (u = s.x, h = s.y), i = ys(i, l.width), r = ys(r, l.height);
    let d = ci().translate(l.x + l.width / 2, l.y + l.height / 2);
    return a && (d = d.rotate(c)), d = d.translate(i + u - l.width / 2, r + h - l.height / 2), d;
  }
  getEdgeMatrix() {
    const e = this.cellView, t = this.options, { offset: i = 0, distance: r = 0, rotate: s } = t;
    let o, a, l;
    const c = ys(r, 1);
    c >= 0 && c <= 1 ? o = e.getTangentAtRatio(c) : o = e.getTangentAtLength(c), o ? (a = o.start, l = o.vector().vectorAngle(new z(1, 0)) || 0) : (a = e.getConnection().start, l = 0);
    let u = ci().translate(a.x, a.y).rotate(l);
    return typeof i == "object" ? u = u.translate(i.x || 0, i.y || 0) : u = u.translate(0, i), s || (u = u.rotate(-l)), u;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.options.onClick;
    typeof t == "function" && Ze(t, this.cellView, {
      e,
      view: this.cellView,
      cell: this.cellView.cell,
      btn: this
    });
  }
}
(function(n) {
  n.config({
    name: "button",
    useCellGeometry: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    }
  });
})(ja || (ja = {}));
(function(n) {
  n.Remove = n.define({
    name: "button-remove",
    markup: [
      {
        tagName: "circle",
        selector: "button",
        attrs: {
          r: 7,
          fill: "#FF1D00",
          cursor: "pointer"
        }
      },
      {
        tagName: "path",
        selector: "icon",
        attrs: {
          d: "M -3 -3 3 3 M -3 3 3 -3",
          fill: "none",
          stroke: "#FFFFFF",
          "stroke-width": 2,
          "pointer-events": "none"
        }
      }
    ],
    distance: 60,
    offset: 0,
    useCellGeometry: !0,
    onClick({ view: e, btn: t }) {
      t.parent.remove(), e.cell.remove({ ui: !0, toolId: t.cid });
    }
  });
})(ja || (ja = {}));
var Ere = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class cm extends Bn.ToolItem {
  onRender() {
    if (Ye(this.container, this.prefixClassName("cell-tool-boundary")), this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, i = Ere(e, ["class"]);
      St(this.container, jd(i)), t && Ye(this.container, t);
    }
    this.update();
  }
  update() {
    const e = this.cellView, t = this.options, { useCellGeometry: i, rotate: r } = t, s = Xl(t.padding);
    let o = ER(e, i).moveAndExpand({
      x: -s.left,
      y: -s.top,
      width: s.left + s.right,
      height: s.top + s.bottom
    });
    const a = e.cell;
    if (a.isNode()) {
      const l = a.getAngle();
      if (l)
        if (r) {
          const c = a.getBBox().getCenter();
          qy(this.container, l, c.x, c.y, {
            absolute: !0
          });
        } else
          o = o.bbox(l);
    }
    return St(this.container, o.toJSON()), this;
  }
}
(function(n) {
  n.config({
    name: "boundary",
    tagName: "rect",
    padding: 10,
    useCellGeometry: !0,
    attrs: {
      fill: "none",
      stroke: "#333",
      "stroke-width": 0.5,
      "stroke-dasharray": "5, 5",
      "pointer-events": "none"
    }
  });
})(cm || (cm = {}));
class Wd extends Bn.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  onRender() {
    return this.addClass(this.prefixClassName("edge-tool-vertices")), this.options.addable && this.updatePath(), this.resetHandles(), this.renderHandles(), this;
  }
  update() {
    return this.vertices.length === this.handles.length ? this.updateHandles() : (this.resetHandles(), this.renderHandles()), this.options.addable && this.updatePath(), this;
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  renderHandles() {
    const e = this.vertices;
    for (let t = 0, i = e.length; t < i; t += 1) {
      const r = e[t], s = this.options.createHandle, o = this.options.processHandle, a = s({
        index: t,
        graph: this.graph,
        guard: (l) => this.guard(l),
        attrs: this.options.attrs || {}
      });
      o && o(a), a.updatePosition(r.x, r.y), this.stamp(a.container), this.container.appendChild(a.container), this.handles.push(a), this.startHandleListening(a);
    }
  }
  updateHandles() {
    const e = this.vertices;
    for (let t = 0, i = e.length; t < i; t += 1) {
      const r = e[t], s = this.handles[t];
      s && s.updatePosition(r.x, r.y);
    }
  }
  updatePath() {
    const e = this.childNodes.connection;
    e && e.setAttribute("d", this.cellView.getConnectionPathData());
  }
  startHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.on("remove", this.onHandleRemove, this);
  }
  stopHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.off("remove", this.onHandleRemove, this);
  }
  getNeighborPoints(e) {
    const t = this.cellView, i = this.vertices, r = e > 0 ? i[e - 1] : t.sourceAnchor, s = e < i.length - 1 ? i[e + 1] : t.targetAnchor;
    return {
      prev: z.create(r),
      next: z.create(s)
    };
  }
  getMouseEventArgs(e) {
    const t = this.normalizeEvent(e), { x: i, y: r } = this.graph.snapToGrid(t.clientX, t.clientY);
    return { e: t, x: i, y: r };
  }
  onHandleChange({ e }) {
    this.focus();
    const t = this.cellView;
    if (t.cell.startBatch("move-vertex", { ui: !0, toolId: this.cid }), !this.options.stopPropagation) {
      const { e: i, x: r, y: s } = this.getMouseEventArgs(e);
      this.eventData(i, { start: { x: r, y: s } }), t.notifyMouseDown(i, r, s);
    }
  }
  onHandleChanging({ handle: e, e: t }) {
    const i = this.cellView, r = e.options.index, { e: s, x: o, y: a } = this.getMouseEventArgs(t), l = { x: o, y: a };
    this.snapVertex(l, r), i.cell.setVertexAt(r, l, { ui: !0, toolId: this.cid }), e.updatePosition(l.x, l.y), this.options.stopPropagation || i.notifyMouseMove(s, o, a);
  }
  stopBatch(e) {
    this.cell.stopBatch("move-vertex", { ui: !0, toolId: this.cid }), e && this.cell.stopBatch("add-vertex", { ui: !0, toolId: this.cid });
  }
  onHandleChanged({ e }) {
    const t = this.options, i = this.cellView;
    if (t.addable && this.updatePath(), !t.removeRedundancies) {
      this.stopBatch(this.eventData(e).vertexAdded);
      return;
    }
    i.removeRedundantLinearVertices({
      ui: !0,
      toolId: this.cid
    }) && this.render(), this.blur(), this.stopBatch(this.eventData(e).vertexAdded);
    const { e: s, x: o, y: a } = this.getMouseEventArgs(e);
    if (!this.options.stopPropagation) {
      i.notifyMouseUp(s, o, a);
      const { start: l } = this.eventData(s);
      if (l) {
        const { x: c, y: u } = l;
        c === o && u === a && i.onClick(s, o, a);
      }
    }
    i.checkMouseleave(s), t.onChanged && t.onChanged({ edge: i.cell, edgeView: i });
  }
  snapVertex(e, t) {
    const i = this.options.snapRadius || 0;
    if (i > 0) {
      const r = this.getNeighborPoints(t), s = r.prev, o = r.next;
      Math.abs(e.x - s.x) < i ? e.x = s.x : Math.abs(e.x - o.x) < i && (e.x = o.x), Math.abs(e.y - s.y) < i ? e.y = r.prev.y : Math.abs(e.y - o.y) < i && (e.y = o.y);
    }
  }
  onHandleRemove({ handle: e, e: t }) {
    if (this.options.removable) {
      const i = e.options.index, r = this.cellView;
      r.cell.removeVertexAt(i, { ui: !0 }), this.options.addable && this.updatePath(), r.checkMouseleave(this.normalizeEvent(t));
    }
  }
  allowAddVertex(e) {
    const t = this.guard(e), i = this.options.addable && this.cellView.can("vertexAddable"), r = this.options.modifiers ? Ba.isMatch(e, this.options.modifiers) : !0;
    return !t && i && r;
  }
  onPathMouseDown(e) {
    const t = this.cellView;
    if (!this.allowAddVertex(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const i = this.normalizeEvent(e), r = this.graph.snapToGrid(i.clientX, i.clientY).toJSON();
    t.cell.startBatch("add-vertex", { ui: !0, toolId: this.cid });
    const s = t.getVertexIndex(r.x, r.y);
    this.snapVertex(r, s), t.cell.insertVertex(r, s, {
      ui: !0,
      toolId: this.cid
    }), this.render();
    const o = this.handles[s];
    this.eventData(i, { vertexAdded: !0 }), o.onMouseDown(i);
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(n) {
  class e extends Rt {
    get graph() {
      return this.options.graph;
    }
    constructor(i) {
      super(), this.options = i, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown",
        dblclick: "onDoubleClick"
      });
    }
    render() {
      this.container = Rt.createElement("circle", !0);
      const i = this.options.attrs;
      if (typeof i == "function") {
        const r = n.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, r.attrs), i(this)));
      } else
        this.setAttrs(i);
      this.addClass(this.prefixClassName("edge-tool-vertex"));
    }
    updatePosition(i, r) {
      this.setAttrs({ cx: i, cy: r });
    }
    onMouseDown(i) {
      this.options.guard(i) || (i.stopPropagation(), i.preventDefault(), this.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, i.data), this.emit("change", { e: i, handle: this }));
    }
    onMouseMove(i) {
      this.emit("changing", { e: i, handle: this });
    }
    onMouseUp(i) {
      this.emit("changed", { e: i, handle: this }), this.undelegateDocumentEvents(), this.graph.view.delegateEvents();
    }
    onDoubleClick(i) {
      this.emit("remove", { e: i, handle: this });
    }
  }
  n.Handle = e;
})(Wd || (Wd = {}));
(function(n) {
  const e = Jr.prefix("edge-tool-vertex-path");
  n.config({
    name: "vertices",
    snapRadius: 20,
    addable: !0,
    removable: !0,
    removeRedundancies: !0,
    stopPropagation: !0,
    attrs: {
      r: 6,
      fill: "#333",
      stroke: "#fff",
      cursor: "move",
      "stroke-width": 2
    },
    createHandle: (t) => new n.Handle(t),
    markup: [
      {
        tagName: "path",
        selector: "connection",
        className: e,
        attrs: {
          fill: "none",
          stroke: "transparent",
          "stroke-width": 10,
          cursor: "pointer"
        }
      }
    ],
    events: {
      [`mousedown .${e}`]: "onPathMouseDown",
      [`touchstart .${e}`]: "onPathMouseDown"
    }
  });
})(Wd || (Wd = {}));
class Hd extends Bn.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  update() {
    return this.render(), this;
  }
  onRender() {
    Ye(this.container, this.prefixClassName("edge-tool-segments")), this.resetHandles();
    const e = this.cellView, t = [...this.vertices];
    t.unshift(e.sourcePoint), t.push(e.targetPoint);
    for (let i = 0, r = t.length; i < r - 1; i += 1) {
      const s = t[i], o = t[i + 1], a = this.renderHandle(s, o, i);
      this.stamp(a.container), this.handles.push(a);
    }
    return this;
  }
  renderHandle(e, t, i) {
    const r = this.options.createHandle({
      index: i,
      graph: this.graph,
      guard: (s) => this.guard(s),
      attrs: this.options.attrs || {}
    });
    return this.options.processHandle && this.options.processHandle(r), this.updateHandle(r, e, t), this.container.appendChild(r.container), this.startHandleListening(r), r;
  }
  startHandleListening(e) {
    e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this);
  }
  stopHandleListening(e) {
    e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this);
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  shiftHandleIndexes(e) {
    const t = this.handles;
    for (let i = 0, r = t.length; i < r; i += 1)
      t[i].options.index += e;
  }
  resetAnchor(e, t) {
    const i = this.cellView.cell, r = {
      ui: !0,
      toolId: this.cid
    };
    t ? i.prop([e, "anchor"], t, r) : i.removeProp([e, "anchor"], r);
  }
  snapHandle(e, t, i) {
    const r = e.options.axis, s = e.options.index, l = this.cellView.cell.getVertices(), c = l[s - 2] || i.sourceAnchor, u = l[s + 1] || i.targetAnchor, h = this.options.snapRadius;
    return Math.abs(t[r] - c[r]) < h ? t[r] = c[r] : Math.abs(t[r] - u[r]) < h && (t[r] = u[r]), t;
  }
  onHandleChanging({ handle: e, e: t }) {
    const i = this.graph, r = this.options, s = this.cellView, o = r.anchor, a = e.options.axis, l = e.options.index - 1, c = this.getEventData(t), u = this.normalizeEvent(t), h = i.snapToGrid(u.clientX, u.clientY), d = this.snapHandle(e, h.clone(), c), f = Bt(this.vertices);
    let p = f[l], g = f[l + 1];
    const m = s.sourceView, v = s.sourceBBox;
    let y = !1, b = !1;
    if (p ? l === 0 ? v.containsPoint(p) ? (f.shift(), this.shiftHandleIndexes(-1), y = !0) : (p[a] = d[a], b = !0) : p[a] = d[a] : (p = s.sourceAnchor.toJSON(), p[a] = d[a], v.containsPoint(p) ? y = !0 : (f.unshift(p), this.shiftHandleIndexes(1), b = !0)), typeof o == "function" && m) {
      if (y) {
        const k = c.sourceAnchor.clone();
        k[a] = d[a];
        const E = Ze(o, s, k, m, s.sourceMagnet || m.container, "source", s, this);
        this.resetAnchor("source", E);
      }
      b && this.resetAnchor("source", c.sourceAnchorDef);
    }
    const w = s.targetView, x = s.targetBBox;
    let S = !1, C = !1;
    if (g ? l === f.length - 2 ? x.containsPoint(g) ? (f.pop(), S = !0) : (g[a] = d[a], C = !0) : g[a] = d[a] : (g = s.targetAnchor.toJSON(), g[a] = d[a], x.containsPoint(g) ? S = !0 : (f.push(g), C = !0)), typeof o == "function" && w) {
      if (S) {
        const k = c.targetAnchor.clone();
        k[a] = d[a];
        const E = Ze(o, s, k, w, s.targetMagnet || w.container, "target", s, this);
        this.resetAnchor("target", E);
      }
      C && this.resetAnchor("target", c.targetAnchorDef);
    }
    z.equalPoints(f, this.vertices) || this.cellView.cell.setVertices(f, { ui: !0, toolId: this.cid }), this.updateHandle(e, p, g, 0), r.stopPropagation || s.notifyMouseMove(u, h.x, h.y);
  }
  onHandleChange({ handle: e, e: t }) {
    const i = this.options, r = this.handles, s = this.cellView, o = e.options.index;
    if (Array.isArray(r)) {
      for (let a = 0, l = r.length; a < l; a += 1)
        a !== o && r[a].hide();
      if (this.focus(), this.setEventData(t, {
        sourceAnchor: s.sourceAnchor.clone(),
        targetAnchor: s.targetAnchor.clone(),
        sourceAnchorDef: Bt(this.cell.prop(["source", "anchor"])),
        targetAnchorDef: Bt(this.cell.prop(["target", "anchor"]))
      }), this.cell.startBatch("move-segment", { ui: !0, toolId: this.cid }), !i.stopPropagation) {
        const a = this.normalizeEvent(t), l = this.graph.snapToGrid(a.clientX, a.clientY);
        s.notifyMouseDown(a, l.x, l.y);
      }
    }
  }
  onHandleChanged({ e }) {
    const t = this.options, i = this.cellView;
    t.removeRedundancies && i.removeRedundantLinearVertices({ ui: !0, toolId: this.cid });
    const r = this.normalizeEvent(e), s = this.graph.snapToGrid(r.clientX, r.clientY);
    this.render(), this.blur(), this.cell.stopBatch("move-segment", { ui: !0, toolId: this.cid }), t.stopPropagation || i.notifyMouseUp(r, s.x, s.y), i.checkMouseleave(r), t.onChanged && t.onChanged({ edge: i.cell, edgeView: i });
  }
  updateHandle(e, t, i, r = 0) {
    const s = this.options.precision || 0, o = Math.abs(t.x - i.x) < s, a = Math.abs(t.y - i.y) < s;
    if (o || a) {
      const l = new Ie(t, i);
      if (l.length() < this.options.threshold)
        e.hide();
      else {
        const u = l.getCenter(), h = o ? "x" : "y";
        u[h] += r || 0;
        const d = l.vector().vectorAngle(new z(1, 0));
        e.updatePosition(u.x, u.y, d, this.cellView), e.show(), e.options.axis = h;
      }
    } else
      e.hide();
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(n) {
  class e extends Rt {
    constructor(i) {
      super(), this.options = i, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      });
    }
    render() {
      this.container = Rt.createElement("rect", !0);
      const i = this.options.attrs;
      if (typeof i == "function") {
        const r = n.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, r.attrs), i(this)));
      } else
        this.setAttrs(i);
      this.addClass(this.prefixClassName("edge-tool-segment"));
    }
    updatePosition(i, r, s, o) {
      const a = o.getClosestPoint(new z(i, r)) || new z(i, r);
      let l = ci().translate(a.x, a.y);
      if (a.equals({ x: i, y: r }))
        l = l.rotate(s);
      else {
        let u = new Ie(i, r, a.x, a.y).vector().vectorAngle(new z(1, 0));
        u !== 0 && (u += 90), l = l.rotate(u);
      }
      this.setAttrs({
        transform: gh(l),
        cursor: s % 180 === 0 ? "row-resize" : "col-resize"
      });
    }
    onMouseDown(i) {
      this.options.guard(i) || (this.trigger("change", { e: i, handle: this }), i.stopPropagation(), i.preventDefault(), this.options.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, i.data));
    }
    onMouseMove(i) {
      this.emit("changing", { e: i, handle: this });
    }
    onMouseUp(i) {
      this.emit("changed", { e: i, handle: this }), this.undelegateDocumentEvents(), this.options.graph.view.delegateEvents();
    }
    show() {
      this.container.style.display = "";
    }
    hide() {
      this.container.style.display = "none";
    }
  }
  n.Handle = e;
})(Hd || (Hd = {}));
(function(n) {
  n.config({
    name: "segments",
    precision: 0.5,
    threshold: 40,
    snapRadius: 10,
    stopPropagation: !0,
    removeRedundancies: !0,
    attrs: {
      width: 20,
      height: 8,
      x: -10,
      y: -4,
      rx: 4,
      ry: 4,
      fill: "#333",
      stroke: "#fff",
      "stroke-width": 2
    },
    createHandle: (e) => new n.Handle(e),
    anchor: PR
  });
})(Hd || (Hd = {}));
class um extends Bn.ToolItem {
  get type() {
    return this.options.type;
  }
  onRender() {
    Ye(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`)), this.toggleArea(!1), this.update();
  }
  update() {
    const e = this.type;
    return this.cellView.getTerminalView(e) ? (this.updateAnchor(), this.updateArea(), this.container.style.display = "") : this.container.style.display = "none", this;
  }
  updateAnchor() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.anchor;
    if (!t)
      return;
    const i = this.type, r = this.cellView, s = this.options, o = r.getTerminalAnchor(i), a = r.cell.prop([i, "anchor"]);
    t.setAttribute("transform", `translate(${o.x}, ${o.y})`);
    const l = a ? s.customAnchorAttrs : s.defaultAnchorAttrs;
    l && Object.keys(l).forEach((c) => {
      t.setAttribute(c, l[c]);
    });
  }
  updateArea() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.area;
    if (!t)
      return;
    const i = this.type, r = this.cellView, s = r.getTerminalView(i);
    if (s) {
      const o = s.cell, a = r.getTerminalMagnet(i);
      let l = this.options.areaPadding || 0;
      Number.isFinite(l) || (l = 0);
      let c, u, h;
      s.isEdgeElement(a) ? (c = s.getBBox(), u = 0, h = c.getCenter()) : (c = s.getUnrotatedBBoxOfElement(a), u = o.getAngle(), h = c.getCenter(), u && h.rotate(-u, o.getBBox().getCenter())), c.inflate(l), St(t, {
        x: -c.width / 2,
        y: -c.height / 2,
        width: c.width,
        height: c.height,
        transform: `translate(${h.x}, ${h.y}) rotate(${u})`
      });
    }
  }
  toggleArea(e) {
    if (this.childNodes) {
      const t = this.childNodes.area;
      t && (t.style.display = e ? "" : "none");
    }
  }
  onMouseDown(e) {
    this.guard(e) || (e.stopPropagation(), e.preventDefault(), this.graph.view.undelegateEvents(), this.options.documentEvents && this.delegateDocumentEvents(this.options.documentEvents), this.focus(), this.toggleArea(this.options.restrictArea), this.cell.startBatch("move-anchor", {
      ui: !0,
      toolId: this.cid
    }));
  }
  resetAnchor(e) {
    const t = this.type, i = this.cell;
    e ? i.prop([t, "anchor"], e, {
      rewrite: !0,
      ui: !0,
      toolId: this.cid
    }) : i.removeProp([t, "anchor"], {
      ui: !0,
      toolId: this.cid
    });
  }
  onMouseMove(e) {
    const t = this.type, i = this.cellView, r = i.getTerminalView(t);
    if (r == null)
      return;
    const s = this.normalizeEvent(e), o = r.cell, a = i.getTerminalMagnet(t);
    let l = this.graph.coord.clientToLocalPoint(s.clientX, s.clientY);
    const c = this.options.snap;
    if (typeof c == "function") {
      const d = Ze(c, i, l, r, a, t, i, this);
      l = z.create(d);
    }
    if (this.options.restrictArea)
      if (r.isEdgeElement(a)) {
        const d = r.getClosestPoint(l);
        d && (l = d);
      } else {
        const d = r.getUnrotatedBBoxOfElement(a), f = o.getAngle(), p = o.getBBox().getCenter(), g = l.clone().rotate(f, p);
        d.containsPoint(g) || (l = d.getNearestPointToPoint(g).rotate(-f, p));
      }
    let u;
    const h = this.options.anchor;
    typeof h == "function" && (u = Ze(h, i, l, r, a, t, i, this)), this.resetAnchor(u), this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMouseUp(e) {
    this.graph.view.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleArea(!1);
    const t = this.cellView;
    this.options.removeRedundancies && t.removeRedundantLinearVertices({ ui: !0, toolId: this.cid }), this.cell.stopBatch("move-anchor", { ui: !0, toolId: this.cid });
  }
  onDblClick() {
    const e = this.options.resetAnchor;
    e && this.resetAnchor(e === !0 ? void 0 : e), this.update();
  }
}
(function(n) {
  n.config({
    tagName: "g",
    markup: [
      {
        tagName: "circle",
        selector: "anchor",
        attrs: {
          cursor: "pointer"
        }
      },
      {
        tagName: "rect",
        selector: "area",
        attrs: {
          "pointer-events": "none",
          fill: "none",
          stroke: "#33334F",
          "stroke-dasharray": "2,4",
          rx: 5,
          ry: 5
        }
      }
    ],
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown",
      dblclick: "onDblClick"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    },
    customAnchorAttrs: {
      "stroke-width": 4,
      stroke: "#33334F",
      fill: "#FFFFFF",
      r: 5
    },
    defaultAnchorAttrs: {
      "stroke-width": 2,
      stroke: "#FFFFFF",
      fill: "#33334F",
      r: 6
    },
    areaPadding: 6,
    snapRadius: 10,
    resetAnchor: !0,
    restrictArea: !0,
    removeRedundancies: !0,
    anchor: PR,
    snap(e, t, i, r, s, o) {
      const a = o.options.snapRadius || 0, l = r === "source", c = l ? 0 : -1, u = this.cell.getVertexAt(c) || this.getTerminalAnchor(l ? "target" : "source");
      return u && (Math.abs(u.x - e.x) < a && (e.x = u.x), Math.abs(u.y - e.y) < a && (e.y = u.y)), e;
    }
  });
})(um || (um = {}));
const Are = um.define({
  name: "source-anchor",
  type: "source"
}), $re = um.define({
  name: "target-anchor",
  type: "target"
});
var Tre = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class hm extends Bn.ToolItem {
  get type() {
    return this.options.type;
  }
  get ratio() {
    return this.options.ratio;
  }
  init() {
    if (this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, i = Tre(e, ["class"]);
      this.setAttrs(i, this.container), t && Ye(this.container, t);
    }
  }
  onRender() {
    Ye(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`)), this.update();
  }
  update() {
    const e = this.ratio, t = this.cellView, i = t.getTangentAtRatio(e), r = i ? i.start : t.getPointAtRatio(e), s = i && i.vector().vectorAngle(new z(1, 0)) || 0;
    if (!r)
      return this;
    const o = ci().translate(r.x, r.y).rotate(s);
    return Eu(this.container, o, { absolute: !0 }), this;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.cellView;
    if (t.can("arrowheadMovable")) {
      t.cell.startBatch("move-arrowhead", {
        ui: !0,
        toolId: this.cid
      });
      const i = this.graph.snapToGrid(e.clientX, e.clientY), r = t.prepareArrowheadDragging(this.type, {
        x: i.x,
        y: i.y,
        options: Object.assign(Object.assign({}, this.options), { toolId: this.cid })
      });
      this.cellView.setEventData(e, r), this.delegateDocumentEvents(this.options.documentEvents, e.data), t.graph.view.undelegateEvents(), this.container.style.pointerEvents = "none";
    }
    this.focus();
  }
  onMouseMove(e) {
    const t = this.normalizeEvent(e), i = this.graph.snapToGrid(t.clientX, t.clientY);
    this.cellView.onMouseMove(t, i.x, i.y), this.update();
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), i = this.cellView, r = this.graph.snapToGrid(t.clientX, t.clientY);
    i.onMouseUp(t, r.x, r.y), this.graph.view.delegateEvents(), this.blur(), this.container.style.pointerEvents = "", i.cell.stopBatch("move-arrowhead", {
      ui: !0,
      toolId: this.cid
    });
  }
}
(function(n) {
  n.config({
    tagName: "path",
    isSVGElement: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    }
  });
})(hm || (hm = {}));
const _re = hm.define({
  name: "source-arrowhead",
  type: "source",
  ratio: 0,
  attrs: {
    d: "M 10 -8 -10 0 10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
}), Mre = hm.define({
  name: "target-arrowhead",
  type: "target",
  ratio: 1,
  attrs: {
    d: "M -10 -8 10 0 -10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});
class Mu extends Bn.ToolItem {
  constructor() {
    super(...arguments), this.labelIndex = -1, this.distance = 0.5, this.dblClick = this.onCellDblClick.bind(this);
  }
  onRender() {
    const e = this.cellView;
    e && e.on("cell:dblclick", this.dblClick);
  }
  createElement() {
    const e = [
      this.prefixClassName(`${this.cell.isEdge() ? "edge" : "node"}-tool-editor`),
      this.prefixClassName("cell-tool-editor")
    ];
    this.editor = Bn.createElement("div", !1), this.addClass(e, this.editor), this.editor.contentEditable = "true", this.container.appendChild(this.editor);
  }
  removeElement() {
    this.undelegateDocumentEvents(), this.editor && (this.container.removeChild(this.editor), this.editor = null);
  }
  updateEditor() {
    const { cell: e, editor: t } = this;
    if (!t)
      return;
    const { style: i } = t;
    e.isNode() ? this.updateNodeEditorTransform() : e.isEdge() && this.updateEdgeEditorTransform();
    const { attrs: r } = this.options;
    i.fontSize = `${r.fontSize}px`, i.fontFamily = r.fontFamily, i.color = r.color, i.backgroundColor = r.backgroundColor;
    const s = this.getCellText() || "";
    return t.innerText = s, this.setCellText(""), this;
  }
  updateNodeEditorTransform() {
    const { graph: e, cell: t, editor: i } = this;
    if (!i)
      return;
    let r = z.create(), s = 20, o = "", { x: a, y: l } = this.options;
    const { width: c, height: u } = this.options;
    if (typeof a < "u" && typeof l < "u") {
      const f = t.getBBox();
      a = ys(a, f.width), l = ys(l, f.height), r = f.topLeft.translate(a, l), s = f.width - a * 2;
    } else {
      const f = t.getBBox();
      r = f.center, s = f.width - 4, o = "translate(-50%, -50%)";
    }
    const h = e.scale(), { style: d } = i;
    r = e.localToGraph(r), d.left = `${r.x}px`, d.top = `${r.y}px`, d.transform = `scale(${h.sx}, ${h.sy}) ${o}`, d.minWidth = `${s}px`, typeof c == "number" && (d.width = `${c}px`), typeof u == "number" && (d.height = `${u}px`);
  }
  updateEdgeEditorTransform() {
    if (!this.event)
      return;
    const { graph: e, editor: t } = this;
    if (!t)
      return;
    let i = z.create(), r = 20;
    const { style: s } = t, o = this.event.target, a = o.parentElement;
    if (a && ph(a, this.prefixClassName("edge-label"))) {
      const u = a.getAttribute("data-index") || "0";
      this.labelIndex = parseInt(u, 10);
      const h = a.getAttribute("transform"), { translation: d } = Cv(h);
      i = new z(d.tx, d.ty), r = It.getBBox(o).width;
    } else {
      if (!this.options.labelAddable)
        return this;
      i = e.clientToLocal(z.create(this.event.clientX, this.event.clientY));
      const h = this.cellView.path.closestPointLength(i);
      this.distance = h, this.labelIndex = -1;
    }
    i = e.localToGraph(i);
    const c = e.scale();
    s.left = `${i.x}px`, s.top = `${i.y}px`, s.minWidth = `${r}px`, s.transform = `scale(${c.sx}, ${c.sy}) translate(-50%, -50%)`;
  }
  onDocumentMouseUp(e) {
    if (this.editor && e.target !== this.editor) {
      const t = this.editor.innerText.replace(/\n$/, "") || "";
      this.setCellText(t !== "" ? t : null), this.removeElement();
    }
  }
  onCellDblClick({ e }) {
    this.editor || (e.stopPropagation(), this.removeElement(), this.event = e, this.createElement(), this.updateEditor(), this.autoFocus(), this.delegateDocumentEvents(this.options.documentEvents));
  }
  onMouseDown(e) {
    e.stopPropagation();
  }
  autoFocus() {
    setTimeout(() => {
      this.editor && (this.editor.focus(), this.selectText());
    });
  }
  selectText() {
    if (window.getSelection && this.editor) {
      const e = document.createRange(), t = window.getSelection();
      e.selectNodeContents(this.editor), t.removeAllRanges(), t.addRange(e);
    }
  }
  getCellText() {
    const { getText: e } = this.options;
    if (typeof e == "function")
      return Ze(e, this.cellView, {
        cell: this.cell,
        index: this.labelIndex
      });
    if (typeof e == "string") {
      if (this.cell.isNode())
        return this.cell.attr(e);
      if (this.cell.isEdge() && this.labelIndex !== -1)
        return this.cell.prop(`labels/${this.labelIndex}/attrs/${e}`);
    }
  }
  setCellText(e) {
    const t = this.options.setText;
    if (typeof t == "function") {
      Ze(t, this.cellView, {
        cell: this.cell,
        value: e,
        index: this.labelIndex,
        distance: this.distance
      });
      return;
    }
    if (typeof t == "string") {
      if (this.cell.isNode()) {
        e !== null && this.cell.attr(t, e);
        return;
      }
      if (this.cell.isEdge()) {
        const i = this.cell;
        if (this.labelIndex === -1) {
          if (e) {
            const r = {
              position: {
                distance: this.distance
              },
              attrs: {}
            };
            fh(r, `attrs/${t}`, e), i.appendLabel(r);
          }
        } else
          e !== null ? i.prop(`labels/${this.labelIndex}/attrs/${t}`, e) : typeof this.labelIndex == "number" && i.removeLabelAt(this.labelIndex);
      }
    }
  }
  onRemove() {
    const e = this.cellView;
    e && e.off("cell:dblclick", this.dblClick), this.removeElement();
  }
}
(function(n) {
  n.config({
    tagName: "div",
    isSVGElement: !1,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mouseup: "onDocumentMouseUp",
      touchend: "onDocumentMouseUp",
      touchcancel: "onDocumentMouseUp"
    }
  });
})(Mu || (Mu = {}));
(function(n) {
  n.NodeEditor = n.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    getText: "text/text",
    setText: "text/text"
  }), n.EdgeEditor = n.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    labelAddable: !0,
    getText: "label/text",
    setText: "label/text"
  });
})(Mu || (Mu = {}));
var AR = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}, Ru;
(function(n) {
  n.presets = {
    boundary: cm,
    button: ja,
    "button-remove": ja.Remove,
    "node-editor": Mu.NodeEditor
  }, n.registry = $n.create({
    type: "node tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let i = Bn.ToolItem;
      const { inherit: r } = t, s = AR(t, ["inherit"]);
      if (r) {
        const o = this.get(r);
        o == null ? this.onNotFound(r, "inherited") : i = o;
      }
      return s.name == null && (s.name = e), i.define.call(i, s);
    }
  }), n.registry.register(n.presets, !0);
})(Ru || (Ru = {}));
var Nu;
(function(n) {
  n.presets = {
    boundary: cm,
    vertices: Wd,
    segments: Hd,
    button: ja,
    "button-remove": ja.Remove,
    "source-anchor": Are,
    "target-anchor": $re,
    "source-arrowhead": _re,
    "target-arrowhead": Mre,
    "edge-editor": Mu.EdgeEditor
  }, n.registry = $n.create({
    type: "edge tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let i = Bn.ToolItem;
      const { inherit: r } = t, s = AR(t, ["inherit"]);
      if (r) {
        const o = this.get(r);
        o == null ? this.onNotFound(r, "inherited") : i = o;
      }
      return s.name == null && (s.name = e), i.define.call(i, s);
    }
  }), n.registry.register(n.presets, !0);
})(Nu || (Nu = {}));
const Rre = ta("center"), Nre = ta("topCenter"), Dre = ta("bottomCenter"), Lre = ta("leftMiddle"), Ire = ta("rightMiddle"), Bre = ta("topLeft"), Qre = ta("topRight"), zre = ta("bottomLeft"), jre = ta("bottomRight");
function ta(n) {
  return function(e, t, i, r = {}) {
    const s = r.rotate ? e.getUnrotatedBBoxOfElement(t) : e.getBBoxOfElement(t), o = s[n];
    o.x += ys(r.dx, s.width), o.y += ys(r.dy, s.height);
    const a = e.cell;
    return r.rotate ? o.rotate(-a.getAngle(), a.getBBox().getCenter()) : o;
  };
}
function Tv(n) {
  return function(e, t, i, r) {
    if (i instanceof Element) {
      const s = this.graph.findViewByElem(i);
      let o;
      if (s)
        if (s.isEdgeElement(i)) {
          const a = r.fixedAt != null ? r.fixedAt : "50%";
          o = $R(s, a);
        } else
          o = s.getBBoxOfElement(i).getCenter();
      else
        o = new z();
      return n.call(this, e, t, o, r);
    }
    return n.apply(this, arguments);
  };
}
function $R(n, e) {
  const t = qo(e), i = typeof e == "string" ? parseFloat(e) : e;
  return t ? n.getPointAtRatio(i / 100) : n.getPointAtLength(i);
}
const Vre = function(n, e, t, i) {
  const r = Pt.normalize(n.cell.getAngle()), s = n.getBBoxOfElement(e), o = s.getCenter(), a = s.getTopLeft(), l = s.getBottomRight();
  let c = i.padding;
  if (Number.isFinite(c) || (c = 0), a.y + c <= t.y && t.y <= l.y - c) {
    const u = t.y - o.y;
    o.x += r === 0 || r === 180 ? 0 : u * 1 / Math.tan(Pt.toRad(r)), o.y += u;
  } else if (a.x + c <= t.x && t.x <= l.x - c) {
    const u = t.x - o.x;
    o.y += r === 90 || r === 270 ? 0 : u * Math.tan(Pt.toRad(r)), o.x += u;
  }
  return o;
}, Fre = Tv(Vre), Zre = function(n, e, t, i, r) {
  const s = n.cell.getConnectionPoint(this.cell, r);
  return (i.dx || i.dy) && s.translate(i.dx || 0, i.dy || 0), s;
}, qre = function(n, e, t, i) {
  let r, s = 0, o;
  const a = n.cell;
  i.rotate ? (r = n.getUnrotatedBBoxOfElement(e), o = a.getBBox().getCenter(), s = a.getAngle()) : r = n.getBBoxOfElement(e);
  const l = i.padding;
  l != null && Number.isFinite(l) && r.inflate(l), i.rotate && t.rotate(s, o);
  const c = r.getNearestSideToPoint(t);
  let u;
  switch (c) {
    case "left":
      u = r.getLeftMiddle();
      break;
    case "right":
      u = r.getRightMiddle();
      break;
    case "top":
      u = r.getTopCenter();
      break;
    case "bottom":
      u = r.getBottomCenter();
      break;
  }
  const h = i.direction;
  return h === "H" ? (c === "top" || c === "bottom") && (t.x <= r.x + r.width ? u = r.getLeftMiddle() : u = r.getRightMiddle()) : h === "V" && (t.y <= r.y + r.height ? u = r.getTopCenter() : u = r.getBottomCenter()), i.rotate ? u.rotate(-s, o) : u;
}, Wre = Tv(qre), Hre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: Dre,
  bottomLeft: zre,
  bottomRight: jre,
  center: Rre,
  left: Lre,
  midSide: Wre,
  nodeCenter: Zre,
  orth: Fre,
  right: Ire,
  top: Nre,
  topLeft: Bre,
  topRight: Qre
}, Symbol.toStringTag, { value: "Module" }));
var Du;
(function(n) {
  n.presets = Hre, n.registry = $n.create({
    type: "node endpoint"
  }), n.registry.register(n.presets, !0);
})(Du || (Du = {}));
const Xre = function(n, e, t, i) {
  let r = i.ratio != null ? i.ratio : 0.5;
  return r > 1 && (r /= 100), n.getPointAtRatio(r);
}, Yre = function(n, e, t, i) {
  const r = i.length != null ? i.length : 20;
  return n.getPointAtLength(r);
}, TR = function(n, e, t, i) {
  const r = n.getClosestPoint(t);
  return r ?? new z();
}, Ure = Tv(TR), Gre = function(n, e, t, i) {
  const s = n.getConnection(), o = n.getConnectionSubdivisions(), a = new Ie(t.clone().translate(0, 1e6), t.clone().translate(0, -1e6)), l = new Ie(t.clone().translate(1e6, 0), t.clone().translate(-1e6, 0)), c = a.intersect(s, {
    segmentSubdivisions: o
  }), u = l.intersect(s, {
    segmentSubdivisions: o
  }), h = [];
  return c && h.push(...c), u && h.push(...u), h.length > 0 ? t.closest(h) : i.fallbackAt != null ? $R(n, i.fallbackAt) : Ze(TR, this, n, e, t, i);
}, Kre = Tv(Gre), Jre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closest: Ure,
  length: Yre,
  orth: Kre,
  ratio: Xre
}, Symbol.toStringTag, { value: "Module" }));
var Lu;
(function(n) {
  n.presets = Jre, n.registry = $n.create({
    type: "edge endpoint"
  }), n.registry.register(n.presets, !0);
})(Lu || (Lu = {}));
function _v(n, e, t) {
  let i;
  if (typeof t == "object") {
    if (Number.isFinite(t.y)) {
      const s = new Ie(e, n), { start: o, end: a } = s.parallel(t.y);
      e = o, n = a;
    }
    i = t.x;
  } else
    i = t;
  if (i == null || !Number.isFinite(i))
    return n;
  const r = n.distance(e);
  return i === 0 && r > 0 ? n : n.move(e, -Math.min(i, r - 1));
}
function dm(n) {
  const e = n.getAttribute("stroke-width");
  return e === null ? 0 : parseFloat(e) || 0;
}
function ese(n) {
  if (n == null)
    return null;
  let e = n;
  do {
    let t = e.tagName;
    if (typeof t != "string")
      return null;
    if (t = t.toUpperCase(), t === "G")
      e = e.firstElementChild;
    else if (t === "TITLE")
      e = e.nextElementSibling;
    else
      break;
  } while (e);
  return e;
}
const _R = function(n, e, t, i) {
  const r = e.getBBoxOfElement(t);
  i.stroked && r.inflate(dm(t) / 2);
  const s = n.intersect(r), o = s && s.length ? n.start.closest(s) : n.end;
  return _v(o, n.start, i.offset);
}, tse = function(n, e, t, i, r) {
  const s = e.cell, o = s.isNode() ? s.getAngle() : 0;
  if (o === 0)
    return Ze(_R, this, n, e, t, i, r);
  const a = e.getUnrotatedBBoxOfElement(t);
  i.stroked && a.inflate(dm(t) / 2);
  const l = a.getCenter(), c = n.clone().rotate(o, l), u = c.setLength(1e6).intersect(a), h = u && u.length ? c.start.closest(u).rotate(-o, l) : n.end;
  return _v(h, n.start, i.offset);
}, nse = function(n, e, t, i) {
  let r, s;
  const o = n.end, a = i.selector;
  if (typeof a == "string" ? r = e.findOne(a) : Array.isArray(a) ? r = Lw(t, a) : r = ese(t), !Ia(r)) {
    if (r === t || !Ia(t))
      return o;
    r = t;
  }
  const l = e.getShapeOfElement(r), c = e.getMatrixOfElement(r), u = e.getRootTranslatedMatrix(), h = e.getRootRotatedMatrix(), d = u.multiply(h).multiply(c), f = d.inverse(), p = It.transformLine(n, f), g = p.start.clone(), m = e.getDataOfElement(r);
  if (i.insideout === !1) {
    m.shapeBBox == null && (m.shapeBBox = l.bbox());
    const w = m.shapeBBox;
    if (w != null && w.containsPoint(g))
      return o;
  }
  i.extrapolate === !0 && p.setLength(1e6);
  let v;
  if (Be.isPath(l)) {
    const w = i.precision || 2;
    m.segmentSubdivisions == null && (m.segmentSubdivisions = l.getSegmentSubdivisions({
      precision: w
    })), v = {
      precision: w,
      segmentSubdivisions: m.segmentSubdivisions
    }, s = p.intersect(l, v);
  } else
    s = p.intersect(l);
  s ? Array.isArray(s) && (s = g.closest(s)) : i.sticky === !0 && (ye.isRectangle(l) ? s = l.getNearestPointToPoint(g) : xs.isEllipse(l) ? s = l.intersectsWithLineFromCenterToPoint(g) : s = l.closestPoint(g, v));
  const y = s ? It.transformPoint(s, d) : o;
  let b = i.offset || 0;
  return i.stroked !== !1 && (typeof b == "object" ? (b = Object.assign({}, b), b.x == null && (b.x = 0), b.x += dm(r) / 2) : b += dm(r) / 2), _v(y, n.start, b);
};
function ise(n, e, t = 0) {
  const { start: i, end: r } = n;
  let s, o, a, l;
  switch (e) {
    case "left":
      l = "x", s = r, o = i, a = -1;
      break;
    case "right":
      l = "x", s = i, o = r, a = 1;
      break;
    case "top":
      l = "y", s = r, o = i, a = -1;
      break;
    case "bottom":
      l = "y", s = i, o = r, a = 1;
      break;
    default:
      return;
  }
  i[l] < r[l] ? s[l] = o[l] : o[l] = s[l], Number.isFinite(t) && (s[l] += a * t, o[l] += a * t);
}
const rse = function(n, e, t, i) {
  const { alignOffset: r, align: s } = i;
  return s && ise(n, s, r), _v(n.end, n.start, i.offset);
}, sse = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  anchor: rse,
  bbox: _R,
  boundary: nse,
  rect: tse
}, Symbol.toStringTag, { value: "Module" }));
var Iu;
(function(n) {
  n.presets = sse, n.registry = $n.create({
    type: "connection point"
  }), n.registry.register(n.presets, !0);
})(Iu || (Iu = {}));
const ose = function(n) {
  return [...n];
}, ase = function(n, e, t) {
  const i = e.side || "bottom", r = Xl(e.padding || 40), s = t.sourceBBox, o = t.targetBBox, a = s.getCenter(), l = o.getCenter();
  let c, u, h;
  switch (i) {
    case "top":
      h = -1, c = "y", u = "height";
      break;
    case "left":
      h = -1, c = "x", u = "width";
      break;
    case "right":
      h = 1, c = "x", u = "width";
      break;
    case "bottom":
    default:
      h = 1, c = "y", u = "height";
      break;
  }
  return a[c] += h * (s[u] / 2 + r[i]), l[c] += h * (o[u] / 2 + r[i]), h * (a[c] - l[c]) > 0 ? l[c] = a[c] : a[c] = l[c], [a.toJSON(), ...n, l.toJSON()];
};
function vp(n) {
  return new ye(n.x, n.y, 0, 0);
}
function fm(n = {}) {
  const e = Xl(n.padding || 20);
  return {
    x: -e.left,
    y: -e.top,
    width: e.left + e.right,
    height: e.top + e.bottom
  };
}
function MR(n, e = {}) {
  return n.sourceBBox.clone().moveAndExpand(fm(e));
}
function RR(n, e = {}) {
  return n.targetBBox.clone().moveAndExpand(fm(e));
}
function lse(n, e = {}) {
  return n.sourceAnchor ? n.sourceAnchor : MR(n, e).getCenter();
}
function cse(n, e = {}) {
  return n.targetAnchor ? n.targetAnchor : RR(n, e).getCenter();
}
const NR = function(n, e, t) {
  let i = MR(t, e), r = RR(t, e);
  const s = lse(t, e), o = cse(t, e);
  i = i.union(vp(s)), r = r.union(vp(o));
  const a = n.map((u) => z.create(u));
  a.unshift(s), a.push(o);
  let l = null;
  const c = [];
  for (let u = 0, h = a.length - 1; u < h; u += 1) {
    let d = null;
    const f = a[u], p = a[u + 1], g = Lr.getBearing(f, p) != null;
    if (u === 0)
      u + 1 === h ? i.intersectsWithRect(r.clone().inflate(1)) ? d = Lr.insideNode(f, p, i, r) : g || (d = Lr.nodeToNode(f, p, i, r)) : i.containsPoint(p) ? d = Lr.insideNode(f, p, i, vp(p).moveAndExpand(fm(e))) : g || (d = Lr.nodeToVertex(f, p, i));
    else if (u + 1 === h) {
      const m = g && Lr.getBearing(p, f) === l;
      r.containsPoint(f) || m ? d = Lr.insideNode(f, p, vp(f).moveAndExpand(fm(e)), r, l) : g || (d = Lr.vertexToNode(f, p, r, l));
    } else
      g || (d = Lr.vertexToVertex(f, p, l));
    d ? (c.push(...d.points), l = d.direction) : l = Lr.getBearing(f, p), u + 1 < h && c.push(p);
  }
  return c;
};
var Lr;
(function(n) {
  const e = {
    N: "S",
    S: "N",
    E: "W",
    W: "E"
  }, t = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  function i(h, d, f) {
    let p = new z(h.x, d.y);
    return f.containsPoint(p) && (p = new z(d.x, h.y)), p;
  }
  function r(h, d) {
    return h[d === "W" || d === "E" ? "width" : "height"];
  }
  n.getBBoxSize = r;
  function s(h, d) {
    return h.x === d.x ? h.y > d.y ? "N" : "S" : h.y === d.y ? h.x > d.x ? "W" : "E" : null;
  }
  n.getBearing = s;
  function o(h, d, f) {
    const p = new z(h.x, d.y), g = new z(d.x, h.y), m = s(h, p), v = s(h, g), y = f ? e[f] : null, b = m === f || m !== y && (v === y || v !== f) ? p : g;
    return { points: [b], direction: s(b, d) };
  }
  n.vertexToVertex = o;
  function a(h, d, f) {
    const p = i(h, d, f);
    return { points: [p], direction: s(p, d) };
  }
  n.nodeToVertex = a;
  function l(h, d, f, p) {
    const g = [new z(h.x, d.y), new z(d.x, h.y)], m = g.filter((b) => !f.containsPoint(b)), v = m.filter((b) => s(b, h) !== p);
    let y;
    if (v.length > 0)
      return y = v.filter((b) => s(h, b) === p).pop(), y = y || v[0], {
        points: [y],
        direction: s(y, d)
      };
    {
      y = gz(g, m)[0];
      const b = z.create(d).move(y, -r(f, p) / 2);
      return {
        points: [i(b, h, f), b],
        direction: s(b, d)
      };
    }
  }
  n.vertexToNode = l;
  function c(h, d, f, p) {
    let g = a(d, h, p);
    const m = g.points[0];
    if (f.containsPoint(m)) {
      g = a(h, d, f);
      const v = g.points[0];
      if (p.containsPoint(v)) {
        const y = z.create(h).move(v, -r(f, s(h, v)) / 2), b = z.create(d).move(m, -r(p, s(d, m)) / 2), w = new Ie(y, b).getCenter(), x = a(h, w, f), S = o(w, d, x.direction);
        g.points = [x.points[0], S.points[0]], g.direction = S.direction;
      }
    }
    return g;
  }
  n.nodeToNode = c;
  function u(h, d, f, p, g) {
    const m = f.union(p).inflate(1), v = m.getCenter(), y = v.distance(d) > v.distance(h), b = y ? d : h, w = y ? h : d;
    let x, S, C;
    g ? (x = z.fromPolar(m.width + m.height, t[g], b), x = m.getNearestPointToPoint(x).move(x, -1)) : x = m.getNearestPointToPoint(b).move(b, 1), S = i(x, w, m);
    let k;
    x.round().equals(S.round()) ? (S = z.fromPolar(m.width + m.height, Pt.toRad(x.theta(b)) + Math.PI / 2, w), S = m.getNearestPointToPoint(S).move(w, 1).round(), C = i(x, S, m), k = y ? [S, C, x] : [x, C, S]) : k = y ? [S, x] : [x, S];
    const E = s(y ? x : S, d);
    return {
      points: k,
      direction: E
    };
  }
  n.insideNode = u;
})(Lr || (Lr = {}));
const use = {
  step: 10,
  maxLoopCount: 2e3,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: !0,
  excludeTerminals: [],
  excludeNodes: [],
  excludeShapes: [],
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    top: { x: 0, y: -1 },
    right: { x: 1, y: 0 },
    bottom: { x: 0, y: 1 },
    left: { x: -1, y: 0 }
  },
  cost() {
    return Oa(this.step, this);
  },
  directions() {
    const n = Oa(this.step, this), e = Oa(this.cost, this);
    return [
      { cost: e, offsetX: n, offsetY: 0 },
      { cost: e, offsetX: -n, offsetY: 0 },
      { cost: e, offsetX: 0, offsetY: n },
      { cost: e, offsetX: 0, offsetY: -n }
    ];
  },
  penalties() {
    const n = Oa(this.step, this);
    return {
      0: 0,
      45: n / 2,
      90: n / 2
    };
  },
  paddingBox() {
    const n = Oa(this.step, this);
    return {
      x: -n,
      y: -n,
      width: 2 * n,
      height: 2 * n
    };
  },
  fallbackRouter: NR,
  draggingRouter: null,
  snapToGrid: !0
};
function Oa(n, e) {
  return typeof n == "function" ? n.call(e) : n;
}
function hse(n) {
  const e = Object.keys(n).reduce((t, i) => {
    const r = t;
    return i === "fallbackRouter" || i === "draggingRouter" || i === "fallbackRoute" ? r[i] = n[i] : r[i] = Oa(n[i], n), t;
  }, {});
  if (e.padding) {
    const t = Xl(e.padding);
    e.paddingBox = {
      x: -t.left,
      y: -t.top,
      width: t.left + t.right,
      height: t.top + t.bottom
    };
  }
  return e.directions.forEach((t) => {
    const i = new z(0, 0), r = new z(t.offsetX, t.offsetY);
    t.angle = Pt.normalize(i.theta(r));
  }), e;
}
const Fk = 1, Zk = 2;
class dse {
  constructor() {
    this.items = [], this.hash = {}, this.values = {};
  }
  add(e, t) {
    this.hash[e] ? this.items.splice(this.items.indexOf(e), 1) : this.hash[e] = Fk, this.values[e] = t;
    const i = oj(this.items, e, (r) => this.values[r]);
    this.items.splice(i, 0, e);
  }
  pop() {
    const e = this.items.shift();
    return e && (this.hash[e] = Zk), e;
  }
  isOpen(e) {
    return this.hash[e] === Fk;
  }
  isClose(e) {
    return this.hash[e] === Zk;
  }
  isEmpty() {
    return this.items.length === 0;
  }
}
class fse {
  constructor(e) {
    this.options = e, this.mapGridSize = 100, this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */
  build(e, t) {
    const i = this.options, r = i.excludeTerminals.reduce((c, u) => {
      const h = t[u];
      if (h) {
        const d = e.getCell(h.cell);
        d && c.push(d);
      }
      return c;
    }, []);
    let s = [];
    const o = e.getCell(t.getSourceCellId());
    o && (s = FS(s, o.getAncestors().map((c) => c.id)));
    const a = e.getCell(t.getTargetCellId());
    a && (s = FS(s, a.getAncestors().map((c) => c.id)));
    const l = this.mapGridSize;
    return e.getNodes().reduce((c, u) => {
      const h = r.some((m) => m.id === u.id), d = u.shape ? i.excludeShapes.includes(u.shape) : !1, f = i.excludeNodes.some((m) => typeof m == "string" ? u.id === m : m === u), p = s.includes(u.id), g = d || h || f || p;
      if (u.isVisible() && !g) {
        const m = u.getBBox().moveAndExpand(i.paddingBox), v = m.getOrigin().snapToGrid(l), y = m.getCorner().snapToGrid(l);
        for (let b = v.x; b <= y.x; b += l)
          for (let w = v.y; w <= y.y; w += l) {
            const x = new z(b, w).toString();
            c[x] == null && (c[x] = []), c[x].push(m);
          }
      }
      return c;
    }, this.map), this;
  }
  isAccessible(e) {
    const t = e.clone().snapToGrid(this.mapGridSize).toString(), i = this.map[t];
    return i ? i.every((r) => !r.containsPoint(e)) : !0;
  }
}
function DR(n, e) {
  const t = n.sourceBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function LR(n, e) {
  const t = n.targetBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function IR(n, e) {
  return n.sourceAnchor ? n.sourceAnchor : DR(n, e).getCenter();
}
function pse(n, e) {
  return n.targetAnchor ? n.targetAnchor : LR(n, e).getCenter();
}
function Q0(n, e, t, i, r) {
  const s = 360 / t, o = n.theta(gse(n, e, i, r)), a = Pt.normalize(o + s / 2);
  return s * Math.floor(a / s);
}
function gse(n, e, t, i) {
  const r = i.step, s = e.x - n.x, o = e.y - n.y, a = s / t.x, l = o / t.y, c = a * r, u = l * r;
  return new z(n.x + c, n.y + u);
}
function qk(n, e) {
  const t = Math.abs(n - e);
  return t > 180 ? 360 - t : t;
}
function mse(n, e) {
  const t = e.step;
  return e.directions.forEach((i) => {
    i.gridOffsetX = i.offsetX / t * n.x, i.gridOffsetY = i.offsetY / t * n.y;
  }), e.directions;
}
function vse(n, e, t) {
  return {
    source: e.clone(),
    x: Wk(t.x - e.x, n),
    y: Wk(t.y - e.y, n)
  };
}
function Wk(n, e) {
  if (!n)
    return e;
  const t = Math.abs(n), i = Math.round(t / e);
  if (!i)
    return t;
  const r = i * e, o = (t - r) / i;
  return e + o;
}
function bse(n, e) {
  const t = e.source, i = At.snapToGrid(n.x - t.x, e.x) + t.x, r = At.snapToGrid(n.y - t.y, e.y) + t.y;
  return new z(i, r);
}
function Vh(n, e) {
  return n.round(e);
}
function Og(n, e, t) {
  return Vh(bse(n.clone(), e), t);
}
function pd(n) {
  return n.toString();
}
function z0(n) {
  return new z(n.x === 0 ? 0 : Math.abs(n.x) / n.x, n.y === 0 ? 0 : Math.abs(n.y) / n.y);
}
function Hk(n, e) {
  let t = 1 / 0;
  for (let i = 0, r = e.length; i < r; i += 1) {
    const s = n.manhattanDistance(e[i]);
    s < t && (t = s);
  }
  return t;
}
function Xk(n, e, t, i, r) {
  const s = r.precision, o = r.directionMap, a = n.diff(e.getCenter()), l = Object.keys(o).reduce((c, u) => {
    if (t.includes(u)) {
      const h = o[u], d = new z(n.x + h.x * (Math.abs(a.x) + e.width), n.y + h.y * (Math.abs(a.y) + e.height)), p = new Ie(n, d).intersect(e) || [];
      let g, m = null;
      for (let v = 0; v < p.length; v += 1) {
        const y = p[v], b = n.squaredDistance(y);
        (g == null || b > g) && (g = b, m = y);
      }
      if (m) {
        let v = Og(m, i, s);
        e.containsPoint(v) && (v = Og(v.translate(h.x * i.x, h.y * i.y), i, s)), c.push(v);
      }
    }
    return c;
  }, []);
  return e.containsPoint(n) || l.push(Og(n, i, s)), l;
}
function yse(n, e, t, i, r) {
  const s = [];
  let o = z0(r.diff(t)), a = pd(t), l = n[a], c;
  for (; l; ) {
    c = e[a];
    const d = z0(c.diff(l));
    d.equals(o) || (s.unshift(c), o = d), a = pd(l), l = n[a];
  }
  const u = e[a];
  return z0(u.diff(i)).equals(o) || s.unshift(u), s;
}
function Ose(n, e, t, i, r) {
  const s = r.precision;
  let o, a;
  ye.isRectangle(e) ? o = Vh(IR(n, r).clone(), s) : o = Vh(e.clone(), s), ye.isRectangle(t) ? a = Vh(pse(n, r).clone(), s) : a = Vh(t.clone(), s);
  const l = vse(r.step, o, a), c = o, u = a;
  let h, d;
  if (ye.isRectangle(e) ? h = Xk(c, e, r.startDirections, l, r) : h = [c], ye.isRectangle(t) ? d = Xk(a, t, r.endDirections, l, r) : d = [u], h = h.filter((f) => i.isAccessible(f)), d = d.filter((f) => i.isAccessible(f)), h.length > 0 && d.length > 0) {
    const f = new dse(), p = {}, g = {}, m = {};
    for (let M = 0, _ = h.length; M < _; M += 1) {
      const T = h[M], B = pd(T);
      f.add(B, Hk(T, d)), p[B] = T, m[B] = 0;
    }
    const v = r.previousDirectionAngle, y = v === void 0;
    let b, w;
    const x = mse(l, r), S = x.length, C = d.reduce((M, _) => {
      const T = pd(_);
      return M.push(T), M;
    }, []), k = z.equalPoints(h, d);
    let E = r.maxLoopCount;
    for (; !f.isEmpty() && E > 0; ) {
      const M = f.pop(), _ = p[M], T = g[M], B = m[M], I = _.equals(c), P = T == null;
      let A;
      if (P ? y ? I ? A = null : A = Q0(c, _, S, l, r) : A = v : A = Q0(T, _, S, l, r), !(P && k) && C.indexOf(M) >= 0)
        return r.previousDirectionAngle = A, yse(g, p, _, c, u);
      for (let q = 0; q < S; q += 1) {
        b = x[q];
        const j = b.angle;
        if (w = qk(A, j), !(y && I) && w > r.maxDirectionChange)
          continue;
        const H = Og(_.clone().translate(b.gridOffsetX || 0, b.gridOffsetY || 0), l, s), oe = pd(H);
        if (f.isClose(oe) || !i.isAccessible(H))
          continue;
        if (C.indexOf(oe) >= 0 && !H.equals(u)) {
          const he = Q0(H, u, S, l, r);
          if (qk(j, he) > r.maxDirectionChange)
            continue;
        }
        const te = b.cost, W = I ? 0 : r.penalties[w], U = B + te + W;
        (!f.isOpen(oe) || U < m[oe]) && (p[oe] = H, g[oe] = _, m[oe] = U, f.add(oe, U + Hk(H, d)));
      }
      E -= 1;
    }
  }
  return r.fallbackRoute ? Ze(r.fallbackRoute, this, c, u, r) : null;
}
function wse(n, e = 10) {
  if (n.length <= 1)
    return n;
  for (let t = 0, i = n.length; t < i - 1; t += 1) {
    const r = n[t], s = n[t + 1];
    if (r.x === s.x) {
      const o = e * Math.round(r.x / e);
      r.x !== o && (r.x = o, s.x = o);
    } else if (r.y === s.y) {
      const o = e * Math.round(r.y / e);
      r.y !== o && (r.y = o, s.y = o);
    }
  }
  return n;
}
const xse = function(n, e, t) {
  const i = hse(e), r = DR(t, i), s = LR(t, i), o = IR(t, i), a = new fse(i).build(t.graph.model, t.cell), l = n.map((f) => z.create(f)), c = [];
  let u = o, h, d;
  for (let f = 0, p = l.length; f <= p; f += 1) {
    let g = null;
    if (h = d || r, d = l[f], d == null) {
      d = s;
      const v = t.cell;
      if ((v.getSourceCellId() == null || v.getTargetCellId() == null) && typeof i.draggingRouter == "function") {
        const b = h === r ? o : h, w = d.getOrigin();
        g = Ze(i.draggingRouter, t, b, w, i);
      }
    }
    if (g == null && (g = Ose(t, h, d, a, i)), g === null)
      return console.warn("Unable to execute manhattan algorithm, use orth instead"), Ze(i.fallbackRouter, this, n, i, t);
    const m = g[0];
    m && m.equals(u) && g.shift(), u = g[g.length - 1] || u, c.push(...g);
  }
  return i.snapToGrid ? wse(c, t.graph.grid.getGridSize()) : c;
}, BR = function(n, e, t) {
  return Ze(xse, this, n, Object.assign(Object.assign({}, use), e), t);
}, Sse = {
  maxDirectionChange: 45,
  // an array of directions to find next points on the route
  // different from start/end directions
  directions() {
    const n = Oa(this.step, this), e = Oa(this.cost, this), t = Math.ceil(Math.sqrt(n * n << 1));
    return [
      { cost: e, offsetX: n, offsetY: 0 },
      { cost: t, offsetX: n, offsetY: n },
      { cost: e, offsetX: 0, offsetY: n },
      { cost: t, offsetX: -n, offsetY: n },
      { cost: e, offsetX: -n, offsetY: 0 },
      { cost: t, offsetX: -n, offsetY: -n },
      { cost: e, offsetX: 0, offsetY: -n },
      { cost: t, offsetX: n, offsetY: -n }
    ];
  },
  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute(n, e, t) {
    const i = n.theta(e), r = [];
    let s = { x: e.x, y: n.y }, o = { x: n.x, y: e.y };
    if (i % 180 > 90) {
      const b = s;
      s = o, o = b;
    }
    const a = i % 90 < 45 ? s : o, l = new Ie(n, a), c = 90 * Math.ceil(i / 90), u = z.fromPolar(l.squaredLength(), Pt.toRad(c + 135), a), h = new Ie(e, u), d = l.intersectsWithLine(h), f = d || e, p = d ? f : n, g = 360 / t.directions.length, m = p.theta(e), v = Pt.normalize(m + g / 2), y = g * Math.floor(v / g);
    return t.previousDirectionAngle = y, f && r.push(f.round()), r.push(e), r;
  }
}, Cse = function(n, e, t) {
  return Ze(BR, this, n, Object.assign(Object.assign({}, Sse), e), t);
}, kse = function(n, e, t) {
  const i = e.offset || 32, r = e.min == null ? 16 : e.min;
  let s = 0, o = e.direction;
  const a = t.sourceBBox, l = t.targetBBox, c = a.getCenter(), u = l.getCenter();
  if (typeof i == "number" && (s = i), o == null) {
    let v = l.left - a.right, y = l.top - a.bottom;
    v >= 0 && y >= 0 ? o = v >= y ? "L" : "T" : v <= 0 && y >= 0 ? (v = a.left - l.right, v >= 0 ? o = v >= y ? "R" : "T" : o = "T") : v >= 0 && y <= 0 ? (y = a.top - l.bottom, y >= 0 ? o = v >= y ? "L" : "B" : o = "L") : (v = a.left - l.right, y = a.top - l.bottom, v >= 0 && y >= 0 ? o = v >= y ? "R" : "B" : v <= 0 && y >= 0 ? o = "B" : v >= 0 && y <= 0 ? o = "R" : o = Math.abs(v) > Math.abs(y) ? "R" : "B");
  }
  o === "H" ? o = u.x - c.x >= 0 ? "L" : "R" : o === "V" && (o = u.y - c.y >= 0 ? "T" : "B"), i === "center" && (o === "L" ? s = (l.left - a.right) / 2 : o === "R" ? s = (a.left - l.right) / 2 : o === "T" ? s = (l.top - a.bottom) / 2 : o === "B" && (s = (a.top - l.bottom) / 2));
  let h, d, f;
  const p = o === "L" || o === "R";
  if (p) {
    if (u.y === c.y)
      return [...n];
    f = o === "L" ? 1 : -1, h = "x", d = "width";
  } else {
    if (u.x === c.x)
      return [...n];
    f = o === "T" ? 1 : -1, h = "y", d = "height";
  }
  const g = c.clone(), m = u.clone();
  if (g[h] += f * (a[d] / 2 + s), m[h] -= f * (l[d] / 2 + s), p) {
    const v = g.x, y = m.x, b = a.width / 2 + r, w = l.width / 2 + r;
    u.x > c.x ? y <= v && (g.x = Math.max(y, c.x + b), m.x = Math.min(v, u.x - w)) : y >= v && (g.x = Math.min(y, c.x - b), m.x = Math.max(v, u.x + w));
  } else {
    const v = g.y, y = m.y, b = a.height / 2 + r, w = l.height / 2 + r;
    u.y > c.y ? y <= v && (g.y = Math.max(y, c.y + b), m.y = Math.min(v, u.y - w)) : y >= v && (g.y = Math.min(y, c.y - b), m.y = Math.max(v, u.y + w));
  }
  return [g.toJSON(), ...n, m.toJSON()];
};
function Cc(n, e) {
  if (e != null && e !== !1) {
    const t = typeof e == "boolean" ? 0 : e;
    if (t > 0) {
      const i = z.create(n[1]).move(n[2], t), r = z.create(n[1]).move(n[0], t);
      return [i.toJSON(), ...n, r.toJSON()];
    }
    {
      const i = n[1];
      return [Object.assign({}, i), ...n, Object.assign({}, i)];
    }
  }
  return n;
}
const Pse = function(n, e, t) {
  const i = e.width || 50, s = (e.height || 80) / 2, o = e.angle || "auto", a = t.sourceAnchor, l = t.targetAnchor, c = t.sourceBBox, u = t.targetBBox;
  if (a.equals(l)) {
    const h = (v) => {
      const y = Pt.toRad(v), b = Math.sin(y), w = Math.cos(y), x = new z(a.x + w * i, a.y + b * i), S = new z(x.x - w * s, x.y - b * s), C = S.clone().rotate(-90, x), k = S.clone().rotate(90, x);
      return [C.toJSON(), x.toJSON(), k.toJSON()];
    }, d = (v) => {
      const y = a.clone().move(v, -1), b = new Ie(y, v);
      return !c.containsPoint(v) && !c.intersectsWithLine(b);
    }, f = [0, 90, 180, 270, 45, 135, 225, 315];
    if (typeof o == "number")
      return Cc(h(o), e.merge);
    const p = c.getCenter();
    if (p.equals(a))
      return Cc(h(0), e.merge);
    const g = p.angleBetween(a, p.clone().translate(1, 0));
    let m = h(g);
    if (d(m[1]))
      return Cc(m, e.merge);
    for (let v = 1, y = f.length; v < y; v += 1)
      if (m = h(g + f[v]), d(m[1]))
        return Cc(m, e.merge);
    return Cc(m, e.merge);
  }
  {
    const h = new Ie(a, l);
    let d = h.parallel(-i), f = d.getCenter(), p = d.start.clone().move(d.end, s), g = d.end.clone().move(d.start, s);
    const m = h.parallel(-1), v = new Ie(m.start, f), y = new Ie(m.end, f);
    if ((c.containsPoint(f) || u.containsPoint(f) || c.intersectsWithLine(v) || c.intersectsWithLine(y) || u.intersectsWithLine(v) || u.intersectsWithLine(y)) && (d = h.parallel(i), f = d.getCenter(), p = d.start.clone().move(d.end, s), g = d.end.clone().move(d.start, s)), e.merge) {
      const b = new Ie(a, l), w = new Ie(f, b.center).setLength(Number.MAX_SAFE_INTEGER), x = c.intersectsWithLine(w), S = u.intersectsWithLine(w), C = x ? Array.isArray(x) ? x : [x] : [];
      S && (Array.isArray(S) ? C.push(...S) : C.push(S));
      const k = b.center.closest(C);
      k ? (t.sourceAnchor = k.clone(), t.targetAnchor = k.clone()) : (t.sourceAnchor = b.center.clone(), t.targetAnchor = b.center.clone());
    }
    return Cc([p.toJSON(), f.toJSON(), g.toJSON()], e.merge);
  }
}, Ese = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  er: kse,
  loop: Pse,
  manhattan: BR,
  metro: Cse,
  normal: ose,
  oneSide: ase,
  orth: NR
}, Symbol.toStringTag, { value: "Module" }));
var Pa;
(function(n) {
  n.presets = Ese, n.registry = $n.create({
    type: "router"
  }), n.registry.register(n.presets, !0);
})(Pa || (Pa = {}));
const Ase = function(n, e, t, i = {}) {
  const r = [n, ...t, e], s = new En(r), o = new Be(s);
  return i.raw ? o : o.serialize();
}, $se = function(n, e, t, i = {}) {
  const r = t.length === 3 ? 0 : 1, s = z.create(t[0 + r]), o = z.create(t[2 + r]), a = z.create(t[1 + r]);
  if (!z.equals(n, e)) {
    const c = new z((n.x + e.x) / 2, (n.y + e.y) / 2), u = c.angleBetween(z.create(n).rotate(90, c), a);
    u > 1 && (s.rotate(180 - u, c), o.rotate(180 - u, c), a.rotate(180 - u, c));
  }
  const l = `
     M ${n.x} ${n.y}
     Q ${s.x} ${s.y} ${a.x} ${a.y}
     Q ${o.x} ${o.y} ${e.x} ${e.y}
  `;
  return i.raw ? Be.parse(l) : l;
}, Tse = function(n, e, t, i = {}) {
  const r = new Be();
  r.appendSegment(Be.createSegment("M", n));
  const s = 1 / 3, o = 2 / 3, a = i.radius || 10;
  let l, c;
  for (let u = 0, h = t.length; u < h; u += 1) {
    const d = z.create(t[u]), f = t[u - 1] || n, p = t[u + 1] || e;
    l = c || d.distance(f) / 2, c = d.distance(p) / 2;
    const g = -Math.min(a, l), m = -Math.min(a, c), v = d.clone().move(f, g).round(), y = d.clone().move(p, m).round(), b = new z(s * v.x + o * d.x, o * d.y + s * v.y), w = new z(s * y.x + o * d.x, o * d.y + s * y.y);
    r.appendSegment(Be.createSegment("L", v)), r.appendSegment(Be.createSegment("C", b, w, y));
  }
  return r.appendSegment(Be.createSegment("L", e)), i.raw ? r : r.serialize();
}, _se = function(n, e, t, i = {}) {
  let r, s = i.direction;
  if (t && t.length !== 0) {
    const o = [n, ...t, e], a = yn.throughPoints(o);
    r = new Be(a);
  } else if (r = new Be(), r.appendSegment(Be.createSegment("M", n)), s || (s = Math.abs(n.x - e.x) >= Math.abs(n.y - e.y) ? "H" : "V"), s === "H") {
    const o = (n.x + e.x) / 2;
    r.appendSegment(Be.createSegment("C", o, n.y, o, e.y, e.x, e.y));
  } else {
    const o = (n.y + e.y) / 2;
    r.appendSegment(Be.createSegment("C", n.x, o, e.x, o, e.x, e.y));
  }
  return i.raw ? r : r.serialize();
}, Yk = 1, bp = 1 / 3, yp = 2 / 3;
function Mse(n) {
  let e = n.graph._jumpOverUpdateList;
  if (e == null && (e = n.graph._jumpOverUpdateList = [], n.graph.on("cell:mouseup", () => {
    const t = n.graph._jumpOverUpdateList;
    setTimeout(() => {
      for (let i = 0; i < t.length; i += 1)
        t[i].update();
    });
  }), n.graph.on("model:reseted", () => {
    e = n.graph._jumpOverUpdateList = [];
  })), e.indexOf(n) < 0) {
    e.push(n);
    const t = () => e.splice(e.indexOf(n), 1);
    n.cell.once("change:connector", t), n.cell.once("removed", t);
  }
}
function j0(n, e, t = []) {
  const i = [n, ...t, e], r = [];
  return i.forEach((s, o) => {
    const a = i[o + 1];
    a != null && r.push(new Ie(s, a));
  }), r;
}
function Rse(n, e) {
  const t = [];
  return e.forEach((i) => {
    const r = n.intersectsWithLine(i);
    r && t.push(r);
  }), t;
}
function Uk(n, e) {
  return new Ie(n, e).squaredLength();
}
function Nse(n, e, t) {
  return e.reduce((i, r, s) => {
    if (pm.includes(r))
      return i;
    const o = i.pop() || n, a = z.create(r).move(o.start, -t);
    let l = z.create(r).move(o.start, +t);
    const c = e[s + 1];
    if (c != null) {
      const d = l.distance(c);
      d <= t && (l = c.move(o.start, d), pm.push(c));
    } else if (a.distance(o.end) < t * 2 + Yk)
      return i.push(o), i;
    if (l.distance(o.start) < t * 2 + Yk)
      return i.push(o), i;
    const h = new Ie(a, l);
    return Xd.push(h), i.push(new Ie(o.start, a), h, new Ie(l, o.end)), i;
  }, []);
}
function Gk(n, e, t, i) {
  const r = new Be();
  let s;
  return s = Be.createSegment("M", n[0].start), r.appendSegment(s), n.forEach((o, a) => {
    if (Xd.includes(o)) {
      let l, c, u, h;
      if (t === "arc") {
        l = -90, c = o.start.diff(o.end), (c.x < 0 || c.x === 0 && c.y < 0) && (l += 180);
        const f = o.getCenter(), p = new Ie(f, o.end).rotate(l, f);
        let g;
        g = new Ie(o.start, f), u = g.pointAt(2 / 3).rotate(l, o.start), h = p.pointAt(1 / 3).rotate(-l, p.end), s = Be.createSegment("C", u, h, p.end), r.appendSegment(s), g = new Ie(f, o.end), u = p.pointAt(1 / 3).rotate(l, p.end), h = g.pointAt(1 / 3).rotate(-l, o.end), s = Be.createSegment("C", u, h, o.end), r.appendSegment(s);
      } else if (t === "gap")
        s = Be.createSegment("M", o.end), r.appendSegment(s);
      else if (t === "cubic") {
        l = o.start.theta(o.end);
        const d = e * 0.6;
        let f = e * 1.35;
        c = o.start.diff(o.end), (c.x < 0 || c.x === 0 && c.y < 0) && (f *= -1), u = new z(o.start.x + d, o.start.y + f).rotate(l, o.start), h = new z(o.end.x - d, o.end.y + f).rotate(l, o.end), s = Be.createSegment("C", u, h, o.end), r.appendSegment(s);
      }
    } else {
      const l = n[a + 1];
      i === 0 || !l || Xd.includes(l) ? (s = Be.createSegment("L", o.end), r.appendSegment(s)) : Dse(i, r, o.end, o.start, l.end);
    }
  }), r;
}
function Dse(n, e, t, i, r) {
  const s = t.distance(i) / 2, o = t.distance(r) / 2, a = -Math.min(n, s), l = -Math.min(n, o), c = t.clone().move(i, a).round(), u = t.clone().move(r, l).round(), h = new z(bp * c.x + yp * t.x, yp * t.y + bp * c.y), d = new z(bp * u.x + yp * t.x, yp * t.y + bp * u.y);
  let f;
  f = Be.createSegment("L", c), e.appendSegment(f), f = Be.createSegment("C", h, d, u), e.appendSegment(f);
}
let Xd, pm;
const Lse = function(n, e, t, i = {}) {
  Xd = [], pm = [], Mse(this);
  const r = i.size || 5, s = i.type || "arc", o = i.radius || 0, a = i.ignoreConnectors || ["smooth"], l = this.graph, u = l.model.getEdges();
  if (u.length === 1)
    return Gk(j0(n, e, t), r, s, o);
  const h = this.cell, d = u.indexOf(h), f = l.options.connecting.connector || {}, p = u.filter((w, x) => {
    const S = w.getConnector() || f;
    return a.includes(S.name) ? !1 : x > d ? S.name !== "jumpover" : !0;
  }), g = p.map((w) => l.findViewByCell(w)), m = j0(n, e, t), v = g.map((w) => w == null ? [] : w === this ? m : j0(w.sourcePoint, w.targetPoint, w.routePoints)), y = [];
  m.forEach((w) => {
    const x = p.reduce((S, C, k) => {
      if (C !== h) {
        const E = Rse(w, v[k]);
        S.push(...E);
      }
      return S;
    }, []).sort((S, C) => Uk(w.start, S) - Uk(w.start, C));
    x.length > 0 ? y.push(...Nse(w, x, r)) : y.push(w);
  });
  const b = Gk(y, r, s, o);
  return Xd = [], pm = [], i.raw ? b : b.serialize();
}, Ise = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  jumpover: Lse,
  loop: $se,
  normal: Ase,
  rounded: Tse,
  smooth: _se
}, Symbol.toStringTag, { value: "Module" }));
var zl;
(function(n) {
  n.presets = Ise, n.registry = $n.create({
    type: "connector"
  }), n.registry.register(n.presets, !0);
})(zl || (zl = {}));
var Bse = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class QR extends gn {
  constructor(e = {}) {
    super(), this.pending = !1, this.changing = !1, this.data = {}, this.mutate(Bt(e)), this.changed = {};
  }
  mutate(e, t = {}) {
    const i = t.unset === !0, r = t.silent === !0, s = [], o = this.changing;
    this.changing = !0, o || (this.previous = Bt(this.data), this.changed = {});
    const a = this.data, l = this.previous, c = this.changed;
    if (Object.keys(e).forEach((u) => {
      const h = u, d = e[h];
      cn(a[h], d) || s.push(h), cn(l[h], d) ? delete c[h] : c[h] = d, i ? delete a[h] : a[h] = d;
    }), !r && s.length > 0 && (this.pending = !0, this.pendingOptions = t, s.forEach((u) => {
      this.emit("change:*", {
        key: u,
        options: t,
        store: this,
        current: a[u],
        previous: l[u]
      });
    })), o)
      return this;
    if (!r)
      for (; this.pending; )
        this.pending = !1, this.emit("changed", {
          current: a,
          previous: l,
          store: this,
          options: this.pendingOptions
        });
    return this.pending = !1, this.changing = !1, this.pendingOptions = null, this;
  }
  get(e, t) {
    if (e == null)
      return this.data;
    const i = this.data[e];
    return i ?? t;
  }
  getPrevious(e) {
    if (this.previous) {
      const t = this.previous[e];
      return t ?? void 0;
    }
  }
  set(e, t, i) {
    return e != null && (typeof e == "object" ? this.mutate(e, t) : this.mutate({ [e]: t }, i)), this;
  }
  remove(e, t) {
    const r = {};
    let s;
    if (typeof e == "string")
      r[e] = void 0, s = t;
    else if (Array.isArray(e))
      e.forEach((o) => r[o] = void 0), s = t;
    else {
      for (const o in this.data)
        r[o] = void 0;
      s = e;
    }
    return this.mutate(r, Object.assign(Object.assign({}, s), { unset: !0 })), this;
  }
  getByPath(e) {
    return Lw(this.data, e, "/");
  }
  setByPath(e, t, i = {}) {
    const r = "/", s = Array.isArray(e) ? [...e] : e.split(r), o = Array.isArray(e) ? e.join(r) : e, a = s[0], l = s.length;
    if (i.propertyPath = o, i.propertyValue = t, i.propertyPathArray = s, l === 1)
      this.set(a, t, i);
    else {
      const c = {};
      let u = c, h = a;
      for (let p = 1; p < l; p += 1) {
        const g = s[p], m = Number.isFinite(Number(g));
        u = u[h] = m ? [] : {}, h = g;
      }
      fh(c, s, t, r);
      const d = Bt(this.data);
      i.rewrite && Ek(d, e, r);
      const f = On(d, c);
      this.set(a, f[a], i);
    }
    return this;
  }
  removeByPath(e, t) {
    const i = Array.isArray(e) ? e : e.split("/"), r = i[0];
    if (i.length === 1)
      this.remove(r, t);
    else {
      const s = i.slice(1), o = Bt(this.get(r));
      o && Ek(o, s), this.set(r, o, t);
    }
    return this;
  }
  hasChanged(e) {
    return e == null ? Object.keys(this.changed).length > 0 : e in this.changed;
  }
  /**
   * Returns an object containing all the data that have changed,
   * or `null` if there are no changes. Useful for determining what
   * parts of a view need to be updated.
   */
  getChanges(e) {
    if (e == null)
      return this.hasChanged() ? Bt(this.changed) : null;
    const t = this.changing ? this.previous : this.data, i = {};
    let r;
    for (const s in e) {
      const o = e[s];
      cn(t[s], o) || (i[s] = o, r = !0);
    }
    return r ? Bt(i) : null;
  }
  /**
   * Returns a copy of the store's `data` object.
   */
  toJSON() {
    return Bt(this.data);
  }
  clone() {
    const e = this.constructor;
    return new e(this.data);
  }
  dispose() {
    this.off(), this.data = {}, this.previous = {}, this.changed = {}, this.pending = !1, this.changing = !1, this.pendingOptions = null, this.trigger("disposed", { store: this });
  }
}
Bse([
  gn.dispose()
], QR.prototype, "dispose", null);
class Yd {
  constructor(e) {
    this.cell = e, this.ids = {}, this.cache = {};
  }
  get() {
    return Object.keys(this.ids);
  }
  start(e, t, i = {}, r = "/") {
    const s = this.cell.getPropByPath(e), o = lz(i, Yd.defaultOptions), a = this.getTiming(o.timing), l = this.getInterp(o.interp, s, t);
    let c = 0;
    const u = Array.isArray(e) ? e.join(r) : e, h = Array.isArray(e) ? e : e.split(r), d = () => {
      const f = (/* @__PURE__ */ new Date()).getTime();
      c === 0 && (c = f);
      let g = (f - c) / o.duration;
      g < 1 ? this.ids[u] = requestAnimationFrame(d) : g = 1;
      const m = l(a(g));
      this.cell.setPropByPath(h, m), i.progress && i.progress(Object.assign({ progress: g, currentValue: m }, this.getArgs(u))), g === 1 && (this.cell.notify("transition:complete", this.getArgs(u)), i.complete && i.complete(this.getArgs(u)), this.cell.notify("transition:finish", this.getArgs(u)), i.finish && i.finish(this.getArgs(u)), this.clean(u));
    };
    return setTimeout(() => {
      this.stop(e, void 0, r), this.cache[u] = { startValue: s, targetValue: t, options: o }, this.ids[u] = requestAnimationFrame(d), this.cell.notify("transition:start", this.getArgs(u)), i.start && i.start(this.getArgs(u));
    }, i.delay), this.stop.bind(this, e, r, i);
  }
  stop(e, t = {}, i = "/") {
    const r = Array.isArray(e) ? e : e.split(i);
    return Object.keys(this.ids).filter((s) => cn(r, s.split(i).slice(0, r.length))).forEach((s) => {
      cancelAnimationFrame(this.ids[s]);
      const o = this.cache[s], a = this.getArgs(s), l = Object.assign(Object.assign({}, o.options), t), c = l.jumpedToEnd;
      c && o.targetValue != null && (this.cell.setPropByPath(s, o.targetValue), this.cell.notify("transition:end", Object.assign({}, a)), this.cell.notify("transition:complete", Object.assign({}, a)), l.complete && l.complete(Object.assign({}, a)));
      const u = Object.assign({ jumpedToEnd: c }, a);
      this.cell.notify("transition:stop", Object.assign({}, u)), l.stop && l.stop(Object.assign({}, u)), this.cell.notify("transition:finish", Object.assign({}, a)), l.finish && l.finish(Object.assign({}, a)), this.clean(s);
    }), this;
  }
  clean(e) {
    delete this.ids[e], delete this.cache[e];
  }
  getTiming(e) {
    return typeof e == "string" ? Ul[e] : e;
  }
  getInterp(e, t, i) {
    return e ? e(t, i) : typeof i == "number" ? Al.number(t, i) : typeof i == "string" ? i[0] === "#" ? Al.color(t, i) : Al.unit(t, i) : Al.object(t, i);
  }
  getArgs(e) {
    const t = this.cache[e];
    return {
      path: e,
      startValue: t.startValue,
      targetValue: t.targetValue,
      cell: this.cell
    };
  }
}
(function(n) {
  n.defaultOptions = {
    delay: 10,
    duration: 100,
    timing: "linear"
  };
})(Yd || (Yd = {}));
var Qse = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}, zR = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class gt extends gn {
  static config(e) {
    const { markup: t, propHooks: i, attrHooks: r } = e, s = zR(e, ["markup", "propHooks", "attrHooks"]);
    t != null && (this.markup = t), i && (this.propHooks = this.propHooks.slice(), Array.isArray(i) ? this.propHooks.push(...i) : typeof i == "function" ? this.propHooks.push(i) : Object.values(i).forEach((o) => {
      typeof o == "function" && this.propHooks.push(o);
    })), r && (this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), r)), this.defaults = On({}, this.defaults, s);
  }
  static getMarkup() {
    return this.markup;
  }
  static getDefaults(e) {
    return e ? this.defaults : Bt(this.defaults);
  }
  static getAttrHooks() {
    return this.attrHooks;
  }
  static applyPropHooks(e, t) {
    return this.propHooks.reduce((i, r) => r ? Ze(r, e, i) : i, t);
  }
  // #endregion
  get [Symbol.toStringTag]() {
    return gt.toStringTag;
  }
  constructor(e = {}) {
    super();
    const i = this.constructor.getDefaults(!0), r = On({}, this.preprocess(i), this.preprocess(e));
    this.id = r.id || im(), this.store = new QR(r), this.animation = new Yd(this), this.setup(), this.init(), this.postprocess(e);
  }
  init() {
  }
  // #region model
  get model() {
    return this._model;
  }
  set model(e) {
    this._model !== e && (this._model = e);
  }
  // #endregion
  preprocess(e, t) {
    const i = e.id, s = this.constructor.applyPropHooks(this, e);
    return i == null && t !== !0 && (s.id = im()), s;
  }
  postprocess(e) {
  }
  // eslint-disable-line
  setup() {
    this.store.on("change:*", (e) => {
      const { key: t, current: i, previous: r, options: s } = e;
      this.notify("change:*", {
        key: t,
        options: s,
        current: i,
        previous: r,
        cell: this
      }), this.notify(`change:${t}`, {
        options: s,
        current: i,
        previous: r,
        cell: this
      });
      const o = t;
      (o === "source" || o === "target") && this.notify("change:terminal", {
        type: o,
        current: i,
        previous: r,
        options: s,
        cell: this
      });
    }), this.store.on("changed", ({ options: e }) => this.notify("changed", { options: e, cell: this }));
  }
  notify(e, t) {
    this.trigger(e, t);
    const i = this.model;
    return i && (i.notify(`cell:${e}`, t), this.isNode() ? i.notify(`node:${e}`, Object.assign(Object.assign({}, t), { node: this })) : this.isEdge() && i.notify(`edge:${e}`, Object.assign(Object.assign({}, t), { edge: this }))), this;
  }
  isNode() {
    return !1;
  }
  isEdge() {
    return !1;
  }
  isSameStore(e) {
    return this.store === e.store;
  }
  get view() {
    return this.store.get("view");
  }
  get shape() {
    return this.store.get("shape", "");
  }
  getProp(e, t) {
    return e == null ? this.store.get() : this.store.get(e, t);
  }
  setProp(e, t, i) {
    if (typeof e == "string")
      this.store.set(e, t, i);
    else {
      const r = this.preprocess(e, !0);
      this.store.set(On({}, this.getProp(), r), t), this.postprocess(e);
    }
    return this;
  }
  removeProp(e, t) {
    return typeof e == "string" || Array.isArray(e) ? this.store.removeByPath(e, t) : this.store.remove(t), this;
  }
  hasChanged(e) {
    return e == null ? this.store.hasChanged() : this.store.hasChanged(e);
  }
  getPropByPath(e) {
    return this.store.getByPath(e);
  }
  setPropByPath(e, t, i = {}) {
    return this.model && (e === "children" ? this._children = t ? t.map((r) => this.model.getCell(r)).filter((r) => r != null) : null : e === "parent" && (this._parent = t ? this.model.getCell(t) : null)), this.store.setByPath(e, t, i), this;
  }
  removePropByPath(e, t = {}) {
    const i = Array.isArray(e) ? e : e.split("/");
    return i[0] === "attrs" && (t.dirty = !0), this.store.removeByPath(i, t), this;
  }
  prop(e, t, i) {
    return e == null ? this.getProp() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getPropByPath(e) : t == null ? this.removePropByPath(e, i || {}) : this.setPropByPath(e, t, i || {}) : this.setProp(e, t || {});
  }
  previous(e) {
    return this.store.getPrevious(e);
  }
  // #endregion
  // #region zIndex
  get zIndex() {
    return this.getZIndex();
  }
  set zIndex(e) {
    e == null ? this.removeZIndex() : this.setZIndex(e);
  }
  getZIndex() {
    return this.store.get("zIndex");
  }
  setZIndex(e, t = {}) {
    return this.store.set("zIndex", e, t), this;
  }
  removeZIndex(e = {}) {
    return this.store.remove("zIndex", e), this;
  }
  toFront(e = {}) {
    const t = this.model;
    if (t) {
      let i = t.getMaxZIndex(), r;
      e.deep ? (r = this.getDescendants({ deep: !0, breadthFirst: !0 }), r.unshift(this)) : r = [this], i = i - r.length + 1;
      const s = t.total();
      let o = t.indexOf(this) !== s - r.length;
      o || (o = r.some((a, l) => a.getZIndex() !== i + l)), o && this.batchUpdate("to-front", () => {
        i += r.length, r.forEach((a, l) => {
          a.setZIndex(i + l, e);
        });
      });
    }
    return this;
  }
  toBack(e = {}) {
    const t = this.model;
    if (t) {
      let i = t.getMinZIndex(), r;
      e.deep ? (r = this.getDescendants({ deep: !0, breadthFirst: !0 }), r.unshift(this)) : r = [this];
      let s = t.indexOf(this) !== 0;
      s || (s = r.some((o, a) => o.getZIndex() !== i + a)), s && this.batchUpdate("to-back", () => {
        i -= r.length, r.forEach((o, a) => {
          o.setZIndex(i + a, e);
        });
      });
    }
    return this;
  }
  // #endregion
  // #region markup
  get markup() {
    return this.getMarkup();
  }
  set markup(e) {
    e == null ? this.removeMarkup() : this.setMarkup(e);
  }
  getMarkup() {
    let e = this.store.get("markup");
    return e == null && (e = this.constructor.getMarkup()), e;
  }
  setMarkup(e, t = {}) {
    return this.store.set("markup", e, t), this;
  }
  removeMarkup(e = {}) {
    return this.store.remove("markup", e), this;
  }
  // #endregion
  // #region attrs
  get attrs() {
    return this.getAttrs();
  }
  set attrs(e) {
    e == null ? this.removeAttrs() : this.setAttrs(e);
  }
  getAttrs() {
    const e = this.store.get("attrs");
    return e ? Object.assign({}, e) : {};
  }
  setAttrs(e, t = {}) {
    if (e == null)
      this.removeAttrs(t);
    else {
      const i = (r) => this.store.set("attrs", r, t);
      if (t.overwrite === !0)
        i(e);
      else {
        const r = this.getAttrs();
        t.deep === !1 ? i(Object.assign(Object.assign({}, r), e)) : i(On({}, r, e));
      }
    }
    return this;
  }
  replaceAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeAttrs(e = {}) {
    return this.store.remove("attrs", e), this;
  }
  getAttrDefinition(e) {
    if (!e)
      return null;
    const i = this.constructor.getAttrHooks() || {};
    let r = i[e] || po.registry.get(e);
    if (!r) {
      const s = uv(e);
      r = i[s] || po.registry.get(s);
    }
    return r || null;
  }
  getAttrByPath(e) {
    return e == null || e === "" ? this.getAttrs() : this.getPropByPath(this.prefixAttrPath(e));
  }
  setAttrByPath(e, t, i = {}) {
    return this.setPropByPath(this.prefixAttrPath(e), t, i), this;
  }
  removeAttrByPath(e, t = {}) {
    return this.removePropByPath(this.prefixAttrPath(e), t), this;
  }
  prefixAttrPath(e) {
    return Array.isArray(e) ? ["attrs"].concat(e) : `attrs/${e}`;
  }
  attr(e, t, i) {
    return e == null ? this.getAttrByPath() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getAttrByPath(e) : t == null ? this.removeAttrByPath(e, i || {}) : this.setAttrByPath(e, t, i || {}) : this.setAttrs(e, t || {});
  }
  // #endregion
  // #region visible
  get visible() {
    return this.isVisible();
  }
  set visible(e) {
    this.setVisible(e);
  }
  setVisible(e, t = {}) {
    return this.store.set("visible", e, t), this;
  }
  isVisible() {
    return this.store.get("visible") !== !1;
  }
  show(e = {}) {
    return this.isVisible() || this.setVisible(!0, e), this;
  }
  hide(e = {}) {
    return this.isVisible() && this.setVisible(!1, e), this;
  }
  toggleVisible(e, t = {}) {
    const i = typeof e == "boolean" ? e : !this.isVisible(), r = typeof e == "boolean" ? t : e;
    return i ? this.show(r) : this.hide(r), this;
  }
  // #endregion
  // #region data
  get data() {
    return this.getData();
  }
  set data(e) {
    this.setData(e);
  }
  getData() {
    return this.store.get("data");
  }
  setData(e, t = {}) {
    if (e == null)
      this.removeData(t);
    else {
      const i = (r) => this.store.set("data", r, t);
      if (t.overwrite === !0)
        i(e);
      else {
        const r = this.getData();
        t.deep === !1 ? i(typeof e == "object" ? Object.assign(Object.assign({}, r), e) : e) : i(On({}, r, e));
      }
    }
    return this;
  }
  replaceData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeData(e = {}) {
    return this.store.remove("data", e), this;
  }
  // #endregion
  // #region parent children
  get parent() {
    return this.getParent();
  }
  get children() {
    return this.getChildren();
  }
  getParentId() {
    return this.store.get("parent");
  }
  getParent() {
    const e = this.getParentId();
    if (e && this.model) {
      const t = this.model.getCell(e);
      return this._parent = t, t;
    }
    return null;
  }
  getChildren() {
    const e = this.store.get("children");
    if (e && e.length && this.model) {
      const t = e.map((i) => {
        var r;
        return (r = this.model) === null || r === void 0 ? void 0 : r.getCell(i);
      }).filter((i) => i != null);
      return this._children = t, [...t];
    }
    return null;
  }
  hasParent() {
    return this.parent != null;
  }
  isParentOf(e) {
    return e != null && e.getParent() === this;
  }
  isChildOf(e) {
    return e != null && this.getParent() === e;
  }
  eachChild(e, t) {
    return this.children && this.children.forEach(e, t), this;
  }
  filterChild(e, t) {
    return this.children ? this.children.filter(e, t) : [];
  }
  getChildCount() {
    return this.children == null ? 0 : this.children.length;
  }
  getChildIndex(e) {
    return this.children == null ? -1 : this.children.indexOf(e);
  }
  getChildAt(e) {
    return this.children != null && e >= 0 ? this.children[e] : null;
  }
  getAncestors(e = {}) {
    const t = [];
    let i = this.getParent();
    for (; i; )
      t.push(i), i = e.deep !== !1 ? i.getParent() : null;
    return t;
  }
  getDescendants(e = {}) {
    if (e.deep !== !1) {
      if (e.breadthFirst) {
        const t = [], i = this.getChildren() || [];
        for (; i.length > 0; ) {
          const r = i.shift(), s = r.getChildren();
          t.push(r), s && i.push(...s);
        }
        return t;
      }
      {
        const t = this.getChildren() || [];
        return t.forEach((i) => {
          t.push(...i.getDescendants(e));
        }), t;
      }
    }
    return this.getChildren() || [];
  }
  isDescendantOf(e, t = {}) {
    if (e == null)
      return !1;
    if (t.deep !== !1) {
      let i = this.getParent();
      for (; i; ) {
        if (i === e)
          return !0;
        i = i.getParent();
      }
      return !1;
    }
    return this.isChildOf(e);
  }
  isAncestorOf(e, t = {}) {
    return e == null ? !1 : e.isDescendantOf(this, t);
  }
  contains(e) {
    return this.isAncestorOf(e);
  }
  getCommonAncestor(...e) {
    return gt.getCommonAncestor(this, ...e);
  }
  setParent(e, t = {}) {
    return this._parent = e, e ? this.store.set("parent", e.id, t) : this.store.remove("parent", t), this;
  }
  setChildren(e, t = {}) {
    return this._children = e, e != null ? this.store.set("children", e.map((i) => i.id), t) : this.store.remove("children", t), this;
  }
  unembed(e, t = {}) {
    const i = this.children;
    if (i != null && e != null) {
      const r = this.getChildIndex(e);
      r !== -1 && (i.splice(r, 1), e.setParent(null, t), this.setChildren(i, t));
    }
    return this;
  }
  embed(e, t = {}) {
    return e.addTo(this, t), this;
  }
  addTo(e, t = {}) {
    return gt.isCell(e) ? e.addChild(this, t) : e.addCell(this, t), this;
  }
  insertTo(e, t, i = {}) {
    return e.insertChild(this, t, i), this;
  }
  addChild(e, t = {}) {
    return this.insertChild(e, void 0, t);
  }
  insertChild(e, t, i = {}) {
    if (e != null && e !== this) {
      const r = e.getParent(), s = this !== r;
      let o = t;
      if (o == null && (o = this.getChildCount(), s || (o -= 1)), r) {
        const l = r.getChildren();
        if (l) {
          const c = l.indexOf(e);
          c >= 0 && (e.setParent(null, i), l.splice(c, 1), r.setChildren(l, i));
        }
      }
      let a = this.children;
      if (a == null ? (a = [], a.push(e)) : a.splice(o, 0, e), e.setParent(this, i), this.setChildren(a, i), s && this.model) {
        const l = this.model.getIncomingEdges(this), c = this.model.getOutgoingEdges(this);
        l && l.forEach((u) => u.updateParent(i)), c && c.forEach((u) => u.updateParent(i));
      }
      this.model && this.model.addCell(e, i);
    }
    return this;
  }
  removeFromParent(e = {}) {
    const t = this.getParent();
    if (t != null) {
      const i = t.getChildIndex(this);
      t.removeChildAt(i, e);
    }
    return this;
  }
  removeChild(e, t = {}) {
    const i = this.getChildIndex(e);
    return this.removeChildAt(i, t);
  }
  removeChildAt(e, t = {}) {
    const i = this.getChildAt(e);
    return this.children != null && i != null && (this.unembed(i, t), i.remove(t)), i;
  }
  remove(e = {}) {
    return this.batchUpdate("remove", () => {
      const t = this.getParent();
      t && t.removeChild(this, e), e.deep !== !1 && this.eachChild((i) => i.remove(e)), this.model && this.model.removeCell(this, e);
    }), this;
  }
  transition(e, t, i = {}, r = "/") {
    return this.animation.start(e, t, i, r);
  }
  stopTransition(e, t, i = "/") {
    return this.animation.stop(e, t, i), this;
  }
  getTransitions() {
    return this.animation.get();
  }
  // #endregion
  // #region transform
  // eslint-disable-next-line
  translate(e, t, i) {
    return this;
  }
  scale(e, t, i, r) {
    return this;
  }
  addTools(e, t, i) {
    const r = Array.isArray(e) ? e : [e], s = typeof t == "string" ? t : null, o = typeof t == "object" ? t : typeof i == "object" ? i : {};
    if (o.reset)
      return this.setTools({ name: s, items: r, local: o.local }, o);
    let a = Bt(this.getTools());
    if (a == null || s == null || a.name === s)
      return a == null && (a = {}), a.items || (a.items = []), a.name = s, a.items = [...a.items, ...r], this.setTools(Object.assign({}, a), o);
  }
  setTools(e, t = {}) {
    return e == null ? this.removeTools() : this.store.set("tools", gt.normalizeTools(e), t), this;
  }
  getTools() {
    return this.store.get("tools");
  }
  removeTools(e = {}) {
    return this.store.remove("tools", e), this;
  }
  hasTools(e) {
    const t = this.getTools();
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  hasTool(e) {
    const t = this.getTools();
    return t == null ? !1 : t.items.some((i) => typeof i == "string" ? i === e : i.name === e);
  }
  removeTool(e, t = {}) {
    const i = Bt(this.getTools());
    if (i) {
      let r = !1;
      const s = i.items.slice(), o = (a) => {
        s.splice(a, 1), r = !0;
      };
      if (typeof e == "number")
        o(e);
      else
        for (let a = s.length - 1; a >= 0; a -= 1) {
          const l = s[a];
          (typeof l == "string" ? l === e : l.name === e) && o(a);
        }
      r && (i.items = s, this.setTools(i, t));
    }
    return this;
  }
  // #endregion
  // #region common
  // eslint-disable-next-line
  getBBox(e) {
    return new ye();
  }
  // eslint-disable-next-line
  getConnectionPoint(e, t) {
    return new z();
  }
  toJSON(e = {}) {
    const t = Object.assign({}, this.store.get()), i = Object.prototype.toString, r = this.isNode() ? "node" : this.isEdge() ? "edge" : "cell";
    if (!t.shape) {
      const p = this.constructor;
      throw new Error(`Unable to serialize ${r} missing "shape" prop, check the ${r} "${p.name || i.call(p)}"`);
    }
    const s = this.constructor, o = e.diff === !0, a = t.attrs || {}, l = s.getDefaults(!0), c = o ? this.preprocess(l, !0) : l, u = c.attrs || {}, h = {};
    Object.entries(t).forEach(([p, g]) => {
      if (g != null && !Array.isArray(g) && typeof g == "object" && !Ps(g))
        throw new Error(`Can only serialize ${r} with plain-object props, but got a "${i.call(g)}" type of key "${p}" on ${r} "${this.id}"`);
      if (p !== "attrs" && p !== "shape" && o) {
        const m = c[p];
        cn(g, m) && delete t[p];
      }
    }), Object.keys(a).forEach((p) => {
      const g = a[p], m = u[p];
      Object.keys(g).forEach((v) => {
        const y = g[v], b = m ? m[v] : null;
        y != null && typeof y == "object" && !Array.isArray(y) ? Object.keys(y).forEach((w) => {
          const x = y[w];
          if (m == null || b == null || !wn(b) || !cn(b[w], x)) {
            h[p] == null && (h[p] = {}), h[p][v] == null && (h[p][v] = {});
            const S = h[p][v];
            S[w] = x;
          }
        }) : (m == null || !cn(b, y)) && (h[p] == null && (h[p] = {}), h[p][v] = y);
      });
    });
    const d = Object.assign(Object.assign({}, t), { attrs: T$(h) ? void 0 : h });
    d.attrs == null && delete d.attrs;
    const f = d;
    return f.angle === 0 && delete f.angle, Bt(f);
  }
  clone(e = {}) {
    if (!e.deep) {
      const i = Object.assign({}, this.store.get());
      e.keepId || delete i.id, delete i.parent, delete i.children;
      const r = this.constructor;
      return new r(i);
    }
    return gt.deepClone(this)[this.id];
  }
  findView(e) {
    return e.findViewByCell(this);
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}, i = this.model) {
    return this.notify("batch:start", { name: e, data: t, cell: this }), i && i.startBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this;
  }
  stopBatch(e, t = {}, i = this.model) {
    return i && i.stopBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this.notify("batch:stop", { name: e, data: t, cell: this }), this;
  }
  batchUpdate(e, t, i) {
    const r = this.model;
    this.startBatch(e, i, r);
    const s = t();
    return this.stopBatch(e, i, r), s;
  }
  // #endregion
  // #region IDisposable
  dispose() {
    this.removeFromParent(), this.store.dispose();
  }
}
gt.defaults = {};
gt.attrHooks = {};
gt.propHooks = [];
Qse([
  gn.dispose()
], gt.prototype, "dispose", null);
(function(n) {
  function e(t) {
    return typeof t == "string" ? { items: [t] } : Array.isArray(t) ? { items: t } : t.items ? t : {
      items: [t]
    };
  }
  n.normalizeTools = e;
})(gt || (gt = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && typeof r.isNode == "function" && typeof r.isEdge == "function" && typeof r.prop == "function" && typeof r.attr == "function";
  }
  n.isCell = e;
})(gt || (gt = {}));
(function(n) {
  function e(...s) {
    const o = s.filter((l) => l != null).map((l) => l.getAncestors()).sort((l, c) => l.length - c.length);
    return o.shift().find((l) => o.every((c) => c.includes(l))) || null;
  }
  n.getCommonAncestor = e;
  function t(s, o = {}) {
    let a = null;
    for (let l = 0, c = s.length; l < c; l += 1) {
      const u = s[l];
      let h = u.getBBox(o);
      if (h) {
        if (u.isNode()) {
          const d = u.getAngle();
          d != null && d !== 0 && (h = h.bbox(d));
        }
        a = a == null ? h : a.union(h);
      }
    }
    return a;
  }
  n.getCellsBBox = t;
  function i(s) {
    const o = [s, ...s.getDescendants({ deep: !0 })];
    return n.cloneCells(o);
  }
  n.deepClone = i;
  function r(s) {
    const o = I$(s), a = o.reduce((l, c) => (l[c.id] = c.clone(), l), {});
    return o.forEach((l) => {
      const c = a[l.id];
      if (c.isEdge()) {
        const d = c.getSourceCellId(), f = c.getTargetCellId();
        d && a[d] && c.setSource(Object.assign(Object.assign({}, c.getSource()), { cell: a[d].id })), f && a[f] && c.setTarget(Object.assign(Object.assign({}, c.getTarget()), { cell: a[f].id }));
      }
      const u = l.getParent();
      u && a[u.id] && c.setParent(a[u.id]);
      const h = l.getChildren();
      if (h && h.length) {
        const d = h.reduce((f, p) => (a[p.id] && f.push(a[p.id]), f), []);
        d.length > 0 && c.setChildren(d);
      }
    }), a;
  }
  n.cloneCells = r;
})(gt || (gt = {}));
(function(n) {
  n.config({
    propHooks(e) {
      var { tools: t } = e, i = zR(e, ["tools"]);
      return t && (i.tools = n.normalizeTools(t)), i;
    }
  });
})(gt || (gt = {}));
var Bu;
(function(n) {
  let e, t;
  function i(o, a) {
    return a ? e != null && e.exist(o) : t != null && t.exist(o);
  }
  n.exist = i;
  function r(o) {
    e = o;
  }
  n.setEdgeRegistry = r;
  function s(o) {
    t = o;
  }
  n.setNodeRegistry = s;
})(Bu || (Bu = {}));
class zse {
  constructor(e) {
    this.ports = [], this.groups = {}, this.init(Bt(e));
  }
  getPorts() {
    return this.ports;
  }
  getGroup(e) {
    return e != null ? this.groups[e] : null;
  }
  getPortsByGroup(e) {
    return this.ports.filter((t) => t.group === e || t.group == null && e == null);
  }
  getPortsLayoutByGroup(e, t) {
    const i = this.getPortsByGroup(e), r = e ? this.getGroup(e) : null, s = r ? r.position : null, o = s ? s.name : null;
    let a;
    if (o != null) {
      const h = Ql.registry.get(o);
      if (h == null)
        return Ql.registry.onNotFound(o);
      a = h;
    } else
      a = Ql.presets.left;
    const l = i.map((h) => h && h.position && h.position.args || {}), c = s && s.args || {};
    return a(l, t, c).map((h, d) => {
      const f = i[d];
      return {
        portLayout: h,
        portId: f.id,
        portSize: f.size,
        portAttrs: f.attrs,
        labelSize: f.label.size,
        labelLayout: this.getPortLabelLayout(f, z.create(h.position), t)
      };
    });
  }
  init(e) {
    const { groups: t, items: i } = e;
    t != null && Object.keys(t).forEach((r) => {
      this.groups[r] = this.parseGroup(t[r]);
    }), Array.isArray(i) && i.forEach((r) => {
      this.ports.push(this.parsePort(r));
    });
  }
  parseGroup(e) {
    return Object.assign(Object.assign({}, e), { label: this.getLabel(e, !0), position: this.getPortPosition(e.position, !0) });
  }
  parsePort(e) {
    const t = Object.assign({}, e), i = this.getGroup(e.group) || {};
    return t.markup = t.markup || i.markup, t.attrs = On({}, i.attrs, t.attrs), t.position = this.createPosition(i, t), t.label = On({}, i.label, this.getLabel(t)), t.zIndex = this.getZIndex(i, t), t.size = Object.assign(Object.assign({}, i.size), t.size), t;
  }
  getZIndex(e, t) {
    return typeof t.zIndex == "number" ? t.zIndex : typeof e.zIndex == "number" || e.zIndex === "auto" ? e.zIndex : "auto";
  }
  createPosition(e, t) {
    return On({
      name: "left",
      args: {}
    }, e.position, { args: t.args });
  }
  getPortPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (Array.isArray(e))
        return {
          name: "absolute",
          args: { x: e[0], y: e[1] }
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getPortLabelPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getLabel(e, t = !1) {
    const i = e.label || {};
    return i.position = this.getPortLabelPosition(i.position, t), i;
  }
  getPortLabelLayout(e, t, i) {
    const r = e.label.position.name || "left", s = e.label.position.args || {}, o = _u.registry.get(r) || _u.presets.left;
    return o ? o(t, i, s) : null;
  }
}
var Mv = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
let Tn = class jR extends gt {
  get [Symbol.toStringTag]() {
    return jR.toStringTag;
  }
  constructor(e = {}) {
    super(e), this.initPorts();
  }
  preprocess(e, t) {
    const { x: i, y: r, width: s, height: o } = e, a = Mv(e, ["x", "y", "width", "height"]);
    if (i != null || r != null) {
      const l = a.position;
      a.position = Object.assign(Object.assign({}, l), { x: i ?? (l ? l.x : 0), y: r ?? (l ? l.y : 0) });
    }
    if (s != null || o != null) {
      const l = a.size;
      a.size = Object.assign(Object.assign({}, l), { width: s ?? (l ? l.width : 0), height: o ?? (l ? l.height : 0) });
    }
    return super.preprocess(a, t);
  }
  isNode() {
    return !0;
  }
  size(e, t, i) {
    return e === void 0 ? this.getSize() : typeof e == "number" ? this.setSize(e, t, i) : this.setSize(e, t);
  }
  getSize() {
    const e = this.store.get("size");
    return e ? Object.assign({}, e) : { width: 1, height: 1 };
  }
  setSize(e, t, i) {
    return typeof e == "object" ? this.resize(e.width, e.height, t) : this.resize(e, t, i), this;
  }
  resize(e, t, i = {}) {
    this.startBatch("resize", i);
    const r = i.direction;
    if (r) {
      const s = this.getSize();
      switch (r) {
        case "left":
        case "right":
          t = s.height;
          break;
        case "top":
        case "bottom":
          e = s.width;
          break;
      }
      let a = {
        right: 0,
        "top-right": 0,
        top: 1,
        "top-left": 1,
        left: 2,
        "bottom-left": 2,
        bottom: 3,
        "bottom-right": 3
      }[r];
      const l = Pt.normalize(this.getAngle() || 0);
      i.absolute && (a += Math.floor((l + 45) / 90), a %= 4);
      const c = this.getBBox();
      let u;
      a === 0 ? u = c.getBottomLeft() : a === 1 ? u = c.getCorner() : a === 2 ? u = c.getTopRight() : u = c.getOrigin();
      const h = u.clone().rotate(-l, c.getCenter()), d = Math.sqrt(e * e + t * t) / 2;
      let f = a * Math.PI / 2;
      f += Math.atan(a % 2 === 0 ? t / e : e / t), f -= Pt.toRad(l);
      const g = z.fromPolar(d, f, h).clone().translate(e / -2, t / -2);
      this.store.set("size", { width: e, height: t }, i), this.setPosition(g.x, g.y, i);
    } else
      this.store.set("size", { width: e, height: t }, i);
    return this.stopBatch("resize", i), this;
  }
  scale(e, t, i, r = {}) {
    const s = this.getBBox().scale(e, t, i ?? void 0);
    return this.startBatch("scale", r), this.setPosition(s.x, s.y, r), this.resize(s.width, s.height, r), this.stopBatch("scale"), this;
  }
  position(e, t, i) {
    return typeof e == "number" ? this.setPosition(e, t, i) : this.getPosition(e);
  }
  getPosition(e = {}) {
    if (e.relative) {
      const i = this.getParent();
      if (i != null && i.isNode()) {
        const r = this.getPosition(), s = i.getPosition();
        return {
          x: r.x - s.x,
          y: r.y - s.y
        };
      }
    }
    const t = this.store.get("position");
    return t ? Object.assign({}, t) : { x: 0, y: 0 };
  }
  setPosition(e, t, i = {}) {
    let r, s, o;
    if (typeof e == "object" ? (r = e.x, s = e.y, o = t || {}) : (r = e, s = t, o = i || {}), o.relative) {
      const a = this.getParent();
      if (a != null && a.isNode()) {
        const l = a.getPosition();
        r += l.x, s += l.y;
      }
    }
    if (o.deep) {
      const a = this.getPosition();
      this.translate(r - a.x, s - a.y, o);
    } else
      this.store.set("position", { x: r, y: s }, o);
    return this;
  }
  translate(e = 0, t = 0, i = {}) {
    if (e === 0 && t === 0)
      return this;
    i.translateBy = i.translateBy || this.id;
    const r = this.getPosition();
    if (i.restrict != null && i.translateBy === this.id) {
      const o = this.getBBox({ deep: !0 }), a = i.restrict, l = r.x - o.x, c = r.y - o.y, u = Math.max(a.x + l, Math.min(a.x + a.width + l - o.width, r.x + e)), h = Math.max(a.y + c, Math.min(a.y + a.height + c - o.height, r.y + t));
      e = u - r.x, t = h - r.y;
    }
    const s = {
      x: r.x + e,
      y: r.y + t
    };
    return i.tx = e, i.ty = t, i.transition ? (typeof i.transition != "object" && (i.transition = {}), this.transition("position", s, Object.assign(Object.assign({}, i.transition), { interp: Al.object })), this.eachChild((o) => {
      var a;
      ((a = i.exclude) === null || a === void 0 ? void 0 : a.includes(o)) || o.translate(e, t, i);
    })) : (this.startBatch("translate", i), this.store.set("position", s, i), this.eachChild((o) => {
      var a;
      ((a = i.exclude) === null || a === void 0 ? void 0 : a.includes(o)) || o.translate(e, t, i);
    }), this.stopBatch("translate", i)), this;
  }
  angle(e, t) {
    return e == null ? this.getAngle() : this.rotate(e, t);
  }
  getAngle() {
    return this.store.get("angle", 0);
  }
  rotate(e, t = {}) {
    const i = this.getAngle();
    if (t.center) {
      const r = this.getSize(), s = this.getPosition(), o = this.getBBox().getCenter();
      o.rotate(i - e, t.center);
      const a = o.x - r.width / 2 - s.x, l = o.y - r.height / 2 - s.y;
      this.startBatch("rotate", { angle: e, options: t }), this.setPosition(s.x + a, s.y + l, t), this.rotate(e, Object.assign(Object.assign({}, t), { center: null })), this.stopBatch("rotate");
    } else
      this.store.set("angle", t.absolute ? e : (i + e) % 360, t);
    return this;
  }
  // #endregion
  // #region common
  getBBox(e = {}) {
    if (e.deep) {
      const t = this.getDescendants({ deep: !0, breadthFirst: !0 });
      return t.push(this), gt.getCellsBBox(t);
    }
    return ye.fromPositionAndSize(this.getPosition(), this.getSize());
  }
  getConnectionPoint(e, t) {
    const i = this.getBBox(), r = i.getCenter(), s = e.getTerminal(t);
    if (s == null)
      return r;
    const o = s.port;
    if (!o || !this.hasPort(o))
      return r;
    const a = this.getPort(o);
    if (!a || !a.group)
      return r;
    const c = this.getPortsPosition(a.group)[o].position, u = z.create(c).translate(i.getOrigin()), h = this.getAngle();
    return h && u.rotate(-h, r), u;
  }
  /**
   * Sets cell's size and position based on the children bbox and given padding.
   */
  fit(e = {}) {
    const i = (this.getChildren() || []).filter((c) => c.isNode());
    if (i.length === 0)
      return this;
    this.startBatch("fit-embeds", e), e.deep && i.forEach((c) => c.fit(e));
    let { x: r, y: s, width: o, height: a } = gt.getCellsBBox(i);
    const l = Xl(e.padding);
    return r -= l.left, s -= l.top, o += l.left + l.right, a += l.bottom + l.top, this.store.set({
      position: { x: r, y: s },
      size: { width: o, height: a }
    }, e), this.stopBatch("fit-embeds"), this;
  }
  // #endregion
  // #region ports
  get portContainerMarkup() {
    return this.getPortContainerMarkup();
  }
  set portContainerMarkup(e) {
    this.setPortContainerMarkup(e);
  }
  getDefaultPortContainerMarkup() {
    return this.store.get("defaultPortContainerMarkup") || Yt.getPortContainerMarkup();
  }
  getPortContainerMarkup() {
    return this.store.get("portContainerMarkup") || this.getDefaultPortContainerMarkup();
  }
  setPortContainerMarkup(e, t = {}) {
    return this.store.set("portContainerMarkup", Yt.clone(e), t), this;
  }
  get portMarkup() {
    return this.getPortMarkup();
  }
  set portMarkup(e) {
    this.setPortMarkup(e);
  }
  getDefaultPortMarkup() {
    return this.store.get("defaultPortMarkup") || Yt.getPortMarkup();
  }
  getPortMarkup() {
    return this.store.get("portMarkup") || this.getDefaultPortMarkup();
  }
  setPortMarkup(e, t = {}) {
    return this.store.set("portMarkup", Yt.clone(e), t), this;
  }
  get portLabelMarkup() {
    return this.getPortLabelMarkup();
  }
  set portLabelMarkup(e) {
    this.setPortLabelMarkup(e);
  }
  getDefaultPortLabelMarkup() {
    return this.store.get("defaultPortLabelMarkup") || Yt.getPortLabelMarkup();
  }
  getPortLabelMarkup() {
    return this.store.get("portLabelMarkup") || this.getDefaultPortLabelMarkup();
  }
  setPortLabelMarkup(e, t = {}) {
    return this.store.set("portLabelMarkup", Yt.clone(e), t), this;
  }
  get ports() {
    const e = this.store.get("ports", { items: [] });
    return e.items == null && (e.items = []), e;
  }
  getPorts() {
    return Bt(this.ports.items);
  }
  getPortsByGroup(e) {
    return this.getPorts().filter((t) => t.group === e);
  }
  getPort(e) {
    return Bt(this.ports.items.find((t) => t.id && t.id === e));
  }
  getPortAt(e) {
    return this.ports.items[e] || null;
  }
  hasPorts() {
    return this.ports.items.length > 0;
  }
  hasPort(e) {
    return this.getPortIndex(e) !== -1;
  }
  getPortIndex(e) {
    const t = typeof e == "string" ? e : e.id;
    return t != null ? this.ports.items.findIndex((i) => i.id === t) : -1;
  }
  getPortsPosition(e) {
    const t = this.getSize();
    return this.port.getPortsLayoutByGroup(e, new ye(0, 0, t.width, t.height)).reduce((r, s) => {
      const o = s.portLayout;
      return r[s.portId] = {
        position: Object.assign({}, o.position),
        angle: o.angle || 0
      }, r;
    }, {});
  }
  getPortProp(e, t) {
    return this.getPropByPath(this.prefixPortPath(e, t));
  }
  setPortProp(e, t, i, r) {
    if (typeof t == "string" || Array.isArray(t)) {
      const a = this.prefixPortPath(e, t), l = i;
      return this.setPropByPath(a, l, r);
    }
    const s = this.prefixPortPath(e), o = t;
    return this.setPropByPath(s, o, i);
  }
  removePortProp(e, t, i) {
    return typeof t == "string" || Array.isArray(t) ? this.removePropByPath(this.prefixPortPath(e, t), i) : this.removePropByPath(this.prefixPortPath(e), t);
  }
  portProp(e, t, i, r) {
    return t == null ? this.getPortProp(e) : typeof t == "string" || Array.isArray(t) ? arguments.length === 2 ? this.getPortProp(e, t) : i == null ? this.removePortProp(e, t, r) : this.setPortProp(e, t, i, r) : this.setPortProp(e, t, i);
  }
  prefixPortPath(e, t) {
    const i = this.getPortIndex(e);
    if (i === -1)
      throw new Error(`Unable to find port with id: "${e}"`);
    return t == null || t === "" ? ["ports", "items", `${i}`] : Array.isArray(t) ? ["ports", "items", `${i}`, ...t] : `ports/items/${i}/${t}`;
  }
  addPort(e, t) {
    const i = [...this.ports.items];
    return i.push(e), this.setPropByPath("ports/items", i, t), this;
  }
  addPorts(e, t) {
    return this.setPropByPath("ports/items", [...this.ports.items, ...e], t), this;
  }
  insertPort(e, t, i) {
    const r = [...this.ports.items];
    return r.splice(e, 0, t), this.setPropByPath("ports/items", r, i), this;
  }
  removePort(e, t = {}) {
    return this.removePortAt(this.getPortIndex(e), t);
  }
  removePortAt(e, t = {}) {
    if (e >= 0) {
      const i = [...this.ports.items];
      i.splice(e, 1), t.rewrite = !0, this.setPropByPath("ports/items", i, t);
    }
    return this;
  }
  removePorts(e, t) {
    let i;
    if (Array.isArray(e)) {
      if (i = t || {}, e.length) {
        i.rewrite = !0;
        const s = [...this.ports.items].filter((o) => !e.some((a) => {
          const l = typeof a == "string" ? a : a.id;
          return o.id === l;
        }));
        this.setPropByPath("ports/items", s, i);
      }
    } else
      i = e || {}, i.rewrite = !0, this.setPropByPath("ports/items", [], i);
    return this;
  }
  getParsedPorts() {
    return this.port.getPorts();
  }
  getParsedGroups() {
    return this.port.groups;
  }
  getPortsLayoutByGroup(e, t) {
    return this.port.getPortsLayoutByGroup(e, t);
  }
  initPorts() {
    this.updatePortData(), this.on("change:ports", () => {
      this.processRemovedPort(), this.updatePortData();
    });
  }
  processRemovedPort() {
    const e = this.ports, t = {};
    e.items.forEach((o) => {
      o.id && (t[o.id] = !0);
    });
    const i = {};
    (this.store.getPrevious("ports") || {
      items: []
    }).items.forEach((o) => {
      o.id && !t[o.id] && (i[o.id] = !0);
    });
    const s = this.model;
    s && !T$(i) && (s.getConnectedEdges(this, { incoming: !0 }).forEach((l) => {
      const c = l.getTargetPortId();
      c && i[c] && l.remove();
    }), s.getConnectedEdges(this, { outgoing: !0 }).forEach((l) => {
      const c = l.getSourcePortId();
      c && i[c] && l.remove();
    }));
  }
  validatePorts() {
    const e = {}, t = [];
    return this.ports.items.forEach((i) => {
      typeof i != "object" && t.push(`Invalid port ${i}.`), i.id == null && (i.id = this.generatePortId()), e[i.id] && t.push("Duplicitied port id."), e[i.id] = !0;
    }), t;
  }
  generatePortId() {
    return im();
  }
  updatePortData() {
    const e = this.validatePorts();
    if (e.length > 0)
      throw this.store.set("ports", this.store.getPrevious("ports")), new Error(e.join(" "));
    const t = this.port ? this.port.getPorts() : null;
    this.port = new zse(this.ports);
    const i = this.port.getPorts(), r = t ? i.filter((o) => t.find((a) => a.id === o.id) ? null : o) : [...i], s = t ? t.filter((o) => i.find((a) => a.id === o.id) ? null : o) : [];
    r.length > 0 && this.notify("ports:added", { added: r, cell: this, node: this }), s.length > 0 && this.notify("ports:removed", { removed: s, cell: this, node: this });
  }
};
Tn.defaults = {
  angle: 0,
  position: { x: 0, y: 0 },
  size: { width: 1, height: 1 }
};
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && typeof r.isNode == "function" && typeof r.isEdge == "function" && typeof r.prop == "function" && typeof r.attr == "function" && typeof r.size == "function" && typeof r.position == "function";
  }
  n.isNode = e;
})(Tn || (Tn = {}));
(function(n) {
  n.config({
    propHooks(e) {
      var { ports: t } = e, i = Mv(e, ["ports"]);
      return t && (i.ports = Array.isArray(t) ? { items: t } : t), i;
    }
  });
})(Tn || (Tn = {}));
(function(n) {
  n.registry = $n.create({
    type: "node",
    process(e, t) {
      if (Bu.exist(e, !0))
        throw new Error(`Node with name '${e}' was registered by anthor Edge`);
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let i = n;
      const { inherit: r } = t, s = Mv(t, ["inherit"]);
      if (r)
        if (typeof r == "string") {
          const a = this.get(r);
          a == null ? this.onNotFound(r, "inherited") : i = a;
        } else
          i = r;
      s.constructorName == null && (s.constructorName = e);
      const o = i.define.call(i, s);
      return o.config({ shape: e }), o;
    }
  }), Bu.setNodeRegistry(n.registry);
})(Tn || (Tn = {}));
(function(n) {
  let e = 0;
  function t(s) {
    return s ? Iw(s) : (e += 1, `CustomNode${e}`);
  }
  function i(s) {
    const { constructorName: o, overwrite: a } = s, l = Mv(s, ["constructorName", "overwrite"]), c = Dw(t(o || l.shape), this);
    return c.config(l), l.shape && n.registry.register(l.shape, c, a), c;
  }
  n.define = i;
  function r(s) {
    const o = s.shape || "rect", a = n.registry.get(o);
    return a ? new a(s) : n.registry.onNotFound(o);
  }
  n.create = r;
})(Tn || (Tn = {}));
var Rv = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
let xn = class VR extends gt {
  get [Symbol.toStringTag]() {
    return VR.toStringTag;
  }
  constructor(e = {}) {
    super(e);
  }
  preprocess(e, t) {
    const { source: i, sourceCell: r, sourcePort: s, sourcePoint: o, target: a, targetCell: l, targetPort: c, targetPoint: u } = e, d = Rv(e, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]), f = (p) => typeof p == "string" || typeof p == "number";
    if (i != null)
      if (gt.isCell(i))
        d.source = { cell: i.id };
      else if (f(i))
        d.source = { cell: i };
      else if (z.isPoint(i))
        d.source = i.toJSON();
      else if (Array.isArray(i))
        d.source = { x: i[0], y: i[1] };
      else {
        const p = i.cell;
        gt.isCell(p) ? d.source = Object.assign(Object.assign({}, i), { cell: p.id }) : d.source = i;
      }
    if (r != null || s != null) {
      let p = d.source;
      if (r != null) {
        const g = f(r) ? r : r.id;
        p ? p.cell = g : p = d.source = { cell: g };
      }
      s != null && p && (p.port = s);
    } else
      o != null && (d.source = z.create(o).toJSON());
    if (a != null)
      if (gt.isCell(a))
        d.target = { cell: a.id };
      else if (f(a))
        d.target = { cell: a };
      else if (z.isPoint(a))
        d.target = a.toJSON();
      else if (Array.isArray(a))
        d.target = { x: a[0], y: a[1] };
      else {
        const p = a.cell;
        gt.isCell(p) ? d.target = Object.assign(Object.assign({}, a), { cell: p.id }) : d.target = a;
      }
    if (l != null || c != null) {
      let p = d.target;
      if (l != null) {
        const g = f(l) ? l : l.id;
        p ? p.cell = g : p = d.target = { cell: g };
      }
      c != null && p && (p.port = c);
    } else
      u != null && (d.target = z.create(u).toJSON());
    return super.preprocess(d, t);
  }
  setup() {
    super.setup(), this.on("change:labels", (e) => this.onLabelsChanged(e)), this.on("change:vertices", (e) => this.onVertexsChanged(e));
  }
  isEdge() {
    return !0;
  }
  // #region terminal
  disconnect(e = {}) {
    return this.store.set({
      source: { x: 0, y: 0 },
      target: { x: 0, y: 0 }
    }, e), this;
  }
  get source() {
    return this.getSource();
  }
  set source(e) {
    this.setSource(e);
  }
  getSource() {
    return this.getTerminal("source");
  }
  getSourceCellId() {
    return this.source.cell;
  }
  getSourcePortId() {
    return this.source.port;
  }
  setSource(e, t, i = {}) {
    return this.setTerminal("source", e, t, i);
  }
  get target() {
    return this.getTarget();
  }
  set target(e) {
    this.setTarget(e);
  }
  getTarget() {
    return this.getTerminal("target");
  }
  getTargetCellId() {
    return this.target.cell;
  }
  getTargetPortId() {
    return this.target.port;
  }
  setTarget(e, t, i = {}) {
    return this.setTerminal("target", e, t, i);
  }
  getTerminal(e) {
    return Object.assign({}, this.store.get(e));
  }
  setTerminal(e, t, i, r = {}) {
    if (gt.isCell(t))
      return this.store.set(e, On({}, i, { cell: t.id }), r), this;
    const s = t;
    return z.isPoint(t) || s.x != null && s.y != null ? (this.store.set(e, On({}, i, { x: s.x, y: s.y }), r), this) : (this.store.set(e, Bt(t), r), this);
  }
  getSourcePoint() {
    return this.getTerminalPoint("source");
  }
  getTargetPoint() {
    return this.getTerminalPoint("target");
  }
  getTerminalPoint(e) {
    const t = this[e];
    if (z.isPointLike(t))
      return z.create(t);
    const i = this.getTerminalCell(e);
    return i ? i.getConnectionPoint(this, e) : new z();
  }
  getSourceCell() {
    return this.getTerminalCell("source");
  }
  getTargetCell() {
    return this.getTerminalCell("target");
  }
  getTerminalCell(e) {
    if (this.model) {
      const t = e === "source" ? this.getSourceCellId() : this.getTargetCellId();
      if (t)
        return this.model.getCell(t);
    }
    return null;
  }
  getSourceNode() {
    return this.getTerminalNode("source");
  }
  getTargetNode() {
    return this.getTerminalNode("target");
  }
  getTerminalNode(e) {
    let t = this;
    const i = {};
    for (; t && t.isEdge(); ) {
      if (i[t.id])
        return null;
      i[t.id] = !0, t = t.getTerminalCell(e);
    }
    return t && t.isNode() ? t : null;
  }
  // #endregion
  // #region router
  get router() {
    return this.getRouter();
  }
  set router(e) {
    e == null ? this.removeRouter() : this.setRouter(e);
  }
  getRouter() {
    return this.store.get("router");
  }
  setRouter(e, t, i) {
    return typeof e == "object" ? this.store.set("router", e, t) : this.store.set("router", { name: e, args: t }, i), this;
  }
  removeRouter(e = {}) {
    return this.store.remove("router", e), this;
  }
  // #endregion
  // #region connector
  get connector() {
    return this.getConnector();
  }
  set connector(e) {
    e == null ? this.removeConnector() : this.setConnector(e);
  }
  getConnector() {
    return this.store.get("connector");
  }
  setConnector(e, t, i) {
    return typeof e == "object" ? this.store.set("connector", e, t) : this.store.set("connector", { name: e, args: t }, i), this;
  }
  removeConnector(e = {}) {
    return this.store.remove("connector", e);
  }
  // #endregion
  // #region labels
  getDefaultLabel() {
    const e = this.constructor, t = this.store.get("defaultLabel") || e.defaultLabel || {};
    return Bt(t);
  }
  get labels() {
    return this.getLabels();
  }
  set labels(e) {
    this.setLabels(e);
  }
  getLabels() {
    return [...this.store.get("labels", [])].map((e) => this.parseLabel(e));
  }
  setLabels(e, t = {}) {
    return this.store.set("labels", Array.isArray(e) ? e : [e], t), this;
  }
  insertLabel(e, t, i = {}) {
    const r = this.getLabels(), s = r.length;
    let o = t != null && Number.isFinite(t) ? t : s;
    return o < 0 && (o = s + o + 1), r.splice(o, 0, this.parseLabel(e)), this.setLabels(r, i);
  }
  appendLabel(e, t = {}) {
    return this.insertLabel(e, -1, t);
  }
  getLabelAt(e) {
    const t = this.getLabels();
    return e != null && Number.isFinite(e) ? this.parseLabel(t[e]) : null;
  }
  setLabelAt(e, t, i = {}) {
    if (e != null && Number.isFinite(e)) {
      const r = this.getLabels();
      r[e] = this.parseLabel(t), this.setLabels(r, i);
    }
    return this;
  }
  removeLabelAt(e, t = {}) {
    const i = this.getLabels(), r = e != null && Number.isFinite(e) ? e : -1, s = i.splice(r, 1);
    return this.setLabels(i, t), s.length ? s[0] : null;
  }
  parseLabel(e) {
    return typeof e == "string" ? this.constructor.parseStringLabel(e) : e;
  }
  onLabelsChanged({ previous: e, current: t }) {
    const i = e && t ? t.filter((s) => e.find((o) => s === o || cn(s, o)) ? null : s) : t ? [...t] : [], r = e && t ? e.filter((s) => t.find((o) => s === o || cn(s, o)) ? null : s) : e ? [...e] : [];
    i.length > 0 && this.notify("labels:added", { added: i, cell: this, edge: this }), r.length > 0 && this.notify("labels:removed", { removed: r, cell: this, edge: this });
  }
  // #endregion
  // #region vertices
  get vertices() {
    return this.getVertices();
  }
  set vertices(e) {
    this.setVertices(e);
  }
  getVertices() {
    return [...this.store.get("vertices", [])];
  }
  setVertices(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    return this.store.set("vertices", i.map((r) => z.toJSON(r)), t), this;
  }
  insertVertex(e, t, i = {}) {
    const r = this.getVertices(), s = r.length;
    let o = t != null && Number.isFinite(t) ? t : s;
    return o < 0 && (o = s + o + 1), r.splice(o, 0, z.toJSON(e)), this.setVertices(r, i);
  }
  appendVertex(e, t = {}) {
    return this.insertVertex(e, -1, t);
  }
  getVertexAt(e) {
    return e != null && Number.isFinite(e) ? this.getVertices()[e] : null;
  }
  setVertexAt(e, t, i = {}) {
    if (e != null && Number.isFinite(e)) {
      const r = this.getVertices();
      r[e] = t, this.setVertices(r, i);
    }
    return this;
  }
  removeVertexAt(e, t = {}) {
    const i = this.getVertices(), r = e != null && Number.isFinite(e) ? e : -1;
    return i.splice(r, 1), this.setVertices(i, t);
  }
  onVertexsChanged({ previous: e, current: t }) {
    const i = e && t ? t.filter((s) => e.find((o) => z.equals(s, o)) ? null : s) : t ? [...t] : [], r = e && t ? e.filter((s) => t.find((o) => z.equals(s, o)) ? null : s) : e ? [...e] : [];
    i.length > 0 && this.notify("vertexs:added", { added: i, cell: this, edge: this }), r.length > 0 && this.notify("vertexs:removed", { removed: r, cell: this, edge: this });
  }
  // #endregion
  // #region markup
  getDefaultMarkup() {
    return this.store.get("defaultMarkup") || Yt.getEdgeMarkup();
  }
  getMarkup() {
    return super.getMarkup() || this.getDefaultMarkup();
  }
  // #endregion
  // #region transform
  /**
   * Translate the edge vertices (and source and target if they are points)
   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
   */
  translate(e, t, i = {}) {
    return i.translateBy = i.translateBy || this.id, i.tx = e, i.ty = t, this.applyToPoints((r) => ({
      x: (r.x || 0) + e,
      y: (r.y || 0) + t
    }), i);
  }
  /**
   * Scales the edge's points (vertices) relative to the given origin.
   */
  scale(e, t, i, r = {}) {
    return this.applyToPoints((s) => z.create(s).scale(e, t, i).toJSON(), r);
  }
  applyToPoints(e, t = {}) {
    const i = {}, r = this.getSource(), s = this.getTarget();
    z.isPointLike(r) && (i.source = e(r)), z.isPointLike(s) && (i.target = e(s));
    const o = this.getVertices();
    return o.length > 0 && (i.vertices = o.map(e)), this.store.set(i, t), this;
  }
  // #endregion
  // #region common
  getBBox() {
    return this.getPolyline().bbox();
  }
  getConnectionPoint() {
    return this.getPolyline().pointAt(0.5);
  }
  getPolyline() {
    const e = [
      this.getSourcePoint(),
      ...this.getVertices().map((t) => z.create(t)),
      this.getTargetPoint()
    ];
    return new En(e);
  }
  updateParent(e) {
    let t = null;
    const i = this.getSourceCell(), r = this.getTargetCell(), s = this.getParent();
    return i && r && (i === r || i.isDescendantOf(r) ? t = r : r.isDescendantOf(i) ? t = i : t = gt.getCommonAncestor(i, r)), s && t && t.id !== s.id && s.unembed(this, e), t && (!s || s.id !== t.id) && t.embed(this, e), t;
  }
  hasLoop(e = {}) {
    const t = this.getSource(), i = this.getTarget(), r = t.cell, s = i.cell;
    if (!r || !s)
      return !1;
    let o = r === s;
    if (!o && e.deep && this._model) {
      const a = this.getSourceCell(), l = this.getTargetCell();
      a && l && (o = a.isAncestorOf(l, e) || l.isAncestorOf(a, e));
    }
    return o;
  }
  getFragmentAncestor() {
    const e = [this, this.getSourceNode(), this.getTargetNode()].filter((t) => t != null);
    return this.getCommonAncestor(...e);
  }
  isFragmentDescendantOf(e) {
    const t = this.getFragmentAncestor();
    return !!t && (t.id === e.id || t.isDescendantOf(e));
  }
};
xn.defaults = {};
(function(n) {
  function e(t, i) {
    const r = t, s = i;
    return r.cell === s.cell ? r.port === s.port || r.port == null && s.port == null : !1;
  }
  n.equalTerminals = e;
})(xn || (xn = {}));
(function(n) {
  n.defaultLabel = {
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      text: {
        fill: "#000",
        fontSize: 14,
        textAnchor: "middle",
        textVerticalAnchor: "middle",
        pointerEvents: "none"
      },
      rect: {
        ref: "label",
        fill: "#fff",
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };
  function e(t) {
    return {
      attrs: { label: { text: t } }
    };
  }
  n.parseStringLabel = e;
})(xn || (xn = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && typeof r.isNode == "function" && typeof r.isEdge == "function" && typeof r.prop == "function" && typeof r.attr == "function" && typeof r.disconnect == "function" && typeof r.getSource == "function" && typeof r.getTarget == "function";
  }
  n.isEdge = e;
})(xn || (xn = {}));
(function(n) {
  n.registry = $n.create({
    type: "edge",
    process(e, t) {
      if (Bu.exist(e, !1))
        throw new Error(`Edge with name '${e}' was registered by anthor Node`);
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let i = n;
      const { inherit: r = "edge" } = t, s = Rv(t, ["inherit"]);
      if (typeof r == "string") {
        const a = this.get(r || "edge");
        a == null && r ? this.onNotFound(r, "inherited") : i = a;
      } else
        i = r;
      s.constructorName == null && (s.constructorName = e);
      const o = i.define.call(i, s);
      return o.config({ shape: e }), o;
    }
  }), Bu.setEdgeRegistry(n.registry);
})(xn || (xn = {}));
(function(n) {
  let e = 0;
  function t(s) {
    return s ? Iw(s) : (e += 1, `CustomEdge${e}`);
  }
  function i(s) {
    const { constructorName: o, overwrite: a } = s, l = Rv(s, ["constructorName", "overwrite"]), c = Dw(t(o || l.shape), this);
    return c.config(l), l.shape && n.registry.register(l.shape, c, a), c;
  }
  n.define = i;
  function r(s) {
    const o = s.shape || "edge", a = n.registry.get(o);
    return a ? new a(s) : n.registry.onNotFound(o);
  }
  n.create = r;
})(xn || (xn = {}));
(function(n) {
  const e = "basic.edge";
  n.config({
    shape: e,
    propHooks(t) {
      const { label: i, vertices: r } = t, s = Rv(t, ["label", "vertices"]);
      if (i) {
        s.labels == null && (s.labels = []);
        const o = typeof i == "string" ? n.parseStringLabel(i) : i;
        s.labels.push(o);
      }
      return r && Array.isArray(r) && (s.vertices = r.map((o) => z.create(o).toJSON())), s;
    }
  }), n.registry.register(e, n);
})(xn || (xn = {}));
var jse = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class gm extends gn {
  constructor(e, t = {}) {
    super(), this.length = 0, this.comparator = t.comparator || "zIndex", this.clean(), e && this.reset(e, { silent: !0 });
  }
  toJSON() {
    return this.cells.map((e) => e.toJSON());
  }
  add(e, t, i) {
    let r, s;
    typeof t == "number" ? (r = t, s = Object.assign({ merge: !1 }, i)) : (r = this.length, s = Object.assign({ merge: !1 }, t)), r > this.length && (r = this.length), r < 0 && (r += this.length + 1);
    const o = Array.isArray(e) ? e : [e], a = this.comparator && typeof t != "number" && s.sort !== !1, l = this.comparator || null;
    let c = !1;
    const u = [], h = [];
    return o.forEach((d) => {
      const f = this.get(d);
      f ? s.merge && !d.isSameStore(f) && (f.setProp(d.getProp(), i), h.push(f), a && !c && (l == null || typeof l == "function" ? c = f.hasChanged() : typeof l == "string" ? c = f.hasChanged(l) : c = l.some((p) => f.hasChanged(p)))) : (u.push(d), this.reference(d));
    }), u.length && (a && (c = !0), this.cells.splice(r, 0, ...u), this.length = this.cells.length), c && this.sort({ silent: !0 }), s.silent || (u.forEach((d, f) => {
      const p = {
        cell: d,
        index: r + f,
        options: s
      };
      this.trigger("added", p), s.dryrun || d.notify("added", Object.assign({}, p));
    }), c && this.trigger("sorted"), (u.length || h.length) && this.trigger("updated", {
      added: u,
      merged: h,
      removed: [],
      options: s
    })), this;
  }
  remove(e, t = {}) {
    const i = Array.isArray(e) ? e : [e], r = this.removeCells(i, t);
    return !t.silent && r.length > 0 && this.trigger("updated", {
      options: t,
      removed: r,
      added: [],
      merged: []
    }), Array.isArray(e) ? r : r[0];
  }
  removeCells(e, t) {
    const i = [];
    for (let r = 0; r < e.length; r += 1) {
      const s = this.get(e[r]);
      if (s == null)
        continue;
      const o = this.cells.indexOf(s);
      this.cells.splice(o, 1), this.length -= 1, delete this.map[s.id], i.push(s), this.unreference(s), t.dryrun || s.remove(), t.silent || (this.trigger("removed", { cell: s, index: o, options: t }), t.dryrun || s.notify("removed", { cell: s, index: o, options: t }));
    }
    return i;
  }
  reset(e, t = {}) {
    const i = this.cells.slice();
    if (i.forEach((r) => this.unreference(r)), this.clean(), this.add(e, Object.assign({ silent: !0 }, t)), !t.silent) {
      const r = this.cells.slice();
      this.trigger("reseted", {
        options: t,
        previous: i,
        current: r
      });
      const s = [], o = [];
      r.forEach((a) => {
        i.some((c) => c.id === a.id) || s.push(a);
      }), i.forEach((a) => {
        r.some((c) => c.id === a.id) || o.push(a);
      }), this.trigger("updated", { options: t, added: s, removed: o, merged: [] });
    }
    return this;
  }
  push(e, t) {
    return this.add(e, this.length, t);
  }
  pop(e) {
    const t = this.at(this.length - 1);
    return this.remove(t, e);
  }
  unshift(e, t) {
    return this.add(e, 0, t);
  }
  shift(e) {
    const t = this.at(0);
    return this.remove(t, e);
  }
  get(e) {
    if (e == null)
      return null;
    const t = typeof e == "string" || typeof e == "number" ? e : e.id;
    return this.map[t] || null;
  }
  has(e) {
    return this.get(e) != null;
  }
  at(e) {
    return e < 0 && (e += this.length), this.cells[e] || null;
  }
  first() {
    return this.at(0);
  }
  last() {
    return this.at(-1);
  }
  indexOf(e) {
    return this.cells.indexOf(e);
  }
  toArray() {
    return this.cells.slice();
  }
  sort(e = {}) {
    return this.comparator != null && (this.cells = N$(this.cells, this.comparator), e.silent || this.trigger("sorted")), this;
  }
  clone() {
    const e = this.constructor;
    return new e(this.cells.slice(), {
      comparator: this.comparator
    });
  }
  reference(e) {
    this.map[e.id] = e, e.on("*", this.notifyCellEvent, this);
  }
  unreference(e) {
    e.off("*", this.notifyCellEvent, this), delete this.map[e.id];
  }
  notifyCellEvent(e, t) {
    const i = t.cell;
    this.trigger(`cell:${e}`, t), i && (i.isNode() ? this.trigger(`node:${e}`, Object.assign(Object.assign({}, t), { node: i })) : i.isEdge() && this.trigger(`edge:${e}`, Object.assign(Object.assign({}, t), { edge: i })));
  }
  clean() {
    this.length = 0, this.cells = [], this.map = {};
  }
  dispose() {
    this.reset([]);
  }
}
jse([
  gm.dispose()
], gm.prototype, "dispose", null);
var Vse = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class lr extends gn {
  get [Symbol.toStringTag]() {
    return lr.toStringTag;
  }
  constructor(e = []) {
    super(), this.batches = {}, this.addings = /* @__PURE__ */ new WeakMap(), this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, this.collection = new gm(e), this.setup();
  }
  notify(e, t) {
    this.trigger(e, t);
    const i = this.graph;
    return i && (e === "sorted" || e === "reseted" || e === "updated" ? i.trigger(`model:${e}`, t) : i.trigger(e, t)), this;
  }
  setup() {
    const e = this.collection;
    e.on("sorted", () => this.notify("sorted", null)), e.on("updated", (t) => this.notify("updated", t)), e.on("cell:change:zIndex", () => this.sortOnChangeZ()), e.on("added", ({ cell: t }) => {
      this.onCellAdded(t);
    }), e.on("removed", (t) => {
      const i = t.cell;
      this.onCellRemoved(i, t.options), this.notify("cell:removed", t), i.isNode() ? this.notify("node:removed", Object.assign(Object.assign({}, t), { node: i })) : i.isEdge() && this.notify("edge:removed", Object.assign(Object.assign({}, t), { edge: i }));
    }), e.on("reseted", (t) => {
      this.onReset(t.current), this.notify("reseted", t);
    }), e.on("edge:change:source", ({ edge: t }) => this.onEdgeTerminalChanged(t, "source")), e.on("edge:change:target", ({ edge: t }) => {
      this.onEdgeTerminalChanged(t, "target");
    });
  }
  sortOnChangeZ() {
    this.collection.sort();
  }
  onCellAdded(e) {
    const t = e.id;
    e.isEdge() ? (e.updateParent(), this.edges[t] = !0, this.onEdgeTerminalChanged(e, "source"), this.onEdgeTerminalChanged(e, "target")) : this.nodes[t] = !0;
  }
  onCellRemoved(e, t) {
    const i = e.id;
    if (e.isEdge()) {
      delete this.edges[i];
      const r = e.getSource(), s = e.getTarget();
      if (r && r.cell) {
        const o = this.outgoings[r.cell], a = o ? o.indexOf(i) : -1;
        a >= 0 && (o.splice(a, 1), o.length === 0 && delete this.outgoings[r.cell]);
      }
      if (s && s.cell) {
        const o = this.incomings[s.cell], a = o ? o.indexOf(i) : -1;
        a >= 0 && (o.splice(a, 1), o.length === 0 && delete this.incomings[s.cell]);
      }
    } else
      delete this.nodes[i];
    t.clear || (t.disconnectEdges ? this.disconnectConnectedEdges(e, t) : this.removeConnectedEdges(e, t)), e.model === this && (e.model = null);
  }
  onReset(e) {
    this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, e.forEach((t) => this.onCellAdded(t));
  }
  onEdgeTerminalChanged(e, t) {
    const i = t === "source" ? this.outgoings : this.incomings, r = e.previous(t);
    if (r && r.cell) {
      const o = gt.isCell(r.cell) ? r.cell.id : r.cell, a = i[o], l = a ? a.indexOf(e.id) : -1;
      l >= 0 && (a.splice(l, 1), a.length === 0 && delete i[o]);
    }
    const s = e.getTerminal(t);
    if (s && s.cell) {
      const o = gt.isCell(s.cell) ? s.cell.id : s.cell, a = i[o] || [];
      a.indexOf(e.id) === -1 && a.push(e.id), i[o] = a;
    }
  }
  prepareCell(e, t) {
    return !e.model && (!t || !t.dryrun) && (e.model = this), e.zIndex == null && e.setZIndex(this.getMaxZIndex() + 1, { silent: !0 }), e;
  }
  resetCells(e, t = {}) {
    return e.map((i) => this.prepareCell(i, Object.assign(Object.assign({}, t), { dryrun: !0 }))), this.collection.reset(e, t), e.map((i) => this.prepareCell(i, { options: t })), this;
  }
  clear(e = {}) {
    const t = this.getCells();
    if (t.length === 0)
      return this;
    const i = Object.assign(Object.assign({}, e), { clear: !0 });
    return this.batchUpdate("clear", () => {
      const r = t.sort((s, o) => {
        const a = s.isEdge() ? 1 : 2, l = o.isEdge() ? 1 : 2;
        return a - l;
      });
      for (; r.length > 0; ) {
        const s = r.shift();
        s && s.remove(i);
      }
    }, i), this;
  }
  addNode(e, t = {}) {
    const i = Tn.isNode(e) ? e : this.createNode(e);
    return this.addCell(i, t), i;
  }
  updateNode(e, t = {}) {
    const i = this.createNode(e), r = i.getProp();
    return i.dispose(), this.updateCell(r, t);
  }
  createNode(e) {
    return Tn.create(e);
  }
  addEdge(e, t = {}) {
    const i = xn.isEdge(e) ? e : this.createEdge(e);
    return this.addCell(i, t), i;
  }
  createEdge(e) {
    return xn.create(e);
  }
  updateEdge(e, t = {}) {
    const i = this.createEdge(e), r = i.getProp();
    return i.dispose(), this.updateCell(r, t);
  }
  addCell(e, t = {}) {
    return Array.isArray(e) ? this.addCells(e, t) : (!this.collection.has(e) && !this.addings.has(e) && (this.addings.set(e, !0), this.collection.add(this.prepareCell(e, t), t), e.eachChild((i) => this.addCell(i, t)), this.addings.delete(e)), this);
  }
  addCells(e, t = {}) {
    const i = e.length;
    if (i === 0)
      return this;
    const r = Object.assign(Object.assign({}, t), { position: i - 1, maxPosition: i - 1 });
    return this.startBatch("add", Object.assign(Object.assign({}, r), { cells: e })), e.forEach((s) => {
      this.addCell(s, r), r.position -= 1;
    }), this.stopBatch("add", Object.assign(Object.assign({}, r), { cells: e })), this;
  }
  updateCell(e, t = {}) {
    const i = e.id && this.getCell(e.id);
    return i ? this.batchUpdate("update", () => (Object.entries(e).forEach(([r, s]) => i.setProp(r, s, t)), !0), e) : !1;
  }
  removeCell(e, t = {}) {
    const i = typeof e == "string" ? this.getCell(e) : e;
    return i && this.has(i) ? this.collection.remove(i, t) : null;
  }
  updateCellId(e, t) {
    if (e.id === t)
      return;
    this.startBatch("update", { id: t }), e.prop("id", t);
    const i = e.clone({ keepId: !0 });
    return this.addCell(i), this.getConnectedEdges(e).forEach((s) => {
      const o = s.getSourceCell(), a = s.getTargetCell();
      o === e && s.setSource(Object.assign(Object.assign({}, s.getSource()), { cell: t })), a === e && s.setTarget(Object.assign(Object.assign({}, s.getTarget()), { cell: t }));
    }), this.removeCell(e), this.stopBatch("update", { id: t }), i;
  }
  removeCells(e, t = {}) {
    return e.length ? this.batchUpdate("remove", () => e.map((i) => this.removeCell(i, t))) : [];
  }
  removeConnectedEdges(e, t = {}) {
    const i = this.getConnectedEdges(e);
    return i.forEach((r) => {
      r.remove(t);
    }), i;
  }
  disconnectConnectedEdges(e, t = {}) {
    const i = typeof e == "string" ? e : e.id;
    this.getConnectedEdges(e).forEach((r) => {
      const s = r.getSourceCellId(), o = r.getTargetCellId();
      s === i && r.setSource({ x: 0, y: 0 }, t), o === i && r.setTarget({ x: 0, y: 0 }, t);
    });
  }
  has(e) {
    return this.collection.has(e);
  }
  total() {
    return this.collection.length;
  }
  indexOf(e) {
    return this.collection.indexOf(e);
  }
  /**
   * Returns a cell from the graph by its id.
   */
  getCell(e) {
    return this.collection.get(e);
  }
  /**
   * Returns all the nodes and edges in the graph.
   */
  getCells() {
    return this.collection.toArray();
  }
  /**
   * Returns the first cell (node or edge) in the graph. The first cell is
   * defined as the cell with the lowest `zIndex`.
   */
  getFirstCell() {
    return this.collection.first();
  }
  /**
   * Returns the last cell (node or edge) in the graph. The last cell is
   * defined as the cell with the highest `zIndex`.
   */
  getLastCell() {
    return this.collection.last();
  }
  /**
   * Returns the lowest `zIndex` value in the graph.
   */
  getMinZIndex() {
    const e = this.collection.first();
    return e && e.getZIndex() || 0;
  }
  /**
   * Returns the highest `zIndex` value in the graph.
   */
  getMaxZIndex() {
    const e = this.collection.last();
    return e && e.getZIndex() || 0;
  }
  getCellsFromCache(e) {
    return e ? Object.keys(e).map((t) => this.getCell(t)).filter((t) => t != null) : [];
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.getCellsFromCache(this.nodes);
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.getCellsFromCache(this.edges);
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    const t = typeof e == "string" ? e : e.id, i = this.outgoings[t];
    return i ? i.map((r) => this.getCell(r)).filter((r) => r && r.isEdge()) : null;
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    const t = typeof e == "string" ? e : e.id, i = this.incomings[t];
    return i ? i.map((r) => this.getCell(r)).filter((r) => r && r.isEdge()) : null;
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    const i = [], r = typeof e == "string" ? this.getCell(e) : e;
    if (r == null)
      return i;
    const s = {}, o = t.indirect;
    let a = t.incoming, l = t.outgoing;
    a == null && l == null && (a = l = !0);
    const c = (u, h) => {
      const d = h ? this.getOutgoingEdges(u) : this.getIncomingEdges(u);
      if (d != null && d.forEach((f) => {
        s[f.id] || (i.push(f), s[f.id] = !0, o && (a && c(f, !1), l && c(f, !0)));
      }), o && u.isEdge()) {
        const f = h ? u.getTargetCell() : u.getSourceCell();
        f && f.isEdge() && (s[f.id] || (i.push(f), c(f, h)));
      }
    };
    if (l && c(r, !0), a && c(r, !1), t.deep) {
      const u = r.getDescendants({ deep: !0 }), h = {};
      u.forEach((f) => {
        f.isNode() && (h[f.id] = !0);
      });
      const d = (f, p) => {
        const g = p ? this.getOutgoingEdges(f.id) : this.getIncomingEdges(f.id);
        g != null && g.forEach((m) => {
          if (!s[m.id]) {
            const v = m.getSourceCell(), y = m.getTargetCell();
            if (!t.enclosed && v && h[v.id] && y && h[y.id])
              return;
            i.push(m), s[m.id] = !0;
          }
        });
      };
      u.forEach((f) => {
        f.isEdge() || (l && d(f, !0), a && d(f, !1));
      });
    }
    return i;
  }
  isBoundary(e, t) {
    const i = typeof e == "string" ? this.getCell(e) : e, r = t ? this.getIncomingEdges(i) : this.getOutgoingEdges(i);
    return r == null || r.length === 0;
  }
  getBoundaryNodes(e) {
    const t = [];
    return Object.keys(this.nodes).forEach((i) => {
      if (this.isBoundary(i, e)) {
        const r = this.getCell(i);
        r && t.push(r);
      }
    }), t;
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRoots() {
    return this.getBoundaryNodes(!0);
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafs() {
    return this.getBoundaryNodes(!1);
  }
  /**
   * Returns `true` if the node is a root node, i.e. there is no edges
   * coming to the node.
   */
  isRoot(e) {
    return this.isBoundary(e, !0);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e. there is no edges
   * going out from the node.
   */
  isLeaf(e) {
    return this.isBoundary(e, !1);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    let i = t.incoming, r = t.outgoing;
    i == null && r == null && (i = r = !0);
    const o = this.getConnectedEdges(e, t).reduce((a, l) => {
      const c = l.hasLoop(t), u = l.getSourceCell(), h = l.getTargetCell();
      return i && u && u.isNode() && !a[u.id] && (c || u !== e && (!t.deep || !u.isDescendantOf(e))) && (a[u.id] = u), r && h && h.isNode() && !a[h.id] && (c || h !== e && (!t.deep || !h.isDescendantOf(e))) && (a[h.id] = h), a;
    }, {});
    if (e.isEdge()) {
      if (i) {
        const a = e.getSourceCell();
        a && a.isNode() && !o[a.id] && (o[a.id] = a);
      }
      if (r) {
        const a = e.getTargetCell();
        a && a.isNode() && !o[a.id] && (o[a.id] = a);
      }
    }
    return Object.keys(o).map((a) => o[a]);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, i = {}) {
    let r = i.incoming, s = i.outgoing;
    return r == null && s == null && (r = s = !0), this.getConnectedEdges(e, i).some((o) => {
      const a = o.getSourceCell(), l = o.getTargetCell();
      return !!(r && a && a.id === t.id || s && l && l.id === t.id);
    });
  }
  getSuccessors(e, t = {}) {
    const i = [];
    return this.search(e, (r, s) => {
      r !== e && this.matchDistance(s, t.distance) && i.push(r);
    }, Object.assign(Object.assign({}, t), { outgoing: !0 })), i;
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, i = {}) {
    let r = !1;
    return this.search(e, (s, o) => {
      if (s === t && s !== e && this.matchDistance(o, i.distance))
        return r = !0, !1;
    }, Object.assign(Object.assign({}, i), { outgoing: !0 })), r;
  }
  getPredecessors(e, t = {}) {
    const i = [];
    return this.search(e, (r, s) => {
      r !== e && this.matchDistance(s, t.distance) && i.push(r);
    }, Object.assign(Object.assign({}, t), { incoming: !0 })), i;
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, i = {}) {
    let r = !1;
    return this.search(e, (s, o) => {
      if (s === t && s !== e && this.matchDistance(o, i.distance))
        return r = !0, !1;
    }, Object.assign(Object.assign({}, i), { incoming: !0 })), r;
  }
  matchDistance(e, t) {
    return t == null ? !0 : typeof t == "function" ? t(e) : Array.isArray(t) && t.includes(e) ? !0 : e === t;
  }
  /**
   * Returns the common ancestor of the passed cells.
   */
  getCommonAncestor(...e) {
    const t = [];
    return e.forEach((i) => {
      i && (Array.isArray(i) ? t.push(...i) : t.push(i));
    }), gt.getCommonAncestor(...t);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    const i = [], r = {}, s = [], o = [], a = (l) => {
      r[l.id] || (i.push(l), r[l.id] = l, l.isEdge() && o.push(l), l.isNode() && s.push(l));
    };
    return e.forEach((l) => {
      a(l), t.deep && l.getDescendants({ deep: !0 }).forEach((u) => a(u));
    }), o.forEach((l) => {
      const c = l.getSourceCell(), u = l.getTargetCell();
      c && !r[c.id] && (i.push(c), r[c.id] = c, c.isNode() && s.push(c)), u && !r[u.id] && (i.push(u), r[u.id] = u, u.isNode() && s.push(u));
    }), s.forEach((l) => {
      this.getConnectedEdges(l, t).forEach((u) => {
        const h = u.getSourceCell(), d = u.getTargetCell();
        !r[u.id] && h && r[h.id] && d && r[d.id] && (i.push(u), r[u.id] = u);
      });
    }), i;
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    const i = this.getSubGraph(e, t);
    return this.cloneCells(i);
  }
  cloneCells(e) {
    return gt.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    const i = typeof e == "number" ? { x: e, y: t || 0 } : e;
    return this.getNodes().filter((r) => r.getBBox().containsPoint(i));
  }
  getNodesInArea(e, t, i, r, s) {
    const o = typeof e == "number" ? new ye(e, t, i, r) : ye.create(e), a = typeof e == "number" ? s : t, l = a && a.strict;
    return this.getNodes().filter((c) => {
      const u = c.getBBox();
      return l ? o.containsRect(u) : o.isIntersectWithRect(u);
    });
  }
  getEdgesInArea(e, t, i, r, s) {
    const o = typeof e == "number" ? new ye(e, t, i, r) : ye.create(e), a = typeof e == "number" ? s : t, l = a && a.strict;
    return this.getEdges().filter((c) => {
      const u = c.getBBox();
      return u.width === 0 ? u.inflate(1, 0) : u.height === 0 && u.inflate(0, 1), l ? o.containsRect(u) : o.isIntersectWithRect(u);
    });
  }
  getNodesUnderNode(e, t = {}) {
    const i = e.getBBox();
    return (t.by == null || t.by === "bbox" ? this.getNodesInArea(i) : this.getNodesFromPoint(i[t.by])).filter((s) => e.id !== s.id && !s.isDescendantOf(e));
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.getCellsBBox(this.getCells());
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return gt.getCellsBBox(e, t);
  }
  // #region search
  search(e, t, i = {}) {
    i.breadthFirst ? this.breadthFirstSearch(e, t, i) : this.depthFirstSearch(e, t, i);
  }
  breadthFirstSearch(e, t, i = {}) {
    const r = [], s = {}, o = {};
    for (r.push(e), o[e.id] = 0; r.length > 0; ) {
      const a = r.shift();
      if (a == null || s[a.id] || (s[a.id] = !0, Ze(t, this, a, o[a.id]) === !1))
        continue;
      this.getNeighbors(a, i).forEach((c) => {
        o[c.id] = o[a.id] + 1, r.push(c);
      });
    }
  }
  depthFirstSearch(e, t, i = {}) {
    const r = [], s = {}, o = {};
    for (r.push(e), o[e.id] = 0; r.length > 0; ) {
      const a = r.pop();
      if (a == null || s[a.id] || (s[a.id] = !0, Ze(t, this, a, o[a.id]) === !1))
        continue;
      const l = this.getNeighbors(a, i), c = r.length;
      l.forEach((u) => {
        o[u.id] = o[a.id] + 1, r.splice(c, 0, u);
      });
    }
  }
  // #endregion
  // #region shortest path
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, i = {}) {
    const r = {};
    this.getEdges().forEach((c) => {
      const u = c.getSourceCellId(), h = c.getTargetCellId();
      u && h && (r[u] || (r[u] = []), r[h] || (r[h] = []), r[u].push(h), i.directed || r[h].push(u));
    });
    const s = typeof e == "string" ? e : e.id, o = Xy.run(r, s, i.weight), a = [];
    let l = typeof t == "string" ? t : t.id;
    for (o[l] && a.push(l); l = o[l]; )
      a.unshift(l);
    return a;
  }
  // #endregion
  // #region transform
  /**
   * Translate all cells in the graph by `tx` and `ty` pixels.
   */
  translate(e, t, i) {
    return this.getCells().filter((r) => !r.hasParent()).forEach((r) => r.translate(e, t, i)), this;
  }
  resize(e, t, i) {
    return this.resizeCells(e, t, this.getCells(), i);
  }
  resizeCells(e, t, i, r = {}) {
    const s = this.getCellsBBox(i);
    if (s) {
      const o = Math.max(e / s.width, 0), a = Math.max(t / s.height, 0), l = s.getOrigin();
      i.forEach((c) => c.scale(o, a, l, r));
    }
    return this;
  }
  // #endregion
  // #region serialize/deserialize
  toJSON(e = {}) {
    return lr.toJSON(this.getCells(), e);
  }
  parseJSON(e) {
    return lr.fromJSON(e);
  }
  fromJSON(e, t = {}) {
    const i = this.parseJSON(e);
    return this.resetCells(i, t), this;
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) + 1, this.notify("batch:start", { name: e, data: t }), this;
  }
  stopBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) - 1, this.notify("batch:stop", { name: e, data: t }), this;
  }
  batchUpdate(e, t, i = {}) {
    this.startBatch(e, i);
    const r = t();
    return this.stopBatch(e, i), r;
  }
  hasActiveBatch(e = Object.keys(this.batches)) {
    return (Array.isArray(e) ? e : [e]).some((i) => this.batches[i] > 0);
  }
  // #endregion
  dispose() {
    this.collection.dispose();
  }
}
Vse([
  lr.dispose()
], lr.prototype, "dispose", null);
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && typeof r.addNode == "function" && typeof r.addEdge == "function" && r.collection != null;
  }
  n.isModel = e;
})(lr || (lr = {}));
(function(n) {
  function e(i, r = {}) {
    return {
      cells: i.map((s) => s.toJSON(r))
    };
  }
  n.toJSON = e;
  function t(i) {
    const r = [];
    return Array.isArray(i) ? r.push(...i) : (i.cells && r.push(...i.cells), i.nodes && i.nodes.forEach((s) => {
      s.shape == null && (s.shape = "rect"), r.push(s);
    }), i.edges && i.edges.forEach((s) => {
      s.shape == null && (s.shape = "edge"), r.push(s);
    })), r.map((s) => {
      const o = s.shape;
      if (o) {
        if (Tn.registry.exist(o))
          return Tn.create(s);
        if (xn.registry.exist(o))
          return xn.create(s);
      }
      throw new Error("The `shape` should be specified when creating a node/edge instance");
    });
  }
  n.fromJSON = t;
})(lr || (lr = {}));
var Fse = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
let Va = class extends Tn {
  get label() {
    return this.getLabel();
  }
  set label(e) {
    this.setLabel(e);
  }
  getLabel() {
    return this.getAttrByPath("text/text");
  }
  setLabel(e, t) {
    return e == null ? this.removeLabel() : this.setAttrByPath("text/text", e, t), this;
  }
  removeLabel() {
    return this.removeAttrByPath("text/text"), this;
  }
};
(function(n) {
  n.bodyAttr = {
    fill: "#ffffff",
    stroke: "#333333",
    strokeWidth: 2
  }, n.labelAttr = {
    fontSize: 14,
    fill: "#000000",
    refX: 0.5,
    refY: 0.5,
    textAnchor: "middle",
    textVerticalAnchor: "middle",
    fontFamily: "Arial, helvetica, sans-serif"
  }, n.config({
    attrs: { text: Object.assign({}, n.labelAttr) },
    propHooks(e) {
      const { label: t } = e, i = Fse(e, ["label"]);
      return t && fh(i, "attrs/text/text", t), i;
    },
    visible: !0
  });
})(Va || (Va = {}));
var Zse = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
function qse(n, e = "body") {
  return [
    {
      tagName: n,
      selector: e
    },
    {
      tagName: "text",
      selector: "label"
    }
  ];
}
function Wse(n = "xlink:href") {
  return (t) => {
    const { imageUrl: i, imageWidth: r, imageHeight: s } = t, o = Zse(t, ["imageUrl", "imageWidth", "imageHeight"]);
    if (i != null || r != null || s != null) {
      const a = () => {
        if (o.attrs) {
          const l = o.attrs.image;
          i != null && (l[n] = i), r != null && (l.width = r), s != null && (l.height = s), o.attrs.image = l;
        }
      };
      o.attrs ? (o.attrs.image == null && (o.attrs.image = {}), a()) : (o.attrs = {
        image: {}
      }, a());
    }
    return o;
  };
}
function vh(n, e, t = {}) {
  const i = {
    constructorName: n,
    markup: qse(n, t.selector),
    attrs: {
      [n]: Object.assign({}, Va.bodyAttr)
    }
  };
  return (t.parent || Va).define(On(i, e, { shape: n }));
}
vh("rect", {
  attrs: {
    body: {
      refWidth: "100%",
      refHeight: "100%"
    }
  }
});
const Hse = xn.define({
  shape: "edge",
  markup: [
    {
      tagName: "path",
      selector: "wrap",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        cursor: "pointer",
        stroke: "transparent",
        strokeLinecap: "round"
      }
    },
    {
      tagName: "path",
      selector: "line",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        pointerEvents: "none"
      }
    }
  ],
  attrs: {
    lines: {
      connection: !0,
      strokeLinejoin: "round"
    },
    wrap: {
      strokeWidth: 10
    },
    line: {
      stroke: "#333",
      strokeWidth: 2,
      targetMarker: "classic"
    }
  }
});
vh("ellipse", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refRx: "50%",
      refRy: "50%"
    }
  }
});
var Xse = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class Qu extends Va {
  get points() {
    return this.getPoints();
  }
  set points(e) {
    this.setPoints(e);
  }
  getPoints() {
    return this.getAttrByPath("body/refPoints");
  }
  setPoints(e, t) {
    return e == null ? this.removePoints() : this.setAttrByPath("body/refPoints", Qu.pointsToString(e), t), this;
  }
  removePoints() {
    return this.removeAttrByPath("body/refPoints"), this;
  }
}
(function(n) {
  function e(t) {
    return typeof t == "string" ? t : t.map((i) => Array.isArray(i) ? i.join(",") : z.isPointLike(i) ? `${i.x}, ${i.y}` : "").join(" ");
  }
  n.pointsToString = e, n.config({
    propHooks(t) {
      const { points: i } = t, r = Xse(t, ["points"]);
      if (i) {
        const s = e(i);
        s && fh(r, "attrs/body/refPoints", s);
      }
      return r;
    }
  });
})(Qu || (Qu = {}));
vh("polygon", {}, { parent: Qu });
vh("polyline", {}, { parent: Qu });
var Yse = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
Va.define({
  shape: "path",
  markup: [
    {
      tagName: "rect",
      selector: "bg"
    },
    {
      tagName: "path",
      selector: "body"
    },
    {
      tagName: "text",
      selector: "label"
    }
  ],
  attrs: {
    bg: {
      refWidth: "100%",
      refHeight: "100%",
      fill: "none",
      stroke: "none",
      pointerEvents: "all"
    },
    body: {
      fill: "none",
      stroke: "#000",
      strokeWidth: 2
    }
  },
  propHooks(n) {
    const { path: e } = n, t = Yse(n, ["path"]);
    return e && fh(t, "attrs/body/refD", e), t;
  }
});
var Use = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
Va.define({
  shape: "text-block",
  markup: [
    {
      tagName: "rect",
      selector: "body"
    },
    La.SUPPORT_FOREIGNOBJECT ? {
      tagName: "foreignObject",
      selector: "foreignObject",
      children: [
        {
          tagName: "div",
          ns: si.xhtml,
          selector: "label",
          style: {
            width: "100%",
            height: "100%",
            position: "static",
            backgroundColor: "transparent",
            textAlign: "center",
            margin: 0,
            padding: "0px 5px",
            boxSizing: "border-box",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      ]
    } : {
      tagName: "text",
      selector: "label",
      attrs: {
        textAnchor: "middle"
      }
    }
  ],
  attrs: {
    body: Object.assign(Object.assign({}, Va.bodyAttr), { refWidth: "100%", refHeight: "100%" }),
    foreignObject: {
      refWidth: "100%",
      refHeight: "100%"
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },
  propHooks(n) {
    const { text: e } = n, t = Use(n, ["text"]);
    return e && fh(t, "attrs/label/text", e), t;
  },
  attrHooks: {
    text: {
      set(n, { cell: e, view: t, refBBox: i, elem: r, attrs: s }) {
        if (r instanceof HTMLElement)
          r.textContent = n;
        else {
          const o = s.style || {}, a = { text: n, width: -5, height: "100%" }, l = Object.assign({ textVerticalAnchor: "middle" }, o), c = po.presets.textWrap;
          return Ze(c.set, this, a, {
            cell: e,
            view: t,
            elem: r,
            refBBox: i,
            attrs: l
          }), { fill: o.color || null };
        }
      },
      position(n, { refBBox: e, elem: t }) {
        if (t instanceof SVGElement)
          return e.getCenter();
      }
    }
  }
});
vh("image", {
  attrs: {
    image: {
      refWidth: "100%",
      refHeight: "100%"
    }
  },
  propHooks: Wse()
}, {
  selector: "image"
});
vh("circle", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refR: "50%"
    }
  }
});
class $r extends An {
  constructor() {
    super(...arguments), this.portsCache = {};
  }
  get [Symbol.toStringTag]() {
    return $r.toStringTag;
  }
  getContainerClassName() {
    const e = [
      super.getContainerClassName(),
      this.prefixClassName("node")
    ];
    return this.can("nodeMovable") || e.push(this.prefixClassName("node-immovable")), e.join(" ");
  }
  updateClassName(e) {
    const t = e.target;
    if (t.hasAttribute("magnet")) {
      const i = this.prefixClassName("port-unconnectable");
      this.can("magnetConnectable") ? Nn(t, i) : Ye(t, i);
    } else {
      const i = this.prefixClassName("node-immovable");
      this.can("nodeMovable") ? this.removeClass(i) : this.addClass(i);
    }
  }
  isNodeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let i = e;
    return this.hasAction(i, "ports") && (this.removePorts(), this.cleanPortsCache()), this.hasAction(i, "render") ? (this.render(), i = this.removeAction(i, [
      "render",
      "update",
      "resize",
      "translate",
      "rotate",
      "ports",
      "tools"
    ])) : (i = this.handleAction(i, "resize", () => this.resize(), "update"), i = this.handleAction(
      i,
      "update",
      () => this.update(),
      // `update()` will render ports when useCSSSelectors are enabled
      "ports"
    ), i = this.handleAction(i, "translate", () => this.translate()), i = this.handleAction(i, "rotate", () => this.rotate()), i = this.handleAction(i, "ports", () => this.renderPorts()), i = this.handleAction(i, "tools", () => {
      this.getFlag("tools") === e ? this.renderTools() : this.updateTools(t);
    })), i;
  }
  update(e) {
    this.cleanCache(), this.removePorts();
    const t = this.cell, i = t.getSize(), r = t.getAttrs();
    this.updateAttrs(this.container, r, {
      attrs: e === r ? null : e,
      rootBBox: new ye(0, 0, i.width, i.height),
      selectors: this.selectors
    }), this.renderPorts();
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid node markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.appendChild(t.fragment);
  }
  render() {
    return this.empty(), this.renderMarkup(), this.resize(), this.updateTransform(), this.renderTools(), this;
  }
  resize() {
    this.cell.getAngle() && this.rotate(), this.update();
  }
  translate() {
    this.updateTransform();
  }
  rotate() {
    this.updateTransform();
  }
  getTranslationString() {
    const e = this.cell.getPosition();
    return `translate(${e.x},${e.y})`;
  }
  getRotationString() {
    const e = this.cell.getAngle();
    if (e) {
      const t = this.cell.getSize();
      return `rotate(${e},${t.width / 2},${t.height / 2})`;
    }
  }
  updateTransform() {
    let e = this.getTranslationString();
    const t = this.getRotationString();
    t && (e += ` ${t}`), this.container.setAttribute("transform", e);
  }
  // #region ports
  findPortElem(e, t) {
    const i = e ? this.portsCache[e] : null;
    if (!i)
      return null;
    const r = i.portContentElement, s = i.portContentSelectors || {};
    return this.findOne(t, r, s);
  }
  cleanPortsCache() {
    this.portsCache = {};
  }
  removePorts() {
    Object.values(this.portsCache).forEach((e) => {
      ro(e.portElement);
    });
  }
  renderPorts() {
    const e = this.container, t = [];
    e.childNodes.forEach((o) => {
      t.push(o);
    });
    const i = this.cell.getParsedPorts(), r = jS(i, "zIndex"), s = "auto";
    r[s] && r[s].forEach((o) => {
      const a = this.getPortElement(o);
      e.append(a), t.push(a);
    }), Object.keys(r).forEach((o) => {
      if (o !== s) {
        const a = parseInt(o, 10);
        this.appendPorts(r[o], a, t);
      }
    }), this.updatePorts();
  }
  appendPorts(e, t, i) {
    const r = e.map((s) => this.getPortElement(s));
    i[t] || t < 0 ? Zw(i[Math.max(t, 0)], r) : Ja(this.container, r);
  }
  getPortElement(e) {
    const t = this.portsCache[e.id];
    return t ? t.portElement : this.createPortElement(e);
  }
  createPortElement(e) {
    let t = Yt.renderMarkup(this.cell.getPortContainerMarkup());
    const i = t.elem;
    if (i == null)
      throw new Error("Invalid port container markup.");
    t = Yt.renderMarkup(this.getPortMarkup(e));
    const r = t.elem, s = t.selectors;
    if (r == null)
      throw new Error("Invalid port markup.");
    this.setAttrs({
      port: e.id,
      "port-group": e.group
    }, r);
    let o = "x6-port";
    e.group && (o += ` x6-port-${e.group}`), Ye(i, o), Ye(i, "x6-port"), Ye(r, "x6-port-body"), i.appendChild(r);
    let a = s, l, c;
    if (this.existPortLabel(e)) {
      if (t = Yt.renderMarkup(this.getPortLabelMarkup(e.label)), l = t.elem, c = t.selectors, l == null)
        throw new Error("Invalid port label markup.");
      if (s && c) {
        for (const h in c)
          if (s[h] && h !== this.rootSelector)
            throw new Error("Selectors within port must be unique.");
        a = Object.assign(Object.assign({}, s), c);
      }
      Ye(l, "x6-port-label"), i.appendChild(l);
    }
    return this.portsCache[e.id] = {
      portElement: i,
      portSelectors: a,
      portLabelElement: l,
      portLabelSelectors: c,
      portContentElement: r,
      portContentSelectors: s
    }, this.graph.options.onPortRendered && this.graph.options.onPortRendered({
      port: e,
      node: this.cell,
      container: i,
      selectors: a,
      labelContainer: l,
      labelSelectors: c,
      contentContainer: r,
      contentSelectors: s
    }), i;
  }
  updatePorts() {
    const e = this.cell.getParsedGroups(), t = Object.keys(e);
    t.length === 0 ? this.updatePortGroup() : t.forEach((i) => this.updatePortGroup(i));
  }
  updatePortGroup(e) {
    const t = ye.fromSize(this.cell.getSize()), i = this.cell.getPortsLayoutByGroup(e, t);
    for (let r = 0, s = i.length; r < s; r += 1) {
      const o = i[r], a = o.portId, l = this.portsCache[a] || {}, c = o.portLayout;
      if (this.applyPortTransform(l.portElement, c), o.portAttrs != null) {
        const h = {
          selectors: l.portSelectors || {}
        };
        o.portSize && (h.rootBBox = ye.fromSize(o.portSize)), this.updateAttrs(l.portElement, o.portAttrs, h);
      }
      const u = o.labelLayout;
      if (u && l.portLabelElement && (this.applyPortTransform(l.portLabelElement, u, -(c.angle || 0)), u.attrs)) {
        const h = {
          selectors: l.portLabelSelectors || {}
        };
        o.labelSize && (h.rootBBox = ye.fromSize(o.labelSize)), this.updateAttrs(l.portLabelElement, u.attrs, h);
      }
    }
  }
  applyPortTransform(e, t, i = 0) {
    const r = t.angle, s = t.position, o = ci().rotate(i).translate(s.x || 0, s.y || 0).rotate(r || 0);
    Eu(e, o, { absolute: !0 });
  }
  getPortMarkup(e) {
    return e.markup || this.cell.portMarkup;
  }
  getPortLabelMarkup(e) {
    return e.markup || this.cell.portLabelMarkup;
  }
  existPortLabel(e) {
    return e.attrs && e.attrs.text;
  }
  getEventArgs(e, t, i) {
    const r = this, s = r.cell, o = s;
    return t == null || i == null ? { e, view: r, node: s, cell: o } : { e, x: t, y: i, view: r, node: s, cell: o };
  }
  getPortEventArgs(e, t, i) {
    const r = this, s = r.cell, o = s;
    return i ? {
      e,
      x: i.x,
      y: i.y,
      view: r,
      node: s,
      cell: o,
      port: t
    } : { e, view: r, node: s, cell: o, port: t };
  }
  notifyMouseDown(e, t, i) {
    super.onMouseDown(e, t, i), this.notify("node:mousedown", this.getEventArgs(e, t, i));
  }
  notifyMouseMove(e, t, i) {
    super.onMouseMove(e, t, i), this.notify("node:mousemove", this.getEventArgs(e, t, i));
  }
  notifyMouseUp(e, t, i) {
    super.onMouseUp(e, t, i), this.notify("node:mouseup", this.getEventArgs(e, t, i));
  }
  notifyPortEvent(e, t, i) {
    const r = this.findAttr("port", t.target);
    if (r) {
      const s = t.type;
      e === "node:port:mouseenter" ? t.type = "mouseenter" : e === "node:port:mouseleave" && (t.type = "mouseleave"), this.notify(e, this.getPortEventArgs(t, r, i)), t.type = s;
    }
  }
  onClick(e, t, i) {
    super.onClick(e, t, i), this.notify("node:click", this.getEventArgs(e, t, i)), this.notifyPortEvent("node:port:click", e, { x: t, y: i });
  }
  onDblClick(e, t, i) {
    super.onDblClick(e, t, i), this.notify("node:dblclick", this.getEventArgs(e, t, i)), this.notifyPortEvent("node:port:dblclick", e, { x: t, y: i });
  }
  onContextMenu(e, t, i) {
    super.onContextMenu(e, t, i), this.notify("node:contextmenu", this.getEventArgs(e, t, i)), this.notifyPortEvent("node:port:contextmenu", e, { x: t, y: i });
  }
  onMouseDown(e, t, i) {
    this.isPropagationStopped(e) || (this.notifyMouseDown(e, t, i), this.notifyPortEvent("node:port:mousedown", e, { x: t, y: i }), this.startNodeDragging(e, t, i));
  }
  onMouseMove(e, t, i) {
    const r = this.getEventData(e), s = r.action;
    if (s === "magnet")
      this.dragMagnet(e, t, i);
    else {
      if (s === "move") {
        const a = r.targetView || this;
        a.dragNode(e, t, i), a.notify("node:moving", {
          e,
          x: t,
          y: i,
          view: a,
          cell: a.cell,
          node: a.cell
        });
      }
      this.notifyMouseMove(e, t, i), this.notifyPortEvent("node:port:mousemove", e, { x: t, y: i });
    }
    this.setEventData(e, r);
  }
  onMouseUp(e, t, i) {
    const r = this.getEventData(e), s = r.action;
    s === "magnet" ? this.stopMagnetDragging(e, t, i) : (this.notifyMouseUp(e, t, i), this.notifyPortEvent("node:port:mouseup", e, { x: t, y: i }), s === "move" && (r.targetView || this).stopNodeDragging(e, t, i));
    const o = r.targetMagnet;
    o && this.onMagnetClick(e, o, t, i), this.checkMouseleave(e);
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("node:mouseover", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseenter", e), this.notifyPortEvent("node:port:mouseover", e);
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("node:mouseout", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseleave", e), this.notifyPortEvent("node:port:mouseout", e);
  }
  onMouseEnter(e) {
    this.updateClassName(e), super.onMouseEnter(e), this.notify("node:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("node:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, i, r) {
    super.onMouseWheel(e, t, i, r), this.notify("node:mousewheel", Object.assign({ delta: r }, this.getEventArgs(e, t, i)));
  }
  onMagnetClick(e, t, i, r) {
    const s = this.graph;
    s.view.getMouseMovedCount(e) > s.options.clickThreshold || this.notify("node:magnet:click", Object.assign({ magnet: t }, this.getEventArgs(e, i, r)));
  }
  onMagnetDblClick(e, t, i, r) {
    this.notify("node:magnet:dblclick", Object.assign({ magnet: t }, this.getEventArgs(e, i, r)));
  }
  onMagnetContextMenu(e, t, i, r) {
    this.notify("node:magnet:contextmenu", Object.assign({ magnet: t }, this.getEventArgs(e, i, r)));
  }
  onMagnetMouseDown(e, t, i, r) {
    this.startMagnetDragging(e, i, r);
  }
  onCustomEvent(e, t, i, r) {
    this.notify("node:customevent", Object.assign({ name: t }, this.getEventArgs(e, i, r))), super.onCustomEvent(e, t, i, r);
  }
  prepareEmbedding(e) {
    const t = this.graph, r = this.getEventData(e).cell || this.cell, s = t.findViewByCell(r), o = t.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embed", {
      e,
      node: r,
      view: s,
      cell: r,
      x: o.x,
      y: o.y,
      currentParent: r.getParent()
    });
  }
  processEmbedding(e, t) {
    const i = t.cell || this.cell, r = t.graph || this.graph, s = r.options.embedding, o = s.findParent;
    let a = typeof o == "function" ? Ze(o, r, {
      view: this,
      node: this.cell
    }).filter((d) => gt.isCell(d) && this.cell.id !== d.id && !d.isDescendantOf(this.cell)) : r.model.getNodesUnderNode(i, {
      by: o
    });
    if (s.frontOnly && a.length > 0) {
      const d = jS(a, "zIndex"), f = zz(Object.keys(d).map((p) => parseInt(p, 10)));
      f && (a = d[f]);
    }
    a = a.filter((d) => d.visible);
    let l = null;
    const c = t.candidateEmbedView, u = s.validate;
    for (let d = a.length - 1; d >= 0; d -= 1) {
      const f = a[d];
      if (c && c.cell.id === f.id) {
        l = c;
        break;
      } else {
        const p = f.findView(r);
        if (u && Ze(u, r, {
          child: this.cell,
          parent: p.cell,
          childView: this,
          parentView: p
        })) {
          l = p;
          break;
        }
      }
    }
    this.clearEmbedding(t), l && l.highlight(null, { type: "embedding" }), t.candidateEmbedView = l;
    const h = r.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embedding", {
      e,
      cell: i,
      node: i,
      view: r.findViewByCell(i),
      x: h.x,
      y: h.y,
      currentParent: i.getParent(),
      candidateParent: l ? l.cell : null
    });
  }
  clearEmbedding(e) {
    const t = e.candidateEmbedView;
    t && (t.unhighlight(null, { type: "embedding" }), e.candidateEmbedView = null);
  }
  finalizeEmbedding(e, t) {
    this.graph.startBatch("embedding");
    const i = t.cell || this.cell, r = t.graph || this.graph, s = r.findViewByCell(i), o = i.getParent(), a = t.candidateEmbedView;
    if (a ? (a.unhighlight(null, { type: "embedding" }), t.candidateEmbedView = null, (o == null || o.id !== a.cell.id) && a.cell.insertChild(i, void 0, { ui: !0 })) : o && o.unembed(i, { ui: !0 }), r.model.getConnectedEdges(i, { deep: !0 }).forEach((l) => {
      l.updateParent({ ui: !0 });
    }), s && a) {
      const l = r.snapToGrid(e.clientX, e.clientY);
      s.notify("node:embedded", {
        e,
        cell: i,
        x: l.x,
        y: l.y,
        node: i,
        view: r.findViewByCell(i),
        previousParent: o,
        currentParent: i.getParent()
      });
    }
    this.graph.stopBatch("embedding");
  }
  getDelegatedView() {
    let e = this.cell, t = this;
    for (; t && !e.isEdge(); ) {
      if (!e.hasParent() || t.can("stopDelegateOnDragging"))
        return t;
      e = e.getParent(), t = this.graph.findViewByCell(e);
    }
    return null;
  }
  validateMagnet(e, t, i) {
    if (t.getAttribute("magnet") !== "passive") {
      const r = this.graph.options.connecting.validateMagnet;
      return r ? Ze(r, this.graph, {
        e: i,
        magnet: t,
        view: e,
        cell: e.cell
      }) : !0;
    }
    return !1;
  }
  startMagnetDragging(e, t, i) {
    if (!this.can("magnetConnectable"))
      return;
    e.stopPropagation();
    const r = e.currentTarget, s = this.graph;
    this.setEventData(e, {
      targetMagnet: r
    }), this.validateMagnet(this, r, e) ? (s.options.magnetThreshold <= 0 && this.startConnectting(e, r, t, i), this.setEventData(e, {
      action: "magnet"
    }), this.stopPropagation(e)) : this.onMouseDown(e, t, i), s.view.delegateDragEvents(e, this);
  }
  startConnectting(e, t, i, r) {
    this.graph.model.startBatch("add-edge");
    const s = this.createEdgeFromMagnet(t, i, r);
    s.setEventData(e, s.prepareArrowheadDragging("target", {
      x: i,
      y: r,
      isNewEdge: !0,
      fallbackAction: "remove"
    })), this.setEventData(e, { edgeView: s }), s.notifyMouseDown(e, i, r);
  }
  getDefaultEdge(e, t) {
    let i;
    const r = this.graph.options.connecting.createEdge;
    return r && (i = Ze(r, this.graph, {
      sourceMagnet: t,
      sourceView: e,
      sourceCell: e.cell
    })), i;
  }
  createEdgeFromMagnet(e, t, i) {
    const r = this.graph, s = r.model, o = this.getDefaultEdge(this, e);
    return o.setSource(Object.assign(Object.assign({}, o.getSource()), this.getEdgeTerminal(e, t, i, o, "source"))), o.setTarget(Object.assign(Object.assign({}, o.getTarget()), { x: t, y: i })), o.addTo(s, { async: !1, ui: !0 }), o.findView(r);
  }
  dragMagnet(e, t, i) {
    const r = this.getEventData(e), s = r.edgeView;
    if (s)
      s.onMouseMove(e, t, i), this.autoScrollGraph(e.clientX, e.clientY);
    else {
      const o = this.graph, a = o.options.magnetThreshold, l = this.getEventTarget(e), c = r.targetMagnet;
      if (a === "onleave") {
        if (c === l || c.contains(l))
          return;
      } else if (o.view.getMouseMovedCount(e) <= a)
        return;
      this.startConnectting(e, c, t, i);
    }
  }
  stopMagnetDragging(e, t, i) {
    const s = this.eventData(e).edgeView;
    s && (s.onMouseUp(e, t, i), this.graph.model.stopBatch("add-edge"));
  }
  notifyUnhandledMouseDown(e, t, i) {
    this.notify("node:unhandled:mousedown", {
      e,
      x: t,
      y: i,
      view: this,
      cell: this.cell,
      node: this.cell
    });
  }
  notifyNodeMove(e, t, i, r, s) {
    let o = [s];
    const a = this.graph.getPlugin("selection");
    if (a && a.isSelectionMovable()) {
      const l = a.getSelectedCells();
      l.includes(s) && (o = l.filter((c) => c.isNode()));
    }
    o.forEach((l) => {
      this.notify(e, {
        e: t,
        x: i,
        y: r,
        cell: l,
        node: l,
        view: l.findView(this.graph)
      });
    });
  }
  getRestrictArea(e) {
    const t = this.graph.options.translating.restrict, i = typeof t == "function" ? Ze(t, this.graph, e) : t;
    return typeof i == "number" ? this.graph.transform.getGraphArea().inflate(i) : i === !0 ? this.graph.transform.getGraphArea() : i || null;
  }
  startNodeDragging(e, t, i) {
    const r = this.getDelegatedView();
    if (r == null || !r.can("nodeMovable"))
      return this.notifyUnhandledMouseDown(e, t, i);
    this.setEventData(e, {
      targetView: r,
      action: "move"
    });
    const s = z.create(r.cell.getPosition());
    r.setEventData(e, {
      moving: !1,
      offset: s.diff(t, i),
      restrict: this.getRestrictArea(r)
    });
  }
  dragNode(e, t, i) {
    const r = this.cell, s = this.graph, o = s.getGridSize(), a = this.getEventData(e), l = a.offset, c = a.restrict;
    a.moving || (a.moving = !0, this.addClass("node-moving"), this.notifyNodeMove("node:move", e, t, i, this.cell)), this.autoScrollGraph(e.clientX, e.clientY);
    const u = At.snapToGrid(t + l.x, o), h = At.snapToGrid(i + l.y, o);
    r.setPosition(u, h, {
      restrict: c,
      deep: !0,
      ui: !0
    }), s.options.embedding.enabled && (a.embedding || (this.prepareEmbedding(e), a.embedding = !0), this.processEmbedding(e, a));
  }
  stopNodeDragging(e, t, i) {
    const r = this.getEventData(e);
    r.embedding && this.finalizeEmbedding(e, r), r.moving && (this.removeClass("node-moving"), this.notifyNodeMove("node:moved", e, t, i, this.cell)), r.moving = !1, r.embedding = !1;
  }
  // eslint-disable-next-line
  autoScrollGraph(e, t) {
    const i = this.graph.getPlugin("scroller");
    i && i.autoScroll(e, t);
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && typeof r.isNodeView == "function" && typeof r.isEdgeView == "function" && typeof r.confirmUpdate == "function" && typeof r.update == "function" && typeof r.findPortElem == "function" && typeof r.resize == "function" && typeof r.rotate == "function" && typeof r.translate == "function";
  }
  n.isNodeView = e;
})($r || ($r = {}));
$r.config({
  isSvgElement: !0,
  priority: 0,
  bootstrap: ["render"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    size: ["resize", "ports", "tools"],
    angle: ["rotate", "tools"],
    position: ["translate", "tools"],
    ports: ["ports"],
    tools: ["tools"]
  }
});
$r.registry.register("node", $r, !0);
var Gse = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class Wo extends An {
  constructor() {
    super(...arguments), this.POINT_ROUNDING = 2, this.labelDestroyFn = {};
  }
  get [Symbol.toStringTag]() {
    return Wo.toStringTag;
  }
  getContainerClassName() {
    return [super.getContainerClassName(), this.prefixClassName("edge")].join(" ");
  }
  get sourceBBox() {
    const e = this.sourceView;
    if (!e) {
      const i = this.cell.getSource();
      return new ye(i.x, i.y);
    }
    const t = this.sourceMagnet;
    return e.isEdgeElement(t) ? new ye(this.sourceAnchor.x, this.sourceAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  get targetBBox() {
    const e = this.targetView;
    if (!e) {
      const i = this.cell.getTarget();
      return new ye(i.x, i.y);
    }
    const t = this.targetMagnet;
    return e.isEdgeElement(t) ? new ye(this.targetAnchor.x, this.targetAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  isEdgeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let i = e;
    if (this.hasAction(i, "source")) {
      if (!this.updateTerminalProperties("source"))
        return i;
      i = this.removeAction(i, "source");
    }
    if (this.hasAction(i, "target")) {
      if (!this.updateTerminalProperties("target"))
        return i;
      i = this.removeAction(i, "target");
    }
    return this.hasAction(i, "render") ? (this.render(), i = this.removeAction(i, ["render", "update", "labels", "tools"]), i) : (i = this.handleAction(i, "update", () => this.update(t)), i = this.handleAction(i, "labels", () => this.onLabelsChange(t)), i = this.handleAction(i, "tools", () => this.renderTools()), i);
  }
  // #region render
  render() {
    return this.empty(), this.renderMarkup(), this.labelContainer = null, this.renderLabels(), this.update(), this.renderTools(), this;
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid edge markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.append(t.fragment);
  }
  customizeLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels;
      for (let i = 0, r = t.length; i < r; i += 1) {
        const s = t[i], o = this.labelCache[i], a = this.labelSelectors[i], l = this.graph.options.onEdgeLabelRendered;
        if (l) {
          const c = l({
            edge: e,
            label: s,
            container: o,
            selectors: a
          });
          c && (this.labelDestroyFn[i] = c);
        }
      }
    }
  }
  destroyCustomizeLabels() {
    const e = this.cell.labels;
    if (this.labelCache && this.labelSelectors && this.labelDestroyFn)
      for (let t = 0, i = e.length; t < i; t += 1) {
        const r = this.labelDestroyFn[t], s = this.labelCache[t], o = this.labelSelectors[t];
        r && s && o && r({
          edge: this.cell,
          label: e[t],
          container: s,
          selectors: o
        });
      }
    this.labelDestroyFn = {};
  }
  renderLabels() {
    const e = this.cell, t = e.getLabels(), i = t.length;
    let r = this.labelContainer;
    if (this.labelCache = {}, this.labelSelectors = {}, i <= 0)
      return r && r.parentNode && r.parentNode.removeChild(r), this;
    r ? this.empty(r) : (r = Ts("g"), this.addClass(this.prefixClassName("edge-labels"), r), this.labelContainer = r);
    for (let s = 0, o = t.length; s < o; s += 1) {
      const a = t[s], l = this.normalizeLabelMarkup(this.parseLabelMarkup(a.markup));
      let c, u;
      if (l)
        c = l.node, u = l.selectors;
      else {
        const d = e.getDefaultLabel(), f = this.normalizeLabelMarkup(this.parseLabelMarkup(d.markup));
        c = f.node, u = f.selectors;
      }
      c.setAttribute("data-index", `${s}`), r.appendChild(c);
      const h = this.rootSelector;
      if (u[h])
        throw new Error("Ambiguous label root selector.");
      u[h] = c, this.labelCache[s] = c, this.labelSelectors[s] = u;
    }
    return r.parentNode == null && this.container.appendChild(r), this.updateLabels(), this.customizeLabels(), this;
  }
  onLabelsChange(e = {}) {
    this.destroyCustomizeLabels(), this.shouldRerenderLabels(e) ? this.renderLabels() : this.updateLabels(), this.updateLabelPositions();
  }
  shouldRerenderLabels(e = {}) {
    const t = this.cell.previous("labels");
    if (t == null)
      return !0;
    if ("propertyPathArray" in e && "propertyValue" in e) {
      const i = e.propertyPathArray || [], r = i.length;
      if (r > 1) {
        const s = i[1];
        if (t[s]) {
          if (r === 2)
            return typeof e.propertyValue == "object" && np(e.propertyValue, "markup");
          if (i[2] !== "markup")
            return !1;
        }
      }
    }
    return !0;
  }
  parseLabelMarkup(e) {
    return e ? typeof e == "string" ? this.parseLabelStringMarkup(e) : this.parseJSONMarkup(e) : null;
  }
  parseLabelStringMarkup(e) {
    const t = Je.createVectors(e), i = document.createDocumentFragment();
    for (let r = 0, s = t.length; r < s; r += 1) {
      const o = t[r].node;
      i.appendChild(o);
    }
    return { fragment: i, selectors: {} };
  }
  normalizeLabelMarkup(e) {
    if (e == null)
      return;
    const t = e.fragment;
    if (!(t instanceof DocumentFragment) || !t.hasChildNodes())
      throw new Error("Invalid label markup.");
    let i;
    const r = t.childNodes;
    return r.length > 1 || r[0].nodeName.toUpperCase() !== "G" ? i = Je.create("g").append(t) : i = Je.create(r[0]), i.addClass(this.prefixClassName("edge-label")), {
      node: i.node,
      selectors: e.selectors
    };
  }
  updateLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels, i = this.can("edgeLabelMovable"), r = e.getDefaultLabel();
      for (let s = 0, o = t.length; s < o; s += 1) {
        const a = this.labelCache[s], l = this.labelSelectors[s];
        a.setAttribute("cursor", i ? "move" : "default");
        const c = t[s], u = On({}, r.attrs, c.attrs);
        this.updateAttrs(a, u, {
          selectors: l,
          rootBBox: c.size ? ye.fromSize(c.size) : void 0
        });
      }
    }
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  // #endregion
  // #region updating
  update(e = {}) {
    this.cleanCache(), this.updateConnection(e);
    const t = this.cell.getAttrs(), i = Gse(t, ["text"]);
    return i != null && this.updateAttrs(this.container, i, {
      selectors: this.selectors
    }), this.updateLabelPositions(), this.updateTools(e), this;
  }
  removeRedundantLinearVertices(e = {}) {
    const t = this.cell, i = t.getVertices(), r = [this.sourceAnchor, ...i, this.targetAnchor], s = r.length, o = new En(r);
    o.simplify({ threshold: 0.01 });
    const a = o.points.map((c) => c.toJSON()), l = a.length;
    return s === l ? 0 : (t.setVertices(a.slice(1, l - 1), e), s - l);
  }
  getTerminalView(e) {
    switch (e) {
      case "source":
        return this.sourceView || null;
      case "target":
        return this.targetView || null;
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  getTerminalAnchor(e) {
    switch (e) {
      case "source":
        return z.create(this.sourceAnchor);
      case "target":
        return z.create(this.targetAnchor);
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  getTerminalConnectionPoint(e) {
    switch (e) {
      case "source":
        return z.create(this.sourcePoint);
      case "target":
        return z.create(this.targetPoint);
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  getTerminalMagnet(e, t = {}) {
    switch (e) {
      case "source": {
        if (t.raw)
          return this.sourceMagnet;
        const i = this.sourceView;
        return i ? this.sourceMagnet || i.container : null;
      }
      case "target": {
        if (t.raw)
          return this.targetMagnet;
        const i = this.targetView;
        return i ? this.targetMagnet || i.container : null;
      }
      default:
        throw new Error(`Unknown terminal type '${e}'`);
    }
  }
  updateConnection(e = {}) {
    const t = this.cell;
    if (e.translateBy && t.isFragmentDescendantOf(e.translateBy)) {
      const i = e.tx || 0, r = e.ty || 0;
      this.routePoints = new En(this.routePoints).translate(i, r).points, this.translateConnectionPoints(i, r), this.path.translate(i, r);
    } else {
      const i = t.getVertices(), r = this.findAnchors(i);
      this.sourceAnchor = r.source, this.targetAnchor = r.target, this.routePoints = this.findRoutePoints(i);
      const s = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
      this.sourcePoint = s.source, this.targetPoint = s.target;
      const o = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
      this.path = this.findPath(this.routePoints, o.source || this.sourcePoint, o.target || this.targetPoint);
    }
    this.cleanCache();
  }
  findAnchors(e) {
    const t = this.cell, i = t.source, r = t.target, s = e[0], o = e[e.length - 1];
    return r.priority && !i.priority ? this.findAnchorsOrdered("target", o, "source", s) : this.findAnchorsOrdered("source", s, "target", o);
  }
  findAnchorsOrdered(e, t, i, r) {
    let s, o;
    const a = this.cell, l = a[e], c = a[i], u = this.getTerminalView(e), h = this.getTerminalView(i), d = this.getTerminalMagnet(e), f = this.getTerminalMagnet(i);
    if (u) {
      let p;
      t ? p = z.create(t) : h ? p = f : p = z.create(c), s = this.getAnchor(l.anchor, u, d, p, e);
    } else
      s = z.create(l);
    if (h) {
      const p = z.create(r || s);
      o = this.getAnchor(c.anchor, h, f, p, i);
    } else
      o = z.isPointLike(c) ? z.create(c) : new z();
    return {
      [e]: s,
      [i]: o
    };
  }
  getAnchor(e, t, i, r, s) {
    const o = t.isEdgeElement(i), a = this.graph.options.connecting;
    let l = typeof e == "string" ? { name: e } : e;
    if (!l) {
      const h = o ? (s === "source" ? a.sourceEdgeAnchor : a.targetEdgeAnchor) || a.edgeAnchor : (s === "source" ? a.sourceAnchor : a.targetAnchor) || a.anchor;
      l = typeof h == "string" ? { name: h } : h;
    }
    if (!l)
      throw new Error("Anchor should be specified.");
    let c;
    const u = l.name;
    if (o) {
      const h = Lu.registry.get(u);
      if (typeof h != "function")
        return Lu.registry.onNotFound(u);
      c = Ze(h, this, t, i, r, l.args || {}, s);
    } else {
      const h = Du.registry.get(u);
      if (typeof h != "function")
        return Du.registry.onNotFound(u);
      c = Ze(h, this, t, i, r, l.args || {}, s);
    }
    return c ? c.round(this.POINT_ROUNDING) : new z();
  }
  findRoutePoints(e = []) {
    const t = this.graph.options.connecting.router || Pa.presets.normal, i = this.cell.getRouter() || t;
    let r;
    if (typeof i == "function")
      r = Ze(i, this, e, {}, this);
    else {
      const s = typeof i == "string" ? i : i.name, o = typeof i == "string" ? {} : i.args || {}, a = s ? Pa.registry.get(s) : Pa.presets.normal;
      if (typeof a != "function")
        return Pa.registry.onNotFound(s);
      r = Ze(a, this, e, o, this);
    }
    return r == null ? e.map((s) => z.create(s)) : r.map((s) => z.create(s));
  }
  findConnectionPoints(e, t, i) {
    const r = this.cell, s = this.graph.options.connecting, o = r.getSource(), a = r.getTarget(), l = this.sourceView, c = this.targetView, u = e[0], h = e[e.length - 1];
    let d;
    if (l && !l.isEdgeElement(this.sourceMagnet)) {
      const p = this.sourceMagnet || l.container, g = u || i, m = new Ie(g, t), v = o.connectionPoint || s.sourceConnectionPoint || s.connectionPoint;
      d = this.getConnectionPoint(v, l, p, m, "source");
    } else
      d = t;
    let f;
    if (c && !c.isEdgeElement(this.targetMagnet)) {
      const p = this.targetMagnet || c.container, g = a.connectionPoint || s.targetConnectionPoint || s.connectionPoint, m = h || t, v = new Ie(m, i);
      f = this.getConnectionPoint(g, c, p, v, "target");
    } else
      f = i;
    return {
      source: d,
      target: f
    };
  }
  getConnectionPoint(e, t, i, r, s) {
    const o = r.end;
    if (e == null)
      return o;
    const a = typeof e == "string" ? e : e.name, l = typeof e == "string" ? {} : e.args, c = Iu.registry.get(a);
    if (typeof c != "function")
      return Iu.registry.onNotFound(a);
    const u = Ze(c, this, r, t, i, l || {}, s);
    return u ? u.round(this.POINT_ROUNDING) : o;
  }
  findMarkerPoints(e, t, i) {
    const r = (h) => {
      const d = this.cell.getAttrs(), f = Object.keys(d);
      for (let p = 0, g = f.length; p < g; p += 1) {
        const m = d[f[p]];
        if (m[`${h}Marker`] || m[`${h}-marker`]) {
          const v = m.strokeWidth || m["stroke-width"];
          if (v)
            return parseFloat(v);
          break;
        }
      }
      return null;
    }, s = e[0], o = e[e.length - 1];
    let a, l;
    const c = r("source");
    c && (a = t.clone().move(s || i, -c));
    const u = r("target");
    return u && (l = i.clone().move(o || t, -u)), this.sourceMarkerPoint = a || t.clone(), this.targetMarkerPoint = l || i.clone(), {
      source: a,
      target: l
    };
  }
  findPath(e, t, i) {
    const r = this.cell.getConnector() || this.graph.options.connecting.connector;
    let s, o, a;
    if (typeof r == "string" ? s = r : (s = r.name, o = r.args), s) {
      const c = zl.registry.get(s);
      if (typeof c != "function")
        return zl.registry.onNotFound(s);
      a = c;
    } else
      a = zl.presets.normal;
    const l = Ze(a, this, t, i, e, Object.assign(Object.assign({}, o), { raw: !0 }), this);
    return typeof l == "string" ? Be.parse(l) : l;
  }
  translateConnectionPoints(e, t) {
    this.sourcePoint.translate(e, t), this.targetPoint.translate(e, t), this.sourceAnchor.translate(e, t), this.targetAnchor.translate(e, t), this.sourceMarkerPoint.translate(e, t), this.targetMarkerPoint.translate(e, t);
  }
  updateLabelPositions() {
    if (this.labelContainer == null)
      return this;
    if (!this.path)
      return this;
    const t = this.cell, i = t.getLabels();
    if (i.length === 0)
      return this;
    const r = t.getDefaultLabel(), s = this.normalizeLabelPosition(r.position);
    for (let o = 0, a = i.length; o < a; o += 1) {
      const l = i[o], c = this.labelCache[o];
      if (!c)
        continue;
      const u = this.normalizeLabelPosition(l.position), h = On({}, s, u), d = this.getLabelTransformationMatrix(h);
      c.setAttribute("transform", gh(d));
    }
    return this;
  }
  updateTerminalProperties(e) {
    const t = this.cell, i = this.graph, r = t[e], s = r && r.cell, o = `${e}View`;
    if (!s)
      return this[o] = null, this.updateTerminalMagnet(e), !0;
    const a = i.getCellById(s);
    if (!a)
      throw new Error(`Edge's ${e} node with id "${s}" not exists`);
    const l = a.findView(i);
    return l ? (this[o] = l, this.updateTerminalMagnet(e), !0) : !1;
  }
  updateTerminalMagnet(e) {
    const t = `${e}Magnet`, i = this.getTerminalView(e);
    if (i) {
      let r = i.getMagnetFromEdgeTerminal(this.cell[e]);
      r === i.container && (r = null), this[t] = r;
    } else
      this[t] = null;
  }
  getLabelPositionAngle(e) {
    const t = this.cell.getLabelAt(e);
    return t && t.position && typeof t.position == "object" && t.position.angle || 0;
  }
  getLabelPositionArgs(e) {
    const t = this.cell.getLabelAt(e);
    if (t && t.position && typeof t.position == "object")
      return t.position.options;
  }
  getDefaultLabelPositionArgs() {
    const e = this.cell.getDefaultLabel();
    if (e && e.position && typeof e.position == "object")
      return e.position.options;
  }
  mergeLabelPositionArgs(e, t) {
    return e === null ? null : e === void 0 ? t === null ? null : t : On({}, t, e);
  }
  // #endregion
  getConnection() {
    return this.path != null ? this.path.clone() : null;
  }
  getConnectionPathData() {
    if (this.path == null)
      return "";
    const e = this.cache.pathCache;
    return np(e, "data") || (e.data = this.path.serialize()), e.data || "";
  }
  getConnectionSubdivisions() {
    if (this.path == null)
      return null;
    const e = this.cache.pathCache;
    return np(e, "segmentSubdivisions") || (e.segmentSubdivisions = this.path.getSegmentSubdivisions()), e.segmentSubdivisions;
  }
  getConnectionLength() {
    if (this.path == null)
      return 0;
    const e = this.cache.pathCache;
    return np(e, "length") || (e.length = this.path.length({
      segmentSubdivisions: this.getConnectionSubdivisions()
    })), e.length;
  }
  getPointAtLength(e) {
    return this.path == null ? null : this.path.pointAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getPointAtRatio(e) {
    return this.path == null ? null : (qo(e) && (e = parseFloat(e) / 100), this.path.pointAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }));
  }
  getTangentAtLength(e) {
    return this.path == null ? null : this.path.tangentAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtRatio(e) {
    return this.path == null ? null : this.path.tangentAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPoint(e) {
    return this.path == null ? null : this.path.closestPoint(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointLength(e) {
    return this.path == null ? null : this.path.closestPointLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointRatio(e) {
    return this.path == null ? null : this.path.closestPointNormalizedLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getLabelPosition(e, t, i, r) {
    const s = { distance: 0 };
    let o = 0, a;
    typeof i == "number" ? (o = i, a = r) : a = i, a != null && (s.options = a);
    const l = a && a.absoluteOffset, c = !(a && a.absoluteDistance), u = a && a.absoluteDistance && a.reverseDistance, h = this.path, d = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }, f = new z(e, t), p = h.closestPointT(f, d), g = this.getConnectionLength() || 0;
    let m = h.lengthAtT(p, d);
    c && (m = g > 0 ? m / g : 0), u && (m = -1 * (g - m) || 1), s.distance = m;
    let v;
    l || (v = h.tangentAtT(p));
    let y;
    if (v)
      y = v.pointOffset(f);
    else {
      const b = h.pointAtT(p), w = f.diff(b);
      y = { x: w.x, y: w.y };
    }
    return s.offset = y, s.angle = o, s;
  }
  normalizeLabelPosition(e) {
    return typeof e == "number" ? { distance: e } : e;
  }
  getLabelTransformationMatrix(e) {
    const t = this.normalizeLabelPosition(e), i = t.options || {}, r = t.angle || 0, s = t.distance, o = s > 0 && s <= 1;
    let a = 0;
    const l = { x: 0, y: 0 }, c = t.offset;
    c && (typeof c == "number" ? a = c : (c.x != null && (l.x = c.x), c.y != null && (l.y = c.y)));
    const u = l.x !== 0 || l.y !== 0 || a === 0, h = i.keepGradient, d = i.ensureLegibility, f = this.path, p = { segmentSubdivisions: this.getConnectionSubdivisions() }, g = o ? s * this.getConnectionLength() : s, m = f.tangentAtLength(g, p);
    let v, y = r;
    if (m) {
      if (u)
        v = m.start, v.translate(l);
      else {
        const b = m.clone();
        b.rotate(-90, m.start), b.setLength(a), v = b.end;
      }
      h && (y = m.angle() + r, d && (y = Pt.normalize((y + 90) % 180 - 90)));
    } else
      v = f.start, u && v.translate(l);
    return ci().translate(v.x, v.y).rotate(y);
  }
  getVertexIndex(e, t) {
    const r = this.cell.getVertices(), s = this.getClosestPointLength(new z(e, t));
    let o = 0;
    if (s != null)
      for (const a = r.length; o < a; o += 1) {
        const l = r[o], c = this.getClosestPointLength(l);
        if (c != null && s < c)
          break;
      }
    return o;
  }
  getEventArgs(e, t, i) {
    const r = this, s = r.cell, o = s;
    return t == null || i == null ? { e, view: r, edge: s, cell: o } : { e, x: t, y: i, view: r, edge: s, cell: o };
  }
  notifyUnhandledMouseDown(e, t, i) {
    this.notify("edge:unhandled:mousedown", {
      e,
      x: t,
      y: i,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  notifyMouseDown(e, t, i) {
    super.onMouseDown(e, t, i), this.notify("edge:mousedown", this.getEventArgs(e, t, i));
  }
  notifyMouseMove(e, t, i) {
    super.onMouseMove(e, t, i), this.notify("edge:mousemove", this.getEventArgs(e, t, i));
  }
  notifyMouseUp(e, t, i) {
    super.onMouseUp(e, t, i), this.notify("edge:mouseup", this.getEventArgs(e, t, i));
  }
  onClick(e, t, i) {
    super.onClick(e, t, i), this.notify("edge:click", this.getEventArgs(e, t, i));
  }
  onDblClick(e, t, i) {
    super.onDblClick(e, t, i), this.notify("edge:dblclick", this.getEventArgs(e, t, i));
  }
  onContextMenu(e, t, i) {
    super.onContextMenu(e, t, i), this.notify("edge:contextmenu", this.getEventArgs(e, t, i));
  }
  onMouseDown(e, t, i) {
    this.notifyMouseDown(e, t, i), this.startEdgeDragging(e, t, i);
  }
  onMouseMove(e, t, i) {
    const r = this.getEventData(e);
    switch (r.action) {
      case "drag-label": {
        this.dragLabel(e, t, i);
        break;
      }
      case "drag-arrowhead": {
        this.dragArrowhead(e, t, i);
        break;
      }
      case "drag-edge": {
        this.dragEdge(e, t, i);
        break;
      }
    }
    return this.notifyMouseMove(e, t, i), r;
  }
  onMouseUp(e, t, i) {
    const r = this.getEventData(e);
    switch (r.action) {
      case "drag-label": {
        this.stopLabelDragging(e, t, i);
        break;
      }
      case "drag-arrowhead": {
        this.stopArrowheadDragging(e, t, i);
        break;
      }
      case "drag-edge": {
        this.stopEdgeDragging(e, t, i);
        break;
      }
    }
    return this.notifyMouseUp(e, t, i), this.checkMouseleave(e), r;
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("edge:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("edge:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    super.onMouseEnter(e), this.notify("edge:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("edge:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, i, r) {
    super.onMouseWheel(e, t, i, r), this.notify("edge:mousewheel", Object.assign({ delta: r }, this.getEventArgs(e, t, i)));
  }
  onCustomEvent(e, t, i, r) {
    if (RM(e.target, "edge-tool", this.container)) {
      if (e.stopPropagation(), this.can("useEdgeTools")) {
        if (t === "edge:remove") {
          this.cell.remove({ ui: !0 });
          return;
        }
        this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, i, r)));
      }
      this.notifyMouseDown(e, i, r);
    } else
      this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, i, r))), super.onCustomEvent(e, t, i, r);
  }
  onLabelMouseDown(e, t, i) {
    this.notifyMouseDown(e, t, i), this.startLabelDragging(e, t, i), this.getEventData(e).stopPropagation && e.stopPropagation();
  }
  // #region drag edge
  startEdgeDragging(e, t, i) {
    if (!this.can("edgeMovable")) {
      this.notifyUnhandledMouseDown(e, t, i);
      return;
    }
    this.setEventData(e, {
      x: t,
      y: i,
      moving: !1,
      action: "drag-edge"
    });
  }
  dragEdge(e, t, i) {
    const r = this.getEventData(e);
    r.moving || (r.moving = !0, this.addClass("edge-moving"), this.notify("edge:move", {
      e,
      x: t,
      y: i,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), this.cell.translate(t - r.x, i - r.y, { ui: !0 }), this.setEventData(e, { x: t, y: i }), this.notify("edge:moving", {
      e,
      x: t,
      y: i,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  stopEdgeDragging(e, t, i) {
    const r = this.getEventData(e);
    r.moving && (this.removeClass("edge-moving"), this.notify("edge:moved", {
      e,
      x: t,
      y: i,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), r.moving = !1;
  }
  // #endregion
  // #region drag arrowhead
  prepareArrowheadDragging(e, t) {
    const i = this.getTerminalMagnet(e), r = {
      action: "drag-arrowhead",
      x: t.x,
      y: t.y,
      isNewEdge: t.isNewEdge === !0,
      terminalType: e,
      initialMagnet: i,
      initialTerminal: Md(this.cell[e]),
      fallbackAction: t.fallbackAction || "revert",
      getValidateConnectionArgs: this.createValidateConnectionArgs(e),
      options: t.options
    };
    return this.beforeArrowheadDragging(r), r;
  }
  createValidateConnectionArgs(e) {
    const t = [];
    t[4] = e, t[5] = this;
    let i, r = 0, s = 0;
    e === "source" ? (r = 2, i = "target") : (s = 2, i = "source");
    const o = this.cell[i], a = o.cell;
    if (a) {
      let l;
      const c = t[r] = this.graph.findViewByCell(a);
      c && (l = c.getMagnetFromEdgeTerminal(o), l === c.container && (l = void 0)), t[r + 1] = l;
    }
    return (l, c) => (t[s] = l, t[s + 1] = l.container === c ? void 0 : c, t);
  }
  beforeArrowheadDragging(e) {
    e.zIndex = this.cell.zIndex, this.cell.toFront();
    const t = this.container.style;
    e.pointerEvents = t.pointerEvents, t.pointerEvents = "none", this.graph.options.connecting.highlight && this.highlightAvailableMagnets(e);
  }
  afterArrowheadDragging(e) {
    e.zIndex != null && (this.cell.setZIndex(e.zIndex, { ui: !0 }), e.zIndex = null);
    const t = this.container;
    t.style.pointerEvents = e.pointerEvents || "", this.graph.options.connecting.highlight && this.unhighlightAvailableMagnets(e);
  }
  validateConnection(e, t, i, r, s, o, a) {
    const l = this.graph.options.connecting, c = l.allowLoop, u = l.allowNode, h = l.allowEdge, d = l.allowPort, f = l.allowMulti, p = l.validateConnection, g = o ? o.cell : null, m = s === "target" ? i : e, v = s === "target" ? r : t;
    let y = !0;
    const b = (w) => {
      const x = s === "source" ? a ? a.port : null : g ? g.getSourcePortId() : null, S = s === "target" ? a ? a.port : null : g ? g.getTargetPortId() : null;
      return Ze(w, this.graph, {
        edge: g,
        edgeView: o,
        sourceView: e,
        targetView: i,
        sourcePort: x,
        targetPort: S,
        sourceMagnet: t,
        targetMagnet: r,
        sourceCell: e ? e.cell : null,
        targetCell: i ? i.cell : null,
        type: s
      });
    };
    if (c != null && (typeof c == "boolean" ? !c && e === i && (y = !1) : y = b(c)), y && d != null && (typeof d == "boolean" ? !d && v && (y = !1) : y = b(d)), y && h != null && (typeof h == "boolean" ? !h && Wo.isEdgeView(m) && (y = !1) : y = b(h)), y && u != null && v == null && (typeof u == "boolean" ? !u && $r.isNodeView(m) && (y = !1) : y = b(u)), y && f != null && o) {
      const w = o.cell, x = s === "source" ? a : w.getSource(), S = s === "target" ? a : w.getTarget(), C = a ? this.graph.getCellById(a.cell) : null;
      if (x && S && x.cell && S.cell && C)
        if (typeof f == "function")
          y = b(f);
        else {
          const k = this.graph.model.getConnectedEdges(C, {
            outgoing: s === "source",
            incoming: s === "target"
          });
          k.length && (f === "withPort" ? k.some((M) => {
            const _ = M.getSource(), T = M.getTarget();
            return _ && T && _.cell === x.cell && T.cell === S.cell && _.port != null && _.port === x.port && T.port != null && T.port === S.port;
          }) && (y = !1) : f || k.some((M) => {
            const _ = M.getSource(), T = M.getTarget();
            return _ && T && _.cell === x.cell && T.cell === S.cell;
          }) && (y = !1));
        }
    }
    return y && p != null && (y = b(p)), y;
  }
  allowConnectToBlank(e) {
    const t = this.graph, r = t.options.connecting.allowBlank;
    if (typeof r != "function")
      return !!r;
    const s = t.findViewByCell(e), o = e.getSourceCell(), a = e.getTargetCell(), l = t.findViewByCell(o), c = t.findViewByCell(a);
    return Ze(r, t, {
      edge: e,
      edgeView: s,
      sourceCell: o,
      targetCell: a,
      sourceView: l,
      targetView: c,
      sourcePort: e.getSourcePortId(),
      targetPort: e.getTargetPortId(),
      sourceMagnet: s.sourceMagnet,
      targetMagnet: s.targetMagnet
    });
  }
  validateEdge(e, t, i) {
    const r = this.graph;
    if (!this.allowConnectToBlank(e)) {
      const o = e.getSourceCellId(), a = e.getTargetCellId();
      if (!(o && a))
        return !1;
    }
    const s = r.options.connecting.validateEdge;
    return s ? Ze(s, r, {
      edge: e,
      type: t,
      previous: i
    }) : !0;
  }
  arrowheadDragging(e, t, i, r) {
    r.x = t, r.y = i, r.currentTarget !== e && (r.currentMagnet && r.currentView && r.currentView.unhighlight(r.currentMagnet, {
      type: "magnetAdsorbed"
    }), r.currentView = this.graph.findViewByElem(e), r.currentView ? (r.currentMagnet = r.currentView.findMagnet(e), r.currentMagnet && this.validateConnection(...r.getValidateConnectionArgs(r.currentView, r.currentMagnet), r.currentView.getEdgeTerminal(r.currentMagnet, t, i, this.cell, r.terminalType)) ? r.currentView.highlight(r.currentMagnet, {
      type: "magnetAdsorbed"
    }) : r.currentMagnet = null) : r.currentMagnet = null), r.currentTarget = e, this.cell.prop(r.terminalType, { x: t, y: i }, Object.assign(Object.assign({}, r.options), { ui: !0 }));
  }
  arrowheadDragged(e, t, i) {
    const r = e.currentView, s = e.currentMagnet;
    if (!s || !r)
      return;
    r.unhighlight(s, { type: "magnetAdsorbed" });
    const o = e.terminalType, a = r.getEdgeTerminal(s, t, i, this.cell, o);
    this.cell.setTerminal(o, a, { ui: !0 });
  }
  snapArrowhead(e, t, i) {
    const r = this.graph, { snap: s, allowEdge: o } = r.options.connecting, a = typeof s == "object" && s.radius || 50, l = typeof s == "object" && s.anchor || "center", c = r.renderer.findViewsInArea({
      x: e - a,
      y: t - a,
      width: 2 * a,
      height: 2 * a
    }, { nodeOnly: !0 });
    if (o) {
      const w = r.renderer.findEdgeViewsFromPoint({ x: e, y: t }, a).filter((x) => x !== this);
      c.push(...w);
    }
    const u = i.closestView || null, h = i.closestMagnet || null;
    i.closestView = null, i.closestMagnet = null;
    let d, f = Number.MAX_SAFE_INTEGER;
    const p = new z(e, t);
    c.forEach((w) => {
      if (w.container.getAttribute("magnet") !== "false") {
        if (w.isNodeView())
          d = l === "center" ? w.cell.getBBox().getCenter().distance(p) : w.cell.getBBox().getNearestPointToPoint(p).distance(p);
        else if (w.isEdgeView()) {
          const x = w.getClosestPoint(p);
          x ? d = x.distance(p) : d = Number.MAX_SAFE_INTEGER;
        }
        d < a && d < f && (h === w.container || this.validateConnection(...i.getValidateConnectionArgs(w, null), w.getEdgeTerminal(w.container, e, t, this.cell, i.terminalType))) && (f = d, i.closestView = w, i.closestMagnet = w.container);
      }
      w.container.querySelectorAll("[magnet]").forEach((x) => {
        if (x.getAttribute("magnet") !== "false") {
          const S = w.getBBoxOfElement(x);
          d = p.distance(S.getCenter()), d < a && d < f && (h === x || this.validateConnection(...i.getValidateConnectionArgs(w, x), w.getEdgeTerminal(x, e, t, this.cell, i.terminalType))) && (f = d, i.closestView = w, i.closestMagnet = x);
        }
      });
    });
    let g;
    const m = i.terminalType, v = i.closestView, y = i.closestMagnet, b = h !== y;
    if (u && b && u.unhighlight(h, {
      type: "magnetAdsorbed"
    }), v) {
      if (!b)
        return;
      v.highlight(y, {
        type: "magnetAdsorbed"
      }), g = v.getEdgeTerminal(y, e, t, this.cell, m);
    } else
      g = { x: e, y: t };
    this.cell.setTerminal(m, g, {}, Object.assign(Object.assign({}, i.options), { ui: !0 }));
  }
  snapArrowheadEnd(e) {
    const t = e.closestView, i = e.closestMagnet;
    t && i && (t.unhighlight(i, {
      type: "magnetAdsorbed"
    }), e.currentMagnet = t.findMagnet(i)), e.closestView = null, e.closestMagnet = null;
  }
  finishEmbedding(e) {
    this.graph.options.embedding.enabled && this.cell.updateParent() && (e.zIndex = null);
  }
  fallbackConnection(e) {
    switch (e.fallbackAction) {
      case "remove":
        this.cell.remove({ ui: !0 });
        break;
      case "revert":
      default:
        this.cell.prop(e.terminalType, e.initialTerminal, {
          ui: !0
        });
        break;
    }
  }
  notifyConnectionEvent(e, t) {
    const i = e.terminalType, r = e.initialTerminal, s = this.cell[i];
    if (s && !xn.equalTerminals(r, s)) {
      const a = this.graph, l = r, c = l.cell ? a.getCellById(l.cell) : null, u = l.port, h = c ? a.findViewByCell(c) : null, d = c || e.isNewEdge ? null : z.create(r).toJSON(), f = s, p = f.cell ? a.getCellById(f.cell) : null, g = f.port, m = p ? a.findViewByCell(p) : null, v = p ? null : z.create(s).toJSON();
      this.notify("edge:connected", {
        e: t,
        previousCell: c,
        previousPort: u,
        previousView: h,
        previousPoint: d,
        currentCell: p,
        currentView: m,
        currentPort: g,
        currentPoint: v,
        previousMagnet: e.initialMagnet,
        currentMagnet: e.currentMagnet,
        edge: this.cell,
        view: this,
        type: i,
        isNew: e.isNewEdge
      });
    }
  }
  highlightAvailableMagnets(e) {
    const t = this.graph, i = t.model.getCells();
    e.marked = {};
    for (let r = 0, s = i.length; r < s; r += 1) {
      const o = t.findViewByCell(i[r]);
      if (!o || o.cell.id === this.cell.id)
        continue;
      const a = Array.prototype.slice.call(o.container.querySelectorAll("[magnet]"));
      o.container.getAttribute("magnet") !== "false" && a.push(o.container);
      const l = a.filter((c) => this.validateConnection(...e.getValidateConnectionArgs(o, c), o.getEdgeTerminal(c, e.x, e.y, this.cell, e.terminalType)));
      if (l.length > 0) {
        for (let c = 0, u = l.length; c < u; c += 1)
          o.highlight(l[c], { type: "magnetAvailable" });
        o.highlight(null, { type: "nodeAvailable" }), e.marked[o.cell.id] = l;
      }
    }
  }
  unhighlightAvailableMagnets(e) {
    const t = e.marked || {};
    Object.keys(t).forEach((i) => {
      const r = this.graph.findViewByCell(i);
      r && (t[i].forEach((o) => {
        r.unhighlight(o, { type: "magnetAvailable" });
      }), r.unhighlight(null, { type: "nodeAvailable" }));
    }), e.marked = null;
  }
  startArrowheadDragging(e, t, i) {
    if (!this.can("arrowheadMovable")) {
      this.notifyUnhandledMouseDown(e, t, i);
      return;
    }
    const s = e.target.getAttribute("data-terminal"), o = this.prepareArrowheadDragging(s, { x: t, y: i });
    this.setEventData(e, o);
  }
  dragArrowhead(e, t, i) {
    const r = this.getEventData(e);
    this.graph.options.connecting.snap ? this.snapArrowhead(t, i, r) : this.arrowheadDragging(this.getEventTarget(e), t, i, r);
  }
  stopArrowheadDragging(e, t, i) {
    const r = this.graph, s = this.getEventData(e);
    r.options.connecting.snap ? this.snapArrowheadEnd(s) : this.arrowheadDragged(s, t, i), this.validateEdge(this.cell, s.terminalType, s.initialTerminal) ? (this.finishEmbedding(s), this.notifyConnectionEvent(s, e)) : this.fallbackConnection(s), this.afterArrowheadDragging(s);
  }
  // #endregion
  // #region drag lable
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLabelDragging(e, t, i) {
    if (this.can("edgeLabelMovable")) {
      const r = e.currentTarget, s = parseInt(r.getAttribute("data-index"), 10), o = this.getLabelPositionAngle(s), a = this.getLabelPositionArgs(s), l = this.getDefaultLabelPositionArgs(), c = this.mergeLabelPositionArgs(a, l);
      this.setEventData(e, {
        index: s,
        positionAngle: o,
        positionArgs: c,
        stopPropagation: !0,
        action: "drag-label"
      });
    } else
      this.setEventData(e, { stopPropagation: !0 });
    this.graph.view.delegateDragEvents(e, this);
  }
  dragLabel(e, t, i) {
    const r = this.getEventData(e), s = this.cell.getLabelAt(r.index), o = On({}, s, {
      position: this.getLabelPosition(t, i, r.positionAngle, r.positionArgs)
    });
    this.cell.setLabelAt(r.index, o);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  stopLabelDragging(e, t, i) {
  }
}
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag], r = t;
    return (i == null || i === n.toStringTag) && typeof r.isNodeView == "function" && typeof r.isEdgeView == "function" && typeof r.confirmUpdate == "function" && typeof r.update == "function" && typeof r.getConnection == "function";
  }
  n.isEdgeView = e;
})(Wo || (Wo = {}));
Wo.config({
  isSvgElement: !0,
  priority: 1,
  bootstrap: ["render", "source", "target"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    source: ["source", "update"],
    target: ["target", "update"],
    router: ["update"],
    connector: ["update"],
    labels: ["labels"],
    defaultLabel: ["labels"],
    tools: ["tools"],
    vertices: ["vertices", "update"]
  }
});
Wo.registry.register("edge", Wo, !0);
var Kse = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class go extends Rt {
  /** Graph's `this.container` is from outer, should not dispose */
  get disposeContainer() {
    return !1;
  }
  get options() {
    return this.graph.options;
  }
  constructor(e) {
    super(), this.graph = e;
    const { selectors: t, fragment: i } = Yt.parseJSONMarkup(go.markup);
    this.background = t.background, this.grid = t.grid, this.svg = t.svg, this.defs = t.defs, this.viewport = t.viewport, this.primer = t.primer, this.stage = t.stage, this.decorator = t.decorator, this.overlay = t.overlay, this.container = this.options.container, this.restore = go.snapshoot(this.container), Ye(this.container, this.prefixClassName("graph")), Ja(this.container, i), this.delegateEvents();
  }
  delegateEvents() {
    const e = this.constructor;
    return super.delegateEvents(e.events), this;
  }
  /**
   * Guard the specified event. If the event is not interesting, it
   * returns `true`, otherwise returns `false`.
   */
  guard(e, t) {
    return e.type === "mousedown" && e.button === 2 || this.options.guard && this.options.guard(e, t) ? !0 : e.data && e.data.guarded !== void 0 ? e.data.guarded : !(t && t.cell && gt.isCell(t.cell) || this.svg === e.target || this.container === e.target || this.svg.contains(e.target));
  }
  findView(e) {
    return this.graph.findViewByElem(e);
  }
  onDblClick(e) {
    this.options.preventDefaultDblClick && e.preventDefault();
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (this.guard(t, i))
      return;
    const r = this.graph.snapToGrid(t.clientX, t.clientY);
    i ? i.onDblClick(t, r.x, r.y) : this.graph.trigger("blank:dblclick", {
      e: t,
      x: r.x,
      y: r.y
    });
  }
  onClick(e) {
    if (this.getMouseMovedCount(e) <= this.options.clickThreshold) {
      const t = this.normalizeEvent(e), i = this.findView(t.target);
      if (this.guard(t, i))
        return;
      const r = this.graph.snapToGrid(t.clientX, t.clientY);
      i ? i.onClick(t, r.x, r.y) : this.graph.trigger("blank:click", {
        e: t,
        x: r.x,
        y: r.y
      });
    }
  }
  isPreventDefaultContextMenu(e) {
    let t = this.options.preventDefaultContextMenu;
    return typeof t == "function" && (t = Ze(t, this.graph, { view: e })), t;
  }
  onContextMenu(e) {
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (this.isPreventDefaultContextMenu(i) && e.preventDefault(), this.guard(t, i))
      return;
    const r = this.graph.snapToGrid(t.clientX, t.clientY);
    i ? i.onContextMenu(t, r.x, r.y) : this.graph.trigger("blank:contextmenu", {
      e: t,
      x: r.x,
      y: r.y
    });
  }
  delegateDragEvents(e, t) {
    e.data == null && (e.data = {}), this.setEventData(e, {
      currentView: t || null,
      mouseMovedCount: 0,
      startPosition: {
        x: e.clientX,
        y: e.clientY
      }
    });
    const i = this.constructor;
    this.delegateDocumentEvents(i.documentEvents, e.data), this.undelegateEvents();
  }
  getMouseMovedCount(e) {
    return this.getEventData(e).mouseMovedCount || 0;
  }
  onMouseDown(e) {
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (this.guard(t, i))
      return;
    this.options.preventDefaultMouseDown && e.preventDefault();
    const r = this.graph.snapToGrid(t.clientX, t.clientY);
    i ? i.onMouseDown(t, r.x, r.y) : (this.options.preventDefaultBlankAction && ["touchstart"].includes(t.type) && e.preventDefault(), this.graph.trigger("blank:mousedown", {
      e: t,
      x: r.x,
      y: r.y
    })), this.delegateDragEvents(t, i);
  }
  onMouseMove(e) {
    const t = this.getEventData(e), i = t.startPosition;
    if (i && i.x === e.clientX && i.y === e.clientY || (t.mouseMovedCount == null && (t.mouseMovedCount = 0), t.mouseMovedCount += 1, t.mouseMovedCount <= this.options.moveThreshold))
      return;
    const s = this.normalizeEvent(e), o = this.graph.snapToGrid(s.clientX, s.clientY), a = t.currentView;
    a ? a.onMouseMove(s, o.x, o.y) : this.graph.trigger("blank:mousemove", {
      e: s,
      x: o.x,
      y: o.y
    }), this.setEventData(s, t);
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), i = this.graph.snapToGrid(t.clientX, t.clientY), s = this.getEventData(e).currentView;
    if (s ? s.onMouseUp(t, i.x, i.y) : this.graph.trigger("blank:mouseup", {
      e: t,
      x: i.x,
      y: i.y
    }), !e.isPropagationStopped()) {
      const o = new so(e, {
        type: "click",
        data: e.data
      });
      this.onClick(o);
    }
    e.stopImmediatePropagation(), this.delegateEvents();
  }
  onMouseOver(e) {
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (!this.guard(t, i))
      if (i)
        i.onMouseOver(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseover", { e: t });
      }
  }
  onMouseOut(e) {
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (!this.guard(t, i))
      if (i)
        i.onMouseOut(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseout", { e: t });
      }
  }
  onMouseEnter(e) {
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (this.guard(t, i))
      return;
    const r = this.graph.findViewByElem(t.relatedTarget);
    if (i) {
      if (r === i)
        return;
      i.onMouseEnter(t);
    } else {
      if (r)
        return;
      this.graph.trigger("graph:mouseenter", { e: t });
    }
  }
  onMouseLeave(e) {
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (this.guard(t, i))
      return;
    const r = this.graph.findViewByElem(t.relatedTarget);
    if (i) {
      if (r === i)
        return;
      i.onMouseLeave(t);
    } else {
      if (r)
        return;
      this.graph.trigger("graph:mouseleave", { e: t });
    }
  }
  onMouseWheel(e) {
    const t = this.normalizeEvent(e), i = this.findView(t.target);
    if (this.guard(t, i))
      return;
    const r = t.originalEvent, s = this.graph.snapToGrid(r.clientX, r.clientY), o = Math.max(-1, Math.min(1, r.wheelDelta || -r.detail));
    i ? i.onMouseWheel(t, s.x, s.y, o) : this.graph.trigger("blank:mousewheel", {
      e: t,
      delta: o,
      x: s.x,
      y: s.y
    });
  }
  onCustomEvent(e) {
    const t = e.currentTarget, i = t.getAttribute("event") || t.getAttribute("data-event");
    if (i) {
      const r = this.findView(t);
      if (r) {
        const s = this.normalizeEvent(e);
        if (this.guard(s, r))
          return;
        const o = this.graph.snapToGrid(s.clientX, s.clientY);
        r.onCustomEvent(s, i, o.x, o.y);
      }
    }
  }
  handleMagnetEvent(e, t) {
    const i = e.currentTarget, r = i.getAttribute("magnet");
    if (r && r.toLowerCase() !== "false") {
      const s = this.findView(i);
      if (s) {
        const o = this.normalizeEvent(e);
        if (this.guard(o, s))
          return;
        const a = this.graph.snapToGrid(o.clientX, o.clientY);
        Ze(t, this.graph, s, o, i, a.x, a.y);
      }
    }
  }
  onMagnetMouseDown(e) {
    this.handleMagnetEvent(e, (t, i, r, s, o) => {
      t.onMagnetMouseDown(i, r, s, o);
    });
  }
  onMagnetDblClick(e) {
    this.handleMagnetEvent(e, (t, i, r, s, o) => {
      t.onMagnetDblClick(i, r, s, o);
    });
  }
  onMagnetContextMenu(e) {
    const t = this.findView(e.target);
    this.isPreventDefaultContextMenu(t) && e.preventDefault(), this.handleMagnetEvent(e, (i, r, s, o, a) => {
      i.onMagnetContextMenu(r, s, o, a);
    });
  }
  onLabelMouseDown(e) {
    const t = e.currentTarget, i = this.findView(t);
    if (i) {
      const r = this.normalizeEvent(e);
      if (this.guard(r, i))
        return;
      const s = this.graph.snapToGrid(r.clientX, r.clientY);
      i.onLabelMouseDown(r, s.x, s.y);
    }
  }
  onImageDragStart() {
    return !1;
  }
  dispose() {
    this.undelegateEvents(), this.undelegateDocumentEvents(), this.restore(), this.restore = () => {
    };
  }
}
Kse([
  Rt.dispose()
], go.prototype, "dispose", null);
(function(n) {
  const e = `${Jr.prefixCls}-graph`;
  n.markup = [
    {
      ns: si.xhtml,
      tagName: "div",
      selector: "background",
      className: `${e}-background`
    },
    {
      ns: si.xhtml,
      tagName: "div",
      selector: "grid",
      className: `${e}-grid`
    },
    {
      ns: si.svg,
      tagName: "svg",
      selector: "svg",
      className: `${e}-svg`,
      attrs: {
        width: "100%",
        height: "100%",
        "xmlns:xlink": si.xlink
      },
      children: [
        {
          tagName: "defs",
          selector: "defs"
        },
        {
          tagName: "g",
          selector: "viewport",
          className: `${e}-svg-viewport`,
          children: [
            {
              tagName: "g",
              selector: "primer",
              className: `${e}-svg-primer`
            },
            {
              tagName: "g",
              selector: "stage",
              className: `${e}-svg-stage`
            },
            {
              tagName: "g",
              selector: "decorator",
              className: `${e}-svg-decorator`
            },
            {
              tagName: "g",
              selector: "overlay",
              className: `${e}-svg-overlay`
            }
          ]
        }
      ]
    }
  ];
  function t(i) {
    const r = i.cloneNode();
    return i.childNodes.forEach((s) => r.appendChild(s)), () => {
      for (Df(i); i.attributes.length > 0; )
        i.removeAttribute(i.attributes[0].name);
      for (let s = 0, o = r.attributes.length; s < o; s += 1) {
        const a = r.attributes[s];
        i.setAttribute(a.name, a.value);
      }
      r.childNodes.forEach((s) => i.appendChild(s));
    };
  }
  n.snapshoot = t;
})(go || (go = {}));
(function(n) {
  const e = Jr.prefixCls;
  n.events = {
    dblclick: "onDblClick",
    contextmenu: "onContextMenu",
    touchstart: "onMouseDown",
    mousedown: "onMouseDown",
    mouseover: "onMouseOver",
    mouseout: "onMouseOut",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousewheel: "onMouseWheel",
    DOMMouseScroll: "onMouseWheel",
    [`mouseenter  .${e}-cell`]: "onMouseEnter",
    [`mouseleave  .${e}-cell`]: "onMouseLeave",
    [`mouseenter  .${e}-cell-tools`]: "onMouseEnter",
    [`mouseleave  .${e}-cell-tools`]: "onMouseLeave",
    [`mousedown   .${e}-cell [event]`]: "onCustomEvent",
    [`touchstart  .${e}-cell [event]`]: "onCustomEvent",
    [`mousedown   .${e}-cell [data-event]`]: "onCustomEvent",
    [`touchstart  .${e}-cell [data-event]`]: "onCustomEvent",
    [`dblclick    .${e}-cell [magnet]`]: "onMagnetDblClick",
    [`contextmenu .${e}-cell [magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${e}-cell [magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${e}-cell [magnet]`]: "onMagnetMouseDown",
    [`dblclick    .${e}-cell [data-magnet]`]: "onMagnetDblClick",
    [`contextmenu .${e}-cell [data-magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${e}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${e}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`dragstart   .${e}-cell image`]: "onImageDragStart",
    [`mousedown   .${e}-edge .${e}-edge-label`]: "onLabelMouseDown",
    [`touchstart  .${e}-edge .${e}-edge-label`]: "onLabelMouseDown"
  }, n.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
})(go || (go = {}));
const Jse = `.x6-graph {
  position: relative;
  overflow: hidden;
  outline: none;
  touch-action: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;
class ui extends Zo {
  get options() {
    return this.graph.options;
  }
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.view;
  }
  constructor(e) {
    super(), this.graph = e, this.init();
  }
  init() {
  }
}
var eoe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Jy extends ui {
  init() {
    kv("core", Jse);
  }
  dispose() {
    Pv("core");
  }
}
eoe([
  Jy.dispose()
], Jy.prototype, "dispose", null);
var toe = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}, Ud;
(function(n) {
  function e(t) {
    const { grid: i, panning: r, mousewheel: s, embedding: o } = t, a = toe(
      t,
      ["grid", "panning", "mousewheel", "embedding"]
    ), l = t.container;
    if (l != null)
      a.width == null && (a.width = l.clientWidth), a.height == null && (a.height = l.clientHeight);
    else
      throw new Error("Ensure the container of the graph is specified and valid");
    const c = On({}, n.defaults, a), u = { size: 10, visible: !1 };
    return typeof i == "number" ? c.grid = { size: i, visible: !1 } : typeof i == "boolean" ? c.grid = Object.assign(Object.assign({}, u), { visible: i }) : c.grid = Object.assign(Object.assign({}, u), i), [
      "panning",
      "mousewheel",
      "embedding"
    ].forEach((d) => {
      const f = t[d];
      typeof f == "boolean" ? c[d].enabled = f : c[d] = Object.assign(Object.assign({}, c[d]), f);
    }), c;
  }
  n.get = e;
})(Ud || (Ud = {}));
(function(n) {
  n.defaults = {
    x: 0,
    y: 0,
    scaling: {
      min: 0.01,
      max: 16
    },
    grid: {
      size: 10,
      visible: !1
    },
    background: !1,
    panning: {
      enabled: !1,
      eventTypes: ["leftMouseDown"]
    },
    mousewheel: {
      enabled: !1,
      factor: 1.2,
      zoomAtMousePosition: !0
    },
    highlighting: {
      default: {
        name: "stroke",
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: "className",
        args: {
          className: Jr.prefix("available-node")
        }
      },
      magnetAvailable: {
        name: "className",
        args: {
          className: Jr.prefix("available-magnet")
        }
      }
    },
    connecting: {
      snap: !1,
      allowLoop: !0,
      allowNode: !0,
      allowEdge: !1,
      allowPort: !0,
      allowBlank: !0,
      allowMulti: !0,
      highlight: !1,
      anchor: "center",
      edgeAnchor: "ratio",
      connectionPoint: "boundary",
      router: "normal",
      connector: "normal",
      validateConnection({ type: e, sourceView: t, targetView: i }) {
        return (e === "target" ? i : t) != null;
      },
      createEdge() {
        return new Hse();
      }
    },
    translating: {
      restrict: !1
    },
    embedding: {
      enabled: !1,
      findParent: "bbox",
      frontOnly: !0,
      validate: () => !0
    },
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultDblClick: !0,
    preventDefaultMouseDown: !1,
    preventDefaultContextMenu: !0,
    preventDefaultBlankAction: !0,
    interacting: {
      edgeLabelMovable: !1
    },
    async: !0,
    virtual: !1,
    guard: () => !1
  };
})(Ud || (Ud = {}));
var noe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}, ioe = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class Gw extends ui {
  get elem() {
    return this.view.grid;
  }
  get grid() {
    return this.options.grid;
  }
  init() {
    this.startListening(), this.draw(this.grid);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  setVisible(e) {
    this.grid.visible !== e && (this.grid.visible = e, this.update());
  }
  getGridSize() {
    return this.grid.size;
  }
  setGridSize(e) {
    this.grid.size = Math.max(e, 1), this.update();
  }
  show() {
    this.setVisible(!0), this.update();
  }
  hide() {
    this.setVisible(!1), this.update();
  }
  clear() {
    this.elem.style.backgroundImage = "";
  }
  draw(e) {
    this.clear(), this.instance = null, Object.assign(this.grid, e), this.patterns = this.resolveGrid(e), this.update();
  }
  update(e = {}) {
    const t = this.grid.size;
    if (t <= 1 || !this.grid.visible)
      return this.clear();
    const i = this.graph.matrix(), r = this.getInstance(), s = Array.isArray(e) ? e : [e];
    this.patterns.forEach((l, c) => {
      const u = `pattern_${c}`, h = i.a || 1, d = i.d || 1, { update: f, markup: p } = l, g = ioe(l, ["update", "markup"]), m = Object.assign(Object.assign(Object.assign({}, g), s[c]), {
        sx: h,
        sy: d,
        ox: i.e || 0,
        oy: i.f || 0,
        width: t * h,
        height: t * d
      });
      r.has(u) || r.add(u, Je.create("pattern", { id: u, patternUnits: "userSpaceOnUse" }, Je.createVectors(p)).node);
      const v = r.get(u);
      typeof f == "function" && f(v.childNodes[0], m);
      let y = m.ox % m.width;
      y < 0 && (y += m.width);
      let b = m.oy % m.height;
      b < 0 && (b += m.height), St(v, {
        x: y,
        y: b,
        width: m.width,
        height: m.height
      });
    });
    const o = new XMLSerializer().serializeToString(r.root), a = `url(data:image/svg+xml;base64,${btoa(o)})`;
    this.elem.style.backgroundImage = a;
  }
  getInstance() {
    return this.instance || (this.instance = new ka()), this.instance;
  }
  resolveGrid(e) {
    if (!e)
      return [];
    const t = e.type;
    if (t == null)
      return [
        Object.assign(Object.assign({}, ka.presets.dot), e.args)
      ];
    const i = ka.registry.get(t);
    if (i) {
      let r = e.args || [];
      return Array.isArray(r) || (r = [r]), Array.isArray(i) ? i.map((s, o) => Object.assign(Object.assign({}, s), r[o])) : [Object.assign(Object.assign({}, i), r[0])];
    }
    return ka.registry.onNotFound(t);
  }
  dispose() {
    this.stopListening(), this.clear();
  }
}
noe([
  ui.dispose()
], Gw.prototype, "dispose", null);
class FR extends ui {
  get container() {
    return this.graph.view.container;
  }
  get viewport() {
    return this.graph.view.viewport;
  }
  get stage() {
    return this.graph.view.stage;
  }
  init() {
    this.resize();
  }
  /**
   * Returns the current transformation matrix of the graph.
   */
  getMatrix() {
    const e = this.viewport.getAttribute("transform");
    return e !== this.viewportTransformString && (this.viewportMatrix = this.viewport.getCTM(), this.viewportTransformString = e), ci(this.viewportMatrix);
  }
  /**
   * Sets new transformation with the given `matrix`
   */
  setMatrix(e) {
    const t = ci(e), i = gh(t);
    this.viewport.setAttribute("transform", i), this.viewportMatrix = t, this.viewportTransformString = i;
  }
  resize(e, t) {
    let i = e === void 0 ? this.options.width : e, r = t === void 0 ? this.options.height : t;
    this.options.width = i, this.options.height = r, typeof i == "number" && (i = Math.round(i)), typeof r == "number" && (r = Math.round(r)), this.container.style.width = i == null ? "" : `${i}px`, this.container.style.height = r == null ? "" : `${r}px`;
    const s = this.getComputedSize();
    return this.graph.trigger("resize", Object.assign({}, s)), this;
  }
  getComputedSize() {
    let e = this.options.width, t = this.options.height;
    return VS(e) || (e = this.container.clientWidth), VS(t) || (t = this.container.clientHeight), { width: e, height: t };
  }
  getScale() {
    return Jte(this.getMatrix());
  }
  scale(e, t = e, i = 0, r = 0) {
    if (e = this.clampScale(e), t = this.clampScale(t), i || r) {
      const o = this.getTranslation(), a = o.tx - i * (e - 1), l = o.ty - r * (t - 1);
      (a !== o.tx || l !== o.ty) && this.translate(a, l);
    }
    const s = this.getMatrix();
    return s.a = e, s.d = t, this.setMatrix(s), this.graph.trigger("scale", { sx: e, sy: t, ox: i, oy: r }), this;
  }
  clampScale(e) {
    const t = this.graph.options.scaling;
    return rr(e, t.min || 0.01, t.max || 16);
  }
  getZoom() {
    return this.getScale().sx;
  }
  zoom(e, t) {
    t = t || {};
    let i = e, r = e;
    const s = this.getScale(), o = this.getComputedSize();
    let a = o.width / 2, l = o.height / 2;
    if (t.absolute || (i += s.sx, r += s.sy), t.scaleGrid && (i = Math.round(i / t.scaleGrid) * t.scaleGrid, r = Math.round(r / t.scaleGrid) * t.scaleGrid), t.maxScale && (i = Math.min(t.maxScale, i), r = Math.min(t.maxScale, r)), t.minScale && (i = Math.max(t.minScale, i), r = Math.max(t.minScale, r)), t.center && (a = t.center.x, l = t.center.y), i = this.clampScale(i), r = this.clampScale(r), a || l) {
      const c = this.getTranslation(), u = a - (a - c.tx) * (i / s.sx), h = l - (l - c.ty) * (r / s.sy);
      (u !== c.tx || h !== c.ty) && this.translate(u, h);
    }
    return this.scale(i, r), this;
  }
  getRotation() {
    return ene(this.getMatrix());
  }
  rotate(e, t, i) {
    if (t == null || i == null) {
      const s = It.getBBox(this.stage);
      t = s.width / 2, i = s.height / 2;
    }
    const r = this.getMatrix().translate(t, i).rotate(e).translate(-t, -i);
    return this.setMatrix(r), this;
  }
  getTranslation() {
    return tne(this.getMatrix());
  }
  translate(e, t) {
    const i = this.getMatrix();
    i.e = e || 0, i.f = t || 0, this.setMatrix(i);
    const r = this.getTranslation();
    return this.options.x = r.tx, this.options.y = r.ty, this.graph.trigger("translate", Object.assign({}, r)), this;
  }
  setOrigin(e, t) {
    return this.translate(e || 0, t || 0);
  }
  fitToContent(e, t, i, r) {
    if (typeof e == "object") {
      const b = e;
      e = b.gridWidth || 1, t = b.gridHeight || 1, i = b.padding || 0, r = b;
    } else
      e = e || 1, t = t || 1, i = i || 0, r == null && (r = {});
    const s = Xl(i), o = r.border || 0, a = r.contentArea ? ye.create(r.contentArea) : this.getContentArea(r);
    o > 0 && a.inflate(o);
    const l = this.getScale(), c = this.getTranslation(), u = l.sx, h = l.sy;
    a.x *= u, a.y *= h, a.width *= u, a.height *= h;
    let d = Math.max(Math.ceil((a.width + a.x) / e), 1) * e, f = Math.max(Math.ceil((a.height + a.y) / t), 1) * t, p = 0, g = 0;
    (r.allowNewOrigin === "negative" && a.x < 0 || r.allowNewOrigin === "positive" && a.x >= 0 || r.allowNewOrigin === "any") && (p = Math.ceil(-a.x / e) * e, p += s.left, d += p), (r.allowNewOrigin === "negative" && a.y < 0 || r.allowNewOrigin === "positive" && a.y >= 0 || r.allowNewOrigin === "any") && (g = Math.ceil(-a.y / t) * t, g += s.top, f += g), d += s.right, f += s.bottom, d = Math.max(d, r.minWidth || 0), f = Math.max(f, r.minHeight || 0), d = Math.min(d, r.maxWidth || Number.MAX_SAFE_INTEGER), f = Math.min(f, r.maxHeight || Number.MAX_SAFE_INTEGER);
    const m = this.getComputedSize(), v = d !== m.width || f !== m.height;
    return (p !== c.tx || g !== c.ty) && this.translate(p, g), v && this.resize(d, f), new ye(-p / u, -g / h, d / u, f / h);
  }
  scaleContentToFit(e = {}) {
    this.scaleContentToFitImpl(e);
  }
  scaleContentToFitImpl(e = {}, t = !0) {
    let i, r;
    if (e.contentArea) {
      const v = e.contentArea;
      i = this.graph.localToGraph(v), r = z.create(v);
    } else
      i = this.getContentBBox(e), r = this.graph.graphToLocal(i);
    if (!i.width || !i.height)
      return;
    const s = Xl(e.padding), o = e.minScale || 0, a = e.maxScale || Number.MAX_SAFE_INTEGER, l = e.minScaleX || o, c = e.maxScaleX || a, u = e.minScaleY || o, h = e.maxScaleY || a;
    let d;
    if (e.viewportArea)
      d = e.viewportArea;
    else {
      const v = this.getComputedSize(), y = this.getTranslation();
      d = {
        x: y.tx,
        y: y.ty,
        width: v.width,
        height: v.height
      };
    }
    d = ye.create(d).moveAndExpand({
      x: s.left,
      y: s.top,
      width: -s.left - s.right,
      height: -s.top - s.bottom
    });
    const f = this.getScale();
    let p = d.width / i.width * f.sx, g = d.height / i.height * f.sy;
    e.preserveAspectRatio !== !1 && (p = g = Math.min(p, g));
    const m = e.scaleGrid;
    if (m && (p = m * Math.floor(p / m), g = m * Math.floor(g / m)), p = rr(p, l, c), g = rr(g, u, h), this.scale(p, g), t) {
      const v = this.options, y = d.x - r.x * p - v.x, b = d.y - r.y * g - v.y;
      this.translate(y, b);
    }
  }
  getContentArea(e = {}) {
    return e.useCellGeometry !== !1 ? this.model.getAllCellsBBox() || new ye() : It.getBBox(this.stage);
  }
  getContentBBox(e = {}) {
    return this.graph.localToGraph(this.getContentArea(e));
  }
  getGraphArea() {
    const e = ye.fromSize(this.getComputedSize());
    return this.graph.graphToLocal(e);
  }
  zoomToRect(e, t = {}) {
    const i = ye.create(e), r = this.graph;
    t.contentArea = i, t.viewportArea == null && (t.viewportArea = {
      x: r.options.x,
      y: r.options.y,
      width: this.options.width,
      height: this.options.height
    }), this.scaleContentToFitImpl(t, !1);
    const s = i.getCenter();
    return this.centerPoint(s.x, s.y), this;
  }
  zoomToFit(e = {}) {
    return this.zoomToRect(this.getContentArea(e), e);
  }
  centerPoint(e, t) {
    const i = this.getComputedSize(), r = this.getScale(), s = this.getTranslation(), o = i.width / 2, a = i.height / 2;
    e = typeof e == "number" ? e : o, t = typeof t == "number" ? t : a, e = o - e * r.sx, t = a - t * r.sy, (s.tx !== e || s.ty !== t) && this.translate(e, t);
  }
  centerContent(e) {
    const i = this.graph.getContentArea(e).getCenter();
    this.centerPoint(i.x, i.y);
  }
  centerCell(e) {
    return this.positionCell(e, "center");
  }
  positionPoint(e, t, i) {
    const r = this.getComputedSize();
    t = ys(t, Math.max(0, r.width)), t < 0 && (t = r.width + t), i = ys(i, Math.max(0, r.height)), i < 0 && (i = r.height + i);
    const s = this.getTranslation(), o = this.getScale(), a = t - e.x * o.sx, l = i - e.y * o.sy;
    (s.tx !== a || s.ty !== l) && this.translate(a, l);
  }
  positionRect(e, t) {
    const i = ye.create(e);
    switch (t) {
      case "center":
        return this.positionPoint(i.getCenter(), "50%", "50%");
      case "top":
        return this.positionPoint(i.getTopCenter(), "50%", 0);
      case "top-right":
        return this.positionPoint(i.getTopRight(), "100%", 0);
      case "right":
        return this.positionPoint(i.getRightMiddle(), "100%", "50%");
      case "bottom-right":
        return this.positionPoint(i.getBottomRight(), "100%", "100%");
      case "bottom":
        return this.positionPoint(i.getBottomCenter(), "50%", "100%");
      case "bottom-left":
        return this.positionPoint(i.getBottomLeft(), 0, "100%");
      case "left":
        return this.positionPoint(i.getLeftMiddle(), 0, "50%");
      case "top-left":
        return this.positionPoint(i.getTopLeft(), 0, 0);
      default:
        return this;
    }
  }
  positionCell(e, t) {
    const i = e.getBBox();
    return this.positionRect(i, t);
  }
  positionContent(e, t) {
    const i = this.graph.getContentArea(t);
    return this.positionRect(i, e);
  }
}
var roe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Kw extends ui {
  get elem() {
    return this.view.background;
  }
  init() {
    this.startListening(), this.options.background && this.draw(this.options.background);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  updateBackgroundImage(e = {}) {
    let t = e.size || "auto auto", i = e.position || "center";
    const r = this.graph.transform.getScale(), s = this.graph.translate();
    if (typeof i == "object") {
      const o = s.tx + r.sx * (i.x || 0), a = s.ty + r.sy * (i.y || 0);
      i = `${o}px ${a}px`;
    }
    typeof t == "object" && (t = ye.fromSize(t).scale(r.sx, r.sy), t = `${t.width}px ${t.height}px`), this.elem.style.backgroundSize = t, this.elem.style.backgroundPosition = i;
  }
  drawBackgroundImage(e, t = {}) {
    if (!(e instanceof HTMLImageElement)) {
      this.elem.style.backgroundImage = "";
      return;
    }
    const i = this.optionsCache;
    if (i && i.image !== t.image)
      return;
    let r;
    const s = t.opacity, o = t.size;
    let a = t.repeat || "no-repeat";
    const l = qd.registry.get(a);
    if (typeof l == "function") {
      const u = t.quality || 1;
      e.width *= u, e.height *= u;
      const h = l(e, t);
      if (!(h instanceof HTMLCanvasElement))
        throw new Error("Background pattern must return an HTML Canvas instance");
      r = h.toDataURL("image/png"), t.repeat && a !== t.repeat ? a = t.repeat : a = "repeat", typeof o == "object" ? (o.width *= h.width / e.width, o.height *= h.height / e.height) : o === void 0 && (t.size = {
        width: h.width / u,
        height: h.height / u
      });
    } else
      r = e.src, o === void 0 && (t.size = {
        width: e.width,
        height: e.height
      });
    i != null && typeof t.size == "object" && t.image === i.image && t.repeat === i.repeat && t.quality === i.quality && (i.size = Md(t.size));
    const c = this.elem.style;
    c.backgroundImage = `url(${r})`, c.backgroundRepeat = a, c.opacity = s == null || s >= 1 ? "" : `${s}`, this.updateBackgroundImage(t);
  }
  updateBackgroundColor(e) {
    this.elem.style.backgroundColor = e || "";
  }
  updateBackgroundOptions(e) {
    this.graph.options.background = e;
  }
  update() {
    this.optionsCache && this.updateBackgroundImage(this.optionsCache);
  }
  draw(e) {
    const t = e || {};
    if (this.updateBackgroundOptions(e), this.updateBackgroundColor(t.color), t.image) {
      this.optionsCache = Md(t);
      const i = document.createElement("img");
      i.onload = () => this.drawBackgroundImage(i, e), i.setAttribute("crossorigin", "anonymous"), i.src = t.image;
    } else
      this.drawBackgroundImage(null), this.optionsCache = null;
  }
  clear() {
    this.draw();
  }
  dispose() {
    this.clear(), this.stopListening();
  }
}
roe([
  ui.dispose()
], Kw.prototype, "dispose", null);
var soe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Jw extends ui {
  get widgetOptions() {
    return this.options.panning;
  }
  get pannable() {
    return this.widgetOptions && this.widgetOptions.enabled === !0;
  }
  init() {
    this.onRightMouseDown = this.onRightMouseDown.bind(this), this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this), this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this), this.startListening(), this.updateClassName();
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onMouseDown, this), this.graph.on("node:unhandled:mousedown", this.onMouseDown, this), this.graph.on("edge:unhandled:mousedown", this.onMouseDown, this), vi.on(this.graph.container, "mousedown", this.onRightMouseDown), vi.on(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle = new HM(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.mousewheelHandle.enable();
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onMouseDown, this), this.graph.off("node:unhandled:mousedown", this.onMouseDown, this), this.graph.off("edge:unhandled:mousedown", this.onMouseDown, this), vi.off(this.graph.container, "mousedown", this.onRightMouseDown), vi.off(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle && this.mousewheelHandle.disable();
  }
  allowPanning(e, t) {
    return e.spaceKey = this.isSpaceKeyPressed, this.pannable && Ba.isMatch(e, this.widgetOptions.modifiers, t);
  }
  startPanning(e) {
    const t = this.view.normalizeEvent(e);
    this.clientX = t.clientX, this.clientY = t.clientY, this.panning = !0, this.updateClassName(), vi.on(document.body, {
      "mousemove.panning touchmove.panning": this.pan.bind(this),
      "mouseup.panning touchend.panning": this.stopPanning.bind(this),
      "mouseleave.panning": this.stopPanning.bind(this)
    }), vi.on(window, "mouseup.panning", this.stopPanning.bind(this));
  }
  pan(e) {
    const t = this.view.normalizeEvent(e), i = t.clientX - this.clientX, r = t.clientY - this.clientY;
    this.clientX = t.clientX, this.clientY = t.clientY, this.graph.translateBy(i, r);
  }
  // eslint-disable-next-line
  stopPanning(e) {
    this.panning = !1, this.updateClassName(), vi.off(document.body, ".panning"), vi.off(window, ".panning");
  }
  updateClassName() {
    const e = this.view.container, t = this.view.prefixClassName("graph-panning"), i = this.view.prefixClassName("graph-pannable");
    this.pannable ? this.panning ? (Ye(e, t), Nn(e, i)) : (Nn(e, t), Ye(e, i)) : (Nn(e, t), Nn(e, i));
  }
  onMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e))
      return;
    const t = this.graph.getPlugin("selection"), i = t && t.allowRubberband(e, !0);
    (this.allowPanning(e, !0) || this.allowPanning(e) && !i) && this.startPanning(e);
  }
  onRightMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    t != null && t.includes("rightMouseDown") && e.button === 2 && this.allowPanning(e, !0) && this.startPanning(e);
  }
  onMouseWheel(e, t, i) {
    this.graph.translateBy(-t, -i);
  }
  onSpaceKeyDown(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !0);
  }
  onSpaceKeyUp(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !1);
  }
  allowBlankMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    return (t == null ? void 0 : t.includes("leftMouseDown")) && e.button === 0 || (t == null ? void 0 : t.includes("mouseWheelDown")) && e.button === 1;
  }
  allowMouseWheel(e) {
    var t;
    return this.pannable && !e.ctrlKey && ((t = this.widgetOptions.eventTypes) === null || t === void 0 ? void 0 : t.includes("mouseWheel"));
  }
  autoPanning(e, t) {
    const r = this.graph.getGraphArea();
    let s = 0, o = 0;
    e <= r.left + 10 && (s = -10), t <= r.top + 10 && (o = -10), e >= r.right - 10 && (s = 10), t >= r.bottom - 10 && (o = 10), (s !== 0 || o !== 0) && this.graph.translateBy(-s, -o);
  }
  enablePanning() {
    this.pannable || (this.widgetOptions.enabled = !0, this.updateClassName());
  }
  disablePanning() {
    this.pannable && (this.widgetOptions.enabled = !1, this.updateClassName());
  }
  dispose() {
    this.stopListening();
  }
}
soe([
  ui.dispose()
], Jw.prototype, "dispose", null);
var ooe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class ex extends ui {
  constructor() {
    super(...arguments), this.cumulatedFactor = 1;
  }
  get widgetOptions() {
    return this.options.mousewheel;
  }
  init() {
    this.container = this.graph.container, this.target = this.widgetOptions.global ? document : this.container, this.mousewheelHandle = new HM(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.widgetOptions.enabled && this.enable(!0);
  }
  get disabled() {
    return this.widgetOptions.enabled !== !0;
  }
  enable(e) {
    (this.disabled || e) && (this.widgetOptions.enabled = !0, this.mousewheelHandle.enable());
  }
  disable() {
    this.disabled || (this.widgetOptions.enabled = !1, this.mousewheelHandle.disable());
  }
  allowMouseWheel(e) {
    const t = this.widgetOptions.guard;
    return (t == null || t(e)) && Ba.isMatch(e, this.widgetOptions.modifiers);
  }
  onMouseWheel(e) {
    const t = this.widgetOptions.guard;
    if ((t == null || t(e)) && Ba.isMatch(e, this.widgetOptions.modifiers)) {
      const i = this.widgetOptions.factor || 1.2;
      this.currentScale == null && (this.startPos = { x: e.clientX, y: e.clientY }, this.currentScale = this.graph.transform.getScale().sx), e.deltaY < 0 ? this.currentScale < 0.15 ? this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * i * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 1.05)) : this.currentScale <= 0.15 ? this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * (1 / i) * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 0.95)), this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
      const s = this.currentScale;
      let o = this.graph.transform.clampScale(s * this.cumulatedFactor);
      const a = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER, l = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
      if (o = rr(o, a, l), o !== s)
        if (this.widgetOptions.zoomAtMousePosition) {
          const u = !!this.graph.getPlugin("scroller") ? this.graph.clientToLocal(this.startPos) : this.graph.clientToGraph(this.startPos);
          this.graph.zoom(o, {
            absolute: !0,
            center: u.clone()
          });
        } else
          this.graph.zoom(o, { absolute: !0 });
      this.currentScale = null, this.cumulatedFactor = 1;
    }
  }
  dispose() {
    this.disable();
  }
}
ooe([
  Zo.dispose()
], ex.prototype, "dispose", null);
var aoe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class ZR extends ui {
  init() {
    this.resetRenderArea = cj(this.resetRenderArea, 200, {
      leading: !0
    }), this.resetRenderArea(), this.startListening();
  }
  startListening() {
    this.graph.on("translate", this.resetRenderArea, this), this.graph.on("scale", this.resetRenderArea, this), this.graph.on("resize", this.resetRenderArea, this);
  }
  stopListening() {
    this.graph.off("translate", this.resetRenderArea, this), this.graph.off("scale", this.resetRenderArea, this), this.graph.off("resize", this.resetRenderArea, this);
  }
  enableVirtualRender() {
    this.options.virtual = !0, this.resetRenderArea();
  }
  disableVirtualRender() {
    this.options.virtual = !1, this.graph.renderer.setRenderArea(void 0);
  }
  resetRenderArea() {
    if (this.options.virtual) {
      const e = this.graph.getGraphArea();
      this.graph.renderer.setRenderArea(e);
    }
  }
  dispose() {
    this.stopListening();
  }
}
aoe([
  ui.dispose()
], ZR.prototype, "dispose", null);
class loe {
  constructor() {
    this.isFlushing = !1, this.isFlushPending = !1, this.scheduleId = 0, this.queue = [], this.frameInterval = 33, this.initialTime = Date.now();
  }
  queueJob(e) {
    if (e.priority & Ao.PRIOR)
      e.cb();
    else {
      const t = this.findInsertionIndex(e);
      t >= 0 && this.queue.splice(t, 0, e);
    }
  }
  queueFlush() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.scheduleJob());
  }
  queueFlushSync() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.flushJobsSync());
  }
  clearJobs() {
    this.queue.length = 0, this.isFlushing = !1, this.isFlushPending = !1, this.cancelScheduleJob();
  }
  flushJobs() {
    this.isFlushPending = !1, this.isFlushing = !0;
    const e = this.getCurrentTime();
    let t;
    for (; (t = this.queue.shift()) && (t.cb(), !(this.getCurrentTime() - e >= this.frameInterval)); )
      ;
    this.isFlushing = !1, this.queue.length && this.queueFlush();
  }
  flushJobsSync() {
    this.isFlushPending = !1, this.isFlushing = !0;
    let e;
    for (; e = this.queue.shift(); )
      try {
        e.cb();
      } catch (t) {
        console.log(t);
      }
    this.isFlushing = !1;
  }
  findInsertionIndex(e) {
    let t = 0, i = this.queue.length, r = i - 1;
    const s = e.priority;
    for (; t <= r; ) {
      const o = (r - t >> 1) + t;
      s <= this.queue[o].priority ? t = o + 1 : (i = o, r = o - 1);
    }
    return i;
  }
  scheduleJob() {
    "requestIdleCallback" in window ? (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
      timeout: 100
    })) : (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.setTimeout(this.flushJobs.bind(this)));
  }
  cancelScheduleJob() {
    "cancelIdleCallback" in window ? (this.scheduleId && window.cancelIdleCallback(this.scheduleId), this.scheduleId = 0) : (this.scheduleId && clearTimeout(this.scheduleId), this.scheduleId = 0);
  }
  getCurrentTime() {
    return typeof performance == "object" && typeof performance.now == "function" ? performance.now() : Date.now() - this.initialTime;
  }
}
var Ao;
(function(n) {
  n[n.Update = 2] = "Update", n[n.RenderEdge = 4] = "RenderEdge", n[n.RenderNode = 8] = "RenderNode", n[n.PRIOR = 1048576] = "PRIOR";
})(Ao || (Ao = {}));
var coe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Zn extends Zo {
  get model() {
    return this.graph.model;
  }
  get container() {
    return this.graph.view.stage;
  }
  constructor(e) {
    super(), this.views = {}, this.willRemoveViews = {}, this.queue = new loe(), this.graph = e, this.init();
  }
  init() {
    this.startListening(), this.renderViews(this.model.getCells());
  }
  startListening() {
    this.model.on("reseted", this.onModelReseted, this), this.model.on("cell:added", this.onCellAdded, this), this.model.on("cell:removed", this.onCellRemoved, this), this.model.on("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.on("cell:change:visible", this.onCellVisibleChanged, this);
  }
  stopListening() {
    this.model.off("reseted", this.onModelReseted, this), this.model.off("cell:added", this.onCellAdded, this), this.model.off("cell:removed", this.onCellRemoved, this), this.model.off("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.off("cell:change:visible", this.onCellVisibleChanged, this);
  }
  onModelReseted({ options: e }) {
    this.queue.clearJobs(), this.removeZPivots(), this.resetViews();
    const t = this.model.getCells();
    this.renderViews(t, Object.assign(Object.assign({}, e), { queue: t.map((i) => i.id) }));
  }
  onCellAdded({ cell: e, options: t }) {
    this.renderViews([e], t);
  }
  onCellRemoved({ cell: e }) {
    this.removeViews([e]);
  }
  onCellZIndexChanged({ cell: e, options: t }) {
    const i = this.views[e.id];
    i && this.requestViewUpdate(i.view, Zn.FLAG_INSERT, t, Ao.Update, !0);
  }
  onCellVisibleChanged({ cell: e, current: t }) {
    this.toggleVisible(e, !!t);
  }
  requestViewUpdate(e, t, i = {}, r = Ao.Update, s = !0) {
    const o = e.cell.id, a = this.views[o];
    if (!a)
      return;
    a.flag = t, a.options = i, (e.hasAction(t, ["translate", "resize", "rotate"]) || i.async === !1) && (r = Ao.PRIOR, s = !1), this.queue.queueJob({
      id: o,
      priority: r,
      cb: () => {
        this.renderViewInArea(e, t, i);
        const u = i.queue;
        if (u) {
          const h = u.indexOf(e.cell.id);
          h >= 0 && u.splice(h, 1), u.length === 0 && this.graph.trigger("render:done");
        }
      }
    }), this.getEffectedEdges(e).forEach((u) => {
      this.requestViewUpdate(u.view, u.flag, i, r, !1);
    }), s && this.flush();
  }
  setRenderArea(e) {
    this.renderArea = e, this.flushWaitingViews();
  }
  isViewMounted(e) {
    if (e == null)
      return !1;
    const t = this.views[e.cell.id];
    return t ? t.state === Zn.ViewState.MOUNTED : !1;
  }
  renderViews(e, t = {}) {
    e.sort((i, r) => i.isNode() && r.isEdge() ? -1 : 0), e.forEach((i) => {
      const r = i.id, s = this.views;
      let o = 0, a = s[r];
      if (a)
        o = Zn.FLAG_INSERT;
      else {
        const l = this.createCellView(i);
        l && (l.graph = this.graph, o = Zn.FLAG_INSERT | l.getBootstrapFlag(), a = {
          view: l,
          flag: o,
          options: t,
          state: Zn.ViewState.CREATED
        }, this.views[r] = a);
      }
      a && this.requestViewUpdate(a.view, o, t, this.getRenderPriority(a.view), !1);
    }), this.flush();
  }
  renderViewInArea(e, t, i = {}) {
    const r = e.cell, s = r.id, o = this.views[s];
    if (!o)
      return;
    let a = 0;
    this.isUpdatable(e) ? (a = this.updateView(e, t, i), o.flag = a) : o.state === Zn.ViewState.MOUNTED ? (a = this.updateView(e, t, i), o.flag = a) : o.state = Zn.ViewState.WAITING, a && r.isEdge() && !(a & e.getFlag(["source", "target"])) && this.queue.queueJob({
      id: s,
      priority: Ao.RenderEdge,
      cb: () => {
        this.updateView(e, t, i);
      }
    });
  }
  removeViews(e) {
    e.forEach((t) => {
      const i = t.id, r = this.views[i];
      r && (this.willRemoveViews[i] = r, delete this.views[i], this.queue.queueJob({
        id: i,
        priority: this.getRenderPriority(r.view),
        cb: () => {
          this.removeView(r.view);
        }
      }));
    }), this.flush();
  }
  flush() {
    this.graph.options.async ? this.queue.queueFlush() : this.queue.queueFlushSync();
  }
  flushWaitingViews() {
    Object.values(this.views).forEach((e) => {
      if (e && e.state === Zn.ViewState.WAITING) {
        const { view: t, flag: i, options: r } = e;
        this.requestViewUpdate(t, i, r, this.getRenderPriority(t), !1);
      }
    }), this.flush();
  }
  updateView(e, t, i = {}) {
    if (e == null)
      return 0;
    if (An.isCellView(e)) {
      if (t & Zn.FLAG_REMOVE)
        return this.removeView(e.cell), 0;
      t & Zn.FLAG_INSERT && (this.insertView(e), t ^= Zn.FLAG_INSERT);
    }
    return t ? e.confirmUpdate(t, i) : 0;
  }
  insertView(e) {
    const t = this.views[e.cell.id];
    if (t) {
      const i = e.cell.getZIndex(), r = this.addZPivot(i);
      this.container.insertBefore(e.container, r), e.cell.isVisible() || this.toggleVisible(e.cell, !1), t.state = Zn.ViewState.MOUNTED, this.graph.trigger("view:mounted", { view: e });
    }
  }
  resetViews() {
    this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews), Object.values(this.willRemoveViews).forEach((e) => {
      e && this.removeView(e.view);
    }), this.views = {}, this.willRemoveViews = {};
  }
  removeView(e) {
    const t = e.cell, i = this.willRemoveViews[t.id];
    i && e && (i.view.remove(), delete this.willRemoveViews[t.id], this.graph.trigger("view:unmounted", { view: e }));
  }
  toggleVisible(e, t) {
    const i = this.model.getConnectedEdges(e);
    for (let s = 0, o = i.length; s < o; s += 1) {
      const a = i[s];
      if (t) {
        const l = a.getSourceCell(), c = a.getTargetCell();
        if (l && !l.isVisible() || c && !c.isVisible())
          continue;
        this.toggleVisible(a, !0);
      } else
        this.toggleVisible(a, !1);
    }
    const r = this.views[e.id];
    r && qn(r.view.container, {
      display: t ? "unset" : "none"
    });
  }
  addZPivot(e = 0) {
    this.zPivots == null && (this.zPivots = {});
    const t = this.zPivots;
    let i = t[e];
    if (i)
      return i;
    i = t[e] = document.createComment(`z-index:${e + 1}`);
    let r = -1 / 0;
    for (const o in t) {
      const a = +o;
      a < e && a > r && (r = a, e - 1);
    }
    const s = this.container;
    if (r !== -1 / 0) {
      const o = t[r];
      s.insertBefore(i, o.nextSibling);
    } else
      s.insertBefore(i, s.firstChild);
    return i;
  }
  removeZPivots() {
    this.zPivots && Object.values(this.zPivots).forEach((e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }), this.zPivots = {};
  }
  createCellView(e) {
    const t = { graph: this.graph }, i = this.graph.options.createCellView;
    if (i) {
      const s = Ze(i, this.graph, e);
      if (s)
        return new s(e, t);
      if (s === null)
        return null;
    }
    const r = e.view;
    if (r != null && typeof r == "string") {
      const s = An.registry.get(r);
      return s ? new s(e, t) : An.registry.onNotFound(r);
    }
    return e.isNode() ? new $r(e, t) : e.isEdge() ? new Wo(e, t) : null;
  }
  getEffectedEdges(e) {
    const t = [], i = e.cell, r = this.model.getConnectedEdges(i);
    for (let s = 0, o = r.length; s < o; s += 1) {
      const a = r[s], l = this.views[a.id];
      if (!l)
        continue;
      const c = l.view;
      if (!this.isViewMounted(c))
        continue;
      const u = ["update"];
      a.getTargetCell() === i && u.push("target"), a.getSourceCell() === i && u.push("source"), t.push({
        id: a.id,
        view: c,
        flag: c.getFlag(u)
      });
    }
    return t;
  }
  isUpdatable(e) {
    if (e.isNodeView())
      return this.renderArea ? this.renderArea.isIntersectWithRect(e.cell.getBBox()) : !0;
    if (e.isEdgeView()) {
      const t = e.cell, i = t.getSourceCell(), r = t.getTargetCell();
      if (this.renderArea && i && r)
        return this.renderArea.isIntersectWithRect(i.getBBox()) || this.renderArea.isIntersectWithRect(r.getBBox());
    }
    return !0;
  }
  getRenderPriority(e) {
    return e.cell.isNode() ? Ao.RenderNode : Ao.RenderEdge;
  }
  dispose() {
    this.stopListening(), Object.keys(this.views).forEach((e) => {
      this.views[e].view.dispose();
    }), this.views = {};
  }
}
coe([
  Zo.dispose()
], Zn.prototype, "dispose", null);
(function(n) {
  n.FLAG_INSERT = 1 << 30, n.FLAG_REMOVE = 1 << 29, n.FLAG_RENDER = (1 << 26) - 1;
})(Zn || (Zn = {}));
(function(n) {
  (function(e) {
    e[e.CREATED = 0] = "CREATED", e[e.MOUNTED = 1] = "MOUNTED", e[e.WAITING = 2] = "WAITING";
  })(n.ViewState || (n.ViewState = {}));
})(Zn || (Zn = {}));
var uoe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
let tx = class extends ui {
  constructor() {
    super(...arguments), this.schedule = new Zn(this.graph);
  }
  requestViewUpdate(e, t, i = {}) {
    this.schedule.requestViewUpdate(e, t, i);
  }
  isViewMounted(e) {
    return this.schedule.isViewMounted(e);
  }
  setRenderArea(e) {
    this.schedule.setRenderArea(e);
  }
  findViewByElem(e) {
    if (e == null)
      return null;
    const t = this.options.container, i = typeof e == "string" ? t.querySelector(e) : e instanceof Element ? e : e[0];
    if (i) {
      const r = this.graph.view.findAttr("data-cell-id", i);
      if (r) {
        const s = this.schedule.views;
        if (s[r])
          return s[r].view;
      }
    }
    return null;
  }
  findViewByCell(e) {
    if (e == null)
      return null;
    const t = gt.isCell(e) ? e.id : e, i = this.schedule.views;
    return i[t] ? i[t].view : null;
  }
  findViewsFromPoint(e) {
    const t = { x: e.x, y: e.y };
    return this.model.getCells().map((i) => this.findViewByCell(i)).filter((i) => i != null ? It.getBBox(i.container, {
      target: this.view.stage
    }).containsPoint(t) : !1);
  }
  findEdgeViewsFromPoint(e, t = 5) {
    return this.model.getEdges().map((i) => this.findViewByCell(i)).filter((i) => {
      if (i != null) {
        const r = i.getClosestPoint(e);
        if (r)
          return r.distance(e) <= t;
      }
      return !1;
    });
  }
  findViewsInArea(e, t = {}) {
    const i = ye.create(e);
    return this.model.getCells().map((r) => this.findViewByCell(r)).filter((r) => {
      if (r) {
        if (t.nodeOnly && !r.isNodeView())
          return !1;
        const s = It.getBBox(r.container, {
          target: this.view.stage
        });
        return s.width === 0 ? s.inflate(1, 0) : s.height === 0 && s.inflate(0, 1), t.strict ? i.containsRect(s) : i.isIntersectWithRect(s);
      }
      return !1;
    });
  }
  dispose() {
    this.schedule.dispose();
  }
};
uoe([
  ui.dispose()
], tx.prototype, "dispose", null);
var Kk = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class qR extends ui {
  get cid() {
    return this.graph.view.cid;
  }
  get svg() {
    return this.view.svg;
  }
  get defs() {
    return this.view.defs;
  }
  isDefined(e) {
    return this.svg.getElementById(e) != null;
  }
  filter(e) {
    let t = e.id;
    const i = e.name;
    if (t || (t = `filter-${i}-${this.cid}-${L0(JSON.stringify(e))}`), !this.isDefined(t)) {
      const r = Tu.registry.get(i);
      if (r == null)
        return Tu.registry.onNotFound(i);
      const s = r(e.args || {}), o = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: "objectBoundingBox" }, e.attrs), { id: t });
      Je.create(Yt.sanitize(s), o).appendTo(this.defs);
    }
    return t;
  }
  gradient(e) {
    let t = e.id;
    const i = e.type;
    if (t || (t = `gradient-${i}-${this.cid}-${L0(JSON.stringify(e))}`), !this.isDefined(t)) {
      const s = e.stops.map((l) => {
        const c = l.opacity != null && Number.isFinite(l.opacity) ? l.opacity : 1;
        return `<stop offset="${l.offset}" stop-color="${l.color}" stop-opacity="${c}"/>`;
      }), o = `<${i}>${s.join("")}</${i}>`, a = Object.assign({ id: t }, e.attrs);
      Je.create(o, a).appendTo(this.defs);
    }
    return t;
  }
  marker(e) {
    const { id: t, refX: i, refY: r, markerUnits: s, markerOrient: o, tagName: a, children: l } = e, c = Kk(e, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
    let u = t;
    if (u || (u = `marker-${this.cid}-${L0(JSON.stringify(e))}`), !this.isDefined(u)) {
      a !== "path" && delete c.d;
      const h = Je.create("marker", {
        refX: i,
        refY: r,
        id: u,
        overflow: "visible",
        orient: o ?? "auto",
        markerUnits: s || "userSpaceOnUse"
      }, l ? l.map((d) => {
        var { tagName: f } = d, p = Kk(d, ["tagName"]);
        return Je.create(`${f}` || "path", jd(Object.assign(Object.assign({}, c), p)));
      }) : [Je.create(a || "path", jd(c))]);
      this.defs.appendChild(h.node);
    }
    return u;
  }
  remove(e) {
    const t = this.svg.getElementById(e);
    t && t.parentNode && t.parentNode.removeChild(t);
  }
}
class WR extends ui {
  getClientMatrix() {
    return ci(this.view.stage.getScreenCTM());
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */
  getClientOffset() {
    const e = this.view.svg.getBoundingClientRect();
    return new z(e.left, e.top);
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */
  getPageOffset() {
    return this.getClientOffset().translate(window.scrollX, window.scrollY);
  }
  snapToGrid(e, t) {
    return (typeof e == "number" ? this.clientToLocalPoint(e, t) : this.clientToLocalPoint(e.x, e.y)).snapToGrid(this.graph.getGridSize());
  }
  localToGraphPoint(e, t) {
    const i = z.create(e, t);
    return It.transformPoint(i, this.graph.matrix());
  }
  localToClientPoint(e, t) {
    const i = z.create(e, t);
    return It.transformPoint(i, this.getClientMatrix());
  }
  localToPagePoint(e, t) {
    return (typeof e == "number" ? this.localToGraphPoint(e, t) : this.localToGraphPoint(e)).translate(this.getPageOffset());
  }
  localToGraphRect(e, t, i, r) {
    const s = ye.create(e, t, i, r);
    return It.transformRectangle(s, this.graph.matrix());
  }
  localToClientRect(e, t, i, r) {
    const s = ye.create(e, t, i, r);
    return It.transformRectangle(s, this.getClientMatrix());
  }
  localToPageRect(e, t, i, r) {
    return (typeof e == "number" ? this.localToGraphRect(e, t, i, r) : this.localToGraphRect(e)).translate(this.getPageOffset());
  }
  graphToLocalPoint(e, t) {
    const i = z.create(e, t);
    return It.transformPoint(i, this.graph.matrix().inverse());
  }
  clientToLocalPoint(e, t) {
    const i = z.create(e, t);
    return It.transformPoint(i, this.getClientMatrix().inverse());
  }
  clientToGraphPoint(e, t) {
    const i = z.create(e, t);
    return It.transformPoint(i, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalPoint(e, t) {
    const r = z.create(e, t).diff(this.getPageOffset());
    return this.graphToLocalPoint(r);
  }
  graphToLocalRect(e, t, i, r) {
    const s = ye.create(e, t, i, r);
    return It.transformRectangle(s, this.graph.matrix().inverse());
  }
  clientToLocalRect(e, t, i, r) {
    const s = ye.create(e, t, i, r);
    return It.transformRectangle(s, this.getClientMatrix().inverse());
  }
  clientToGraphRect(e, t, i, r) {
    const s = ye.create(e, t, i, r);
    return It.transformRectangle(s, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalRect(e, t, i, r) {
    const s = ye.create(e, t, i, r), o = this.getPageOffset();
    return s.x -= o.x, s.y -= o.y, this.graphToLocalRect(s);
  }
}
var hoe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class mm extends ui {
  constructor() {
    super(...arguments), this.highlights = {};
  }
  init() {
    this.startListening();
  }
  startListening() {
    this.graph.on("cell:highlight", this.onCellHighlight, this), this.graph.on("cell:unhighlight", this.onCellUnhighlight, this);
  }
  stopListening() {
    this.graph.off("cell:highlight", this.onCellHighlight, this), this.graph.off("cell:unhighlight", this.onCellUnhighlight, this);
  }
  onCellHighlight({ view: e, magnet: t, options: i = {} }) {
    const r = this.resolveHighlighter(i);
    if (!r)
      return;
    const s = this.getHighlighterId(t, r);
    if (!this.highlights[s]) {
      const o = r.highlighter;
      o.highlight(e, t, Object.assign({}, r.args)), this.highlights[s] = {
        cellView: e,
        magnet: t,
        highlighter: o,
        args: r.args
      };
    }
  }
  onCellUnhighlight({ magnet: e, options: t = {} }) {
    const i = this.resolveHighlighter(t);
    if (!i)
      return;
    const r = this.getHighlighterId(e, i);
    this.unhighlight(r);
  }
  resolveHighlighter(e) {
    const t = this.options;
    let i = e.highlighter;
    if (i == null) {
      const a = e.type;
      i = a && t.highlighting[a] || t.highlighting.default;
    }
    if (i == null)
      return null;
    const r = typeof i == "string" ? {
      name: i
    } : i, s = r.name, o = Bo.registry.get(s);
    return o == null ? Bo.registry.onNotFound(s) : (Bo.check(s, o), {
      name: s,
      highlighter: o,
      args: r.args || {}
    });
  }
  getHighlighterId(e, t) {
    return jw(e), t.name + e.id + JSON.stringify(t.args);
  }
  unhighlight(e) {
    const t = this.highlights[e];
    t && (t.highlighter.unhighlight(t.cellView, t.magnet, t.args), delete this.highlights[e]);
  }
  dispose() {
    Object.keys(this.highlights).forEach((e) => this.unhighlight(e)), this.stopListening();
  }
}
hoe([
  mm.dispose()
], mm.prototype, "dispose", null);
var doe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class HR extends ui {
  getScroller() {
    const e = this.graph.getPlugin("scroller");
    return e && e.options.enabled ? e : null;
  }
  getContainer() {
    const e = this.getScroller();
    return e ? e.container.parentElement : this.graph.container.parentElement;
  }
  getSensorTarget() {
    const e = this.options.autoResize;
    if (e)
      return typeof e == "boolean" ? this.getContainer() : e;
  }
  init() {
    if (this.options.autoResize) {
      const t = this.getSensorTarget();
      t && am.bind(t, () => {
        const i = t.offsetWidth, r = t.offsetHeight;
        this.resize(i, r);
      });
    }
  }
  resize(e, t) {
    const i = this.getScroller();
    i ? i.resize(e, t) : this.graph.transform.resize(e, t);
  }
  dispose() {
    am.clear(this.graph.container);
  }
}
doe([
  ui.dispose()
], HR.prototype, "dispose", null);
var foe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Pe extends gn {
  get container() {
    return this.options.container;
  }
  get [Symbol.toStringTag]() {
    return Pe.toStringTag;
  }
  constructor(e) {
    super(), this.installedPlugins = /* @__PURE__ */ new Set(), this.options = Ud.get(e), this.css = new Jy(this), this.view = new go(this), this.defs = new qR(this), this.coord = new WR(this), this.transform = new FR(this), this.highlight = new mm(this), this.grid = new Gw(this), this.background = new Kw(this), this.options.model ? this.model = this.options.model : (this.model = new lr(), this.model.graph = this), this.renderer = new tx(this), this.panning = new Jw(this), this.mousewheel = new ex(this), this.virtualRender = new ZR(this), this.size = new HR(this);
  }
  // #region model
  isNode(e) {
    return e.isNode();
  }
  isEdge(e) {
    return e.isEdge();
  }
  resetCells(e, t = {}) {
    return this.model.resetCells(e, t), this;
  }
  clearCells(e = {}) {
    return this.model.clear(e), this;
  }
  toJSON(e = {}) {
    return this.model.toJSON(e);
  }
  parseJSON(e) {
    return this.model.parseJSON(e);
  }
  fromJSON(e, t = {}) {
    return this.model.fromJSON(e, t), this;
  }
  getCellById(e) {
    return this.model.getCell(e);
  }
  addNode(e, t = {}) {
    return this.model.addNode(e, t);
  }
  addNodes(e, t = {}) {
    return this.addCell(e.map((i) => Tn.isNode(i) ? i : this.createNode(i)), t);
  }
  createNode(e) {
    return this.model.createNode(e);
  }
  removeNode(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  addEdge(e, t = {}) {
    return this.model.addEdge(e, t);
  }
  addEdges(e, t = {}) {
    return this.addCell(e.map((i) => xn.isEdge(i) ? i : this.createEdge(i)), t);
  }
  removeEdge(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  createEdge(e) {
    return this.model.createEdge(e);
  }
  addCell(e, t = {}) {
    return this.model.addCell(e, t), this;
  }
  removeCell(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  removeCells(e, t = {}) {
    return this.model.removeCells(e, t);
  }
  removeConnectedEdges(e, t = {}) {
    return this.model.removeConnectedEdges(e, t);
  }
  disconnectConnectedEdges(e, t = {}) {
    return this.model.disconnectConnectedEdges(e, t), this;
  }
  hasCell(e) {
    return this.model.has(e);
  }
  getCells() {
    return this.model.getCells();
  }
  getCellCount() {
    return this.model.total();
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.model.getNodes();
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.model.getEdges();
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    return this.model.getOutgoingEdges(e);
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    return this.model.getIncomingEdges(e);
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    return this.model.getConnectedEdges(e, t);
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRootNodes() {
    return this.model.getRoots();
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafNodes() {
    return this.model.getLeafs();
  }
  /**
   * Returns `true` if the node is a root node, i.e.
   * there is no  edges coming to the node.
   */
  isRootNode(e) {
    return this.model.isRoot(e);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e.
   * there is no edges going out from the node.
   */
  isLeafNode(e) {
    return this.model.isLeaf(e);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    return this.model.getNeighbors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, i = {}) {
    return this.model.isNeighbor(e, t, i);
  }
  getSuccessors(e, t = {}) {
    return this.model.getSuccessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, i = {}) {
    return this.model.isSuccessor(e, t, i);
  }
  getPredecessors(e, t = {}) {
    return this.model.getPredecessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, i = {}) {
    return this.model.isPredecessor(e, t, i);
  }
  getCommonAncestor(...e) {
    return this.model.getCommonAncestor(...e);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    return this.model.getSubGraph(e, t);
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    return this.model.cloneSubGraph(e, t);
  }
  cloneCells(e) {
    return this.model.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    return this.model.getNodesFromPoint(e, t);
  }
  getNodesInArea(e, t, i, r, s) {
    return this.model.getNodesInArea(e, t, i, r, s);
  }
  getNodesUnderNode(e, t = {}) {
    return this.model.getNodesUnderNode(e, t);
  }
  searchCell(e, t, i = {}) {
    return this.model.search(e, t, i), this;
  }
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, i = {}) {
    return this.model.getShortestPath(e, t, i);
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.model.getAllCellsBBox();
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return this.model.getCellsBBox(e, t);
  }
  startBatch(e, t = {}) {
    this.model.startBatch(e, t);
  }
  stopBatch(e, t = {}) {
    this.model.stopBatch(e, t);
  }
  batchUpdate(e, t, i) {
    const r = typeof e == "string" ? e : "update", s = typeof e == "string" ? t : e, o = typeof t == "function" ? i : t;
    this.startBatch(r, o);
    const a = s();
    return this.stopBatch(r, o), a;
  }
  updateCellId(e, t) {
    return this.model.updateCellId(e, t);
  }
  // #endregion
  // #region view
  findView(e) {
    return gt.isCell(e) ? this.findViewByCell(e) : this.findViewByElem(e);
  }
  findViews(e) {
    return ye.isRectangleLike(e) ? this.findViewsInArea(e) : z.isPointLike(e) ? this.findViewsFromPoint(e) : [];
  }
  findViewByCell(e) {
    return this.renderer.findViewByCell(e);
  }
  findViewByElem(e) {
    return this.renderer.findViewByElem(e);
  }
  findViewsFromPoint(e, t) {
    const i = typeof e == "number" ? { x: e, y: t } : e;
    return this.renderer.findViewsFromPoint(i);
  }
  findViewsInArea(e, t, i, r, s) {
    const o = typeof e == "number" ? {
      x: e,
      y: t,
      width: i,
      height: r
    } : e, a = typeof e == "number" ? s : t;
    return this.renderer.findViewsInArea(o, a);
  }
  matrix(e) {
    return typeof e > "u" ? this.transform.getMatrix() : (this.transform.setMatrix(e), this);
  }
  resize(e, t) {
    const i = this.getPlugin("scroller");
    return i ? i.resize(e, t) : this.transform.resize(e, t), this;
  }
  scale(e, t = e, i = 0, r = 0) {
    return typeof e > "u" ? this.transform.getScale() : (this.transform.scale(e, t, i, r), this);
  }
  zoom(e, t) {
    const i = this.getPlugin("scroller");
    if (i) {
      if (typeof e > "u")
        return i.zoom();
      i.zoom(e, t);
    } else {
      if (typeof e > "u")
        return this.transform.getZoom();
      this.transform.zoom(e, t);
    }
    return this;
  }
  zoomTo(e, t = {}) {
    const i = this.getPlugin("scroller");
    return i ? i.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })) : this.transform.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })), this;
  }
  zoomToRect(e, t = {}) {
    const i = this.getPlugin("scroller");
    return i ? i.zoomToRect(e, t) : this.transform.zoomToRect(e, t), this;
  }
  zoomToFit(e = {}) {
    const t = this.getPlugin("scroller");
    return t ? t.zoomToFit(e) : this.transform.zoomToFit(e), this;
  }
  rotate(e, t, i) {
    return typeof e > "u" ? this.transform.getRotation() : (this.transform.rotate(e, t, i), this);
  }
  translate(e, t) {
    return typeof e > "u" ? this.transform.getTranslation() : (this.transform.translate(e, t), this);
  }
  translateBy(e, t) {
    const i = this.translate(), r = i.tx + e, s = i.ty + t;
    return this.translate(r, s);
  }
  getGraphArea() {
    return this.transform.getGraphArea();
  }
  getContentArea(e = {}) {
    return this.transform.getContentArea(e);
  }
  getContentBBox(e = {}) {
    return this.transform.getContentBBox(e);
  }
  fitToContent(e, t, i, r) {
    return this.transform.fitToContent(e, t, i, r);
  }
  scaleContentToFit(e = {}) {
    return this.transform.scaleContentToFit(e), this;
  }
  /**
   * Position the center of graph to the center of the viewport.
   */
  center(e) {
    return this.centerPoint(e);
  }
  centerPoint(e, t, i) {
    const r = this.getPlugin("scroller");
    return r ? r.centerPoint(e, t, i) : this.transform.centerPoint(e, t), this;
  }
  centerContent(e) {
    const t = this.getPlugin("scroller");
    return t ? t.centerContent(e) : this.transform.centerContent(e), this;
  }
  centerCell(e, t) {
    const i = this.getPlugin("scroller");
    return i ? i.centerCell(e, t) : this.transform.centerCell(e), this;
  }
  positionPoint(e, t, i, r = {}) {
    const s = this.getPlugin("scroller");
    return s ? s.positionPoint(e, t, i, r) : this.transform.positionPoint(e, t, i), this;
  }
  positionRect(e, t, i) {
    const r = this.getPlugin("scroller");
    return r ? r.positionRect(e, t, i) : this.transform.positionRect(e, t), this;
  }
  positionCell(e, t, i) {
    const r = this.getPlugin("scroller");
    return r ? r.positionCell(e, t, i) : this.transform.positionCell(e, t), this;
  }
  positionContent(e, t) {
    const i = this.getPlugin("scroller");
    return i ? i.positionContent(e, t) : this.transform.positionContent(e, t), this;
  }
  snapToGrid(e, t) {
    return this.coord.snapToGrid(e, t);
  }
  pageToLocal(e, t, i, r) {
    return ye.isRectangleLike(e) ? this.coord.pageToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof i == "number" && typeof r == "number" ? this.coord.pageToLocalRect(e, t, i, r) : this.coord.pageToLocalPoint(e, t);
  }
  localToPage(e, t, i, r) {
    return ye.isRectangleLike(e) ? this.coord.localToPageRect(e) : typeof e == "number" && typeof t == "number" && typeof i == "number" && typeof r == "number" ? this.coord.localToPageRect(e, t, i, r) : this.coord.localToPagePoint(e, t);
  }
  clientToLocal(e, t, i, r) {
    return ye.isRectangleLike(e) ? this.coord.clientToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof i == "number" && typeof r == "number" ? this.coord.clientToLocalRect(e, t, i, r) : this.coord.clientToLocalPoint(e, t);
  }
  localToClient(e, t, i, r) {
    return ye.isRectangleLike(e) ? this.coord.localToClientRect(e) : typeof e == "number" && typeof t == "number" && typeof i == "number" && typeof r == "number" ? this.coord.localToClientRect(e, t, i, r) : this.coord.localToClientPoint(e, t);
  }
  localToGraph(e, t, i, r) {
    return ye.isRectangleLike(e) ? this.coord.localToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof i == "number" && typeof r == "number" ? this.coord.localToGraphRect(e, t, i, r) : this.coord.localToGraphPoint(e, t);
  }
  graphToLocal(e, t, i, r) {
    return ye.isRectangleLike(e) ? this.coord.graphToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof i == "number" && typeof r == "number" ? this.coord.graphToLocalRect(e, t, i, r) : this.coord.graphToLocalPoint(e, t);
  }
  clientToGraph(e, t, i, r) {
    return ye.isRectangleLike(e) ? this.coord.clientToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof i == "number" && typeof r == "number" ? this.coord.clientToGraphRect(e, t, i, r) : this.coord.clientToGraphPoint(e, t);
  }
  // #endregion
  // #region defs
  defineFilter(e) {
    return this.defs.filter(e);
  }
  defineGradient(e) {
    return this.defs.gradient(e);
  }
  defineMarker(e) {
    return this.defs.marker(e);
  }
  // #endregion
  // #region grid
  getGridSize() {
    return this.grid.getGridSize();
  }
  setGridSize(e) {
    return this.grid.setGridSize(e), this;
  }
  showGrid() {
    return this.grid.show(), this;
  }
  hideGrid() {
    return this.grid.hide(), this;
  }
  clearGrid() {
    return this.grid.clear(), this;
  }
  drawGrid(e) {
    return this.grid.draw(e), this;
  }
  // #endregion
  // #region background
  updateBackground() {
    return this.background.update(), this;
  }
  drawBackground(e, t) {
    const i = this.getPlugin("scroller");
    return i != null && (this.options.background == null || !t) ? i.drawBackground(e, t) : this.background.draw(e), this;
  }
  clearBackground(e) {
    const t = this.getPlugin("scroller");
    return t != null && (this.options.background == null || !e) ? t.clearBackground(e) : this.background.clear(), this;
  }
  // #endregion
  // #region virtual-render
  enableVirtualRender() {
    return this.virtualRender.enableVirtualRender(), this;
  }
  disableVirtualRender() {
    return this.virtualRender.disableVirtualRender(), this;
  }
  // #endregion
  // #region mousewheel
  isMouseWheelEnabled() {
    return !this.mousewheel.disabled;
  }
  enableMouseWheel() {
    return this.mousewheel.enable(), this;
  }
  disableMouseWheel() {
    return this.mousewheel.disable(), this;
  }
  toggleMouseWheel(e) {
    return e == null ? this.isMouseWheelEnabled() ? this.disableMouseWheel() : this.enableMouseWheel() : e ? this.enableMouseWheel() : this.disableMouseWheel(), this;
  }
  // #endregion
  // #region panning
  isPannable() {
    const e = this.getPlugin("scroller");
    return e ? e.isPannable() : this.panning.pannable;
  }
  enablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.enablePanning() : this.panning.enablePanning(), this;
  }
  disablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.disablePanning() : this.panning.disablePanning(), this;
  }
  togglePanning(e) {
    return e == null ? this.isPannable() ? this.disablePanning() : this.enablePanning() : e !== this.isPannable() && (e ? this.enablePanning() : this.disablePanning()), this;
  }
  // #endregion
  // #region plugin
  use(e, ...t) {
    return this.installedPlugins.has(e) || (this.installedPlugins.add(e), e.init(this, ...t)), this;
  }
  getPlugin(e) {
    return Array.from(this.installedPlugins).find((t) => t.name === e);
  }
  getPlugins(e) {
    return Array.from(this.installedPlugins).filter((t) => e.includes(t.name));
  }
  enablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const i = this.getPlugins(t);
    return i == null || i.forEach((r) => {
      var s;
      (s = r == null ? void 0 : r.enable) === null || s === void 0 || s.call(r);
    }), this;
  }
  disablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const i = this.getPlugins(t);
    return i == null || i.forEach((r) => {
      var s;
      (s = r == null ? void 0 : r.disable) === null || s === void 0 || s.call(r);
    }), this;
  }
  isPluginEnabled(e) {
    var t;
    const i = this.getPlugin(e);
    return (t = i == null ? void 0 : i.isEnabled) === null || t === void 0 ? void 0 : t.call(i);
  }
  disposePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const i = this.getPlugins(t);
    return i == null || i.forEach((r) => {
      r.dispose(), this.installedPlugins.delete(r);
    }), this;
  }
  // #endregion
  // #region dispose
  dispose(e = !0) {
    e && this.model.dispose(), this.css.dispose(), this.defs.dispose(), this.grid.dispose(), this.coord.dispose(), this.transform.dispose(), this.highlight.dispose(), this.background.dispose(), this.mousewheel.dispose(), this.panning.dispose(), this.view.dispose(), this.renderer.dispose(), this.installedPlugins.forEach((t) => {
      t.dispose();
    });
  }
}
foe([
  gn.dispose()
], Pe.prototype, "dispose", null);
(function(n) {
  n.View = go, n.Renderer = tx, n.MouseWheel = ex, n.DefsManager = qR, n.GridManager = Gw, n.CoordManager = WR, n.TransformManager = FR, n.HighlightManager = mm, n.BackgroundManager = Kw, n.PanningManager = Jw;
})(Pe || (Pe = {}));
(function(n) {
  n.toStringTag = `X6.${n.name}`;
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof n)
      return !0;
    const i = t[Symbol.toStringTag];
    return i == null || i === n.toStringTag;
  }
  n.isGraph = e;
})(Pe || (Pe = {}));
(function(n) {
  function e(t, i) {
    const r = t instanceof HTMLElement ? new n({ container: t }) : new n(t);
    return i != null && r.fromJSON(i), r;
  }
  n.render = e;
})(Pe || (Pe = {}));
(function(n) {
  n.registerNode = Tn.registry.register, n.registerEdge = xn.registry.register, n.registerView = An.registry.register, n.registerAttr = po.registry.register, n.registerGrid = ka.registry.register, n.registerFilter = Tu.registry.register, n.registerNodeTool = Ru.registry.register, n.registerEdgeTool = Nu.registry.register, n.registerBackground = qd.registry.register, n.registerHighlighter = Bo.registry.register, n.registerPortLayout = Ql.registry.register, n.registerPortLabelLayout = _u.registry.register, n.registerMarker = za.registry.register, n.registerRouter = Pa.registry.register, n.registerConnector = zl.registry.register, n.registerAnchor = Du.registry.register, n.registerEdgeAnchor = Lu.registry.register, n.registerConnectionPoint = Iu.registry.register;
})(Pe || (Pe = {}));
(function(n) {
  n.unregisterNode = Tn.registry.unregister, n.unregisterEdge = xn.registry.unregister, n.unregisterView = An.registry.unregister, n.unregisterAttr = po.registry.unregister, n.unregisterGrid = ka.registry.unregister, n.unregisterFilter = Tu.registry.unregister, n.unregisterNodeTool = Ru.registry.unregister, n.unregisterEdgeTool = Nu.registry.unregister, n.unregisterBackground = qd.registry.unregister, n.unregisterHighlighter = Bo.registry.unregister, n.unregisterPortLayout = Ql.registry.unregister, n.unregisterPortLabelLayout = _u.registry.unregister, n.unregisterMarker = za.registry.unregister, n.unregisterRouter = Pa.registry.unregister, n.unregisterConnector = zl.registry.unregister, n.unregisterAnchor = Du.registry.unregister, n.unregisterEdgeAnchor = Lu.registry.unregister, n.unregisterConnectionPoint = Iu.registry.unregister;
})(Pe || (Pe = {}));
var poe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}, goe = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class zu extends Tn {
}
(function(n) {
  class e extends $r {
    init() {
      super.init(), this.cell.on("change:*", this.onCellChangeAny, this);
    }
    onCellChangeAny({ key: i }) {
      const r = n.shapeMaps[this.cell.shape];
      if (r) {
        const { effect: s } = r;
        (!s || s.includes(i)) && this.renderHTMLComponent();
      }
    }
    confirmUpdate(i) {
      const r = super.confirmUpdate(i);
      return this.handleAction(r, e.action, () => this.renderHTMLComponent());
    }
    renderHTMLComponent() {
      const i = this.selectors && this.selectors.foContent;
      if (i) {
        Df(i);
        const r = n.shapeMaps[this.cell.shape];
        if (!r)
          return;
        let { html: s } = r;
        typeof s == "function" && (s = s(this.cell)), s && (typeof s == "string" ? i.innerHTML = s : Ja(i, s));
      }
    }
    dispose() {
      this.cell.off("change:*", this.onCellChangeAny, this);
    }
  }
  poe([
    e.dispose()
  ], e.prototype, "dispose", null), n.View = e, function(t) {
    t.action = "html", t.config({
      bootstrap: [t.action],
      actions: {
        html: t.action
      }
    }), $r.registry.register("html-view", t, !0);
  }(e = n.View || (n.View = {}));
})(zu || (zu = {}));
(function(n) {
  n.config({
    view: "html-view",
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      Object.assign({}, Yt.getForeignObjectMarkup()),
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    }
  }), Tn.registry.register("html", n, !0);
})(zu || (zu = {}));
(function(n) {
  n.shapeMaps = {};
  function e(t) {
    const { shape: i, html: r, effect: s, inherit: o } = t, a = goe(t, ["shape", "html", "effect", "inherit"]);
    if (!i)
      throw new Error("should specify shape in config");
    n.shapeMaps[i] = {
      html: r,
      effect: s
    }, Pe.registerNode(i, Object.assign({ inherit: o || "html" }, a), !0);
  }
  n.register = e;
})(zu || (zu = {}));
class Jk extends Tn {
}
(function(n) {
  function e(t) {
    const i = [], r = Yt.getForeignObjectMarkup();
    return t ? i.push({
      tagName: t,
      selector: "body"
    }, r) : i.push(r), i;
  }
  n.config({
    view: "vue-shape-view",
    markup: e(),
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    },
    propHooks(t) {
      if (t.markup == null) {
        const i = t.primer;
        if (i) {
          t.markup = e(i);
          let r = {};
          switch (i) {
            case "circle":
              r = {
                refCx: "50%",
                refCy: "50%",
                refR: "50%"
              };
              break;
            case "ellipse":
              r = {
                refCx: "50%",
                refCy: "50%",
                refRx: "50%",
                refRy: "50%"
              };
              break;
          }
          t.attrs = On({}, {
            body: Object.assign({ refWidth: null, refHeight: null }, r)
          }, t.attrs || {});
        }
      }
      return t;
    }
  }), Tn.registry.register("vue-shape", n, !0);
})(Jk || (Jk = {}));
var moe = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
const XR = {};
function lJe(n) {
  const { shape: e, component: t, inherit: i } = n, r = moe(n, ["shape", "component", "inherit"]);
  if (!e)
    throw new Error("should specify shape in config");
  XR[e] = {
    component: t
  }, Pe.registerNode(e, Object.assign({ inherit: i || "vue-shape" }, r), !0);
}
let Nv = !1;
const vm = Gt({});
function voe(n, e, t, i, r) {
  Nv && (vm[n] = BL(F({
    render: () => Re(tv, { to: t }, [Re(e, { node: i, graph: r })]),
    provide: () => ({
      getNode: () => i,
      getGraph: () => r
    })
  })));
}
function e2(n) {
  Nv && delete vm[n];
}
function t2() {
  return Nv;
}
function cJe() {
  return Nv = !0, F({
    setup() {
      return () => Re(Tt, {}, Object.keys(vm).map((n) => Re(vm[n])));
    }
  });
}
class bm extends $r {
  getComponentContainer() {
    return this.selectors && this.selectors.foContent;
  }
  confirmUpdate(e) {
    const t = super.confirmUpdate(e);
    return this.handleAction(t, bm.action, () => {
      this.renderVueComponent();
    });
  }
  targetId() {
    return `${this.graph.view.cid}:${this.cell.id}`;
  }
  renderVueComponent() {
    console.log("======renderVueComponent====>1"), this.unmountVueComponent();
    const e = this.getComponentContainer(), t = this.cell, i = this.graph;
    if (e) {
      const { component: r } = XR[t.shape];
      r && (t2() ? (e2(this.targetId()), voe(this.targetId(), r, e, t, i)) : (this.vm = QL({
        render() {
          return Re(r, { node: t, graph: i });
        },
        provide() {
          return {
            getNode: () => t,
            getGraph: () => i
          };
        }
      }), this.vm.mount(e)));
    }
  }
  unmountVueComponent() {
    const e = this.getComponentContainer();
    return this.vm && (this.vm.unmount(), this.vm = null), e && (e.innerHTML = ""), e;
  }
  onMouseDown(e, t, i) {
    const r = e.target;
    if (r.tagName.toLowerCase() === "input") {
      const o = r.getAttribute("type");
      if (o == null || [
        "text",
        "password",
        "number",
        "email",
        "search",
        "tel",
        "url"
      ].includes(o))
        return;
    }
    super.onMouseDown(e, t, i);
  }
  unmount() {
    return t2() && e2(this.targetId()), this.unmountVueComponent(), super.unmount(), this;
  }
}
(function(n) {
  n.action = "vue", n.config({
    bootstrap: [n.action],
    actions: {
      component: n.action
    }
  }), $r.registry.register("vue-shape-view", n, !0);
})(bm || (bm = {}));
const boe = `.x6-widget-dnd {
  position: absolute;
  top: -10000px;
  left: -10000px;
  z-index: 999999;
  display: none;
  cursor: move;
  opacity: 0.7;
  pointer-events: 'cursor';
}
.x6-widget-dnd.dragging {
  display: inline-block;
}
.x6-widget-dnd.dragging * {
  pointer-events: none !important;
}
.x6-widget-dnd .x6-graph {
  background: transparent;
  box-shadow: none;
}
`;
var yoe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class ju extends Rt {
  get targetScroller() {
    return this.options.target.getPlugin("scroller");
  }
  get targetGraph() {
    return this.options.target;
  }
  get targetModel() {
    return this.targetGraph.model;
  }
  get snapline() {
    return this.options.target.getPlugin("snapline");
  }
  constructor(e) {
    super(), this.name = "dnd", this.options = Object.assign(Object.assign({}, ju.defaults), e), this.init();
  }
  init() {
    kv(this.name, boe), this.container = document.createElement("div"), Ye(this.container, this.prefixClassName("widget-dnd")), this.draggingGraph = new Pe(Object.assign(Object.assign({}, this.options.delegateGraphOptions), { container: document.createElement("div"), width: 1, height: 1, async: !1 })), Ja(this.container, this.draggingGraph.container);
  }
  start(e, t) {
    const i = t;
    i.preventDefault(), this.targetModel.startBatch("dnd"), Ye(this.container, "dragging"), cd(this.container, this.options.draggingContainer || document.body), this.sourceNode = e, this.prepareDragging(e, i.clientX, i.clientY);
    const r = this.updateNodePosition(i.clientX, i.clientY);
    this.isSnaplineEnabled() && (this.snapline.captureCursorOffset({
      e: i,
      node: e,
      cell: e,
      view: this.draggingView,
      x: r.x,
      y: r.y
    }), this.draggingNode.on("change:position", this.snap, this)), this.delegateDocumentEvents(ju.documentEvents, i.data);
  }
  isSnaplineEnabled() {
    return this.snapline && this.snapline.isEnabled();
  }
  prepareDragging(e, t, i) {
    const r = this.draggingGraph, s = r.model, o = this.options.getDragNode(e, {
      sourceNode: e,
      draggingGraph: r,
      targetGraph: this.targetGraph
    });
    o.position(0, 0);
    let a = 5;
    if (this.isSnaplineEnabled() && (a += this.snapline.options.tolerance || 0), this.isSnaplineEnabled() || this.options.scaled) {
      const u = this.targetGraph.transform.getScale();
      r.scale(u.sx, u.sy), a *= Math.max(u.sx, u.sy);
    } else
      r.scale(1, 1);
    this.clearDragging(), s.resetCells([o]);
    const l = r.findViewByCell(o);
    l.undelegateEvents(), l.cell.off("changed"), r.fitToContent({
      padding: a,
      allowNewOrigin: "any",
      useCellGeometry: !1
    });
    const c = l.getBBox();
    this.geometryBBox = l.getBBox({ useCellGeometry: !0 }), this.delta = this.geometryBBox.getTopLeft().diff(c.getTopLeft()), this.draggingNode = o, this.draggingView = l, this.draggingBBox = o.getBBox(), this.padding = a, this.originOffset = this.updateGraphPosition(t, i);
  }
  updateGraphPosition(e, t) {
    const i = document.body.scrollTop || document.documentElement.scrollTop, r = document.body.scrollLeft || document.documentElement.scrollLeft, s = this.delta, o = this.geometryBBox, a = this.padding || 5, l = {
      left: e - s.x - o.width / 2 - a + r,
      top: t - s.y - o.height / 2 - a + i
    };
    return this.draggingGraph && qn(this.container, {
      left: `${l.left}px`,
      top: `${l.top}px`
    }), l;
  }
  updateNodePosition(e, t) {
    const i = this.targetGraph.clientToLocal(e, t), r = this.draggingBBox;
    return i.x -= r.width / 2, i.y -= r.height / 2, this.draggingNode.position(i.x, i.y), i;
  }
  snap({ cell: e, current: t, options: i }) {
    const r = e;
    if (i.snapped) {
      const s = this.draggingBBox;
      r.position(s.x + i.tx, s.y + i.ty, { silent: !0 }), this.draggingView.translate(), r.position(t.x, t.y, { silent: !0 }), this.snapOffset = {
        x: i.tx,
        y: i.ty
      };
    } else
      this.snapOffset = null;
  }
  onDragging(e) {
    const t = this.draggingView;
    if (t) {
      e.preventDefault();
      const i = this.normalizeEvent(e), r = i.clientX, s = i.clientY;
      this.updateGraphPosition(r, s);
      const o = this.updateNodePosition(r, s), a = this.targetGraph.options.embedding.enabled, l = (a || this.isSnaplineEnabled()) && this.isInsideValidArea({
        x: r,
        y: s
      });
      if (a) {
        t.setEventData(i, {
          graph: this.targetGraph,
          candidateEmbedView: this.candidateEmbedView
        });
        const c = t.getEventData(i);
        l ? t.processEmbedding(i, c) : t.clearEmbedding(c), this.candidateEmbedView = c.candidateEmbedView;
      }
      this.isSnaplineEnabled() && (l ? this.snapline.snapOnMoving({
        e: i,
        view: t,
        x: o.x,
        y: o.y
      }) : this.snapline.hide());
    }
  }
  onDragEnd(e) {
    const t = this.draggingNode;
    if (t) {
      const i = this.normalizeEvent(e), r = this.draggingView, s = this.draggingBBox, o = this.snapOffset;
      let a = s.x, l = s.y;
      o && (a += o.x, l += o.y), t.position(a, l, { silent: !0 });
      const c = this.drop(t, { x: i.clientX, y: i.clientY }), u = (h) => {
        h ? (this.onDropped(t), this.targetGraph.options.embedding.enabled && r && (r.setEventData(i, {
          cell: h,
          graph: this.targetGraph,
          candidateEmbedView: this.candidateEmbedView
        }), r.finalizeEmbedding(i, r.getEventData(i)))) : this.onDropInvalid(), this.candidateEmbedView = null, this.targetModel.stopBatch("dnd");
      };
      jy(c) ? (this.undelegateDocumentEvents(), c.then(u)) : u(c);
    }
  }
  clearDragging() {
    this.draggingNode && (this.sourceNode = null, this.draggingNode.remove(), this.draggingNode = null, this.draggingView = null, this.delta = null, this.padding = null, this.snapOffset = null, this.originOffset = null, this.undelegateDocumentEvents());
  }
  onDropped(e) {
    this.draggingNode === e && (this.clearDragging(), Nn(this.container, "dragging"), ro(this.container));
  }
  onDropInvalid() {
    const e = this.draggingNode;
    e && this.onDropped(e);
  }
  isInsideValidArea(e) {
    let t, i = null;
    const r = this.targetGraph, s = this.targetScroller;
    this.options.dndContainer && (i = this.getDropArea(this.options.dndContainer));
    const o = i && i.containsPoint(e);
    if (s)
      if (s.options.autoResize)
        t = this.getDropArea(s.container);
      else {
        const a = this.getDropArea(s.container);
        t = this.getDropArea(r.container).intersectsWithRect(a);
      }
    else
      t = this.getDropArea(r.container);
    return !o && t && t.containsPoint(e);
  }
  getDropArea(e) {
    const t = Hy(e), i = document.body.scrollTop || document.documentElement.scrollTop, r = document.body.scrollLeft || document.documentElement.scrollLeft;
    return ye.create({
      x: t.left + parseInt(qn(e, "border-left-width"), 10) - r,
      y: t.top + parseInt(qn(e, "border-top-width"), 10) - i,
      width: e.clientWidth,
      height: e.clientHeight
    });
  }
  drop(e, t) {
    if (this.isInsideValidArea(t)) {
      const i = this.targetGraph, r = i.model, s = i.clientToLocal(t), o = this.sourceNode, a = this.options.getDropNode(e, {
        sourceNode: o,
        draggingNode: e,
        targetGraph: this.targetGraph,
        draggingGraph: this.draggingGraph
      }), l = a.getBBox();
      s.x += l.x - l.width / 2, s.y += l.y - l.height / 2;
      const c = this.snapOffset ? 1 : i.getGridSize();
      a.position(At.snapToGrid(s.x, c), At.snapToGrid(s.y, c)), a.removeZIndex();
      const u = this.options.validateNode, h = u ? u(a, {
        sourceNode: o,
        draggingNode: e,
        droppingNode: a,
        targetGraph: i,
        draggingGraph: this.draggingGraph
      }) : !0;
      return typeof h == "boolean" ? h ? (r.addCell(a, { stencil: this.cid }), a) : null : cte(h).then((d) => d ? (r.addCell(a, { stencil: this.cid }), a) : null);
    }
    return null;
  }
  onRemove() {
    this.draggingGraph && (this.draggingGraph.view.remove(), this.draggingGraph.dispose());
  }
  dispose() {
    this.remove(), Pv(this.name);
  }
}
yoe([
  Rt.dispose()
], ju.prototype, "dispose", null);
(function(n) {
  n.defaults = {
    // animation: false,
    getDragNode: (e) => e.clone(),
    getDropNode: (e) => e.clone()
  }, n.documentEvents = {
    mousemove: "onDragging",
    touchmove: "onDragging",
    mouseup: "onDragEnd",
    touchend: "onDragEnd",
    touchcancel: "onDragEnd"
  };
})(ju || (ju = {}));
var Ooe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class YR extends Rt {
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.renderer.findViewByCell(this.node);
  }
  get containerClassName() {
    return this.prefixClassName("widget-transform");
  }
  get resizeClassName() {
    return `${this.containerClassName}-resize`;
  }
  get rotateClassName() {
    return `${this.containerClassName}-rotate`;
  }
  constructor(e, t, i) {
    super(), this.node = t, this.graph = i, this.options = Object.assign(Object.assign({}, jn.defaultOptions), e), this.render(), this.startListening();
  }
  startListening() {
    this.delegateEvents({
      [`mousedown .${this.resizeClassName}`]: "startResizing",
      [`touchstart .${this.resizeClassName}`]: "startResizing",
      [`mousedown .${this.rotateClassName}`]: "startRotating",
      [`touchstart .${this.rotateClassName}`]: "startRotating"
    }), this.model.on("*", this.update, this), this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this), this.node.on("removed", this.remove, this), this.model.on("reseted", this.remove, this), this.view.on("cell:knob:mousedown", this.onKnobMouseDown, this), this.view.on("cell:knob:mouseup", this.onKnobMouseUp, this);
  }
  stopListening() {
    this.undelegateEvents(), this.model.off("*", this.update, this), this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this), this.node.off("removed", this.remove, this), this.model.off("reseted", this.remove, this), this.view.off("cell:knob:mousedown", this.onKnobMouseDown, this), this.view.off("cell:knob:mouseup", this.onKnobMouseUp, this);
  }
  renderHandles() {
    this.container = document.createElement("div");
    const e = document.createElement("div");
    St(e, "draggable", "false");
    const t = e.cloneNode(!0);
    Ye(t, this.rotateClassName);
    const i = jn.POSITIONS.map((r) => {
      const s = e.cloneNode(!0);
      return Ye(s, this.resizeClassName), St(s, "data-position", r), s;
    });
    this.empty(), Ja(this.container, [...i, t]);
  }
  render() {
    return this.renderHandles(), this.view && this.view.addClass(jn.NODE_CLS), Ye(this.container, this.containerClassName), ld(this.container, "no-orth-resize", this.options.preserveAspectRatio || !this.options.orthogonalResizing), ld(this.container, "no-resize", !this.options.resizable), ld(this.container, "no-rotate", !this.options.rotatable), this.options.className && Ye(this.container, this.options.className), this.graph.container.appendChild(this.container), this.update();
  }
  update() {
    const e = this.graph.matrix(), t = this.node.getBBox();
    t.x *= e.a, t.x += e.e, t.y *= e.d, t.y += e.f, t.width *= e.a, t.height *= e.d;
    const i = Pt.normalize(this.node.getAngle()), r = i !== 0 ? `rotate(${i}deg)` : "";
    return qn(this.container, {
      transform: r,
      width: t.width,
      height: t.height,
      left: t.x,
      top: t.y
    }), this.updateResizerDirections(), this;
  }
  remove() {
    return this.view && this.view.removeClass(jn.NODE_CLS), super.remove();
  }
  onKnobMouseDown() {
    this.startHandle();
  }
  onKnobMouseUp() {
    this.stopHandle();
  }
  updateResizerDirections() {
    const e = Pt.normalize(this.node.getAngle()), t = Math.floor(e * (jn.DIRECTIONS.length / 360));
    if (t !== this.prevShift) {
      const i = jn.DIRECTIONS.slice(t).concat(jn.DIRECTIONS.slice(0, t)), r = (o) => `${this.containerClassName}-cursor-${o}`;
      this.container.querySelectorAll(`.${this.resizeClassName}`).forEach((o, a) => {
        Nn(o, jn.DIRECTIONS.map((l) => r(l)).join(" ")), Ye(o, r(i[a]));
      }), this.prevShift = t;
    }
  }
  getTrueDirection(e) {
    const t = Pt.normalize(this.node.getAngle());
    let i = jn.POSITIONS.indexOf(e);
    return i += Math.floor(t * (jn.POSITIONS.length / 360)), i %= jn.POSITIONS.length, jn.POSITIONS[i];
  }
  toValidResizeDirection(e) {
    return {
      top: "top-left",
      bottom: "bottom-right",
      left: "bottom-left",
      right: "top-right"
    }[e] || e;
  }
  startResizing(e) {
    e.stopPropagation(), this.model.startBatch("resize", { cid: this.cid });
    const t = St(e.target, "data-position");
    this.prepareResizing(e, t), this.startAction(e);
  }
  prepareResizing(e, t) {
    const i = this.getTrueDirection(t);
    let r = 0, s = 0;
    t.split("-").forEach((c) => {
      r = { left: -1, right: 1 }[c] || r, s = { top: -1, bottom: 1 }[c] || s;
    });
    const o = this.toValidResizeDirection(t), a = {
      "top-right": "bottomLeft",
      "top-left": "bottomRight",
      "bottom-left": "topRight",
      "bottom-right": "topLeft"
    }[o], l = Pt.normalize(this.node.getAngle());
    this.setEventData(e, {
      selector: a,
      direction: o,
      trueDirection: i,
      relativeDirection: t,
      angle: l,
      resizeX: r,
      resizeY: s,
      action: "resizing"
    });
  }
  startRotating(e) {
    e.stopPropagation(), this.model.startBatch("rotate", { cid: this.cid });
    const t = this.node.getBBox().getCenter(), i = this.normalizeEvent(e), r = this.graph.snapToGrid(i.clientX, i.clientY);
    this.setEventData(e, {
      center: t,
      action: "rotating",
      angle: Pt.normalize(this.node.getAngle()),
      start: z.create(r).theta(t)
    }), this.startAction(e);
  }
  onMouseMove(e) {
    const t = this.graph.findViewByCell(this.node);
    let i = this.getEventData(e);
    if (i.action) {
      const r = this.normalizeEvent(e);
      let s = r.clientX, o = r.clientY;
      const a = this.graph.getPlugin("scroller"), l = this.options.restrictedResizing;
      if (l === !0 || typeof l == "number") {
        const f = l === !0 ? 0 : l, p = a ? Math.max(f, 8) : f, g = this.graph.container.getBoundingClientRect();
        s = rr(s, g.left + p, g.right - p), o = rr(o, g.top + p, g.bottom - p);
      } else
        this.options.autoScrollOnResizing && a && a.autoScroll(s, o);
      const c = this.graph.snapToGrid(s, o), u = this.graph.getGridSize(), h = this.node, d = this.options;
      if (i.action === "resizing") {
        i = i, i.resized || (t && (t.addClass("node-resizing"), this.notify("node:resize", e, t)), i.resized = !0);
        const f = h.getBBox(), p = z.create(c).rotate(i.angle, f.getCenter()).diff(f[i.selector]);
        let g = i.resizeX ? p.x * i.resizeX : f.width, m = i.resizeY ? p.y * i.resizeY : f.height;
        const v = g, y = m;
        if (g = At.snapToGrid(g, u), m = At.snapToGrid(m, u), g = Math.max(g, d.minWidth || u), m = Math.max(m, d.minHeight || u), g = Math.min(g, d.maxWidth || 1 / 0), m = Math.min(m, d.maxHeight || 1 / 0), d.preserveAspectRatio) {
          const w = f.width * m / f.height, x = f.height * g / f.width;
          g < w ? m = x : g = w;
        }
        const b = i.relativeDirection;
        if (d.allowReverse && (v <= -g || y <= -m)) {
          let w;
          b === "left" ? v <= -g && (w = "right") : b === "right" ? v <= -g && (w = "left") : b === "top" ? y <= -m && (w = "bottom") : b === "bottom" ? y <= -m && (w = "top") : b === "top-left" ? v <= -g && y <= -m ? w = "bottom-right" : v <= -g ? w = "top-right" : y <= -m && (w = "bottom-left") : b === "top-right" ? v <= -g && y <= -m ? w = "bottom-left" : v <= -g ? w = "top-left" : y <= -m && (w = "bottom-right") : b === "bottom-left" ? v <= -g && y <= -m ? w = "top-right" : v <= -g ? w = "bottom-right" : y <= -m && (w = "top-left") : b === "bottom-right" && (v <= -g && y <= -m ? w = "top-left" : v <= -g ? w = "bottom-left" : y <= -m && (w = "top-right"));
          const x = w;
          this.stopHandle();
          const S = this.container.querySelector(`.${this.resizeClassName}[data-position="${x}"]`);
          this.startHandle(S), this.prepareResizing(e, x), this.onMouseMove(e);
        }
        if (f.width !== g || f.height !== m) {
          const w = {
            ui: !0,
            direction: i.direction,
            relativeDirection: i.relativeDirection,
            trueDirection: i.trueDirection,
            minWidth: d.minWidth,
            minHeight: d.minHeight,
            maxWidth: d.maxWidth,
            maxHeight: d.maxHeight,
            preserveAspectRatio: d.preserveAspectRatio === !0
          };
          h.resize(g, m, w), this.notify("node:resizing", e, t);
        }
      } else if (i.action === "rotating") {
        i = i, i.rotated || (t && (t.addClass("node-rotating"), this.notify("node:rotate", e, t)), i.rotated = !0);
        const f = h.getAngle(), p = i.start - z.create(c).theta(i.center);
        let g = i.angle + p;
        d.rotateGrid && (g = At.snapToGrid(g, d.rotateGrid)), g = Pt.normalize(g), f !== g && (h.rotate(g, { absolute: !0 }), this.notify("node:rotating", e, t));
      }
    }
  }
  onMouseUp(e) {
    const t = this.getEventData(e);
    t.action && (this.stopAction(e), this.model.stopBatch(t.action === "resizing" ? "resize" : "rotate", {
      cid: this.cid
    }));
  }
  startHandle(e) {
    if (this.handle = e || null, Ye(this.container, `${this.containerClassName}-active`), e) {
      Ye(e, `${this.containerClassName}-active-handle`);
      const t = e.getAttribute("data-position");
      if (t) {
        const i = jn.DIRECTIONS[jn.POSITIONS.indexOf(t)];
        Ye(this.container, `${this.containerClassName}-cursor-${i}`);
      }
    }
  }
  stopHandle() {
    if (Nn(this.container, `${this.containerClassName}-active`), this.handle) {
      Nn(this.handle, `${this.containerClassName}-active-handle`);
      const e = this.handle.getAttribute("data-position");
      if (e) {
        const t = jn.DIRECTIONS[jn.POSITIONS.indexOf(e)];
        Nn(this.container, `${this.containerClassName}-cursor-${t}`);
      }
      this.handle = null;
    }
  }
  startAction(e) {
    this.startHandle(e.target), this.graph.view.undelegateEvents(), this.delegateDocumentEvents(jn.documentEvents, e.data);
  }
  stopAction(e) {
    this.stopHandle(), this.undelegateDocumentEvents(), this.graph.view.delegateEvents();
    const t = this.graph.findViewByCell(this.node), i = this.getEventData(e);
    t && (t.removeClass(`node-${i.action}`), i.action === "resizing" && i.resized ? this.notify("node:resized", e, t) : i.action === "rotating" && i.rotated && this.notify("node:rotated", e, t));
  }
  notify(e, t, i, r = {}) {
    if (i) {
      const s = i.graph, o = s.view.normalizeEvent(t), a = s.snapToGrid(o.clientX, o.clientY);
      this.trigger(e, Object.assign({
        e: o,
        view: i,
        node: i.cell,
        cell: i.cell,
        x: a.x,
        y: a.y
      }, r));
    }
  }
  dispose() {
    this.stopListening(), this.remove(), this.off();
  }
}
Ooe([
  Rt.dispose()
], YR.prototype, "dispose", null);
var jn;
(function(n) {
  n.NODE_CLS = "has-widget-transform", n.DIRECTIONS = ["nw", "n", "ne", "e", "se", "s", "sw", "w"], n.POSITIONS = [
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ], n.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp"
  }, n.defaultOptions = {
    minWidth: 0,
    minHeight: 0,
    maxWidth: 1 / 0,
    maxHeight: 1 / 0,
    rotateGrid: 15,
    rotatable: !0,
    preserveAspectRatio: !1,
    orthogonalResizing: !0,
    restrictedResizing: !1,
    autoScrollOnResizing: !0,
    allowReverse: !0
  };
})(jn || (jn = {}));
const woe = `.x6-widget-transform {
  position: absolute;
  box-sizing: content-box !important;
  margin: -5px 0 0 -5px;
  padding: 4px;
  border: 1px dashed #000;
  border-radius: 5px;
  user-select: none;
  pointer-events: none;
}
.x6-widget-transform > div {
  position: absolute;
  box-sizing: border-box;
  background-color: #fff;
  border: 1px solid #000;
  transition: background-color 0.2s;
  pointer-events: auto;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-transform > div:hover {
  background-color: #d3d3d3;
}
.x6-widget-transform-cursor-n {
  cursor: n-resize;
}
.x6-widget-transform-cursor-s {
  cursor: s-resize;
}
.x6-widget-transform-cursor-e {
  cursor: e-resize;
}
.x6-widget-transform-cursor-w {
  cursor: w-resize;
}
.x6-widget-transform-cursor-ne {
  cursor: ne-resize;
}
.x6-widget-transform-cursor-nw {
  cursor: nw-resize;
}
.x6-widget-transform-cursor-se {
  cursor: se-resize;
}
.x6-widget-transform-cursor-sw {
  cursor: sw-resize;
}
.x6-widget-transform-resize {
  width: 10px;
  height: 10px;
  border-radius: 6px;
}
.x6-widget-transform-resize[data-position='top-left'] {
  top: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='top-right'] {
  top: -5px;
  right: -5px;
}
.x6-widget-transform-resize[data-position='bottom-left'] {
  bottom: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='bottom-right'] {
  right: -5px;
  bottom: -5px;
}
.x6-widget-transform-resize[data-position='top'] {
  top: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='bottom'] {
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='left'] {
  top: 50%;
  left: -5px;
  margin-top: -5px;
}
.x6-widget-transform-resize[data-position='right'] {
  top: 50%;
  right: -5px;
  margin-top: -5px;
}
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='top'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='right'] {
  display: none;
}
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='right'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='top'] {
  display: none;
}
.x6-widget-transform.no-resize .x6-widget-transform-resize {
  display: none;
}
.x6-widget-transform-rotate {
  top: -20px;
  left: -20px;
  width: 12px;
  height: 12px;
  border-radius: 6px;
  cursor: crosshair;
}
.x6-widget-transform.no-rotate .x6-widget-transform-rotate {
  display: none;
}
.x6-widget-transform-active {
  border-color: transparent;
  pointer-events: all;
}
.x6-widget-transform-active > div {
  display: none;
}
.x6-widget-transform-active > .x6-widget-transform-active-handle {
  display: block;
  background-color: #808080;
}
`;
Pe.prototype.createTransformWidget = function(n) {
  const e = this.getPlugin("transform");
  return e && e.createWidget(n), this;
};
Pe.prototype.clearTransformWidgets = function() {
  const n = this.getPlugin("transform");
  return n && n.clearWidgets(), this;
};
var xoe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Vu extends gn {
  constructor(e = {}) {
    super(), this.name = "transform", this.widgets = /* @__PURE__ */ new Map(), this.disabled = !1, this.options = e, kv(this.name, woe);
  }
  init(e) {
    this.graph = e, !this.disabled && this.startListening();
  }
  startListening() {
    this.graph.on("node:click", this.onNodeClick, this), this.graph.on("blank:mousedown", this.onBlankMouseDown, this);
  }
  stopListening() {
    this.graph.off("node:click", this.onNodeClick, this), this.graph.off("blank:mousedown", this.onBlankMouseDown, this);
  }
  enable() {
    this.disabled && (this.disabled = !1, this.startListening());
  }
  disable() {
    this.disabled || (this.disabled = !0, this.stopListening());
  }
  isEnabled() {
    return !this.disabled;
  }
  createWidget(e) {
    this.clearWidgets();
    const t = this.createTransform(e);
    t && (this.widgets.set(e, t), t.on("*", (i, r) => {
      this.trigger(i, r), this.graph.trigger(i, r);
    }));
  }
  onNodeClick({ node: e }) {
    this.createWidget(e);
  }
  onBlankMouseDown() {
    this.clearWidgets();
  }
  createTransform(e) {
    const t = this.getTransformOptions(e);
    return t.resizable || t.rotatable ? new YR(t, e, this.graph) : null;
  }
  getTransformOptions(e) {
    this.options.resizing || (this.options.resizing = {
      enabled: !1
    }), this.options.rotating || (this.options.rotating = {
      enabled: !1
    }), typeof this.options.resizing == "boolean" && (this.options.resizing = {
      enabled: this.options.resizing
    }), typeof this.options.rotating == "boolean" && (this.options.rotating = {
      enabled: this.options.rotating
    });
    const t = Vu.parseOptionGroup(this.graph, e, this.options.resizing), i = Vu.parseOptionGroup(this.graph, e, this.options.rotating);
    return {
      resizable: !!t.enabled,
      minWidth: t.minWidth || 0,
      maxWidth: t.maxWidth || Number.MAX_SAFE_INTEGER,
      minHeight: t.minHeight || 0,
      maxHeight: t.maxHeight || Number.MAX_SAFE_INTEGER,
      orthogonalResizing: typeof t.orthogonal == "boolean" ? t.orthogonal : !0,
      restrictedResizing: !!t.restrict,
      autoScrollOnResizing: typeof t.autoScroll == "boolean" ? t.autoScroll : !0,
      preserveAspectRatio: !!t.preserveAspectRatio,
      allowReverse: typeof t.allowReverse == "boolean" ? t.allowReverse : !0,
      rotatable: !!i.enabled,
      rotateGrid: i.grid || 15
    };
  }
  clearWidgets() {
    this.widgets.forEach((e, t) => {
      this.graph.getCellById(t.id) && e.dispose();
    }), this.widgets.clear();
  }
  dispose() {
    this.clearWidgets(), this.stopListening(), this.off(), Pv(this.name);
  }
}
xoe([
  gn.dispose()
], Vu.prototype, "dispose", null);
(function(n) {
  function e(t, i, r) {
    const s = {};
    return Object.keys(r || {}).forEach((o) => {
      const a = r[o];
      s[o] = typeof a == "function" ? a.call(t, i) : a;
    }), s;
  }
  n.parseOptionGroup = e;
})(Vu || (Vu = {}));
var Soe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class UR extends Rt {
  get graph() {
    return this.options.graph;
  }
  get boxClassName() {
    return this.prefixClassName(er.classNames.box);
  }
  get $boxes() {
    return Cte(this.container, this.boxClassName);
  }
  get handleOptions() {
    return this.options;
  }
  constructor(e) {
    super(), this.options = e, this.options.model && (this.options.collection = this.options.model.collection), this.options.collection ? this.collection = this.options.collection : (this.collection = new gm([], {
      comparator: er.depthComparator
    }), this.options.collection = this.collection), this.boxCount = 0, this.createContainer(), this.startListening();
  }
  startListening() {
    const e = this.graph, t = this.collection;
    this.delegateEvents({
      [`mousedown .${this.boxClassName}`]: "onSelectionBoxMouseDown",
      [`touchstart .${this.boxClassName}`]: "onSelectionBoxMouseDown"
    }, !0), e.on("scale", this.onGraphTransformed, this), e.on("translate", this.onGraphTransformed, this), e.model.on("updated", this.onModelUpdated, this), t.on("added", this.onCellAdded, this), t.on("removed", this.onCellRemoved, this), t.on("reseted", this.onReseted, this), t.on("updated", this.onCollectionUpdated, this), t.on("node:change:position", this.onNodePositionChanged, this), t.on("cell:changed", this.onCellChanged, this);
  }
  stopListening() {
    const e = this.graph, t = this.collection;
    this.undelegateEvents(), e.off("scale", this.onGraphTransformed, this), e.off("translate", this.onGraphTransformed, this), e.model.off("updated", this.onModelUpdated, this), t.off("added", this.onCellAdded, this), t.off("removed", this.onCellRemoved, this), t.off("reseted", this.onReseted, this), t.off("updated", this.onCollectionUpdated, this), t.off("node:change:position", this.onNodePositionChanged, this), t.off("cell:changed", this.onCellChanged, this);
  }
  onRemove() {
    this.stopListening();
  }
  onGraphTransformed() {
    this.updateSelectionBoxes();
  }
  onCellChanged() {
    this.updateSelectionBoxes();
  }
  onNodePositionChanged({ node: e, options: t }) {
    const { showNodeSelectionBox: i, pointerEvents: r } = this.options, { ui: s, selection: o, translateBy: a, snapped: l } = t, c = (i !== !0 || r && this.getPointerEventsValue(r) === "none") && !this.translating && !o, u = s && a && e.id === a;
    if (c && (u || l)) {
      this.translating = !0;
      const h = e.position(), d = e.previous("position"), f = h.x - d.x, p = h.y - d.y;
      (f !== 0 || p !== 0) && this.translateSelectedNodes(f, p, e, t), this.translating = !1;
    }
  }
  onModelUpdated({ removed: e }) {
    e && e.length && this.unselect(e);
  }
  isEmpty() {
    return this.length <= 0;
  }
  isSelected(e) {
    return this.collection.has(e);
  }
  get length() {
    return this.collection.length;
  }
  get cells() {
    return this.collection.toArray();
  }
  select(e, t = {}) {
    t.dryrun = !0;
    const i = this.filter(Array.isArray(e) ? e : [e]);
    return this.collection.add(i, t), this;
  }
  unselect(e, t = {}) {
    return t.dryrun = !0, this.collection.remove(Array.isArray(e) ? e : [e], t), this;
  }
  reset(e, t = {}) {
    if (e) {
      if (t.batch) {
        const c = this.filter(Array.isArray(e) ? e : [e]);
        return this.collection.reset(c, Object.assign(Object.assign({}, t), { ui: !0 })), this;
      }
      const i = this.cells, r = this.filter(Array.isArray(e) ? e : [e]), s = {}, o = {};
      i.forEach((c) => s[c.id] = c), r.forEach((c) => o[c.id] = c);
      const a = [], l = [];
      return r.forEach((c) => {
        s[c.id] || a.push(c);
      }), i.forEach((c) => {
        o[c.id] || l.push(c);
      }), l.length && this.unselect(l, Object.assign(Object.assign({}, t), { ui: !0 })), a.length && this.select(a, Object.assign(Object.assign({}, t), { ui: !0 })), l.length === 0 && a.length === 0 && this.updateContainer(), this;
    }
    return this.clean(t);
  }
  clean(e = {}) {
    return this.length && (e.batch === !1 ? this.unselect(this.cells, e) : this.collection.reset([], Object.assign(Object.assign({}, e), { ui: !0 }))), this;
  }
  setFilter(e) {
    this.options.filter = e;
  }
  setContent(e) {
    this.options.content = e;
  }
  startSelecting(e) {
    e = this.normalizeEvent(e), this.clean();
    let t, i;
    const r = this.graph.container;
    if (e.offsetX != null && e.offsetY != null && r.contains(e.target))
      t = e.offsetX, i = e.offsetY;
    else {
      const s = Hy(r), o = r.scrollLeft, a = r.scrollTop;
      t = e.clientX - s.left + window.pageXOffset + o, i = e.clientY - s.top + window.pageYOffset + a;
    }
    qn(this.container, {
      top: i,
      left: t,
      width: 1,
      height: 1
    }), this.setEventData(e, {
      action: "selecting",
      clientX: e.clientX,
      clientY: e.clientY,
      offsetX: t,
      offsetY: i,
      scrollerX: 0,
      scrollerY: 0,
      moving: !1
    }), this.delegateDocumentEvents(er.documentEvents, e.data);
  }
  filter(e) {
    const t = this.options.filter;
    return e.filter((i) => Array.isArray(t) ? t.some((r) => typeof r == "string" ? i.shape === r : i.id === r.id) : typeof t == "function" ? Ze(t, this.graph, i) : !0);
  }
  stopSelecting(e) {
    const t = this.graph, i = this.getEventData(e);
    switch (i.action) {
      case "selecting": {
        let s = sne(this.container), o = one(this.container);
        const a = Hy(this.container), l = t.pageToLocal(a.left, a.top), c = t.transform.getScale();
        s /= c.sx, o /= c.sy;
        const u = new ye(l.x, l.y, s, o), h = this.getCellViewsInArea(u).map((d) => d.cell);
        this.reset(h, { batch: !0 }), this.hideRubberband();
        break;
      }
      case "translating": {
        const s = t.snapToGrid(e.clientX, e.clientY);
        if (!this.options.following) {
          const o = i;
          this.updateSelectedNodesPosition({
            dx: o.clientX - o.originX,
            dy: o.clientY - o.originY
          });
        }
        this.graph.model.stopBatch("move-selection"), this.notifyBoxEvent("box:mouseup", e, s.x, s.y);
        break;
      }
      default: {
        this.clean();
        break;
      }
    }
  }
  onMouseUp(e) {
    this.getEventData(e).action && (this.stopSelecting(e), this.undelegateDocumentEvents());
  }
  onSelectionBoxMouseDown(e) {
    this.options.following || e.stopPropagation();
    const t = this.normalizeEvent(e);
    this.options.movable && this.startTranslating(t);
    const i = this.getCellViewFromElem(t.target);
    this.setEventData(t, { activeView: i });
    const r = this.graph.snapToGrid(t.clientX, t.clientY);
    this.notifyBoxEvent("box:mousedown", t, r.x, r.y), this.delegateDocumentEvents(er.documentEvents, t.data);
  }
  startTranslating(e) {
    this.graph.model.startBatch("move-selection");
    const t = this.graph.snapToGrid(e.clientX, e.clientY);
    this.setEventData(e, {
      action: "translating",
      clientX: t.x,
      clientY: t.y,
      originX: t.x,
      originY: t.y
    });
  }
  getRestrictArea() {
    const e = this.graph.options.translating.restrict, t = typeof e == "function" ? Ze(e, this.graph, null) : e;
    return typeof t == "number" ? this.graph.transform.getGraphArea().inflate(t) : t === !0 ? this.graph.transform.getGraphArea() : t || null;
  }
  getSelectionOffset(e, t) {
    let i = e.x - t.clientX, r = e.y - t.clientY;
    const s = this.getRestrictArea();
    if (s) {
      const o = this.collection.toArray(), a = gt.getCellsBBox(o, { deep: !0 }) || ye.create(), l = s.x - a.x, c = s.y - a.y, u = s.x + s.width - (a.x + a.width), h = s.y + s.height - (a.y + a.height);
      if (i < l && (i = l), r < c && (r = c), u < i && (i = u), h < r && (r = h), !this.options.following) {
        const d = e.x - t.originX, f = e.y - t.originY;
        i = d <= l || d >= u ? 0 : i, r = f <= c || f >= h ? 0 : r;
      }
    }
    return {
      dx: i,
      dy: r
    };
  }
  updateElementPosition(e, t, i) {
    const r = qn(e, "left"), s = qn(e, "top"), o = r ? parseFloat(r) : 0, a = s ? parseFloat(s) : 0;
    qn(e, "left", o + t), qn(e, "top", a + i);
  }
  updateSelectedNodesPosition(e) {
    const { dx: t, dy: i } = e;
    if (t || i)
      if (this.translateSelectedNodes(t, i), this.boxesUpdated)
        this.collection.length > 1 && this.updateSelectionBoxes();
      else {
        const r = this.graph.transform.getScale();
        for (let s = 0, o = this.$boxes, a = o.length; s < a; s += 1)
          this.updateElementPosition(o[s], t * r.sx, i * r.sy);
        this.updateElementPosition(this.selectionContainer, t * r.sx, i * r.sy);
      }
  }
  autoScrollGraph(e, t) {
    const i = this.graph.getPlugin("scroller");
    return i ? i.autoScroll(e, t) : { scrollerX: 0, scrollerY: 0 };
  }
  adjustSelection(e) {
    const t = this.normalizeEvent(e), i = this.getEventData(t);
    switch (i.action) {
      case "selecting": {
        const s = i;
        s.moving !== !0 && (cd(this.container, this.graph.container), this.showRubberband(), s.moving = !0);
        const { scrollerX: o, scrollerY: a } = this.autoScrollGraph(t.clientX, t.clientY);
        s.scrollerX += o, s.scrollerY += a;
        const l = t.clientX - s.clientX + s.scrollerX, c = t.clientY - s.clientY + s.scrollerY, u = parseInt(qn(this.container, "left") || "0", 10), h = parseInt(qn(this.container, "top") || "0", 10);
        qn(this.container, {
          left: l < 0 ? s.offsetX + l : u,
          top: c < 0 ? s.offsetY + c : h,
          width: Math.abs(l),
          height: Math.abs(c)
        });
        break;
      }
      case "translating": {
        const s = this.graph.snapToGrid(t.clientX, t.clientY), o = i, a = this.getSelectionOffset(s, o);
        this.options.following ? this.updateSelectedNodesPosition(a) : this.updateContainerPosition(a), a.dx && (o.clientX = s.x), a.dy && (o.clientY = s.y), this.notifyBoxEvent("box:mousemove", e, s.x, s.y);
        break;
      }
    }
    this.boxesUpdated = !1;
  }
  translateSelectedNodes(e, t, i, r) {
    const s = {}, o = [];
    if (i && (s[i.id] = !0), this.collection.toArray().forEach((a) => {
      a.getDescendants({ deep: !0 }).forEach((l) => {
        s[l.id] = !0;
      });
    }), r && r.translateBy) {
      const a = this.graph.getCellById(r.translateBy);
      a && (s[a.id] = !0, a.getDescendants({ deep: !0 }).forEach((l) => {
        s[l.id] = !0;
      }), o.push(a));
    }
    this.collection.toArray().forEach((a) => {
      if (!s[a.id]) {
        const l = Object.assign(Object.assign({}, r), { selection: this.cid, exclude: o });
        a.translate(e, t, l), this.graph.model.getConnectedEdges(a).forEach((c) => {
          s[c.id] || (c.translate(e, t, l), s[c.id] = !0);
        });
      }
    });
  }
  getCellViewsInArea(e) {
    const t = this.graph, i = {
      strict: this.options.strict
    };
    let r = [];
    return this.options.rubberNode && (r = r.concat(t.model.getNodesInArea(e, i).map((s) => t.renderer.findViewByCell(s)).filter((s) => s != null))), this.options.rubberEdge && (r = r.concat(t.model.getEdgesInArea(e, i).map((s) => t.renderer.findViewByCell(s)).filter((s) => s != null))), r;
  }
  notifyBoxEvent(e, t, i, r) {
    const o = this.getEventData(t).activeView;
    this.trigger(e, { e: t, view: o, x: i, y: r, cell: o.cell });
  }
  getSelectedClassName(e) {
    return this.prefixClassName(`${e.isNode() ? "node" : "edge"}-selected`);
  }
  addCellSelectedClassName(e) {
    const t = this.graph.renderer.findViewByCell(e);
    t && t.addClass(this.getSelectedClassName(e));
  }
  removeCellUnSelectedClassName(e) {
    const t = this.graph.renderer.findViewByCell(e);
    t && t.removeClass(this.getSelectedClassName(e));
  }
  destroySelectionBox(e) {
    this.removeCellUnSelectedClassName(e), this.canShowSelectionBox(e) && (ro(this.container.querySelector(`[data-cell-id="${e.id}"]`)), this.$boxes.length === 0 && this.hide(), this.boxCount = Math.max(0, this.boxCount - 1));
  }
  destroyAllSelectionBoxes(e) {
    e.forEach((t) => this.removeCellUnSelectedClassName(t)), this.hide(), ro(this.$boxes), this.boxCount = 0;
  }
  hide() {
    Nn(this.container, this.prefixClassName(er.classNames.rubberband)), Nn(this.container, this.prefixClassName(er.classNames.selected));
  }
  showRubberband() {
    Ye(this.container, this.prefixClassName(er.classNames.rubberband));
  }
  hideRubberband() {
    Nn(this.container, this.prefixClassName(er.classNames.rubberband));
  }
  showSelected() {
    qw(this.container, "style"), Ye(this.container, this.prefixClassName(er.classNames.selected));
  }
  createContainer() {
    this.container = document.createElement("div"), Ye(this.container, this.prefixClassName(er.classNames.root)), this.options.className && Ye(this.container, this.options.className), this.selectionContainer = document.createElement("div"), Ye(this.selectionContainer, this.prefixClassName(er.classNames.inner)), this.selectionContent = document.createElement("div"), Ye(this.selectionContent, this.prefixClassName(er.classNames.content)), Ja(this.selectionContainer, this.selectionContent), St(this.selectionContainer, "data-selection-length", this.collection.length), DM(this.container, this.selectionContainer);
  }
  updateContainerPosition(e) {
    (e.dx || e.dy) && this.updateElementPosition(this.selectionContainer, e.dx, e.dy);
  }
  updateContainer() {
    const e = { x: 1 / 0, y: 1 / 0 }, t = { x: 0, y: 0 };
    this.collection.toArray().filter((s) => this.canShowSelectionBox(s)).forEach((s) => {
      const o = this.graph.renderer.findViewByCell(s);
      if (o) {
        const a = o.getBBox({
          useCellGeometry: !0
        });
        e.x = Math.min(e.x, a.x), e.y = Math.min(e.y, a.y), t.x = Math.max(t.x, a.x + a.width), t.y = Math.max(t.y, a.y + a.height);
      }
    }), qn(this.selectionContainer, {
      position: "absolute",
      pointerEvents: "none",
      left: e.x,
      top: e.y,
      width: t.x - e.x,
      height: t.y - e.y
    }), St(this.selectionContainer, "data-selection-length", this.collection.length);
    const r = this.options.content;
    if (r)
      if (typeof r == "function") {
        const s = Ze(r, this.graph, this, this.selectionContent);
        s && (this.selectionContent.innerHTML = s);
      } else
        this.selectionContent.innerHTML = r;
    this.collection.length > 0 && !this.container.parentNode ? cd(this.container, this.graph.container) : this.collection.length <= 0 && this.container.parentNode && this.container.parentNode.removeChild(this.container);
  }
  canShowSelectionBox(e) {
    return e.isNode() && this.options.showNodeSelectionBox === !0 || e.isEdge() && this.options.showEdgeSelectionBox === !0;
  }
  getPointerEventsValue(e) {
    return typeof e == "string" ? e : e(this.cells);
  }
  createSelectionBox(e) {
    if (this.addCellSelectedClassName(e), this.canShowSelectionBox(e)) {
      const t = this.graph.renderer.findViewByCell(e);
      if (t) {
        const i = t.getBBox({
          useCellGeometry: !0
        }), r = this.boxClassName, s = document.createElement("div"), o = this.options.pointerEvents;
        Ye(s, r), Ye(s, `${r}-${e.isNode() ? "node" : "edge"}`), St(s, "data-cell-id", e.id), qn(s, {
          position: "absolute",
          left: i.x,
          top: i.y,
          width: i.width,
          height: i.height,
          pointerEvents: o ? this.getPointerEventsValue(o) : "auto"
        }), cd(s, this.container), this.showSelected(), this.boxCount += 1;
      }
    }
  }
  updateSelectionBoxes() {
    this.collection.length > 0 && (this.boxesUpdated = !0, this.confirmUpdate());
  }
  confirmUpdate() {
    if (this.boxCount) {
      this.hide();
      for (let e = 0, t = this.$boxes, i = t.length; e < i; e += 1) {
        const r = t[e], s = St(r, "data-cell-id");
        ro(r), this.boxCount -= 1;
        const o = this.collection.get(s);
        o && this.createSelectionBox(o);
      }
      this.updateContainer();
    }
    return 0;
  }
  getCellViewFromElem(e) {
    const t = e.getAttribute("data-cell-id");
    if (t) {
      const i = this.collection.get(t);
      if (i)
        return this.graph.renderer.findViewByCell(i);
    }
    return null;
  }
  onCellRemoved({ cell: e }) {
    this.destroySelectionBox(e), this.updateContainer();
  }
  onReseted({ previous: e, current: t }) {
    this.destroyAllSelectionBoxes(e), t.forEach((i) => {
      this.listenCellRemoveEvent(i), this.createSelectionBox(i);
    }), this.updateContainer();
  }
  onCellAdded({ cell: e }) {
    this.listenCellRemoveEvent(e), this.createSelectionBox(e), this.updateContainer();
  }
  listenCellRemoveEvent(e) {
    e.off("removed", this.onCellRemoved, this), e.on("removed", this.onCellRemoved, this);
  }
  onCollectionUpdated({ added: e, removed: t, options: i }) {
    e.forEach((s) => {
      this.trigger("cell:selected", { cell: s, options: i }), s.isNode() ? this.trigger("node:selected", { cell: s, options: i, node: s }) : s.isEdge() && this.trigger("edge:selected", { cell: s, options: i, edge: s });
    }), t.forEach((s) => {
      this.trigger("cell:unselected", { cell: s, options: i }), s.isNode() ? this.trigger("node:unselected", { cell: s, options: i, node: s }) : s.isEdge() && this.trigger("edge:unselected", { cell: s, options: i, edge: s });
    });
    const r = {
      added: e,
      removed: t,
      options: i,
      selected: this.cells.filter((s) => !!this.graph.getCellById(s.id))
    };
    this.trigger("selection:changed", r);
  }
  // #endregion
  dispose() {
    this.clean(), this.remove(), this.off();
  }
}
Soe([
  Rt.dispose()
], UR.prototype, "dispose", null);
var er;
(function(n) {
  const e = "widget-selection";
  n.classNames = {
    root: e,
    inner: `${e}-inner`,
    box: `${e}-box`,
    content: `${e}-content`,
    rubberband: `${e}-rubberband`,
    selected: `${e}-selected`
  }, n.documentEvents = {
    mousemove: "adjustSelection",
    touchmove: "adjustSelection",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
  function t(i) {
    return i.getAncestors().length;
  }
  n.depthComparator = t;
})(er || (er = {}));
const Coe = `.x6-widget-selection {
  position: absolute;
  top: 0;
  left: 0;
  display: none;
  width: 0;
  height: 0;
  touch-action: none;
}
.x6-widget-selection-rubberband {
  display: block;
  overflow: visible;
  opacity: 0.3;
}
.x6-widget-selection-selected {
  display: block;
}
.x6-widget-selection-box {
  cursor: move;
}
.x6-widget-selection-inner[data-selection-length='0'],
.x6-widget-selection-inner[data-selection-length='1'] {
  display: none;
}
.x6-widget-selection-content {
  position: absolute;
  top: 100%;
  right: -20px;
  left: -20px;
  margin-top: 30px;
  padding: 6px;
  line-height: 14px;
  text-align: center;
  border-radius: 6px;
}
.x6-widget-selection-content:empty {
  display: none;
}
.x6-widget-selection-rubberband {
  background-color: #3498db;
  border: 2px solid #2980b9;
}
.x6-widget-selection-box {
  box-sizing: content-box !important;
  margin-top: -4px;
  margin-left: -4px;
  padding-right: 4px;
  padding-bottom: 4px;
  border: 2px dashed #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-inner {
  box-sizing: content-box !important;
  margin-top: -8px;
  margin-left: -8px;
  padding-right: 12px;
  padding-bottom: 12px;
  border: 2px solid #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-content {
  color: #fff;
  font-size: 10px;
  background-color: #6a6b8a;
}
`;
Pe.prototype.isSelectionEnabled = function() {
  const n = this.getPlugin("selection");
  return n ? n.isEnabled() : !1;
};
Pe.prototype.enableSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.enable(), this;
};
Pe.prototype.disableSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.disable(), this;
};
Pe.prototype.toggleSelection = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleEnabled(n), this;
};
Pe.prototype.isMultipleSelection = function() {
  const n = this.getPlugin("selection");
  return n ? n.isMultipleSelection() : !1;
};
Pe.prototype.enableMultipleSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.enableMultipleSelection(), this;
};
Pe.prototype.disableMultipleSelection = function() {
  const n = this.getPlugin("selection");
  return n && n.disableMultipleSelection(), this;
};
Pe.prototype.toggleMultipleSelection = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleMultipleSelection(n), this;
};
Pe.prototype.isSelectionMovable = function() {
  const n = this.getPlugin("selection");
  return n ? n.isSelectionMovable() : !1;
};
Pe.prototype.enableSelectionMovable = function() {
  const n = this.getPlugin("selection");
  return n && n.enableSelectionMovable(), this;
};
Pe.prototype.disableSelectionMovable = function() {
  const n = this.getPlugin("selection");
  return n && n.disableSelectionMovable(), this;
};
Pe.prototype.toggleSelectionMovable = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleSelectionMovable(n), this;
};
Pe.prototype.isRubberbandEnabled = function() {
  const n = this.getPlugin("selection");
  return n ? n.isRubberbandEnabled() : !1;
};
Pe.prototype.enableRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.enableRubberband(), this;
};
Pe.prototype.disableRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.disableRubberband(), this;
};
Pe.prototype.toggleRubberband = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleRubberband(n), this;
};
Pe.prototype.isStrictRubberband = function() {
  const n = this.getPlugin("selection");
  return n ? n.isStrictRubberband() : !1;
};
Pe.prototype.enableStrictRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.enableStrictRubberband(), this;
};
Pe.prototype.disableStrictRubberband = function() {
  const n = this.getPlugin("selection");
  return n && n.disableStrictRubberband(), this;
};
Pe.prototype.toggleStrictRubberband = function(n) {
  const e = this.getPlugin("selection");
  return e && e.toggleStrictRubberband(n), this;
};
Pe.prototype.setRubberbandModifiers = function(n) {
  const e = this.getPlugin("selection");
  return e && e.setRubberbandModifiers(n), this;
};
Pe.prototype.setSelectionFilter = function(n) {
  const e = this.getPlugin("selection");
  return e && e.setSelectionFilter(n), this;
};
Pe.prototype.setSelectionDisplayContent = function(n) {
  const e = this.getPlugin("selection");
  return e && e.setSelectionDisplayContent(n), this;
};
Pe.prototype.isSelectionEmpty = function() {
  const n = this.getPlugin("selection");
  return n ? n.isEmpty() : !0;
};
Pe.prototype.cleanSelection = function(n) {
  const e = this.getPlugin("selection");
  return e && e.clean(n), this;
};
Pe.prototype.resetSelection = function(n, e) {
  const t = this.getPlugin("selection");
  return t && t.reset(n, e), this;
};
Pe.prototype.getSelectedCells = function() {
  const n = this.getPlugin("selection");
  return n ? n.getSelectedCells() : [];
};
Pe.prototype.getSelectedCellCount = function() {
  const n = this.getPlugin("selection");
  return n ? n.getSelectedCellCount() : 0;
};
Pe.prototype.isSelected = function(n) {
  const e = this.getPlugin("selection");
  return e ? e.isSelected(n) : !1;
};
Pe.prototype.select = function(n, e) {
  const t = this.getPlugin("selection");
  return t && t.select(n, e), this;
};
Pe.prototype.unselect = function(n, e) {
  const t = this.getPlugin("selection");
  return t && t.unselect(n, e), this;
};
var koe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Gd extends gn {
  get rubberbandDisabled() {
    return this.options.enabled !== !0 || this.options.rubberband !== !0;
  }
  get disabled() {
    return this.options.enabled !== !0;
  }
  get length() {
    return this.selectionImpl.length;
  }
  get cells() {
    return this.selectionImpl.cells;
  }
  constructor(e = {}) {
    super(), this.name = "selection", this.movedMap = /* @__PURE__ */ new WeakMap(), this.unselectMap = /* @__PURE__ */ new WeakMap(), this.options = Object.assign(Object.assign({ enabled: !0 }, Gd.defaultOptions), e), kv(this.name, Coe);
  }
  init(e) {
    this.graph = e, this.selectionImpl = new UR(Object.assign(Object.assign({}, this.options), { graph: e })), this.setup(), this.startListening();
  }
  // #region api
  isEnabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled && (this.options.enabled = !0);
  }
  disable() {
    this.disabled || (this.options.enabled = !1);
  }
  toggleEnabled(e) {
    return e != null ? e !== this.isEnabled() && (e ? this.enable() : this.disable()) : this.isEnabled() ? this.disable() : this.enable(), this;
  }
  isMultipleSelection() {
    return this.isMultiple();
  }
  enableMultipleSelection() {
    return this.enableMultiple(), this;
  }
  disableMultipleSelection() {
    return this.disableMultiple(), this;
  }
  toggleMultipleSelection(e) {
    return e != null ? e !== this.isMultipleSelection() && (e ? this.enableMultipleSelection() : this.disableMultipleSelection()) : this.isMultipleSelection() ? this.disableMultipleSelection() : this.enableMultipleSelection(), this;
  }
  isSelectionMovable() {
    return this.options.movable !== !1;
  }
  enableSelectionMovable() {
    return this.selectionImpl.options.movable = !0, this;
  }
  disableSelectionMovable() {
    return this.selectionImpl.options.movable = !1, this;
  }
  toggleSelectionMovable(e) {
    return e != null ? e !== this.isSelectionMovable() && (e ? this.enableSelectionMovable() : this.disableSelectionMovable()) : this.isSelectionMovable() ? this.disableSelectionMovable() : this.enableSelectionMovable(), this;
  }
  isRubberbandEnabled() {
    return !this.rubberbandDisabled;
  }
  enableRubberband() {
    return this.rubberbandDisabled && (this.options.rubberband = !0), this;
  }
  disableRubberband() {
    return this.rubberbandDisabled || (this.options.rubberband = !1), this;
  }
  toggleRubberband(e) {
    return e != null ? e !== this.isRubberbandEnabled() && (e ? this.enableRubberband() : this.disableRubberband()) : this.isRubberbandEnabled() ? this.disableRubberband() : this.enableRubberband(), this;
  }
  isStrictRubberband() {
    return this.selectionImpl.options.strict === !0;
  }
  enableStrictRubberband() {
    return this.selectionImpl.options.strict = !0, this;
  }
  disableStrictRubberband() {
    return this.selectionImpl.options.strict = !1, this;
  }
  toggleStrictRubberband(e) {
    return e != null ? e !== this.isStrictRubberband() && (e ? this.enableStrictRubberband() : this.disableStrictRubberband()) : this.isStrictRubberband() ? this.disableStrictRubberband() : this.enableStrictRubberband(), this;
  }
  setRubberbandModifiers(e) {
    this.setModifiers(e);
  }
  setSelectionFilter(e) {
    return this.setFilter(e), this;
  }
  setSelectionDisplayContent(e) {
    return this.setContent(e), this;
  }
  isEmpty() {
    return this.length <= 0;
  }
  clean(e = {}) {
    return this.selectionImpl.clean(e), this;
  }
  reset(e, t = {}) {
    return this.selectionImpl.reset(e ? this.getCells(e) : [], t), this;
  }
  getSelectedCells() {
    return this.cells;
  }
  getSelectedCellCount() {
    return this.length;
  }
  isSelected(e) {
    return this.selectionImpl.isSelected(e);
  }
  select(e, t = {}) {
    const i = this.getCells(e);
    return i.length && (this.isMultiple() ? this.selectionImpl.select(i, t) : this.reset(i.slice(0, 1), t)), this;
  }
  unselect(e, t = {}) {
    return this.selectionImpl.unselect(this.getCells(e), t), this;
  }
  // #endregion
  setup() {
    this.selectionImpl.on("*", (e, t) => {
      this.trigger(e, t), this.graph.trigger(e, t);
    });
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onBlankMouseDown, this), this.graph.on("blank:click", this.onBlankClick, this), this.graph.on("cell:mousemove", this.onCellMouseMove, this), this.graph.on("cell:mouseup", this.onCellMouseUp, this), this.selectionImpl.on("box:mousedown", this.onBoxMouseDown, this);
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onBlankMouseDown, this), this.graph.off("blank:click", this.onBlankClick, this), this.graph.off("cell:mousemove", this.onCellMouseMove, this), this.graph.off("cell:mouseup", this.onCellMouseUp, this), this.selectionImpl.off("box:mousedown", this.onBoxMouseDown, this);
  }
  onBlankMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e))
      return;
    const t = this.graph.panning.allowPanning(e, !0), i = this.graph.getPlugin("scroller"), r = i && i.allowPanning(e, !0);
    (this.allowRubberband(e, !0) || this.allowRubberband(e) && !r && !t) && this.startRubberband(e);
  }
  allowBlankMouseDown(e) {
    const t = this.options.eventTypes;
    return (t == null ? void 0 : t.includes("leftMouseDown")) && e.button === 0 || (t == null ? void 0 : t.includes("mouseWheelDown")) && e.button === 1;
  }
  onBlankClick() {
    this.clean();
  }
  allowRubberband(e, t) {
    return !this.rubberbandDisabled && Ba.isMatch(e, this.options.modifiers, t);
  }
  allowMultipleSelection(e) {
    return this.isMultiple() && Ba.isMatch(e, this.options.multipleSelectionModifiers);
  }
  onCellMouseMove({ cell: e }) {
    this.movedMap.set(e, !0);
  }
  onCellMouseUp({ e, cell: t }) {
    const i = this.options;
    let r = this.disabled;
    !r && this.movedMap.has(t) && (r = i.selectCellOnMoved === !1, r || (r = i.selectNodeOnMoved === !1 && t.isNode()), r || (r = i.selectEdgeOnMoved === !1 && t.isEdge())), r || (this.allowMultipleSelection(e) ? this.unselectMap.has(t) ? this.unselectMap.delete(t) : this.isSelected(t) ? this.unselect(t) : this.select(t) : this.reset(t)), this.movedMap.delete(t);
  }
  onBoxMouseDown({ e, cell: t }) {
    this.disabled || this.allowMultipleSelection(e) && (this.unselect(t), this.unselectMap.set(t, !0));
  }
  getCells(e) {
    return (Array.isArray(e) ? e : [e]).map((t) => typeof t == "string" ? this.graph.getCellById(t) : t).filter((t) => t != null);
  }
  startRubberband(e) {
    return this.rubberbandDisabled || this.selectionImpl.startSelecting(e), this;
  }
  isMultiple() {
    return this.options.multiple !== !1;
  }
  enableMultiple() {
    return this.options.multiple = !0, this;
  }
  disableMultiple() {
    return this.options.multiple = !1, this;
  }
  setModifiers(e) {
    return this.options.modifiers = e, this;
  }
  setContent(e) {
    return this.selectionImpl.setContent(e), this;
  }
  setFilter(e) {
    return this.selectionImpl.setFilter(e), this;
  }
  dispose() {
    this.stopListening(), this.off(), this.selectionImpl.dispose(), Pv(this.name);
  }
}
koe([
  gn.dispose()
], Gd.prototype, "dispose", null);
(function(n) {
  n.defaultOptions = {
    rubberband: !1,
    rubberNode: !0,
    rubberEdge: !1,
    pointerEvents: "auto",
    multiple: !0,
    multipleSelectionModifiers: ["ctrl", "meta"],
    movable: !0,
    strict: !1,
    selectCellOnMoved: !1,
    selectNodeOnMoved: !1,
    selectEdgeOnMoved: !1,
    following: !0,
    content: null,
    eventTypes: ["leftMouseDown", "mouseWheelDown"]
  };
})(Gd || (Gd = {}));
class Poe {
  constructor() {
    this.cells = [];
  }
  copy(e, t, i = {}) {
    this.options = Object.assign({}, i);
    const s = (lr.isModel(t) ? t : t.model).cloneSubGraph(e, i);
    this.cells = N$(Object.keys(s).map((o) => s[o]), (o) => o.isEdge() ? 2 : 1), this.serialize(i);
  }
  cut(e, t, i = {}) {
    this.copy(e, t, i), (Pe.isGraph(t) ? t.model : t).batchUpdate("cut", () => {
      e.forEach((s) => s.remove());
    });
  }
  paste(e, t = {}) {
    const i = Object.assign(Object.assign({}, this.options), t), { offset: r, edgeProps: s, nodeProps: o } = i;
    let a = 20, l = 20;
    r && (a = typeof r == "number" ? r : r.dx, l = typeof r == "number" ? r : r.dy), this.deserialize(i);
    const c = this.cells;
    c.forEach((h) => {
      h.model = null, h.removeProp("zIndex"), (a || l) && h.translate(a, l), o && h.isNode() && h.prop(o), s && h.isEdge() && h.prop(s);
    });
    const u = Pe.isGraph(e) ? e.model : e;
    return u.batchUpdate("paste", () => {
      u.addCells(this.cells);
    }), this.copy(c, e, t), c;
  }
  serialize(e) {
    e.useLocalStorage !== !1 && gd.save(this.cells);
  }
  deserialize(e) {
    if (e.useLocalStorage) {
      const t = gd.fetch();
      t && (this.cells = t);
    }
  }
  isEmpty(e = {}) {
    return e.useLocalStorage && this.deserialize(e), this.cells.length <= 0;
  }
  clean() {
    this.options = {}, this.cells = [], gd.clean();
  }
}
var gd;
(function(n) {
  const e = `${Jr.prefixCls}.clipboard.cells`;
  function t(s) {
    if (window.localStorage) {
      const o = s.map((a) => a.toJSON());
      localStorage.setItem(e, JSON.stringify(o));
    }
  }
  n.save = t;
  function i() {
    if (window.localStorage) {
      const s = localStorage.getItem(e), o = s ? JSON.parse(s) : [];
      if (o)
        return lr.fromJSON(o);
    }
  }
  n.fetch = i;
  function r() {
    window.localStorage && localStorage.removeItem(e);
  }
  n.clean = r;
})(gd || (gd = {}));
Pe.prototype.isClipboardEnabled = function() {
  const n = this.getPlugin("clipboard");
  return n ? n.isEnabled() : !1;
};
Pe.prototype.enableClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n && n.enable(), this;
};
Pe.prototype.disableClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n && n.disable(), this;
};
Pe.prototype.toggleClipboard = function(n) {
  const e = this.getPlugin("clipboard");
  return e && e.toggleEnabled(n), this;
};
Pe.prototype.isClipboardEmpty = function(n) {
  const e = this.getPlugin("clipboard");
  return e ? e.isEmpty(n) : !0;
};
Pe.prototype.getCellsInClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n ? n.getCellsInClipboard() : [];
};
Pe.prototype.cleanClipboard = function() {
  const n = this.getPlugin("clipboard");
  return n && n.clean(), this;
};
Pe.prototype.copy = function(n, e) {
  const t = this.getPlugin("clipboard");
  return t && t.copy(n, e), this;
};
Pe.prototype.cut = function(n, e) {
  const t = this.getPlugin("clipboard");
  return t && t.cut(n, e), this;
};
Pe.prototype.paste = function(n, e) {
  const t = this.getPlugin("clipboard");
  return t ? t.paste(n, e) : [];
};
var Eoe = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}, Aoe = function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
class $oe extends gn {
  get disabled() {
    return this.options.enabled !== !0;
  }
  get cells() {
    return this.clipboardImpl.cells;
  }
  constructor(e = {}) {
    super(), this.name = "clipboard", this.options = Object.assign({ enabled: !0 }, e);
  }
  init(e) {
    this.graph = e, this.clipboardImpl = new Poe(), this.clipboardImpl.deserialize(this.options);
  }
  // #region api
  isEnabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled && (this.options.enabled = !0);
  }
  disable() {
    this.disabled || (this.options.enabled = !1);
  }
  toggleEnabled(e) {
    return e != null ? e !== this.isEnabled() && (e ? this.enable() : this.disable()) : this.isEnabled() ? this.disable() : this.enable(), this;
  }
  isEmpty(e = {}) {
    return this.clipboardImpl.isEmpty(e);
  }
  getCellsInClipboard() {
    return this.cells;
  }
  clean(e) {
    return (!this.disabled || e) && (this.clipboardImpl.clean(), this.notify("clipboard:changed", { cells: [] })), this;
  }
  copy(e, t = {}) {
    return this.disabled || (this.clipboardImpl.copy(e, this.graph, Object.assign(Object.assign({}, this.commonOptions), t)), this.notify("clipboard:changed", { cells: e })), this;
  }
  cut(e, t = {}) {
    return this.disabled || (this.clipboardImpl.cut(e, this.graph, Object.assign(Object.assign({}, this.commonOptions), t)), this.notify("clipboard:changed", { cells: e })), this;
  }
  paste(e = {}, t = this.graph) {
    return this.disabled ? [] : this.clipboardImpl.paste(t, Object.assign(Object.assign({}, this.commonOptions), e));
  }
  // #endregion
  get commonOptions() {
    const e = this.options;
    return Aoe(e, ["enabled"]);
  }
  notify(e, t) {
    this.trigger(e, t), this.graph.trigger(e, t);
  }
  dispose() {
    this.clean(!0), this.off();
  }
}
Eoe([
  gn.dispose()
], $oe.prototype, "dispose", null);
Pe.prototype.isHistoryEnabled = function() {
  const n = this.getPlugin("history");
  return n ? n.isEnabled() : !1;
};
Pe.prototype.enableHistory = function() {
  const n = this.getPlugin("history");
  return n && n.enable(), this;
};
Pe.prototype.disableHistory = function() {
  const n = this.getPlugin("history");
  return n && n.disable(), this;
};
Pe.prototype.toggleHistory = function(n) {
  const e = this.getPlugin("history");
  return e && e.toggleEnabled(n), this;
};
Pe.prototype.undo = function(n) {
  const e = this.getPlugin("history");
  return e && e.undo(n), this;
};
Pe.prototype.redo = function(n) {
  const e = this.getPlugin("history");
  return e && e.redo(n), this;
};
Pe.prototype.undoAndCancel = function(n) {
  const e = this.getPlugin("history");
  return e && e.cancel(n), this;
};
Pe.prototype.canUndo = function() {
  const n = this.getPlugin("history");
  return n ? n.canUndo() : !1;
};
Pe.prototype.canRedo = function() {
  const n = this.getPlugin("history");
  return n ? n.canRedo() : !1;
};
Pe.prototype.cleanHistory = function(n) {
  const e = this.getPlugin("history");
  return e && e.clean(n), this;
};
Pe.prototype.getHistoryStackSize = function() {
  return this.getPlugin("history").getSize();
};
Pe.prototype.getUndoStackSize = function() {
  return this.getPlugin("history").getUndoSize();
};
Pe.prototype.getRedoStackSize = function() {
  return this.getPlugin("history").getRedoSize();
};
Pe.prototype.getUndoRemainSize = function() {
  return this.getPlugin("history").getUndoRemainSize();
};
var GR = function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
};
class Kd extends gn {
  constructor(e = {}) {
    super(), this.name = "history", this.batchCommands = null, this.batchLevel = 0, this.lastBatchIndex = -1, this.freezed = !1, this.stackSize = 0, this.handlers = [];
    const { stackSize: t = 0 } = e;
    this.stackSize = t, this.options = dn.getOptions(e), this.validator = new Kd.Validator({
      history: this,
      cancelInvalid: this.options.cancelInvalid
    });
  }
  init(e) {
    this.graph = e, this.model = this.graph.model, this.clean(), this.startListening();
  }
  // #region api
  isEnabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled && (this.options.enabled = !0);
  }
  disable() {
    this.disabled || (this.options.enabled = !1);
  }
  toggleEnabled(e) {
    return e != null ? e !== this.isEnabled() && (e ? this.enable() : this.disable()) : this.isEnabled() ? this.disable() : this.enable(), this;
  }
  undo(e = {}) {
    if (!this.disabled) {
      const t = this.undoStack.pop();
      t && (this.revertCommand(t, e), this.redoStack.push(t), this.notify("undo", t, e));
    }
    return this;
  }
  redo(e = {}) {
    if (!this.disabled) {
      const t = this.redoStack.pop();
      t && (this.applyCommand(t, e), this.undoStackPush(t), this.notify("redo", t, e));
    }
    return this;
  }
  /**
   * Same as `undo()` but does not store the undo-ed command to the
   * `redoStack`. Canceled command therefore cannot be redo-ed.
   */
  cancel(e = {}) {
    if (!this.disabled) {
      const t = this.undoStack.pop();
      t && (this.revertCommand(t, e), this.redoStack = [], this.notify("cancel", t, e));
    }
    return this;
  }
  getSize() {
    return this.stackSize;
  }
  getUndoRemainSize() {
    const e = this.undoStack.length;
    return this.stackSize - e;
  }
  getUndoSize() {
    return this.undoStack.length;
  }
  getRedoSize() {
    return this.redoStack.length;
  }
  canUndo() {
    return !this.disabled && this.undoStack.length > 0;
  }
  canRedo() {
    return !this.disabled && this.redoStack.length > 0;
  }
  clean(e = {}) {
    return this.undoStack = [], this.redoStack = [], this.notify("clean", null, e), this;
  }
  // #endregion
  get disabled() {
    return this.options.enabled !== !0;
  }
  validate(e, ...t) {
    return this.validator.validate(e, ...t), this;
  }
  startListening() {
    this.model.on("batch:start", this.initBatchCommand, this), this.model.on("batch:stop", this.storeBatchCommand, this), this.options.eventNames && this.options.eventNames.forEach((e, t) => {
      this.handlers[t] = this.addCommand.bind(this, e), this.model.on(e, this.handlers[t]);
    }), this.validator.on("invalid", (e) => this.trigger("invalid", e));
  }
  stopListening() {
    this.model.off("batch:start", this.initBatchCommand, this), this.model.off("batch:stop", this.storeBatchCommand, this), this.options.eventNames && (this.options.eventNames.forEach((e, t) => {
      this.model.off(e, this.handlers[t]);
    }), this.handlers.length = 0), this.validator.off("invalid");
  }
  createCommand(e) {
    return {
      batch: e ? e.batch : !1,
      data: {}
    };
  }
  revertCommand(e, t) {
    this.freezed = !0;
    const i = Array.isArray(e) ? dn.sortBatchCommands(e) : [e];
    for (let r = i.length - 1; r >= 0; r -= 1) {
      const s = i[r], o = Object.assign(Object.assign({}, t), Kb(s.options, this.options.revertOptionsList || []));
      this.executeCommand(s, !0, o);
    }
    this.freezed = !1;
  }
  applyCommand(e, t) {
    this.freezed = !0;
    const i = Array.isArray(e) ? dn.sortBatchCommands(e) : [e];
    for (let r = 0; r < i.length; r += 1) {
      const s = i[r], o = Object.assign(Object.assign({}, t), Kb(s.options, this.options.applyOptionsList || []));
      this.executeCommand(s, !1, o);
    }
    this.freezed = !1;
  }
  executeCommand(e, t, i) {
    const r = this.model, s = r.getCell(e.data.id), o = e.event;
    if (dn.isAddEvent(o) && t || dn.isRemoveEvent(o) && !t)
      s && s.remove(i);
    else if (dn.isAddEvent(o) && !t || dn.isRemoveEvent(o) && t) {
      const a = e.data;
      a.node ? r.addNode(a.props, i) : a.edge && r.addEdge(a.props, i);
    } else if (dn.isChangeEvent(o)) {
      const a = e.data, l = a.key;
      if (l && s) {
        const c = t ? a.prev[l] : a.next[l];
        a.key === "attrs" && this.ensureUndefinedAttrs(c, t ? a.next[l] : a.prev[l]) && (i.dirty = !0), s.prop(l, c, i);
      }
    } else {
      const a = this.options.executeCommand;
      a && Ze(a, this, e, t, i);
    }
  }
  addCommand(e, t) {
    if (this.freezed || this.disabled)
      return;
    const i = t, r = i.options || {};
    if (r.dryrun || dn.isAddEvent(e) && this.options.ignoreAdd || dn.isRemoveEvent(e) && this.options.ignoreRemove || dn.isChangeEvent(e) && this.options.ignoreChange)
      return;
    const s = this.options.beforeAddCommand;
    if (s != null && Ze(s, this, e, t) === !1)
      return;
    e === "cell:change:*" && (e = `cell:change:${i.key}`);
    const o = i.cell, a = lr.isModel(o);
    let l;
    if (this.batchCommands) {
      l = this.batchCommands[Math.max(this.lastBatchIndex, 0)];
      const u = a && !l.modelChange || l.data.id !== o.id, h = l.event !== e;
      if (this.lastBatchIndex >= 0 && (u || h)) {
        const d = this.batchCommands.findIndex((f) => (a && f.modelChange || f.data.id === o.id) && f.event === e);
        d < 0 || dn.isAddEvent(e) || dn.isRemoveEvent(e) ? l = this.createCommand({ batch: !0 }) : (l = this.batchCommands[d], this.batchCommands.splice(d, 1)), this.batchCommands.push(l), this.lastBatchIndex = this.batchCommands.length - 1;
      }
    } else
      l = this.createCommand({ batch: !1 });
    if (dn.isAddEvent(e) || dn.isRemoveEvent(e)) {
      const u = l.data;
      return l.event = e, l.options = r, u.id = o.id, u.props = Bt(o.toJSON()), o.isEdge() ? u.edge = !0 : o.isNode() && (u.node = !0), this.push(l, r);
    }
    if (dn.isChangeEvent(e)) {
      const u = t.key, h = l.data;
      return (!l.batch || !l.event) && (l.event = e, l.options = r, h.key = u, h.prev == null && (h.prev = {}), h.prev[u] = Bt(o.previous(u)), a ? l.modelChange = !0 : h.id = o.id), h.next == null && (h.next = {}), h.next[u] = Bt(o.prop(u)), this.push(l, r);
    }
    const c = this.options.afterAddCommand;
    c && Ze(c, this, e, t, l), this.push(l, r);
  }
  /**
   * Gather multiple changes into a single command. These commands could
   * be reverted with single `undo()` call. From the moment the function
   * is called every change made on model is not stored into the undoStack.
   * Changes are temporarily kept until `storeBatchCommand()` is called.
   */
  // eslint-disable-next-line
  initBatchCommand(e) {
    this.freezed || (this.batchCommands ? this.batchLevel += 1 : (this.batchCommands = [this.createCommand({ batch: !0 })], this.batchLevel = 0, this.lastBatchIndex = -1));
  }
  /**
   * Store changes temporarily kept in the undoStack. You have to call this
   * function as many times as `initBatchCommand()` been called.
   */
  storeBatchCommand(e) {
    if (!this.freezed)
      if (this.batchCommands && this.batchLevel <= 0) {
        const t = this.filterBatchCommand(this.batchCommands);
        t.length > 0 && (this.redoStack = [], this.undoStackPush(t), this.consolidateCommands(), this.notify("add", t, e)), this.batchCommands = null, this.lastBatchIndex = -1, this.batchLevel = 0;
      } else
        this.batchCommands && this.batchLevel > 0 && (this.batchLevel -= 1);
  }
  filterBatchCommand(e) {
    let t = e.slice();
    const i = [];
    for (; t.length > 0; ) {
      const r = t.shift(), s = r.event, o = r.data.id;
      if (s != null && (o != null || r.modelChange)) {
        if (dn.isAddEvent(s)) {
          const a = t.findIndex((l) => dn.isRemoveEvent(l.event) && l.data.id === o);
          if (a >= 0) {
            t = t.filter((l, c) => a < c || l.data.id !== o);
            continue;
          }
        } else if (dn.isRemoveEvent(s)) {
          const a = t.findIndex((l) => dn.isAddEvent(l.event) && l.data.id === o);
          if (a >= 0) {
            t.splice(a, 1);
            continue;
          }
        } else if (dn.isChangeEvent(s)) {
          const a = r.data;
          if (cn(a.prev, a.next))
            continue;
        }
        i.push(r);
      }
    }
    return i;
  }
  notify(e, t, i) {
    const r = t == null ? null : Array.isArray(t) ? t : [t];
    this.emit(e, { cmds: r, options: i }), this.graph.trigger(`history:${e}`, { cmds: r, options: i }), this.emit("change", { cmds: r, options: i }), this.graph.trigger("history:change", { cmds: r, options: i });
  }
  push(e, t) {
    this.redoStack = [], e.batch ? (this.lastBatchIndex = Math.max(this.lastBatchIndex, 0), this.emit("batch", { cmd: e, options: t })) : (this.undoStackPush(e), this.consolidateCommands(), this.notify("add", e, t));
  }
  /**
   * Conditionally combine multiple undo items into one.
   *
   * Currently this is only used combine a `cell:changed:position` event
   * followed by multiple `cell:change:parent` and `cell:change:children`
   * events, such that a "move + embed" action can be undone in one step.
   *
   * See https://github.com/antvis/X6/issues/2421
   *
   * This is an ugly WORKAROUND. It does not solve deficiencies in the batch
   * system itself.
   */
  consolidateCommands() {
    var e;
    const t = this.undoStack[this.undoStack.length - 1], i = this.undoStack[this.undoStack.length - 2];
    if (!Array.isArray(t))
      return;
    const r = new Set(t.map((o) => o.event));
    if (r.size !== 2 || !r.has("cell:change:parent") || !r.has("cell:change:children") || !t.every((o) => {
      var a;
      return o.batch && ((a = o.options) === null || a === void 0 ? void 0 : a.ui);
    }) || !Array.isArray(i) || i.length !== 1)
      return;
    const s = i[0];
    s.event !== "cell:change:position" || !(!((e = s.options) === null || e === void 0) && e.ui) || (i.push(...t), this.undoStack.pop());
  }
  undoStackPush(e) {
    if (this.stackSize === 0) {
      this.undoStack.push(e);
      return;
    }
    this.undoStack.length >= this.stackSize && this.undoStack.shift(), this.undoStack.push(e);
  }
  ensureUndefinedAttrs(e, t) {
    let i = !1;
    return e !== null && t !== null && typeof e == "object" && typeof t == "object" && Object.keys(t).forEach((r) => {
      e[r] === void 0 && t[r] !== void 0 ? (e[r] = void 0, i = !0) : typeof e[r] == "object" && typeof t[r] == "object" && (i = this.ensureUndefinedAttrs(e[r], t[r]));
    }), i;
  }
  dispose() {
    this.validator.dispose(), this.clean(), this.stopListening(), this.off();
  }
}
GR([
  gn.dispose()
], Kd.prototype, "dispose", null);
(function(n) {
  class e extends gn {
    constructor(i) {
      super(), this.map = {}, this.command = i.history, this.cancelInvalid = i.cancelInvalid !== !1, this.command.on("add", this.onCommandAdded, this);
    }
    onCommandAdded({ cmds: i }) {
      return Array.isArray(i) ? i.every((r) => this.isValidCommand(r)) : this.isValidCommand(i);
    }
    isValidCommand(i) {
      if (i.options && i.options.validation === !1)
        return !0;
      const r = i.event && this.map[i.event] || [];
      let s = null;
      return r.forEach((o) => {
        let a = 0;
        const l = (c) => {
          const u = o[a];
          a += 1;
          try {
            if (u)
              u(c, i, l);
            else {
              s = c;
              return;
            }
          } catch (h) {
            l(h);
          }
        };
        l(s);
      }), s ? (this.cancelInvalid && this.command.cancel(), this.emit("invalid", { err: s }), !1) : !0;
    }
    validate(i, ...r) {
      const s = Array.isArray(i) ? i : i.split(/\s+/);
      return r.forEach((o) => {
        if (typeof o != "function")
          throw new Error(`${s.join(" ")} requires callback functions.`);
      }), s.forEach((o) => {
        this.map[o] == null && (this.map[o] = []), this.map[o].push(r);
      }), this;
    }
    dispose() {
      this.command.off("add", this.onCommandAdded, this);
    }
  }
  GR([
    gn.dispose()
  ], e.prototype, "dispose", null), n.Validator = e;
})(Kd || (Kd = {}));
var dn;
(function(n) {
  function e(o) {
    return o === "cell:added";
  }
  n.isAddEvent = e;
  function t(o) {
    return o === "cell:removed";
  }
  n.isRemoveEvent = t;
  function i(o) {
    return o != null && o.startsWith("cell:change:");
  }
  n.isChangeEvent = i;
  function r(o) {
    const a = [
      "cell:added",
      "cell:removed",
      "cell:change:*"
    ], l = ["batch:start", "batch:stop"], c = o.eventNames ? o.eventNames.filter((u) => !(n.isChangeEvent(u) || a.includes(u) || l.includes(u))) : a;
    return Object.assign(Object.assign({ enabled: !0 }, o), { eventNames: c, applyOptionsList: o.applyOptionsList || ["propertyPath"], revertOptionsList: o.revertOptionsList || ["propertyPath"] });
  }
  n.getOptions = r;
  function s(o) {
    const a = [];
    for (let l = 0, c = o.length; l < c; l += 1) {
      const u = o[l];
      let h = null;
      if (n.isAddEvent(u.event)) {
        const d = u.data.id;
        for (let f = 0; f < l; f += 1)
          if (o[f].data.id === d) {
            h = f;
            break;
          }
      }
      h !== null ? a.splice(h, 0, u) : a.push(u);
    }
    return a;
  }
  n.sortBatchCommands = s;
})(dn || (dn = {}));
const Lt = "md-editor", Toe = "md-editor-v3", _oe = "https://at.alicdn.com/t/c/font_2605852_prouiefeic.js", Moe = "https://at.alicdn.com/t/c/font_2605852_prouiefeic.css", Mn = "https://cdnjs.cloudflare.com/ajax/libs", Roe = `${Mn}/highlight.js/11.8.0/highlight.min.js`, Noe = [
  "bold",
  "underline",
  "italic",
  "strikeThrough",
  "-",
  "title",
  "sub",
  "sup",
  "quote",
  "unorderedList",
  "orderedList",
  "task",
  "-",
  "codeRow",
  "code",
  "link",
  "image",
  "table",
  "mermaid",
  "katex",
  "-",
  "revoke",
  "next",
  "save",
  "=",
  "prettier",
  "pageFullscreen",
  "fullscreen",
  "preview",
  "htmlPreview",
  "catalog",
  "github"
], Doe = ["markdownTotal", "=", "scrollSwitch"], n2 = {
  "zh-CN": {
    toolbarTips: {
      bold: "加粗",
      underline: "下划线",
      italic: "斜体",
      strikeThrough: "删除线",
      title: "标题",
      sub: "下标",
      sup: "上标",
      quote: "引用",
      unorderedList: "无序列表",
      orderedList: "有序列表",
      task: "任务列表",
      codeRow: "行内代码",
      code: "块级代码",
      link: "链接",
      image: "图片",
      table: "表格",
      mermaid: "mermaid图",
      katex: "katex公式",
      revoke: "后退",
      next: "前进",
      save: "保存",
      prettier: "美化",
      pageFullscreen: "浏览器全屏",
      fullscreen: "屏幕全屏",
      preview: "预览",
      htmlPreview: "html代码预览",
      catalog: "目录",
      github: "源码地址"
    },
    titleItem: {
      h1: "一级标题",
      h2: "二级标题",
      h3: "三级标题",
      h4: "四级标题",
      h5: "五级标题",
      h6: "六级标题"
    },
    imgTitleItem: {
      link: "添加链接",
      upload: "上传图片",
      clip2upload: "裁剪上传"
    },
    linkModalTips: {
      linkTitle: "添加链接",
      imageTitle: "添加图片",
      descLabel: "链接描述：",
      descLabelPlaceHolder: "请输入描述...",
      urlLabel: "链接地址：",
      urlLabelPlaceHolder: "请输入链接...",
      buttonOK: "确定"
    },
    clipModalTips: {
      title: "裁剪图片上传",
      buttonUpload: "上传"
    },
    copyCode: {
      text: "复制代码",
      successTips: "已复制！",
      failTips: "复制失败！"
    },
    mermaid: {
      flow: "流程图",
      sequence: "时序图",
      gantt: "甘特图",
      class: "类图",
      state: "状态图",
      pie: "饼图",
      relationship: "关系图",
      journey: "旅程图"
    },
    katex: {
      inline: "行内公式",
      block: "块级公式"
    },
    footer: {
      markdownTotal: "字数",
      scrollAuto: "同步滚动"
    }
  },
  "en-US": {
    toolbarTips: {
      bold: "bold",
      underline: "underline",
      italic: "italic",
      strikeThrough: "strikeThrough",
      title: "title",
      sub: "subscript",
      sup: "superscript",
      quote: "quote",
      unorderedList: "unordered list",
      orderedList: "ordered list",
      task: "task list",
      codeRow: "inline code",
      code: "block-level code",
      link: "link",
      image: "image",
      table: "table",
      mermaid: "mermaid",
      katex: "formula",
      revoke: "revoke",
      next: "undo revoke",
      save: "save",
      prettier: "prettier",
      pageFullscreen: "fullscreen in page",
      fullscreen: "fullscreen",
      preview: "preview",
      htmlPreview: "html preview",
      catalog: "catalog",
      github: "source code"
    },
    titleItem: {
      h1: "Lv1 Heading",
      h2: "Lv2 Heading",
      h3: "Lv3 Heading",
      h4: "Lv4 Heading",
      h5: "Lv5 Heading",
      h6: "Lv6 Heading"
    },
    imgTitleItem: {
      link: "Add Img Link",
      upload: "Upload Img",
      clip2upload: "Clip Upload"
    },
    linkModalTips: {
      linkTitle: "Add Link",
      imageTitle: "Add Image",
      descLabel: "Desc:",
      descLabelPlaceHolder: "Enter a description...",
      urlLabel: "Link:",
      urlLabelPlaceHolder: "Enter a link...",
      buttonOK: "OK"
    },
    clipModalTips: {
      title: "Crop Image",
      buttonUpload: "Upload"
    },
    copyCode: {
      text: "Copy",
      successTips: "Copied!",
      failTips: "Copy failed!"
    },
    mermaid: {
      flow: "flow",
      sequence: "sequence",
      gantt: "gantt",
      class: "class",
      state: "state",
      pie: "pie",
      relationship: "relationship",
      journey: "journey"
    },
    katex: {
      inline: "inline",
      block: "block"
    },
    footer: {
      markdownTotal: "Character Count",
      scrollAuto: "Scroll Auto"
    }
  }
}, Loe = `${Mn}/mermaid/10.6.1/mermaid.esm.min.mjs`, i2 = {
  js: `${Mn}/KaTeX/0.16.9/katex.min.js`,
  css: `${Mn}/KaTeX/0.16.9/katex.min.css`
}, r2 = {
  a11y: {
    light: `${Mn}/highlight.js/11.8.0/styles/a11y-light.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/a11y-dark.min.css`
  },
  atom: {
    light: `${Mn}/highlight.js/11.8.0/styles/atom-one-light.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/atom-one-dark.min.css`
  },
  github: {
    light: `${Mn}/highlight.js/11.8.0/styles/github.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/github-dark.min.css`
  },
  gradient: {
    light: `${Mn}/highlight.js/11.8.0/styles/gradient-light.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/gradient-dark.min.css`
  },
  kimbie: {
    light: `${Mn}/highlight.js/11.8.0/styles/kimbie-light.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/kimbie-dark.min.css`
  },
  paraiso: {
    light: `${Mn}/highlight.js/11.8.0/styles/paraiso-light.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/paraiso-dark.min.css`
  },
  qtcreator: {
    light: `${Mn}/highlight.js/11.8.0/styles/qtcreator-light.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/qtcreator-dark.min.css`
  },
  stackoverflow: {
    light: `${Mn}/highlight.js/11.8.0/styles/stackoverflow-light.min.css`,
    dark: `${Mn}/highlight.js/11.8.0/styles/stackoverflow-dark.min.css`
  }
}, oo = {
  editorExtensions: {},
  editorConfig: {},
  codeMirrorExtensions: (n, e) => e,
  markdownItConfig: () => {
  },
  markdownItPlugins: (n) => n,
  iconfontType: "svg",
  mermaidConfig: (n) => n
}, nx = (n, e = 200) => {
  let t = 0;
  return (...i) => new Promise((r) => {
    t && (clearTimeout(t), r("cancel")), t = window.setTimeout(() => {
      n.apply(void 0, i), t = 0, r("done");
    }, e);
  });
}, eO = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`;
var Ioe = Object.defineProperty, Boe = (n, e, t) => e in n ? Ioe(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Qoe = (n, e, t) => (Boe(n, typeof e != "symbol" ? e + "" : e, t), t);
let zoe = class {
  constructor() {
    Qoe(this, "pools", {});
  }
  // 移除事件监听
  remove(e, t, i) {
    const r = this.pools[e] && this.pools[e][t];
    r && (this.pools[e][t] = r.filter((s) => s !== i));
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(e) {
    this.pools[e] = {};
  }
  // 注册事件监听
  on(e, t) {
    return this.pools[e] || (this.pools[e] = {}), this.pools[e][t.name] || (this.pools[e][t.name] = []), this.pools[e][t.name].push(t.callback), this.pools[e][t.name].includes(t.callback);
  }
  // 触发事件
  emit(e, t, ...i) {
    this.pools[e] || (this.pools[e] = {});
    const r = this.pools[e][t];
    r && r.forEach((s) => {
      try {
        s(...i);
      } catch (o) {
        console.error(`${t} monitor event exception！`, o);
      }
    });
  }
};
const yl = new zoe(), joe = "buildFinished", s2 = "catalogChanged", Voe = "pushCatalog", KR = "rerender", Foe = (n) => {
  if (!n)
    return n;
  const e = n.split(`
`), t = ['<span rn-wrapper aria-hidden="true">'];
  return e.forEach(() => {
    t.push("<span></span>");
  }), t.push("</span>"), `<span class="code-block">${n}</span>${t.join("")}`;
}, Gl = (n, e = "") => {
  const t = document.getElementById(n.id), i = n.onload;
  n.onload = null;
  const r = function(s) {
    typeof i == "function" && i.bind(this)(s), n.removeEventListener("load", r);
  };
  t ? e !== "" && (t.addEventListener("load", r), Reflect.get(window, e) && t.dispatchEvent(new Event("load"))) : (n.addEventListener("load", r), document.head.appendChild(n));
}, Zoe = nx((n, e, t) => {
  const i = document.getElementById(n);
  i && i.setAttribute(e, t);
}, 10);
class $t {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    [e, t] = Fu(this, e, t);
    let r = [];
    return this.decompose(
      0,
      e,
      r,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      r,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      r,
      1
      /* Open.From */
    ), Ys.from(r, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = Fu(this, e, t);
    let i = [];
    return this.decompose(e, t, i, 0), Ys.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), r = new md(this), s = new md(e);
    for (let o = t, a = t; ; ) {
      if (r.next(o), s.next(o), o = 0, r.lineBreak != s.lineBreak || r.done != s.done || r.value != s.value)
        return !1;
      if (a += r.value.length, r.done || a >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new md(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new JR(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let r = this.line(e).from;
      i = this.iterRange(r, Math.max(r, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new e3(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? $t.empty : e.length <= 32 ? new kn(e) : Ys.from(kn.split(e, []));
  }
}
class kn extends $t {
  constructor(e, t = qoe(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, r) {
    for (let s = 0; ; s++) {
      let o = this.text[s], a = r + o.length;
      if ((t ? i : a) >= e)
        return new Woe(r, a, i, o);
      r = a + 1, i++;
    }
  }
  decompose(e, t, i, r) {
    let s = e <= 0 && t >= this.length ? this : new kn(o2(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (r & 1) {
      let o = i.pop(), a = wg(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32)
        i.push(new kn(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        i.push(new kn(a.slice(0, l)), new kn(a.slice(l)));
      }
    } else
      i.push(s);
  }
  replace(e, t, i) {
    if (!(i instanceof kn))
      return super.replace(e, t, i);
    [e, t] = Fu(this, e, t);
    let r = wg(this.text, wg(i.text, o2(this.text, 0, e)), t), s = this.length + i.length - (t - e);
    return r.length <= 32 ? new kn(r, s) : Ys.from(kn.split(r, []), s);
  }
  sliceString(e, t = this.length, i = `
`) {
    [e, t] = Fu(this, e, t);
    let r = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let a = this.text[o], l = s + a.length;
      s > e && o && (r += i), e < l && t > s && (r += a.slice(Math.max(0, e - s), t - s)), s = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], r = -1;
    for (let s of e)
      i.push(s), r += s.length + 1, i.length == 32 && (t.push(new kn(i, r)), i = [], r = -1);
    return r > -1 && t.push(new kn(i, r)), t;
  }
}
class Ys extends $t {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, r) {
    for (let s = 0; ; s++) {
      let o = this.children[s], a = r + o.length, l = i + o.lines - 1;
      if ((t ? l : a) >= e)
        return o.lineInner(e, t, i, r);
      r = a + 1, i = l + 1;
    }
  }
  decompose(e, t, i, r) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let a = this.children[s], l = o + a.length;
      if (e <= l && t >= o) {
        let c = r & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0));
        o >= e && l <= t && !c ? i.push(a) : a.decompose(e - o, t - o, i, c);
      }
      o = l + 1;
    }
  }
  replace(e, t, i) {
    if ([e, t] = Fu(this, e, t), i.lines < this.lines)
      for (let r = 0, s = 0; r < this.children.length; r++) {
        let o = this.children[r], a = s + o.length;
        if (e >= s && t <= a) {
          let l = o.replace(e - s, t - s, i), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[r] = l, new Ys(u, this.length - (t - e) + i.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    [e, t] = Fu(this, e, t);
    let r = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let a = this.children[s], l = o + a.length;
      o > e && s && (r += i), e < l && t > o && (r += a.sliceString(e - o, t - o, i)), o = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Ys))
      return 0;
    let i = 0, [r, s, o, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; r += t, s += t) {
      if (r == o || s == a)
        return i;
      let l = this.children[r], c = e.children[s];
      if (l != c)
        return i + l.scanIdentical(c, t);
      i += l.length + 1;
    }
  }
  static from(e, t = e.reduce((i, r) => i + r.length + 1, -1)) {
    let i = 0;
    for (let f of e)
      i += f.lines;
    if (i < 32) {
      let f = [];
      for (let p of e)
        p.flatten(f);
      return new kn(f, t);
    }
    let r = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), s = r << 1, o = r >> 1, a = [], l = 0, c = -1, u = [];
    function h(f) {
      let p;
      if (f.lines > s && f instanceof Ys)
        for (let g of f.children)
          h(g);
      else
        f.lines > o && (l > o || !l) ? (d(), a.push(f)) : f instanceof kn && l && (p = u[u.length - 1]) instanceof kn && f.lines + p.lines <= 32 ? (l += f.lines, c += f.length + 1, u[u.length - 1] = new kn(p.text.concat(f.text), p.length + 1 + f.length)) : (l + f.lines > r && d(), l += f.lines, c += f.length + 1, u.push(f));
    }
    function d() {
      l != 0 && (a.push(u.length == 1 ? u[0] : Ys.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let f of e)
      h(f);
    return d(), a.length == 1 ? a[0] : new Ys(a, t);
  }
}
$t.empty = /* @__PURE__ */ new kn([""], 0);
function qoe(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function wg(n, e, t = 0, i = 1e9) {
  for (let r = 0, s = 0, o = !0; s < n.length && r <= i; s++) {
    let a = n[s], l = r + a.length;
    l >= t && (l > i && (a = a.slice(0, i - r)), r < t && (a = a.slice(t - r)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), r = l + 1;
  }
  return e;
}
function o2(n, e, t) {
  return wg(n, [""], e, t);
}
class md {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof kn ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, r = this.nodes[i], s = this.offsets[i], o = s >> 1, a = r instanceof kn ? r.text.length : r.children.length;
      if (o == (t > 0 ? a : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (r instanceof kn) {
        let l = r.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = r.children[o + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof kn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class JR {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new md(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: r } = this.cursor.next(e);
    return this.pos += (r.length + e) * t, this.value = r.length <= i ? r : t < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class e3 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: r } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && ($t.prototype[Symbol.iterator] = function() {
  return this.iter();
}, md.prototype[Symbol.iterator] = JR.prototype[Symbol.iterator] = e3.prototype[Symbol.iterator] = function() {
  return this;
});
class Woe {
  /**
  @internal
  */
  constructor(e, t, i, r) {
    this.from = e, this.to = t, this.number = i, this.text = r;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Fu(n, e, t) {
  return e = Math.max(0, Math.min(n.length, e)), [e, Math.max(e, Math.min(n.length, t))];
}
let Xc = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((n) => n ? parseInt(n, 36) : 1);
for (let n = 1; n < Xc.length; n++)
  Xc[n] += Xc[n - 1];
function Hoe(n) {
  for (let e = 1; e < Xc.length; e += 2)
    if (Xc[e] > n)
      return Xc[e - 1] <= n;
  return !1;
}
function a2(n) {
  return n >= 127462 && n <= 127487;
}
const l2 = 8205;
function ki(n, e, t = !0, i = !0) {
  return (t ? t3 : Xoe)(n, e, i);
}
function t3(n, e, t) {
  if (e == n.length)
    return e;
  e && n3(n.charCodeAt(e)) && i3(n.charCodeAt(e - 1)) && e--;
  let i = yi(n, e);
  for (e += jr(i); e < n.length; ) {
    let r = yi(n, e);
    if (i == l2 || r == l2 || t && Hoe(r))
      e += jr(r), i = r;
    else if (a2(r)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && a2(yi(n, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function Xoe(n, e, t) {
  for (; e > 0; ) {
    let i = t3(n, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function n3(n) {
  return n >= 56320 && n < 57344;
}
function i3(n) {
  return n >= 55296 && n < 56320;
}
function yi(n, e) {
  let t = n.charCodeAt(e);
  if (!i3(t) || e + 1 == n.length)
    return t;
  let i = n.charCodeAt(e + 1);
  return n3(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function ix(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function jr(n) {
  return n < 65536 ? 1 : 2;
}
const tO = /\r\n?|\n/;
var xi = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(xi || (xi = {}));
class ao {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, r = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(i, r, s), r += s) : r += o, i += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    nO(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], r = this.sections[t++];
      r < 0 ? e.push(i, r) : e.push(r, i);
    }
    return new ao(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : r3(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : iO(this, e, t);
  }
  mapPos(e, t = -1, i = xi.Simple) {
    let r = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = r + a;
      if (l < 0) {
        if (c > e)
          return s + (e - r);
        s += a;
      } else {
        if (i != xi.Simple && c >= e && (i == xi.TrackDel && r < e && c > e || i == xi.TrackBefore && r < e || i == xi.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !a)
          return e == r || t < 0 ? s : s + l;
        s += l;
      }
      r = c;
    }
    if (e > r)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, r = 0; i < this.sections.length && r <= t; ) {
      let s = this.sections[i++], o = this.sections[i++], a = r + s;
      if (o >= 0 && r <= t && a >= e)
        return r < e && a > t ? "cover" : !0;
      r = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], r = this.sections[t++];
      e += (e ? " " : "") + i + (r >= 0 ? ":" + r : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ao(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new ao(e);
  }
}
class Hn extends ao {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return nO(this, (t, i, r, s, o) => e = e.replace(r, r + (i - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return iO(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let r = 0, s = 0; r < t.length; r += 2) {
      let o = t[r], a = t[r + 1];
      if (a >= 0) {
        t[r] = a, t[r + 1] = o;
        let l = r >> 1;
        for (; i.length < l; )
          i.push($t.empty);
        i.push(o ? e.slice(s, s + o) : $t.empty);
      }
      s += o;
    }
    return new Hn(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : r3(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : iO(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    nO(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ao.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], r = [], s = new Jd(this);
    e:
      for (let o = 0, a = 0; ; ) {
        let l = o == e.length ? 1e9 : e[o++];
        for (; a < l || a == l && s.len == 0; ) {
          if (s.done)
            break e;
          let u = Math.min(s.len, l - a);
          _i(r, u, -1);
          let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          _i(t, u, h), h > 0 && Ea(i, t, s.text), s.forward(u), a += u;
        }
        let c = e[o++];
        for (; a < c; ) {
          if (s.done)
            break e;
          let u = Math.min(s.len, c - a);
          _i(t, u, -1), _i(r, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), a += u;
        }
      }
    return {
      changes: new Hn(t, i),
      filtered: ao.create(r)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], r = this.sections[t + 1];
      r < 0 ? e.push(i) : r == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let r = [], s = [], o = 0, a = null;
    function l(u = !1) {
      if (!u && !r.length)
        return;
      o < t && _i(r, t - o, -1);
      let h = new Hn(r, s);
      a = a ? a.compose(h.map(a)) : h, r = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof Hn) {
        if (u.length != t)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${t})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: h, to: d = h, insert: f } = u;
        if (h > d || h < 0 || d > t)
          throw new RangeError(`Invalid change range ${h} to ${d} (in doc of length ${t})`);
        let p = f ? typeof f == "string" ? $t.of(f.split(i || tO)) : f : $t.empty, g = p.length;
        if (h == d && g == 0)
          return;
        h < o && l(), h > o && _i(r, h - o, -1), _i(r, d - h, g), Ea(s, r, p), o = d;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Hn(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; i.length < r; )
            i.push($t.empty);
          i[r] = $t.of(s.slice(1)), t.push(s[0], i[r].length);
        }
      }
    }
    return new Hn(t, i);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new Hn(e, t);
  }
}
function _i(n, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let r = n.length - 2;
  r >= 0 && t <= 0 && t == n[r + 1] ? n[r] += e : e == 0 && n[r] == 0 ? n[r + 1] += t : i ? (n[r] += e, n[r + 1] += t) : n.push(e, t);
}
function Ea(n, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < i; )
      n.push($t.empty);
    n.push(t);
  }
}
function nO(n, e, t) {
  let i = n.inserted;
  for (let r = 0, s = 0, o = 0; o < n.sections.length; ) {
    let a = n.sections[o++], l = n.sections[o++];
    if (l < 0)
      r += a, s += a;
    else {
      let c = r, u = s, h = $t.empty;
      for (; c += a, u += l, l && i && (h = h.append(i[o - 2 >> 1])), !(t || o == n.sections.length || n.sections[o + 1] < 0); )
        a = n.sections[o++], l = n.sections[o++];
      e(r, c, s, u, h), r = c, s = u;
    }
  }
}
function iO(n, e, t, i = !1) {
  let r = [], s = i ? [] : null, o = new Jd(n), a = new Jd(e);
  for (let l = -1; ; )
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      _i(r, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !t))) {
      let c = a.len;
      for (_i(r, a.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= u && (_i(r, 0, o.ins), s && Ea(s, r, o.text), l = o.i), o.forward(u), c -= u;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let h = Math.min(u, a.len);
          c += h, u -= h, a.forward(h);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      _i(r, c, l < o.i ? o.ins : 0), s && l < o.i && Ea(s, r, o.text), l = o.i, o.forward(o.len - u);
    } else {
      if (o.done && a.done)
        return s ? Hn.createSet(r, s) : ao.create(r);
      throw new Error("Mismatched change set lengths");
    }
}
function r3(n, e, t = !1) {
  let i = [], r = t ? [] : null, s = new Jd(n), o = new Jd(e);
  for (let a = !1; ; ) {
    if (s.done && o.done)
      return r ? Hn.createSet(i, r) : ao.create(i);
    if (s.ins == 0)
      _i(i, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done)
      _i(i, 0, o.ins, a), r && Ea(r, i, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len), c = i.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          _i(i, l, u, a), r && u && Ea(r, i, o.text);
        } else
          o.ins == -1 ? (_i(i, s.off ? 0 : s.len, l, a), r && Ea(r, i, s.textBit(l))) : (_i(i, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), r && !o.off && Ea(r, i, o.text));
        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || i.length > c), s.forward2(l), o.forward(l);
      }
    }
  }
}
class Jd {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? $t.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? $t.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class $l {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, r;
    return this.empty ? i = r = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), r = e.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new $l(i, r, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return ue.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return ue.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return ue.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new $l(e, t, i);
  }
}
class ue {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : ue.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new ue([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return ue.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, ue.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new ue(e.ranges.map((t) => $l.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new ue([ue.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, r = 0; r < e.length; r++) {
      let s = e[r];
      if (s.empty ? s.from <= i : s.from < i)
        return ue.normalized(e.slice(), t);
      i = s.to;
    }
    return new ue(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, r) {
    return $l.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (r ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i, r) {
    let s = (i ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r));
    return t < e ? $l.create(t, e, 48 | s) : $l.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((r, s) => r.from - s.from), t = e.indexOf(i);
    for (let r = 1; r < e.length; r++) {
      let s = e[r], o = e[r - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from, l = Math.max(s.to, o.to);
        r <= t && t--, e.splice(--r, 2, s.anchor > s.head ? ue.range(l, a) : ue.range(a, l));
      }
    }
    return new ue(e, t);
  }
}
function s3(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let rx = 0;
class Me {
  constructor(e, t, i, r, s) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = r, this.id = rx++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Me(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : sx), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new xg([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xg(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xg(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function sx(n, e) {
  return n == e || n.length == e.length && n.every((t, i) => t === e[i]);
}
class xg {
  constructor(e, t, i, r) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = r, this.id = rx++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, r = this.facet.compareInput, s = this.id, o = e[s] >> 1, a = this.type == 2, l = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? c = !0 : ((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1 || u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = i(h), 1;
      },
      update(h, d) {
        if (l && d.docChanged || c && (d.docChanged || d.selection) || rO(h, u)) {
          let f = i(h);
          if (a ? !c2(f, h.values[o], r) : !r(f, h.values[o]))
            return h.values[o] = f, 1;
        }
        return 0;
      },
      reconfigure: (h, d) => {
        let f, p = d.config.address[s];
        if (p != null) {
          let g = Om(d, p);
          if (this.dependencies.every((m) => m instanceof Me ? d.facet(m) === h.facet(m) : m instanceof hi ? d.field(m, !1) == h.field(m, !1) : !0) || (a ? c2(f = i(h), g, r) : r(f = i(h), g)))
            return h.values[o] = g, 0;
        } else
          f = i(h);
        return h.values[o] = f, 1;
      }
    };
  }
}
function c2(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (!t(n[i], e[i]))
      return !1;
  return !0;
}
function rO(n, e) {
  let t = !1;
  for (let i of e)
    vd(n, i) & 1 && (t = !0);
  return t;
}
function Yoe(n, e, t) {
  let i = t.map((l) => n[l.id]), r = t.map((l) => l.type), s = i.filter((l) => !(l & 1)), o = n[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < i.length; u++) {
      let h = Om(l, i[u]);
      if (r[u] == 2)
        for (let d of h)
          c.push(d);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of i)
        vd(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!rO(l, s))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);
    },
    reconfigure(l, c) {
      let u = rO(l, i), h = c.config.facets[e.id], d = c.facet(e);
      if (h && !u && sx(t, h))
        return l.values[o] = d, 0;
      let f = a(l);
      return e.compare(f, d) ? (l.values[o] = d, 0) : (l.values[o] = f, 1);
    }
  };
}
const u2 = /* @__PURE__ */ Me.define({ static: !0 });
class hi {
  constructor(e, t, i, r, s) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = r, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new hi(rx++, e.create, e.update, e.compare || ((i, r) => i === r), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(u2).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, r) => {
        let s = i.values[t], o = this.updateF(s, r);
        return this.compareF(s, o) ? 0 : (i.values[t] = o, 1);
      },
      reconfigure: (i, r) => r.config.address[this.id] != null ? (i.values[t] = r.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, u2.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Ol = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Th(n) {
  return (e) => new o3(e, n);
}
const hc = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Th(Ol.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Th(Ol.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Th(Ol.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Th(Ol.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Th(Ol.lowest)
};
class o3 {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Dv {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new sO(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Dv.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class sO {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class ym {
  constructor(e, t, i, r, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = r, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let r = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let d of Uoe(e, t, o))
      d instanceof hi ? r.push(d) : (s[d.facet.id] || (s[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let d of r)
      a[d.id] = c.length << 1, c.push((f) => d.slot(f));
    let u = i == null ? void 0 : i.config.facets;
    for (let d in s) {
      let f = s[d], p = f[0].facet, g = u && u[d] || [];
      if (f.every(
        (m) => m.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, sx(g, f))
          l.push(i.facet(p));
        else {
          let m = p.combine(f.map((v) => v.value));
          l.push(i && p.compare(m, i.facet(p)) ? i.facet(p) : m);
        }
      else {
        for (let m of f)
          m.type == 0 ? (a[m.id] = l.length << 1 | 1, l.push(m.value)) : (a[m.id] = c.length << 1, c.push((v) => m.dynamicSlot(v)));
        a[p.id] = c.length << 1, c.push((m) => Yoe(m, p, f));
      }
    }
    let h = c.map((d) => d(a));
    return new ym(e, o, h, a, l, s);
  }
}
function Uoe(n, e, t) {
  let i = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function s(o, a) {
    let l = r.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = i[l].indexOf(o);
      c > -1 && i[l].splice(c, 1), o instanceof sO && t.delete(o.compartment);
    }
    if (r.set(o, a), Array.isArray(o))
      for (let c of o)
        s(c, a);
    else if (o instanceof sO) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, a);
    } else if (o instanceof o3)
      s(o.inner, o.prec);
    else if (o instanceof hi)
      i[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof xg)
      i[a].push(o), o.facet.extensions && s(o.facet.extensions, Ol.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, a);
    }
  }
  return s(n, Ol.default), i.reduce((o, a) => o.concat(a));
}
function vd(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = n.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  n.status[t] = 4;
  let r = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | r;
}
function Om(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const a3 = /* @__PURE__ */ Me.define(), oO = /* @__PURE__ */ Me.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), l3 = /* @__PURE__ */ Me.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), c3 = /* @__PURE__ */ Me.define(), u3 = /* @__PURE__ */ Me.define(), h3 = /* @__PURE__ */ Me.define(), d3 = /* @__PURE__ */ Me.define({
  combine: (n) => n.length ? n[0] : !1
});
class na {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new Goe();
  }
}
class Goe {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new na(this, e);
  }
}
class Koe {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new ct(this, e);
  }
}
class ct {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new ct(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new Koe(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let r of e) {
      let s = r.map(t);
      s && i.push(s);
    }
    return i;
  }
}
ct.reconfigure = /* @__PURE__ */ ct.define();
ct.appendConfig = /* @__PURE__ */ ct.define();
class Dn {
  constructor(e, t, i, r, s, o) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = r, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, i && s3(i, t.newLength), s.some((a) => a.type == Dn.time) || (this.annotations = s.concat(Dn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, i, r, s, o) {
    return new Dn(e, t, i, r, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(Dn.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
Dn.time = /* @__PURE__ */ na.define();
Dn.userEvent = /* @__PURE__ */ na.define();
Dn.addToHistory = /* @__PURE__ */ na.define();
Dn.remote = /* @__PURE__ */ na.define();
function Joe(n, e) {
  let t = [];
  for (let i = 0, r = 0; ; ) {
    let s, o;
    if (i < n.length && (r == e.length || e[r] >= n[i]))
      s = n[i++], o = n[i++];
    else if (r < e.length)
      s = e[r++], o = e[r++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function f3(n, e, t) {
  var i;
  let r, s, o;
  return t ? (r = e.changes, s = Hn.empty(e.changes.length), o = n.changes.compose(e.changes)) : (r = e.changes.map(n.changes), s = n.changes.mapDesc(e.changes, !0), o = n.changes.compose(r)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (i = n.selection) === null || i === void 0 ? void 0 : i.map(r),
    effects: ct.mapEffects(n.effects, r).concat(ct.mapEffects(e.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function aO(n, e, t) {
  let i = e.selection, r = Yc(e.annotations);
  return e.userEvent && (r = r.concat(Dn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Hn ? e.changes : Hn.of(e.changes || [], t, n.facet(l3)),
    selection: i && (i instanceof ue ? i : ue.single(i.anchor, i.head)),
    effects: Yc(e.effects),
    annotations: r,
    scrollIntoView: !!e.scrollIntoView
  };
}
function p3(n, e, t) {
  let i = aO(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    i = f3(i, aO(n, e[s], o ? i.changes.newLength : n.doc.length), o);
  }
  let r = Dn.create(n, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return tae(t ? eae(r) : r);
}
function eae(n) {
  let e = n.startState, t = !0;
  for (let r of e.facet(c3)) {
    let s = r(n);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : Joe(t, s));
  }
  if (t !== !0) {
    let r, s;
    if (t === !1)
      s = n.changes.invertedDesc, r = Hn.empty(e.doc.length);
    else {
      let o = n.changes.filter(t);
      r = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = Dn.create(e, r, n.selection && n.selection.map(s), ct.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let i = e.facet(u3);
  for (let r = i.length - 1; r >= 0; r--) {
    let s = i[r](n);
    s instanceof Dn ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Dn ? n = s[0] : n = p3(e, Yc(s), !1);
  }
  return n;
}
function tae(n) {
  let e = n.startState, t = e.facet(h3), i = n;
  for (let r = t.length - 1; r >= 0; r--) {
    let s = t[r](n);
    s && Object.keys(s).length && (i = f3(i, aO(e, s, n.changes.newLength), !0));
  }
  return i == n ? n : Dn.create(e, n.changes, n.selection, i.effects, i.annotations, i.scrollIntoView);
}
const nae = [];
function Yc(n) {
  return n == null ? nae : Array.isArray(n) ? n : [n];
}
var ln = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(ln || (ln = {}));
const iae = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let lO;
try {
  lO = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function rae(n) {
  if (lO)
    return lO.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || iae.test(t)))
      return !0;
  }
  return !1;
}
function sae(n) {
  return (e) => {
    if (!/\S/.test(e))
      return ln.Space;
    if (rae(e))
      return ln.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return ln.Word;
    return ln.Other;
  };
}
class Et {
  constructor(e, t, i, r, s, o) {
    this.config = e, this.doc = t, this.selection = i, this.values = r, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      vd(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return vd(this, i), Om(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return p3(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: r } = t;
    for (let a of e.effects)
      a.is(Dv.reconfigure) ? (t && (r = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => r.set(c, l)), t = null), r.set(a.value.compartment, a.value.extension)) : a.is(ct.reconfigure) ? (t = null, i = a.value) : a.is(ct.appendConfig) && (t = null, i = Yc(i).concat(a.value));
    let s;
    t ? s = e.startState.values.slice() : (t = ym.resolve(i, r, this), s = new Et(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(oO) ? e.newSelection : e.newSelection.asSingle();
    new Et(t, e.newDoc, o, s, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: ue.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), r = this.changes(i.changes), s = [i.range], o = Yc(i.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), c = this.changes(l.changes), u = c.map(r);
      for (let d = 0; d < a; d++)
        s[d] = s[d].map(u);
      let h = r.mapDesc(c, !0);
      s.push(l.range.map(h)), r = r.compose(u), o = ct.mapEffects(o, u).concat(ct.mapEffects(Yc(l.effects), h));
    }
    return {
      changes: r,
      selection: ue.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Hn ? e : Hn.of(e, this.doc.length, this.facet(Et.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return $t.of(e.split(this.facet(Et.lineSeparator) || tO));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (vd(this, t), Om(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let r = e[i];
        r instanceof hi && this.config.address[r.id] != null && (t[i] = r.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (i) {
      for (let s in i)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = i[s], a = e[s];
          r.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return Et.create({
      doc: e.doc,
      selection: ue.fromJSON(e.selection),
      extensions: t.extensions ? r.concat([t.extensions]) : r
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = ym.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof $t ? e.doc : $t.of((e.doc || "").split(t.staticFacet(Et.lineSeparator) || tO)), r = e.selection ? e.selection instanceof ue ? e.selection : ue.single(e.selection.anchor, e.selection.head) : ue.single(0);
    return s3(r, i.length), t.staticFacet(oO) || (r = r.asSingle()), new Et(t, i, r, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Et.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Et.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(d3);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let i of this.facet(Et.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, r) => {
      if (r == "$")
        return "$";
      let s = +(r || 1);
      return !s || s > t.length ? i : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, i = -1) {
    let r = [];
    for (let s of this.facet(a3))
      for (let o of s(this, t, i))
        Object.prototype.hasOwnProperty.call(o, e) && r.push(o[e]);
    return r;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return sae(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: r } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - i, a = e - i;
    for (; o > 0; ) {
      let l = ki(t, o, !1);
      if (s(t.slice(l, o)) != ln.Word)
        break;
      o = l;
    }
    for (; a < r; ) {
      let l = ki(t, a);
      if (s(t.slice(a, l)) != ln.Word)
        break;
      a = l;
    }
    return o == a ? null : ue.range(o + i, a + i);
  }
}
Et.allowMultipleSelections = oO;
Et.tabSize = /* @__PURE__ */ Me.define({
  combine: (n) => n.length ? n[0] : 4
});
Et.lineSeparator = l3;
Et.readOnly = d3;
Et.phrases = /* @__PURE__ */ Me.define({
  compare(n, e) {
    let t = Object.keys(n), i = Object.keys(e);
    return t.length == i.length && t.every((r) => n[r] == e[r]);
  }
});
Et.languageData = a3;
Et.changeFilter = c3;
Et.transactionFilter = u3;
Et.transactionExtender = h3;
Dv.reconfigure = /* @__PURE__ */ ct.define();
function Oo(n, e, t = {}) {
  let i = {};
  for (let r of n)
    for (let s of Object.keys(r)) {
      let o = r[s], a = i[s];
      if (a === void 0)
        i[s] = o;
      else if (!(a === o || o === void 0))
        if (Object.hasOwnProperty.call(t, s))
          i[s] = t[s](a, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let r in e)
    i[r] === void 0 && (i[r] = e[r]);
  return i;
}
class Kl {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return cO.create(e, t, this);
  }
}
Kl.prototype.startSide = Kl.prototype.endSide = 0;
Kl.prototype.point = !1;
Kl.prototype.mapMode = xi.TrackDel;
let cO = class g3 {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new g3(e, t, i);
  }
};
function uO(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class ox {
  constructor(e, t, i, r) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, r = 0) {
    let s = i ? this.to : this.from;
    for (let o = r, a = s.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = s[l] - e || (i ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, t, i, r) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(i, 1e9, !1, s); s < o; s++)
      if (r(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], r = [], s = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, d, f;
      if (u == h) {
        let p = t.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (d = f = p, c.startSide != c.endSide && (f = t.mapPos(u, c.endSide), f < d)))
          continue;
      } else if (d = t.mapPos(u, c.startSide), f = t.mapPos(h, c.endSide), d > f || d == f && c.startSide > 0 && c.endSide <= 0)
        continue;
      (f - d || c.endSide - c.startSide) < 0 || (o < 0 && (o = d), c.point && (a = Math.max(a, f - d)), i.push(c), r.push(d - o), s.push(f - o));
    }
    return { mapped: i.length ? new ox(r, s, i, a) : null, pos: o };
  }
}
class kt {
  constructor(e, t, i, r) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = r;
  }
  /**
  @internal
  */
  static create(e, t, i, r) {
    return new kt(e, t, i, r);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: r = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (i && (t = t.slice().sort(uO)), this.isEmpty)
      return t.length ? kt.of(t) : this;
    let a = new m3(this, null, -1).goto(0), l = 0, c = [], u = new Fa();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let h = t[l++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!o || r > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || r > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(cO.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? kt.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: r, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], r = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        r = Math.max(r, l.maxPoint), t.push(l), i.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: h } = l.map(a, e);
        u && (r = Math.max(r, u.maxPoint), t.push(u), i.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new kt(i, t, s || kt.empty, r);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let s = this.chunkPos[r], o = this.chunk[r];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return ef.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return ef.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, r, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), a = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), l = h2(o, a, i), c = new _h(o, l, s), u = new _h(a, l, s);
    i.iterGaps((h, d, f) => d2(c, h, u, d, f, r)), i.empty && i.length == 0 && d2(c, 0, u, 0, 0, r);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, r) {
    r == null && (r = 999999999);
    let s = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0), o = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let a = h2(s, o), l = new _h(s, a, 0).goto(i), c = new _h(o, a, 0).goto(i);
    for (; ; ) {
      if (l.to != c.to || !hO(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > r)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, r, s = -1) {
    let o = new _h(e, null, s).goto(t), a = t, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, i);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < t ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);
        r.point(a, c, o.point, u, h, o.pointRank), l = Math.min(o.openEnd(c), u.length);
      } else
        c > a && (r.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > i)
        return l + (o.point && o.to > i ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let i = new Fa();
    for (let r of e instanceof cO ? [e] : t ? oae(e) : e)
      i.add(r.from, r.to, r.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return kt.empty;
    let t = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let r = e[i]; r != kt.empty; r = r.nextLayer)
        t = new kt(r.chunkPos, r.chunk, t, Math.max(r.maxPoint, t.maxPoint));
    return t;
  }
}
kt.empty = /* @__PURE__ */ new kt([], [], null, -1);
function oae(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let i = n[t];
      if (uO(e, i) > 0)
        return n.slice().sort(uO);
      e = i;
    }
  return n;
}
kt.empty.nextLayer = kt.empty;
class Fa {
  finishChunk(e) {
    this.chunks.push(new ox(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new Fa())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let r = e - this.lastTo || i.startSide - this.last.endSide;
    if (r <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(kt.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = kt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function h2(n, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && i.set(s.chunk[o], s.chunkPos[o]);
  let r = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = i.get(s.chunk[o]);
      a != null && (t ? t.mapPos(a) : a) == s.chunkPos[o] && !(t != null && t.touchesRange(a, a + s.chunk[o].length)) && r.add(s.chunk[o]);
    }
  return r;
}
class m3 {
  constructor(e, t, i, r = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < e || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class ef {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let r = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && r.push(new m3(o, t, i, s));
    return r.length == 1 ? r[0] : new ef(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      V0(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      V0(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), V0(this.heap, 0);
    }
  }
}
function V0(n, e) {
  for (let t = n[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= n.length)
      break;
    let r = n[i];
    if (i + 1 < n.length && r.compare(n[i + 1]) >= 0 && (r = n[i + 1], i++), t.compare(r) < 0)
      break;
    n[i] = t, n[e] = r, e = i;
  }
}
class _h {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = ef.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Op(this.active, e), Op(this.activeTo, e), Op(this.activeRank, e), this.minActive = f2(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: r, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || r - this.activeTo[t]) > 0; )
      t++;
    wp(this.active, t, i), wp(this.activeTo, t, r), wp(this.activeRank, t, s), e && wp(e, t, this.cursor.from), this.minActive = f2(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > e) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && Op(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let r = i.length - 1; r >= 0 && i[r] < e; r--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function d2(n, e, t, i, r, s) {
  n.goto(e), t.goto(i);
  let o = i + r, a = i, l = i - e;
  for (; ; ) {
    let c = n.to + l - t.to || n.endSide - t.endSide, u = c < 0 ? n.to + l : t.to, h = Math.min(u, o);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && hO(n.activeForPoint(n.to), t.activeForPoint(t.to)) || s.comparePoint(a, h, n.point, t.point) : h > a && !hO(n.active, t.active) && s.compareRange(a, h, n.active, t.active), u > o)
      break;
    a = u, c <= 0 && n.next(), c >= 0 && t.next();
  }
}
function hO(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function Op(n, e) {
  for (let t = e, i = n.length - 1; t < i; t++)
    n[t] = n[t + 1];
  n.pop();
}
function wp(n, e, t) {
  for (let i = n.length - 1; i >= e; i--)
    n[i + 1] = n[i];
  n[e] = t;
}
function f2(n, e) {
  let t = -1, i = 1e9;
  for (let r = 0; r < e.length; r++)
    (e[r] - i || n[r].endSide - n[t].endSide) < 0 && (t = r, i = e[r]);
  return t;
}
function bh(n, e, t = n.length) {
  let i = 0;
  for (let r = 0; r < t; )
    n.charCodeAt(r) == 9 ? (i += e - i % e, r++) : (i++, r = ki(n, r));
  return i;
}
function dO(n, e, t, i) {
  for (let r = 0, s = 0; ; ) {
    if (s >= e)
      return r;
    if (r == n.length)
      break;
    s += n.charCodeAt(r) == 9 ? t - s % t : 1, r = ki(n, r);
  }
  return i === !0 ? -1 : n.length;
}
const fO = "ͼ", p2 = typeof Symbol > "u" ? "__" + fO : Symbol.for(fO), pO = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), g2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Za {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function r(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), d = h && h[1] == "keyframes";
      if (h && a == null)
        return l.push(o[0] + ";");
      for (let f in a) {
        let p = a[f];
        if (/&/.test(f))
          s(
            f.split(/,\s*/).map((g) => o.map((m) => g.replace(/&/, m))).reduce((g, m) => g.concat(m)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!h)
            throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          s(r(f), p, u, d);
        } else
          p != null && u.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (u.length || d) && l.push((i && !h && !c ? o.map(i) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e)
      s(r(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = g2[p2] || 1;
    return g2[p2] = e + 1, fO + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, i) {
    let r = e[pO], s = i && i.nonce;
    r ? s && r.setNonce(s) : r = new aae(e, s), r.mount(Array.isArray(t) ? t : [t]);
  }
}
let m2 = /* @__PURE__ */ new Map();
class aae {
  constructor(e, t) {
    let i = e.ownerDocument || e, r = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
      let s = m2.get(i);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[pO] = s;
      this.sheet = new r.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], m2.set(i, this);
    } else {
      this.styleTag = i.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[pO] = this;
  }
  mount(e) {
    let t = this.sheet, i = 0, r = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], a = this.modules.indexOf(o);
      if (a < r && a > -1 && (this.modules.splice(a, 1), r--, a = -1), a == -1) {
        if (this.modules.splice(r++, 0, o), t)
          for (let l = 0; l < o.rules.length; l++)
            t.insertRule(o.rules[l], i++);
      } else {
        for (; r < a; )
          i += this.modules[r++].rules.length;
        i += o.rules.length, r++;
      }
    }
    if (!t) {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var qa = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, tf = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, lae = typeof navigator < "u" && /Mac/.test(navigator.platform), cae = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Oi = 0; Oi < 10; Oi++)
  qa[48 + Oi] = qa[96 + Oi] = String(Oi);
for (var Oi = 1; Oi <= 24; Oi++)
  qa[Oi + 111] = "F" + Oi;
for (var Oi = 65; Oi <= 90; Oi++)
  qa[Oi] = String.fromCharCode(Oi + 32), tf[Oi] = String.fromCharCode(Oi);
for (var F0 in qa)
  tf.hasOwnProperty(F0) || (tf[F0] = qa[F0]);
function uae(n) {
  var e = lae && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || cae && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? tf : qa)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function wm(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function gO(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function hae(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Sg(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return gO(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function nf(n) {
  return n.nodeType == 3 ? Jl(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function bd(n, e, t, i) {
  return t ? v2(n, e, t, i, -1) || v2(n, e, t, i, 1) : !1;
}
function rf(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function v2(n, e, t, i, r) {
  for (; ; ) {
    if (n == t && e == i)
      return !0;
    if (e == (r < 0 ? 0 : Ho(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = rf(n) + (r < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (r < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = r < 0 ? Ho(n) : 0;
    } else
      return !1;
  }
}
function Ho(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function ax(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function dae(n) {
  return {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function v3(n, e) {
  let t = e.width / n.offsetWidth, i = e.height / n.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - n.offsetWidth) < 1) && (t = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - n.offsetHeight) < 1) && (i = 1), { scaleX: t, scaleY: i };
}
function fae(n, e, t, i, r, s, o, a) {
  let l = n.ownerDocument, c = l.defaultView || window;
  for (let u = n, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let d, f = u == l.body, p = 1, g = 1;
      if (f)
        d = dae(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let y = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: g } = v3(u, y)), d = {
          left: y.left,
          right: y.left + u.clientWidth * p,
          top: y.top,
          bottom: y.top + u.clientHeight * g
        };
      }
      let m = 0, v = 0;
      if (r == "nearest")
        e.top < d.top ? (v = -(d.top - e.top + o), t > 0 && e.bottom > d.bottom + v && (v = e.bottom - d.bottom + v + o)) : e.bottom > d.bottom && (v = e.bottom - d.bottom + o, t < 0 && e.top - v < d.top && (v = -(d.top + v - e.top + o)));
      else {
        let y = e.bottom - e.top, b = d.bottom - d.top;
        v = (r == "center" && y <= b ? e.top + y / 2 - b / 2 : r == "start" || r == "center" && t < 0 ? e.top - o : e.bottom - b + o) - d.top;
      }
      if (i == "nearest" ? e.left < d.left ? (m = -(d.left - e.left + s), t > 0 && e.right > d.right + m && (m = e.right - d.right + m + s)) : e.right > d.right && (m = e.right - d.right + s, t < 0 && e.left < d.left + m && (m = -(d.left + m - e.left + s))) : m = (i == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : i == "start" == a ? e.left - s : e.right - (d.right - d.left) + s) - d.left, m || v)
        if (f)
          c.scrollBy(m, v);
        else {
          let y = 0, b = 0;
          if (v) {
            let w = u.scrollTop;
            u.scrollTop += v / g, b = (u.scrollTop - w) * g;
          }
          if (m) {
            let w = u.scrollLeft;
            u.scrollLeft += m / p, y = (u.scrollLeft - w) * p;
          }
          e = {
            left: e.left - y,
            top: e.top - b,
            right: e.right - y,
            bottom: e.bottom - b
          }, y && Math.abs(y - m) < 1 && (i = "nearest"), b && Math.abs(b - v) < 1 && (r = "nearest");
        }
      if (f)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function pae(n) {
  let e = n.ownerDocument;
  for (let t = n.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class gae {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? Ho(t) : 0), i, Math.min(e.focusOffset, i ? Ho(i) : 0));
  }
  set(e, t, i, r) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = r;
  }
}
let kc = null;
function b3(n) {
  if (n.setActive)
    return n.setActive();
  if (kc)
    return n.focus(kc);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(kc == null ? {
    get preventScroll() {
      return kc = { preventScroll: !0 }, !0;
    }
  } : void 0), !kc) {
    kc = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], r = e[t++], s = e[t++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
let b2;
function Jl(n, e, t = e) {
  let i = b2 || (b2 = document.createRange());
  return i.setEnd(n, t), i.setStart(n, e), i;
}
function Uc(n, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, r = new KeyboardEvent("keydown", i);
  r.synthetic = !0, n.dispatchEvent(r);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, n.dispatchEvent(s), r.defaultPrevented || s.defaultPrevented;
}
function mae(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function y3(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function vae(n, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, Ho(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let r = t.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (t = r, i = Ho(t));
    } else {
      if (t == n)
        return !0;
      i = rf(t), t = t.parentNode;
    }
}
function O3(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
class Ri {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new Ri(e.parentNode, rf(e), t);
  }
  static after(e, t) {
    return new Ri(e.parentNode, rf(e) + 1, t);
  }
}
const lx = [];
class tn {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let i = this.dom, r = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = r ? r.nextSibling : i.firstChild)) {
            let a = tn.get(s);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = r ? r.nextSibling : i.firstChild, t && !t.written && t.node == i && s != o.dom && (t.written = !0), o.dom.parentNode == i)
          for (; s && s != o.dom; )
            s = y2(s);
        else
          i.insertBefore(o.dom, s);
        r = o.dom;
      }
      for (s = r ? r.nextSibling : i.firstChild, s && t && t.node == i && (t.written = !0); s; )
        s = y2(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, t), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let r = Ho(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        r == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? r = -1 : r = 1), e = s;
      }
      r < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !tn.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let r = 0, s = 0; ; r++) {
      let o = this.children[r];
      if (o.dom == i)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let r = -1, s = -1, o = -1, a = -1;
    for (let l = 0, c = i, u = i; l < this.children.length; l++) {
      let h = this.children[l], d = c + h.length;
      if (c < e && d > t)
        return h.domBoundsAround(e, t, c);
      if (d >= e && r == -1 && (r = l, s = c), c > t && h.dom.parentNode == this.dom) {
        o = l, a = u;
        break;
      }
      u = d, c = d + h.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? i + this.length : a,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = lx) {
    this.markDirty();
    for (let r = e; r < t; r++) {
      let s = this.children[r];
      s.parent == this && i.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let r = 0; r < i.length; r++)
      i[r].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new w3(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, r, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
tn.prototype.breakAfter = 0;
function y2(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class w3 {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function x3(n, e, t, i, r, s, o, a, l) {
  let { children: c } = n, u = c.length ? c[e] : null, h = s.length ? s[s.length - 1] : null, d = h ? h.breakAfter : o;
  if (!(e == i && u && !o && !d && s.length < 2 && u.merge(t, r, s.length ? h : null, t == 0, a, l))) {
    if (i < c.length) {
      let f = c[i];
      f && (r < f.length || f.breakAfter && (h != null && h.breakAfter)) ? (e == i && (f = f.split(r), r = 0), !d && h && f.merge(0, r, h, !0, 0, l) ? s[s.length - 1] = f : ((r || f.children.length && !f.children[0].length) && f.merge(0, r, null, !1, 0, l), s.push(f))) : f != null && f.breakAfter && (h ? h.breakAfter = 1 : o = 1), i++;
    }
    for (u && (u.breakAfter = o, t > 0 && (!o && s.length && u.merge(t, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (t < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(t, u.length, null, !1, a, 0), e++)); e < i && s.length; )
      if (c[i - 1].become(s[s.length - 1]))
        i--, s.pop(), l = s.length ? 0 : a;
      else if (c[e].become(s[0]))
        e++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < i || s.length) && n.replaceChildren(e, i, s);
  }
}
function S3(n, e, t, i, r, s) {
  let o = n.childCursor(), { i: a, off: l } = o.findPos(t, 1), { i: c, off: u } = o.findPos(e, -1), h = e - t;
  for (let d of i)
    h += d.length;
  n.length += h, x3(n, c, u, a, l, i, 0, r, s);
}
let Cr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, mO = typeof document < "u" ? document : { documentElement: { style: {} } };
const vO = /* @__PURE__ */ /Edge\/(\d+)/.exec(Cr.userAgent), C3 = /* @__PURE__ */ /MSIE \d/.test(Cr.userAgent), bO = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Cr.userAgent), Lv = !!(C3 || bO || vO), O2 = !Lv && /* @__PURE__ */ /gecko\/(\d+)/i.test(Cr.userAgent), Z0 = !Lv && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Cr.userAgent), w2 = "webkitFontSmoothing" in mO.documentElement.style, k3 = !Lv && /* @__PURE__ */ /Apple Computer/.test(Cr.vendor), x2 = k3 && (/* @__PURE__ */ /Mobile\/\w+/.test(Cr.userAgent) || Cr.maxTouchPoints > 2);
var Ne = {
  mac: x2 || /* @__PURE__ */ /Mac/.test(Cr.platform),
  windows: /* @__PURE__ */ /Win/.test(Cr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Cr.platform),
  ie: Lv,
  ie_version: C3 ? mO.documentMode || 6 : bO ? +bO[1] : vO ? +vO[1] : 0,
  gecko: O2,
  gecko_version: O2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Cr.userAgent) || [0, 0])[1] : 0,
  chrome: !!Z0,
  chrome_version: Z0 ? +Z0[1] : 0,
  ios: x2,
  android: /* @__PURE__ */ /Android\b/.test(Cr.userAgent),
  webkit: w2,
  safari: k3,
  webkit_version: w2 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: mO.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const bae = 256;
class Xo extends tn {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return this.flags & 8 || i && (!(i instanceof Xo) || this.length - (t - e) + i.length > bae || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Xo(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Ri(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return yae(this.dom, e, t);
  }
}
class Yo extends tn {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let r of t)
      r.setParent(this);
  }
  setAttrs(e) {
    if (y3(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof Yo && i.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (S3(this, e, t, i ? i.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, r = -1, s = 0;
    for (let a of this.children) {
      let l = i + a.length;
      l > e && t.push(i < e ? a.split(e - i) : a), r < 0 && i >= e && (r = s), i = l, s++;
    }
    let o = this.length - e;
    return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new Yo(this.mark, t, o);
  }
  domAtPos(e) {
    return P3(this, e);
  }
  coordsAt(e, t) {
    return A3(this, e, t);
  }
}
function yae(n, e, t) {
  let i = n.nodeValue.length;
  e > i && (e = i);
  let r = e, s = e, o = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? Ne.chrome || Ne.gecko || (e ? (r--, o = 1) : s < i && (s++, o = -1)) : t < 0 ? r-- : s < i && s++;
  let a = Jl(n, r, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : t >= 0) ? 0 : a.length - 1];
  return Ne.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? ax(l, o < 0) : l || null;
}
class Aa extends tn {
  static create(e, t, i) {
    return new Aa(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let t = Aa.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof Aa) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Aa && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return $t.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, r = this.posAtStart;
    return i ? i.slice(r, r + this.length) : $t.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Ri.before(this.dom) : Ri.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let r = this.dom.getClientRects(), s = null;
    if (!r.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? r.length - 1 : 0; s = r[a], !(e > 0 ? a == 0 : a == r.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
      ;
    return ax(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Zu extends tn {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Zu && e.side == this.side;
  }
  split() {
    return new Zu(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Ri.before(this.dom) : Ri.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return $t.empty;
  }
  get isHidden() {
    return !0;
  }
}
Xo.prototype.children = Aa.prototype.children = Zu.prototype.children = lx;
function P3(n, e) {
  let t = n.dom, { children: i } = n, r = 0;
  for (let s = 0; r < i.length; r++) {
    let o = i[r], a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = a;
    }
  }
  for (let s = r; s > 0; s--) {
    let o = i[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = r; s < i.length; s++) {
    let o = i[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new Ri(t, 0);
}
function E3(n, e, t) {
  let i, { children: r } = n;
  t > 0 && e instanceof Yo && r.length && (i = r[r.length - 1]) instanceof Yo && i.mark.eq(e.mark) ? E3(i, e.children[0], t - 1) : (r.push(e), e.setParent(n)), n.length += e.length;
}
function A3(n, e, t) {
  let i = null, r = -1, s = null, o = -1;
  function a(c, u) {
    for (let h = 0, d = 0; h < c.children.length && d <= u; h++) {
      let f = c.children[h], p = d + f.length;
      p >= u && (f.children.length ? a(f, u - d) : (!s || s.isHidden && t > 0) && (p > u || d == p && f.getSide() > 0) ? (s = f, o = u - d) : (d < u || d == p && f.getSide() < 0 && !f.isHidden) && (i = f, r = u - d)), d = p;
    }
  }
  a(n, e);
  let l = (t < 0 ? i : s) || i || s;
  return l ? l.coordsAt(Math.max(0, l == i ? r : o), t) : Oae(n);
}
function Oae(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = nf(e);
  return t[t.length - 1] || null;
}
function yO(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const S2 = /* @__PURE__ */ Object.create(null);
function cx(n, e, t) {
  if (n == e)
    return !0;
  n || (n = S2), e || (e = S2);
  let i = Object.keys(n), r = Object.keys(e);
  if (i.length - (t && i.indexOf(t) > -1 ? 1 : 0) != r.length - (t && r.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != t && (r.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function OO(n, e, t) {
  let i = !1;
  if (e)
    for (let r in e)
      t && r in t || (i = !0, r == "style" ? n.style.cssText = "" : n.removeAttribute(r));
  if (t)
    for (let r in t)
      e && e[r] == t[r] || (i = !0, r == "style" ? n.style.cssText = t[r] : n.setAttribute(r, t[r]));
  return i;
}
function wae(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let i = n.attributes[t];
    e[i.name] = i.value;
  }
  return e;
}
class Wn extends tn {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, r, s, o) {
    if (i) {
      if (!(i instanceof Wn))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return r && this.setDeco(i ? i.attrs : null), S3(this, e, t, i ? i.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new Wn();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: r } = this.childPos(e);
    r && (t.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    cx(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    E3(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = yO(t, this.attrs || {})), i && (this.attrs = yO({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return P3(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.flags & 4 && (y3(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (OO(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let r = this.dom.lastChild;
    for (; r && tn.get(r) instanceof Yo; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((i = tn.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!Ne.ios || !this.children.some((s) => s instanceof Xo))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof Xo) || /[^ -~]/.test(i.text))
        return null;
      let r = nf(i.dom);
      if (r.length != 1)
        return null;
      e += r[0].width, t = r[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = A3(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - r.lineHeight) < 2 && r.textHeight < s) {
        let o = (s - r.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let i = 0, r = 0; i < e.children.length; i++) {
      let s = e.children[i], o = r + s.length;
      if (o >= t) {
        if (s instanceof Wn)
          return s;
        if (o > t)
          break;
      }
      r = o + s.breakAfter;
    }
    return null;
  }
}
class _a extends tn {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof _a) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Ri.before(this.dom) : Ri.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new _a(this.widget, t, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return lx;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : $t.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof _a && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: i } = this.deco;
    return t == i ? !1 : e < 0 ? t < 0 : i > 0;
  }
}
class ia {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Wi = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(Wi || (Wi = {}));
class He extends Kl {
  constructor(e, t, i, r) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = r;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Bf(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Wa(e, t, t, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, r;
    if (e.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: s, end: o } = $3(e, t);
      i = (s ? t ? -3e8 : -1 : 5e8) - 1, r = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Wa(e, i, r, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Qf(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return kt.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
He.none = kt.empty;
class Bf extends He {
  constructor(e) {
    let { start: t, end: i } = $3(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, i;
    return this == e || e instanceof Bf && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && cx(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
Bf.prototype.point = !1;
class Qf extends He {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Qf && this.spec.class == e.spec.class && cx(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
Qf.prototype.mapMode = xi.TrackBefore;
Qf.prototype.point = !0;
class Wa extends He {
  constructor(e, t, i, r, s, o) {
    super(t, i, s, e), this.block = r, this.isReplace = o, this.mapMode = r ? t <= 0 ? xi.TrackBefore : xi.TrackAfter : xi.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Wi.WidgetRange : this.startSide <= 0 ? Wi.WidgetBefore : Wi.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Wa && xae(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Wa.prototype.point = !0;
function $3(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = n;
  return t == null && (t = n.inclusive), i == null && (i = n.inclusive), { start: t ?? e, end: i ?? e };
}
function xae(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function wO(n, e, t, i = 0) {
  let r = t.length - 1;
  r >= 0 && t[r] + i >= n ? t[r] = Math.max(t[r], e) : t.push(n, e);
}
class yd {
  constructor(e, t, i, r) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof _a && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Wn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(xp(new Zu(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof _a) && this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let r = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(xp(new Xo(this.text.slice(this.textOff, this.textOff + r)), t), i), this.atCursorPos = !0, this.textOff += r, e -= r, i = 0;
    }
  }
  span(e, t, i, r) {
    this.buildText(t - e, i, r), this.pos = t, this.openStart < 0 && (this.openStart = r);
  }
  point(e, t, i, r, s, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof Wa) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (i instanceof Wa)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new _a(i.widget || new C2("div"), a, i));
      else {
        let l = Aa.create(i.widget || new C2("span"), a, a ? 0 : i.startSide), c = this.atCursorPos && !l.isEditable && s <= r.length && (e < t || i.startSide > 0), u = !l.isEditable && (e < t || s > r.length || i.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), c && (h.append(xp(new Zu(1), r), s), s = r.length + Math.max(0, s - r.length)), h.append(xp(l, r), s), this.atCursorPos = u, this.pendingBuffer = u ? e < t || s > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, i, r, s) {
    let o = new yd(e, t, i, s);
    return o.openEnd = kt.spans(r, t, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function xp(n, e) {
  for (let t of e)
    n = new Yo(t, [n], n.length);
  return n;
}
class C2 extends ia {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var nn = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(nn || (nn = {}));
const ec = nn.LTR, ux = nn.RTL;
function T3(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const Sae = /* @__PURE__ */ T3("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Cae = /* @__PURE__ */ T3("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), xO = /* @__PURE__ */ Object.create(null), Is = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  xO[e] = t, xO[t] = -e;
}
function _3(n) {
  return n <= 247 ? Sae[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? Cae[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const kae = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class $a {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? ux : ec;
  }
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, i, r) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= t && a.to >= t) {
        if (a.level == i)
          return o;
        (s < 0 || (r != 0 ? r < 0 ? a.from < t : a.to > t : e[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function M3(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let i = n[t], r = e[t];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !M3(i.inner, r.inner))
      return !1;
  }
  return !0;
}
const Vt = [];
function Pae(n, e, t, i, r) {
  for (let s = 0; s <= i.length; s++) {
    let o = s ? i[s - 1].to : e, a = s < i.length ? i[s].from : t, l = s ? 256 : r;
    for (let c = o, u = l, h = l; c < a; c++) {
      let d = _3(n.charCodeAt(c));
      d == 512 ? d = u : d == 8 && h == 4 && (d = 16), Vt[c] = d == 4 ? 2 : d, d & 7 && (h = d), u = d;
    }
    for (let c = o, u = l, h = l; c < a; c++) {
      let d = Vt[c];
      if (d == 128)
        c < a - 1 && u == Vt[c + 1] && u & 24 ? d = Vt[c] = u : Vt[c] = 256;
      else if (d == 64) {
        let f = c + 1;
        for (; f < a && Vt[f] == 64; )
          f++;
        let p = c && u == 8 || f < t && Vt[f] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let g = c; g < f; g++)
          Vt[g] = p;
        c = f - 1;
      } else
        d == 8 && h == 1 && (Vt[c] = 1);
      u = d, d & 7 && (h = d);
    }
  }
}
function Eae(n, e, t, i, r) {
  let s = r == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= i.length; o++) {
    let c = o ? i[o - 1].to : e, u = o < i.length ? i[o].from : t;
    for (let h = c, d, f, p; h < u; h++)
      if (f = xO[d = n.charCodeAt(h)])
        if (f < 0) {
          for (let g = a - 3; g >= 0; g -= 3)
            if (Is[g + 1] == -f) {
              let m = Is[g + 2], v = m & 2 ? r : m & 4 ? m & 1 ? s : r : 0;
              v && (Vt[h] = Vt[Is[g]] = v), a = g;
              break;
            }
        } else {
          if (Is.length == 189)
            break;
          Is[a++] = h, Is[a++] = d, Is[a++] = l;
        }
      else if ((p = Vt[h]) == 2 || p == 1) {
        let g = p == r;
        l = g ? 0 : 1;
        for (let m = a - 3; m >= 0; m -= 3) {
          let v = Is[m + 2];
          if (v & 2)
            break;
          if (g)
            Is[m + 2] |= 2;
          else {
            if (v & 4)
              break;
            Is[m + 2] |= 4;
          }
        }
      }
  }
}
function Aae(n, e, t, i) {
  for (let r = 0, s = i; r <= t.length; r++) {
    let o = r ? t[r - 1].to : n, a = r < t.length ? t[r].from : e;
    for (let l = o; l < a; ) {
      let c = Vt[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (r == t.length)
              break;
            u = t[r++].to, a = r < t.length ? t[r].from : e;
          } else if (Vt[u] == 256)
            u++;
          else
            break;
        let h = s == 1, d = (u < e ? Vt[u] : i) == 1, f = h == d ? h ? 1 : 2 : i;
        for (let p = u, g = r, m = g ? t[g - 1].to : n; p > l; )
          p == m && (p = t[--g].from, m = g ? t[g - 1].to : n), Vt[--p] = f;
        l = u;
      } else
        s = c, l++;
    }
  }
}
function SO(n, e, t, i, r, s, o) {
  let a = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let l = e, c = 0; l < t; ) {
      let u = !0, h = !1;
      if (c == s.length || l < s[c].from) {
        let g = Vt[l];
        g != a && (u = !1, h = g == 16);
      }
      let d = !u && a == 1 ? [] : null, f = u ? i : i + 1, p = l;
      e:
        for (; ; )
          if (c < s.length && p == s[c].from) {
            if (h)
              break e;
            let g = s[c];
            if (!u)
              for (let m = g.to, v = c + 1; ; ) {
                if (m == t)
                  break e;
                if (v < s.length && s[v].from == m)
                  m = s[v++].to;
                else {
                  if (Vt[m] == a)
                    break e;
                  break;
                }
              }
            if (c++, d)
              d.push(g);
            else {
              g.from > l && o.push(new $a(l, g.from, f));
              let m = g.direction == ec != !(f % 2);
              CO(n, m ? i + 1 : i, r, g.inner, g.from, g.to, o), l = g.to;
            }
            p = g.to;
          } else {
            if (p == t || (u ? Vt[p] != a : Vt[p] == a))
              break;
            p++;
          }
      d ? SO(n, l, p, i + 1, r, d, o) : l < p && o.push(new $a(l, p, f)), l = p;
    }
  else
    for (let l = t, c = s.length; l > e; ) {
      let u = !0, h = !1;
      if (!c || l > s[c - 1].to) {
        let g = Vt[l - 1];
        g != a && (u = !1, h = g == 16);
      }
      let d = !u && a == 1 ? [] : null, f = u ? i : i + 1, p = l;
      e:
        for (; ; )
          if (c && p == s[c - 1].to) {
            if (h)
              break e;
            let g = s[--c];
            if (!u)
              for (let m = g.from, v = c; ; ) {
                if (m == e)
                  break e;
                if (v && s[v - 1].to == m)
                  m = s[--v].from;
                else {
                  if (Vt[m - 1] == a)
                    break e;
                  break;
                }
              }
            if (d)
              d.push(g);
            else {
              g.to < l && o.push(new $a(g.to, l, f));
              let m = g.direction == ec != !(f % 2);
              CO(n, m ? i + 1 : i, r, g.inner, g.from, g.to, o), l = g.from;
            }
            p = g.from;
          } else {
            if (p == e || (u ? Vt[p - 1] != a : Vt[p - 1] == a))
              break;
            p--;
          }
      d ? SO(n, p, l, i + 1, r, d, o) : p < l && o.push(new $a(p, l, f)), l = p;
    }
}
function CO(n, e, t, i, r, s, o) {
  let a = e % 2 ? 2 : 1;
  Pae(n, r, s, i, a), Eae(n, r, s, i, a), Aae(r, s, i, a), SO(n, r, s, e, t, i, o);
}
function $ae(n, e, t) {
  if (!n)
    return [new $a(0, 0, e == ux ? 1 : 0)];
  if (e == ec && !t.length && !kae.test(n))
    return R3(n.length);
  if (t.length)
    for (; n.length > Vt.length; )
      Vt[Vt.length] = 256;
  let i = [], r = e == ec ? 0 : 1;
  return CO(n, r, r, t, 0, n.length, i), i;
}
function R3(n) {
  return [new $a(0, n, 0)];
}
let N3 = "";
function Tae(n, e, t, i, r) {
  var s;
  let o = i.head - n.from, a = $a.find(e, o, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc), l = e[a], c = l.side(r, t);
  if (o == c) {
    let d = a += r ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    l = e[a = d], o = l.side(!r, t), c = l.side(r, t);
  }
  let u = ki(n.text, o, l.forward(r, t));
  (u < l.from || u > l.to) && (u = c), N3 = n.text.slice(Math.min(o, u), Math.max(o, u));
  let h = a == (r ? e.length - 1 : 0) ? null : e[a + (r ? 1 : -1)];
  return h && u == c && h.level + (r ? 0 : 1) < l.level ? ue.cursor(h.side(!r, t) + n.from, h.forward(r, t) ? 1 : -1, h.level) : ue.cursor(u + n.from, l.forward(r, t) ? -1 : 1, l.level);
}
function _ae(n, e, t) {
  for (let i = e; i < t; i++) {
    let r = _3(n.charCodeAt(i));
    if (r == 1)
      return ec;
    if (r == 2 || r == 4)
      return ux;
  }
  return ec;
}
const D3 = /* @__PURE__ */ Me.define(), L3 = /* @__PURE__ */ Me.define(), I3 = /* @__PURE__ */ Me.define(), B3 = /* @__PURE__ */ Me.define(), kO = /* @__PURE__ */ Me.define(), Q3 = /* @__PURE__ */ Me.define(), z3 = /* @__PURE__ */ Me.define(), j3 = /* @__PURE__ */ Me.define({
  combine: (n) => n.some((e) => e)
}), V3 = /* @__PURE__ */ Me.define({
  combine: (n) => n.some((e) => e)
});
class Gc {
  constructor(e, t = "nearest", i = "nearest", r = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = i, this.yMargin = r, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new Gc(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Gc(ue.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Sp = /* @__PURE__ */ ct.define({ map: (n, e) => n.map(e) });
function qr(n, e, t) {
  let i = n.facet(B3);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const Iv = /* @__PURE__ */ Me.define({ combine: (n) => n.length ? n[0] : !0 });
let Mae = 0;
const Fh = /* @__PURE__ */ Me.define();
class Qn {
  constructor(e, t, i, r, s) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.domEventObservers = r, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: i, eventObservers: r, provide: s, decorations: o } = t || {};
    return new Qn(Mae++, e, i, r, (a) => {
      let l = [Fh.of(a)];
      return o && l.push(sf.of((c) => {
        let u = c.plugin(a);
        return u ? o(u) : He.none;
      })), s && l.push(s(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Qn.define((i) => new e(i), t);
  }
}
class q0 {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (qr(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        qr(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        qr(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const F3 = /* @__PURE__ */ Me.define(), hx = /* @__PURE__ */ Me.define(), sf = /* @__PURE__ */ Me.define(), Z3 = /* @__PURE__ */ Me.define(), dx = /* @__PURE__ */ Me.define(), q3 = /* @__PURE__ */ Me.define();
function k2(n, e) {
  let t = n.state.facet(q3);
  if (!t.length)
    return t;
  let i = t.map((s) => s instanceof Function ? s(n) : s), r = [];
  return kt.spans(i, e.from, e.to, {
    point() {
    },
    span(s, o, a, l) {
      let c = s - e.from, u = o - e.from, h = r;
      for (let d = a.length - 1; d >= 0; d--, l--) {
        let f = a[d].spec.bidiIsolate, p;
        if (f == null && (f = _ae(e.text, c, u)), l > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == f)
          p.to = u, h = p.inner;
        else {
          let g = { from: c, to: u, direction: f, inner: [] };
          h.push(g), h = g.inner;
        }
      }
    }
  }), r;
}
const W3 = /* @__PURE__ */ Me.define();
function H3(n) {
  let e = 0, t = 0, i = 0, r = 0;
  for (let s of n.state.facet(W3)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (r = Math.max(r, o.bottom)));
  }
  return { left: e, right: t, top: i, bottom: r };
}
const Zh = /* @__PURE__ */ Me.define();
class Wr {
  constructor(e, t, i, r) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = r;
  }
  join(e) {
    return new Wr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let r = e[t - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let r = 0, s = 0, o = 0, a = 0; ; r++) {
      let l = r == e.length ? null : e[r], c = o - a, u = l ? l.fromB : 1e9;
      for (; s < t.length && t[s] < u; ) {
        let h = t[s], d = t[s + 1], f = Math.max(a, h), p = Math.min(u, d);
        if (f <= p && new Wr(f + c, p + c, f, p).addToSet(i), d > u)
          break;
        s += 2;
      }
      if (!l)
        return i;
      new Wr(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), o = l.toA, a = l.toB;
    }
  }
}
class xm {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = Hn.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let r = [];
    this.changes.iterChangedRanges((s, o, a, l) => r.push(new Wr(s, o, a, l))), this.changedRanges = r;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new xm(e, t, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class P2 extends tn {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Wn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Wr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let r = -1;
    this.view.inputState.composing >= 0 && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? r = this.domChanged.newSel.head : !Qae(e.changes, this.hasComposition) && !e.selectionSet && (r = e.state.selection.main.head));
    let s = r > -1 ? Nae(this.view, e.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      i = new Wr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(i.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (Ne.ie || Ne.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = Iae(o, a, e.changes);
    return i = Wr.extendWithRanges(i, l), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, i);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = Ne.chrome || Ne.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || r.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof _a && o.widget instanceof E2 && s.push(o.dom);
    r.updateGaps(s);
  }
  updateChildren(e, t, i) {
    let r = i ? i.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = r.length - 1; ; o--) {
      let a = o >= 0 ? r[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: h } = a, d, f, p, g;
      if (i && i.range.fromB < h && i.range.toB > u) {
        let w = yd.build(this.view.state.doc, u, i.range.fromB, this.decorations, this.dynamicDecorationMap), x = yd.build(this.view.state.doc, i.range.toB, h, this.decorations, this.dynamicDecorationMap);
        f = w.breakAtStart, p = w.openStart, g = x.openEnd;
        let S = this.compositionView(i);
        x.breakAtStart ? S.breakAfter = 1 : x.content.length && S.merge(S.length, S.length, x.content[0], !1, x.openStart, 0) && (S.breakAfter = x.content[0].breakAfter, x.content.shift()), w.content.length && S.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), d = w.content.concat(S).concat(x.content);
      } else
        ({ content: d, breakAtStart: f, openStart: p, openEnd: g } = yd.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: v } = s.findPos(c, 1), { i: y, off: b } = s.findPos(l, -1);
      x3(this, y, b, m, v, d, f, p, g);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let t = new Xo(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: r } of e.marks)
      t = new Yo(r, [t], t.length);
    let i = new Wn();
    return i.append(t, 0), i;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = tn.get(s);
      a && a != o && (a.dom = null), o.setDOM(s);
    }, i = this.childPos(e.range.fromB, 1), r = this.children[i.i];
    t(e.line, r);
    for (let s = e.marks.length - 1; s >= -1; s--)
      i = r.childPos(i.off, 1), r = r.children[i.i], t(s >= 0 ? e.marks[s].node : e.text, r);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, r = i == this.dom, s = !r && Sg(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(r || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (Ne.gecko && a.empty && !this.hasComposition && Rae(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = c = new Ri(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!bd(l.node, l.offset, u.anchorNode, u.anchorOffset) || !bd(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      Ne.android && Ne.chrome && this.dom.contains(u.focusNode) && Bae(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = wm(this.view.root);
      if (h)
        if (a.empty) {
          if (Ne.gecko) {
            let d = Dae(l.node, l.offset);
            if (d && d != 3) {
              let f = Y3(l.node, l.offset, d == 1 ? 1 : -1);
              f && (l = new Ri(f.node, f.offset));
            }
          }
          h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
        } else if (h.extend) {
          h.collapse(l.node, l.offset);
          try {
            h.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let d = document.createRange();
          a.anchor > a.head && ([l, c] = [c, l]), d.setEnd(c.node, c.offset), d.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(d);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new Ri(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Ri(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && bd(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, i = wm(e.root), { anchorNode: r, anchorOffset: s } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let o = Wn.find(this, t.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (t.head == a || t.head == a + o.length)
      return;
    let l = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(t.head + t.assoc);
    i.collapse(u.node, u.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && i.collapse(r, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, i;
    if (e.node != t)
      return e;
    for (let r = e.offset; !i && r < t.childNodes.length; r++) {
      let s = tn.get(t.childNodes[r]);
      s instanceof Wn && (i = s.domAtPos(0));
    }
    for (let r = e.offset - 1; !i && r >= 0; r--) {
      let s = tn.get(t.childNodes[r]);
      s instanceof Wn && (i = s.domAtPos(s.length));
    }
    return i ? new Ri(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = tn.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let r = this.children[t];
      if (i < r.length || r instanceof Wn)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    let i = null, r = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = s - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!i || a instanceof Wn && !(i instanceof Wn && t >= 0)) && (i = a, r = c), s = c;
    }
    return i ? i.coordsAt(e - r, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: i } = this.childPos(e, 1), r = this.children[t];
    if (!(r instanceof Wn))
      return null;
    for (; r.children.length; ) {
      let { i: a, off: l } = r.childPos(i, 1);
      for (; ; a++) {
        if (a == r.children.length)
          return null;
        if ((r = r.children[a]).length)
          break;
      }
      i = l;
    }
    if (!(r instanceof Xo))
      return null;
    let s = ki(r.text, i);
    if (s == i)
      return null;
    let o = Jl(r.dom, i, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: r } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == nn.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], d = c + h.length;
      if (d > r)
        break;
      if (c >= i) {
        let f = h.dom.getBoundingClientRect();
        if (t.push(f.height), o) {
          let p = h.dom.lastChild, g = p ? nf(p) : [];
          if (g.length) {
            let m = g[g.length - 1], v = l ? m.right - f.left : f.right - m.left;
            v > a && (a = v, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = d);
          }
        }
      }
      c = d + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? nn.RTL : nn.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Wn) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, i, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = nf(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, r = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: r };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new w3(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let s = r == t.viewports.length ? null : t.viewports[r], o = s ? s.from - 1 : this.length;
      if (o > i) {
        let a = (t.lineBlockAt(o).bottom - t.lineBlockAt(i).top) / this.view.scaleY;
        e.push(He.replace({
          widget: new E2(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return He.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(sf).map((r, s) => (this.dynamicDecorationMap[s] = typeof r == "function") ? r(this.view) : r), t = !1, i = this.view.state.facet(Z3).map((r, s) => {
      let o = typeof r == "function";
      return o && (t = !0), o ? r(this.view) : r;
    });
    i.length && (this.dynamicDecorationMap[e.length] = t, e.push(kt.join(i)));
    for (let r = e.length; r < e.length + 3; r++)
      this.dynamicDecorationMap[r] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), r;
    if (!i)
      return;
    !t.empty && (r = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let s = H3(this.view), o = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    fae(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == nn.LTR);
  }
}
function Rae(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
class E2 extends ia {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function X3(n, e) {
  let t = n.observer.selectionRange, i = t.focusNode && Y3(t.focusNode, t.focusOffset, 0);
  if (!i)
    return null;
  let r = e - i.offset;
  return { from: r, to: r + i.node.nodeValue.length, node: i.node };
}
function Nae(n, e, t) {
  let i = X3(n, t);
  if (!i)
    return null;
  let { node: r, from: s, to: o } = i, a = r.nodeValue;
  if (/[\n\r]/.test(a) || n.state.doc.sliceString(i.from, i.to) != a)
    return null;
  let l = e.invertedDesc, c = new Wr(l.mapPos(s), l.mapPos(o), s, o), u = [];
  for (let h = r.parentNode; ; h = h.parentNode) {
    let d = tn.get(h);
    if (d instanceof Yo)
      u.push({ node: h, deco: d.mark });
    else {
      if (d instanceof Wn || h.nodeName == "DIV" && h.parentNode == n.contentDOM)
        return { range: c, text: r, marks: u, line: h };
      if (h != n.contentDOM)
        u.push({ node: h, deco: new Bf({
          inclusive: !0,
          attributes: wae(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function Y3(n, e, t) {
  if (t <= 0)
    for (let i = n, r = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: r };
      if (i.nodeType == 1 && r > 0)
        i = i.childNodes[r - 1], r = Ho(i);
      else
        break;
    }
  if (t >= 0)
    for (let i = n, r = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: r };
      if (i.nodeType == 1 && r < i.childNodes.length && t >= 0)
        i = i.childNodes[r], r = 0;
      else
        break;
    }
  return null;
}
function Dae(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let Lae = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    wO(e, t, this.changes);
  }
  comparePoint(e, t) {
    wO(e, t, this.changes);
  }
};
function Iae(n, e, t) {
  let i = new Lae();
  return kt.compare(n, e, t, i), i.changes;
}
function Bae(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function Qae(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((i, r) => {
    i < e.to && r > e.from && (t = !0);
  }), t;
}
function zae(n, e, t = 1) {
  let i = n.charCategorizer(e), r = n.doc.lineAt(e), s = e - r.from;
  if (r.length == 0)
    return ue.cursor(e);
  s == 0 ? t = 1 : s == r.length && (t = -1);
  let o = s, a = s;
  t < 0 ? o = ki(r.text, s, !1) : a = ki(r.text, s);
  let l = i(r.text.slice(o, a));
  for (; o > 0; ) {
    let c = ki(r.text, o, !1);
    if (i(r.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < r.length; ) {
    let c = ki(r.text, a);
    if (i(r.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return ue.range(o + r.from, a + r.from);
}
function jae(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function Vae(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function W0(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function A2(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function $2(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function PO(n, e, t) {
  let i, r, s, o, a = !1, l, c, u, h;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let g = nf(p);
    for (let m = 0; m < g.length; m++) {
      let v = g[m];
      r && W0(r, v) && (v = A2($2(v, r.bottom), r.top));
      let y = jae(e, v), b = Vae(t, v);
      if (y == 0 && b == 0)
        return p.nodeType == 3 ? T2(p, e, t) : PO(p, e, t);
      if (!i || o > b || o == b && s > y) {
        i = p, r = v, s = y, o = b;
        let w = b ? t < v.top ? -1 : 1 : y ? e < v.left ? -1 : 1 : 0;
        a = !w || (w > 0 ? m < g.length - 1 : m > 0);
      }
      y == 0 ? t > v.bottom && (!u || u.bottom < v.bottom) ? (l = p, u = v) : t < v.top && (!h || h.top > v.top) && (c = p, h = v) : u && W0(u, v) ? u = $2(u, v.bottom) : h && W0(h, v) && (h = A2(h, v.top));
    }
  }
  if (u && u.bottom >= t ? (i = l, r = u) : h && h.top <= t && (i = c, r = h), !i)
    return { node: n, offset: 0 };
  let d = Math.max(r.left, Math.min(r.right, e));
  if (i.nodeType == 3)
    return T2(i, d, t);
  if (a && i.contentEditable != "false")
    return PO(i, d, t);
  let f = Array.prototype.indexOf.call(n.childNodes, i) + (e >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: n, offset: f };
}
function T2(n, e, t) {
  let i = n.nodeValue.length, r = -1, s = 1e9, o = 0;
  for (let a = 0; a < i; a++) {
    let l = Jl(n, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > t ? u.top - t : t - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let d = e >= (u.left + u.right) / 2, f = d;
        if ((Ne.chrome || Ne.gecko) && Jl(n, a).getBoundingClientRect().left == u.right && (f = !d), h <= 0)
          return { node: n, offset: a + (f ? 1 : 0) };
        r = a + (f ? 1 : 0), s = h;
      }
    }
  }
  return { node: n, offset: r > -1 ? r : o > 0 ? n.nodeValue.length : 0 };
}
function U3(n, e, t, i = -1) {
  var r, s;
  let o = n.contentDOM.getBoundingClientRect(), a = o.top + n.viewState.paddingTop, l, { docHeight: c } = n.viewState, { x: u, y: h } = e, d = h - a;
  if (d < 0)
    return 0;
  if (d > c)
    return n.state.doc.length;
  for (let w = n.viewState.heightOracle.textHeight / 2, x = !1; l = n.elementAtHeight(d), l.type != Wi.Text; )
    for (; d = i > 0 ? l.bottom + w : l.top - w, !(d >= 0 && d <= c); ) {
      if (x)
        return t ? null : 0;
      x = !0, i = -i;
    }
  h = a + d;
  let f = l.from;
  if (f < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : _2(n, o, l, u, h);
  if (f > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : _2(n, o, l, u, h);
  let p = n.dom.ownerDocument, g = n.root.elementFromPoint ? n.root : p, m = g.elementFromPoint(u, h);
  m && !n.contentDOM.contains(m) && (m = null), m || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), m = g.elementFromPoint(u, h), m && !n.contentDOM.contains(m) && (m = null));
  let v, y = -1;
  if (m && ((r = n.docView.nearest(m)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(u, h);
      w && ({ offsetNode: v, offset: y } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(u, h);
      w && ({ startContainer: v, startOffset: y } = w, (!n.contentDOM.contains(v) || Ne.safari && Fae(v, y, u) || Ne.chrome && Zae(v, y, u)) && (v = void 0));
    }
  }
  if (!v || !n.docView.dom.contains(v)) {
    let w = Wn.find(n.docView, f);
    if (!w)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: v, offset: y } = PO(w.dom, u, h));
  }
  let b = n.docView.nearest(v);
  if (!b)
    return null;
  if (b.isWidget && ((s = b.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = b.dom.getBoundingClientRect();
    return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? b.posAtStart : b.posAtEnd;
  } else
    return b.localPosFromDOM(v, y) + b.posAtStart;
}
function _2(n, e, t, i, r) {
  let s = Math.round((i - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let a = n.viewState.heightOracle.textHeight, l = Math.floor((r - t.top - (n.defaultLineHeight - a) * 0.5) / a);
    s += l * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + dO(o, s, n.state.tabSize);
}
function Fae(n, e, t) {
  let i;
  if (n.nodeType != 3 || e != (i = n.nodeValue.length))
    return !1;
  for (let r = n.nextSibling; r; r = r.nextSibling)
    if (r.nodeType != 1 || r.nodeName != "BR")
      return !1;
  return Jl(n, i - 1, i).getBoundingClientRect().left > t;
}
function Zae(n, e, t) {
  if (e != 0)
    return !1;
  for (let r = n; ; ) {
    let s = r.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != r)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    r = s;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : Jl(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function EO(n, e) {
  let t = n.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == Wi.Text))
        return i;
  }
  return t;
}
function qae(n, e, t, i) {
  let r = EO(n, e.head), s = !i || r.type != Wi.Text || !(n.lineWrapping || r.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), a = n.textDirectionAt(r.from), l = n.posAtCoords({
      x: t == (a == nn.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return ue.cursor(l, t ? -1 : 1);
  }
  return ue.cursor(t ? r.to : r.from, t ? -1 : 1);
}
function M2(n, e, t, i) {
  let r = n.state.doc.lineAt(e.head), s = n.bidiSpans(r), o = n.textDirectionAt(r.from);
  for (let a = e, l = null; ; ) {
    let c = Tae(r, s, o, a, t), u = N3;
    if (!c) {
      if (r.number == (t ? n.state.doc.lines : 1))
        return a;
      u = `
`, r = n.state.doc.line(r.number + (t ? 1 : -1)), s = n.bidiSpans(r), c = n.visualLineSide(r, !t);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!i)
        return c;
      l = i(u);
    }
    a = c;
  }
}
function Wae(n, e, t) {
  let i = n.state.charCategorizer(e), r = i(t);
  return (s) => {
    let o = i(s);
    return r == ln.Space && (r = o), r == o;
  };
}
function Hae(n, e, t, i) {
  let r = e.head, s = t ? 1 : -1;
  if (r == (t ? n.state.doc.length : 0))
    return ue.cursor(r, e.assoc);
  let o = e.goalColumn, a, l = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(r, e.assoc || -1), u = n.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = s < 0 ? c.top : c.bottom;
  else {
    let f = n.viewState.lineBlockAt(r);
    o == null && (o = Math.min(l.right - l.left, n.defaultCharacterWidth * (r - f.from))), a = (s < 0 ? f.top : f.bottom) + u;
  }
  let h = l.left + o, d = i ?? n.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let p = a + (d + f) * s, g = U3(n, { x: h, y: p }, !1, s);
    if (p < l.top || p > l.bottom || (s < 0 ? g < r : g > r)) {
      let m = n.docView.coordsForChar(g), v = !m || p < m.top ? -1 : 1;
      return ue.cursor(g, v, void 0, o);
    }
  }
}
function Cg(n, e, t) {
  for (; ; ) {
    let i = 0;
    for (let r of n)
      r.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = i || t || (e - s < o - e ? -1 : 1);
          e = l < 0 ? s : o, i = l;
        }
      });
    if (!i)
      return e;
  }
}
function H0(n, e, t) {
  let i = Cg(n.state.facet(dx).map((r) => r(n)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : ue.cursor(i, i < t.from ? 1 : -1);
}
class Xae {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, Ne.safari && e.contentDOM.addEventListener("input", () => null), Ne.gecko && ule(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !nle(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, t) {
    let i = this.handlers[e];
    if (i) {
      for (let r of i.observers)
        r(this.view, t);
      for (let r of i.handlers) {
        if (t.defaultPrevented)
          break;
        if (r(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = Yae(e), i = this.handlers, r = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, a = i[s];
        a && o != !a.handlers.length && (r.removeEventListener(s, this.handleEvent), a = null), a || r.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in i)
      s != "scroll" && !t[s] && r.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && K3.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), Ne.android && Ne.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return Ne.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = G3.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || Uae.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, Uc(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : Ne.safari && !Ne.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function R2(n, e) {
  return (t, i) => {
    try {
      return e.call(n, i, t);
    } catch (r) {
      qr(t.state, r);
    }
  };
}
function Yae(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of n) {
    let r = i.spec;
    if (r && r.domEventHandlers)
      for (let s in r.domEventHandlers) {
        let o = r.domEventHandlers[s];
        o && t(s).handlers.push(R2(i.value, o));
      }
    if (r && r.domEventObservers)
      for (let s in r.domEventObservers) {
        let o = r.domEventObservers[s];
        o && t(s).observers.push(R2(i.value, o));
      }
  }
  for (let i in Ss)
    t(i).handlers.push(Ss[i]);
  for (let i in Cs)
    t(i).observers.push(Cs[i]);
  return e;
}
const G3 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], Uae = "dthko", K3 = [16, 17, 18, 20, 91, 92, 224, 225], Cp = 6;
function kp(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function Gae(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class Kae {
  constructor(e, t, i, r) {
    this.view = e, this.startEvent = t, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = pae(e.contentDOM), this.atoms = e.state.facet(dx).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(Et.allowMultipleSelections) && Jae(e, t), this.dragging = tle(e, t) && nN(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && Gae(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, r = 0, s = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = H3(this.view);
    e.clientX - o.left <= s.left + Cp ? i = -kp(s.left - e.clientX) : e.clientX + o.right >= s.right - Cp && (i = kp(e.clientX - s.right)), e.clientY - o.top <= s.top + Cp ? r = -kp(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - Cp && (r = kp(e.clientY - s.bottom)), this.setScrollSpeed(i, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let r = e.ranges[i], s = null;
      if (r.empty) {
        let o = Cg(this.atoms, r.from, 0);
        o != r.from && (s = ue.cursor(o, -1));
      } else {
        let o = Cg(this.atoms, r.from, -1), a = Cg(this.atoms, r.to, 1);
        (o != r.from || a != r.to) && (s = ue.range(r.from == r.anchor ? o : a, r.from == r.head ? o : a));
      }
      s && (t || (t = e.ranges.slice()), t[i] = s);
    }
    return t ? ue.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function Jae(n, e) {
  let t = n.state.facet(D3);
  return t.length ? t[0](e) : Ne.mac ? e.metaKey : e.ctrlKey;
}
function ele(n, e) {
  let t = n.state.facet(L3);
  return t.length ? t[0](e) : Ne.mac ? !e.altKey : !e.ctrlKey;
}
function tle(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let i = wm(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function nle(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = tn.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const Ss = /* @__PURE__ */ Object.create(null), Cs = /* @__PURE__ */ Object.create(null), J3 = Ne.ie && Ne.ie_version < 15 || Ne.ios && Ne.webkit_version < 604;
function ile(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), eN(n, t.value);
  }, 50);
}
function eN(n, e) {
  let { state: t } = n, i, r = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (AO != null && t.selection.ranges.every((l) => l.empty) && AO == s.toString()) {
    let l = -1;
    i = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let h = t.toText((o ? s.line(r++).text : e) + t.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: ue.cursor(c.from + h.length)
      };
    });
  } else
    o ? i = t.changeByRange((l) => {
      let c = s.line(r++);
      return {
        changes: { from: l.from, to: l.to, insert: c.text },
        range: ue.cursor(l.from + c.length)
      };
    }) : i = t.replaceSelection(s);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Cs.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
Ss.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (n.inputState.lastEscPress = Date.now()), !1);
Cs.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
Cs.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
Ss.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let i of n.state.facet(I3))
    if (t = i(n, e), t)
      break;
  if (!t && e.button == 0 && (t = ole(n, e)), t) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new Kae(n, e, t, i)), i && n.observer.ignore(() => b3(n.contentDOM));
    let r = n.inputState.mouseSelection;
    if (r)
      return r.start(e), r.dragging === !1;
  }
  return !1;
};
function N2(n, e, t, i) {
  if (i == 1)
    return ue.cursor(e, t);
  if (i == 2)
    return zae(n.state, e, t);
  {
    let r = Wn.find(n.docView, e), s = n.state.doc.lineAt(r ? r.posAtEnd : e), o = r ? r.posAtStart : s.from, a = r ? r.posAtEnd : s.to;
    return a < n.state.doc.length && a == s.to && a++, ue.range(o, a);
  }
}
let tN = (n, e) => n >= e.top && n <= e.bottom, D2 = (n, e, t) => tN(e, t) && n >= t.left && n <= t.right;
function rle(n, e, t, i) {
  let r = Wn.find(n.docView, e);
  if (!r)
    return 1;
  let s = e - r.posAtStart;
  if (s == 0)
    return 1;
  if (s == r.length)
    return -1;
  let o = r.coordsAt(s, -1);
  if (o && D2(t, i, o))
    return -1;
  let a = r.coordsAt(s, 1);
  return a && D2(t, i, a) ? 1 : o && tN(i, o) ? -1 : 1;
}
function L2(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: rle(n, t, e.clientX, e.clientY) };
}
const sle = Ne.ie && Ne.ie_version <= 11;
let I2 = null, B2 = 0, Q2 = 0;
function nN(n) {
  if (!sle)
    return n.detail;
  let e = I2, t = Q2;
  return I2 = n, Q2 = Date.now(), B2 = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (B2 + 1) % 3 : 1;
}
function ole(n, e) {
  let t = L2(n, e), i = nN(e), r = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), r = r.map(s.changes));
    },
    get(s, o, a) {
      let l = L2(n, s), c, u = N2(n, l.pos, l.bias, i);
      if (t.pos != l.pos && !o) {
        let h = N2(n, t.pos, t.bias, i), d = Math.min(h.from, u.from), f = Math.max(h.to, u.to);
        u = d < u.from ? ue.range(d, f) : ue.range(f, d);
      }
      return o ? r.replaceRange(r.main.extend(u.from, u.to)) : a && i == 1 && r.ranges.length > 1 && (c = ale(r, l.pos)) ? c : a ? r.addRange(u) : ue.create([u]);
    }
  };
}
function ale(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: i, to: r } = n.ranges[t];
    if (i <= e && r >= e)
      return ue.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
Ss.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let r = n.docView.nearest(e.target);
    if (r && r.isWidget) {
      let s = r.posAtStart, o = s + r.length;
      (s >= t.to || o <= t.from) && (t = ue.range(s, o));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", n.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Ss.dragend = (n) => (n.inputState.draggedContent = null, !1);
function z2(n, e, t, i) {
  if (!t)
    return;
  let r = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = n.inputState, o = i && s && ele(n, e) ? { from: s.from, to: s.to } : null, a = { from: r, insert: t }, l = n.state.changes(o ? [o, a] : a);
  n.focus(), n.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(r, -1), head: l.mapPos(r, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
Ss.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let i = Array(t.length), r = 0, s = () => {
      ++r == t.length && z2(n, e, i.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (i[o] = a.result), s();
      }, a.readAsText(t[o]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return z2(n, e, i, !0), !0;
  }
  return !1;
};
Ss.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = J3 ? null : e.clipboardData;
  return t ? (eN(n, t.getData("text/plain") || t.getData("text/uri-text")), !0) : (ile(n), !1);
};
function lle(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
function cle(n) {
  let e = [], t = [], i = !1;
  for (let r of n.selection.ranges)
    r.empty || (e.push(n.sliceDoc(r.from, r.to)), t.push(r));
  if (!e.length) {
    let r = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > r && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), r = o.number;
    }
    i = !0;
  }
  return { text: e.join(n.lineBreak), ranges: t, linewise: i };
}
let AO = null;
Ss.copy = Ss.cut = (n, e) => {
  let { text: t, ranges: i, linewise: r } = cle(n.state);
  if (!t && !r)
    return !1;
  AO = r ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = J3 ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (lle(n, t), !1);
};
const iN = /* @__PURE__ */ na.define();
function rN(n, e) {
  let t = [];
  for (let i of n.facet(z3)) {
    let r = i(n, e);
    r && t.push(r);
  }
  return t ? n.update({ effects: t, annotations: iN.of(!0) }) : null;
}
function sN(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = rN(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
Cs.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), sN(n);
};
Cs.blur = (n) => {
  n.observer.clearSelectionRange(), sN(n);
};
Cs.compositionstart = Cs.compositionupdate = (n) => {
  n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0);
};
Cs.compositionend = (n) => {
  n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, Ne.chrome && Ne.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50);
};
Cs.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
Ss.beforeinput = (n, e) => {
  var t;
  let i;
  if (Ne.chrome && Ne.android && (i = G3.find((r) => r.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let r = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > r + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return !1;
};
const j2 = /* @__PURE__ */ new Set();
function ule(n) {
  j2.has(n) || (j2.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const V2 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class hle {
  constructor(e) {
    this.lineWrapping = e, this.doc = $t.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return V2.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (t = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, r, s, o) {
    let a = V2.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = i, this.textHeight = r, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class dle {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Us {
  /**
  @internal
  */
  constructor(e, t, i, r, s) {
    this.from = e, this.length = t, this.top = i, this.height = r, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Wi.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Wa ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Us(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var en = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(en || (en = {}));
const kg = 1e-3;
class Hi {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > kg && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return Hi.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, r) {
    let s = this, o = i.doc;
    for (let a = r.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: h } = r[a], d = s.lineAt(l, en.ByPosNoHeight, i.setDoc(t), 0, 0), f = d.to >= c ? d : s.lineAt(c, en.ByPosNoHeight, i, 0, 0);
      for (h += f.to - c, c = f.to; a > 0 && d.from <= r[a - 1].toA; )
        l = r[a - 1].fromA, u = r[a - 1].fromB, a--, l < d.from && (d = s.lineAt(l, en.ByPosNoHeight, i, 0, 0));
      u += d.from - l, l = d.from;
      let p = fx.build(i.setDoc(o), e, u, h);
      s = s.replace(l, c, p);
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new xr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, r = 0, s = 0;
    for (; ; )
      if (t == i)
        if (r > s * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), i += 1 + a.break, r -= a.size;
        } else if (s > r * 2) {
          let a = e[i];
          a.break ? e.splice(i, 1, a.left, null, a.right) : e.splice(i, 1, a.left, a.right), i += 2 + a.break, s -= a.size;
        } else
          break;
      else if (r < s) {
        let a = e[t++];
        a && (r += a.size);
      } else {
        let a = e[--i];
        a && (s += a.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, i++), new fle(Hi.of(e.slice(0, t)), o, Hi.of(e.slice(i)));
  }
}
Hi.prototype.size = 1;
class oN extends Hi {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, r) {
    return new Us(r, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, r, s) {
    return this.blockAt(0, i, r, s);
  }
  forEachLine(e, t, i, r, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, i, r, s));
  }
  updateHeight(e, t = 0, i = !1, r) {
    return r && r.from <= t && r.more && this.setHeight(e, r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class xr extends oN {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, r) {
    return new Us(r, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof xr || r instanceof gi && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof gi ? r = new xr(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : Hi.of(i);
  }
  updateHeight(e, t = 0, i = !1, r) {
    return r && r.from <= t && r.more ? this.setHeight(e, r.heights[r.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class gi extends Hi {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, r = e.doc.lineAt(t + this.length).number, s = r - i + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: i, lastLine: r, perLine: o, perChar: a };
  }
  blockAt(e, t, i, r) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(t, r);
    if (t.lineWrapping) {
      let c = r + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), u = t.doc.lineAt(c), h = a + u.length * l, d = Math.max(i, e - h / 2);
      return new Us(u.from, u.length, d, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - i) / a))), { from: u, length: h } = t.doc.line(s + c);
      return new Us(u, h, i + a * c, a, 0);
    }
  }
  lineAt(e, t, i, r, s) {
    if (t == en.ByHeight)
      return this.blockAt(e, i, r, s);
    if (t == en.ByPosNoHeight) {
      let { from: f, to: p } = i.doc.lineAt(e);
      return new Us(f, p - f, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(i, s), c = i.doc.lineAt(e), u = a + c.length * l, h = c.number - o, d = r + a * h + l * (c.from - s - h);
    return new Us(c.from, c.length, Math.max(r, Math.min(d, r + this.height - u)), u, 0);
  }
  forEachLine(e, t, i, r, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(i, s);
    for (let u = e, h = r; u <= t; ) {
      let d = i.doc.lineAt(u);
      if (u == e) {
        let p = d.number - a;
        h += l * p + c * (e - s - p);
      }
      let f = l + c * d.length;
      o(new Us(d.from, d.length, h, f, 0)), h += f, u = d.to + 1;
    }
  }
  replace(e, t, i) {
    let r = this.length - t;
    if (r > 0) {
      let s = i[i.length - 1];
      s instanceof gi ? i[i.length - 1] = new gi(s.length + r) : i.push(null, new gi(r - 1));
    }
    if (e > 0) {
      let s = i[0];
      s instanceof gi ? i[0] = new gi(e + s.length) : i.unshift(new gi(e - 1), null);
    }
    return Hi.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new gi(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new gi(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, r) {
    let s = t + this.length;
    if (r && r.from <= t + this.length && r.more) {
      let o = [], a = Math.max(t, r.from), l = -1;
      for (r.from > t && o.push(new gi(r.from - t - 1).updateHeight(e, t)); a <= s && r.more; ) {
        let u = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let h = r.heights[r.index++];
        l == -1 ? l = h : Math.abs(h - l) >= kg && (l = -2);
        let d = new xr(u, h);
        d.outdated = !1, o.push(d), a += u + 1;
      }
      a <= s && o.push(null, new gi(s - a).updateHeight(e, a));
      let c = Hi.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= kg || Math.abs(l - this.heightMetrics(e, t).perLine) >= kg) && (e.heightChanged = !0), c;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class fle extends Hi {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, r) {
    let s = i + this.left.height;
    return e < s ? this.left.blockAt(e, t, i, r) : this.right.blockAt(e, t, s, r + this.left.length + this.break);
  }
  lineAt(e, t, i, r, s) {
    let o = r + this.left.height, a = s + this.left.length + this.break, l = t == en.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, t, i, r, s) : this.right.lineAt(e, t, i, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = t == en.ByPosNoHeight ? en.ByPosNoHeight : en.ByPos;
    return l ? c.join(this.right.lineAt(a, u, i, o, a)) : this.left.lineAt(a, u, i, r, s).join(c);
  }
  forEachLine(e, t, i, r, s, o) {
    let a = r + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, i, r, s, o), t >= l && this.right.forEachLine(e, t, i, a, l, o);
    else {
      let c = this.lineAt(l, en.ByPos, i, r, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, i, r, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, i, a, l, o);
    }
  }
  replace(e, t, i) {
    let r = this.left.length + this.break;
    if (t < r)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - r, t - r, i));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let a of i)
      s.push(a);
    if (e > 0 && F2(s, o - 1), t < this.length) {
      let a = s.length;
      this.decomposeRight(t, s), F2(s, a);
    }
    return Hi.of(s);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, r = i + this.break;
    if (e >= r)
      return this.right.decomposeRight(e - r, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < r && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Hi.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, r) {
    let { left: s, right: o } = this, a = t + s.length + this.break, l = null;
    return r && r.from <= t + s.length && r.more ? l = s = s.updateHeight(e, t, i, r) : s.updateHeight(e, t, i), r && r.from <= a + o.length && r.more ? l = o = o.updateHeight(e, a, i, r) : o.updateHeight(e, a, i), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function F2(n, e) {
  let t, i;
  n[e] == null && (t = n[e - 1]) instanceof gi && (i = n[e + 1]) instanceof gi && n.splice(e - 1, 3, new gi(t.length + 1 + i.length));
}
const ple = 5;
class fx {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof xr ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new xr(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let o = t - e;
      i.block ? this.addBlock(new oN(o, r, i)) : (o || s || r >= ple) && this.addLineDeco(r, s, o);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new xr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new gi(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof xr)
      return e;
    let t = new xr(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof xr) && !this.isCovered ? this.nodes.push(new xr(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let r of this.nodes)
      r instanceof xr && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, r) {
    let s = new fx(i, e);
    return kt.spans(t, i, r, s, 0), s.finish(i);
  }
}
function gle(n, e, t) {
  let i = new mle();
  return kt.compare(n, e, t, i, 0), i.changes;
}
class mle {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, r) {
    (e < t || i && i.heightRelevant || r && r.heightRelevant) && wO(e, t, this.changes, 5);
  }
}
function vle(n, e) {
  let t = n.getBoundingClientRect(), i = n.ownerDocument, r = i.defaultView || window, s = Math.max(0, t.left), o = Math.min(r.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(r.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let d = u.getBoundingClientRect();
        s = Math.max(s, d.left), o = Math.min(o, d.right), a = Math.max(a, d.top), l = c == n.parentNode ? d.bottom : Math.min(l, d.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function ble(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class X0 {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i], s = t[i];
      if (r.from != s.from || r.to != s.to || r.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return He.replace({
      widget: new yle(this.size * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class yle extends ia {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Z2 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = q2, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = nn.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(hx).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new hle(t), this.stateDeco = e.facet(sf).filter((i) => typeof i != "function"), this.heightMap = Hi.empty().applyChanges(this.stateDeco, $t.empty, this.heightOracle.setDoc(e.doc), [new Wr(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = He.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => r >= s && r <= o)) {
        let { from: s, to: o } = this.lineBlockAt(r);
        e.push(new Pp(s, o));
      }
    }
    this.viewports = e.sort((i, r) => i.from - r.from), this.scaler = this.heightMap.height <= 7e6 ? q2 : new xle(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : qh(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(sf).filter((u) => typeof u != "function");
    let r = e.changedRanges, s = Wr.extendWithRanges(r, gle(i, this.stateDeco, e ? e.changes : Hn.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let c = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(V3) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), r = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? nn.RTL : nn.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), a = t.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: w, scaleY: x } = v3(t, a);
      (this.scaleX != w || this.scaleY != x) && (this.scaleX = w, this.scaleY = x, c |= 8, o = l = !0);
    }
    let h = (parseInt(i.paddingTop) || 0) * this.scaleY, d = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != d) && (this.paddingTop = h, this.paddingBottom = d, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let f = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f && (this.scrollAnchorHeight = -1, this.scrollTop = f), this.scrolledToBottom = O3(e.scrollDOM);
    let p = (this.printing ? ble : vle)(t, this.paddingTop), g = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v != this.inView && (this.inView = v, v && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let y = a.width;
    if ((this.contentDOMWidth != y || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), l) {
      let w = e.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(w) && (o = !0), o || r.lineWrapping && Math.abs(y - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: x, charWidth: S, textHeight: C } = e.docView.measureTextSize();
        o = x > 0 && r.refresh(s, x, S, C, y / S, w), o && (e.docView.minWidth = 0, c |= 8);
      }
      g > 0 && m > 0 ? u = Math.max(g, m) : g < 0 && m < 0 && (u = Math.min(g, m)), r.heightChanged = !1;
      for (let x of this.viewports) {
        let S = x.from == this.viewport.from ? w : e.docView.measureVisibleLineHeights(x);
        this.heightMap = (o ? Hi.empty().applyChanges(this.stateDeco, $t.empty, this.heightOracle, [new Wr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, o, new dle(x.from, S));
      }
      r.heightChanged && (c |= 2);
    }
    let b = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b && (this.viewport = this.getViewport(u, this.scrollTarget)), this.updateForViewport(), (c & 2 || b) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), r = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new Pp(r.lineAt(o - i * 1e3, en.ByHeight, s, 0, 0).from, r.lineAt(a + (1 - i) * 1e3, en.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = r.lineAt(c, en.ByPos, s, 0, 0), d;
        t.y == "center" ? d = (h.top + h.bottom) / 2 - u / 2 : t.y == "start" || t.y == "nearest" && c < l.from ? d = h.top : d = h.bottom - u, l = new Pp(r.lineAt(d - 1e3 / 2, en.ByHeight, s, 0, 0).from, r.lineAt(d + u + 1e3 / 2, en.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), r = t.mapPos(e.to, 1);
    return new Pp(this.heightMap.lineAt(i, en.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, en.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(e, en.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, en.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || r <= o - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= a + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && r > o - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let r of e)
      t.touchesRange(r.from, r.to) || i.push(new X0(t.mapPos(r.from), t.mapPos(r.to), r.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, s = r >> 1, o = r << 1;
    if (this.defaultTextDirection != nn.LTR && !i)
      return [];
    let a = [], l = (c, u, h, d) => {
      if (u - c < s)
        return;
      let f = this.state.selection.main, p = [f.from];
      f.empty || p.push(f.to);
      for (let m of p)
        if (m > c && m < u) {
          l(c, m - 10, h, d), l(m + 10, u, h, d);
          return;
        }
      let g = wle(e, (m) => m.from >= h.from && m.to <= h.to && Math.abs(m.from - c) < s && Math.abs(m.to - u) < s && !p.some((v) => m.from < v && m.to > v));
      if (!g) {
        if (u < h.to && t && i && t.visibleRanges.some((m) => m.from <= u && m.to >= u)) {
          let m = t.moveToLineBoundary(ue.cursor(u), !1, !0).head;
          m > c && (u = m);
        }
        g = new X0(c, u, this.gapSize(h, c, u, d));
      }
      a.push(g);
    };
    for (let c of this.viewportLines) {
      if (c.length < o)
        continue;
      let u = Ole(c.from, c.to, this.stateDeco);
      if (u.total < o)
        continue;
      let h = this.scrollTarget ? this.scrollTarget.range.head : null, d, f;
      if (i) {
        let p = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, m;
        if (h != null) {
          let v = Ap(u, h), y = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;
          g = v - y, m = v + y;
        } else
          g = (this.visibleTop - c.top - p) / c.height, m = (this.visibleBottom - c.top + p) / c.height;
        d = Ep(u, g), f = Ep(u, m);
      } else {
        let p = u.total * this.heightOracle.charWidth, g = r * this.heightOracle.charWidth, m, v;
        if (h != null) {
          let y = Ap(u, h), b = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          m = y - b, v = y + b;
        } else
          m = (this.pixelViewport.left - g) / p, v = (this.pixelViewport.right + g) / p;
        d = Ep(u, m), f = Ep(u, v);
      }
      d > c.from && l(c.from, d, c, u), f < c.to && l(f, c.to, c, u);
    }
    return a;
  }
  gapSize(e, t, i, r) {
    let s = Ap(r, i) - Ap(r, t);
    return this.heightOracle.lineWrapping ? e.height * s : r.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    X0.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = He.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    kt.spans(e, this.viewport.from, this.viewport.to, {
      span(r, s) {
        t.push({ from: r, to: s });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((r, s) => r.from != t[s].from || r.to != t[s].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || qh(this.heightMap.lineAt(e, en.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return qh(this.heightMap.lineAt(this.scaler.fromDOM(e), en.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return qh(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Pp {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function Ole(n, e, t) {
  let i = [], r = n, s = 0;
  return kt.spans(t, n, e, {
    span() {
    },
    point(o, a) {
      o > r && (i.push({ from: r, to: o }), s += o - r), r = a;
    }
  }, 20), r < e && (i.push({ from: r, to: e }), s += e - r), { total: s, ranges: i };
}
function Ep({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(n * t);
  for (let r = 0; ; r++) {
    let { from: s, to: o } = e[r], a = o - s;
    if (i <= a)
      return s + i;
    i -= a;
  }
}
function Ap(n, e) {
  let t = 0;
  for (let { from: i, to: r } of n.ranges) {
    if (e <= r) {
      t += e - i;
      break;
    }
    t += r - i;
  }
  return t / n.total;
}
function wle(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const q2 = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
class xle {
  constructor(e, t, i) {
    let r = 0, s = 0, o = 0;
    this.viewports = i.map(({ from: a, to: l }) => {
      let c = t.lineAt(a, en.ByPos, e, 0, 0).top, u = t.lineAt(l, en.ByPos, e, 0, 0).bottom;
      return r += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (t.height - r);
    for (let a of this.viewports)
      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return r + (e - i) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      i = s.bottom, r = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return i + (e - r) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      i = s.bottom, r = s.domBottom;
    }
  }
}
function qh(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), i = e.toDOM(n.bottom);
  return new Us(n.from, n.length, t, i - t, Array.isArray(n._content) ? n._content.map((r) => qh(r, e)) : n._content);
}
const $p = /* @__PURE__ */ Me.define({ combine: (n) => n.join(" ") }), $O = /* @__PURE__ */ Me.define({ combine: (n) => n.indexOf(!0) > -1 }), TO = /* @__PURE__ */ Za.newName(), aN = /* @__PURE__ */ Za.newName(), lN = /* @__PURE__ */ Za.newName(), cN = { "&light": "." + aN, "&dark": "." + lN };
function _O(n, e, t) {
  return new Za(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return n;
        if (!t || !t[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return t[r];
      }) : n + " " + i;
    }
  });
}
const Sle = /* @__PURE__ */ _O("." + TO, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, cN), Wh = "￿";
class Cle {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(Et.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Wh;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let r = e; ; ) {
      this.findPointBefore(i, r);
      let s = this.text.length;
      this.readNode(r);
      let o = r.nextSibling;
      if (o == t)
        break;
      let a = tn.get(r), l = tn.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : W2(r)) || W2(o) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > s) && this.lineBreak(), r = o;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, a;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (a = r.exec(t)) && (s = a.index, o = a[0].length), this.append(t.slice(i, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      i = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = tn.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (kle(e, i.node, i.offset) ? t : 0));
  }
}
function kle(n, e, t) {
  for (; ; ) {
    if (!e || t < Ho(e))
      return !1;
    if (e == n)
      return !0;
    t = rf(e) + 1, e = e.parentNode;
  }
}
function W2(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
class H2 {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class Ple {
  constructor(e, t, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let a = s || o ? [] : $le(e), l = new Cle(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = Tle(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !gO(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !gO(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((Ne.ios || Ne.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(l, c), d = Math.max(l, c), f = u.from - h, p = u.to - d;
        (f == 0 || f == 1 || h == 0) && (p == 0 || p == -1 || d == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = ue.single(c, l);
    }
  }
}
function uN(n, e) {
  let t, { newSel: i } = e, r = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = r.from, c = null;
    (s === 8 || Ne.android && e.text.length < a - o) && (l = r.to, c = "end");
    let u = Ale(n.state.doc.sliceString(o, a, Wh), e.text, l - o, c);
    u && (Ne.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Wh + Wh && u.toB--, t = {
      from: o + u.from,
      to: o + u.toA,
      insert: $t.of(e.text.slice(u.from, u.toB).split(Wh))
    });
  } else
    i && (!n.hasFocus && n.state.facet(Iv) || i.main.eq(r)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !r.empty && i && i.main.empty ? t = { from: r.from, to: r.to, insert: n.state.doc.slice(r.from, r.to) } : t && t.from >= r.from && t.to <= r.to && (t.from != r.from || t.to != r.to) && r.to - r.from - (t.to - t.from) <= 4 ? t = {
    from: r.from,
    to: r.to,
    insert: n.state.doc.slice(r.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, r.to))
  } : (Ne.mac || Ne.android) && t && t.from == t.to && t.from == r.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = ue.single(i.main.anchor - 1, i.main.head - 1)), t = { from: r.from, to: r.to, insert: $t.of([" "]) }) : Ne.chrome && t && t.from == t.to && t.from == r.head && t.insert.toString() == `
 ` && n.lineWrapping && (i && (i = ue.single(i.main.anchor - 1, i.main.head - 1)), t = { from: r.from, to: r.to, insert: $t.of([" "]) }), t) {
    if (Ne.ios && n.inputState.flushIOSKey() || Ne.android && (t.from == r.from && t.to == r.to && t.insert.length == 1 && t.insert.lines == 2 && Uc(n.contentDOM, "Enter", 13) || (t.from == r.from - 1 && t.to == r.to && t.insert.length == 0 || s == 8 && t.insert.length < t.to - t.from && t.to > r.head) && Uc(n.contentDOM, "Backspace", 8) || t.from == r.from && t.to == r.to + 1 && t.insert.length == 0 && Uc(n.contentDOM, "Delete", 46)))
      return !0;
    let o = t.insert.toString();
    n.inputState.composing >= 0 && n.inputState.composing++;
    let a, l = () => a || (a = Ele(n, t, i));
    return n.state.facet(Q3).some((c) => c(n, t.from, t.to, o, l)) || n.dispatch(l()), !0;
  } else if (i && !i.main.eq(r)) {
    let o = !1, a = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), a = n.inputState.lastSelectionOrigin), n.dispatch({ selection: i, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function Ele(n, e, t) {
  let i, r = n.state, s = r.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let a = s.from < e.from ? r.sliceDoc(s.from, e.from) : "", l = s.to > e.to ? r.sliceDoc(e.to, s.to) : "";
    i = r.replaceSelection(n.state.toText(a + e.insert.sliceString(0, void 0, n.state.lineBreak) + l));
  } else {
    let a = r.changes(e), l = t && t.main.to <= a.newLength ? t.main : void 0;
    if (r.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = n.state.sliceDoc(e.from, e.to), u, h = t && X3(n, t.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - p };
      } else
        u = n.state.doc.lineAt(s.head);
      let d = s.to - e.to, f = s.to - s.from;
      i = r.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: a, range: l || p.map(a) };
        let g = p.to - d, m = g - c.length;
        if (p.to - p.from != f || n.state.sliceDoc(m, g) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let v = r.changes({ from: m, to: g, insert: e.insert }), y = p.to - s.to;
        return {
          changes: v,
          range: l ? ue.range(Math.max(0, l.anchor + y), Math.max(0, l.head + y)) : p.map(v)
        };
      });
    } else
      i = {
        changes: a,
        selection: l && r.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: o, scrollIntoView: !0 });
}
function Ale(n, e, t, i) {
  let r = Math.min(n.length, e.length), s = 0;
  for (; s < r && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == r && n.length == e.length)
    return null;
  let o = n.length, a = e.length;
  for (; o > 0 && a > 0 && n.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (i == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    t -= o + l - s;
  }
  if (o < s && n.length < e.length) {
    let l = t <= s && t >= o ? s - t : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = t <= s && t >= a ? s - t : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { from: s, toA: o, toB: a };
}
function $le(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: r, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new H2(t, i)), (r != t || s != i) && e.push(new H2(r, s))), e;
}
function Tle(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, i = n.length == 2 ? n[1].pos : t;
  return t > -1 && i > -1 ? ue.single(t + e, i + e) : null;
}
const _le = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Y0 = Ne.ie && Ne.ie_version <= 11;
class Mle {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new gae(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (Ne.ie && Ne.ie_version <= 11 || Ne.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Y0 && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(Iv) ? i.root.activeElement != this.dom : !Sg(i.dom, r))
      return;
    let s = r.anchorNode && i.docView.nearest(r.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (Ne.ie && Ne.ie_version <= 11 || Ne.android && Ne.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    r.focusNode && bd(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Ne.safari && e.root.nodeType == 11 && hae(this.dom.ownerDocument) == this.dom && Rle(this.view) || wm(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let i = Sg(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && vae(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, _le), Y0 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Y0 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Uc(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, r = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (r = !0), t == -1 ? { from: t, to: i } = o : (t = Math.min(o.from, t), i = Math.max(o.to, i)));
    }
    return { from: t, to: i, typeOver: r };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), r = this.selectionChanged && Sg(this.dom, this.selectionRange);
    if (e < 0 && !r)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new Ple(this.view, e, t, i);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, r = uN(this.view, t);
    return this.view.state == i && this.view.update([]), r;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let i = X2(t, e.previousSibling || e.target.previousSibling, -1), r = X2(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: r ? t.posBefore(r) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function X2(n, e, t) {
  for (; e; ) {
    let i = tn.get(e);
    if (i && i.parent == n)
      return i;
    let r = e.parentNode;
    e = r != n.dom ? r : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function Rle(n) {
  let e = null;
  function t(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (n.contentDOM.addEventListener("beforeinput", t, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, r = e.startOffset, s = e.endContainer, o = e.endOffset, a = n.docView.domAtPos(n.state.selection.main.anchor);
  return bd(a.node, a.offset, s, o) && ([i, r, s, o] = [s, o, i, r]), { anchorNode: i, anchorOffset: r, focusNode: s, focusOffset: o };
}
class _e {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: t } = e;
    this.dispatchTransactions = e.dispatchTransactions || t && ((i) => i.forEach((r) => t(r, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || mae(e.parent) || document, this.viewState = new Z2(e.state || Et.create(e)), e.scrollTo && e.scrollTo.is(Sp) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Fh).map((i) => new q0(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new Mle(this), this.inputState = new Xae(this), this.inputState.ensureHandlers(this.plugins), this.docView = new P2(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Dn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, r, s = this.state;
    for (let d of e) {
      if (d.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(iN)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = rN(s, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(Et.phrases) != this.state.facet(Et.phrases))
      return this.setState(s);
    r = xm.create(this, s, e), r.flags |= a;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (h && (h = h.map(d.changes)), d.scrollIntoView) {
          let { main: f } = d.state.selection;
          h = new Gc(f.empty ? f : ue.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of d.effects)
          f.is(Sp) && (h = f.value.clip(this.state));
      }
      this.viewState.update(r, h), this.bidiCache = Sm.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), t = this.docView.update(r), this.state.facet(Zh) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet($p) != r.state.facet($p) && (this.viewState.mustMeasureContent = !0), (t || i || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !r.empty)
      for (let d of this.state.facet(kO))
        try {
          d(r);
        } catch (f) {
          qr(this.state, f, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !uN(this, u) && c.force && Uc(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new Z2(e), this.plugins = e.facet(Fh).map((i) => new q0(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new P2(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Fh), i = e.state.facet(Fh);
    if (t != i) {
      let r = [];
      for (let s of i) {
        let o = t.indexOf(s);
        if (o < 0)
          r.push(new q0(s));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, r.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = e;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    t != i && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (O3(i))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let f = this.viewState.scrollAnchorAt(r);
            s = f.from, o = f.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((f) => {
          try {
            return f.read(this);
          } catch (p) {
            return qr(this.state, p), Y2;
          }
        }), h = xm.create(this, this.state, []), d = !1;
        h.flags |= l, t ? t.flags |= l : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), d = this.docView.update(h));
        for (let f = 0; f < c.length; f++)
          if (u[f] != Y2)
            try {
              let p = c[f];
              p.write && p.write(u[f], this);
            } catch (p) {
              qr(this.state, p);
            }
        if (d && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                r = r + p, i.scrollTop = r / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(kO))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return TO + " " + (this.state.facet($O) ? lN : aN) + " " + this.state.facet($p);
  }
  updateAttrs() {
    let e = U2(this, F3, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Iv) ? "true" : "false",
      class: "cm-content",
      style: `${Ne.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), U2(this, hx, t);
    let i = this.observer.ignore(() => {
      let r = OO(this.contentDOM, this.contentAttrs, t), s = OO(this.dom, this.editorAttrs, e);
      return r || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let r of i.effects)
        if (r.is(_e.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Zh);
    let e = this.state.facet(_e.cspNonce);
    Za.mount(this.root, this.styleModules.concat(Sle).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return H0(this, e, M2(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return H0(this, e, M2(this, e, t, (i) => Wae(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let i = this.bidiSpans(e), r = this.textDirectionAt(e.from), s = i[t ? i.length - 1 : 0];
    return ue.cursor(s.side(t, r) + e.from, s.forward(!t, r) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = !0) {
    return qae(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return H0(this, e, Hae(this, e, t, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), U3(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(e), s = this.bidiSpans(r), o = s[$a.find(s, e - r.from, -1, t)];
    return ax(i, o.dir == nn.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(j3) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Nle)
      return R3(e.length);
    let t = this.textDirectionAt(e.from), i;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || M3(s.isolates, i = k2(this, e))))
        return s.order;
    i || (i = k2(this, e));
    let r = $ae(e.text, t, i);
    return this.bidiCache.push(new Sm(e.from, e.to, t, i, !0, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Ne.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      b3(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Sp.of(new Gc(typeof e == "number" ? ue.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return Sp.of(new Gc(ue.cursor(i.from), "start", "start", i.top - e, t, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Qn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Qn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = Za.newName(), r = [$p.of(i), Zh.of(_O(`.${i}`, e))];
    return t && t.dark && r.push($O.of(!0)), r;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return hc.lowest(Zh.of(_O("." + TO, e, cN)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), r = i && tn.get(i) || tn.get(e);
    return ((t = r == null ? void 0 : r.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
_e.styleModule = Zh;
_e.inputHandler = Q3;
_e.focusChangeEffect = z3;
_e.perLineTextDirection = j3;
_e.exceptionSink = B3;
_e.updateListener = kO;
_e.editable = Iv;
_e.mouseSelectionStyle = I3;
_e.dragMovesSelection = L3;
_e.clickAddsSelectionRange = D3;
_e.decorations = sf;
_e.outerDecorations = Z3;
_e.atomicRanges = dx;
_e.bidiIsolatedRanges = q3;
_e.scrollMargins = W3;
_e.darkTheme = $O;
_e.cspNonce = /* @__PURE__ */ Me.define({ combine: (n) => n.length ? n[0] : "" });
_e.contentAttributes = hx;
_e.editorAttributes = F3;
_e.lineWrapping = /* @__PURE__ */ _e.contentAttributes.of({ class: "cm-lineWrapping" });
_e.announce = /* @__PURE__ */ ct.define();
const Nle = 4096, Y2 = {};
class Sm {
  constructor(e, t, i, r, s, o) {
    this.from = e, this.to = t, this.dir = i, this.isolates = r, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let i = [], r = e.length ? e[e.length - 1].dir : nn.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == r && !t.touchesRange(o.from, o.to) && i.push(new Sm(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return i;
  }
}
function U2(n, e, t) {
  for (let i = n.state.facet(e), r = i.length - 1; r >= 0; r--) {
    let s = i[r], o = typeof s == "function" ? s(n) : s;
    o && yO(o, t);
  }
  return t;
}
const Dle = Ne.mac ? "mac" : Ne.windows ? "win" : Ne.linux ? "linux" : "key";
function Lle(n, e) {
  const t = n.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let r, s, o, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (i = "Alt-" + i), s && (i = "Ctrl-" + i), a && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function Tp(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const Ile = /* @__PURE__ */ hc.default(/* @__PURE__ */ _e.domEventHandlers({
  keydown(n, e) {
    return dN(hN(e.state), n, e, "editor");
  }
})), Bv = /* @__PURE__ */ Me.define({ enables: Ile }), G2 = /* @__PURE__ */ new WeakMap();
function hN(n) {
  let e = n.facet(Bv), t = G2.get(e);
  return t || G2.set(e, t = zle(e.reduce((i, r) => i.concat(r), []))), t;
}
function Ble(n, e, t) {
  return dN(hN(n.state), e, n, t);
}
let wa = null;
const Qle = 4e3;
function zle(n, e = Dle) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), r = (o, a) => {
    let l = i[o];
    if (l == null)
      i[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, a, l, c, u) => {
    var h, d;
    let f = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((v) => Lle(v, e));
    for (let v = 1; v < p.length; v++) {
      let y = p.slice(0, v).join(" ");
      r(y, !0), f[y] || (f[y] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(b) => {
          let w = wa = { view: b, prefix: y, scope: o };
          return setTimeout(() => {
            wa == w && (wa = null);
          }, Qle), !0;
        }]
      });
    }
    let g = p.join(" ");
    r(g, !1);
    let m = f[g] || (f[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (h = f._any) === null || h === void 0 ? void 0 : h.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && m.run.push(l), c && (m.preventDefault = !0), u && (m.stopPropagation = !0);
  };
  for (let o of n) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let u = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let h in u)
          u[h].run.push(o.any);
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
function dN(n, e, t, i) {
  let r = uae(e), s = yi(r, 0), o = jr(s) == r.length && r != " ", a = "", l = !1, c = !1, u = !1;
  wa && wa.view == t && wa.scope == i && (a = wa.prefix + " ", K3.indexOf(e.keyCode) < 0 && (c = !0, wa = null));
  let h = /* @__PURE__ */ new Set(), d = (m) => {
    if (m) {
      for (let v of m.run)
        if (!h.has(v) && (h.add(v), v(t, e)))
          return m.stopPropagation && (u = !0), !0;
      m.preventDefault && (m.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, f = n[i], p, g;
  return f && (d(f[a + Tp(r, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Ne.windows && e.ctrlKey && e.altKey) && (p = qa[e.keyCode]) && p != r ? (d(f[a + Tp(p, e, !0)]) || e.shiftKey && (g = tf[e.keyCode]) != r && g != p && d(f[a + Tp(g, e, !1)])) && (l = !0) : o && e.shiftKey && d(f[a + Tp(r, e, !0)]) && (l = !0), !l && d(f._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), l;
}
class zf {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, i, r, s) {
    this.className = e, this.left = t, this.top = i, this.width = r, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, i) {
    if (i.empty) {
      let r = e.coordsAtPos(i.head, i.assoc || 1);
      if (!r)
        return [];
      let s = fN(e);
      return [new zf(t, r.left - s.left, r.top - s.top, null, r.bottom - r.top)];
    } else
      return jle(e, t, i);
  }
}
function fN(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == nn.LTR ? e.left : e.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: e.top - n.scrollDOM.scrollTop * n.scaleY };
}
function K2(n, e, t) {
  let i = ue.cursor(e);
  return {
    from: Math.max(t.from, n.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(t.to, n.moveToLineBoundary(i, !0, !0).from),
    type: Wi.Text
  };
}
function jle(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let i = Math.max(t.from, n.viewport.from), r = Math.min(t.to, n.viewport.to), s = n.textDirection == nn.LTR, o = n.contentDOM, a = o.getBoundingClientRect(), l = fN(n), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), d = a.right - (u ? parseInt(u.paddingRight) : 0), f = EO(n, i), p = EO(n, r), g = f.type == Wi.Text ? f : null, m = p.type == Wi.Text ? p : null;
  if (g && (n.lineWrapping || f.widgetLineBreaks) && (g = K2(n, i, g)), m && (n.lineWrapping || p.widgetLineBreaks) && (m = K2(n, r, m)), g && m && g.from == m.from)
    return y(b(t.from, t.to, g));
  {
    let x = g ? b(t.from, null, g) : w(f, !1), S = m ? b(null, t.to, m) : w(p, !0), C = [];
    return (g || f).to < (m || p).from - (g && m ? 1 : 0) || f.widgetLineBreaks > 1 && x.bottom + n.defaultLineHeight / 2 < S.top ? C.push(v(h, x.bottom, d, S.top)) : x.bottom < S.top && n.elementAtHeight((x.bottom + S.top) / 2).type == Wi.Text && (x.bottom = S.top = (x.bottom + S.top) / 2), y(x).concat(C).concat(y(S));
  }
  function v(x, S, C, k) {
    return new zf(
      e,
      x - l.left,
      S - l.top - 0.01,
      C - x,
      k - S + 0.01
      /* C.Epsilon */
    );
  }
  function y({ top: x, bottom: S, horizontal: C }) {
    let k = [];
    for (let E = 0; E < C.length; E += 2)
      k.push(v(C[E], x, C[E + 1], S));
    return k;
  }
  function b(x, S, C) {
    let k = 1e9, E = -1e9, M = [];
    function _(I, P, A, N, q) {
      let j = n.coordsAtPos(I, I == C.to ? -2 : 2), H = n.coordsAtPos(A, A == C.from ? 2 : -2);
      !j || !H || (k = Math.min(j.top, H.top, k), E = Math.max(j.bottom, H.bottom, E), q == nn.LTR ? M.push(s && P ? h : j.left, s && N ? d : H.right) : M.push(!s && N ? h : H.left, !s && P ? d : j.right));
    }
    let T = x ?? C.from, B = S ?? C.to;
    for (let I of n.visibleRanges)
      if (I.to > T && I.from < B)
        for (let P = Math.max(I.from, T), A = Math.min(I.to, B); ; ) {
          let N = n.state.doc.lineAt(P);
          for (let q of n.bidiSpans(N)) {
            let j = q.from + N.from, H = q.to + N.from;
            if (j >= A)
              break;
            H > P && _(Math.max(j, P), x == null && j <= T, Math.min(H, A), S == null && H >= B, q.dir);
          }
          if (P = N.to + 1, P >= A)
            break;
        }
    return M.length == 0 && _(T, x == null, B, S == null, n.textDirection), { top: k, bottom: E, horizontal: M };
  }
  function w(x, S) {
    let C = a.top + (S ? x.top : x.bottom);
    return { top: C, bottom: C, horizontal: [] };
  }
}
function Vle(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class Fle {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Pg) != e.state.facet(Pg) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let t = 0, i = e.facet(Pg);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !Vle(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let r of e)
        r.update && t && r.constructor && this.drawn[i].constructor && r.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(r.draw(), t);
      for (; t; ) {
        let r = t.nextSibling;
        t.remove(), t = r;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Pg = /* @__PURE__ */ Me.define();
function pN(n) {
  return [
    Qn.define((e) => new Fle(e, n)),
    Pg.of(n)
  ];
}
const gN = !Ne.ios, of = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function Zle(n = {}) {
  return [
    of.of(n),
    qle,
    Wle,
    Hle,
    V3.of(!0)
  ];
}
function mN(n) {
  return n.startState.facet(of) != n.state.facet(of);
}
const qle = /* @__PURE__ */ pN({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(of), i = [];
    for (let r of e.selection.ranges) {
      let s = r == e.selection.main;
      if (r.empty ? !s || gN : t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = r.empty ? r : ue.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let l of zf.forRange(n, o, a))
          i.push(l);
      }
    }
    return i;
  },
  update(n, e) {
    n.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = mN(n);
    return t && J2(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    J2(e.state, n);
  },
  class: "cm-cursorLayer"
});
function J2(n, e) {
  e.style.animationDuration = n.facet(of).cursorBlinkRate + "ms";
}
const Wle = /* @__PURE__ */ pN({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : zf.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || mN(n);
  },
  class: "cm-selectionLayer"
}), MO = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
gN && (MO[".cm-line"].caretColor = "transparent !important", MO[".cm-content"] = { caretColor: "transparent !important" });
const Hle = /* @__PURE__ */ hc.highest(/* @__PURE__ */ _e.theme(MO)), vN = /* @__PURE__ */ ct.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), Hh = /* @__PURE__ */ hi.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, i) => i.is(vN) ? i.value : t, n);
  }
}), Xle = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(Hh);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(Hh) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, e = n.state.field(Hh), t = e != null && n.coordsAtPos(e);
    if (!t)
      return null;
    let i = n.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: t.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      n ? (this.cursor.style.left = n.left / e + "px", this.cursor.style.top = n.top / t + "px", this.cursor.style.height = n.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(Hh) != n && this.view.dispatch({ effects: vN.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function Yle() {
  return [Hh, Xle];
}
function eP(n, e, t, i, r) {
  e.lastIndex = 0;
  for (let s = n.iterRange(t, i), o = t, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; a = e.exec(s.value); )
        r(o + a.index, a);
}
function Ule(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let i = [];
  for (let { from: r, to: s } of t)
    r = Math.max(n.state.doc.lineAt(r).from, r - e), s = Math.min(n.state.doc.lineAt(s).to, s + e), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = s : i.push({ from: r, to: s });
  return i;
}
class Gle {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: i, decorate: r, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, r)
      this.addMatch = (a, l, c, u) => r(u, c, c + a[0].length, a, l);
    else if (typeof i == "function")
      this.addMatch = (a, l, c, u) => {
        let h = i(a, l, c);
        h && u(c, c + a[0].length, h);
      };
    else if (i)
      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Fa(), i = t.add.bind(t);
    for (let { from: r, to: s } of Ule(e, this.maxLength))
      eP(e.state.doc, this.regexp, r, s, (o, a) => this.addMatch(a, e, o, i));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, r = -1;
    return e.docChanged && e.changes.iterChanges((s, o, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (i = Math.min(a, i), r = Math.max(l, r));
    }), e.viewportChanged || r - i > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, t.map(e.changes), i, r) : t;
  }
  updateRange(e, t, i, r) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, i), a = Math.min(s.to, r);
      if (a > o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(s.from, l.from), h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              h = a;
              break;
            }
        }
        let d = [], f, p = (g, m, v) => d.push(v.range(g, m));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (f = this.regexp.exec(l.text)) && f.index < h - l.from; )
            this.addMatch(f, e, f.index + l.from, p);
        else
          eP(e.state.doc, this.regexp, u, h, (g, m) => this.addMatch(m, e, g, p));
        t = t.update({ filterFrom: u, filterTo: h, filter: (g, m) => g < u || m > h, add: d });
      }
    }
    return t;
  }
}
const RO = /x/.unicode != null ? "gu" : "g", Kle = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, RO), Jle = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let U0 = null;
function ece() {
  var n;
  if (U0 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    U0 = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return U0 || !1;
}
const Eg = /* @__PURE__ */ Me.define({
  combine(n) {
    let e = Oo(n, {
      render: null,
      specialChars: Kle,
      addSpecialChars: null
    });
    return (e.replaceTabs = !ece()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, RO)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, RO)), e;
  }
});
function tce(n = {}) {
  return [Eg.of(n), nce()];
}
let tP = null;
function nce() {
  return tP || (tP = Qn.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = He.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(Eg)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new Gle({
        regexp: n.specialChars,
        decoration: (e, t, i) => {
          let { doc: r } = t.state, s = yi(e[0], 0);
          if (s == 9) {
            let o = r.lineAt(i), a = t.state.tabSize, l = bh(o.text, a, i - o.from);
            return He.replace({
              widget: new oce((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = He.replace({ widget: new sce(n, s) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(Eg);
      n.startState.facet(Eg) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const ice = "•";
function rce(n) {
  return n >= 32 ? ice : n == 10 ? "␤" : String.fromCharCode(9216 + n);
}
class sce extends ia {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = rce(this.code), i = e.state.phrase("Control character") + " " + (Jle[this.code] || "0x" + this.code.toString(16)), r = this.options.render && this.options.render(this.code, i, t);
    if (r)
      return r;
    let s = document.createElement("span");
    return s.textContent = t, s.title = i, s.setAttribute("aria-label", i), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class oce extends ia {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function ace() {
  return cce;
}
const lce = /* @__PURE__ */ He.line({ class: "cm-activeLine" }), cce = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let i of n.state.selection.ranges) {
      let r = n.lineBlockAt(i.head);
      r.from > e && (t.push(lce.range(r.from)), e = r.from);
    }
    return He.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), NO = 2e3;
function uce(n, e, t) {
  let i = Math.min(e.line, t.line), r = Math.max(e.line, t.line), s = [];
  if (e.off > NO || t.off > NO || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), a = Math.max(e.off, t.off);
    for (let l = i; l <= r; l++) {
      let c = n.doc.line(l);
      c.length <= a && s.push(ue.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, t.col), a = Math.max(e.col, t.col);
    for (let l = i; l <= r; l++) {
      let c = n.doc.line(l), u = dO(c.text, o, n.tabSize, !0);
      if (u < 0)
        s.push(ue.cursor(c.to));
      else {
        let h = dO(c.text, a, n.tabSize);
        s.push(ue.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function hce(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function nP(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = n.state.doc.lineAt(t), r = t - i.from, s = r > NO ? -1 : r == i.length ? hce(n, e.clientX) : bh(i.text, n.state.tabSize, t - i.from);
  return { line: i.number, col: s, off: r };
}
function dce(n, e) {
  let t = nP(n, e), i = n.state.selection;
  return t ? {
    update(r) {
      if (r.docChanged) {
        let s = r.changes.mapPos(r.startState.doc.line(t.line).from), o = r.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, i = i.map(r.changes);
      }
    },
    get(r, s, o) {
      let a = nP(n, r);
      if (!a)
        return i;
      let l = uce(n.state, t, a);
      return l.length ? o ? ue.create(l.concat(i.ranges)) : ue.create(l) : i;
    }
  } : null;
}
function fce(n) {
  let e = (n == null ? void 0 : n.eventFilter) || ((t) => t.altKey && t.button == 0);
  return _e.mouseSelectionStyle.of((t, i) => e(i) ? dce(t, i) : null);
}
const pce = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, gce = { style: "cursor: crosshair" };
function mce(n = {}) {
  let [e, t] = pce[n.key || "Alt"], i = Qn.fromClass(class {
    constructor(r) {
      this.view = r, this.isDown = !1;
    }
    set(r) {
      this.isDown != r && (this.isDown = r, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(r) {
        this.set(r.keyCode == e || t(r));
      },
      keyup(r) {
        (r.keyCode == e || !t(r)) && this.set(!1);
      },
      mousemove(r) {
        this.set(t(r));
      }
    }
  });
  return [
    i,
    _e.contentAttributes.of((r) => {
      var s;
      return !((s = r.plugin(i)) === null || s === void 0) && s.isDown ? gce : null;
    })
  ];
}
const Mh = "-10000px";
class bN {
  constructor(e, t, i, r) {
    this.facet = t, this.createTooltipView = i, this.removeTooltipView = r, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = i(o, s));
  }
  update(e, t) {
    var i;
    let r = e.state.facet(this.facet), s = r.filter((l) => l);
    if (r === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = t ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let c = s[l], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let d = this.tooltips[h];
          d && d.create == c.create && (u = h);
        }
        if (u < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let h = o[l] = this.tooltipViews[u];
          a && (a[l] = t[u]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return t && (a.forEach((l, c) => t[c] = l), t.length = a.length), this.input = r, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function vce(n) {
  let { win: e } = n;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const G0 = /* @__PURE__ */ Me.define({
  combine: (n) => {
    var e, t, i;
    return {
      position: Ne.ios ? "absolute" : ((e = n.find((r) => r.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((r) => r.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = n.find((r) => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || vce
    };
  }
}), iP = /* @__PURE__ */ new WeakMap(), px = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(G0);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new bN(n, gx, (t, i) => this.createTooltip(t, i), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n, this.above);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, i = n.state.facet(G0);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n, e) {
    let t = n.create(this.view), i = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), n.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let r = document.createElement("div");
      r.className = "cm-tooltip-arrow", t.dom.insertBefore(r, i);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Mh, t.dom.style.left = "0px", this.container.insertBefore(t.dom, i), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var n, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (n = i.destroy) === null || n === void 0 || n.call(i);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = this.view.dom.getBoundingClientRect(), e = 1, t = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: r } = this.manager.tooltipViews[0];
      if (Ne.gecko)
        i = r.offsetParent != this.container.ownerDocument.body;
      else if (r.style.top == Mh && r.style.left == "0px") {
        let s = r.getBoundingClientRect();
        i = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let r = this.parent.getBoundingClientRect();
        r.width && r.height && (e = r.width / this.parent.offsetWidth, t = r.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: t } = this.view.viewState);
    return {
      editor: n,
      parent: this.parent ? this.container.getBoundingClientRect() : n,
      pos: this.manager.tooltips.map((r, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(r.pos) : this.view.coordsAtPos(r.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()),
      space: this.view.state.facet(G0).tooltipSpace(this.view),
      scaleX: e,
      scaleY: t,
      makeAbsolute: i
    };
  }
  writeMeasure(n) {
    var e;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: t, space: i, scaleX: r, scaleY: s } = n, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, h = n.pos[a], d = n.size[a];
      if (!h || h.bottom <= Math.max(t.top, i.top) || h.top >= Math.min(t.bottom, i.bottom) || h.right < Math.max(t.left, i.left) - 0.1 || h.left > Math.min(t.right, i.right) + 0.1) {
        u.style.top = Mh;
        continue;
      }
      let f = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = f ? 7 : 0, g = d.right - d.left, m = (e = iP.get(c)) !== null && e !== void 0 ? e : d.bottom - d.top, v = c.offset || yce, y = this.view.textDirection == nn.LTR, b = d.width > i.right - i.left ? y ? i.left : i.right - d.width : y ? Math.min(h.left - (f ? 14 : 0) + v.x, i.right - g) : Math.max(i.left, h.left - g + (f ? 14 : 0) - v.x), w = this.above[a];
      !l.strictSide && (w ? h.top - (d.bottom - d.top) - v.y < i.top : h.bottom + (d.bottom - d.top) + v.y > i.bottom) && w == i.bottom - h.bottom > h.top - i.top && (w = this.above[a] = !w);
      let x = (w ? h.top - i.top : i.bottom - h.bottom) - p;
      if (x < m && c.resize !== !1) {
        if (x < this.view.defaultLineHeight) {
          u.style.top = Mh;
          continue;
        }
        iP.set(c, m), u.style.height = (m = x) / s + "px";
      } else
        u.style.height && (u.style.height = "");
      let S = w ? h.top - m - p - v.y : h.bottom + p + v.y, C = b + g;
      if (c.overlap !== !0)
        for (let k of o)
          k.left < C && k.right > b && k.top < S + m && k.bottom > S && (S = w ? k.top - m - 2 - p : k.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (S - n.parent.top) / s + "px", u.style.left = (b - n.parent.left) / r + "px") : (u.style.top = S / s + "px", u.style.left = b / r + "px"), f) {
        let k = h.left + (y ? v.x : -v.x) - (b + 14 - 7);
        f.style.left = k / r + "px";
      }
      c.overlap !== !0 && o.push({ left: b, top: S, right: C, bottom: S + m }), u.classList.toggle("cm-tooltip-above", w), u.classList.toggle("cm-tooltip-below", !w), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = Mh;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), bce = /* @__PURE__ */ _e.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), yce = { x: 0, y: 0 }, gx = /* @__PURE__ */ Me.define({
  enables: [px, bce]
}), Cm = /* @__PURE__ */ Me.define({
  combine: (n) => n.reduce((e, t) => e.concat(t), [])
});
class Qv {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Qv(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new bN(e, Cm, (t, i) => this.createHostedView(t, i), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let i of this.manager.tooltipViews) {
      let r = i[e];
      if (r !== void 0) {
        if (t === void 0)
          t = r;
        else if (t !== r)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const Oce = /* @__PURE__ */ gx.compute([Cm], (n) => {
  let e = n.facet(Cm);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var i;
      return (i = t.end) !== null && i !== void 0 ? i : t.pos;
    })),
    create: Qv.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class wce {
  constructor(e, t, i, r, s) {
    this.view = e, this.source = t, this.field = i, this.setHover = r, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, i = e.docView.nearest(t.target);
    if (!i)
      return;
    let r, s = 1;
    if (i instanceof Aa)
      r = i.posAtStart;
    else {
      if (r = e.posAtCoords(t), r == null)
        return;
      let a = e.coordsAtPos(r);
      if (!a || t.y < a.top || t.y > a.bottom || t.x < a.left - e.defaultCharacterWidth || t.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(r)).find((u) => u.from <= r && u.to >= r), c = l && l.dir == nn.RTL ? -1 : 1;
      s = t.x < a.left ? -c : c;
    }
    let o = this.source(e, r, s);
    if (o != null && o.then) {
      let a = this.pending = { pos: r };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => qr(e.state, l, "hover tooltip"));
    } else
      o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(px), t = e ? e.manager.tooltips.findIndex((i) => i.create == Qv.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: r, tooltip: s } = this;
    if (r.length && s && !xce(s.dom, e) || this.pending) {
      let { pos: o } = r[0] || this.pending, a = (i = (t = r[0]) === null || t === void 0 ? void 0 : t.end) !== null && i !== void 0 ? i : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !Sce(this.view, o, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (i) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const _p = 4;
function xce(n, e) {
  let t = n.getBoundingClientRect();
  return e.clientX >= t.left - _p && e.clientX <= t.right + _p && e.clientY >= t.top - _p && e.clientY <= t.bottom + _p;
}
function Sce(n, e, t, i, r, s) {
  let o = n.scrollDOM.getBoundingClientRect(), a = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (o.left > i || o.right < i || o.top > r || Math.min(o.bottom, a) < r)
    return !1;
  let l = n.posAtCoords({ x: i, y: r }, !1);
  return l >= e && l <= t;
}
function Cce(n, e = {}) {
  let t = ct.define(), i = hi.define({
    create() {
      return [];
    },
    update(r, s) {
      if (r.length && (e.hideOnChange && (s.docChanged || s.selection) ? r = [] : e.hideOn && (r = r.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let a of r) {
          let l = s.changes.mapPos(a.pos, -1, xi.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = l, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        r = o;
      }
      for (let o of s.effects)
        o.is(t) && (r = o.value), o.is(kce) && (r = []);
      return r;
    },
    provide: (r) => Cm.from(r)
  });
  return [
    i,
    Qn.define((r) => new wce(
      r,
      n,
      i,
      t,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    Oce
  ];
}
function yN(n, e) {
  let t = n.plugin(px);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const kce = /* @__PURE__ */ ct.define(), rP = /* @__PURE__ */ Me.define({
  combine(n) {
    let e, t;
    for (let i of n)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function af(n, e) {
  let t = n.plugin(ON), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const ON = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(lf), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(rP);
    this.top = new Mp(n, !0, e.topContainer), this.bottom = new Mp(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(rP);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Mp(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Mp(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet(lf);
    if (t != this.input) {
      let i = t.filter((l) => l), r = [], s = [], o = [], a = [];
      for (let l of i) {
        let c = this.specs.indexOf(l), u;
        c < 0 ? (u = l(n.view), a.push(u)) : (u = this.panels[c], u.update && u.update(n)), r.push(u), (u.top ? s : o).push(u);
      }
      this.specs = i, this.panels = r, this.top.sync(s), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => _e.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class Mp {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = sP(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = sP(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function sP(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const lf = /* @__PURE__ */ Me.define({
  enables: ON
});
class Uo extends Kl {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Uo.prototype.elementClass = "";
Uo.prototype.toDOM = void 0;
Uo.prototype.mapMode = xi.TrackBefore;
Uo.prototype.startSide = Uo.prototype.endSide = -1;
Uo.prototype.point = !0;
const Ag = /* @__PURE__ */ Me.define(), Pce = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => kt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Od = /* @__PURE__ */ Me.define();
function Ece(n) {
  return [wN(), Od.of(Object.assign(Object.assign({}, Pce), n))];
}
const DO = /* @__PURE__ */ Me.define({
  combine: (n) => n.some((e) => e)
});
function wN(n) {
  let e = [
    Ace
  ];
  return n && n.fixed === !1 && e.push(DO.of(!0)), e;
}
const Ace = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.view = n, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(Od).map((e) => new aP(n, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !n.state.facet(DO), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    n.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(DO) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && this.dom.remove();
    let t = kt.iter(this.view.state.facet(Ag), this.view.viewport.from), i = [], r = this.gutters.map((s) => new $ce(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(s.type)) {
        let o = !0;
        for (let a of s.type)
          if (a.type == Wi.Text && o) {
            LO(t, i, a.from);
            for (let l of r)
              l.line(this.view, a, i);
            o = !1;
          } else if (a.widget)
            for (let l of r)
              l.widget(this.view, a);
      } else if (s.type == Wi.Text) {
        LO(t, i, s.from);
        for (let o of r)
          o.line(this.view, s, i);
      } else if (s.widget)
        for (let o of r)
          o.widget(this.view, s);
    for (let s of r)
      s.finish();
    n && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(n) {
    let e = n.startState.facet(Od), t = n.state.facet(Od), i = n.docChanged || n.heightChanged || n.viewportChanged || !kt.eq(n.startState.facet(Ag), n.state.facet(Ag), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let r of this.gutters)
        r.update(n) && (i = !0);
    else {
      i = !0;
      let r = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? r.push(new aP(this.view, s)) : (this.gutters[o].update(n), r.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), r.indexOf(s) < 0 && s.destroy();
      for (let s of r)
        this.dom.appendChild(s.dom);
      this.gutters = r;
    }
    return i;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove();
  }
}, {
  provide: (n) => _e.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == nn.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function oP(n) {
  return Array.isArray(n) ? n : [n];
}
function LO(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class $ce {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = kt.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: r } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == r.elements.length) {
      let a = new xN(e, o, s, i);
      r.elements.push(a), r.dom.appendChild(a.dom);
    } else
      r.elements[this.i].update(e, o, s, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let r = [];
    LO(this.cursor, r, t.from), i.length && (r = r.concat(i));
    let s = this.gutter.config.lineMarker(e, t, r);
    s && r.unshift(s);
    let o = this.gutter;
    r.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, r);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t);
    i && this.addElement(e, t, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class aP {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (r) => {
        let s = r.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = r.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[i](e, a, r) && r.preventDefault();
      });
    this.markers = oP(t.markers(e)), t.initialSpacer && (this.spacer = new xN(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = oP(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let r = this.config.updateSpacer(this.spacer.markers[0], e);
      r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]);
    }
    let i = e.view.viewport;
    return !kt.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class xN {
  constructor(e, t, i, r) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, r);
  }
  update(e, t, i, r) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), Tce(this.markers, r) || this.setMarkers(e, r);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", r = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o, l = s < t.length ? t[s++] : null, c = !1;
      if (l) {
        let u = l.elementClass;
        u && (i += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            a = h, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(r);
          let h = r.nextSibling;
          r.remove(), r = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? r = r.nextSibling : this.dom.insertBefore(l.toDOM(e), r)), c && o++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Tce(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const _ce = /* @__PURE__ */ Me.define(), Ic = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let r in t) {
          let s = i[r], o = t[r];
          i[r] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;
        }
        return i;
      }
    });
  }
});
class K0 extends Uo {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function J0(n, e) {
  return n.state.facet(Ic).formatNumber(e, n.state);
}
const Mce = /* @__PURE__ */ Od.compute([Ic], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(_ce);
  },
  lineMarker(e, t, i) {
    return i.some((r) => r.toDOM) ? null : new K0(J0(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Ic) != e.state.facet(Ic),
  initialSpacer(e) {
    return new K0(J0(e, lP(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = J0(t.view, lP(t.view.state.doc.lines));
    return i == e.number ? e : new K0(i);
  },
  domEventHandlers: n.facet(Ic).domEventHandlers
}));
function Rce(n = {}) {
  return [
    Ic.of(n),
    wN(),
    Mce
  ];
}
function lP(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const Nce = /* @__PURE__ */ new class extends Uo {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), Dce = /* @__PURE__ */ Ag.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let i of n.selection.ranges) {
    let r = n.doc.lineAt(i.head).from;
    r > t && (t = r, e.push(Nce.range(r)));
  }
  return kt.of(e);
});
function Lce() {
  return Dce;
}
const SN = 1024;
let Ice = 0;
class eb {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class mt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = Ice++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = hr.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
mt.closedBy = new mt({ deserialize: (n) => n.split(" ") });
mt.openedBy = new mt({ deserialize: (n) => n.split(" ") });
mt.group = new mt({ deserialize: (n) => n.split(" ") });
mt.isolate = new mt({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
mt.contextHash = new mt({ perNode: !0 });
mt.lookAhead = new mt({ perNode: !0 });
mt.mounted = new mt({ perNode: !0 });
class km {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[mt.mounted.id];
  }
}
const Bce = /* @__PURE__ */ Object.create(null);
class hr {
  /**
  @internal
  */
  constructor(e, t, i, r = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = r;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : Bce, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), r = new hr(e.name || "", t, e.id, i);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(r)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return r;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(mt.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let r of i.split(" "))
        t[r] = e[i];
    return (i) => {
      for (let r = i.prop(mt.group), s = -1; s < (r ? r.length : 0); s++) {
        let o = t[s < 0 ? i.name : r[s]];
        if (o)
          return o;
      }
    };
  }
}
hr.none = new hr(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class mx {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let r = null;
      for (let s of e) {
        let o = s(i);
        o && (r || (r = Object.assign({}, i.props)), r[o[0].id] = o[1]);
      }
      t.push(r ? new hr(i.name, r, i.id, i.flags) : i);
    }
    return new mx(t);
  }
}
const Rp = /* @__PURE__ */ new WeakMap(), cP = /* @__PURE__ */ new WeakMap();
var Xn;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Xn || (Xn = {}));
class Ln {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, i, r, s) {
    if (this.type = e, this.children = t, this.positions = i, this.length = r, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of s)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = km.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let r = i.toString();
      r && (t && (t += ","), t += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new BO(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, i = 0) {
    let r = Rp.get(this) || this.topNode, s = new BO(r);
    return s.moveTo(e, t), Rp.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new cr(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let i = cf(Rp.get(this) || this.topNode, e, t, !1);
    return Rp.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let i = cf(cP.get(this) || this.topNode, e, t, !0);
    return cP.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return jce(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: i, from: r = 0, to: s = this.length } = e, o = e.mode || 0, a = (o & Xn.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Xn.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= s && l.to >= r && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && i && (a || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : yx(hr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, r) => new Ln(this.type, t, i, r, this.propValues), e.makeTree || ((t, i, r) => new Ln(hr.none, t, i, r)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return Vce(e);
  }
}
Ln.empty = new Ln(hr.none, [], [], 0);
class vx {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new vx(this.buffer, this.index);
  }
}
class Ha {
  /**
  Create a tree buffer.
  */
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return hr.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], r = this.set.types[t], s = r.name;
    if (/\W/.test(s) && !r.isError && (s = JSON.stringify(s)), e += 4, i == e)
      return s;
    let o = [];
    for (; e < i; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, i, r, s) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != t && !(CN(s, r, o[l + 1], o[l + 2]) && (a = l, i > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, t, i) {
    let r = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let a = e, l = 0; a < t; ) {
      s[l++] = r[a++], s[l++] = r[a++] - i;
      let c = s[l++] = r[a++] - i;
      s[l++] = r[a++] - e, o = Math.max(o, c);
    }
    return new Ha(s, o, this.set);
  }
}
function CN(n, e, t, i) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function cf(n, e, t, i) {
  for (var r; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let o = !i && n instanceof cr && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let s = i ? 0 : Xn.IgnoreOverlays;
  if (i)
    for (let o = n, a = o.parent; a; o = a, a = o.parent)
      o instanceof cr && o.index < 0 && ((r = a.enter(e, t, s)) === null || r === void 0 ? void 0 : r.from) != o.from && (n = a);
  for (; ; ) {
    let o = n.enter(e, t, s);
    if (!o)
      return n;
    n = o;
  }
}
class kN {
  cursor(e = 0) {
    return new BO(this, e);
  }
  getChild(e, t = null, i = null) {
    let r = uP(this, e, t, i);
    return r.length ? r[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return uP(this, e, t, i);
  }
  resolve(e, t = 0) {
    return cf(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return cf(this, e, t, !0);
  }
  matchContext(e) {
    return IO(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), i = this;
    for (; t; ) {
      let r = t.lastChild;
      if (!r || r.to != t.to)
        break;
      r.type.isError && r.from == r.to ? (i = t, t = r.prevSibling) : t = r;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class cr extends kN {
  constructor(e, t, i, r) {
    super(), this._tree = e, this.from = t, this.index = i, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, r, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = t > 0 ? a.length : -1; e != c; e += t) {
        let u = a[e], h = l[e] + o.from;
        if (CN(r, i, h, h + u.length)) {
          if (u instanceof Ha) {
            if (s & Xn.ExcludeBuffers)
              continue;
            let d = u.findChild(0, u.buffer.length, t, i - h, r);
            if (d > -1)
              return new Ks(new Qce(o, u, e, h), null, d);
          } else if (s & Xn.IncludeAnonymous || !u.type.isAnonymous || bx(u)) {
            let d;
            if (!(s & Xn.IgnoreMounts) && (d = km.get(u)) && !d.overlay)
              return new cr(d.tree, h, e, o);
            let f = new cr(u, h, e, o);
            return s & Xn.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(t < 0 ? u.children.length - 1 : 0, t, i, r);
          }
        }
      }
      if (s & Xn.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    let r;
    if (!(i & Xn.IgnoreOverlays) && (r = km.get(this._tree)) && r.overlay) {
      let s = e - this.from;
      for (let { from: o, to: a } of r.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? a >= s : a > s))
          return new cr(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function uP(n, e, t, i) {
  let r = n.cursor(), s = [];
  if (!r.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = r.type.is(t), !r.nextSibling())
        return s;
  }
  for (; ; ) {
    if (i != null && r.type.is(i))
      return s;
    if (r.type.is(e) && s.push(r.node), !r.nextSibling())
      return i == null ? s : [];
  }
}
function IO(n, e, t = e.length - 1) {
  for (let i = n.parent; t >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class Qce {
  constructor(e, t, i, r) {
    this.parent = e, this.buffer = t, this.index = i, this.start = r;
  }
}
class Ks extends kN {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    super(), this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.context.start, i);
    return s < 0 ? null : new Ks(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    if (i & Xn.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new Ks(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ks(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Ks(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, r = this.index + 4, s = i.buffer[this.index + 3];
    if (s > r) {
      let o = i.buffer[this.index + 1];
      e.push(i.slice(r, s, o)), t.push(0);
    }
    return new Ln(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function PN(n) {
  if (!n.length)
    return null;
  let e = 0, t = n[0];
  for (let s = 1; s < n.length; s++) {
    let o = n[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let i = t instanceof cr && t.index < 0 ? null : t.parent, r = n.slice();
  return i ? r[e] = i : r.splice(e, 1), new zce(r, t);
}
class zce {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return PN(this.heads);
  }
}
function jce(n, e, t) {
  let i = n.resolveInner(e, t), r = null;
  for (let s = i instanceof cr ? i : i.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (r || (r = [i])).push(o.resolve(e, t)), s = o;
    } else {
      let o = km.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new cr(o.tree, o.overlay[0].from + s.from, -1, s);
        (r || (r = [i])).push(cf(a, e, t, !1));
      }
    }
  return r ? PN(r) : i;
}
class BO {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof cr)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: r } = this.buffer;
    return this.type = t || r.set.types[r.buffer[e]], this.from = i + r.buffer[e + 1], this.to = i + r.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof cr ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: r } = this.buffer, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.buffer.start, i);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, i = this.mode) {
    return this.buffer ? i & Xn.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Xn.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Xn.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let r = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != r)
        return this.yieldBuf(t.findChild(
          r,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let r = t.buffer[this.index + 3];
      if (r < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(r);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: r } = this;
    if (r) {
      if (e > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (r.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = r);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : i._tree.children.length; s != o; s += e) {
          let a = i._tree.children[s];
          if (this.mode & Xn.IncludeAnonymous || a instanceof Ha || !a.type.isAnonymous || bx(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let r = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == r) {
              if (r == this.index)
                return o;
              t = o, i = s + 1;
              break e;
            }
          r = this.stack[--s];
        }
    for (let r = i; r < this.stack.length; r++)
      t = new Ks(this.buffer, t, this.stack[r]);
    return this.bufferNode = new Ks(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let i = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; r && t && t(this), r = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, r = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return IO(this.node, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let r = e.length - 1, s = this.stack.length - 1; r >= 0; s--) {
      if (s < 0)
        return IO(this.node, e, r);
      let o = i[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[r] && e[r] != o.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}
function bx(n) {
  return n.children.some((e) => e instanceof Ha || !e.type.isAnonymous || bx(e));
}
function Vce(n) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: r = SN, reused: s = [], minRepeatType: o = i.types.length } = n, a = Array.isArray(t) ? new vx(t, t.length) : t, l = i.types, c = 0, u = 0;
  function h(x, S, C, k, E, M) {
    let { id: _, start: T, end: B, size: I } = a, P = u;
    for (; I < 0; )
      if (a.next(), I == -1) {
        let H = s[_];
        C.push(H), k.push(T - x);
        return;
      } else if (I == -3) {
        c = _;
        return;
      } else if (I == -4) {
        u = _;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${I}`);
    let A = l[_], N, q, j = T - x;
    if (B - T <= r && (q = m(a.pos - S, E))) {
      let H = new Uint16Array(q.size - q.skip), oe = a.pos - q.size, te = H.length;
      for (; a.pos > oe; )
        te = v(q.start, H, te);
      N = new Ha(H, B - q.start, i), j = q.start - x;
    } else {
      let H = a.pos - I;
      a.next();
      let oe = [], te = [], W = _ >= o ? _ : -1, U = 0, ae = B;
      for (; a.pos > H; )
        W >= 0 && a.id == W && a.size >= 0 ? (a.end <= ae - r && (p(oe, te, T, U, a.end, ae, W, P), U = oe.length, ae = a.end), a.next()) : M > 2500 ? d(T, H, oe, te) : h(T, H, oe, te, W, M + 1);
      if (W >= 0 && U > 0 && U < oe.length && p(oe, te, T, U, T, ae, W, P), oe.reverse(), te.reverse(), W > -1 && U > 0) {
        let he = f(A);
        N = yx(A, oe, te, 0, oe.length, 0, B - T, he, he);
      } else
        N = g(A, oe, te, B - T, P - B);
    }
    C.push(N), k.push(j);
  }
  function d(x, S, C, k) {
    let E = [], M = 0, _ = -1;
    for (; a.pos > S; ) {
      let { id: T, start: B, end: I, size: P } = a;
      if (P > 4)
        a.next();
      else {
        if (_ > -1 && B < _)
          break;
        _ < 0 && (_ = I - r), E.push(T, B, I), M++, a.next();
      }
    }
    if (M) {
      let T = new Uint16Array(M * 4), B = E[E.length - 2];
      for (let I = E.length - 3, P = 0; I >= 0; I -= 3)
        T[P++] = E[I], T[P++] = E[I + 1] - B, T[P++] = E[I + 2] - B, T[P++] = P;
      C.push(new Ha(T, E[2] - B, i)), k.push(B - x);
    }
  }
  function f(x) {
    return (S, C, k) => {
      let E = 0, M = S.length - 1, _, T;
      if (M >= 0 && (_ = S[M]) instanceof Ln) {
        if (!M && _.type == x && _.length == k)
          return _;
        (T = _.prop(mt.lookAhead)) && (E = C[M] + _.length + T);
      }
      return g(x, S, C, k, E);
    };
  }
  function p(x, S, C, k, E, M, _, T) {
    let B = [], I = [];
    for (; x.length > k; )
      B.push(x.pop()), I.push(S.pop() + C - E);
    x.push(g(i.types[_], B, I, M - E, T - M)), S.push(E - C);
  }
  function g(x, S, C, k, E = 0, M) {
    if (c) {
      let _ = [mt.contextHash, c];
      M = M ? [_].concat(M) : [_];
    }
    if (E > 25) {
      let _ = [mt.lookAhead, E];
      M = M ? [_].concat(M) : [_];
    }
    return new Ln(x, S, C, k, M);
  }
  function m(x, S) {
    let C = a.fork(), k = 0, E = 0, M = 0, _ = C.end - r, T = { size: 0, start: 0, skip: 0 };
    e:
      for (let B = C.pos - x; C.pos > B; ) {
        let I = C.size;
        if (C.id == S && I >= 0) {
          T.size = k, T.start = E, T.skip = M, M += 4, k += 4, C.next();
          continue;
        }
        let P = C.pos - I;
        if (I < 0 || P < B || C.start < _)
          break;
        let A = C.id >= o ? 4 : 0, N = C.start;
        for (C.next(); C.pos > P; ) {
          if (C.size < 0)
            if (C.size == -3)
              A += 4;
            else
              break e;
          else
            C.id >= o && (A += 4);
          C.next();
        }
        E = N, k += I, M += A;
      }
    return (S < 0 || k == x) && (T.size = k, T.start = E, T.skip = M), T.size > 4 ? T : void 0;
  }
  function v(x, S, C) {
    let { id: k, start: E, end: M, size: _ } = a;
    if (a.next(), _ >= 0 && k < o) {
      let T = C;
      if (_ > 4) {
        let B = a.pos - (_ - 4);
        for (; a.pos > B; )
          C = v(x, S, C);
      }
      S[--C] = T, S[--C] = M - x, S[--C] = E - x, S[--C] = k;
    } else
      _ == -3 ? c = k : _ == -4 && (u = k);
    return C;
  }
  let y = [], b = [];
  for (; a.pos > 0; )
    h(n.start || 0, n.bufferStart || 0, y, b, -1, 0);
  let w = (e = n.length) !== null && e !== void 0 ? e : y.length ? b[0] + y[0].length : 0;
  return new Ln(l[n.topID], y.reverse(), b.reverse(), w);
}
const hP = /* @__PURE__ */ new WeakMap();
function $g(n, e) {
  if (!n.isAnonymous || e instanceof Ha || e.type != n)
    return 1;
  let t = hP.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != n || !(i instanceof Ln)) {
        t = 1;
        break;
      }
      t += $g(n, i);
    }
    hP.set(e, t);
  }
  return t;
}
function yx(n, e, t, i, r, s, o, a, l) {
  let c = 0;
  for (let p = i; p < r; p++)
    c += $g(n, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], d = [];
  function f(p, g, m, v, y) {
    for (let b = m; b < v; ) {
      let w = b, x = g[b], S = $g(n, p[b]);
      for (b++; b < v; b++) {
        let C = $g(n, p[b]);
        if (S + C >= u)
          break;
        S += C;
      }
      if (b == w + 1) {
        if (S > u) {
          let C = p[w];
          f(C.children, C.positions, 0, C.children.length, g[w] + y);
          continue;
        }
        h.push(p[w]);
      } else {
        let C = g[b - 1] + p[b - 1].length - x;
        h.push(yx(n, p, g, w, b, x, C, null, l));
      }
      d.push(x + y - s);
    }
  }
  return f(e, t, i, r, 0), (a || l)(h, d, o);
}
class Fce {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, i) {
    let r = this.map.get(e);
    r || this.map.set(e, r = /* @__PURE__ */ new Map()), r.set(t, i);
  }
  getBuffer(e, t) {
    let i = this.map.get(e);
    return i && i.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Ks ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof cr && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Ks ? this.getBuffer(e.context.buffer, e.index) : e instanceof cr ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class jl {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, i, r, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = r, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], i = !1) {
    let r = [new jl(0, e.length, e, 0, !1, i)];
    for (let s of t)
      s.to > e.length && r.push(s);
    return r;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let r = [], s = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < t.length ? t[a] : null, h = u ? u.fromA : 1e9;
      if (h - l >= i)
        for (; o && o.from < h; ) {
          let d = o;
          if (l >= d.from || h <= d.to || c) {
            let f = Math.max(d.from, l) - c, p = Math.min(d.to, h) - c;
            d = f >= p ? null : new jl(f, p, d.tree, d.offset + c, a > 0, !!u);
          }
          if (d && r.push(d), o.to > h)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return r;
  }
}
class EN {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, i) {
    return typeof e == "string" && (e = new Zce(e)), i = i ? i.length ? i.map((r) => new eb(r.from, r.to)) : [new eb(0, 0)] : [new eb(0, e.length)], this.createParse(e, t || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, i) {
    let r = this.startParse(e, t, i);
    for (; ; ) {
      let s = r.advance();
      if (s)
        return s;
    }
  }
}
class Zce {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
new mt({ perNode: !0 });
let qce = 0;
class Ws {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = qce++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Ws([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Pm();
    return (t) => t.modified.indexOf(e) > -1 ? t : Pm.get(t.base || t, t.modified.concat(e).sort((i, r) => i.id - r.id));
  }
}
let Wce = 0;
class Pm {
  constructor() {
    this.instances = [], this.id = Wce++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((a) => a.base == e && Hce(t, a.modified));
    if (i)
      return i;
    let r = [], s = new Ws(r, e, t);
    for (let a of t)
      a.instances.push(s);
    let o = Xce(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          r.push(Pm.get(a, l));
    return s;
  }
}
function Hce(n, e) {
  return n.length == e.length && n.every((t, i) => t == e[i]);
}
function Xce(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let i = 0, r = e.length; i < r; i++)
      e.push(e[i].concat(n[t]));
  return e.sort((t, i) => i.length - t.length);
}
function zv(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let i = n[t];
    Array.isArray(i) || (i = [i]);
    for (let r of t.split(" "))
      if (r) {
        let s = [], o = 2, a = r;
        for (let h = 0; ; ) {
          if (a == "..." && h > 0 && h + 3 == r.length) {
            o = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + r);
          if (s.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), h += d[0].length, h == r.length)
            break;
          let f = r[h++];
          if (h == r.length && f == "!") {
            o = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + r);
          a = r.slice(h);
        }
        let l = s.length - 1, c = s[l];
        if (!c)
          throw new RangeError("Invalid path: " + r);
        let u = new Em(i, o, l > 0 ? s.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return AN.add(e);
}
const AN = new mt();
class Em {
  constructor(e, t, i, r) {
    this.tags = e, this.mode = t, this.context = i, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Em.empty = new Em([], 2, null);
function $N(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: i, all: r = null } = e || {};
  return {
    style: (s) => {
      let o = r;
      for (let a of s)
        for (let l of a.set) {
          let c = t[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function Yce(n, e) {
  let t = null;
  for (let i of n) {
    let r = i.style(e);
    r && (t = t ? t + " " + r : r);
  }
  return t;
}
function Uce(n, e, t, i = 0, r = n.length) {
  let s = new Gce(i, Array.isArray(e) ? e : [e], t);
  s.highlightRange(n.cursor(), i, r, "", s.highlighters), s.flush(r);
}
class Gce {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, r, s) {
    let { type: o, from: a, to: l } = e;
    if (a >= i || l <= t)
      return;
    o.isTop && (s = this.highlighters.filter((f) => !f.scope || f.scope(o)));
    let c = r, u = Kce(e) || Em.empty, h = Yce(s, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (r += (r ? " " : "") + h)), this.startSpan(Math.max(t, a), c), u.opaque)
      return;
    let d = e.tree && e.tree.prop(mt.mounted);
    if (d && d.overlay) {
      let f = e.node.enter(d.overlay[0].from + a, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(d.tree.type)), g = e.firstChild();
      for (let m = 0, v = a; ; m++) {
        let y = m < d.overlay.length ? d.overlay[m] : null, b = y ? y.from + a : l, w = Math.max(t, v), x = Math.min(i, b);
        if (w < x && g)
          for (; e.from < x && (this.highlightRange(e, w, x, r, s), this.startSpan(Math.min(x, e.to), c), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!y || b > i)
          break;
        v = y.to + a, v > t && (this.highlightRange(f.cursor(), Math.max(t, y.from + a), Math.min(i, v), "", p), this.startSpan(Math.min(i, v), c));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      d && (r = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, r, s), this.startSpan(Math.min(i, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function Kce(n) {
  let e = n.type.prop(AN);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const Se = Ws.define, Np = Se(), ga = Se(), dP = Se(ga), fP = Se(ga), ma = Se(), Dp = Se(ma), tb = Se(ma), zs = Se(), al = Se(zs), Bs = Se(), Qs = Se(), QO = Se(), Rh = Se(QO), Lp = Se(), X = {
  /**
  A comment.
  */
  comment: Np,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Se(Np),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Se(Np),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Se(Np),
  /**
  Any kind of identifier.
  */
  name: ga,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Se(ga),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: dP,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Se(dP),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: fP,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Se(fP),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Se(ga),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Se(ga),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Se(ga),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Se(ga),
  /**
  A literal value.
  */
  literal: ma,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Dp,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Se(Dp),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Se(Dp),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Se(Dp),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: tb,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Se(tb),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Se(tb),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Se(ma),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Se(ma),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Se(ma),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Se(ma),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Se(ma),
  /**
  A language keyword.
  */
  keyword: Bs,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Se(Bs),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Se(Bs),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Se(Bs),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Se(Bs),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Se(Bs),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Se(Bs),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Se(Bs),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Se(Bs),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Se(Bs),
  /**
  An operator.
  */
  operator: Qs,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Se(Qs),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Se(Qs),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Se(Qs),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Se(Qs),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Se(Qs),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Se(Qs),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Se(Qs),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Se(Qs),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Se(Qs),
  /**
  Program or markup punctuation.
  */
  punctuation: QO,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Se(QO),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Rh,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Se(Rh),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Se(Rh),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Se(Rh),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Se(Rh),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: zs,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: al,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Se(al),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Se(al),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Se(al),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Se(al),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Se(al),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Se(al),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: Se(zs),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Se(zs),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Se(zs),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Se(zs),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Se(zs),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Se(zs),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Se(zs),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Se(zs),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Se(),
  /**
  Deleted text.
  */
  deleted: Se(),
  /**
  Changed text.
  */
  changed: Se(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Se(),
  /**
  Metadata or meta-instruction.
  */
  meta: Lp,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Se(Lp),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Se(Lp),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Se(Lp),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Ws.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Ws.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Ws.defineModifier()
};
$N([
  { tag: X.link, class: "tok-link" },
  { tag: X.heading, class: "tok-heading" },
  { tag: X.emphasis, class: "tok-emphasis" },
  { tag: X.strong, class: "tok-strong" },
  { tag: X.keyword, class: "tok-keyword" },
  { tag: X.atom, class: "tok-atom" },
  { tag: X.bool, class: "tok-bool" },
  { tag: X.url, class: "tok-url" },
  { tag: X.labelName, class: "tok-labelName" },
  { tag: X.inserted, class: "tok-inserted" },
  { tag: X.deleted, class: "tok-deleted" },
  { tag: X.literal, class: "tok-literal" },
  { tag: X.string, class: "tok-string" },
  { tag: X.number, class: "tok-number" },
  { tag: [X.regexp, X.escape, X.special(X.string)], class: "tok-string2" },
  { tag: X.variableName, class: "tok-variableName" },
  { tag: X.local(X.variableName), class: "tok-variableName tok-local" },
  { tag: X.definition(X.variableName), class: "tok-variableName tok-definition" },
  { tag: X.special(X.variableName), class: "tok-variableName2" },
  { tag: X.definition(X.propertyName), class: "tok-propertyName tok-definition" },
  { tag: X.typeName, class: "tok-typeName" },
  { tag: X.namespace, class: "tok-namespace" },
  { tag: X.className, class: "tok-className" },
  { tag: X.macroName, class: "tok-macroName" },
  { tag: X.propertyName, class: "tok-propertyName" },
  { tag: X.operator, class: "tok-operator" },
  { tag: X.comment, class: "tok-comment" },
  { tag: X.meta, class: "tok-meta" },
  { tag: X.invalid, class: "tok-invalid" },
  { tag: X.punctuation, class: "tok-punctuation" }
]);
var nb;
const Bc = /* @__PURE__ */ new mt();
function TN(n) {
  return Me.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const Ox = /* @__PURE__ */ new mt();
class vs {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, i = [], r = "") {
    this.data = e, this.name = r, Et.prototype.hasOwnProperty("tree") || Object.defineProperty(Et.prototype, "tree", { get() {
      return zn(this);
    } }), this.parser = t, this.extension = [
      Xa.of(this),
      Et.languageData.of((s, o, a) => {
        let l = pP(s, o, a), c = l.type.prop(Bc);
        if (!c)
          return [];
        let u = s.facet(c), h = l.type.prop(Ox);
        if (h) {
          let d = l.resolve(o - l.from, a);
          for (let f of h)
            if (f.test(d, s)) {
              let p = s.facet(f.facet);
              return f.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return pP(e, t, i).type.prop(Bc) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(Xa);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], r = (s, o) => {
      if (s.prop(Bc) == this.data) {
        i.push({ from: o, to: o + s.length });
        return;
      }
      let a = s.prop(mt.mounted);
      if (a) {
        if (a.tree.prop(Bc) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              i.push({ from: l.from + o, to: l.to + o });
          else
            i.push({ from: o, to: o + s.length });
          return;
        } else if (a.overlay) {
          let l = i.length;
          if (r(a.tree, a.overlay[0].from + o), i.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let c = s.children[l];
        c instanceof Ln && r(c, s.positions[l] + o);
      }
    };
    return r(zn(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
vs.setState = /* @__PURE__ */ ct.define();
function pP(n, e, t) {
  let i = n.facet(Xa), r = zn(n).topNode;
  if (!i || i.allowsNesting)
    for (let s = r; s; s = s.enter(e, t, Xn.ExcludeBuffers))
      s.type.isTop && (r = s);
  return r;
}
class qu extends vs {
  constructor(e, t, i) {
    super(e, t, [], i), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = TN(e.languageData);
    return new qu(t, e.parser.configure({
      props: [Bc.add((i) => i.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new qu(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function zn(n) {
  let e = n.field(vs.state, !1);
  return e ? e.tree : Ln.empty;
}
class Jce {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let Nh = null;
class Am {
  constructor(e, t, i = [], r, s, o, a, l) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = r, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Am(e, t, [], Ln.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new Jce(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != Ln.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let r = Date.now() + e;
        e = () => Date.now() > r;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(jl.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(jl.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = Nh;
    Nh = this;
    try {
      return e();
    } finally {
      Nh = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = gP(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: r, treeLen: s, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, h, d) => l.push({ fromA: c, toA: u, fromB: h, toB: d })), i = jl.applyChanges(i, l), r = Ln.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && a.push({ from: u, to: h });
        }
      }
    }
    return new Am(this.parser, t, i, r, s, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: r, to: s } = this.skipped[i];
      r < e.to && s > e.from && (this.fragments = gP(this.fragments, r, s), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends EN {
      createParse(t, i, r) {
        let s = r[0].from, o = r[r.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = Nh;
            if (l) {
              for (let c of r)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new Ln(hr.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Nh;
  }
}
function gP(n, e, t) {
  return jl.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Wu {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new Wu(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = Am.create(e.facet(Xa).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new Wu(i);
  }
}
vs.state = /* @__PURE__ */ hi.define({
  create: Wu.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(vs.setState))
        return t.value;
    return e.startState.facet(Xa) != e.state.facet(Xa) ? Wu.init(e.state) : n.apply(e);
  }
});
let _N = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (_N = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const ib = typeof navigator < "u" && (!((nb = navigator.scheduling) === null || nb === void 0) && nb.isInputPending) ? () => navigator.scheduling.isInputPending() : null, eue = /* @__PURE__ */ Qn.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(vs.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(vs.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = _N(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: r } } = this.view, s = i.field(vs.state);
    if (s.tree == s.context.tree && s.context.isDone(
      r + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !ib ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < r && i.doc.length > r + 1e3, l = s.context.work(() => ib && ib() || Date.now() > o, r + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: vs.setState.of(new Wu(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => qr(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Xa = /* @__PURE__ */ Me.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    vs.state,
    eue,
    _e.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class wx {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const tue = /* @__PURE__ */ Me.define(), jv = /* @__PURE__ */ Me.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function $m(n) {
  let e = n.facet(jv);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function uf(n, e) {
  let t = "", i = n.tabSize, r = n.facet(jv)[0];
  if (r == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    r = " ";
  }
  for (let s = 0; s < e; s++)
    t += r;
  return t;
}
function xx(n, e) {
  n instanceof Et && (n = new Vv(n));
  for (let i of n.state.facet(tue)) {
    let r = i(n, e);
    if (r !== void 0)
      return r;
  }
  let t = zn(n.state);
  return t.length >= e ? nue(n, t, e) : null;
}
class Vv {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = $m(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: r, simulateDoubleBreak: s } = this.options;
    return r != null && r >= i.from && r <= i.to ? s && r == e ? { text: "", from: e } : (t < 0 ? r < e : r <= e) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: r } = this.lineAt(e, t);
    return i.slice(e - r, Math.min(i.length, e + 100 - r));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: r } = this.lineAt(e, t), s = this.countColumn(i, e - r), o = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return o > -1 && (s += o - this.countColumn(i, i.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return bh(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: r } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(r);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Fv = /* @__PURE__ */ new mt();
function nue(n, e, t) {
  let i = e.resolveStack(t), r = i.node.enterUnfinishedNodesBefore(t);
  if (r != i.node) {
    let s = [];
    for (let o = r; o != i.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      i = { node: s[o], next: i };
  }
  return MN(i, n, t);
}
function MN(n, e, t) {
  for (let i = n; i; i = i.next) {
    let r = rue(i.node);
    if (r)
      return r(Sx.create(e, t, i));
  }
  return 0;
}
function iue(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function rue(n) {
  let e = n.type.prop(Fv);
  if (e)
    return e;
  let t = n.firstChild, i;
  if (t && (i = t.type.prop(mt.closedBy))) {
    let r = n.lastChild, s = r && i.indexOf(r.name) > -1;
    return (o) => RN(o, !0, 1, void 0, s && !iue(o) ? r.from : void 0);
  }
  return n.parent == null ? sue : null;
}
function sue() {
  return 0;
}
class Sx extends Vv {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Sx(e, t, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(t.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (oue(i, e))
        break;
      t = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return MN(this.context.next, this.base, this.pos);
  }
}
function oue(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function aue(n) {
  let e = n.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let r = n.options.simulateBreak, s = n.state.doc.lineAt(t.from), o = r == null || r <= s.from ? s.to : Math.min(s.to, r);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped)
      return l.from < o ? t : null;
    a = l.to;
  }
}
function lue({ closing: n, align: e = !0, units: t = 1 }) {
  return (i) => RN(i, e, t, n);
}
function RN(n, e, t, i, r) {
  let s = n.textAfter, o = s.match(/^\s*/)[0].length, a = i && s.slice(o, o + i.length) == i || r == n.pos + o, l = e ? aue(n) : null;
  return l ? a ? n.column(l.from) : n.column(l.to) : n.baseIndent + (a ? 0 : n.unit * t);
}
const cue = (n) => n.baseIndent;
function Kc({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let i = n && n.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
const uue = 200;
function hue() {
  return Et.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: i } = n.newSelection.main, r = t.lineAt(i);
    if (i > r.from + uue)
      return n;
    let s = t.sliceString(r.from, i);
    if (!e.some((c) => c.test(s)))
      return n;
    let { state: o } = n, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let h = xx(o, u.from);
      if (h == null)
        continue;
      let d = /^\s*/.exec(u.text)[0], f = uf(o, h);
      d != f && l.push({ from: u.from, to: u.from + d.length, insert: f });
    }
    return l.length ? [n, { changes: l, sequential: !0 }] : n;
  });
}
const due = /* @__PURE__ */ Me.define(), Zv = /* @__PURE__ */ new mt();
function NN(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function fue(n, e, t) {
  let i = zn(n);
  if (i.length < t)
    return null;
  let r = i.resolveStack(t, 1), s = null;
  for (let o = r; o; o = o.next) {
    let a = o.node;
    if (a.to <= t || a.from > t)
      continue;
    if (s && a.from < e)
      break;
    let l = a.type.prop(Zv);
    if (l && (a.to < i.length - 50 || i.length == n.doc.length || !pue(a))) {
      let c = l(a, n);
      c && c.from <= t && c.from >= e && c.to > t && (s = c);
    }
  }
  return s;
}
function pue(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function Tm(n, e, t) {
  for (let i of n.facet(due)) {
    let r = i(n, e, t);
    if (r)
      return r;
  }
  return fue(n, e, t);
}
function DN(n, e) {
  let t = e.mapPos(n.from, 1), i = e.mapPos(n.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const qv = /* @__PURE__ */ ct.define({ map: DN }), jf = /* @__PURE__ */ ct.define({ map: DN });
function LN(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const tc = /* @__PURE__ */ hi.define({
  create() {
    return He.none;
  },
  update(n, e) {
    n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(qv) && !gue(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(Cx), r = i ? He.replace({ widget: new xue(i(e.state, t.value)) }) : mP;
        n = n.update({ add: [r.range(t.value.from, t.value.to)] });
      } else
        t.is(jf) && (n = n.update({
          filter: (i, r) => t.value.from != i || t.value.to != r,
          filterFrom: t.value.from,
          filterTo: t.value.to
        }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      n.between(i, i, (r, s) => {
        r < i && s > i && (t = !0);
      }), t && (n = n.update({
        filterFrom: i,
        filterTo: i,
        filter: (r, s) => s <= i || r >= i
      }));
    }
    return n;
  },
  provide: (n) => _e.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (i, r) => {
      t.push(i, r);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let i = n[t++], r = n[t++];
      if (typeof i != "number" || typeof r != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(mP.range(i, r));
    }
    return He.set(e, !0);
  }
});
function _m(n, e, t) {
  var i;
  let r = null;
  return (i = n.field(tc, !1)) === null || i === void 0 || i.between(e, t, (s, o) => {
    (!r || r.from > s) && (r = { from: s, to: o });
  }), r;
}
function gue(n, e, t) {
  let i = !1;
  return n.between(e, e, (r, s) => {
    r == e && s == t && (i = !0);
  }), i;
}
function IN(n, e) {
  return n.field(tc, !1) ? e : e.concat(ct.appendConfig.of(QN()));
}
const mue = (n) => {
  for (let e of LN(n)) {
    let t = Tm(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: IN(n.state, [qv.of(t), BN(n, t)]) }), !0;
  }
  return !1;
}, vue = (n) => {
  if (!n.state.field(tc, !1))
    return !1;
  let e = [];
  for (let t of LN(n)) {
    let i = _m(n.state, t.from, t.to);
    i && e.push(jf.of(i), BN(n, i, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function BN(n, e, t = !0) {
  let i = n.state.doc.lineAt(e.from).number, r = n.state.doc.lineAt(e.to).number;
  return _e.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${n.state.phrase("to")} ${r}.`);
}
const bue = (n) => {
  let { state: e } = n, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let r = n.lineBlockAt(i), s = Tm(e, r.from, r.to);
    s && t.push(qv.of(s)), i = (s ? n.lineBlockAt(s.to) : r).to + 1;
  }
  return t.length && n.dispatch({ effects: IN(n.state, t) }), !!t.length;
}, yue = (n) => {
  let e = n.state.field(tc, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (i, r) => {
    t.push(jf.of({ from: i, to: r }));
  }), n.dispatch({ effects: t }), !0;
}, Oue = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: mue },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: vue },
  { key: "Ctrl-Alt-[", run: bue },
  { key: "Ctrl-Alt-]", run: yue }
], wue = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, Cx = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, wue);
  }
});
function QN(n) {
  let e = [tc, kue];
  return n && e.push(Cx.of(n)), e;
}
function zN(n, e) {
  let { state: t } = n, i = t.facet(Cx), r = (o) => {
    let a = n.lineBlockAt(n.posAtDOM(o.target)), l = _m(n.state, a.from, a.to);
    l && n.dispatch({ effects: jf.of(l) }), o.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(n, r, e);
  let s = document.createElement("span");
  return s.textContent = i.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = r, s;
}
const mP = /* @__PURE__ */ He.replace({ widget: /* @__PURE__ */ new class extends ia {
  toDOM(n) {
    return zN(n, null);
  }
}() });
class xue extends ia {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return zN(e, this.value);
  }
}
const Sue = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class rb extends Uo {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function Cue(n = {}) {
  let e = Object.assign(Object.assign({}, Sue), n), t = new rb(e, !0), i = new rb(e, !1), r = Qn.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Xa) != o.state.facet(Xa) || o.startState.field(tc, !1) != o.state.field(tc, !1) || zn(o.startState) != zn(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new Fa();
      for (let l of o.viewportLineBlocks) {
        let c = _m(o.state, l.from, l.to) ? i : Tm(o.state, l.from, l.to) ? t : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    r,
    Ece({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(r)) === null || a === void 0 ? void 0 : a.markers) || kt.empty;
      },
      initialSpacer() {
        return new rb(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, a, l) => {
        if (s.click && s.click(o, a, l))
          return !0;
        let c = _m(o.state, a.from, a.to);
        if (c)
          return o.dispatch({ effects: jf.of(c) }), !0;
        let u = Tm(o.state, a.from, a.to);
        return u ? (o.dispatch({ effects: qv.of(u) }), !0) : !1;
      } })
    }),
    QN()
  ];
}
const kue = /* @__PURE__ */ _e.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Wv {
  constructor(e, t) {
    this.specs = e;
    let i;
    function r(a) {
      let l = Za.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? r(t.all) : void 0, o = t.scope;
    this.scope = o instanceof vs ? (a) => a.prop(Bc) == o.data : o ? (a) => a == o : void 0, this.style = $N(e.map((a) => ({
      tag: a.tag,
      class: a.class || r(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = i ? new Za(i) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Wv(e, t || {});
  }
}
const zO = /* @__PURE__ */ Me.define(), jN = /* @__PURE__ */ Me.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function sb(n) {
  let e = n.facet(zO);
  return e.length ? e : n.facet(jN);
}
function Pue(n, e) {
  let t = [Aue], i;
  return n instanceof Wv && (n.module && t.push(_e.styleModule.of(n.module)), i = n.themeType), e != null && e.fallback ? t.push(jN.of(n)) : i ? t.push(zO.computeN([_e.darkTheme], (r) => r.facet(_e.darkTheme) == (i == "dark") ? [n] : [])) : t.push(zO.of(n)), t;
}
class Eue {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = zn(e.state), this.decorations = this.buildDeco(e, sb(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = zn(e.state), i = sb(e.state), r = i != sb(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < s.to && !r && t.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || r) && (this.tree = t, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = s.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return He.none;
    let i = new Fa();
    for (let { from: r, to: s } of e.visibleRanges)
      Uce(this.tree, t, (o, a, l) => {
        i.add(o, a, this.markCache[l] || (this.markCache[l] = He.mark({ class: l })));
      }, r, s);
    return i.finish();
  }
}
const Aue = /* @__PURE__ */ hc.high(/* @__PURE__ */ Qn.fromClass(Eue, {
  decorations: (n) => n.decorations
})), $ue = /* @__PURE__ */ Wv.define([
  {
    tag: X.meta,
    color: "#404740"
  },
  {
    tag: X.link,
    textDecoration: "underline"
  },
  {
    tag: X.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: X.emphasis,
    fontStyle: "italic"
  },
  {
    tag: X.strong,
    fontWeight: "bold"
  },
  {
    tag: X.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: X.keyword,
    color: "#708"
  },
  {
    tag: [X.atom, X.bool, X.url, X.contentSeparator, X.labelName],
    color: "#219"
  },
  {
    tag: [X.literal, X.inserted],
    color: "#164"
  },
  {
    tag: [X.string, X.deleted],
    color: "#a11"
  },
  {
    tag: [X.regexp, X.escape, /* @__PURE__ */ X.special(X.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ X.definition(X.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ X.local(X.variableName),
    color: "#30a"
  },
  {
    tag: [X.typeName, X.namespace],
    color: "#085"
  },
  {
    tag: X.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ X.special(X.variableName), X.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ X.definition(X.propertyName),
    color: "#00c"
  },
  {
    tag: X.comment,
    color: "#940"
  },
  {
    tag: X.invalid,
    color: "#f00"
  }
]), Tue = /* @__PURE__ */ _e.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), VN = 1e4, FN = "()[]{}", ZN = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, {
      afterCursor: !0,
      brackets: FN,
      maxScanDistance: VN,
      renderMatch: Rue
    });
  }
}), _ue = /* @__PURE__ */ He.mark({ class: "cm-matchingBracket" }), Mue = /* @__PURE__ */ He.mark({ class: "cm-nonmatchingBracket" });
function Rue(n) {
  let e = [], t = n.matched ? _ue : Mue;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const Nue = /* @__PURE__ */ hi.define({
  create() {
    return He.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], i = e.state.facet(ZN);
    for (let r of e.state.selection.ranges) {
      if (!r.empty)
        continue;
      let s = Js(e.state, r.head, -1, i) || r.head > 0 && Js(e.state, r.head - 1, 1, i) || i.afterCursor && (Js(e.state, r.head, 1, i) || r.head < e.state.doc.length && Js(e.state, r.head + 1, -1, i));
      s && (t = t.concat(i.renderMatch(s, e.state)));
    }
    return He.set(t, !0);
  },
  provide: (n) => _e.decorations.from(n)
}), Due = [
  Nue,
  Tue
];
function Lue(n = {}) {
  return [ZN.of(n), Due];
}
const Iue = /* @__PURE__ */ new mt();
function jO(n, e, t) {
  let i = n.prop(e < 0 ? mt.openedBy : mt.closedBy);
  if (i)
    return i;
  if (n.name.length == 1) {
    let r = t.indexOf(n.name);
    if (r > -1 && r % 2 == (e < 0 ? 1 : 0))
      return [t[r + e]];
  }
  return null;
}
function VO(n) {
  let e = n.type.prop(Iue);
  return e ? e(n.node) : n;
}
function Js(n, e, t, i = {}) {
  let r = i.maxScanDistance || VN, s = i.brackets || FN, o = zn(n), a = o.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let c = jO(l.type, t, s);
    if (c && l.from < l.to) {
      let u = VO(l);
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return Bue(n, e, t, l, u, c, s);
    }
  }
  return Que(n, e, t, o, a.type, r, s);
}
function Bue(n, e, t, i, r, s, o) {
  let a = i.parent, l = { from: r.from, to: r.to }, c = 0, u = a == null ? void 0 : a.cursor();
  if (u && (t < 0 ? u.childBefore(i.from) : u.childAfter(i.to)))
    do
      if (t < 0 ? u.to <= i.from : u.from >= i.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = VO(u);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (jO(u.type, t, o))
          c++;
        else if (jO(u.type, -t, o)) {
          if (c == 0) {
            let h = VO(u);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function Que(n, e, t, i, r, s, o) {
  let a = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, u = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let d = 0; !u.next().done && d <= s; ) {
    let f = u.value;
    t < 0 && (d += f.length);
    let p = e + d * t;
    for (let g = t > 0 ? 0 : f.length - 1, m = t > 0 ? f.length : -1; g != m; g += t) {
      let v = o.indexOf(f[g]);
      if (!(v < 0 || i.resolveInner(p + g, 1).type != r))
        if (v % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: p + g, to: p + g + 1 }, matched: v >> 1 == l >> 1 };
          h--;
        }
    }
    t > 0 && (d += f.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
const zue = /* @__PURE__ */ Object.create(null), vP = [hr.none], bP = [], yP = /* @__PURE__ */ Object.create(null), jue = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  jue[n] = /* @__PURE__ */ Vue(zue, e);
function ob(n, e) {
  bP.indexOf(n) > -1 || (bP.push(n), console.warn(e));
}
function Vue(n, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = n[c] || X[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : ob(c, `Modifier ${c} used at start of tag`) : l.length ? ob(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : ob(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let i = e.replace(/ /g, "_"), r = i + " " + t.map((a) => a.id), s = yP[r];
  if (s)
    return s.id;
  let o = yP[r] = hr.define({
    id: vP.length,
    name: i,
    props: [zv({ [i]: t })]
  });
  return vP.push(o), o.id;
}
nn.RTL, nn.LTR;
const Fue = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), i = Px(n.state, t.from);
  return i.line ? Zue(n) : i.block ? Wue(n) : !1;
};
function kx(n, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let r = n(e, t);
    return r ? (i(t.update(r)), !0) : !1;
  };
}
const Zue = /* @__PURE__ */ kx(
  Yue,
  0
  /* CommentOption.Toggle */
), que = /* @__PURE__ */ kx(
  qN,
  0
  /* CommentOption.Toggle */
), Wue = /* @__PURE__ */ kx(
  (n, e) => qN(n, e, Xue(e)),
  0
  /* CommentOption.Toggle */
);
function Px(n, e) {
  let t = n.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const Dh = 50;
function Hue(n, { open: e, close: t }, i, r) {
  let s = n.sliceDoc(i - Dh, i), o = n.sliceDoc(r, r + Dh), a = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(o)[0].length, c = s.length - a;
  if (s.slice(c - e.length, c) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: i - a, margin: a && 1 },
      close: { pos: r + l, margin: l && 1 }
    };
  let u, h;
  r - i <= 2 * Dh ? u = h = n.sliceDoc(i, r) : (u = n.sliceDoc(i, i + Dh), h = n.sliceDoc(r - Dh, r));
  let d = /^\s*/.exec(u)[0].length, f = /\s*$/.exec(h)[0].length, p = h.length - f - t.length;
  return u.slice(d, d + e.length) == e && h.slice(p, p + t.length) == t ? {
    open: {
      pos: i + d + e.length,
      margin: /\s/.test(u.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: r - f - t.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function Xue(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let i = n.doc.lineAt(t.from), r = t.to <= i.to ? i : n.doc.lineAt(t.to), s = e.length - 1;
    s >= 0 && e[s].to > i.from ? e[s].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to });
  }
  return e;
}
function qN(n, e, t = e.selection.ranges) {
  let i = t.map((s) => Px(e, s.from).block);
  if (!i.every((s) => s))
    return null;
  let r = t.map((s, o) => Hue(e, i[o], s.from, s.to));
  if (n != 2 && !r.every((s) => s))
    return { changes: e.changes(t.map((s, o) => r[o] ? [] : [{ from: s.from, insert: i[o].open + " " }, { from: s.to, insert: " " + i[o].close }])) };
  if (n != 1 && r.some((s) => s)) {
    let s = [];
    for (let o = 0, a; o < r.length; o++)
      if (a = r[o]) {
        let l = i[o], { open: c, close: u } = a;
        s.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function Yue(n, e, t = e.selection.ranges) {
  let i = [], r = -1;
  for (let { from: s, to: o } of t) {
    let a = i.length, l = 1e9, c = Px(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > r && (s == o || o > h.from)) {
          r = h.from;
          let d = /^\s*/.exec(h.text)[0].length, f = d == h.length, p = h.text.slice(d, d + c.length) == c ? d : -1;
          d < h.text.length && d < l && (l = d), i.push({ line: h, comment: p, token: c, indent: d, empty: f, single: !1 });
        }
        u = h.to + 1;
      }
      if (l < 1e9)
        for (let u = a; u < i.length; u++)
          i[u].indent < i[u].line.text.length && (i[u].indent = l);
      i.length == a + 1 && (i[a].single = !0);
    }
  }
  if (n != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: c, empty: u, single: h } of i)
      (h || !u) && s.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (n != 1 && i.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: a, token: l } of i)
      if (a >= 0) {
        let c = o.from + a, u = c + l.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const FO = /* @__PURE__ */ na.define(), Uue = /* @__PURE__ */ na.define(), Gue = /* @__PURE__ */ Me.define(), WN = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, r) => e(i, r) || t(i, r)
    });
  }
}), HN = /* @__PURE__ */ hi.define({
  create() {
    return eo.empty;
  },
  update(n, e) {
    let t = e.state.facet(WN), i = e.annotation(FO);
    if (i) {
      let l = sr.fromTransaction(e, i.selection), c = i.side, u = c == 0 ? n.undone : n.done;
      return l ? u = Mm(u, u.length, t.minDepth, l) : u = UN(u, e.startState.selection), new eo(c == 0 ? i.rest : u, c == 0 ? u : i.rest);
    }
    let r = e.annotation(Uue);
    if ((r == "full" || r == "before") && (n = n.isolate()), e.annotation(Dn.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let s = sr.fromTransaction(e), o = e.annotation(Dn.time), a = e.annotation(Dn.userEvent);
    return s ? n = n.addChanges(s, o, a, t, e) : e.selection && (n = n.addSelection(e.startState.selection, o, a, t.newGroupDelay)), (r == "full" || r == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new eo(n.done.map(sr.fromJSON), n.undone.map(sr.fromJSON));
  }
});
function Kue(n = {}) {
  return [
    HN,
    WN.of(n),
    _e.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? XN : e.inputType == "historyRedo" ? ZO : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
function Hv(n, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let r = t.field(HN, !1);
    if (!r)
      return !1;
    let s = r.pop(n, t, e);
    return s ? (i(s), !0) : !1;
  };
}
const XN = /* @__PURE__ */ Hv(0, !1), ZO = /* @__PURE__ */ Hv(1, !1), Jue = /* @__PURE__ */ Hv(0, !0), ehe = /* @__PURE__ */ Hv(1, !0);
class sr {
  constructor(e, t, i, r, s) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = r, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new sr(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(e) {
    return new sr(e.changes && Hn.fromJSON(e.changes), [], e.mapped && ao.fromJSON(e.mapped), e.startSelection && ue.fromJSON(e.startSelection), e.selectionsAfter.map(ue.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = Vr;
    for (let r of e.startState.facet(Gue)) {
      let s = r(e);
      s.length && (i = i.concat(s));
    }
    return !i.length && e.changes.empty ? null : new sr(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, Vr);
  }
  static selection(e) {
    return new sr(void 0, Vr, void 0, void 0, e);
  }
}
function Mm(n, e, t, i) {
  let r = e + 1 > t + 20 ? e - t - 1 : 0, s = n.slice(r, e);
  return s.push(i), s;
}
function the(n, e) {
  let t = [], i = !1;
  return n.iterChangedRanges((r, s) => t.push(r, s)), e.iterChangedRanges((r, s, o, a) => {
    for (let l = 0; l < t.length; ) {
      let c = t[l++], u = t[l++];
      a >= c && o <= u && (i = !0);
    }
  }), i;
}
function nhe(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function YN(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const Vr = [], ihe = 200;
function UN(n, e) {
  if (n.length) {
    let t = n[n.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - ihe));
    return i.length && i[i.length - 1].eq(e) ? n : (i.push(e), Mm(n, n.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [sr.selection([e])];
}
function rhe(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function ab(n, e) {
  if (!n.length)
    return n;
  let t = n.length, i = Vr;
  for (; t; ) {
    let r = she(n[t - 1], e, i);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let s = n.slice(0, t);
      return s[t - 1] = r, s;
    } else
      e = r.mapped, t--, i = r.selectionsAfter;
  }
  return i.length ? [sr.selection(i)] : Vr;
}
function she(n, e, t) {
  let i = YN(n.selectionsAfter.length ? n.selectionsAfter.map((a) => a.map(e)) : Vr, t);
  if (!n.changes)
    return sr.selection(i);
  let r = n.changes.map(e), s = e.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(s) : s;
  return new sr(r, ct.mapEffects(n.effects, e), o, n.startSelection.map(s), i);
}
const ohe = /^(input\.type|delete)($|\.)/;
class eo {
  constructor(e, t, i = 0, r = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new eo(this.done, this.undone) : this;
  }
  addChanges(e, t, i, r, s) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!i || ohe.test(i)) && (!a.selectionsAfter.length && t - this.prevTime < r.newGroupDelay && r.joinToEvent(s, the(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? o = Mm(o, o.length - 1, r.minDepth, new sr(e.changes.compose(a.changes), YN(e.effects, a.effects), a.mapped, a.startSelection, Vr)) : o = Mm(o, o.length, r.minDepth, e), new eo(o, Vr, t, i);
  }
  addSelection(e, t, i, r) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Vr;
    return s.length > 0 && t - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && nhe(s[s.length - 1], e) ? this : new eo(UN(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new eo(ab(this.done, e), ab(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let r = e == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let s = r[r.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (i && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: FO.of({ side: e, rest: rhe(r), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let a = r.length == 1 ? Vr : r.slice(0, r.length - 1);
      return s.mapped && (a = ab(a, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: FO.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
eo.empty = /* @__PURE__ */ new eo(Vr, Vr);
const ahe = [
  { key: "Mod-z", run: XN, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: ZO, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: ZO, preventDefault: !0 },
  { key: "Mod-u", run: Jue, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: ehe, preventDefault: !0 }
];
function yh(n, e) {
  return ue.create(n.ranges.map(e), n.mainIndex);
}
function wo(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function _s({ state: n, dispatch: e }, t) {
  let i = yh(n.selection, t);
  return i.eq(n.selection, !0) ? !1 : (e(wo(n, i)), !0);
}
function Xv(n, e) {
  return ue.cursor(e ? n.to : n.from);
}
function GN(n, e) {
  return _s(n, (t) => t.empty ? n.moveByChar(t, e) : Xv(t, e));
}
function Di(n) {
  return n.textDirectionAt(n.state.selection.main.head) == nn.LTR;
}
const KN = (n) => GN(n, !Di(n)), JN = (n) => GN(n, Di(n));
function eD(n, e) {
  return _s(n, (t) => t.empty ? n.moveByGroup(t, e) : Xv(t, e));
}
const lhe = (n) => eD(n, !Di(n)), che = (n) => eD(n, Di(n));
function uhe(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Yv(n, e, t) {
  let i = zn(n).resolveInner(e.head), r = t ? mt.closedBy : mt.openedBy;
  for (let l = e.head; ; ) {
    let c = t ? i.childAfter(l) : i.childBefore(l);
    if (!c)
      break;
    uhe(n, c, r) ? i = c : l = t ? c.to : c.from;
  }
  let s = i.type.prop(r), o, a;
  return s && (o = t ? Js(n, i.from, 1) : Js(n, i.to, -1)) && o.matched ? a = t ? o.end.to : o.end.from : a = t ? i.to : i.from, ue.cursor(a, t ? -1 : 1);
}
const hhe = (n) => _s(n, (e) => Yv(n.state, e, !Di(n))), dhe = (n) => _s(n, (e) => Yv(n.state, e, Di(n)));
function tD(n, e) {
  return _s(n, (t) => {
    if (!t.empty)
      return Xv(t, e);
    let i = n.moveVertically(t, e);
    return i.head != t.head ? i : n.moveToLineBoundary(t, e);
  });
}
const nD = (n) => tD(n, !1), iD = (n) => tD(n, !0);
function rD(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, i = 0, r;
  if (e) {
    for (let s of n.state.facet(_e.scrollMargins)) {
      let o = s(n);
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)), o != null && o.bottom && (i = Math.max(o == null ? void 0 : o.bottom, i));
    }
    r = n.scrollDOM.clientHeight - t - i;
  } else
    r = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, r - 5)
  };
}
function sD(n, e) {
  let t = rD(n), { state: i } = n, r = yh(i.selection, (o) => o.empty ? n.moveVertically(o, e, t.height) : Xv(o, e));
  if (r.eq(i.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = n.coordsAtPos(i.selection.main.head), a = n.scrollDOM.getBoundingClientRect(), l = a.top + t.marginTop, c = a.bottom - t.marginBottom;
    o && o.top > l && o.bottom < c && (s = _e.scrollIntoView(r.main.head, { y: "start", yMargin: o.top - l }));
  }
  return n.dispatch(wo(i, r), { effects: s }), !0;
}
const OP = (n) => sD(n, !1), qO = (n) => sD(n, !0);
function il(n, e, t) {
  let i = n.lineBlockAt(e.head), r = n.moveToLineBoundary(e, t);
  if (r.head == e.head && r.head != (t ? i.to : i.from) && (r = n.moveToLineBoundary(e, t, !1)), !t && r.head == i.from && i.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    s && e.head != i.from + s && (r = ue.cursor(i.from + s));
  }
  return r;
}
const fhe = (n) => _s(n, (e) => il(n, e, !0)), phe = (n) => _s(n, (e) => il(n, e, !1)), ghe = (n) => _s(n, (e) => il(n, e, !Di(n))), mhe = (n) => _s(n, (e) => il(n, e, Di(n))), vhe = (n) => _s(n, (e) => ue.cursor(n.lineBlockAt(e.head).from, 1)), bhe = (n) => _s(n, (e) => ue.cursor(n.lineBlockAt(e.head).to, -1));
function yhe(n, e, t) {
  let i = !1, r = yh(n.selection, (s) => {
    let o = Js(n, s.head, -1) || Js(n, s.head, 1) || s.head > 0 && Js(n, s.head - 1, 1) || s.head < n.doc.length && Js(n, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    i = !0;
    let a = o.start.from == s.head ? o.end.to : o.end.from;
    return t ? ue.range(s.anchor, a) : ue.cursor(a);
  });
  return i ? (e(wo(n, r)), !0) : !1;
}
const Ohe = ({ state: n, dispatch: e }) => yhe(n, e, !1);
function ns(n, e) {
  let t = yh(n.state.selection, (i) => {
    let r = e(i);
    return ue.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(wo(n.state, t)), !0);
}
function oD(n, e) {
  return ns(n, (t) => n.moveByChar(t, e));
}
const aD = (n) => oD(n, !Di(n)), lD = (n) => oD(n, Di(n));
function cD(n, e) {
  return ns(n, (t) => n.moveByGroup(t, e));
}
const whe = (n) => cD(n, !Di(n)), xhe = (n) => cD(n, Di(n)), She = (n) => ns(n, (e) => Yv(n.state, e, !Di(n))), Che = (n) => ns(n, (e) => Yv(n.state, e, Di(n)));
function uD(n, e) {
  return ns(n, (t) => n.moveVertically(t, e));
}
const hD = (n) => uD(n, !1), dD = (n) => uD(n, !0);
function fD(n, e) {
  return ns(n, (t) => n.moveVertically(t, e, rD(n).height));
}
const wP = (n) => fD(n, !1), xP = (n) => fD(n, !0), khe = (n) => ns(n, (e) => il(n, e, !0)), Phe = (n) => ns(n, (e) => il(n, e, !1)), Ehe = (n) => ns(n, (e) => il(n, e, !Di(n))), Ahe = (n) => ns(n, (e) => il(n, e, Di(n))), $he = (n) => ns(n, (e) => ue.cursor(n.lineBlockAt(e.head).from)), The = (n) => ns(n, (e) => ue.cursor(n.lineBlockAt(e.head).to)), SP = ({ state: n, dispatch: e }) => (e(wo(n, { anchor: 0 })), !0), CP = ({ state: n, dispatch: e }) => (e(wo(n, { anchor: n.doc.length })), !0), kP = ({ state: n, dispatch: e }) => (e(wo(n, { anchor: n.selection.main.anchor, head: 0 })), !0), PP = ({ state: n, dispatch: e }) => (e(wo(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), _he = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), Mhe = ({ state: n, dispatch: e }) => {
  let t = Uv(n).map(({ from: i, to: r }) => ue.range(i, Math.min(r + 1, n.doc.length)));
  return e(n.update({ selection: ue.create(t), userEvent: "select" })), !0;
}, Rhe = ({ state: n, dispatch: e }) => {
  let t = yh(n.selection, (i) => {
    var r;
    let s = zn(n).resolveStack(i.from, 1);
    for (let o = s; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < i.from && a.to >= i.to || a.to > i.to && a.from <= i.from) && (!((r = a.parent) === null || r === void 0) && r.parent))
        return ue.range(a.to, a.from);
    }
    return i;
  });
  return e(wo(n, t)), !0;
}, Nhe = ({ state: n, dispatch: e }) => {
  let t = n.selection, i = null;
  return t.ranges.length > 1 ? i = ue.create([t.main]) : t.main.empty || (i = ue.create([ue.cursor(t.main.head)])), i ? (e(wo(n, i)), !0) : !1;
};
function Vf(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: i } = n, r = i.changeByRange((s) => {
    let { from: o, to: a } = s;
    if (o == a) {
      let l = e(s);
      l < o ? (t = "delete.backward", l = Ip(n, l, !1)) : l > o && (t = "delete.forward", l = Ip(n, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = Ip(n, o, !1), a = Ip(n, a, !0);
    return o == a ? { range: s } : { changes: { from: o, to: a }, range: ue.cursor(o, o < s.head ? -1 : 1) };
  });
  return r.changes.empty ? !1 : (n.dispatch(i.update(r, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? _e.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Ip(n, e, t) {
  if (n instanceof _e)
    for (let i of n.state.facet(_e.atomicRanges).map((r) => r(n)))
      i.between(e, e, (r, s) => {
        r < e && s > e && (e = t ? s : r);
      });
  return e;
}
const pD = (n, e) => Vf(n, (t) => {
  let i = t.from, { state: r } = n, s = r.doc.lineAt(i), o, a;
  if (!e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(o = s.text.slice(0, i - s.from))) {
    if (o[o.length - 1] == "	")
      return i - 1;
    let l = bh(o, r.tabSize), c = l % $m(r) || $m(r);
    for (let u = 0; u < c && o[o.length - 1 - u] == " "; u++)
      i--;
    a = i;
  } else
    a = ki(s.text, i - s.from, e, e) + s.from, a == i && s.number != (e ? r.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(a - s.from, i - s.from)) && (a = ki(s.text, a - s.from, !1, !1) + s.from);
  return a;
}), WO = (n) => pD(n, !1), gD = (n) => pD(n, !0), mD = (n, e) => Vf(n, (t) => {
  let i = t.head, { state: r } = n, s = r.doc.lineAt(i), o = r.charCategorizer(i);
  for (let a = null; ; ) {
    if (i == (e ? s.to : s.from)) {
      i == t.head && s.number != (e ? r.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let l = ki(s.text, i - s.from, e) + s.from, c = s.text.slice(Math.min(i, l) - s.from, Math.max(i, l) - s.from), u = o(c);
    if (a != null && u != a)
      break;
    (c != " " || i != t.head) && (a = u), i = l;
  }
  return i;
}), vD = (n) => mD(n, !1), Dhe = (n) => mD(n, !0), Lhe = (n) => Vf(n, (e) => {
  let t = n.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), Ihe = (n) => Vf(n, (e) => {
  let t = n.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), Bhe = (n) => Vf(n, (e) => {
  let t = n.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), Qhe = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: $t.of(["", ""]) },
    range: ue.cursor(i.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, zhe = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == n.doc.length)
      return { range: i };
    let r = i.from, s = n.doc.lineAt(r), o = r == s.from ? r - 1 : ki(s.text, r - s.from, !1) + s.from, a = r == s.to ? r + 1 : ki(s.text, r - s.from, !0) + s.from;
    return {
      changes: { from: o, to: a, insert: n.doc.slice(r, a).append(n.doc.slice(o, r)) },
      range: ue.cursor(a)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Uv(n) {
  let e = [], t = -1;
  for (let i of n.selection.ranges) {
    let r = n.doc.lineAt(i.from), s = n.doc.lineAt(i.to);
    if (!i.empty && i.to == s.from && (s = n.doc.lineAt(i.to - 1)), t >= r.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(i);
    } else
      e.push({ from: r.from, to: s.to, ranges: [i] });
    t = s.number + 1;
  }
  return e;
}
function bD(n, e, t) {
  if (n.readOnly)
    return !1;
  let i = [], r = [];
  for (let s of Uv(n)) {
    if (t ? s.to == n.doc.length : s.from == 0)
      continue;
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1), a = o.length + 1;
    if (t) {
      i.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + n.lineBreak });
      for (let l of s.ranges)
        r.push(ue.range(Math.min(n.doc.length, l.anchor + a), Math.min(n.doc.length, l.head + a)));
    } else {
      i.push({ from: o.from, to: s.from }, { from: s.to, insert: n.lineBreak + o.text });
      for (let l of s.ranges)
        r.push(ue.range(l.anchor - a, l.head - a));
    }
  }
  return i.length ? (e(n.update({
    changes: i,
    scrollIntoView: !0,
    selection: ue.create(r, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const jhe = ({ state: n, dispatch: e }) => bD(n, e, !1), Vhe = ({ state: n, dispatch: e }) => bD(n, e, !0);
function yD(n, e, t) {
  if (n.readOnly)
    return !1;
  let i = [];
  for (let r of Uv(n))
    t ? i.push({ from: r.from, insert: n.doc.slice(r.from, r.to) + n.lineBreak }) : i.push({ from: r.to, insert: n.lineBreak + n.doc.slice(r.from, r.to) });
  return e(n.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Fhe = ({ state: n, dispatch: e }) => yD(n, e, !1), Zhe = ({ state: n, dispatch: e }) => yD(n, e, !0), qhe = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(Uv(e).map(({ from: r, to: s }) => (r > 0 ? r-- : s < e.doc.length && s++, { from: r, to: s }))), i = yh(e.selection, (r) => n.moveVertically(r, !0)).map(t);
  return n.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Whe(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = zn(n).resolveInner(e), i = t.childBefore(e), r = t.childAfter(e), s;
  return i && r && i.to <= e && r.from >= e && (s = i.type.prop(mt.closedBy)) && s.indexOf(r.name) > -1 && n.doc.lineAt(i.to).from == n.doc.lineAt(r.from).from && !/\S/.test(n.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null;
}
const Hhe = /* @__PURE__ */ OD(!1), Xhe = /* @__PURE__ */ OD(!0);
function OD(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((r) => {
      let { from: s, to: o } = r, a = e.doc.lineAt(s), l = !n && s == o && Whe(e, s);
      n && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new Vv(e, { simulateBreak: s, simulateDoubleBreak: !!l }), u = xx(c, s);
      for (u == null && (u = bh(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: s, to: o } = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let h = ["", uf(e, u)];
      return l && h.push(uf(e, c.lineIndent(a.from, -1))), {
        changes: { from: s, to: o, insert: $t.of(h) },
        range: ue.cursor(s + 1 + h[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Ex(n, e) {
  let t = -1;
  return n.changeByRange((i) => {
    let r = [];
    for (let o = i.from; o <= i.to; ) {
      let a = n.doc.lineAt(o);
      a.number > t && (i.empty || i.to > a.from) && (e(a, r, i), t = a.number), o = a.to + 1;
    }
    let s = n.changes(r);
    return {
      changes: r,
      range: ue.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1))
    };
  });
}
const Yhe = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new Vv(n, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), r = Ex(n, (s, o, a) => {
    let l = xx(i, s.from);
    if (l == null)
      return;
    /\S/.test(s.text) || (l = 0);
    let c = /^\s*/.exec(s.text)[0], u = uf(n, l);
    (c != u || a.from < s.from + c.length) && (t[s.from] = l, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return r.changes.empty || e(n.update(r, { userEvent: "indent" })), !0;
}, Uhe = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Ex(n, (t, i) => {
  i.push({ from: t.from, insert: n.facet(jv) });
}), { userEvent: "input.indent" })), !0), Ghe = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Ex(n, (t, i) => {
  let r = /^\s*/.exec(t.text)[0];
  if (!r)
    return;
  let s = bh(r, n.tabSize), o = 0, a = uf(n, Math.max(0, s - $m(n)));
  for (; o < r.length && o < a.length && r.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  i.push({ from: t.from + o, to: t.from + r.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), Khe = [
  { key: "Ctrl-b", run: KN, shift: aD, preventDefault: !0 },
  { key: "Ctrl-f", run: JN, shift: lD },
  { key: "Ctrl-p", run: nD, shift: hD },
  { key: "Ctrl-n", run: iD, shift: dD },
  { key: "Ctrl-a", run: vhe, shift: $he },
  { key: "Ctrl-e", run: bhe, shift: The },
  { key: "Ctrl-d", run: gD },
  { key: "Ctrl-h", run: WO },
  { key: "Ctrl-k", run: Lhe },
  { key: "Ctrl-Alt-h", run: vD },
  { key: "Ctrl-o", run: Qhe },
  { key: "Ctrl-t", run: zhe },
  { key: "Ctrl-v", run: qO }
], Jhe = /* @__PURE__ */ [
  { key: "ArrowLeft", run: KN, shift: aD, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: lhe, shift: whe, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: ghe, shift: Ehe, preventDefault: !0 },
  { key: "ArrowRight", run: JN, shift: lD, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: che, shift: xhe, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: mhe, shift: Ahe, preventDefault: !0 },
  { key: "ArrowUp", run: nD, shift: hD, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: SP, shift: kP },
  { mac: "Ctrl-ArrowUp", run: OP, shift: wP },
  { key: "ArrowDown", run: iD, shift: dD, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: CP, shift: PP },
  { mac: "Ctrl-ArrowDown", run: qO, shift: xP },
  { key: "PageUp", run: OP, shift: wP },
  { key: "PageDown", run: qO, shift: xP },
  { key: "Home", run: phe, shift: Phe, preventDefault: !0 },
  { key: "Mod-Home", run: SP, shift: kP },
  { key: "End", run: fhe, shift: khe, preventDefault: !0 },
  { key: "Mod-End", run: CP, shift: PP },
  { key: "Enter", run: Hhe },
  { key: "Mod-a", run: _he },
  { key: "Backspace", run: WO, shift: WO },
  { key: "Delete", run: gD },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: vD },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Dhe },
  { mac: "Mod-Backspace", run: Ihe },
  { mac: "Mod-Delete", run: Bhe }
].concat(/* @__PURE__ */ Khe.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), ede = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: hhe, shift: She },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: dhe, shift: Che },
  { key: "Alt-ArrowUp", run: jhe },
  { key: "Shift-Alt-ArrowUp", run: Fhe },
  { key: "Alt-ArrowDown", run: Vhe },
  { key: "Shift-Alt-ArrowDown", run: Zhe },
  { key: "Escape", run: Nhe },
  { key: "Mod-Enter", run: Xhe },
  { key: "Alt-l", mac: "Ctrl-l", run: Mhe },
  { key: "Mod-i", run: Rhe, preventDefault: !0 },
  { key: "Mod-[", run: Ghe },
  { key: "Mod-]", run: Uhe },
  { key: "Mod-Alt-\\", run: Yhe },
  { key: "Shift-Mod-k", run: qhe },
  { key: "Shift-Mod-\\", run: Ohe },
  { key: "Mod-/", run: Fue },
  { key: "Alt-A", run: que }
].concat(Jhe);
function Ht() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var r = t[i];
        typeof r == "string" ? n.setAttribute(i, r) : r != null && (n[i] = r);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    wD(n, arguments[e]);
  return n;
}
function wD(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      n.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        wD(n, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const EP = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class Hu {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, r = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, r), this.bufferStart = i, this.normalize = s ? (a) => s(EP(a)) : EP, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return yi(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = ix(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += jr(e);
      let r = this.normalize(t);
      for (let s = 0, o = i; ; s++) {
        let a = r.charCodeAt(s), l = this.match(a, o, this.bufferPos + this.bufferStart);
        if (s == r.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        o == i && s < t.length && t.charCodeAt(s) == a && o++;
      }
    }
  }
  match(e, t, i) {
    let r = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? r = { from: this.matches[s + 1], to: i } : (this.matches[s]++, a = !0)), a || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: t, to: i } : this.matches.push(1, t)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r;
  }
}
typeof Symbol < "u" && (Hu.prototype[Symbol.iterator] = function() {
  return this;
});
const xD = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Ax = "gm" + (/x/.unicode == null ? "" : "u");
class SD {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, r = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = xD, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new CD(e, t, i, r, s);
    this.re = new RegExp(t, Ax + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let o = e.lineAt(r);
    this.curLineStart = o.from, this.matchPos = Rm(e, r), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, r = i + t[0].length;
        if (this.matchPos = Rm(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, t)))
          return this.value = { from: i, to: r, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const lb = /* @__PURE__ */ new WeakMap();
class Jc {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let r = lb.get(e);
    if (!r || r.from >= i || r.to <= t) {
      let a = new Jc(t, e.sliceString(t, i));
      return lb.set(e, a), a;
    }
    if (r.from == t && r.to == i)
      return r;
    let { text: s, from: o } = r;
    return o > t && (s = e.sliceString(t, o) + s, o = t), r.to < i && (s += e.sliceString(r.to, i)), lb.set(e, new Jc(o, s)), new Jc(t, s.slice(t - o, i - o));
  }
}
class CD {
  constructor(e, t, i, r, s) {
    this.text = e, this.to = s, this.done = !1, this.value = xD, this.matchPos = Rm(e, r), this.re = new RegExp(t, Ax + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Jc.get(e, r, this.chunkEnd(
      r + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, r = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, r, t)))
          return this.value = { from: i, to: r, match: t }, this.matchPos = Rm(this.text, r + (i == r ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Jc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (SD.prototype[Symbol.iterator] = CD.prototype[Symbol.iterator] = function() {
  return this;
});
function tde(n) {
  try {
    return new RegExp(n, Ax), !0;
  } catch {
    return !1;
  }
}
function Rm(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function HO(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number), t = Ht("input", { class: "cm-textfield", name: "line", value: e }), i = Ht("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), n.dispatch({ effects: Nm.of(!1) }), n.focus()) : s.keyCode == 13 && (s.preventDefault(), r());
    },
    onsubmit: (s) => {
      s.preventDefault(), r();
    }
  }, Ht("label", n.state.phrase("Go to line"), ": ", t), " ", Ht("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")));
  function r() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = n, a = o.doc.lineAt(o.selection.main.head), [, l, c, u, h] = s, d = u ? +u.slice(1) : 0, f = c ? +c : a.number;
    if (c && h) {
      let m = f / 100;
      l && (m = m * (l == "-" ? -1 : 1) + a.number / o.doc.lines), f = Math.round(o.doc.lines * m);
    } else
      c && l && (f = f * (l == "-" ? -1 : 1) + a.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, f))), g = ue.cursor(p.from + Math.max(0, Math.min(d, p.length)));
    n.dispatch({
      effects: [Nm.of(!1), _e.scrollIntoView(g.from, { y: "center" })],
      selection: g
    }), n.focus();
  }
  return { dom: i };
}
const Nm = /* @__PURE__ */ ct.define(), AP = /* @__PURE__ */ hi.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Nm) && (n = t.value);
    return n;
  },
  provide: (n) => lf.from(n, (e) => e ? HO : null)
}), nde = (n) => {
  let e = af(n, HO);
  if (!e) {
    let t = [Nm.of(!0)];
    n.state.field(AP, !1) == null && t.push(ct.appendConfig.of([AP, ide])), n.dispatch({ effects: t }), e = af(n, HO);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, ide = /* @__PURE__ */ _e.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), rde = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, kD = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, rde, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function sde(n) {
  let e = [ude, cde];
  return n && e.push(kD.of(n)), e;
}
const ode = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch" }), ade = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function $P(n, e, t, i) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != ln.Word) && (i == e.doc.length || n(e.sliceDoc(i, i + 1)) != ln.Word);
}
function lde(n, e, t, i) {
  return n(e.sliceDoc(t, t + 1)) == ln.Word && n(e.sliceDoc(i - 1, i)) == ln.Word;
}
const cde = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(kD), { state: t } = n, i = t.selection;
    if (i.ranges.length > 1)
      return He.none;
    let r = i.main, s, o = null;
    if (r.empty) {
      if (!e.highlightWordAroundCursor)
        return He.none;
      let l = t.wordAt(r.head);
      if (!l)
        return He.none;
      o = t.charCategorizer(r.head), s = t.sliceDoc(l.from, l.to);
    } else {
      let l = r.to - r.from;
      if (l < e.minSelectionLength || l > 200)
        return He.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(r.from, r.to), o = t.charCategorizer(r.head), !($P(o, t, r.from, r.to) && lde(o, t, r.from, r.to)))
          return He.none;
      } else if (s = t.sliceDoc(r.from, r.to), !s)
        return He.none;
    }
    let a = [];
    for (let l of n.visibleRanges) {
      let c = new Hu(t.doc, s, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: u, to: h } = c.value;
        if ((!o || $P(o, t, u, h)) && (r.empty && u <= r.from && h >= r.to ? a.push(ade.range(u, h)) : (u >= r.to || h <= r.from) && a.push(ode.range(u, h)), a.length > e.maxMatches))
          return He.none;
      }
    }
    return He.set(a);
  }
}, {
  decorations: (n) => n.decorations
}), ude = /* @__PURE__ */ _e.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), hde = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, i = ue.create(t.ranges.map((r) => n.wordAt(r.head) || ue.cursor(r.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(n.update({ selection: i })), !0);
};
function dde(n, e) {
  let { main: t, ranges: i } = n.selection, r = n.wordAt(t.head), s = r && r.from == t.from && r.to == t.to;
  for (let o = !1, a = new Hu(n.doc, e, i[i.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new Hu(n.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((l) => l.from == a.value.from))
        continue;
      if (s) {
        let l = n.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const fde = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((s) => s.from === s.to))
    return hde({ state: n, dispatch: e });
  let i = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != i))
    return !1;
  let r = dde(n, i);
  return r ? (e(n.update({
    selection: n.selection.addRange(ue.range(r.from, r.to), !1),
    effects: _e.scrollIntoView(r.to)
  })), !0) : !1;
}, Oh = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new kde(e),
      scrollToMatch: (e) => _e.scrollIntoView(e)
    });
  }
});
class PD {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || tde(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new vde(this) : new gde(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, i) {
    let r = e.doc ? e : Et.create({ doc: e });
    return i == null && (i = r.doc.length), this.regexp ? Nc(this, r, t, i) : Rc(this, r, t, i);
  }
}
class ED {
  constructor(e) {
    this.spec = e;
  }
}
function Rc(n, e, t, i) {
  return new Hu(e.doc, n.unquoted, t, i, n.caseSensitive ? void 0 : (r) => r.toLowerCase(), n.wholeWord ? pde(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function pde(n, e) {
  return (t, i, r, s) => ((s > t || s + r.length < i) && (s = Math.max(0, t - 2), r = n.sliceString(s, Math.min(n.length, i + 2))), (e(Dm(r, t - s)) != ln.Word || e(Lm(r, t - s)) != ln.Word) && (e(Lm(r, i - s)) != ln.Word || e(Dm(r, i - s)) != ln.Word));
}
class gde extends ED {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let r = Rc(this.spec, e, i, e.doc.length).nextOverlapping();
    return r.done && (r = Rc(this.spec, e, 0, t).nextOverlapping()), r.done ? null : r.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let r = i; ; ) {
      let s = Math.max(t, r - 1e4 - this.spec.unquoted.length), o = Rc(this.spec, e, s, r), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (s == t)
        return null;
      r -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = Rc(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= t)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, t, i, r) {
    let s = Rc(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
function Nc(n, e, t, i) {
  return new SD(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? mde(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function Dm(n, e) {
  return n.slice(ki(n, e, !1), e);
}
function Lm(n, e) {
  return n.slice(e, ki(n, e));
}
function mde(n) {
  return (e, t, i) => !i[0].length || (n(Dm(i.input, i.index)) != ln.Word || n(Lm(i.input, i.index)) != ln.Word) && (n(Lm(i.input, i.index + i[0].length)) != ln.Word || n(Dm(i.input, i.index + i[0].length)) != ln.Word);
}
class vde extends ED {
  nextMatch(e, t, i) {
    let r = Nc(this.spec, e, i, e.doc.length).next();
    return r.done && (r = Nc(this.spec, e, 0, t).next()), r.done ? null : r.value;
  }
  prevMatchInRange(e, t, i) {
    for (let r = 1; ; r++) {
      let s = Math.max(
        t,
        i - r * 1e4
        /* FindPrev.ChunkSize */
      ), o = Nc(this.spec, e, s, i), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (s == t || a.from > s + 10))
        return a;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t);
  }
  matchAll(e, t) {
    let i = Nc(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= t)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, t, i, r) {
    let s = Nc(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
const hf = /* @__PURE__ */ ct.define(), $x = /* @__PURE__ */ ct.define(), Ma = /* @__PURE__ */ hi.define({
  create(n) {
    return new cb(XO(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(hf) ? n = new cb(t.value.create(), n.panel) : t.is($x) && (n = new cb(n.query, t.value ? Tx : null));
    return n;
  },
  provide: (n) => lf.from(n, (e) => e.panel)
});
class cb {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const bde = /* @__PURE__ */ He.mark({ class: "cm-searchMatch" }), yde = /* @__PURE__ */ He.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Ode = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(Ma));
  }
  update(n) {
    let e = n.state.field(Ma);
    (e != n.startState.field(Ma) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return He.none;
    let { view: t } = this, i = new Fa();
    for (let r = 0, s = t.visibleRanges, o = s.length; r < o; r++) {
      let { from: a, to: l } = s[r];
      for (; r < o - 1 && l > s[r + 1].from - 2 * 250; )
        l = s[++r].to;
      n.highlight(t.state, a, l, (c, u) => {
        let h = t.state.selection.ranges.some((d) => d.from == c && d.to == u);
        i.add(c, u, h ? yde : bde);
      });
    }
    return i.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function Ff(n) {
  return (e) => {
    let t = e.state.field(Ma, !1);
    return t && t.query.spec.valid ? n(e, t) : TD(e);
  };
}
const Im = /* @__PURE__ */ Ff((n, { query: e }) => {
  let { to: t } = n.state.selection.main, i = e.nextMatch(n.state, t, t);
  if (!i)
    return !1;
  let r = ue.single(i.from, i.to), s = n.state.facet(Oh);
  return n.dispatch({
    selection: r,
    effects: [_x(n, i), s.scrollToMatch(r.main, n)],
    userEvent: "select.search"
  }), $D(n), !0;
}), Bm = /* @__PURE__ */ Ff((n, { query: e }) => {
  let { state: t } = n, { from: i } = t.selection.main, r = e.prevMatch(t, i, i);
  if (!r)
    return !1;
  let s = ue.single(r.from, r.to), o = n.state.facet(Oh);
  return n.dispatch({
    selection: s,
    effects: [_x(n, r), o.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), $D(n), !0;
}), wde = /* @__PURE__ */ Ff((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: ue.create(t.map((i) => ue.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), xde = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: r } = t.main, s = [], o = 0;
  for (let a = new Hu(n.doc, n.sliceDoc(i, r)); !a.next().done; ) {
    if (s.length > 1e3)
      return !1;
    a.value.from == i && (o = s.length), s.push(ue.range(a.value.from, a.value.to));
  }
  return e(n.update({
    selection: ue.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, TP = /* @__PURE__ */ Ff((n, { query: e }) => {
  let { state: t } = n, { from: i, to: r } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, i, i);
  if (!s)
    return !1;
  let o = [], a, l, c = [];
  if (s.from == i && s.to == r && (l = t.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: l }), s = e.nextMatch(t, s.from, s.to), c.push(_e.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + "."))), s) {
    let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - l.length;
    a = ue.single(s.from - u, s.to - u), c.push(_x(n, s)), c.push(t.facet(Oh).scrollToMatch(a.main, n));
  }
  return n.dispatch({
    changes: o,
    selection: a,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), Sde = /* @__PURE__ */ Ff((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((r) => {
    let { from: s, to: o } = r;
    return { from: s, to: o, insert: e.getReplacement(r) };
  });
  if (!t.length)
    return !1;
  let i = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: _e.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function Tx(n) {
  return n.state.facet(Oh).createPanel(n);
}
function XO(n, e) {
  var t, i, r, s, o;
  let a = n.selection.main, l = a.empty || a.to > a.from + 100 ? "" : n.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = n.facet(Oh);
  return new PD({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive,
    literal: (r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function AD(n) {
  let e = af(n, Tx);
  return e && e.dom.querySelector("[main-field]");
}
function $D(n) {
  let e = AD(n);
  e && e == n.root.activeElement && e.select();
}
const TD = (n) => {
  let e = n.state.field(Ma, !1);
  if (e && e.panel) {
    let t = AD(n);
    if (t && t != n.root.activeElement) {
      let i = XO(n.state, e.query.spec);
      i.valid && n.dispatch({ effects: hf.of(i) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      $x.of(!0),
      e ? hf.of(XO(n.state, e.query.spec)) : ct.appendConfig.of(Ede)
    ] });
  return !0;
}, _D = (n) => {
  let e = n.state.field(Ma, !1);
  if (!e || !e.panel)
    return !1;
  let t = af(n, Tx);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: $x.of(!1) }), !0;
}, Cde = [
  { key: "Mod-f", run: TD, scope: "editor search-panel" },
  { key: "F3", run: Im, shift: Bm, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Im, shift: Bm, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: _D, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: xde },
  { key: "Mod-Alt-g", run: nde },
  { key: "Mod-d", run: fde, preventDefault: !0 }
];
class kde {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Ma).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ht("input", {
      value: t.search,
      placeholder: pr(e, "Find"),
      "aria-label": pr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ht("input", {
      value: t.replace,
      placeholder: pr(e, "Replace"),
      "aria-label": pr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ht("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Ht("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Ht("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(r, s, o) {
      return Ht("button", { class: "cm-button", name: r, onclick: s, type: "button" }, o);
    }
    this.dom = Ht("div", { onkeydown: (r) => this.keydown(r), class: "cm-search" }, [
      this.searchField,
      i("next", () => Im(e), [pr(e, "next")]),
      i("prev", () => Bm(e), [pr(e, "previous")]),
      i("select", () => wde(e), [pr(e, "all")]),
      Ht("label", null, [this.caseField, pr(e, "match case")]),
      Ht("label", null, [this.reField, pr(e, "regexp")]),
      Ht("label", null, [this.wordField, pr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Ht("br"),
        this.replaceField,
        i("replace", () => TP(e), [pr(e, "replace")]),
        i("replaceAll", () => Sde(e), [pr(e, "replace all")])
      ],
      Ht("button", {
        name: "close",
        onclick: () => _D(e),
        "aria-label": pr(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new PD({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: hf.of(e) }));
  }
  keydown(e) {
    Ble(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Bm : Im)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), TP(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(hf) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Oh).top;
  }
}
function pr(n, e) {
  return n.state.phrase(e);
}
const Bp = 30, Qp = /[\s\.,:;?!]/;
function _x(n, { from: e, to: t }) {
  let i = n.state.doc.lineAt(e), r = n.state.doc.lineAt(t).to, s = Math.max(i.from, e - Bp), o = Math.min(r, t + Bp), a = n.state.sliceDoc(s, o);
  if (s != i.from) {
    for (let l = 0; l < Bp; l++)
      if (!Qp.test(a[l + 1]) && Qp.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != r) {
    for (let l = a.length - 1; l > a.length - Bp; l--)
      if (!Qp.test(a[l - 1]) && Qp.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return _e.announce.of(`${n.state.phrase("current match")}. ${a} ${n.state.phrase("on line")} ${i.number}.`);
}
const Pde = /* @__PURE__ */ _e.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), Ede = [
  Ma,
  /* @__PURE__ */ hc.low(Ode),
  Pde
];
class MD {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = zn(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), r = t.text.slice(i - t.from, this.pos - t.from), s = r.search(ND(e, !1));
    return s < 0 ? null : { from: i + s, to: this.pos, text: r.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function _P(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function Ade(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of n) {
    e[r[0]] = !0;
    for (let s = 1; s < r.length; s++)
      t[r[s]] = !0;
  }
  let i = _P(e) + _P(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function Mx(n) {
  let e = n.map((r) => typeof r == "string" ? { label: r } : r), [t, i] = e.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : Ade(e);
  return (r) => {
    let s = r.matchBefore(i);
    return s || r.explicit ? { from: s ? s.from : r.pos, options: e, validFor: t } : null;
  };
}
function RD(n, e) {
  return (t) => {
    for (let i = zn(t.state).resolveInner(t.pos, -1); i; i = i.parent) {
      if (n.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(t);
  };
}
class MP {
  constructor(e, t, i, r) {
    this.completion = e, this.source = t, this.match = i, this.score = r;
  }
}
function Ra(n) {
  return n.selection.main.from;
}
function ND(n, e) {
  var t;
  let { source: i } = n, r = e && i[0] != "^", s = i[i.length - 1] != "$";
  return !r && !s ? n : new RegExp(`${r ? "^" : ""}(?:${i})${s ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const DD = /* @__PURE__ */ na.define();
function $de(n, e, t, i) {
  let { main: r } = n.selection, s = t - r.from, o = i - r.from;
  return Object.assign(Object.assign({}, n.changeByRange((a) => a != r && t != i && n.sliceDoc(a.from + s, a.from + o) != n.sliceDoc(t, i) ? { range: a } : {
    changes: { from: a.from + s, to: i == r.from ? a.to : a.from + o, insert: e },
    range: ue.cursor(a.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const RP = /* @__PURE__ */ new WeakMap();
function Tde(n) {
  if (!Array.isArray(n))
    return n;
  let e = RP.get(n);
  return e || RP.set(n, e = Mx(n)), e;
}
const Qm = /* @__PURE__ */ ct.define(), df = /* @__PURE__ */ ct.define();
class _de {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let i = yi(e, t), r = jr(i);
      this.chars.push(i);
      let s = e.slice(t, t + r), o = s.toUpperCase();
      this.folded.push(yi(o == s ? s.toLowerCase() : o, 0)), t += r;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: t, folded: i, any: r, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let y = yi(e, 0), b = jr(y), w = b == e.length ? 0 : -100;
      if (y != t[0])
        if (y == i[0])
          w += -200;
        else
          return !1;
      return this.ret(w, [0, b]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, c = 0;
    if (a < 0) {
      for (let y = 0, b = Math.min(e.length, 200); y < b && c < l; ) {
        let w = yi(e, y);
        (w == t[c] || w == i[c]) && (r[c++] = y), y += jr(w);
      }
      if (c < l)
        return !1;
    }
    let u = 0, h = 0, d = !1, f = 0, p = -1, g = -1, m = /[a-z]/.test(e), v = !0;
    for (let y = 0, b = Math.min(e.length, 200), w = 0; y < b && h < l; ) {
      let x = yi(e, y);
      a < 0 && (u < l && x == t[u] && (s[u++] = y), f < l && (x == t[f] || x == i[f] ? (f == 0 && (p = y), g = y + 1, f++) : f = 0));
      let S, C = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (S = ix(x)) != S.toLowerCase() ? 1 : S != S.toUpperCase() ? 2 : 0;
      (!y || C == 1 && m || w == 0 && C != 0) && (t[h] == x || i[h] == x && (d = !0) ? o[h++] = y : o.length && (v = !1)), w = C, y += jr(x);
    }
    return h == l && o[0] == 0 && v ? this.result(-100 + (d ? -200 : 0), o, e) : f == l && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : f == l ? this.ret(-900 - e.length, [p, g]) : h == l ? this.result(-100 + (d ? -200 : 0) + -700 + (v ? 0 : -1100), o, e) : t.length == 2 ? !1 : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e);
  }
  result(e, t, i) {
    let r = [], s = 0;
    for (let o of t) {
      let a = o + (this.astral ? jr(yi(i, o)) : 1);
      s && r[s - 1] == o ? r[s - 1] = a : (r[s++] = o, r[s++] = a);
    }
    return this.ret(e - i.length, r);
  }
}
const Si = /* @__PURE__ */ Me.define({
  combine(n) {
    return Oo(n, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: Mde,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => NP(e(i), t(i)),
      optionClass: (e, t) => (i) => NP(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function NP(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function Mde(n, e, t, i, r, s) {
  let o = n.textDirection == nn.RTL, a = o, l = !1, c = "top", u, h, d = e.left - r.left, f = r.right - e.right, p = i.right - i.left, g = i.bottom - i.top;
  if (a && d < Math.min(p, f) ? a = !1 : !a && f < Math.min(p, d) && (a = !0), p <= (a ? d : f))
    u = Math.max(r.top, Math.min(t.top, r.bottom - g)) - e.top, h = Math.min(400, a ? d : f);
  else {
    l = !0, h = Math.min(
      400,
      (o ? e.right : r.right - e.left) - 30
      /* Info.Margin */
    );
    let y = r.bottom - e.bottom;
    y >= g || y > e.top ? u = t.bottom - e.top : (c = "bottom", u = e.bottom - t.top);
  }
  let m = (e.bottom - e.top) / s.offsetHeight, v = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / m}px; max-width: ${h / v}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function Rde(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, r, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = t.displayLabel || t.label, l = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], h = s[c++];
        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
        let d = o.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(a.slice(u, h))), d.className = "cm-completionMatchedText", l = h;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function ub(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let r = Math.floor(e / t);
    return { from: r * t, to: (r + 1) * t };
  }
  let i = Math.floor((n - e) / t);
  return { from: n - (i + 1) * t, to: n - i * t };
}
class Nde {
  constructor(e, t, i) {
    this.view = e, this.stateField = t, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = e.state.field(t), { options: s, selected: o } = r.open, a = e.state.facet(Si);
    this.optionContent = Rde(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = ub(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(t).open;
      for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Si).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: df.of(null) });
    }), this.showOptions(s, r.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let i = e.state.field(this.stateField), r = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != r) {
      let { options: s, selected: o, disabled: a } = i.open;
      (!r.open || r.open.options != s) && (this.range = ub(s.length, o, e.state.facet(Si).maxRenderedOptions), this.showOptions(s, i.id)), this.updateSel(), a != ((t = r.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = ub(t.options.length, t.selected, this.view.state.facet(Si).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: i } = t.options[t.selected], { info: r } = i;
      if (!r)
        return;
      let s = typeof r == "string" ? document.createTextNode(r) : r(i);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, i);
      }).catch((o) => qr(this.view.state, o, "completion info")) : this.addInfoPane(s, i);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: r, destroy: s } = e;
      i.appendChild(r), this.infoDestroy = s || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)
      i.nodeName != "LI" || !i.id ? r-- : r == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && Lde(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return r.top > Math.min(s.bottom, t.bottom) - 10 || r.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(Si).positionInfo(this.view, t, r, i, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, i) {
    const r = document.createElement("ul");
    r.id = t, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = i.from; o < i.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let d = typeof c == "string" ? c : c.name;
        if (d != s && (o > i.from || i.from == 0))
          if (s = d, typeof c != "string" && c.header)
            r.appendChild(c.header(c));
          else {
            let f = r.appendChild(document.createElement("completion-section"));
            f.textContent = d;
          }
      }
      const u = r.appendChild(document.createElement("li"));
      u.id = t + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(a);
      h && (u.className = h);
      for (let d of this.optionContent) {
        let f = d(a, this.view.state, this.view, l);
        f && u.appendChild(f);
      }
    }
    return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < e.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function Dde(n, e) {
  return (t) => new Nde(t, n, e);
}
function Lde(n, e) {
  let t = n.getBoundingClientRect(), i = e.getBoundingClientRect(), r = t.height / n.offsetHeight;
  i.top < t.top ? n.scrollTop -= (t.top - i.top) / r : i.bottom > t.bottom && (n.scrollTop += (i.bottom - t.bottom) / r);
}
function DP(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function Ide(n, e) {
  let t = [], i = null, r = (l) => {
    t.push(l);
    let { section: c } = l.completion;
    if (c) {
      i || (i = []);
      let u = typeof c == "string" ? c : c.name;
      i.some((h) => h.name == u) || i.push(typeof c == "string" ? { name: u } : c);
    }
  };
  for (let l of n)
    if (l.hasResult()) {
      let c = l.result.getMatch;
      if (l.result.filter === !1)
        for (let u of l.result.options)
          r(new MP(u, l.source, c ? c(u) : [], 1e9 - t.length));
      else {
        let u = new _de(e.sliceDoc(l.from, l.to));
        for (let h of l.result.options)
          if (u.match(h.label)) {
            let d = h.displayLabel ? c ? c(h, u.matched) : [] : u.matched;
            r(new MP(h, l.source, d, u.score + (h.boost || 0)));
          }
      }
    }
  if (i) {
    let l = /* @__PURE__ */ Object.create(null), c = 0, u = (h, d) => {
      var f, p;
      return ((f = h.rank) !== null && f !== void 0 ? f : 1e9) - ((p = d.rank) !== null && p !== void 0 ? p : 1e9) || (h.name < d.name ? -1 : 1);
    };
    for (let h of i.sort(u))
      c -= 1e5, l[h.name] = c;
    for (let h of t) {
      let { section: d } = h.completion;
      d && (h.score += l[typeof d == "string" ? d : d.name]);
    }
  }
  let s = [], o = null, a = e.facet(Si).compareCompletions;
  for (let l of t.sort((c, u) => u.score - c.score || a(c.completion, u.completion))) {
    let c = l.completion;
    !o || o.label != c.label || o.detail != c.detail || o.type != null && c.type != null && o.type != c.type || o.apply != c.apply || o.boost != c.boost ? s.push(l) : DP(l.completion) > DP(o) && (s[s.length - 1] = l), o = l.completion;
  }
  return s;
}
class Qc {
  constructor(e, t, i, r, s, o) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = r, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Qc(this.options, LP(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, r, s) {
    let o = Ide(e, t);
    if (!o.length)
      return r && e.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new Qc(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0) : null;
    let a = t.facet(Si).selectOnOpen ? 0 : -1;
    if (r && r.selected != a && r.selected != -1) {
      let l = r.options[r.selected].completion;
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == l) {
          a = c;
          break;
        }
    }
    return new Qc(o, LP(i, a), {
      pos: e.reduce((l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),
      create: Vde,
      above: s.aboveCursor
    }, r ? r.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new Qc(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class zm {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new zm(zde, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(Si), s = (i.override || t.languageDataAt("autocomplete", Ra(t)).map(Tde)).map((a) => (this.active.find((c) => c.source == a) || new ir(
      a,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !Bde(s, this.active) ? o = Qc.build(s, t, this.id, o, i) : o && o.disabled && !s.some(
      (a) => a.state == 1
      /* State.Pending */
    ) && (o = null), !o && s.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new ir(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(ID) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new zm(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : Qde;
  }
}
function Bde(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < n.length && !n[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let r = t == n.length, s = i == e.length;
    if (r || s)
      return r == s;
    if (n[t++].result != e[i++].result)
      return !1;
  }
}
const Qde = {
  "aria-autocomplete": "list"
};
function LP(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const zde = [];
function YO(n) {
  return n.isUserEvent("input.type") ? "input" : n.isUserEvent("delete.backward") ? "delete" : null;
}
class ir {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let i = YO(e), r = this;
    i ? r = r.handleUserEvent(e, i, t) : e.docChanged ? r = r.handleChange(e) : e.selection && r.state != 0 && (r = new ir(
      r.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(Qm))
        r = new ir(r.source, 1, s.value ? Ra(e.state) : -1);
      else if (s.is(df))
        r = new ir(
          r.source,
          0
          /* State.Inactive */
        );
      else if (s.is(LD))
        for (let o of s.value)
          o.source == r.source && (r = o);
    return r;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new ir(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Ra(e.startState)) ? new ir(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new ir(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class eu extends ir {
  constructor(e, t, i, r, s) {
    super(e, 2, t), this.result = i, this.from = r, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, i) {
    var r;
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = Ra(e.state);
    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || t == "delete" && Ra(e.startState) == this.from)
      return new ir(
        this.source,
        t == "input" && i.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return jde(this.result.validFor, e.state, s, o) ? new eu(this.source, l, this.result, s, o) : this.result.update && (c = this.result.update(this.result, s, o, new MD(e.state, a, l >= 0))) ? new eu(this.source, l, c, c.from, (r = c.to) !== null && r !== void 0 ? r : Ra(e.state)) : new ir(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new ir(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new eu(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function jde(n, e, t, i) {
  if (!n)
    return !1;
  let r = e.sliceDoc(t, i);
  return typeof n == "function" ? n(r, t, i, e) : ND(n, !0).test(r);
}
const LD = /* @__PURE__ */ ct.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), ID = /* @__PURE__ */ ct.define(), Sr = /* @__PURE__ */ hi.define({
  create() {
    return zm.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    gx.from(n, (e) => e.tooltip),
    _e.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function BD(n, e) {
  const t = e.completion.apply || e.completion.label;
  let i = n.state.field(Sr).active.find((r) => r.source == e.source);
  return i instanceof eu ? (typeof t == "string" ? n.dispatch(Object.assign(Object.assign({}, $de(n.state, t, i.from, i.to)), { annotations: DD.of(e.completion) })) : t(n, e.completion, i.from, i.to), !0) : !1;
}
const Vde = /* @__PURE__ */ Dde(Sr, BD);
function zp(n, e = "option") {
  return (t) => {
    let i = t.state.field(Sr, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(Si).interactionDelay)
      return !1;
    let r = 1, s;
    e == "page" && (s = yN(t, i.open.tooltip)) && (r = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = i.open.options, a = i.open.selected > -1 ? i.open.selected + r * (n ? 1 : -1) : n ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), t.dispatch({ effects: ID.of(a) }), !0;
  };
}
const Fde = (n) => {
  let e = n.state.field(Sr, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(Si).interactionDelay ? !1 : BD(n, e.open.options[e.open.selected]);
}, Zde = (n) => n.state.field(Sr, !1) ? (n.dispatch({ effects: Qm.of(!0) }), !0) : !1, qde = (n) => {
  let e = n.state.field(Sr, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: df.of(null) }), !0);
};
class Wde {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Hde = 50, Xde = 1e3, Yde = /* @__PURE__ */ Qn.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of n.state.field(Sr).active)
      e.state == 1 && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(Sr);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Sr) == e)
      return;
    let t = n.transactions.some((r) => (r.selection || r.docChanged) && !YO(r));
    for (let r = 0; r < this.running.length; r++) {
      let s = this.running[r];
      if (t || s.updates.length + n.transactions.length > Hde && Date.now() - s.time > Xde) {
        for (let o of s.context.abortListeners)
          try {
            o();
          } catch (a) {
            qr(this.view.state, a);
          }
        s.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        s.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((r) => r.effects.some((s) => s.is(Qm))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : n.state.facet(Si).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((r) => r.state == 1 && !this.running.some((s) => s.active.source == r.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let r of n.transactions)
        YO(r) == "input" ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, e = n.field(Sr);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(n) {
    let { state: e } = this.view, t = Ra(e), i = new MD(e, t, n.explicitPos == t), r = new Wde(n, i);
    this.running.push(r), Promise.resolve(n.source(i)).then((s) => {
      r.context.aborted || (r.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: df.of(null) }), qr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Si).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Si);
    for (let i = 0; i < this.running.length; i++) {
      let r = this.running[i];
      if (r.done === void 0)
        continue;
      if (this.running.splice(i--, 1), r.done) {
        let o = new eu(r.active.source, r.active.explicitPos, r.done, r.done.from, (n = r.done.to) !== null && n !== void 0 ? n : Ra(r.updates.length ? r.updates[0].startState : this.view.state));
        for (let a of r.updates)
          o = o.update(a, t);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(Sr).active.find((o) => o.source == r.active.source);
      if (s && s.state == 1)
        if (r.done == null) {
          let o = new ir(
            r.active.source,
            0
            /* State.Inactive */
          );
          for (let a of r.updates)
            o = o.update(a, t);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: LD.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(Sr, !1);
      if (e && e.tooltip && this.view.state.facet(Si).closeOnBlur) {
        let t = e.open && yN(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: df.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Qm.of(!1) }), 20), this.composing = 0;
    }
  }
}), QD = /* @__PURE__ */ _e.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Ude {
  constructor(e, t, i, r) {
    this.field = e, this.line = t, this.from = i, this.to = r;
  }
}
class Rx {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, xi.TrackDel), i = e.mapPos(this.to, 1, xi.TrackDel);
    return t == null || i == null ? null : new Rx(this.field, t, i);
  }
}
class Nx {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], r = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let c = o, u = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < u; h++)
          c += e.facet(jv);
        r.push(t + c.length - u), l = c + l.slice(u);
      }
      i.push(l), t += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new Rx(l.field, r[l.line] + l.from, r[l.line] + l.to));
    return { text: i, ranges: a };
  }
  static parse(e) {
    let t = [], i = [], r = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || "", c = -1;
        for (let u = 0; u < t.length; u++)
          (a != null ? t[u].seq == a : l && t[u].name == l) && (c = u);
        if (c < 0) {
          let u = 0;
          for (; u < t.length && (a == null || t[u].seq != null && t[u].seq < a); )
            u++;
          t.splice(u, 0, { seq: a, name: l }), c = u;
          for (let h of r)
            h.field >= c && h.field++;
        }
        r.push(new Ude(c, i.length, s.index, s.index + l.length)), o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length);
      }
      for (let a; a = /\\([{}])/.exec(o); ) {
        o = o.slice(0, a.index) + a[1] + o.slice(a.index + a[0].length);
        for (let l of r)
          l.line == i.length && l.from > a.index && (l.from--, l.to--);
      }
      i.push(o);
    }
    return new Nx(i, r);
  }
}
let Gde = /* @__PURE__ */ He.widget({ widget: /* @__PURE__ */ new class extends ia {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Kde = /* @__PURE__ */ He.mark({ class: "cm-snippetField" });
class wh {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = He.set(e.map((i) => (i.from == i.to ? Gde : Kde).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let r = i.map(e);
      if (!r)
        return null;
      t.push(r);
    }
    return new wh(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
}
const Zf = /* @__PURE__ */ ct.define({
  map(n, e) {
    return n && n.map(e);
  }
}), Jde = /* @__PURE__ */ ct.define(), ff = /* @__PURE__ */ hi.define({
  create() {
    return null;
  },
  update(n, e) {
    for (let t of e.effects) {
      if (t.is(Zf))
        return t.value;
      if (t.is(Jde) && n)
        return new wh(n.ranges, t.value);
    }
    return n && e.docChanged && (n = n.map(e.changes)), n && e.selection && !n.selectionInsideField(e.selection) && (n = null), n;
  },
  provide: (n) => _e.decorations.from(n, (e) => e ? e.deco : He.none)
});
function Dx(n, e) {
  return ue.create(n.filter((t) => t.field == e).map((t) => ue.range(t.from, t.to)));
}
function efe(n) {
  let e = Nx.parse(n);
  return (t, i, r, s) => {
    let { text: o, ranges: a } = e.instantiate(t.state, r), l = {
      changes: { from: r, to: s, insert: $t.of(o) },
      scrollIntoView: !0,
      annotations: i ? [DD.of(i), Dn.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (l.selection = Dx(a, 0)), a.some((c) => c.field > 0)) {
      let c = new wh(a, 0), u = l.effects = [Zf.of(c)];
      t.state.field(ff, !1) === void 0 && u.push(ct.appendConfig.of([ff, sfe, ofe, QD]));
    }
    t.dispatch(t.state.update(l));
  };
}
function zD(n) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(ff, !1);
    if (!i || n < 0 && i.active == 0)
      return !1;
    let r = i.active + n, s = n > 0 && !i.ranges.some((o) => o.field == r + n);
    return t(e.update({
      selection: Dx(i.ranges, r),
      effects: Zf.of(s ? null : new wh(i.ranges, r)),
      scrollIntoView: !0
    })), !0;
  };
}
const tfe = ({ state: n, dispatch: e }) => n.field(ff, !1) ? (e(n.update({ effects: Zf.of(null) })), !0) : !1, nfe = /* @__PURE__ */ zD(1), ife = /* @__PURE__ */ zD(-1), rfe = [
  { key: "Tab", run: nfe, shift: ife },
  { key: "Escape", run: tfe }
], IP = /* @__PURE__ */ Me.define({
  combine(n) {
    return n.length ? n[0] : rfe;
  }
}), sfe = /* @__PURE__ */ hc.highest(/* @__PURE__ */ Bv.compute([IP], (n) => n.facet(IP)));
function tr(n, e) {
  return Object.assign(Object.assign({}, e), { apply: efe(n) });
}
const ofe = /* @__PURE__ */ _e.domEventHandlers({
  mousedown(n, e) {
    let t = e.state.field(ff, !1), i;
    if (!t || (i = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let r = t.ranges.find((s) => s.from <= i && s.to >= i);
    return !r || r.field == t.active ? !1 : (e.dispatch({
      selection: Dx(t.ranges, r.field),
      effects: Zf.of(t.ranges.some((s) => s.field > r.field) ? new wh(t.ranges, r.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), pf = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Tl = /* @__PURE__ */ ct.define({
  map(n, e) {
    let t = e.mapPos(n, -1, xi.TrackAfter);
    return t ?? void 0;
  }
}), Lx = /* @__PURE__ */ new class extends Kl {
}();
Lx.startSide = 1;
Lx.endSide = -1;
const jD = /* @__PURE__ */ hi.define({
  create() {
    return kt.empty;
  },
  update(n, e) {
    if (n = n.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      n = n.update({ filter: (i) => i >= t.from && i <= t.to });
    }
    for (let t of e.effects)
      t.is(Tl) && (n = n.update({ add: [Lx.range(t.value, t.value + 1)] }));
    return n;
  }
});
function afe() {
  return [cfe, jD];
}
const hb = "()[]{}<>";
function VD(n) {
  for (let e = 0; e < hb.length; e += 2)
    if (hb.charCodeAt(e) == n)
      return hb.charAt(e + 1);
  return ix(n < 128 ? n : n + 1);
}
function FD(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || pf;
}
const lfe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), cfe = /* @__PURE__ */ _e.inputHandler.of((n, e, t, i) => {
  if ((lfe ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let r = n.state.selection.main;
  if (i.length > 2 || i.length == 2 && jr(yi(i, 0)) == 1 || e != r.from || t != r.to)
    return !1;
  let s = dfe(n.state, i);
  return s ? (n.dispatch(s), !0) : !1;
}), ufe = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let i = FD(n, n.selection.main.head).brackets || pf.brackets, r = null, s = n.changeByRange((o) => {
    if (o.empty) {
      let a = ffe(n.doc, o.head);
      for (let l of i)
        if (l == a && Gv(n.doc, o.head) == VD(yi(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: ue.cursor(o.head - l.length)
          };
    }
    return { range: r = o };
  });
  return r || e(n.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !r;
}, hfe = [
  { key: "Backspace", run: ufe }
];
function dfe(n, e) {
  let t = FD(n, n.selection.main.head), i = t.brackets || pf.brackets;
  for (let r of i) {
    let s = VD(yi(r, 0));
    if (e == r)
      return s == r ? mfe(n, r, i.indexOf(r + r + r) > -1, t) : pfe(n, r, s, t.before || pf.before);
    if (e == s && ZD(n, n.selection.main.from))
      return gfe(n, r, s);
  }
  return null;
}
function ZD(n, e) {
  let t = !1;
  return n.field(jD).between(0, n.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function Gv(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, jr(yi(t, 0)));
}
function ffe(n, e) {
  let t = n.sliceString(e - 2, e);
  return jr(yi(t, 0)) == t.length ? t : t.slice(1);
}
function pfe(n, e, t, i) {
  let r = null, s = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: Tl.of(o.to + e.length),
        range: ue.range(o.anchor + e.length, o.head + e.length)
      };
    let a = Gv(n.doc, o.head);
    return !a || /\s/.test(a) || i.indexOf(a) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: Tl.of(o.head + e.length),
      range: ue.cursor(o.head + e.length)
    } : { range: r = o };
  });
  return r ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function gfe(n, e, t) {
  let i = null, r = n.changeByRange((s) => s.empty && Gv(n.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: ue.cursor(s.head + t.length)
  } : i = { range: s });
  return i ? null : n.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function mfe(n, e, t, i) {
  let r = i.stringPrefixes || pf.stringPrefixes, s = null, o = n.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Tl.of(a.to + e.length),
        range: ue.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = Gv(n.doc, l), u;
    if (c == e) {
      if (BP(n, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Tl.of(l + e.length),
          range: ue.cursor(l + e.length)
        };
      if (ZD(n, l)) {
        let d = t && n.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: ue.cursor(l + d.length)
        };
      }
    } else {
      if (t && n.sliceDoc(l - 2 * e.length, l) == e + e && (u = QP(n, l - 2 * e.length, r)) > -1 && BP(n, u))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Tl.of(l + e.length),
          range: ue.cursor(l + e.length)
        };
      if (n.charCategorizer(l)(c) != ln.Word && QP(n, l, r) > -1 && !vfe(n, l, e, r))
        return {
          changes: { insert: e + e, from: l },
          effects: Tl.of(l + e.length),
          range: ue.cursor(l + e.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function BP(n, e) {
  let t = zn(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function vfe(n, e, t, i) {
  let r = zn(n).resolveInner(e, -1), s = i.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = n.sliceDoc(r.from, Math.min(r.to, r.from + t.length + s)), l = a.indexOf(t);
    if (!l || l > -1 && i.indexOf(a.slice(0, l)) > -1) {
      let u = r.firstChild;
      for (; u && u.from == r.from && u.to - u.from > t.length + l; ) {
        if (n.sliceDoc(u.to - t.length, u.to) == t)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = r.to == e && r.parent;
    if (!c)
      break;
    r = c;
  }
  return !1;
}
function QP(n, e, t) {
  let i = n.charCategorizer(e);
  if (i(n.sliceDoc(e - 1, e)) != ln.Word)
    return e;
  for (let r of t) {
    let s = e - r.length;
    if (n.sliceDoc(s, e) == r && i(n.sliceDoc(s - 1, s)) != ln.Word)
      return s;
  }
  return -1;
}
function bfe(n = {}) {
  return [
    Sr,
    Si.of(n),
    Yde,
    yfe,
    QD
  ];
}
const qD = [
  { key: "Ctrl-Space", run: Zde },
  { key: "Escape", run: qde },
  { key: "ArrowDown", run: /* @__PURE__ */ zp(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ zp(!1) },
  { key: "PageDown", run: /* @__PURE__ */ zp(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ zp(!1, "page") },
  { key: "Enter", run: Fde }
], yfe = /* @__PURE__ */ hc.highest(/* @__PURE__ */ Bv.computeN([Si], (n) => n.facet(Si).defaultKeymap ? [qD] : []));
class Ofe {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class wl {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let r = e, s = i.facet(XD).markerFilter;
    s && (r = s(r, i));
    let o = He.set(r.map((a) => a.from == a.to || a.from == a.to - 1 && i.doc.lineAt(a.from).to == a.from ? He.widget({
      widget: new $fe(a),
      diagnostic: a
    }).range(a.from) : He.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity + (a.markClass ? " " + a.markClass : "") },
      diagnostic: a,
      inclusive: !0
    }).range(a.from, a.to)), !0);
    return new wl(o, t, Xu(o));
  }
}
function Xu(n, e = null, t = 0) {
  let i = null;
  return n.between(t, 1e9, (r, s, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return i = new Ofe(r, s, o.diagnostic), !1;
  }), i;
}
function wfe(n, e) {
  let t = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((i) => i.is(WD)) || n.changes.touchesRange(t.from, t.to));
}
function xfe(n, e) {
  return n.field(Ar, !1) ? e : e.concat(ct.appendConfig.of(Mfe));
}
const WD = /* @__PURE__ */ ct.define(), Ix = /* @__PURE__ */ ct.define(), HD = /* @__PURE__ */ ct.define(), Ar = /* @__PURE__ */ hi.define({
  create() {
    return new wl(He.none, null, null);
  },
  update(n, e) {
    if (e.docChanged) {
      let t = n.diagnostics.map(e.changes), i = null;
      if (n.selected) {
        let r = e.changes.mapPos(n.selected.from, 1);
        i = Xu(t, n.selected.diagnostic, r) || Xu(t, null, r);
      }
      n = new wl(t, n.panel, i);
    }
    for (let t of e.effects)
      t.is(WD) ? n = wl.init(t.value, n.panel, e.state) : t.is(Ix) ? n = new wl(n.diagnostics, t.value ? Kv.open : null, n.selected) : t.is(HD) && (n = new wl(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    lf.from(n, (e) => e.panel),
    _e.decorations.from(n, (e) => e.diagnostics)
  ]
}), Sfe = /* @__PURE__ */ He.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: !0 });
function Cfe(n, e, t) {
  let { diagnostics: i } = n.state.field(Ar), r = [], s = 2e8, o = 0;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: u }) => {
    e >= l && e <= c && (l == c || (e > l || t > 0) && (e < c || t < 0)) && (r.push(u.diagnostic), s = Math.min(l, s), o = Math.max(c, o));
  });
  let a = n.state.facet(XD).tooltipFilter;
  return a && (r = a(r, n.state)), r.length ? {
    pos: s,
    end: o,
    above: n.state.doc.lineAt(s).to < o,
    create() {
      return { dom: kfe(n, r) };
    }
  } : null;
}
function kfe(n, e) {
  return Ht("ul", { class: "cm-tooltip-lint" }, e.map((t) => UD(n, t, !1)));
}
const Pfe = (n) => {
  let e = n.state.field(Ar, !1);
  (!e || !e.panel) && n.dispatch({ effects: xfe(n.state, [Ix.of(!0)]) });
  let t = af(n, Kv.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, zP = (n) => {
  let e = n.state.field(Ar, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: Ix.of(!1) }), !0);
}, Efe = (n) => {
  let e = n.state.field(Ar, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, Afe = [
  { key: "Mod-Shift-m", run: Pfe, preventDefault: !0 },
  { key: "F8", run: Efe }
], XD = /* @__PURE__ */ Me.define({
  combine(n) {
    return Object.assign({ sources: n.map((e) => e.source).filter((e) => e != null) }, Oo(n.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (i) => e(i) || t(i) : e : t
    }));
  }
});
function YD(n) {
  let e = [];
  if (n)
    e:
      for (let { name: t } of n) {
        for (let i = 0; i < t.length; i++) {
          let r = t[i];
          if (/[a-zA-Z]/.test(r) && !e.some((s) => s.toLowerCase() == r.toLowerCase())) {
            e.push(r);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function UD(n, e, t) {
  var i;
  let r = t ? YD(e.actions) : [];
  return Ht("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ht("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((s, o) => {
    let a = !1, l = (d) => {
      if (d.preventDefault(), a)
        return;
      a = !0;
      let f = Xu(n.state.field(Ar).diagnostics, e);
      f && s.apply(n, f.from, f.to);
    }, { name: c } = s, u = r[o] ? c.indexOf(r[o]) : -1, h = u < 0 ? c : [
      c.slice(0, u),
      Ht("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ];
    return Ht("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${r[o]})"`}.`
    }, h);
  }), e.source && Ht("div", { class: "cm-diagnosticSource" }, e.source));
}
class $fe extends ia {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Ht("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class jP {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = UD(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Kv {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (r) => {
      if (r.keyCode == 27)
        zP(this.view), this.view.focus();
      else if (r.keyCode == 38 || r.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (r.keyCode == 40 || r.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (r.keyCode == 36)
        this.moveSelection(0);
      else if (r.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (r.keyCode == 13)
        this.view.focus();
      else if (r.keyCode >= 65 && r.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = YD(s.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == r.keyCode) {
            let l = Xu(this.view.state.field(Ar).diagnostics, s);
            l && s.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      r.preventDefault();
    }, i = (r) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(r.target) && this.moveSelection(s);
    };
    this.list = Ht("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = Ht("div", { class: "cm-panel-lint" }, this.list, Ht("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => zP(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Ar).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Ar), i = 0, r = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (o, a, { spec: l }) => {
      let c = -1, u;
      for (let h = i; h < this.items.length; h++)
        if (this.items[h].diagnostic == l.diagnostic) {
          c = h;
          break;
        }
      c < 0 ? (u = new jP(this.view, l.diagnostic), this.items.splice(i, 0, u), r = !0) : (u = this.items[c], c > i && (this.items.splice(i, c - i), r = !0)), t && u.diagnostic == t.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), s = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      r = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new jP(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), r = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: a }) => {
        let l = a.height / this.list.offsetHeight;
        o.top < a.top ? this.list.scrollTop -= (a.top - o.top) / l : o.bottom > a.bottom && (this.list.scrollTop += (o.bottom - a.bottom) / l);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), r && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Ar), i = Xu(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: HD.of(i)
    });
  }
  static open(e) {
    return new Kv(e);
  }
}
function Tfe(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function jp(n) {
  return Tfe(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const _fe = /* @__PURE__ */ _e.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ jp("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ jp("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ jp("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ jp("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), Mfe = [
  Ar,
  /* @__PURE__ */ _e.decorations.compute([Ar], (n) => {
    let { selected: e, panel: t } = n.field(Ar);
    return !e || !t || e.from == e.to ? He.none : He.set([
      Sfe.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ Cce(Cfe, { hideOn: wfe }),
  _fe
], fJe = [
  Rce(),
  Lce(),
  tce(),
  Kue(),
  Cue(),
  Zle(),
  Yle(),
  Et.allowMultipleSelections.of(!0),
  hue(),
  Pue($ue, { fallback: !0 }),
  Lue(),
  afe(),
  bfe(),
  fce(),
  mce(),
  ace(),
  sde(),
  Bv.of([
    ...hfe,
    ...ede,
    ...Cde,
    ...ahe,
    ...Oue,
    ...qD,
    ...Afe
  ])
];
let Rfe = class UO {
  /**
  @internal
  */
  constructor(e, t, i, r, s, o, a, l, c, u = 0, h) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = r, this.pos = s, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = u, this.parent = h;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, i = 0) {
    let r = e.parser.context;
    return new UO(e, [], t, i, i, 0, [], 0, r ? new VP(r, r.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let i = e >> 19, r = e & 65535, { parser: s } = this.p, o = s.dynamicPrecedence(r);
    if (o && (this.score += o), i == 0) {
      this.pushState(s.getGoto(this.state, r, !0), this.reducePos), r < s.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, 4, !0), this.reduceContext(r, this.reducePos);
      return;
    }
    let a = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, c = this.reducePos - l;
    c >= 2e3 && !(!((t = this.p.parser.nodeSet.types[r]) === null || t === void 0) && t.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = c));
    let u = a ? this.stack[a - 1] : 0, h = this.bufferBase + this.buffer.length - u;
    if (r < s.minRepeatTerm || e & 131072) {
      let d = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(r, l, d, h + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[a];
    else {
      let d = this.stack[a - 3];
      this.state = s.getGoto(d, r, !0);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(r, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, i, r = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, a = this.buffer.length;
      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {
        if (t == i)
          return;
        if (o.buffer[a - 2] >= t) {
          o.buffer[a - 2] = i;
          return;
        }
      }
    }
    if (!s || this.pos == i)
      this.buffer.push(e, t, i, r);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > i; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, r > 4 && (r -= 4);
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = i, this.buffer[o + 3] = r;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, i, r) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = r, this.shiftContext(t, i), t <= this.p.parser.maxNode && this.buffer.push(t, i, r, 4);
    else {
      let s = e, { parser: o } = this.p;
      (r > this.pos || t <= o.maxNode) && (this.pos = r, o.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(s, i), this.shiftContext(t, i), t <= o.maxNode && this.buffer.push(t, i, r, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, i, r) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let r = this.pos;
    this.reducePos = this.pos = r + e.length, this.pushState(t, r), this.buffer.push(
      i,
      r,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), r = e.bufferBase + t;
    for (; e && r == e.bufferBase; )
      e = e.parent;
    return new UO(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new Nfe(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let r = [];
      for (let s = 0, o; s < t.length; s += 2)
        (o = t[s + 1]) != this.state && this.p.parser.hasAction(o, e) && r.push(t[s], o);
      if (this.stack.length < 120)
        for (let s = 0; r.length < 8 && s < t.length; s += 2) {
          let o = t[s + 1];
          r.some((a, l) => l & 1 && a == o) || r.push(t[s], o);
        }
      t = r;
    }
    let i = [];
    for (let r = 0; r < t.length && i.length < 4; r += 2) {
      let s = t[r + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(t[r], this.pos), o.reducePos = this.pos, o.score -= 200, i.push(o);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(t & 65536))
      return !1;
    if (!e.validAction(this.state, t)) {
      let i = t >> 19, r = t & 65535, s = this.stack.length - i * 3;
      if (s < 0 || e.getGoto(this.stack[s], r, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        t = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], i = (r, s) => {
      if (!t.includes(r))
        return t.push(r), e.allActions(r, (o) => {
          if (!(o & 393216))
            if (o & 65536) {
              let a = (o >> 19) - s;
              if (a > 1) {
                let l = o & 65535, c = this.stack.length - a * 3;
                if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = i(o, s + 1);
              if (a != null)
                return a;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new VP(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
class VP {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class Nfe {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let r = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = r;
  }
}
class jm {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new jm(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new jm(this.stack, this.pos, this.index);
  }
}
function Xh(n, e = Uint16Array) {
  if (typeof n != "string")
    return n;
  let t = null;
  for (let i = 0, r = 0; i < n.length; ) {
    let s = 0;
    for (; ; ) {
      let o = n.charCodeAt(i++), a = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, a = !0), s += l, a)
        break;
      s *= 46;
    }
    t ? t[r++] = s : t = new e(s);
  }
  return t;
}
class Tg {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const FP = new Tg();
class Dfe {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = FP, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let i = this.range, r = this.rangeIndex, s = this.pos + e;
    for (; s < i.from; ) {
      if (!r)
        return null;
      let o = this.ranges[--r];
      s -= i.from - o.to, i = o;
    }
    for (; t < 0 ? s > i.to : s >= i.to; ) {
      if (r == this.ranges.length - 1)
        return null;
      let o = this.ranges[++r];
      s += o.from - i.to, i = o;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, i, r;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, r = this.chunk.charCodeAt(t);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (i = s, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        r = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, a = this.range;
        for (; a.to <= i; )
          a = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - i)), r = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, t) {
    this.token.value = e, this.token.end = t;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = FP, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let r of this.ranges) {
      if (r.from >= t)
        break;
      r.to > e && (i += this.input.read(Math.max(r.from, e), Math.min(r.to, t)));
    }
    return i;
  }
}
class tu {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: i } = t.p;
    GD(this.data, e, t, this.id, i.data, i.tokenPrecTable);
  }
}
tu.prototype.contextual = tu.prototype.fallback = tu.prototype.extend = !1;
class GO {
  constructor(e, t, i) {
    this.precTable = t, this.elseToken = i, this.data = typeof e == "string" ? Xh(e) : e;
  }
  token(e, t) {
    let i = e.pos, r = 0;
    for (; ; ) {
      let s = e.next < 0, o = e.resolveOffset(1, 1);
      if (GD(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || r++, o == null)
        break;
      e.reset(o, e.token);
    }
    r && (e.reset(i, e.token), e.acceptToken(this.elseToken, r));
  }
}
GO.prototype.contextual = tu.prototype.fallback = tu.prototype.extend = !1;
class qf {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function GD(n, e, t, i, r, s) {
  let o = 0, a = 1 << i, { dialect: l } = t.p.parser;
  e:
    for (; a & n[o]; ) {
      let c = n[o + 1];
      for (let f = o + 3; f < c; f += 2)
        if ((n[f + 1] & a) > 0) {
          let p = n[f];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || Lfe(p, e.token.value, r, s))) {
            e.acceptToken(p);
            break;
          }
        }
      let u = e.next, h = 0, d = n[o + 2];
      if (e.next < 0 && d > h && n[c + d * 3 - 3] == 65535) {
        o = n[c + d * 3 - 1];
        continue e;
      }
      for (; h < d; ) {
        let f = h + d >> 1, p = c + f + (f << 1), g = n[p], m = n[p + 1] || 65536;
        if (u < g)
          d = f;
        else if (u >= m)
          h = f + 1;
        else {
          o = n[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function ZP(n, e, t) {
  for (let i = e, r; (r = n[i]) != 65535; i++)
    if (r == t)
      return i - e;
  return -1;
}
function Lfe(n, e, t, i) {
  let r = ZP(t, i, e);
  return r < 0 || ZP(t, i, n) < r;
}
const gr = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let db = null;
function qP(n, e, t) {
  let i = n.cursor(Xn.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(n.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : n.length;
      }
}
class Ife {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? qP(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? qP(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], r = this.index[t];
      if (r == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = i.children[r], o = this.start[t] + i.positions[r];
      if (o > e)
        return this.nextStart = o, null;
      if (s instanceof Ln) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let a = o + s.length;
          if (a <= this.safeTo) {
            let l = s.prop(mt.lookAhead);
            if (!l || a + l < this.fragment.to)
              return s;
          }
        }
        this.index[t]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + s.length;
    }
  }
}
class Bfe {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new Tg());
  }
  getActions(e) {
    let t = 0, i = null, { parser: r } = e.p, { tokenizers: s } = r, o = r.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < s.length; c++) {
      if (!(1 << c & o))
        continue;
      let u = s[c], h = this.tokens[c];
      if (!(i && !u.fallback) && ((u.contextual || h.start != e.pos || h.mask != o || h.context != a) && (this.updateCachedToken(h, u, e), h.mask = o, h.context = a), h.lookAhead > h.end + 25 && (l = Math.max(h.lookAhead, l)), h.value != 0)) {
        let d = t;
        if (h.extended > -1 && (t = this.addActions(e, h.extended, h.end, t)), t = this.addActions(e, h.value, h.end, t), !u.extend && (i = h, t > d))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !i && e.pos == this.stream.end && (i = new Tg(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new Tg(), { pos: i, p: r } = e;
    return t.start = i, t.end = Math.min(i + 1, r.stream.end), t.value = i == r.stream.end ? r.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    let r = this.stream.clipPos(i.pos);
    if (t.token(this.stream.reset(r, e), i), e.value > -1) {
      let { parser: s } = i.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let a = s.specializers[o](this.stream.read(e.start, e.end), i);
          if (a >= 0 && i.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(r + 1);
  }
  putAction(e, t, i, r) {
    for (let s = 0; s < r; s += 3)
      if (this.actions[s] == e)
        return r;
    return this.actions[r++] = e, this.actions[r++] = t, this.actions[r++] = i, r;
  }
  addActions(e, t, i, r) {
    let { state: s } = e, { parser: o } = e.p, { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(
        s,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = $o(a, c + 2);
          else {
            r == 0 && a[c + 1] == 2 && (r = this.putAction($o(a, c + 2), t, i, r));
            break;
          }
        a[c] == t && (r = this.putAction($o(a, c + 1), t, i, r));
      }
    return r;
  }
}
class Qfe {
  constructor(e, t, i, r) {
    this.parser = e, this.input = t, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new Dfe(t, r), this.tokens = new Bfe(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = r[0];
    this.stacks = [Rfe.start(this, e.top[0], s)], this.fragments = i.length && this.stream.end - s > e.bufferLength * 4 ? new Ife(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], r, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > t)
          i.push(a);
        else {
          if (this.advanceStack(a, i, e))
            continue;
          {
            r || (r = [], s = []), r.push(a);
            let l = this.tokens.getMainToken(a);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = r && Vfe(r);
      if (o)
        return gr && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw gr && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && r) {
      let o = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, s, i);
      if (o)
        return gr && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((a, l) => l.score - a.score); i.length > o; )
          i.pop();
      i.some((a) => a.reducePos > t) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let o = 0; o < i.length - 1; o++) {
          let a = i[o];
          for (let l = o + 1; l < i.length; l++) {
            let c = i[l];
            if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
              if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
                i.splice(l--, 1);
              else {
                i.splice(o--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let r = e.pos, { parser: s } = this, o = gr ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && r > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, u = c ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(r); h; ) {
        let d = this.parser.nodeSet.types[h.type.id] == h.type ? s.getGoto(e.state, h.type.id) : -1;
        if (d > -1 && h.length && (!c || (h.prop(mt.contextHash) || 0) == u))
          return e.useNode(h, d), gr && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(h.type.id)})`), !0;
        if (!(h instanceof Ln) || h.children.length == 0 || h.positions[0] > 0)
          break;
        let f = h.children[0];
        if (f instanceof Ln && h.positions[0] == 0)
          h = f;
        else
          break;
      }
    }
    let a = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), gr && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let u = l[c++], h = l[c++], d = l[c++], f = c == l.length || !i, p = f ? e : e.split(), g = this.tokens.mainToken;
      if (p.apply(u, h, g ? g.start : p.pos, d), gr && console.log(o + this.stackID(p) + ` (via ${u & 65536 ? `reduce of ${s.getName(
        u & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(h)} @ ${r}${p == e ? "" : ", split"})`), f)
        return !0;
      p.pos > r ? t.push(p) : i.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return WP(e, t), !0;
    }
  }
  runRecovery(e, t, i) {
    let r = null, s = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = t[o << 1], c = t[(o << 1) + 1], u = gr ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (s || (s = !0, a.restart(), gr && console.log(u + this.stackID(a) + " (restarted)"), this.advanceFully(a, i))))
        continue;
      let h = a.split(), d = u;
      for (let f = 0; h.forceReduce() && f < 10 && (gr && console.log(d + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, i)); f++)
        gr && (d = this.stackID(h) + " -> ");
      for (let f of a.recoverByInsert(l))
        gr && console.log(u + this.stackID(f) + " (via recover-insert)"), this.advanceFully(f, i);
      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), gr && console.log(u + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), WP(a, i)) : (!r || r.score < a.score) && (r = a);
    }
    return r;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Ln.build({
      buffer: jm.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (db || (db = /* @__PURE__ */ new WeakMap())).get(e);
    return t || db.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function WP(n, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == n.pos && i.sameState(n)) {
      e[t].score < n.score && (e[t] = n);
      return;
    }
  }
  e.push(n);
}
class zfe {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const fb = (n) => n;
class jfe {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || fb, this.reduce = e.reduce || fb, this.reuse = e.reuse || fb, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Yu extends EN {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      t.push("");
    let i = Object.keys(e.topRules).map((a) => e.topRules[a][1]), r = [];
    for (let a = 0; a < t.length; a++)
      r.push([]);
    function s(a, l, c) {
      r[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = mt[l]);
        for (let c = 1; c < a.length; ) {
          let u = a[c++];
          if (u >= 0)
            s(u, l, a[c++]);
          else {
            let h = a[c + -u];
            for (let d = -u; d > 0; d--)
              s(a[c++], l, h);
            c++;
          }
        }
      }
    this.nodeSet = new mx(t.map((a, l) => hr.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: r[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = SN;
    let o = Xh(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(HP), this.states = Xh(e.states, Uint32Array), this.data = Xh(e.stateData), this.goto = Xh(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new tu(o, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let r = new Qfe(this, e, t, i);
    for (let s of this.wrappers)
      r = s(r, e, t, i);
    return r;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, i = !1) {
    let r = this.goto;
    if (t >= r[0])
      return -1;
    for (let s = r[t + 1]; ; ) {
      let o = r[s++], a = o & 1, l = r[s++];
      if (a && i)
        return l;
      for (let c = s + (o >> 1); s < c; s++)
        if (r[s] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let i = this.data;
    for (let r = 0; r < 2; r++)
      for (let s = this.stateSlot(
        e,
        r ? 2 : 1
        /* ParseState.Actions */
      ), o; ; s += 3) {
        if ((o = i[s]) == 65535)
          if (i[s + 1] == 1)
            o = i[s = $o(i, s + 2)];
          else {
            if (i[s + 1] == 2)
              return $o(i, s + 2);
            break;
          }
        if (o == t || o == 0)
          return $o(i, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (i) => i == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), r = i ? t(i) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); r == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = $o(this.data, s + 2);
        else
          break;
      r = t($o(this.data, s + 1));
    }
    return r;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = $o(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let r = this.data[i + 1];
        t.some((s, o) => o & 1 && s == r) || t.push(this.data[i], r);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(Yu.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let r = e.tokenizers.find((s) => s.from == i);
      return r ? r.to : i;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((i, r) => {
      let s = e.specializers.find((a) => a.from == i.external);
      if (!s)
        return i;
      let o = Object.assign(Object.assign({}, i), { external: s.to });
      return t.specializers[r] = HP(o), o;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = t.indexOf(s);
        o >= 0 && (i[o] = !0);
      }
    let r = null;
    for (let s = 0; s < t.length; s++)
      if (!i[s])
        for (let o = this.dialects[t[s]], a; (a = this.data[o++]) != 65535; )
          (r || (r = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new zfe(e, i, r);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Yu(e);
  }
}
function $o(n, e) {
  return n[e] | n[e + 1] << 16;
}
function Vfe(n) {
  let e = null;
  for (let t of n) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function HP(n) {
  if (n.external) {
    let e = n.extend ? 1 : 0;
    return (t, i) => n.external(t, i) << 1 | e;
  }
  return n.get;
}
const Ffe = 309, XP = 1, Zfe = 2, qfe = 3, Wfe = 310, Hfe = 312, Xfe = 313, Yfe = 4, Ufe = 5, Gfe = 0, KO = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], KD = 125, Kfe = 59, JO = 47, Jfe = 42, epe = 43, tpe = 45, npe = 60, ipe = 44, rpe = new jfe({
  start: !1,
  shift(n, e) {
    return e == Yfe || e == Ufe || e == Hfe ? n : e == Xfe;
  },
  strict: !1
}), spe = new qf((n, e) => {
  let { next: t } = n;
  (t == KD || t == -1 || e.context) && n.acceptToken(Wfe);
}, { contextual: !0, fallback: !0 }), ope = new qf((n, e) => {
  let { next: t } = n, i;
  KO.indexOf(t) > -1 || t == JO && ((i = n.peek(1)) == JO || i == Jfe) || t != KD && t != Kfe && t != -1 && !e.context && n.acceptToken(Ffe);
}, { contextual: !0 }), ape = new qf((n, e) => {
  let { next: t } = n;
  if ((t == epe || t == tpe) && (n.advance(), t == n.next)) {
    n.advance();
    let i = !e.context && e.canShift(XP);
    n.acceptToken(i ? XP : Zfe);
  }
}, { contextual: !0 });
function pb(n, e) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n == 95 || n >= 192 || !e && n >= 48 && n <= 57;
}
const lpe = new qf((n, e) => {
  if (n.next != npe || !e.dialectEnabled(Gfe) || (n.advance(), n.next == JO))
    return;
  let t = 0;
  for (; KO.indexOf(n.next) > -1; )
    n.advance(), t++;
  if (pb(n.next, !0)) {
    for (n.advance(), t++; pb(n.next, !1); )
      n.advance(), t++;
    for (; KO.indexOf(n.next) > -1; )
      n.advance(), t++;
    if (n.next == ipe)
      return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!pb(n.next, !0))
          return;
        break;
      }
      if (n.next != "extends".charCodeAt(i))
        break;
      n.advance(), t++;
    }
  }
  n.acceptToken(qfe, -t);
}), cpe = zv({
  "get set async static": X.modifier,
  "for while do if else switch try catch finally return throw break continue default case": X.controlKeyword,
  "in of await yield void typeof delete instanceof": X.operatorKeyword,
  "let var const using function class extends": X.definitionKeyword,
  "import export from": X.moduleKeyword,
  "with debugger as new": X.keyword,
  TemplateString: X.special(X.string),
  super: X.atom,
  BooleanLiteral: X.bool,
  this: X.self,
  null: X.null,
  Star: X.modifier,
  VariableName: X.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": X.function(X.variableName),
  VariableDefinition: X.definition(X.variableName),
  Label: X.labelName,
  PropertyName: X.propertyName,
  PrivatePropertyName: X.special(X.propertyName),
  "CallExpression/MemberExpression/PropertyName": X.function(X.propertyName),
  "FunctionDeclaration/VariableDefinition": X.function(X.definition(X.variableName)),
  "ClassDeclaration/VariableDefinition": X.definition(X.className),
  PropertyDefinition: X.definition(X.propertyName),
  PrivatePropertyDefinition: X.definition(X.special(X.propertyName)),
  UpdateOp: X.updateOperator,
  "LineComment Hashbang": X.lineComment,
  BlockComment: X.blockComment,
  Number: X.number,
  String: X.string,
  Escape: X.escape,
  ArithOp: X.arithmeticOperator,
  LogicOp: X.logicOperator,
  BitOp: X.bitwiseOperator,
  CompareOp: X.compareOperator,
  RegExp: X.regexp,
  Equals: X.definitionOperator,
  Arrow: X.function(X.punctuation),
  ": Spread": X.punctuation,
  "( )": X.paren,
  "[ ]": X.squareBracket,
  "{ }": X.brace,
  "InterpolationStart InterpolationEnd": X.special(X.brace),
  ".": X.derefOperator,
  ", ;": X.separator,
  "@": X.meta,
  TypeName: X.typeName,
  TypeDefinition: X.definition(X.typeName),
  "type enum interface implements namespace module declare": X.definitionKeyword,
  "abstract global Privacy readonly override": X.modifier,
  "is keyof unique infer": X.operatorKeyword,
  JSXAttributeValue: X.attributeValue,
  JSXText: X.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": X.angleBracket,
  "JSXIdentifier JSXNameSpacedName": X.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": X.attributeName,
  "JSXBuiltin/JSXIdentifier": X.standard(X.tagName)
}), upe = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, hpe = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, dpe = { __proto__: null, "<": 143 }, fpe = Yu.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "⚠ ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: rpe,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [cpe],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [ope, ape, lpe, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, spe, new GO("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new GO("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14614 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (n) => upe[n] || -1 }, { term: 334, get: (n) => hpe[n] || -1 }, { term: 70, get: (n) => dpe[n] || -1 }],
  tokenPrec: 14638
}), JD = [
  /* @__PURE__ */ tr("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ tr("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ tr("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ tr("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ tr("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ tr(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ tr("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ tr(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ tr(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ tr('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ tr('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], ppe = /* @__PURE__ */ JD.concat([
  /* @__PURE__ */ tr("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ tr("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ tr("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), YP = /* @__PURE__ */ new Fce(), e4 = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Lh(n) {
  return (e, t) => {
    let i = e.node.getChild("VariableDefinition");
    return i && t(i, n), !0;
  };
}
const gpe = ["FunctionDeclaration"], mpe = {
  FunctionDeclaration: /* @__PURE__ */ Lh("function"),
  ClassDeclaration: /* @__PURE__ */ Lh("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Lh("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Lh("type"),
  NamespaceDeclaration: /* @__PURE__ */ Lh("namespace"),
  VariableDefinition(n, e) {
    n.matchContext(gpe) || e(n, "variable");
  },
  TypeDefinition(n, e) {
    e(n, "type");
  },
  __proto__: null
};
function t4(n, e) {
  let t = YP.get(e);
  if (t)
    return t;
  let i = [], r = !0;
  function s(o, a) {
    let l = n.sliceString(o.from, o.to);
    i.push({ label: l, type: a });
  }
  return e.cursor(Xn.IncludeAnonymous).iterate((o) => {
    if (r)
      r = !1;
    else if (o.name) {
      let a = mpe[o.name];
      if (a && a(o, s) || e4.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let a of t4(n, o.node))
        i.push(a);
      return !1;
    }
  }), YP.set(e, i), i;
}
const UP = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, n4 = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function vpe(n) {
  let e = zn(n.state).resolveInner(n.pos, -1);
  if (n4.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && UP.test(n.state.sliceDoc(e.from, e.to));
  if (!t && !n.explicit)
    return null;
  let i = [];
  for (let r = e; r; r = r.parent)
    e4.has(r.name) && (i = i.concat(t4(n.state.doc, r)));
  return {
    options: i,
    from: t ? e.from : n.pos,
    validFor: UP
  };
}
const Vl = /* @__PURE__ */ qu.define({
  name: "javascript",
  parser: /* @__PURE__ */ fpe.configure({
    props: [
      /* @__PURE__ */ Fv.add({
        IfStatement: /* @__PURE__ */ Kc({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Kc({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: cue,
        SwitchBody: (n) => {
          let e = n.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return n.baseIndent + (t ? 0 : i ? 1 : 2) * n.unit;
        },
        Block: /* @__PURE__ */ lue({ closing: "}" }),
        ArrowFunction: (n) => n.baseIndent + n.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Kc({ except: /^{/ }),
        JSXElement(n) {
          let e = /^\s*<\//.test(n.textAfter);
          return n.lineIndent(n.node.from) + (e ? 0 : n.unit);
        },
        JSXEscape(n) {
          let e = /\s*\}/.test(n.textAfter);
          return n.lineIndent(n.node.from) + (e ? 0 : n.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        }
      }),
      /* @__PURE__ */ Zv.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": NN,
        BlockComment(n) {
          return { from: n.from + 2, to: n.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), i4 = {
  test: (n) => /^JSX/.test(n.name),
  facet: /* @__PURE__ */ TN({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, bpe = /* @__PURE__ */ Vl.configure({ dialect: "ts" }, "typescript"), ype = /* @__PURE__ */ Vl.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Ox.add((n) => n.isTop ? [i4] : void 0)]
}), Ope = /* @__PURE__ */ Vl.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Ox.add((n) => n.isTop ? [i4] : void 0)]
}, "typescript");
let r4 = (n) => ({ label: n, type: "keyword" });
const s4 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(r4), wpe = /* @__PURE__ */ s4.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(r4));
function pJe(n = {}) {
  let e = n.jsx ? n.typescript ? Ope : ype : n.typescript ? bpe : Vl, t = n.typescript ? ppe.concat(wpe) : JD.concat(s4);
  return new wx(e, [
    Vl.data.of({
      autocomplete: RD(n4, Mx(t))
    }),
    Vl.data.of({
      autocomplete: vpe
    }),
    n.jsx ? Cpe : []
  ]);
}
function xpe(n) {
  for (; ; ) {
    if (n.name == "JSXOpenTag" || n.name == "JSXSelfClosingTag" || n.name == "JSXFragmentTag")
      return n;
    if (n.name == "JSXEscape" || !n.parent)
      return null;
    n = n.parent;
  }
}
function GP(n, e, t = n.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return n.sliceString(i.from, Math.min(i.to, t));
  return "";
}
const Spe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Cpe = /* @__PURE__ */ _e.inputHandler.of((n, e, t, i, r) => {
  if ((Spe ? n.composing : n.compositionStarted) || n.state.readOnly || e != t || i != ">" && i != "/" || !Vl.isActiveAt(n.state, e, -1))
    return !1;
  let s = r(), { state: o } = s, a = o.changeByRange((l) => {
    var c;
    let { head: u } = l, h = zn(o).resolveInner(u - 1, -1), d;
    if (h.name == "JSXStartTag" && (h = h.parent), !(o.doc.sliceString(u - 1, u) != i || h.name == "JSXAttributeValue" && h.to > u)) {
      if (i == ">" && h.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (i == "/" && h.name == "JSXStartCloseTag") {
        let f = h.parent, p = f.parent;
        if (p && f.from == u - 2 && ((d = GP(o.doc, p.firstChild, u)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let g = `${d}>`;
          return { range: ue.cursor(u + g.length, -1), changes: { from: u, insert: g } };
        }
      } else if (i == ">") {
        let f = xpe(h);
        if (f && f.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(u, u + 2)) && (d = GP(o.doc, f, u)))
          return { range: l, changes: { from: u, insert: `</${d}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (n.dispatch([
    s,
    o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
/*! medium-zoom 1.1.0 | MIT License | https://github.com/francoischalifour/medium-zoom */
var fl = Object.assign || function(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e];
    for (var i in t)
      Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
  }
  return n;
}, Vp = function(e) {
  return e.tagName === "IMG";
}, kpe = function(e) {
  return NodeList.prototype.isPrototypeOf(e);
}, _g = function(e) {
  return e && e.nodeType === 1;
}, KP = function(e) {
  var t = e.currentSrc || e.src;
  return t.substr(-4).toLowerCase() === ".svg";
}, JP = function(e) {
  try {
    return Array.isArray(e) ? e.filter(Vp) : kpe(e) ? [].slice.call(e).filter(Vp) : _g(e) ? [e].filter(Vp) : typeof e == "string" ? [].slice.call(document.querySelectorAll(e)).filter(Vp) : [];
  } catch {
    throw new TypeError(`The provided selector is invalid.
Expects a CSS selector, a Node element, a NodeList or an array.
See: https://github.com/francoischalifour/medium-zoom`);
  }
}, Ppe = function(e) {
  var t = document.createElement("div");
  return t.classList.add("medium-zoom-overlay"), t.style.background = e, t;
}, Epe = function(e) {
  var t = e.getBoundingClientRect(), i = t.top, r = t.left, s = t.width, o = t.height, a = e.cloneNode(), l = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, c = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
  return a.removeAttribute("id"), a.style.position = "absolute", a.style.top = i + l + "px", a.style.left = r + c + "px", a.style.width = s + "px", a.style.height = o + "px", a.style.transform = "", a;
}, Pc = function(e, t) {
  var i = fl({
    bubbles: !1,
    cancelable: !1,
    detail: void 0
  }, t);
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(e, i);
  var r = document.createEvent("CustomEvent");
  return r.initCustomEvent(e, i.bubbles, i.cancelable, i.detail), r;
}, Ape = function n(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = window.Promise || function(T) {
    function B() {
    }
    T(B, B);
  }, r = function(T) {
    var B = T.target;
    if (B === E) {
      p();
      return;
    }
    b.indexOf(B) !== -1 && g({ target: B });
  }, s = function() {
    if (!(x || !k.original)) {
      var T = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      Math.abs(S - T) > C.scrollOffset && setTimeout(p, 150);
    }
  }, o = function(T) {
    var B = T.key || T.keyCode;
    (B === "Escape" || B === "Esc" || B === 27) && p();
  }, a = function() {
    var T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, B = T;
    if (T.background && (E.style.background = T.background), T.container && T.container instanceof Object && (B.container = fl({}, C.container, T.container)), T.template) {
      var I = _g(T.template) ? T.template : document.querySelector(T.template);
      B.template = I;
    }
    return C = fl({}, C, B), b.forEach(function(P) {
      P.dispatchEvent(Pc("medium-zoom:update", {
        detail: { zoom: M }
      }));
    }), M;
  }, l = function() {
    var T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return n(fl({}, C, T));
  }, c = function() {
    for (var T = arguments.length, B = Array(T), I = 0; I < T; I++)
      B[I] = arguments[I];
    var P = B.reduce(function(A, N) {
      return [].concat(A, JP(N));
    }, []);
    return P.filter(function(A) {
      return b.indexOf(A) === -1;
    }).forEach(function(A) {
      b.push(A), A.classList.add("medium-zoom-image");
    }), w.forEach(function(A) {
      var N = A.type, q = A.listener, j = A.options;
      P.forEach(function(H) {
        H.addEventListener(N, q, j);
      });
    }), M;
  }, u = function() {
    for (var T = arguments.length, B = Array(T), I = 0; I < T; I++)
      B[I] = arguments[I];
    k.zoomed && p();
    var P = B.length > 0 ? B.reduce(function(A, N) {
      return [].concat(A, JP(N));
    }, []) : b;
    return P.forEach(function(A) {
      A.classList.remove("medium-zoom-image"), A.dispatchEvent(Pc("medium-zoom:detach", {
        detail: { zoom: M }
      }));
    }), b = b.filter(function(A) {
      return P.indexOf(A) === -1;
    }), M;
  }, h = function(T, B) {
    var I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return b.forEach(function(P) {
      P.addEventListener("medium-zoom:" + T, B, I);
    }), w.push({ type: "medium-zoom:" + T, listener: B, options: I }), M;
  }, d = function(T, B) {
    var I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return b.forEach(function(P) {
      P.removeEventListener("medium-zoom:" + T, B, I);
    }), w = w.filter(function(P) {
      return !(P.type === "medium-zoom:" + T && P.listener.toString() === B.toString());
    }), M;
  }, f = function() {
    var T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, B = T.target, I = function() {
      var A = {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }, N = void 0, q = void 0;
      if (C.container)
        if (C.container instanceof Object)
          A = fl({}, A, C.container), N = A.width - A.left - A.right - C.margin * 2, q = A.height - A.top - A.bottom - C.margin * 2;
        else {
          var j = _g(C.container) ? C.container : document.querySelector(C.container), H = j.getBoundingClientRect(), oe = H.width, te = H.height, W = H.left, U = H.top;
          A = fl({}, A, {
            width: oe,
            height: te,
            left: W,
            top: U
          });
        }
      N = N || A.width - C.margin * 2, q = q || A.height - C.margin * 2;
      var ae = k.zoomedHd || k.original, he = KP(ae) ? N : ae.naturalWidth || N, ee = KP(ae) ? q : ae.naturalHeight || q, pe = ae.getBoundingClientRect(), be = pe.top, fe = pe.left, Ae = pe.width, ut = pe.height, zt = Math.min(Math.max(Ae, he), N) / Ae, Jn = Math.min(Math.max(ut, ee), q) / ut, ei = Math.min(zt, Jn), Li = (-fe + (N - Ae) / 2 + C.margin + A.left) / ei, di = (-be + (q - ut) / 2 + C.margin + A.top) / ei, Ii = "scale(" + ei + ") translate3d(" + Li + "px, " + di + "px, 0)";
      k.zoomed.style.transform = Ii, k.zoomedHd && (k.zoomedHd.style.transform = Ii);
    };
    return new i(function(P) {
      if (B && b.indexOf(B) === -1) {
        P(M);
        return;
      }
      var A = function oe() {
        x = !1, k.zoomed.removeEventListener("transitionend", oe), k.original.dispatchEvent(Pc("medium-zoom:opened", {
          detail: { zoom: M }
        })), P(M);
      };
      if (k.zoomed) {
        P(M);
        return;
      }
      if (B)
        k.original = B;
      else if (b.length > 0) {
        var N = b;
        k.original = N[0];
      } else {
        P(M);
        return;
      }
      if (k.original.dispatchEvent(Pc("medium-zoom:open", {
        detail: { zoom: M }
      })), S = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, x = !0, k.zoomed = Epe(k.original), document.body.appendChild(E), C.template) {
        var q = _g(C.template) ? C.template : document.querySelector(C.template);
        k.template = document.createElement("div"), k.template.appendChild(q.content.cloneNode(!0)), document.body.appendChild(k.template);
      }
      if (k.original.parentElement && k.original.parentElement.tagName === "PICTURE" && k.original.currentSrc && (k.zoomed.src = k.original.currentSrc), document.body.appendChild(k.zoomed), window.requestAnimationFrame(function() {
        document.body.classList.add("medium-zoom--opened");
      }), k.original.classList.add("medium-zoom-image--hidden"), k.zoomed.classList.add("medium-zoom-image--opened"), k.zoomed.addEventListener("click", p), k.zoomed.addEventListener("transitionend", A), k.original.getAttribute("data-zoom-src")) {
        k.zoomedHd = k.zoomed.cloneNode(), k.zoomedHd.removeAttribute("srcset"), k.zoomedHd.removeAttribute("sizes"), k.zoomedHd.removeAttribute("loading"), k.zoomedHd.src = k.zoomed.getAttribute("data-zoom-src"), k.zoomedHd.onerror = function() {
          clearInterval(j), console.warn("Unable to reach the zoom image target " + k.zoomedHd.src), k.zoomedHd = null, I();
        };
        var j = setInterval(function() {
          k.zoomedHd.complete && (clearInterval(j), k.zoomedHd.classList.add("medium-zoom-image--opened"), k.zoomedHd.addEventListener("click", p), document.body.appendChild(k.zoomedHd), I());
        }, 10);
      } else if (k.original.hasAttribute("srcset")) {
        k.zoomedHd = k.zoomed.cloneNode(), k.zoomedHd.removeAttribute("sizes"), k.zoomedHd.removeAttribute("loading");
        var H = k.zoomedHd.addEventListener("load", function() {
          k.zoomedHd.removeEventListener("load", H), k.zoomedHd.classList.add("medium-zoom-image--opened"), k.zoomedHd.addEventListener("click", p), document.body.appendChild(k.zoomedHd), I();
        });
      } else
        I();
    });
  }, p = function() {
    return new i(function(T) {
      if (x || !k.original) {
        T(M);
        return;
      }
      var B = function I() {
        k.original.classList.remove("medium-zoom-image--hidden"), document.body.removeChild(k.zoomed), k.zoomedHd && document.body.removeChild(k.zoomedHd), document.body.removeChild(E), k.zoomed.classList.remove("medium-zoom-image--opened"), k.template && document.body.removeChild(k.template), x = !1, k.zoomed.removeEventListener("transitionend", I), k.original.dispatchEvent(Pc("medium-zoom:closed", {
          detail: { zoom: M }
        })), k.original = null, k.zoomed = null, k.zoomedHd = null, k.template = null, T(M);
      };
      x = !0, document.body.classList.remove("medium-zoom--opened"), k.zoomed.style.transform = "", k.zoomedHd && (k.zoomedHd.style.transform = ""), k.template && (k.template.style.transition = "opacity 150ms", k.template.style.opacity = 0), k.original.dispatchEvent(Pc("medium-zoom:close", {
        detail: { zoom: M }
      })), k.zoomed.addEventListener("transitionend", B);
    });
  }, g = function() {
    var T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, B = T.target;
    return k.original ? p() : f({ target: B });
  }, m = function() {
    return C;
  }, v = function() {
    return b;
  }, y = function() {
    return k.original;
  }, b = [], w = [], x = !1, S = 0, C = t, k = {
    original: null,
    zoomed: null,
    zoomedHd: null,
    template: null
    // If the selector is omitted, it's replaced by the options
  };
  Object.prototype.toString.call(e) === "[object Object]" ? C = e : (e || typeof e == "string") && c(e), C = fl({
    margin: 0,
    background: "#fff",
    scrollOffset: 40,
    container: null,
    template: null
  }, C);
  var E = Ppe(C.background);
  document.addEventListener("click", r), document.addEventListener("keyup", o), document.addEventListener("scroll", s), window.addEventListener("resize", p);
  var M = {
    open: f,
    close: p,
    toggle: g,
    update: a,
    clone: l,
    attach: c,
    detach: u,
    on: h,
    off: d,
    getOptions: m,
    getImages: v,
    getZoomedImage: y
  };
  return M;
};
function $pe(n, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(!n || typeof document > "u")) {
    var i = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style");
    r.type = "text/css", t === "top" && i.firstChild ? i.insertBefore(r, i.firstChild) : i.appendChild(r), r.styleSheet ? r.styleSheet.cssText = n : r.appendChild(document.createTextNode(n));
  }
}
var Tpe = ".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";
$pe(Tpe);
const _pe = Ape;
var Mpe = function() {
  var n = document.getSelection();
  if (!n.rangeCount)
    return function() {
    };
  for (var e = document.activeElement, t = [], i = 0; i < n.rangeCount; i++)
    t.push(n.getRangeAt(i));
  switch (e.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      e.blur();
      break;
    default:
      e = null;
      break;
  }
  return n.removeAllRanges(), function() {
    n.type === "Caret" && n.removeAllRanges(), n.rangeCount || t.forEach(function(r) {
      n.addRange(r);
    }), e && e.focus();
  };
}, Rpe = Mpe, eE = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, Npe = "Copy to clipboard: #{key}, Enter";
function Dpe(n) {
  var e = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return n.replace(/#{\s*key\s*}/g, e);
}
function Lpe(n, e) {
  var t, i, r, s, o, a, l = !1;
  e || (e = {}), t = e.debug || !1;
  try {
    r = Rpe(), s = document.createRange(), o = document.getSelection(), a = document.createElement("span"), a.textContent = n, a.ariaHidden = "true", a.style.all = "unset", a.style.position = "fixed", a.style.top = 0, a.style.clip = "rect(0, 0, 0, 0)", a.style.whiteSpace = "pre", a.style.webkitUserSelect = "text", a.style.MozUserSelect = "text", a.style.msUserSelect = "text", a.style.userSelect = "text", a.addEventListener("copy", function(u) {
      if (u.stopPropagation(), e.format)
        if (u.preventDefault(), typeof u.clipboardData > "u") {
          t && console.warn("unable to use e.clipboardData"), t && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var h = eE[e.format] || eE.default;
          window.clipboardData.setData(h, n);
        } else
          u.clipboardData.clearData(), u.clipboardData.setData(e.format, n);
      e.onCopy && (u.preventDefault(), e.onCopy(u.clipboardData));
    }), document.body.appendChild(a), s.selectNodeContents(a), o.addRange(s);
    var c = document.execCommand("copy");
    if (!c)
      throw new Error("copy command was unsuccessful");
    l = !0;
  } catch (u) {
    t && console.error("unable to copy using execCommand: ", u), t && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(e.format || "text", n), e.onCopy && e.onCopy(window.clipboardData), l = !0;
    } catch (h) {
      t && console.error("unable to copy using clipboardData: ", h), t && console.error("falling back to prompt"), i = Dpe("message" in e ? e.message : Npe), window.prompt(i, n);
    }
  } finally {
    o && (typeof o.removeRange == "function" ? o.removeRange(s) : o.removeAllRanges()), a && document.body.removeChild(a), r();
  }
  return l;
}
var Ipe = Lpe;
const Bpe = /* @__PURE__ */ Mf(Ipe);
var Nt = {};
const Qpe = "Á", zpe = "á", jpe = "Ă", Vpe = "ă", Fpe = "∾", Zpe = "∿", qpe = "∾̳", Wpe = "Â", Hpe = "â", Xpe = "´", Ype = "А", Upe = "а", Gpe = "Æ", Kpe = "æ", Jpe = "⁡", ege = "𝔄", tge = "𝔞", nge = "À", ige = "à", rge = "ℵ", sge = "ℵ", oge = "Α", age = "α", lge = "Ā", cge = "ā", uge = "⨿", hge = "&", dge = "&", fge = "⩕", pge = "⩓", gge = "∧", mge = "⩜", vge = "⩘", bge = "⩚", yge = "∠", Oge = "⦤", wge = "∠", xge = "⦨", Sge = "⦩", Cge = "⦪", kge = "⦫", Pge = "⦬", Ege = "⦭", Age = "⦮", $ge = "⦯", Tge = "∡", _ge = "∟", Mge = "⊾", Rge = "⦝", Nge = "∢", Dge = "Å", Lge = "⍼", Ige = "Ą", Bge = "ą", Qge = "𝔸", zge = "𝕒", jge = "⩯", Vge = "≈", Fge = "⩰", Zge = "≊", qge = "≋", Wge = "'", Hge = "⁡", Xge = "≈", Yge = "≊", Uge = "Å", Gge = "å", Kge = "𝒜", Jge = "𝒶", eme = "≔", tme = "*", nme = "≈", ime = "≍", rme = "Ã", sme = "ã", ome = "Ä", ame = "ä", lme = "∳", cme = "⨑", ume = "≌", hme = "϶", dme = "‵", fme = "∽", pme = "⋍", gme = "∖", mme = "⫧", vme = "⊽", bme = "⌅", yme = "⌆", Ome = "⌅", wme = "⎵", xme = "⎶", Sme = "≌", Cme = "Б", kme = "б", Pme = "„", Eme = "∵", Ame = "∵", $me = "∵", Tme = "⦰", _me = "϶", Mme = "ℬ", Rme = "ℬ", Nme = "Β", Dme = "β", Lme = "ℶ", Ime = "≬", Bme = "𝔅", Qme = "𝔟", zme = "⋂", jme = "◯", Vme = "⋃", Fme = "⨀", Zme = "⨁", qme = "⨂", Wme = "⨆", Hme = "★", Xme = "▽", Yme = "△", Ume = "⨄", Gme = "⋁", Kme = "⋀", Jme = "⤍", eve = "⧫", tve = "▪", nve = "▴", ive = "▾", rve = "◂", sve = "▸", ove = "␣", ave = "▒", lve = "░", cve = "▓", uve = "█", hve = "=⃥", dve = "≡⃥", fve = "⫭", pve = "⌐", gve = "𝔹", mve = "𝕓", vve = "⊥", bve = "⊥", yve = "⋈", Ove = "⧉", wve = "┐", xve = "╕", Sve = "╖", Cve = "╗", kve = "┌", Pve = "╒", Eve = "╓", Ave = "╔", $ve = "─", Tve = "═", _ve = "┬", Mve = "╤", Rve = "╥", Nve = "╦", Dve = "┴", Lve = "╧", Ive = "╨", Bve = "╩", Qve = "⊟", zve = "⊞", jve = "⊠", Vve = "┘", Fve = "╛", Zve = "╜", qve = "╝", Wve = "└", Hve = "╘", Xve = "╙", Yve = "╚", Uve = "│", Gve = "║", Kve = "┼", Jve = "╪", e0e = "╫", t0e = "╬", n0e = "┤", i0e = "╡", r0e = "╢", s0e = "╣", o0e = "├", a0e = "╞", l0e = "╟", c0e = "╠", u0e = "‵", h0e = "˘", d0e = "˘", f0e = "¦", p0e = "𝒷", g0e = "ℬ", m0e = "⁏", v0e = "∽", b0e = "⋍", y0e = "⧅", O0e = "\\", w0e = "⟈", x0e = "•", S0e = "•", C0e = "≎", k0e = "⪮", P0e = "≏", E0e = "≎", A0e = "≏", $0e = "Ć", T0e = "ć", _0e = "⩄", M0e = "⩉", R0e = "⩋", N0e = "∩", D0e = "⋒", L0e = "⩇", I0e = "⩀", B0e = "ⅅ", Q0e = "∩︀", z0e = "⁁", j0e = "ˇ", V0e = "ℭ", F0e = "⩍", Z0e = "Č", q0e = "č", W0e = "Ç", H0e = "ç", X0e = "Ĉ", Y0e = "ĉ", U0e = "∰", G0e = "⩌", K0e = "⩐", J0e = "Ċ", ebe = "ċ", tbe = "¸", nbe = "¸", ibe = "⦲", rbe = "¢", sbe = "·", obe = "·", abe = "𝔠", lbe = "ℭ", cbe = "Ч", ube = "ч", hbe = "✓", dbe = "✓", fbe = "Χ", pbe = "χ", gbe = "ˆ", mbe = "≗", vbe = "↺", bbe = "↻", ybe = "⊛", Obe = "⊚", wbe = "⊝", xbe = "⊙", Sbe = "®", Cbe = "Ⓢ", kbe = "⊖", Pbe = "⊕", Ebe = "⊗", Abe = "○", $be = "⧃", Tbe = "≗", _be = "⨐", Mbe = "⫯", Rbe = "⧂", Nbe = "∲", Dbe = "”", Lbe = "’", Ibe = "♣", Bbe = "♣", Qbe = ":", zbe = "∷", jbe = "⩴", Vbe = "≔", Fbe = "≔", Zbe = ",", qbe = "@", Wbe = "∁", Hbe = "∘", Xbe = "∁", Ybe = "ℂ", Ube = "≅", Gbe = "⩭", Kbe = "≡", Jbe = "∮", eye = "∯", tye = "∮", nye = "𝕔", iye = "ℂ", rye = "∐", sye = "∐", oye = "©", aye = "©", lye = "℗", cye = "∳", uye = "↵", hye = "✗", dye = "⨯", fye = "𝒞", pye = "𝒸", gye = "⫏", mye = "⫑", vye = "⫐", bye = "⫒", yye = "⋯", Oye = "⤸", wye = "⤵", xye = "⋞", Sye = "⋟", Cye = "↶", kye = "⤽", Pye = "⩈", Eye = "⩆", Aye = "≍", $ye = "∪", Tye = "⋓", _ye = "⩊", Mye = "⊍", Rye = "⩅", Nye = "∪︀", Dye = "↷", Lye = "⤼", Iye = "⋞", Bye = "⋟", Qye = "⋎", zye = "⋏", jye = "¤", Vye = "↶", Fye = "↷", Zye = "⋎", qye = "⋏", Wye = "∲", Hye = "∱", Xye = "⌭", Yye = "†", Uye = "‡", Gye = "ℸ", Kye = "↓", Jye = "↡", eOe = "⇓", tOe = "‐", nOe = "⫤", iOe = "⊣", rOe = "⤏", sOe = "˝", oOe = "Ď", aOe = "ď", lOe = "Д", cOe = "д", uOe = "‡", hOe = "⇊", dOe = "ⅅ", fOe = "ⅆ", pOe = "⤑", gOe = "⩷", mOe = "°", vOe = "∇", bOe = "Δ", yOe = "δ", OOe = "⦱", wOe = "⥿", xOe = "𝔇", SOe = "𝔡", COe = "⥥", kOe = "⇃", POe = "⇂", EOe = "´", AOe = "˙", $Oe = "˝", TOe = "`", _Oe = "˜", MOe = "⋄", ROe = "⋄", NOe = "⋄", DOe = "♦", LOe = "♦", IOe = "¨", BOe = "ⅆ", QOe = "ϝ", zOe = "⋲", jOe = "÷", VOe = "÷", FOe = "⋇", ZOe = "⋇", qOe = "Ђ", WOe = "ђ", HOe = "⌞", XOe = "⌍", YOe = "$", UOe = "𝔻", GOe = "𝕕", KOe = "¨", JOe = "˙", e1e = "⃜", t1e = "≐", n1e = "≑", i1e = "≐", r1e = "∸", s1e = "∔", o1e = "⊡", a1e = "⌆", l1e = "∯", c1e = "¨", u1e = "⇓", h1e = "⇐", d1e = "⇔", f1e = "⫤", p1e = "⟸", g1e = "⟺", m1e = "⟹", v1e = "⇒", b1e = "⊨", y1e = "⇑", O1e = "⇕", w1e = "∥", x1e = "⤓", S1e = "↓", C1e = "↓", k1e = "⇓", P1e = "⇵", E1e = "̑", A1e = "⇊", $1e = "⇃", T1e = "⇂", _1e = "⥐", M1e = "⥞", R1e = "⥖", N1e = "↽", D1e = "⥟", L1e = "⥗", I1e = "⇁", B1e = "↧", Q1e = "⊤", z1e = "⤐", j1e = "⌟", V1e = "⌌", F1e = "𝒟", Z1e = "𝒹", q1e = "Ѕ", W1e = "ѕ", H1e = "⧶", X1e = "Đ", Y1e = "đ", U1e = "⋱", G1e = "▿", K1e = "▾", J1e = "⇵", ewe = "⥯", twe = "⦦", nwe = "Џ", iwe = "џ", rwe = "⟿", swe = "É", owe = "é", awe = "⩮", lwe = "Ě", cwe = "ě", uwe = "Ê", hwe = "ê", dwe = "≖", fwe = "≕", pwe = "Э", gwe = "э", mwe = "⩷", vwe = "Ė", bwe = "ė", ywe = "≑", Owe = "ⅇ", wwe = "≒", xwe = "𝔈", Swe = "𝔢", Cwe = "⪚", kwe = "È", Pwe = "è", Ewe = "⪖", Awe = "⪘", $we = "⪙", Twe = "∈", _we = "⏧", Mwe = "ℓ", Rwe = "⪕", Nwe = "⪗", Dwe = "Ē", Lwe = "ē", Iwe = "∅", Bwe = "∅", Qwe = "◻", zwe = "∅", jwe = "▫", Vwe = " ", Fwe = " ", Zwe = " ", qwe = "Ŋ", Wwe = "ŋ", Hwe = " ", Xwe = "Ę", Ywe = "ę", Uwe = "𝔼", Gwe = "𝕖", Kwe = "⋕", Jwe = "⧣", exe = "⩱", txe = "ε", nxe = "Ε", ixe = "ε", rxe = "ϵ", sxe = "≖", oxe = "≕", axe = "≂", lxe = "⪖", cxe = "⪕", uxe = "⩵", hxe = "=", dxe = "≂", fxe = "≟", pxe = "⇌", gxe = "≡", mxe = "⩸", vxe = "⧥", bxe = "⥱", yxe = "≓", Oxe = "ℯ", wxe = "ℰ", xxe = "≐", Sxe = "⩳", Cxe = "≂", kxe = "Η", Pxe = "η", Exe = "Ð", Axe = "ð", $xe = "Ë", Txe = "ë", _xe = "€", Mxe = "!", Rxe = "∃", Nxe = "∃", Dxe = "ℰ", Lxe = "ⅇ", Ixe = "ⅇ", Bxe = "≒", Qxe = "Ф", zxe = "ф", jxe = "♀", Vxe = "ﬃ", Fxe = "ﬀ", Zxe = "ﬄ", qxe = "𝔉", Wxe = "𝔣", Hxe = "ﬁ", Xxe = "◼", Yxe = "▪", Uxe = "fj", Gxe = "♭", Kxe = "ﬂ", Jxe = "▱", eSe = "ƒ", tSe = "𝔽", nSe = "𝕗", iSe = "∀", rSe = "∀", sSe = "⋔", oSe = "⫙", aSe = "ℱ", lSe = "⨍", cSe = "½", uSe = "⅓", hSe = "¼", dSe = "⅕", fSe = "⅙", pSe = "⅛", gSe = "⅔", mSe = "⅖", vSe = "¾", bSe = "⅗", ySe = "⅜", OSe = "⅘", wSe = "⅚", xSe = "⅝", SSe = "⅞", CSe = "⁄", kSe = "⌢", PSe = "𝒻", ESe = "ℱ", ASe = "ǵ", $Se = "Γ", TSe = "γ", _Se = "Ϝ", MSe = "ϝ", RSe = "⪆", NSe = "Ğ", DSe = "ğ", LSe = "Ģ", ISe = "Ĝ", BSe = "ĝ", QSe = "Г", zSe = "г", jSe = "Ġ", VSe = "ġ", FSe = "≥", ZSe = "≧", qSe = "⪌", WSe = "⋛", HSe = "≥", XSe = "≧", YSe = "⩾", USe = "⪩", GSe = "⩾", KSe = "⪀", JSe = "⪂", eCe = "⪄", tCe = "⋛︀", nCe = "⪔", iCe = "𝔊", rCe = "𝔤", sCe = "≫", oCe = "⋙", aCe = "⋙", lCe = "ℷ", cCe = "Ѓ", uCe = "ѓ", hCe = "⪥", dCe = "≷", fCe = "⪒", pCe = "⪤", gCe = "⪊", mCe = "⪊", vCe = "⪈", bCe = "≩", yCe = "⪈", OCe = "≩", wCe = "⋧", xCe = "𝔾", SCe = "𝕘", CCe = "`", kCe = "≥", PCe = "⋛", ECe = "≧", ACe = "⪢", $Ce = "≷", TCe = "⩾", _Ce = "≳", MCe = "𝒢", RCe = "ℊ", NCe = "≳", DCe = "⪎", LCe = "⪐", ICe = "⪧", BCe = "⩺", QCe = ">", zCe = ">", jCe = "≫", VCe = "⋗", FCe = "⦕", ZCe = "⩼", qCe = "⪆", WCe = "⥸", HCe = "⋗", XCe = "⋛", YCe = "⪌", UCe = "≷", GCe = "≳", KCe = "≩︀", JCe = "≩︀", eke = "ˇ", tke = " ", nke = "½", ike = "ℋ", rke = "Ъ", ske = "ъ", oke = "⥈", ake = "↔", lke = "⇔", cke = "↭", uke = "^", hke = "ℏ", dke = "Ĥ", fke = "ĥ", pke = "♥", gke = "♥", mke = "…", vke = "⊹", bke = "𝔥", yke = "ℌ", Oke = "ℋ", wke = "⤥", xke = "⤦", Ske = "⇿", Cke = "∻", kke = "↩", Pke = "↪", Eke = "𝕙", Ake = "ℍ", $ke = "―", Tke = "─", _ke = "𝒽", Mke = "ℋ", Rke = "ℏ", Nke = "Ħ", Dke = "ħ", Lke = "≎", Ike = "≏", Bke = "⁃", Qke = "‐", zke = "Í", jke = "í", Vke = "⁣", Fke = "Î", Zke = "î", qke = "И", Wke = "и", Hke = "İ", Xke = "Е", Yke = "е", Uke = "¡", Gke = "⇔", Kke = "𝔦", Jke = "ℑ", e2e = "Ì", t2e = "ì", n2e = "ⅈ", i2e = "⨌", r2e = "∭", s2e = "⧜", o2e = "℩", a2e = "Ĳ", l2e = "ĳ", c2e = "Ī", u2e = "ī", h2e = "ℑ", d2e = "ⅈ", f2e = "ℐ", p2e = "ℑ", g2e = "ı", m2e = "ℑ", v2e = "⊷", b2e = "Ƶ", y2e = "⇒", O2e = "℅", w2e = "∞", x2e = "⧝", S2e = "ı", C2e = "⊺", k2e = "∫", P2e = "∬", E2e = "ℤ", A2e = "∫", $2e = "⊺", T2e = "⋂", _2e = "⨗", M2e = "⨼", R2e = "⁣", N2e = "⁢", D2e = "Ё", L2e = "ё", I2e = "Į", B2e = "į", Q2e = "𝕀", z2e = "𝕚", j2e = "Ι", V2e = "ι", F2e = "⨼", Z2e = "¿", q2e = "𝒾", W2e = "ℐ", H2e = "∈", X2e = "⋵", Y2e = "⋹", U2e = "⋴", G2e = "⋳", K2e = "∈", J2e = "⁢", ePe = "Ĩ", tPe = "ĩ", nPe = "І", iPe = "і", rPe = "Ï", sPe = "ï", oPe = "Ĵ", aPe = "ĵ", lPe = "Й", cPe = "й", uPe = "𝔍", hPe = "𝔧", dPe = "ȷ", fPe = "𝕁", pPe = "𝕛", gPe = "𝒥", mPe = "𝒿", vPe = "Ј", bPe = "ј", yPe = "Є", OPe = "є", wPe = "Κ", xPe = "κ", SPe = "ϰ", CPe = "Ķ", kPe = "ķ", PPe = "К", EPe = "к", APe = "𝔎", $Pe = "𝔨", TPe = "ĸ", _Pe = "Х", MPe = "х", RPe = "Ќ", NPe = "ќ", DPe = "𝕂", LPe = "𝕜", IPe = "𝒦", BPe = "𝓀", QPe = "⇚", zPe = "Ĺ", jPe = "ĺ", VPe = "⦴", FPe = "ℒ", ZPe = "Λ", qPe = "λ", WPe = "⟨", HPe = "⟪", XPe = "⦑", YPe = "⟨", UPe = "⪅", GPe = "ℒ", KPe = "«", JPe = "⇤", eEe = "⤟", tEe = "←", nEe = "↞", iEe = "⇐", rEe = "⤝", sEe = "↩", oEe = "↫", aEe = "⤹", lEe = "⥳", cEe = "↢", uEe = "⤙", hEe = "⤛", dEe = "⪫", fEe = "⪭", pEe = "⪭︀", gEe = "⤌", mEe = "⤎", vEe = "❲", bEe = "{", yEe = "[", OEe = "⦋", wEe = "⦏", xEe = "⦍", SEe = "Ľ", CEe = "ľ", kEe = "Ļ", PEe = "ļ", EEe = "⌈", AEe = "{", $Ee = "Л", TEe = "л", _Ee = "⤶", MEe = "“", REe = "„", NEe = "⥧", DEe = "⥋", LEe = "↲", IEe = "≤", BEe = "≦", QEe = "⟨", zEe = "⇤", jEe = "←", VEe = "←", FEe = "⇐", ZEe = "⇆", qEe = "↢", WEe = "⌈", HEe = "⟦", XEe = "⥡", YEe = "⥙", UEe = "⇃", GEe = "⌊", KEe = "↽", JEe = "↼", eAe = "⇇", tAe = "↔", nAe = "↔", iAe = "⇔", rAe = "⇆", sAe = "⇋", oAe = "↭", aAe = "⥎", lAe = "↤", cAe = "⊣", uAe = "⥚", hAe = "⋋", dAe = "⧏", fAe = "⊲", pAe = "⊴", gAe = "⥑", mAe = "⥠", vAe = "⥘", bAe = "↿", yAe = "⥒", OAe = "↼", wAe = "⪋", xAe = "⋚", SAe = "≤", CAe = "≦", kAe = "⩽", PAe = "⪨", EAe = "⩽", AAe = "⩿", $Ae = "⪁", TAe = "⪃", _Ae = "⋚︀", MAe = "⪓", RAe = "⪅", NAe = "⋖", DAe = "⋚", LAe = "⪋", IAe = "⋚", BAe = "≦", QAe = "≶", zAe = "≶", jAe = "⪡", VAe = "≲", FAe = "⩽", ZAe = "≲", qAe = "⥼", WAe = "⌊", HAe = "𝔏", XAe = "𝔩", YAe = "≶", UAe = "⪑", GAe = "⥢", KAe = "↽", JAe = "↼", e$e = "⥪", t$e = "▄", n$e = "Љ", i$e = "љ", r$e = "⇇", s$e = "≪", o$e = "⋘", a$e = "⌞", l$e = "⇚", c$e = "⥫", u$e = "◺", h$e = "Ŀ", d$e = "ŀ", f$e = "⎰", p$e = "⎰", g$e = "⪉", m$e = "⪉", v$e = "⪇", b$e = "≨", y$e = "⪇", O$e = "≨", w$e = "⋦", x$e = "⟬", S$e = "⇽", C$e = "⟦", k$e = "⟵", P$e = "⟵", E$e = "⟸", A$e = "⟷", $$e = "⟷", T$e = "⟺", _$e = "⟼", M$e = "⟶", R$e = "⟶", N$e = "⟹", D$e = "↫", L$e = "↬", I$e = "⦅", B$e = "𝕃", Q$e = "𝕝", z$e = "⨭", j$e = "⨴", V$e = "∗", F$e = "_", Z$e = "↙", q$e = "↘", W$e = "◊", H$e = "◊", X$e = "⧫", Y$e = "(", U$e = "⦓", G$e = "⇆", K$e = "⌟", J$e = "⇋", eTe = "⥭", tTe = "‎", nTe = "⊿", iTe = "‹", rTe = "𝓁", sTe = "ℒ", oTe = "↰", aTe = "↰", lTe = "≲", cTe = "⪍", uTe = "⪏", hTe = "[", dTe = "‘", fTe = "‚", pTe = "Ł", gTe = "ł", mTe = "⪦", vTe = "⩹", bTe = "<", yTe = "<", OTe = "≪", wTe = "⋖", xTe = "⋋", STe = "⋉", CTe = "⥶", kTe = "⩻", PTe = "◃", ETe = "⊴", ATe = "◂", $Te = "⦖", TTe = "⥊", _Te = "⥦", MTe = "≨︀", RTe = "≨︀", NTe = "¯", DTe = "♂", LTe = "✠", ITe = "✠", BTe = "↦", QTe = "↦", zTe = "↧", jTe = "↤", VTe = "↥", FTe = "▮", ZTe = "⨩", qTe = "М", WTe = "м", HTe = "—", XTe = "∺", YTe = "∡", UTe = " ", GTe = "ℳ", KTe = "𝔐", JTe = "𝔪", e_e = "℧", t_e = "µ", n_e = "*", i_e = "⫰", r_e = "∣", s_e = "·", o_e = "⊟", a_e = "−", l_e = "∸", c_e = "⨪", u_e = "∓", h_e = "⫛", d_e = "…", f_e = "∓", p_e = "⊧", g_e = "𝕄", m_e = "𝕞", v_e = "∓", b_e = "𝓂", y_e = "ℳ", O_e = "∾", w_e = "Μ", x_e = "μ", S_e = "⊸", C_e = "⊸", k_e = "∇", P_e = "Ń", E_e = "ń", A_e = "∠⃒", $_e = "≉", T_e = "⩰̸", __e = "≋̸", M_e = "ŉ", R_e = "≉", N_e = "♮", D_e = "ℕ", L_e = "♮", I_e = " ", B_e = "≎̸", Q_e = "≏̸", z_e = "⩃", j_e = "Ň", V_e = "ň", F_e = "Ņ", Z_e = "ņ", q_e = "≇", W_e = "⩭̸", H_e = "⩂", X_e = "Н", Y_e = "н", U_e = "–", G_e = "⤤", K_e = "↗", J_e = "⇗", eMe = "↗", tMe = "≠", nMe = "≐̸", iMe = "​", rMe = "​", sMe = "​", oMe = "​", aMe = "≢", lMe = "⤨", cMe = "≂̸", uMe = "≫", hMe = "≪", dMe = `
`, fMe = "∄", pMe = "∄", gMe = "𝔑", mMe = "𝔫", vMe = "≧̸", bMe = "≱", yMe = "≱", OMe = "≧̸", wMe = "⩾̸", xMe = "⩾̸", SMe = "⋙̸", CMe = "≵", kMe = "≫⃒", PMe = "≯", EMe = "≯", AMe = "≫̸", $Me = "↮", TMe = "⇎", _Me = "⫲", MMe = "∋", RMe = "⋼", NMe = "⋺", DMe = "∋", LMe = "Њ", IMe = "њ", BMe = "↚", QMe = "⇍", zMe = "‥", jMe = "≦̸", VMe = "≰", FMe = "↚", ZMe = "⇍", qMe = "↮", WMe = "⇎", HMe = "≰", XMe = "≦̸", YMe = "⩽̸", UMe = "⩽̸", GMe = "≮", KMe = "⋘̸", JMe = "≴", eRe = "≪⃒", tRe = "≮", nRe = "⋪", iRe = "⋬", rRe = "≪̸", sRe = "∤", oRe = "⁠", aRe = " ", lRe = "𝕟", cRe = "ℕ", uRe = "⫬", hRe = "¬", dRe = "≢", fRe = "≭", pRe = "∦", gRe = "∉", mRe = "≠", vRe = "≂̸", bRe = "∄", yRe = "≯", ORe = "≱", wRe = "≧̸", xRe = "≫̸", SRe = "≹", CRe = "⩾̸", kRe = "≵", PRe = "≎̸", ERe = "≏̸", ARe = "∉", $Re = "⋵̸", TRe = "⋹̸", _Re = "∉", MRe = "⋷", RRe = "⋶", NRe = "⧏̸", DRe = "⋪", LRe = "⋬", IRe = "≮", BRe = "≰", QRe = "≸", zRe = "≪̸", jRe = "⩽̸", VRe = "≴", FRe = "⪢̸", ZRe = "⪡̸", qRe = "∌", WRe = "∌", HRe = "⋾", XRe = "⋽", YRe = "⊀", URe = "⪯̸", GRe = "⋠", KRe = "∌", JRe = "⧐̸", e3e = "⋫", t3e = "⋭", n3e = "⊏̸", i3e = "⋢", r3e = "⊐̸", s3e = "⋣", o3e = "⊂⃒", a3e = "⊈", l3e = "⊁", c3e = "⪰̸", u3e = "⋡", h3e = "≿̸", d3e = "⊃⃒", f3e = "⊉", p3e = "≁", g3e = "≄", m3e = "≇", v3e = "≉", b3e = "∤", y3e = "∦", O3e = "∦", w3e = "⫽⃥", x3e = "∂̸", S3e = "⨔", C3e = "⊀", k3e = "⋠", P3e = "⊀", E3e = "⪯̸", A3e = "⪯̸", $3e = "⤳̸", T3e = "↛", _3e = "⇏", M3e = "↝̸", R3e = "↛", N3e = "⇏", D3e = "⋫", L3e = "⋭", I3e = "⊁", B3e = "⋡", Q3e = "⪰̸", z3e = "𝒩", j3e = "𝓃", V3e = "∤", F3e = "∦", Z3e = "≁", q3e = "≄", W3e = "≄", H3e = "∤", X3e = "∦", Y3e = "⋢", U3e = "⋣", G3e = "⊄", K3e = "⫅̸", J3e = "⊈", eNe = "⊂⃒", tNe = "⊈", nNe = "⫅̸", iNe = "⊁", rNe = "⪰̸", sNe = "⊅", oNe = "⫆̸", aNe = "⊉", lNe = "⊃⃒", cNe = "⊉", uNe = "⫆̸", hNe = "≹", dNe = "Ñ", fNe = "ñ", pNe = "≸", gNe = "⋪", mNe = "⋬", vNe = "⋫", bNe = "⋭", yNe = "Ν", ONe = "ν", wNe = "#", xNe = "№", SNe = " ", CNe = "≍⃒", kNe = "⊬", PNe = "⊭", ENe = "⊮", ANe = "⊯", $Ne = "≥⃒", TNe = ">⃒", _Ne = "⤄", MNe = "⧞", RNe = "⤂", NNe = "≤⃒", DNe = "<⃒", LNe = "⊴⃒", INe = "⤃", BNe = "⊵⃒", QNe = "∼⃒", zNe = "⤣", jNe = "↖", VNe = "⇖", FNe = "↖", ZNe = "⤧", qNe = "Ó", WNe = "ó", HNe = "⊛", XNe = "Ô", YNe = "ô", UNe = "⊚", GNe = "О", KNe = "о", JNe = "⊝", eDe = "Ő", tDe = "ő", nDe = "⨸", iDe = "⊙", rDe = "⦼", sDe = "Œ", oDe = "œ", aDe = "⦿", lDe = "𝔒", cDe = "𝔬", uDe = "˛", hDe = "Ò", dDe = "ò", fDe = "⧁", pDe = "⦵", gDe = "Ω", mDe = "∮", vDe = "↺", bDe = "⦾", yDe = "⦻", ODe = "‾", wDe = "⧀", xDe = "Ō", SDe = "ō", CDe = "Ω", kDe = "ω", PDe = "Ο", EDe = "ο", ADe = "⦶", $De = "⊖", TDe = "𝕆", _De = "𝕠", MDe = "⦷", RDe = "“", NDe = "‘", DDe = "⦹", LDe = "⊕", IDe = "↻", BDe = "⩔", QDe = "∨", zDe = "⩝", jDe = "ℴ", VDe = "ℴ", FDe = "ª", ZDe = "º", qDe = "⊶", WDe = "⩖", HDe = "⩗", XDe = "⩛", YDe = "Ⓢ", UDe = "𝒪", GDe = "ℴ", KDe = "Ø", JDe = "ø", e4e = "⊘", t4e = "Õ", n4e = "õ", i4e = "⨶", r4e = "⨷", s4e = "⊗", o4e = "Ö", a4e = "ö", l4e = "⌽", c4e = "‾", u4e = "⏞", h4e = "⎴", d4e = "⏜", f4e = "¶", p4e = "∥", g4e = "∥", m4e = "⫳", v4e = "⫽", b4e = "∂", y4e = "∂", O4e = "П", w4e = "п", x4e = "%", S4e = ".", C4e = "‰", k4e = "⊥", P4e = "‱", E4e = "𝔓", A4e = "𝔭", $4e = "Φ", T4e = "φ", _4e = "ϕ", M4e = "ℳ", R4e = "☎", N4e = "Π", D4e = "π", L4e = "⋔", I4e = "ϖ", B4e = "ℏ", Q4e = "ℎ", z4e = "ℏ", j4e = "⨣", V4e = "⊞", F4e = "⨢", Z4e = "+", q4e = "∔", W4e = "⨥", H4e = "⩲", X4e = "±", Y4e = "±", U4e = "⨦", G4e = "⨧", K4e = "±", J4e = "ℌ", eLe = "⨕", tLe = "𝕡", nLe = "ℙ", iLe = "£", rLe = "⪷", sLe = "⪻", oLe = "≺", aLe = "≼", lLe = "⪷", cLe = "≺", uLe = "≼", hLe = "≺", dLe = "⪯", fLe = "≼", pLe = "≾", gLe = "⪯", mLe = "⪹", vLe = "⪵", bLe = "⋨", yLe = "⪯", OLe = "⪳", wLe = "≾", xLe = "′", SLe = "″", CLe = "ℙ", kLe = "⪹", PLe = "⪵", ELe = "⋨", ALe = "∏", $Le = "∏", TLe = "⌮", _Le = "⌒", MLe = "⌓", RLe = "∝", NLe = "∝", DLe = "∷", LLe = "∝", ILe = "≾", BLe = "⊰", QLe = "𝒫", zLe = "𝓅", jLe = "Ψ", VLe = "ψ", FLe = " ", ZLe = "𝔔", qLe = "𝔮", WLe = "⨌", HLe = "𝕢", XLe = "ℚ", YLe = "⁗", ULe = "𝒬", GLe = "𝓆", KLe = "ℍ", JLe = "⨖", eIe = "?", tIe = "≟", nIe = '"', iIe = '"', rIe = "⇛", sIe = "∽̱", oIe = "Ŕ", aIe = "ŕ", lIe = "√", cIe = "⦳", uIe = "⟩", hIe = "⟫", dIe = "⦒", fIe = "⦥", pIe = "⟩", gIe = "»", mIe = "⥵", vIe = "⇥", bIe = "⤠", yIe = "⤳", OIe = "→", wIe = "↠", xIe = "⇒", SIe = "⤞", CIe = "↪", kIe = "↬", PIe = "⥅", EIe = "⥴", AIe = "⤖", $Ie = "↣", TIe = "↝", _Ie = "⤚", MIe = "⤜", RIe = "∶", NIe = "ℚ", DIe = "⤍", LIe = "⤏", IIe = "⤐", BIe = "❳", QIe = "}", zIe = "]", jIe = "⦌", VIe = "⦎", FIe = "⦐", ZIe = "Ř", qIe = "ř", WIe = "Ŗ", HIe = "ŗ", XIe = "⌉", YIe = "}", UIe = "Р", GIe = "р", KIe = "⤷", JIe = "⥩", e5e = "”", t5e = "”", n5e = "↳", i5e = "ℜ", r5e = "ℛ", s5e = "ℜ", o5e = "ℝ", a5e = "ℜ", l5e = "▭", c5e = "®", u5e = "®", h5e = "∋", d5e = "⇋", f5e = "⥯", p5e = "⥽", g5e = "⌋", m5e = "𝔯", v5e = "ℜ", b5e = "⥤", y5e = "⇁", O5e = "⇀", w5e = "⥬", x5e = "Ρ", S5e = "ρ", C5e = "ϱ", k5e = "⟩", P5e = "⇥", E5e = "→", A5e = "→", $5e = "⇒", T5e = "⇄", _5e = "↣", M5e = "⌉", R5e = "⟧", N5e = "⥝", D5e = "⥕", L5e = "⇂", I5e = "⌋", B5e = "⇁", Q5e = "⇀", z5e = "⇄", j5e = "⇌", V5e = "⇉", F5e = "↝", Z5e = "↦", q5e = "⊢", W5e = "⥛", H5e = "⋌", X5e = "⧐", Y5e = "⊳", U5e = "⊵", G5e = "⥏", K5e = "⥜", J5e = "⥔", e8e = "↾", t8e = "⥓", n8e = "⇀", i8e = "˚", r8e = "≓", s8e = "⇄", o8e = "⇌", a8e = "‏", l8e = "⎱", c8e = "⎱", u8e = "⫮", h8e = "⟭", d8e = "⇾", f8e = "⟧", p8e = "⦆", g8e = "𝕣", m8e = "ℝ", v8e = "⨮", b8e = "⨵", y8e = "⥰", O8e = ")", w8e = "⦔", x8e = "⨒", S8e = "⇉", C8e = "⇛", k8e = "›", P8e = "𝓇", E8e = "ℛ", A8e = "↱", $8e = "↱", T8e = "]", _8e = "’", M8e = "’", R8e = "⋌", N8e = "⋊", D8e = "▹", L8e = "⊵", I8e = "▸", B8e = "⧎", Q8e = "⧴", z8e = "⥨", j8e = "℞", V8e = "Ś", F8e = "ś", Z8e = "‚", q8e = "⪸", W8e = "Š", H8e = "š", X8e = "⪼", Y8e = "≻", U8e = "≽", G8e = "⪰", K8e = "⪴", J8e = "Ş", e6e = "ş", t6e = "Ŝ", n6e = "ŝ", i6e = "⪺", r6e = "⪶", s6e = "⋩", o6e = "⨓", a6e = "≿", l6e = "С", c6e = "с", u6e = "⊡", h6e = "⋅", d6e = "⩦", f6e = "⤥", p6e = "↘", g6e = "⇘", m6e = "↘", v6e = "§", b6e = ";", y6e = "⤩", O6e = "∖", w6e = "∖", x6e = "✶", S6e = "𝔖", C6e = "𝔰", k6e = "⌢", P6e = "♯", E6e = "Щ", A6e = "щ", $6e = "Ш", T6e = "ш", _6e = "↓", M6e = "←", R6e = "∣", N6e = "∥", D6e = "→", L6e = "↑", I6e = "­", B6e = "Σ", Q6e = "σ", z6e = "ς", j6e = "ς", V6e = "∼", F6e = "⩪", Z6e = "≃", q6e = "≃", W6e = "⪞", H6e = "⪠", X6e = "⪝", Y6e = "⪟", U6e = "≆", G6e = "⨤", K6e = "⥲", J6e = "←", eBe = "∘", tBe = "∖", nBe = "⨳", iBe = "⧤", rBe = "∣", sBe = "⌣", oBe = "⪪", aBe = "⪬", lBe = "⪬︀", cBe = "Ь", uBe = "ь", hBe = "⌿", dBe = "⧄", fBe = "/", pBe = "𝕊", gBe = "𝕤", mBe = "♠", vBe = "♠", bBe = "∥", yBe = "⊓", OBe = "⊓︀", wBe = "⊔", xBe = "⊔︀", SBe = "√", CBe = "⊏", kBe = "⊑", PBe = "⊏", EBe = "⊑", ABe = "⊐", $Be = "⊒", TBe = "⊐", _Be = "⊒", MBe = "□", RBe = "□", NBe = "⊓", DBe = "⊏", LBe = "⊑", IBe = "⊐", BBe = "⊒", QBe = "⊔", zBe = "▪", jBe = "□", VBe = "▪", FBe = "→", ZBe = "𝒮", qBe = "𝓈", WBe = "∖", HBe = "⌣", XBe = "⋆", YBe = "⋆", UBe = "☆", GBe = "★", KBe = "ϵ", JBe = "ϕ", eQe = "¯", tQe = "⊂", nQe = "⋐", iQe = "⪽", rQe = "⫅", sQe = "⊆", oQe = "⫃", aQe = "⫁", lQe = "⫋", cQe = "⊊", uQe = "⪿", hQe = "⥹", dQe = "⊂", fQe = "⋐", pQe = "⊆", gQe = "⫅", mQe = "⊆", vQe = "⊊", bQe = "⫋", yQe = "⫇", OQe = "⫕", wQe = "⫓", xQe = "⪸", SQe = "≻", CQe = "≽", kQe = "≻", PQe = "⪰", EQe = "≽", AQe = "≿", $Qe = "⪰", TQe = "⪺", _Qe = "⪶", MQe = "⋩", RQe = "≿", NQe = "∋", DQe = "∑", LQe = "∑", IQe = "♪", BQe = "¹", QQe = "²", zQe = "³", jQe = "⊃", VQe = "⋑", FQe = "⪾", ZQe = "⫘", qQe = "⫆", WQe = "⊇", HQe = "⫄", XQe = "⊃", YQe = "⊇", UQe = "⟉", GQe = "⫗", KQe = "⥻", JQe = "⫂", eze = "⫌", tze = "⊋", nze = "⫀", ize = "⊃", rze = "⋑", sze = "⊇", oze = "⫆", aze = "⊋", lze = "⫌", cze = "⫈", uze = "⫔", hze = "⫖", dze = "⤦", fze = "↙", pze = "⇙", gze = "↙", mze = "⤪", vze = "ß", bze = "	", yze = "⌖", Oze = "Τ", wze = "τ", xze = "⎴", Sze = "Ť", Cze = "ť", kze = "Ţ", Pze = "ţ", Eze = "Т", Aze = "т", $ze = "⃛", Tze = "⌕", _ze = "𝔗", Mze = "𝔱", Rze = "∴", Nze = "∴", Dze = "∴", Lze = "Θ", Ize = "θ", Bze = "ϑ", Qze = "ϑ", zze = "≈", jze = "∼", Vze = "  ", Fze = " ", Zze = " ", qze = "≈", Wze = "∼", Hze = "Þ", Xze = "þ", Yze = "˜", Uze = "∼", Gze = "≃", Kze = "≅", Jze = "≈", eje = "⨱", tje = "⊠", nje = "×", ije = "⨰", rje = "∭", sje = "⤨", oje = "⌶", aje = "⫱", lje = "⊤", cje = "𝕋", uje = "𝕥", hje = "⫚", dje = "⤩", fje = "‴", pje = "™", gje = "™", mje = "▵", vje = "▿", bje = "◃", yje = "⊴", Oje = "≜", wje = "▹", xje = "⊵", Sje = "◬", Cje = "≜", kje = "⨺", Pje = "⃛", Eje = "⨹", Aje = "⧍", $je = "⨻", Tje = "⏢", _je = "𝒯", Mje = "𝓉", Rje = "Ц", Nje = "ц", Dje = "Ћ", Lje = "ћ", Ije = "Ŧ", Bje = "ŧ", Qje = "≬", zje = "↞", jje = "↠", Vje = "Ú", Fje = "ú", Zje = "↑", qje = "↟", Wje = "⇑", Hje = "⥉", Xje = "Ў", Yje = "ў", Uje = "Ŭ", Gje = "ŭ", Kje = "Û", Jje = "û", eVe = "У", tVe = "у", nVe = "⇅", iVe = "Ű", rVe = "ű", sVe = "⥮", oVe = "⥾", aVe = "𝔘", lVe = "𝔲", cVe = "Ù", uVe = "ù", hVe = "⥣", dVe = "↿", fVe = "↾", pVe = "▀", gVe = "⌜", mVe = "⌜", vVe = "⌏", bVe = "◸", yVe = "Ū", OVe = "ū", wVe = "¨", xVe = "_", SVe = "⏟", CVe = "⎵", kVe = "⏝", PVe = "⋃", EVe = "⊎", AVe = "Ų", $Ve = "ų", TVe = "𝕌", _Ve = "𝕦", MVe = "⤒", RVe = "↑", NVe = "↑", DVe = "⇑", LVe = "⇅", IVe = "↕", BVe = "↕", QVe = "⇕", zVe = "⥮", jVe = "↿", VVe = "↾", FVe = "⊎", ZVe = "↖", qVe = "↗", WVe = "υ", HVe = "ϒ", XVe = "ϒ", YVe = "Υ", UVe = "υ", GVe = "↥", KVe = "⊥", JVe = "⇈", eFe = "⌝", tFe = "⌝", nFe = "⌎", iFe = "Ů", rFe = "ů", sFe = "◹", oFe = "𝒰", aFe = "𝓊", lFe = "⋰", cFe = "Ũ", uFe = "ũ", hFe = "▵", dFe = "▴", fFe = "⇈", pFe = "Ü", gFe = "ü", mFe = "⦧", vFe = "⦜", bFe = "ϵ", yFe = "ϰ", OFe = "∅", wFe = "ϕ", xFe = "ϖ", SFe = "∝", CFe = "↕", kFe = "⇕", PFe = "ϱ", EFe = "ς", AFe = "⊊︀", $Fe = "⫋︀", TFe = "⊋︀", _Fe = "⫌︀", MFe = "ϑ", RFe = "⊲", NFe = "⊳", DFe = "⫨", LFe = "⫫", IFe = "⫩", BFe = "В", QFe = "в", zFe = "⊢", jFe = "⊨", VFe = "⊩", FFe = "⊫", ZFe = "⫦", qFe = "⊻", WFe = "∨", HFe = "⋁", XFe = "≚", YFe = "⋮", UFe = "|", GFe = "‖", KFe = "|", JFe = "‖", eZe = "∣", tZe = "|", nZe = "❘", iZe = "≀", rZe = " ", sZe = "𝔙", oZe = "𝔳", aZe = "⊲", lZe = "⊂⃒", cZe = "⊃⃒", uZe = "𝕍", hZe = "𝕧", dZe = "∝", fZe = "⊳", pZe = "𝒱", gZe = "𝓋", mZe = "⫋︀", vZe = "⊊︀", bZe = "⫌︀", yZe = "⊋︀", OZe = "⊪", wZe = "⦚", xZe = "Ŵ", SZe = "ŵ", CZe = "⩟", kZe = "∧", PZe = "⋀", EZe = "≙", AZe = "℘", $Ze = "𝔚", TZe = "𝔴", _Ze = "𝕎", MZe = "𝕨", RZe = "℘", NZe = "≀", DZe = "≀", LZe = "𝒲", IZe = "𝓌", BZe = "⋂", QZe = "◯", zZe = "⋃", jZe = "▽", VZe = "𝔛", FZe = "𝔵", ZZe = "⟷", qZe = "⟺", WZe = "Ξ", HZe = "ξ", XZe = "⟵", YZe = "⟸", UZe = "⟼", GZe = "⋻", KZe = "⨀", JZe = "𝕏", eqe = "𝕩", tqe = "⨁", nqe = "⨂", iqe = "⟶", rqe = "⟹", sqe = "𝒳", oqe = "𝓍", aqe = "⨆", lqe = "⨄", cqe = "△", uqe = "⋁", hqe = "⋀", dqe = "Ý", fqe = "ý", pqe = "Я", gqe = "я", mqe = "Ŷ", vqe = "ŷ", bqe = "Ы", yqe = "ы", Oqe = "¥", wqe = "𝔜", xqe = "𝔶", Sqe = "Ї", Cqe = "ї", kqe = "𝕐", Pqe = "𝕪", Eqe = "𝒴", Aqe = "𝓎", $qe = "Ю", Tqe = "ю", _qe = "ÿ", Mqe = "Ÿ", Rqe = "Ź", Nqe = "ź", Dqe = "Ž", Lqe = "ž", Iqe = "З", Bqe = "з", Qqe = "Ż", zqe = "ż", jqe = "ℨ", Vqe = "​", Fqe = "Ζ", Zqe = "ζ", qqe = "𝔷", Wqe = "ℨ", Hqe = "Ж", Xqe = "ж", Yqe = "⇝", Uqe = "𝕫", Gqe = "ℤ", Kqe = "𝒵", Jqe = "𝓏", e7e = "‍", t7e = "‌", n7e = {
  Aacute: Qpe,
  aacute: zpe,
  Abreve: jpe,
  abreve: Vpe,
  ac: Fpe,
  acd: Zpe,
  acE: qpe,
  Acirc: Wpe,
  acirc: Hpe,
  acute: Xpe,
  Acy: Ype,
  acy: Upe,
  AElig: Gpe,
  aelig: Kpe,
  af: Jpe,
  Afr: ege,
  afr: tge,
  Agrave: nge,
  agrave: ige,
  alefsym: rge,
  aleph: sge,
  Alpha: oge,
  alpha: age,
  Amacr: lge,
  amacr: cge,
  amalg: uge,
  amp: hge,
  AMP: dge,
  andand: fge,
  And: pge,
  and: gge,
  andd: mge,
  andslope: vge,
  andv: bge,
  ang: yge,
  ange: Oge,
  angle: wge,
  angmsdaa: xge,
  angmsdab: Sge,
  angmsdac: Cge,
  angmsdad: kge,
  angmsdae: Pge,
  angmsdaf: Ege,
  angmsdag: Age,
  angmsdah: $ge,
  angmsd: Tge,
  angrt: _ge,
  angrtvb: Mge,
  angrtvbd: Rge,
  angsph: Nge,
  angst: Dge,
  angzarr: Lge,
  Aogon: Ige,
  aogon: Bge,
  Aopf: Qge,
  aopf: zge,
  apacir: jge,
  ap: Vge,
  apE: Fge,
  ape: Zge,
  apid: qge,
  apos: Wge,
  ApplyFunction: Hge,
  approx: Xge,
  approxeq: Yge,
  Aring: Uge,
  aring: Gge,
  Ascr: Kge,
  ascr: Jge,
  Assign: eme,
  ast: tme,
  asymp: nme,
  asympeq: ime,
  Atilde: rme,
  atilde: sme,
  Auml: ome,
  auml: ame,
  awconint: lme,
  awint: cme,
  backcong: ume,
  backepsilon: hme,
  backprime: dme,
  backsim: fme,
  backsimeq: pme,
  Backslash: gme,
  Barv: mme,
  barvee: vme,
  barwed: bme,
  Barwed: yme,
  barwedge: Ome,
  bbrk: wme,
  bbrktbrk: xme,
  bcong: Sme,
  Bcy: Cme,
  bcy: kme,
  bdquo: Pme,
  becaus: Eme,
  because: Ame,
  Because: $me,
  bemptyv: Tme,
  bepsi: _me,
  bernou: Mme,
  Bernoullis: Rme,
  Beta: Nme,
  beta: Dme,
  beth: Lme,
  between: Ime,
  Bfr: Bme,
  bfr: Qme,
  bigcap: zme,
  bigcirc: jme,
  bigcup: Vme,
  bigodot: Fme,
  bigoplus: Zme,
  bigotimes: qme,
  bigsqcup: Wme,
  bigstar: Hme,
  bigtriangledown: Xme,
  bigtriangleup: Yme,
  biguplus: Ume,
  bigvee: Gme,
  bigwedge: Kme,
  bkarow: Jme,
  blacklozenge: eve,
  blacksquare: tve,
  blacktriangle: nve,
  blacktriangledown: ive,
  blacktriangleleft: rve,
  blacktriangleright: sve,
  blank: ove,
  blk12: ave,
  blk14: lve,
  blk34: cve,
  block: uve,
  bne: hve,
  bnequiv: dve,
  bNot: fve,
  bnot: pve,
  Bopf: gve,
  bopf: mve,
  bot: vve,
  bottom: bve,
  bowtie: yve,
  boxbox: Ove,
  boxdl: wve,
  boxdL: xve,
  boxDl: Sve,
  boxDL: Cve,
  boxdr: kve,
  boxdR: Pve,
  boxDr: Eve,
  boxDR: Ave,
  boxh: $ve,
  boxH: Tve,
  boxhd: _ve,
  boxHd: Mve,
  boxhD: Rve,
  boxHD: Nve,
  boxhu: Dve,
  boxHu: Lve,
  boxhU: Ive,
  boxHU: Bve,
  boxminus: Qve,
  boxplus: zve,
  boxtimes: jve,
  boxul: Vve,
  boxuL: Fve,
  boxUl: Zve,
  boxUL: qve,
  boxur: Wve,
  boxuR: Hve,
  boxUr: Xve,
  boxUR: Yve,
  boxv: Uve,
  boxV: Gve,
  boxvh: Kve,
  boxvH: Jve,
  boxVh: e0e,
  boxVH: t0e,
  boxvl: n0e,
  boxvL: i0e,
  boxVl: r0e,
  boxVL: s0e,
  boxvr: o0e,
  boxvR: a0e,
  boxVr: l0e,
  boxVR: c0e,
  bprime: u0e,
  breve: h0e,
  Breve: d0e,
  brvbar: f0e,
  bscr: p0e,
  Bscr: g0e,
  bsemi: m0e,
  bsim: v0e,
  bsime: b0e,
  bsolb: y0e,
  bsol: O0e,
  bsolhsub: w0e,
  bull: x0e,
  bullet: S0e,
  bump: C0e,
  bumpE: k0e,
  bumpe: P0e,
  Bumpeq: E0e,
  bumpeq: A0e,
  Cacute: $0e,
  cacute: T0e,
  capand: _0e,
  capbrcup: M0e,
  capcap: R0e,
  cap: N0e,
  Cap: D0e,
  capcup: L0e,
  capdot: I0e,
  CapitalDifferentialD: B0e,
  caps: Q0e,
  caret: z0e,
  caron: j0e,
  Cayleys: V0e,
  ccaps: F0e,
  Ccaron: Z0e,
  ccaron: q0e,
  Ccedil: W0e,
  ccedil: H0e,
  Ccirc: X0e,
  ccirc: Y0e,
  Cconint: U0e,
  ccups: G0e,
  ccupssm: K0e,
  Cdot: J0e,
  cdot: ebe,
  cedil: tbe,
  Cedilla: nbe,
  cemptyv: ibe,
  cent: rbe,
  centerdot: sbe,
  CenterDot: obe,
  cfr: abe,
  Cfr: lbe,
  CHcy: cbe,
  chcy: ube,
  check: hbe,
  checkmark: dbe,
  Chi: fbe,
  chi: pbe,
  circ: gbe,
  circeq: mbe,
  circlearrowleft: vbe,
  circlearrowright: bbe,
  circledast: ybe,
  circledcirc: Obe,
  circleddash: wbe,
  CircleDot: xbe,
  circledR: Sbe,
  circledS: Cbe,
  CircleMinus: kbe,
  CirclePlus: Pbe,
  CircleTimes: Ebe,
  cir: Abe,
  cirE: $be,
  cire: Tbe,
  cirfnint: _be,
  cirmid: Mbe,
  cirscir: Rbe,
  ClockwiseContourIntegral: Nbe,
  CloseCurlyDoubleQuote: Dbe,
  CloseCurlyQuote: Lbe,
  clubs: Ibe,
  clubsuit: Bbe,
  colon: Qbe,
  Colon: zbe,
  Colone: jbe,
  colone: Vbe,
  coloneq: Fbe,
  comma: Zbe,
  commat: qbe,
  comp: Wbe,
  compfn: Hbe,
  complement: Xbe,
  complexes: Ybe,
  cong: Ube,
  congdot: Gbe,
  Congruent: Kbe,
  conint: Jbe,
  Conint: eye,
  ContourIntegral: tye,
  copf: nye,
  Copf: iye,
  coprod: rye,
  Coproduct: sye,
  copy: oye,
  COPY: aye,
  copysr: lye,
  CounterClockwiseContourIntegral: cye,
  crarr: uye,
  cross: hye,
  Cross: dye,
  Cscr: fye,
  cscr: pye,
  csub: gye,
  csube: mye,
  csup: vye,
  csupe: bye,
  ctdot: yye,
  cudarrl: Oye,
  cudarrr: wye,
  cuepr: xye,
  cuesc: Sye,
  cularr: Cye,
  cularrp: kye,
  cupbrcap: Pye,
  cupcap: Eye,
  CupCap: Aye,
  cup: $ye,
  Cup: Tye,
  cupcup: _ye,
  cupdot: Mye,
  cupor: Rye,
  cups: Nye,
  curarr: Dye,
  curarrm: Lye,
  curlyeqprec: Iye,
  curlyeqsucc: Bye,
  curlyvee: Qye,
  curlywedge: zye,
  curren: jye,
  curvearrowleft: Vye,
  curvearrowright: Fye,
  cuvee: Zye,
  cuwed: qye,
  cwconint: Wye,
  cwint: Hye,
  cylcty: Xye,
  dagger: Yye,
  Dagger: Uye,
  daleth: Gye,
  darr: Kye,
  Darr: Jye,
  dArr: eOe,
  dash: tOe,
  Dashv: nOe,
  dashv: iOe,
  dbkarow: rOe,
  dblac: sOe,
  Dcaron: oOe,
  dcaron: aOe,
  Dcy: lOe,
  dcy: cOe,
  ddagger: uOe,
  ddarr: hOe,
  DD: dOe,
  dd: fOe,
  DDotrahd: pOe,
  ddotseq: gOe,
  deg: mOe,
  Del: vOe,
  Delta: bOe,
  delta: yOe,
  demptyv: OOe,
  dfisht: wOe,
  Dfr: xOe,
  dfr: SOe,
  dHar: COe,
  dharl: kOe,
  dharr: POe,
  DiacriticalAcute: EOe,
  DiacriticalDot: AOe,
  DiacriticalDoubleAcute: $Oe,
  DiacriticalGrave: TOe,
  DiacriticalTilde: _Oe,
  diam: MOe,
  diamond: ROe,
  Diamond: NOe,
  diamondsuit: DOe,
  diams: LOe,
  die: IOe,
  DifferentialD: BOe,
  digamma: QOe,
  disin: zOe,
  div: jOe,
  divide: VOe,
  divideontimes: FOe,
  divonx: ZOe,
  DJcy: qOe,
  djcy: WOe,
  dlcorn: HOe,
  dlcrop: XOe,
  dollar: YOe,
  Dopf: UOe,
  dopf: GOe,
  Dot: KOe,
  dot: JOe,
  DotDot: e1e,
  doteq: t1e,
  doteqdot: n1e,
  DotEqual: i1e,
  dotminus: r1e,
  dotplus: s1e,
  dotsquare: o1e,
  doublebarwedge: a1e,
  DoubleContourIntegral: l1e,
  DoubleDot: c1e,
  DoubleDownArrow: u1e,
  DoubleLeftArrow: h1e,
  DoubleLeftRightArrow: d1e,
  DoubleLeftTee: f1e,
  DoubleLongLeftArrow: p1e,
  DoubleLongLeftRightArrow: g1e,
  DoubleLongRightArrow: m1e,
  DoubleRightArrow: v1e,
  DoubleRightTee: b1e,
  DoubleUpArrow: y1e,
  DoubleUpDownArrow: O1e,
  DoubleVerticalBar: w1e,
  DownArrowBar: x1e,
  downarrow: S1e,
  DownArrow: C1e,
  Downarrow: k1e,
  DownArrowUpArrow: P1e,
  DownBreve: E1e,
  downdownarrows: A1e,
  downharpoonleft: $1e,
  downharpoonright: T1e,
  DownLeftRightVector: _1e,
  DownLeftTeeVector: M1e,
  DownLeftVectorBar: R1e,
  DownLeftVector: N1e,
  DownRightTeeVector: D1e,
  DownRightVectorBar: L1e,
  DownRightVector: I1e,
  DownTeeArrow: B1e,
  DownTee: Q1e,
  drbkarow: z1e,
  drcorn: j1e,
  drcrop: V1e,
  Dscr: F1e,
  dscr: Z1e,
  DScy: q1e,
  dscy: W1e,
  dsol: H1e,
  Dstrok: X1e,
  dstrok: Y1e,
  dtdot: U1e,
  dtri: G1e,
  dtrif: K1e,
  duarr: J1e,
  duhar: ewe,
  dwangle: twe,
  DZcy: nwe,
  dzcy: iwe,
  dzigrarr: rwe,
  Eacute: swe,
  eacute: owe,
  easter: awe,
  Ecaron: lwe,
  ecaron: cwe,
  Ecirc: uwe,
  ecirc: hwe,
  ecir: dwe,
  ecolon: fwe,
  Ecy: pwe,
  ecy: gwe,
  eDDot: mwe,
  Edot: vwe,
  edot: bwe,
  eDot: ywe,
  ee: Owe,
  efDot: wwe,
  Efr: xwe,
  efr: Swe,
  eg: Cwe,
  Egrave: kwe,
  egrave: Pwe,
  egs: Ewe,
  egsdot: Awe,
  el: $we,
  Element: Twe,
  elinters: _we,
  ell: Mwe,
  els: Rwe,
  elsdot: Nwe,
  Emacr: Dwe,
  emacr: Lwe,
  empty: Iwe,
  emptyset: Bwe,
  EmptySmallSquare: Qwe,
  emptyv: zwe,
  EmptyVerySmallSquare: jwe,
  emsp13: Vwe,
  emsp14: Fwe,
  emsp: Zwe,
  ENG: qwe,
  eng: Wwe,
  ensp: Hwe,
  Eogon: Xwe,
  eogon: Ywe,
  Eopf: Uwe,
  eopf: Gwe,
  epar: Kwe,
  eparsl: Jwe,
  eplus: exe,
  epsi: txe,
  Epsilon: nxe,
  epsilon: ixe,
  epsiv: rxe,
  eqcirc: sxe,
  eqcolon: oxe,
  eqsim: axe,
  eqslantgtr: lxe,
  eqslantless: cxe,
  Equal: uxe,
  equals: hxe,
  EqualTilde: dxe,
  equest: fxe,
  Equilibrium: pxe,
  equiv: gxe,
  equivDD: mxe,
  eqvparsl: vxe,
  erarr: bxe,
  erDot: yxe,
  escr: Oxe,
  Escr: wxe,
  esdot: xxe,
  Esim: Sxe,
  esim: Cxe,
  Eta: kxe,
  eta: Pxe,
  ETH: Exe,
  eth: Axe,
  Euml: $xe,
  euml: Txe,
  euro: _xe,
  excl: Mxe,
  exist: Rxe,
  Exists: Nxe,
  expectation: Dxe,
  exponentiale: Lxe,
  ExponentialE: Ixe,
  fallingdotseq: Bxe,
  Fcy: Qxe,
  fcy: zxe,
  female: jxe,
  ffilig: Vxe,
  fflig: Fxe,
  ffllig: Zxe,
  Ffr: qxe,
  ffr: Wxe,
  filig: Hxe,
  FilledSmallSquare: Xxe,
  FilledVerySmallSquare: Yxe,
  fjlig: Uxe,
  flat: Gxe,
  fllig: Kxe,
  fltns: Jxe,
  fnof: eSe,
  Fopf: tSe,
  fopf: nSe,
  forall: iSe,
  ForAll: rSe,
  fork: sSe,
  forkv: oSe,
  Fouriertrf: aSe,
  fpartint: lSe,
  frac12: cSe,
  frac13: uSe,
  frac14: hSe,
  frac15: dSe,
  frac16: fSe,
  frac18: pSe,
  frac23: gSe,
  frac25: mSe,
  frac34: vSe,
  frac35: bSe,
  frac38: ySe,
  frac45: OSe,
  frac56: wSe,
  frac58: xSe,
  frac78: SSe,
  frasl: CSe,
  frown: kSe,
  fscr: PSe,
  Fscr: ESe,
  gacute: ASe,
  Gamma: $Se,
  gamma: TSe,
  Gammad: _Se,
  gammad: MSe,
  gap: RSe,
  Gbreve: NSe,
  gbreve: DSe,
  Gcedil: LSe,
  Gcirc: ISe,
  gcirc: BSe,
  Gcy: QSe,
  gcy: zSe,
  Gdot: jSe,
  gdot: VSe,
  ge: FSe,
  gE: ZSe,
  gEl: qSe,
  gel: WSe,
  geq: HSe,
  geqq: XSe,
  geqslant: YSe,
  gescc: USe,
  ges: GSe,
  gesdot: KSe,
  gesdoto: JSe,
  gesdotol: eCe,
  gesl: tCe,
  gesles: nCe,
  Gfr: iCe,
  gfr: rCe,
  gg: sCe,
  Gg: oCe,
  ggg: aCe,
  gimel: lCe,
  GJcy: cCe,
  gjcy: uCe,
  gla: hCe,
  gl: dCe,
  glE: fCe,
  glj: pCe,
  gnap: gCe,
  gnapprox: mCe,
  gne: vCe,
  gnE: bCe,
  gneq: yCe,
  gneqq: OCe,
  gnsim: wCe,
  Gopf: xCe,
  gopf: SCe,
  grave: CCe,
  GreaterEqual: kCe,
  GreaterEqualLess: PCe,
  GreaterFullEqual: ECe,
  GreaterGreater: ACe,
  GreaterLess: $Ce,
  GreaterSlantEqual: TCe,
  GreaterTilde: _Ce,
  Gscr: MCe,
  gscr: RCe,
  gsim: NCe,
  gsime: DCe,
  gsiml: LCe,
  gtcc: ICe,
  gtcir: BCe,
  gt: QCe,
  GT: zCe,
  Gt: jCe,
  gtdot: VCe,
  gtlPar: FCe,
  gtquest: ZCe,
  gtrapprox: qCe,
  gtrarr: WCe,
  gtrdot: HCe,
  gtreqless: XCe,
  gtreqqless: YCe,
  gtrless: UCe,
  gtrsim: GCe,
  gvertneqq: KCe,
  gvnE: JCe,
  Hacek: eke,
  hairsp: tke,
  half: nke,
  hamilt: ike,
  HARDcy: rke,
  hardcy: ske,
  harrcir: oke,
  harr: ake,
  hArr: lke,
  harrw: cke,
  Hat: uke,
  hbar: hke,
  Hcirc: dke,
  hcirc: fke,
  hearts: pke,
  heartsuit: gke,
  hellip: mke,
  hercon: vke,
  hfr: bke,
  Hfr: yke,
  HilbertSpace: Oke,
  hksearow: wke,
  hkswarow: xke,
  hoarr: Ske,
  homtht: Cke,
  hookleftarrow: kke,
  hookrightarrow: Pke,
  hopf: Eke,
  Hopf: Ake,
  horbar: $ke,
  HorizontalLine: Tke,
  hscr: _ke,
  Hscr: Mke,
  hslash: Rke,
  Hstrok: Nke,
  hstrok: Dke,
  HumpDownHump: Lke,
  HumpEqual: Ike,
  hybull: Bke,
  hyphen: Qke,
  Iacute: zke,
  iacute: jke,
  ic: Vke,
  Icirc: Fke,
  icirc: Zke,
  Icy: qke,
  icy: Wke,
  Idot: Hke,
  IEcy: Xke,
  iecy: Yke,
  iexcl: Uke,
  iff: Gke,
  ifr: Kke,
  Ifr: Jke,
  Igrave: e2e,
  igrave: t2e,
  ii: n2e,
  iiiint: i2e,
  iiint: r2e,
  iinfin: s2e,
  iiota: o2e,
  IJlig: a2e,
  ijlig: l2e,
  Imacr: c2e,
  imacr: u2e,
  image: h2e,
  ImaginaryI: d2e,
  imagline: f2e,
  imagpart: p2e,
  imath: g2e,
  Im: m2e,
  imof: v2e,
  imped: b2e,
  Implies: y2e,
  incare: O2e,
  in: "∈",
  infin: w2e,
  infintie: x2e,
  inodot: S2e,
  intcal: C2e,
  int: k2e,
  Int: P2e,
  integers: E2e,
  Integral: A2e,
  intercal: $2e,
  Intersection: T2e,
  intlarhk: _2e,
  intprod: M2e,
  InvisibleComma: R2e,
  InvisibleTimes: N2e,
  IOcy: D2e,
  iocy: L2e,
  Iogon: I2e,
  iogon: B2e,
  Iopf: Q2e,
  iopf: z2e,
  Iota: j2e,
  iota: V2e,
  iprod: F2e,
  iquest: Z2e,
  iscr: q2e,
  Iscr: W2e,
  isin: H2e,
  isindot: X2e,
  isinE: Y2e,
  isins: U2e,
  isinsv: G2e,
  isinv: K2e,
  it: J2e,
  Itilde: ePe,
  itilde: tPe,
  Iukcy: nPe,
  iukcy: iPe,
  Iuml: rPe,
  iuml: sPe,
  Jcirc: oPe,
  jcirc: aPe,
  Jcy: lPe,
  jcy: cPe,
  Jfr: uPe,
  jfr: hPe,
  jmath: dPe,
  Jopf: fPe,
  jopf: pPe,
  Jscr: gPe,
  jscr: mPe,
  Jsercy: vPe,
  jsercy: bPe,
  Jukcy: yPe,
  jukcy: OPe,
  Kappa: wPe,
  kappa: xPe,
  kappav: SPe,
  Kcedil: CPe,
  kcedil: kPe,
  Kcy: PPe,
  kcy: EPe,
  Kfr: APe,
  kfr: $Pe,
  kgreen: TPe,
  KHcy: _Pe,
  khcy: MPe,
  KJcy: RPe,
  kjcy: NPe,
  Kopf: DPe,
  kopf: LPe,
  Kscr: IPe,
  kscr: BPe,
  lAarr: QPe,
  Lacute: zPe,
  lacute: jPe,
  laemptyv: VPe,
  lagran: FPe,
  Lambda: ZPe,
  lambda: qPe,
  lang: WPe,
  Lang: HPe,
  langd: XPe,
  langle: YPe,
  lap: UPe,
  Laplacetrf: GPe,
  laquo: KPe,
  larrb: JPe,
  larrbfs: eEe,
  larr: tEe,
  Larr: nEe,
  lArr: iEe,
  larrfs: rEe,
  larrhk: sEe,
  larrlp: oEe,
  larrpl: aEe,
  larrsim: lEe,
  larrtl: cEe,
  latail: uEe,
  lAtail: hEe,
  lat: dEe,
  late: fEe,
  lates: pEe,
  lbarr: gEe,
  lBarr: mEe,
  lbbrk: vEe,
  lbrace: bEe,
  lbrack: yEe,
  lbrke: OEe,
  lbrksld: wEe,
  lbrkslu: xEe,
  Lcaron: SEe,
  lcaron: CEe,
  Lcedil: kEe,
  lcedil: PEe,
  lceil: EEe,
  lcub: AEe,
  Lcy: $Ee,
  lcy: TEe,
  ldca: _Ee,
  ldquo: MEe,
  ldquor: REe,
  ldrdhar: NEe,
  ldrushar: DEe,
  ldsh: LEe,
  le: IEe,
  lE: BEe,
  LeftAngleBracket: QEe,
  LeftArrowBar: zEe,
  leftarrow: jEe,
  LeftArrow: VEe,
  Leftarrow: FEe,
  LeftArrowRightArrow: ZEe,
  leftarrowtail: qEe,
  LeftCeiling: WEe,
  LeftDoubleBracket: HEe,
  LeftDownTeeVector: XEe,
  LeftDownVectorBar: YEe,
  LeftDownVector: UEe,
  LeftFloor: GEe,
  leftharpoondown: KEe,
  leftharpoonup: JEe,
  leftleftarrows: eAe,
  leftrightarrow: tAe,
  LeftRightArrow: nAe,
  Leftrightarrow: iAe,
  leftrightarrows: rAe,
  leftrightharpoons: sAe,
  leftrightsquigarrow: oAe,
  LeftRightVector: aAe,
  LeftTeeArrow: lAe,
  LeftTee: cAe,
  LeftTeeVector: uAe,
  leftthreetimes: hAe,
  LeftTriangleBar: dAe,
  LeftTriangle: fAe,
  LeftTriangleEqual: pAe,
  LeftUpDownVector: gAe,
  LeftUpTeeVector: mAe,
  LeftUpVectorBar: vAe,
  LeftUpVector: bAe,
  LeftVectorBar: yAe,
  LeftVector: OAe,
  lEg: wAe,
  leg: xAe,
  leq: SAe,
  leqq: CAe,
  leqslant: kAe,
  lescc: PAe,
  les: EAe,
  lesdot: AAe,
  lesdoto: $Ae,
  lesdotor: TAe,
  lesg: _Ae,
  lesges: MAe,
  lessapprox: RAe,
  lessdot: NAe,
  lesseqgtr: DAe,
  lesseqqgtr: LAe,
  LessEqualGreater: IAe,
  LessFullEqual: BAe,
  LessGreater: QAe,
  lessgtr: zAe,
  LessLess: jAe,
  lesssim: VAe,
  LessSlantEqual: FAe,
  LessTilde: ZAe,
  lfisht: qAe,
  lfloor: WAe,
  Lfr: HAe,
  lfr: XAe,
  lg: YAe,
  lgE: UAe,
  lHar: GAe,
  lhard: KAe,
  lharu: JAe,
  lharul: e$e,
  lhblk: t$e,
  LJcy: n$e,
  ljcy: i$e,
  llarr: r$e,
  ll: s$e,
  Ll: o$e,
  llcorner: a$e,
  Lleftarrow: l$e,
  llhard: c$e,
  lltri: u$e,
  Lmidot: h$e,
  lmidot: d$e,
  lmoustache: f$e,
  lmoust: p$e,
  lnap: g$e,
  lnapprox: m$e,
  lne: v$e,
  lnE: b$e,
  lneq: y$e,
  lneqq: O$e,
  lnsim: w$e,
  loang: x$e,
  loarr: S$e,
  lobrk: C$e,
  longleftarrow: k$e,
  LongLeftArrow: P$e,
  Longleftarrow: E$e,
  longleftrightarrow: A$e,
  LongLeftRightArrow: $$e,
  Longleftrightarrow: T$e,
  longmapsto: _$e,
  longrightarrow: M$e,
  LongRightArrow: R$e,
  Longrightarrow: N$e,
  looparrowleft: D$e,
  looparrowright: L$e,
  lopar: I$e,
  Lopf: B$e,
  lopf: Q$e,
  loplus: z$e,
  lotimes: j$e,
  lowast: V$e,
  lowbar: F$e,
  LowerLeftArrow: Z$e,
  LowerRightArrow: q$e,
  loz: W$e,
  lozenge: H$e,
  lozf: X$e,
  lpar: Y$e,
  lparlt: U$e,
  lrarr: G$e,
  lrcorner: K$e,
  lrhar: J$e,
  lrhard: eTe,
  lrm: tTe,
  lrtri: nTe,
  lsaquo: iTe,
  lscr: rTe,
  Lscr: sTe,
  lsh: oTe,
  Lsh: aTe,
  lsim: lTe,
  lsime: cTe,
  lsimg: uTe,
  lsqb: hTe,
  lsquo: dTe,
  lsquor: fTe,
  Lstrok: pTe,
  lstrok: gTe,
  ltcc: mTe,
  ltcir: vTe,
  lt: bTe,
  LT: yTe,
  Lt: OTe,
  ltdot: wTe,
  lthree: xTe,
  ltimes: STe,
  ltlarr: CTe,
  ltquest: kTe,
  ltri: PTe,
  ltrie: ETe,
  ltrif: ATe,
  ltrPar: $Te,
  lurdshar: TTe,
  luruhar: _Te,
  lvertneqq: MTe,
  lvnE: RTe,
  macr: NTe,
  male: DTe,
  malt: LTe,
  maltese: ITe,
  Map: "⤅",
  map: BTe,
  mapsto: QTe,
  mapstodown: zTe,
  mapstoleft: jTe,
  mapstoup: VTe,
  marker: FTe,
  mcomma: ZTe,
  Mcy: qTe,
  mcy: WTe,
  mdash: HTe,
  mDDot: XTe,
  measuredangle: YTe,
  MediumSpace: UTe,
  Mellintrf: GTe,
  Mfr: KTe,
  mfr: JTe,
  mho: e_e,
  micro: t_e,
  midast: n_e,
  midcir: i_e,
  mid: r_e,
  middot: s_e,
  minusb: o_e,
  minus: a_e,
  minusd: l_e,
  minusdu: c_e,
  MinusPlus: u_e,
  mlcp: h_e,
  mldr: d_e,
  mnplus: f_e,
  models: p_e,
  Mopf: g_e,
  mopf: m_e,
  mp: v_e,
  mscr: b_e,
  Mscr: y_e,
  mstpos: O_e,
  Mu: w_e,
  mu: x_e,
  multimap: S_e,
  mumap: C_e,
  nabla: k_e,
  Nacute: P_e,
  nacute: E_e,
  nang: A_e,
  nap: $_e,
  napE: T_e,
  napid: __e,
  napos: M_e,
  napprox: R_e,
  natural: N_e,
  naturals: D_e,
  natur: L_e,
  nbsp: I_e,
  nbump: B_e,
  nbumpe: Q_e,
  ncap: z_e,
  Ncaron: j_e,
  ncaron: V_e,
  Ncedil: F_e,
  ncedil: Z_e,
  ncong: q_e,
  ncongdot: W_e,
  ncup: H_e,
  Ncy: X_e,
  ncy: Y_e,
  ndash: U_e,
  nearhk: G_e,
  nearr: K_e,
  neArr: J_e,
  nearrow: eMe,
  ne: tMe,
  nedot: nMe,
  NegativeMediumSpace: iMe,
  NegativeThickSpace: rMe,
  NegativeThinSpace: sMe,
  NegativeVeryThinSpace: oMe,
  nequiv: aMe,
  nesear: lMe,
  nesim: cMe,
  NestedGreaterGreater: uMe,
  NestedLessLess: hMe,
  NewLine: dMe,
  nexist: fMe,
  nexists: pMe,
  Nfr: gMe,
  nfr: mMe,
  ngE: vMe,
  nge: bMe,
  ngeq: yMe,
  ngeqq: OMe,
  ngeqslant: wMe,
  nges: xMe,
  nGg: SMe,
  ngsim: CMe,
  nGt: kMe,
  ngt: PMe,
  ngtr: EMe,
  nGtv: AMe,
  nharr: $Me,
  nhArr: TMe,
  nhpar: _Me,
  ni: MMe,
  nis: RMe,
  nisd: NMe,
  niv: DMe,
  NJcy: LMe,
  njcy: IMe,
  nlarr: BMe,
  nlArr: QMe,
  nldr: zMe,
  nlE: jMe,
  nle: VMe,
  nleftarrow: FMe,
  nLeftarrow: ZMe,
  nleftrightarrow: qMe,
  nLeftrightarrow: WMe,
  nleq: HMe,
  nleqq: XMe,
  nleqslant: YMe,
  nles: UMe,
  nless: GMe,
  nLl: KMe,
  nlsim: JMe,
  nLt: eRe,
  nlt: tRe,
  nltri: nRe,
  nltrie: iRe,
  nLtv: rRe,
  nmid: sRe,
  NoBreak: oRe,
  NonBreakingSpace: aRe,
  nopf: lRe,
  Nopf: cRe,
  Not: uRe,
  not: hRe,
  NotCongruent: dRe,
  NotCupCap: fRe,
  NotDoubleVerticalBar: pRe,
  NotElement: gRe,
  NotEqual: mRe,
  NotEqualTilde: vRe,
  NotExists: bRe,
  NotGreater: yRe,
  NotGreaterEqual: ORe,
  NotGreaterFullEqual: wRe,
  NotGreaterGreater: xRe,
  NotGreaterLess: SRe,
  NotGreaterSlantEqual: CRe,
  NotGreaterTilde: kRe,
  NotHumpDownHump: PRe,
  NotHumpEqual: ERe,
  notin: ARe,
  notindot: $Re,
  notinE: TRe,
  notinva: _Re,
  notinvb: MRe,
  notinvc: RRe,
  NotLeftTriangleBar: NRe,
  NotLeftTriangle: DRe,
  NotLeftTriangleEqual: LRe,
  NotLess: IRe,
  NotLessEqual: BRe,
  NotLessGreater: QRe,
  NotLessLess: zRe,
  NotLessSlantEqual: jRe,
  NotLessTilde: VRe,
  NotNestedGreaterGreater: FRe,
  NotNestedLessLess: ZRe,
  notni: qRe,
  notniva: WRe,
  notnivb: HRe,
  notnivc: XRe,
  NotPrecedes: YRe,
  NotPrecedesEqual: URe,
  NotPrecedesSlantEqual: GRe,
  NotReverseElement: KRe,
  NotRightTriangleBar: JRe,
  NotRightTriangle: e3e,
  NotRightTriangleEqual: t3e,
  NotSquareSubset: n3e,
  NotSquareSubsetEqual: i3e,
  NotSquareSuperset: r3e,
  NotSquareSupersetEqual: s3e,
  NotSubset: o3e,
  NotSubsetEqual: a3e,
  NotSucceeds: l3e,
  NotSucceedsEqual: c3e,
  NotSucceedsSlantEqual: u3e,
  NotSucceedsTilde: h3e,
  NotSuperset: d3e,
  NotSupersetEqual: f3e,
  NotTilde: p3e,
  NotTildeEqual: g3e,
  NotTildeFullEqual: m3e,
  NotTildeTilde: v3e,
  NotVerticalBar: b3e,
  nparallel: y3e,
  npar: O3e,
  nparsl: w3e,
  npart: x3e,
  npolint: S3e,
  npr: C3e,
  nprcue: k3e,
  nprec: P3e,
  npreceq: E3e,
  npre: A3e,
  nrarrc: $3e,
  nrarr: T3e,
  nrArr: _3e,
  nrarrw: M3e,
  nrightarrow: R3e,
  nRightarrow: N3e,
  nrtri: D3e,
  nrtrie: L3e,
  nsc: I3e,
  nsccue: B3e,
  nsce: Q3e,
  Nscr: z3e,
  nscr: j3e,
  nshortmid: V3e,
  nshortparallel: F3e,
  nsim: Z3e,
  nsime: q3e,
  nsimeq: W3e,
  nsmid: H3e,
  nspar: X3e,
  nsqsube: Y3e,
  nsqsupe: U3e,
  nsub: G3e,
  nsubE: K3e,
  nsube: J3e,
  nsubset: eNe,
  nsubseteq: tNe,
  nsubseteqq: nNe,
  nsucc: iNe,
  nsucceq: rNe,
  nsup: sNe,
  nsupE: oNe,
  nsupe: aNe,
  nsupset: lNe,
  nsupseteq: cNe,
  nsupseteqq: uNe,
  ntgl: hNe,
  Ntilde: dNe,
  ntilde: fNe,
  ntlg: pNe,
  ntriangleleft: gNe,
  ntrianglelefteq: mNe,
  ntriangleright: vNe,
  ntrianglerighteq: bNe,
  Nu: yNe,
  nu: ONe,
  num: wNe,
  numero: xNe,
  numsp: SNe,
  nvap: CNe,
  nvdash: kNe,
  nvDash: PNe,
  nVdash: ENe,
  nVDash: ANe,
  nvge: $Ne,
  nvgt: TNe,
  nvHarr: _Ne,
  nvinfin: MNe,
  nvlArr: RNe,
  nvle: NNe,
  nvlt: DNe,
  nvltrie: LNe,
  nvrArr: INe,
  nvrtrie: BNe,
  nvsim: QNe,
  nwarhk: zNe,
  nwarr: jNe,
  nwArr: VNe,
  nwarrow: FNe,
  nwnear: ZNe,
  Oacute: qNe,
  oacute: WNe,
  oast: HNe,
  Ocirc: XNe,
  ocirc: YNe,
  ocir: UNe,
  Ocy: GNe,
  ocy: KNe,
  odash: JNe,
  Odblac: eDe,
  odblac: tDe,
  odiv: nDe,
  odot: iDe,
  odsold: rDe,
  OElig: sDe,
  oelig: oDe,
  ofcir: aDe,
  Ofr: lDe,
  ofr: cDe,
  ogon: uDe,
  Ograve: hDe,
  ograve: dDe,
  ogt: fDe,
  ohbar: pDe,
  ohm: gDe,
  oint: mDe,
  olarr: vDe,
  olcir: bDe,
  olcross: yDe,
  oline: ODe,
  olt: wDe,
  Omacr: xDe,
  omacr: SDe,
  Omega: CDe,
  omega: kDe,
  Omicron: PDe,
  omicron: EDe,
  omid: ADe,
  ominus: $De,
  Oopf: TDe,
  oopf: _De,
  opar: MDe,
  OpenCurlyDoubleQuote: RDe,
  OpenCurlyQuote: NDe,
  operp: DDe,
  oplus: LDe,
  orarr: IDe,
  Or: BDe,
  or: QDe,
  ord: zDe,
  order: jDe,
  orderof: VDe,
  ordf: FDe,
  ordm: ZDe,
  origof: qDe,
  oror: WDe,
  orslope: HDe,
  orv: XDe,
  oS: YDe,
  Oscr: UDe,
  oscr: GDe,
  Oslash: KDe,
  oslash: JDe,
  osol: e4e,
  Otilde: t4e,
  otilde: n4e,
  otimesas: i4e,
  Otimes: r4e,
  otimes: s4e,
  Ouml: o4e,
  ouml: a4e,
  ovbar: l4e,
  OverBar: c4e,
  OverBrace: u4e,
  OverBracket: h4e,
  OverParenthesis: d4e,
  para: f4e,
  parallel: p4e,
  par: g4e,
  parsim: m4e,
  parsl: v4e,
  part: b4e,
  PartialD: y4e,
  Pcy: O4e,
  pcy: w4e,
  percnt: x4e,
  period: S4e,
  permil: C4e,
  perp: k4e,
  pertenk: P4e,
  Pfr: E4e,
  pfr: A4e,
  Phi: $4e,
  phi: T4e,
  phiv: _4e,
  phmmat: M4e,
  phone: R4e,
  Pi: N4e,
  pi: D4e,
  pitchfork: L4e,
  piv: I4e,
  planck: B4e,
  planckh: Q4e,
  plankv: z4e,
  plusacir: j4e,
  plusb: V4e,
  pluscir: F4e,
  plus: Z4e,
  plusdo: q4e,
  plusdu: W4e,
  pluse: H4e,
  PlusMinus: X4e,
  plusmn: Y4e,
  plussim: U4e,
  plustwo: G4e,
  pm: K4e,
  Poincareplane: J4e,
  pointint: eLe,
  popf: tLe,
  Popf: nLe,
  pound: iLe,
  prap: rLe,
  Pr: sLe,
  pr: oLe,
  prcue: aLe,
  precapprox: lLe,
  prec: cLe,
  preccurlyeq: uLe,
  Precedes: hLe,
  PrecedesEqual: dLe,
  PrecedesSlantEqual: fLe,
  PrecedesTilde: pLe,
  preceq: gLe,
  precnapprox: mLe,
  precneqq: vLe,
  precnsim: bLe,
  pre: yLe,
  prE: OLe,
  precsim: wLe,
  prime: xLe,
  Prime: SLe,
  primes: CLe,
  prnap: kLe,
  prnE: PLe,
  prnsim: ELe,
  prod: ALe,
  Product: $Le,
  profalar: TLe,
  profline: _Le,
  profsurf: MLe,
  prop: RLe,
  Proportional: NLe,
  Proportion: DLe,
  propto: LLe,
  prsim: ILe,
  prurel: BLe,
  Pscr: QLe,
  pscr: zLe,
  Psi: jLe,
  psi: VLe,
  puncsp: FLe,
  Qfr: ZLe,
  qfr: qLe,
  qint: WLe,
  qopf: HLe,
  Qopf: XLe,
  qprime: YLe,
  Qscr: ULe,
  qscr: GLe,
  quaternions: KLe,
  quatint: JLe,
  quest: eIe,
  questeq: tIe,
  quot: nIe,
  QUOT: iIe,
  rAarr: rIe,
  race: sIe,
  Racute: oIe,
  racute: aIe,
  radic: lIe,
  raemptyv: cIe,
  rang: uIe,
  Rang: hIe,
  rangd: dIe,
  range: fIe,
  rangle: pIe,
  raquo: gIe,
  rarrap: mIe,
  rarrb: vIe,
  rarrbfs: bIe,
  rarrc: yIe,
  rarr: OIe,
  Rarr: wIe,
  rArr: xIe,
  rarrfs: SIe,
  rarrhk: CIe,
  rarrlp: kIe,
  rarrpl: PIe,
  rarrsim: EIe,
  Rarrtl: AIe,
  rarrtl: $Ie,
  rarrw: TIe,
  ratail: _Ie,
  rAtail: MIe,
  ratio: RIe,
  rationals: NIe,
  rbarr: DIe,
  rBarr: LIe,
  RBarr: IIe,
  rbbrk: BIe,
  rbrace: QIe,
  rbrack: zIe,
  rbrke: jIe,
  rbrksld: VIe,
  rbrkslu: FIe,
  Rcaron: ZIe,
  rcaron: qIe,
  Rcedil: WIe,
  rcedil: HIe,
  rceil: XIe,
  rcub: YIe,
  Rcy: UIe,
  rcy: GIe,
  rdca: KIe,
  rdldhar: JIe,
  rdquo: e5e,
  rdquor: t5e,
  rdsh: n5e,
  real: i5e,
  realine: r5e,
  realpart: s5e,
  reals: o5e,
  Re: a5e,
  rect: l5e,
  reg: c5e,
  REG: u5e,
  ReverseElement: h5e,
  ReverseEquilibrium: d5e,
  ReverseUpEquilibrium: f5e,
  rfisht: p5e,
  rfloor: g5e,
  rfr: m5e,
  Rfr: v5e,
  rHar: b5e,
  rhard: y5e,
  rharu: O5e,
  rharul: w5e,
  Rho: x5e,
  rho: S5e,
  rhov: C5e,
  RightAngleBracket: k5e,
  RightArrowBar: P5e,
  rightarrow: E5e,
  RightArrow: A5e,
  Rightarrow: $5e,
  RightArrowLeftArrow: T5e,
  rightarrowtail: _5e,
  RightCeiling: M5e,
  RightDoubleBracket: R5e,
  RightDownTeeVector: N5e,
  RightDownVectorBar: D5e,
  RightDownVector: L5e,
  RightFloor: I5e,
  rightharpoondown: B5e,
  rightharpoonup: Q5e,
  rightleftarrows: z5e,
  rightleftharpoons: j5e,
  rightrightarrows: V5e,
  rightsquigarrow: F5e,
  RightTeeArrow: Z5e,
  RightTee: q5e,
  RightTeeVector: W5e,
  rightthreetimes: H5e,
  RightTriangleBar: X5e,
  RightTriangle: Y5e,
  RightTriangleEqual: U5e,
  RightUpDownVector: G5e,
  RightUpTeeVector: K5e,
  RightUpVectorBar: J5e,
  RightUpVector: e8e,
  RightVectorBar: t8e,
  RightVector: n8e,
  ring: i8e,
  risingdotseq: r8e,
  rlarr: s8e,
  rlhar: o8e,
  rlm: a8e,
  rmoustache: l8e,
  rmoust: c8e,
  rnmid: u8e,
  roang: h8e,
  roarr: d8e,
  robrk: f8e,
  ropar: p8e,
  ropf: g8e,
  Ropf: m8e,
  roplus: v8e,
  rotimes: b8e,
  RoundImplies: y8e,
  rpar: O8e,
  rpargt: w8e,
  rppolint: x8e,
  rrarr: S8e,
  Rrightarrow: C8e,
  rsaquo: k8e,
  rscr: P8e,
  Rscr: E8e,
  rsh: A8e,
  Rsh: $8e,
  rsqb: T8e,
  rsquo: _8e,
  rsquor: M8e,
  rthree: R8e,
  rtimes: N8e,
  rtri: D8e,
  rtrie: L8e,
  rtrif: I8e,
  rtriltri: B8e,
  RuleDelayed: Q8e,
  ruluhar: z8e,
  rx: j8e,
  Sacute: V8e,
  sacute: F8e,
  sbquo: Z8e,
  scap: q8e,
  Scaron: W8e,
  scaron: H8e,
  Sc: X8e,
  sc: Y8e,
  sccue: U8e,
  sce: G8e,
  scE: K8e,
  Scedil: J8e,
  scedil: e6e,
  Scirc: t6e,
  scirc: n6e,
  scnap: i6e,
  scnE: r6e,
  scnsim: s6e,
  scpolint: o6e,
  scsim: a6e,
  Scy: l6e,
  scy: c6e,
  sdotb: u6e,
  sdot: h6e,
  sdote: d6e,
  searhk: f6e,
  searr: p6e,
  seArr: g6e,
  searrow: m6e,
  sect: v6e,
  semi: b6e,
  seswar: y6e,
  setminus: O6e,
  setmn: w6e,
  sext: x6e,
  Sfr: S6e,
  sfr: C6e,
  sfrown: k6e,
  sharp: P6e,
  SHCHcy: E6e,
  shchcy: A6e,
  SHcy: $6e,
  shcy: T6e,
  ShortDownArrow: _6e,
  ShortLeftArrow: M6e,
  shortmid: R6e,
  shortparallel: N6e,
  ShortRightArrow: D6e,
  ShortUpArrow: L6e,
  shy: I6e,
  Sigma: B6e,
  sigma: Q6e,
  sigmaf: z6e,
  sigmav: j6e,
  sim: V6e,
  simdot: F6e,
  sime: Z6e,
  simeq: q6e,
  simg: W6e,
  simgE: H6e,
  siml: X6e,
  simlE: Y6e,
  simne: U6e,
  simplus: G6e,
  simrarr: K6e,
  slarr: J6e,
  SmallCircle: eBe,
  smallsetminus: tBe,
  smashp: nBe,
  smeparsl: iBe,
  smid: rBe,
  smile: sBe,
  smt: oBe,
  smte: aBe,
  smtes: lBe,
  SOFTcy: cBe,
  softcy: uBe,
  solbar: hBe,
  solb: dBe,
  sol: fBe,
  Sopf: pBe,
  sopf: gBe,
  spades: mBe,
  spadesuit: vBe,
  spar: bBe,
  sqcap: yBe,
  sqcaps: OBe,
  sqcup: wBe,
  sqcups: xBe,
  Sqrt: SBe,
  sqsub: CBe,
  sqsube: kBe,
  sqsubset: PBe,
  sqsubseteq: EBe,
  sqsup: ABe,
  sqsupe: $Be,
  sqsupset: TBe,
  sqsupseteq: _Be,
  square: MBe,
  Square: RBe,
  SquareIntersection: NBe,
  SquareSubset: DBe,
  SquareSubsetEqual: LBe,
  SquareSuperset: IBe,
  SquareSupersetEqual: BBe,
  SquareUnion: QBe,
  squarf: zBe,
  squ: jBe,
  squf: VBe,
  srarr: FBe,
  Sscr: ZBe,
  sscr: qBe,
  ssetmn: WBe,
  ssmile: HBe,
  sstarf: XBe,
  Star: YBe,
  star: UBe,
  starf: GBe,
  straightepsilon: KBe,
  straightphi: JBe,
  strns: eQe,
  sub: tQe,
  Sub: nQe,
  subdot: iQe,
  subE: rQe,
  sube: sQe,
  subedot: oQe,
  submult: aQe,
  subnE: lQe,
  subne: cQe,
  subplus: uQe,
  subrarr: hQe,
  subset: dQe,
  Subset: fQe,
  subseteq: pQe,
  subseteqq: gQe,
  SubsetEqual: mQe,
  subsetneq: vQe,
  subsetneqq: bQe,
  subsim: yQe,
  subsub: OQe,
  subsup: wQe,
  succapprox: xQe,
  succ: SQe,
  succcurlyeq: CQe,
  Succeeds: kQe,
  SucceedsEqual: PQe,
  SucceedsSlantEqual: EQe,
  SucceedsTilde: AQe,
  succeq: $Qe,
  succnapprox: TQe,
  succneqq: _Qe,
  succnsim: MQe,
  succsim: RQe,
  SuchThat: NQe,
  sum: DQe,
  Sum: LQe,
  sung: IQe,
  sup1: BQe,
  sup2: QQe,
  sup3: zQe,
  sup: jQe,
  Sup: VQe,
  supdot: FQe,
  supdsub: ZQe,
  supE: qQe,
  supe: WQe,
  supedot: HQe,
  Superset: XQe,
  SupersetEqual: YQe,
  suphsol: UQe,
  suphsub: GQe,
  suplarr: KQe,
  supmult: JQe,
  supnE: eze,
  supne: tze,
  supplus: nze,
  supset: ize,
  Supset: rze,
  supseteq: sze,
  supseteqq: oze,
  supsetneq: aze,
  supsetneqq: lze,
  supsim: cze,
  supsub: uze,
  supsup: hze,
  swarhk: dze,
  swarr: fze,
  swArr: pze,
  swarrow: gze,
  swnwar: mze,
  szlig: vze,
  Tab: bze,
  target: yze,
  Tau: Oze,
  tau: wze,
  tbrk: xze,
  Tcaron: Sze,
  tcaron: Cze,
  Tcedil: kze,
  tcedil: Pze,
  Tcy: Eze,
  tcy: Aze,
  tdot: $ze,
  telrec: Tze,
  Tfr: _ze,
  tfr: Mze,
  there4: Rze,
  therefore: Nze,
  Therefore: Dze,
  Theta: Lze,
  theta: Ize,
  thetasym: Bze,
  thetav: Qze,
  thickapprox: zze,
  thicksim: jze,
  ThickSpace: Vze,
  ThinSpace: Fze,
  thinsp: Zze,
  thkap: qze,
  thksim: Wze,
  THORN: Hze,
  thorn: Xze,
  tilde: Yze,
  Tilde: Uze,
  TildeEqual: Gze,
  TildeFullEqual: Kze,
  TildeTilde: Jze,
  timesbar: eje,
  timesb: tje,
  times: nje,
  timesd: ije,
  tint: rje,
  toea: sje,
  topbot: oje,
  topcir: aje,
  top: lje,
  Topf: cje,
  topf: uje,
  topfork: hje,
  tosa: dje,
  tprime: fje,
  trade: pje,
  TRADE: gje,
  triangle: mje,
  triangledown: vje,
  triangleleft: bje,
  trianglelefteq: yje,
  triangleq: Oje,
  triangleright: wje,
  trianglerighteq: xje,
  tridot: Sje,
  trie: Cje,
  triminus: kje,
  TripleDot: Pje,
  triplus: Eje,
  trisb: Aje,
  tritime: $je,
  trpezium: Tje,
  Tscr: _je,
  tscr: Mje,
  TScy: Rje,
  tscy: Nje,
  TSHcy: Dje,
  tshcy: Lje,
  Tstrok: Ije,
  tstrok: Bje,
  twixt: Qje,
  twoheadleftarrow: zje,
  twoheadrightarrow: jje,
  Uacute: Vje,
  uacute: Fje,
  uarr: Zje,
  Uarr: qje,
  uArr: Wje,
  Uarrocir: Hje,
  Ubrcy: Xje,
  ubrcy: Yje,
  Ubreve: Uje,
  ubreve: Gje,
  Ucirc: Kje,
  ucirc: Jje,
  Ucy: eVe,
  ucy: tVe,
  udarr: nVe,
  Udblac: iVe,
  udblac: rVe,
  udhar: sVe,
  ufisht: oVe,
  Ufr: aVe,
  ufr: lVe,
  Ugrave: cVe,
  ugrave: uVe,
  uHar: hVe,
  uharl: dVe,
  uharr: fVe,
  uhblk: pVe,
  ulcorn: gVe,
  ulcorner: mVe,
  ulcrop: vVe,
  ultri: bVe,
  Umacr: yVe,
  umacr: OVe,
  uml: wVe,
  UnderBar: xVe,
  UnderBrace: SVe,
  UnderBracket: CVe,
  UnderParenthesis: kVe,
  Union: PVe,
  UnionPlus: EVe,
  Uogon: AVe,
  uogon: $Ve,
  Uopf: TVe,
  uopf: _Ve,
  UpArrowBar: MVe,
  uparrow: RVe,
  UpArrow: NVe,
  Uparrow: DVe,
  UpArrowDownArrow: LVe,
  updownarrow: IVe,
  UpDownArrow: BVe,
  Updownarrow: QVe,
  UpEquilibrium: zVe,
  upharpoonleft: jVe,
  upharpoonright: VVe,
  uplus: FVe,
  UpperLeftArrow: ZVe,
  UpperRightArrow: qVe,
  upsi: WVe,
  Upsi: HVe,
  upsih: XVe,
  Upsilon: YVe,
  upsilon: UVe,
  UpTeeArrow: GVe,
  UpTee: KVe,
  upuparrows: JVe,
  urcorn: eFe,
  urcorner: tFe,
  urcrop: nFe,
  Uring: iFe,
  uring: rFe,
  urtri: sFe,
  Uscr: oFe,
  uscr: aFe,
  utdot: lFe,
  Utilde: cFe,
  utilde: uFe,
  utri: hFe,
  utrif: dFe,
  uuarr: fFe,
  Uuml: pFe,
  uuml: gFe,
  uwangle: mFe,
  vangrt: vFe,
  varepsilon: bFe,
  varkappa: yFe,
  varnothing: OFe,
  varphi: wFe,
  varpi: xFe,
  varpropto: SFe,
  varr: CFe,
  vArr: kFe,
  varrho: PFe,
  varsigma: EFe,
  varsubsetneq: AFe,
  varsubsetneqq: $Fe,
  varsupsetneq: TFe,
  varsupsetneqq: _Fe,
  vartheta: MFe,
  vartriangleleft: RFe,
  vartriangleright: NFe,
  vBar: DFe,
  Vbar: LFe,
  vBarv: IFe,
  Vcy: BFe,
  vcy: QFe,
  vdash: zFe,
  vDash: jFe,
  Vdash: VFe,
  VDash: FFe,
  Vdashl: ZFe,
  veebar: qFe,
  vee: WFe,
  Vee: HFe,
  veeeq: XFe,
  vellip: YFe,
  verbar: UFe,
  Verbar: GFe,
  vert: KFe,
  Vert: JFe,
  VerticalBar: eZe,
  VerticalLine: tZe,
  VerticalSeparator: nZe,
  VerticalTilde: iZe,
  VeryThinSpace: rZe,
  Vfr: sZe,
  vfr: oZe,
  vltri: aZe,
  vnsub: lZe,
  vnsup: cZe,
  Vopf: uZe,
  vopf: hZe,
  vprop: dZe,
  vrtri: fZe,
  Vscr: pZe,
  vscr: gZe,
  vsubnE: mZe,
  vsubne: vZe,
  vsupnE: bZe,
  vsupne: yZe,
  Vvdash: OZe,
  vzigzag: wZe,
  Wcirc: xZe,
  wcirc: SZe,
  wedbar: CZe,
  wedge: kZe,
  Wedge: PZe,
  wedgeq: EZe,
  weierp: AZe,
  Wfr: $Ze,
  wfr: TZe,
  Wopf: _Ze,
  wopf: MZe,
  wp: RZe,
  wr: NZe,
  wreath: DZe,
  Wscr: LZe,
  wscr: IZe,
  xcap: BZe,
  xcirc: QZe,
  xcup: zZe,
  xdtri: jZe,
  Xfr: VZe,
  xfr: FZe,
  xharr: ZZe,
  xhArr: qZe,
  Xi: WZe,
  xi: HZe,
  xlarr: XZe,
  xlArr: YZe,
  xmap: UZe,
  xnis: GZe,
  xodot: KZe,
  Xopf: JZe,
  xopf: eqe,
  xoplus: tqe,
  xotime: nqe,
  xrarr: iqe,
  xrArr: rqe,
  Xscr: sqe,
  xscr: oqe,
  xsqcup: aqe,
  xuplus: lqe,
  xutri: cqe,
  xvee: uqe,
  xwedge: hqe,
  Yacute: dqe,
  yacute: fqe,
  YAcy: pqe,
  yacy: gqe,
  Ycirc: mqe,
  ycirc: vqe,
  Ycy: bqe,
  ycy: yqe,
  yen: Oqe,
  Yfr: wqe,
  yfr: xqe,
  YIcy: Sqe,
  yicy: Cqe,
  Yopf: kqe,
  yopf: Pqe,
  Yscr: Eqe,
  yscr: Aqe,
  YUcy: $qe,
  yucy: Tqe,
  yuml: _qe,
  Yuml: Mqe,
  Zacute: Rqe,
  zacute: Nqe,
  Zcaron: Dqe,
  zcaron: Lqe,
  Zcy: Iqe,
  zcy: Bqe,
  Zdot: Qqe,
  zdot: zqe,
  zeetrf: jqe,
  ZeroWidthSpace: Vqe,
  Zeta: Fqe,
  zeta: Zqe,
  zfr: qqe,
  Zfr: Wqe,
  ZHcy: Hqe,
  zhcy: Xqe,
  zigrarr: Yqe,
  zopf: Uqe,
  Zopf: Gqe,
  Zscr: Kqe,
  zscr: Jqe,
  zwj: e7e,
  zwnj: t7e
};
var o4 = n7e, Bx = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, xh = {}, tE = {};
function i7e(n) {
  var e, t, i = tE[n];
  if (i)
    return i;
  for (i = tE[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? i.push(t) : i.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    i[n.charCodeAt(e)] = n[e];
  return i;
}
function Jv(n, e, t) {
  var i, r, s, o, a, l = "";
  for (typeof e != "string" && (t = e, e = Jv.defaultChars), typeof t > "u" && (t = !0), a = i7e(e), i = 0, r = n.length; i < r; i++) {
    if (s = n.charCodeAt(i), t && s === 37 && i + 2 < r && /^[0-9a-f]{2}$/i.test(n.slice(i + 1, i + 3))) {
      l += n.slice(i, i + 3), i += 2;
      continue;
    }
    if (s < 128) {
      l += a[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && i + 1 < r && (o = n.charCodeAt(i + 1), o >= 56320 && o <= 57343)) {
        l += encodeURIComponent(n[i] + n[i + 1]), i++;
        continue;
      }
      l += "%EF%BF%BD";
      continue;
    }
    l += encodeURIComponent(n[i]);
  }
  return l;
}
Jv.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Jv.componentChars = "-_.!~*'()";
var r7e = Jv, nE = {};
function s7e(n) {
  var e, t, i = nE[n];
  if (i)
    return i;
  for (i = nE[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), i.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), i[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return i;
}
function e0(n, e) {
  var t;
  return typeof e != "string" && (e = e0.defaultChars), t = s7e(e), n.replace(/(%[a-f0-9]{2})+/gi, function(i) {
    var r, s, o, a, l, c, u, h = "";
    for (r = 0, s = i.length; r < s; r += 3) {
      if (o = parseInt(i.slice(r + 1, r + 3), 16), o < 128) {
        h += t[o];
        continue;
      }
      if ((o & 224) === 192 && r + 3 < s && (a = parseInt(i.slice(r + 4, r + 6), 16), (a & 192) === 128)) {
        u = o << 6 & 1984 | a & 63, u < 128 ? h += "��" : h += String.fromCharCode(u), r += 3;
        continue;
      }
      if ((o & 240) === 224 && r + 6 < s && (a = parseInt(i.slice(r + 4, r + 6), 16), l = parseInt(i.slice(r + 7, r + 9), 16), (a & 192) === 128 && (l & 192) === 128)) {
        u = o << 12 & 61440 | a << 6 & 4032 | l & 63, u < 2048 || u >= 55296 && u <= 57343 ? h += "���" : h += String.fromCharCode(u), r += 6;
        continue;
      }
      if ((o & 248) === 240 && r + 9 < s && (a = parseInt(i.slice(r + 4, r + 6), 16), l = parseInt(i.slice(r + 7, r + 9), 16), c = parseInt(i.slice(r + 10, r + 12), 16), (a & 192) === 128 && (l & 192) === 128 && (c & 192) === 128)) {
        u = o << 18 & 1835008 | a << 12 & 258048 | l << 6 & 4032 | c & 63, u < 65536 || u > 1114111 ? h += "����" : (u -= 65536, h += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), r += 9;
        continue;
      }
      h += "�";
    }
    return h;
  });
}
e0.defaultChars = ";/?:@&=+$,#";
e0.componentChars = "";
var o7e = e0, a7e = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function Vm() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var l7e = /^([a-z0-9.+-]+:)/i, c7e = /:[0-9]*$/, u7e = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, h7e = ["<", ">", '"', "`", " ", "\r", `
`, "	"], d7e = ["{", "}", "|", "\\", "^", "`"].concat(h7e), f7e = ["'"].concat(d7e), iE = ["%", "/", "?", ";", "#"].concat(f7e), rE = ["/", "?", "#"], p7e = 255, sE = /^[+a-z0-9A-Z_-]{0,63}$/, g7e = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, oE = {
  javascript: !0,
  "javascript:": !0
}, aE = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function m7e(n, e) {
  if (n && n instanceof Vm)
    return n;
  var t = new Vm();
  return t.parse(n, e), t;
}
Vm.prototype.parse = function(n, e) {
  var t, i, r, s, o, a = n;
  if (a = a.trim(), !e && n.split("#").length === 1) {
    var l = u7e.exec(a);
    if (l)
      return this.pathname = l[1], l[2] && (this.search = l[2]), this;
  }
  var c = l7e.exec(a);
  if (c && (c = c[0], r = c.toLowerCase(), this.protocol = c, a = a.substr(c.length)), (e || c || a.match(/^\/\/[^@\/]+@[^@\/]+/)) && (o = a.substr(0, 2) === "//", o && !(c && oE[c]) && (a = a.substr(2), this.slashes = !0)), !oE[c] && (o || c && !aE[c])) {
    var u = -1;
    for (t = 0; t < rE.length; t++)
      s = a.indexOf(rE[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    var h, d;
    for (u === -1 ? d = a.lastIndexOf("@") : d = a.lastIndexOf("@", u), d !== -1 && (h = a.slice(0, d), a = a.slice(d + 1), this.auth = h), u = -1, t = 0; t < iE.length; t++)
      s = a.indexOf(iE[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    u === -1 && (u = a.length), a[u - 1] === ":" && u--;
    var f = a.slice(0, u);
    a = a.slice(u), this.parseHost(f), this.hostname = this.hostname || "";
    var p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      var g = this.hostname.split(/\./);
      for (t = 0, i = g.length; t < i; t++) {
        var m = g[t];
        if (m && !m.match(sE)) {
          for (var v = "", y = 0, b = m.length; y < b; y++)
            m.charCodeAt(y) > 127 ? v += "x" : v += m[y];
          if (!v.match(sE)) {
            var w = g.slice(0, t), x = g.slice(t + 1), S = m.match(g7e);
            S && (w.push(S[1]), x.unshift(S[2])), x.length && (a = x.join(".") + a), this.hostname = w.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > p7e && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var C = a.indexOf("#");
  C !== -1 && (this.hash = a.substr(C), a = a.slice(0, C));
  var k = a.indexOf("?");
  return k !== -1 && (this.search = a.substr(k), a = a.slice(0, k)), a && (this.pathname = a), aE[r] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Vm.prototype.parseHost = function(n) {
  var e = c7e.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var v7e = m7e;
xh.encode = r7e;
xh.decode = o7e;
xh.format = a7e;
xh.parse = v7e;
var ll = {}, gb, lE;
function a4() {
  return lE || (lE = 1, gb = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), gb;
}
var mb, cE;
function l4() {
  return cE || (cE = 1, mb = /[\0-\x1F\x7F-\x9F]/), mb;
}
var vb, uE;
function b7e() {
  return uE || (uE = 1, vb = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), vb;
}
var bb, hE;
function c4() {
  return hE || (hE = 1, bb = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), bb;
}
var dE;
function y7e() {
  return dE || (dE = 1, ll.Any = a4(), ll.Cc = l4(), ll.Cf = b7e(), ll.P = Bx, ll.Z = c4()), ll;
}
(function(n) {
  function e(I) {
    return Object.prototype.toString.call(I);
  }
  function t(I) {
    return e(I) === "[object String]";
  }
  var i = Object.prototype.hasOwnProperty;
  function r(I, P) {
    return i.call(I, P);
  }
  function s(I) {
    var P = Array.prototype.slice.call(arguments, 1);
    return P.forEach(function(A) {
      if (A) {
        if (typeof A != "object")
          throw new TypeError(A + "must be object");
        Object.keys(A).forEach(function(N) {
          I[N] = A[N];
        });
      }
    }), I;
  }
  function o(I, P, A) {
    return [].concat(I.slice(0, P), A, I.slice(P + 1));
  }
  function a(I) {
    return !(I >= 55296 && I <= 57343 || I >= 64976 && I <= 65007 || (I & 65535) === 65535 || (I & 65535) === 65534 || I >= 0 && I <= 8 || I === 11 || I >= 14 && I <= 31 || I >= 127 && I <= 159 || I > 1114111);
  }
  function l(I) {
    if (I > 65535) {
      I -= 65536;
      var P = 55296 + (I >> 10), A = 56320 + (I & 1023);
      return String.fromCharCode(P, A);
    }
    return String.fromCharCode(I);
  }
  var c = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, h = new RegExp(c.source + "|" + u.source, "gi"), d = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i, f = o4;
  function p(I, P) {
    var A;
    return r(f, P) ? f[P] : P.charCodeAt(0) === 35 && d.test(P) && (A = P[1].toLowerCase() === "x" ? parseInt(P.slice(2), 16) : parseInt(P.slice(1), 10), a(A)) ? l(A) : I;
  }
  function g(I) {
    return I.indexOf("\\") < 0 ? I : I.replace(c, "$1");
  }
  function m(I) {
    return I.indexOf("\\") < 0 && I.indexOf("&") < 0 ? I : I.replace(h, function(P, A, N) {
      return A || p(P, N);
    });
  }
  var v = /[&<>"]/, y = /[&<>"]/g, b = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function w(I) {
    return b[I];
  }
  function x(I) {
    return v.test(I) ? I.replace(y, w) : I;
  }
  var S = /[.?*+^$[\]\\(){}|-]/g;
  function C(I) {
    return I.replace(S, "\\$&");
  }
  function k(I) {
    switch (I) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function E(I) {
    if (I >= 8192 && I <= 8202)
      return !0;
    switch (I) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var M = Bx;
  function _(I) {
    return M.test(I);
  }
  function T(I) {
    switch (I) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function B(I) {
    return I = I.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (I = I.replace(/ẞ/g, "ß")), I.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = xh, n.lib.ucmicro = y7e(), n.assign = s, n.isString = t, n.has = r, n.unescapeMd = g, n.unescapeAll = m, n.isValidEntityCode = a, n.fromCodePoint = l, n.escapeHtml = x, n.arrayReplaceAt = o, n.isSpace = k, n.isWhiteSpace = E, n.isMdAsciiPunct = T, n.isPunctChar = _, n.escapeRE = C, n.normalizeReference = B;
})(Nt);
var t0 = {}, O7e = function(e, t, i) {
  var r, s, o, a, l = -1, c = e.posMax, u = e.pos;
  for (e.pos = t + 1, r = 1; e.pos < c; ) {
    if (o = e.src.charCodeAt(e.pos), o === 93 && (r--, r === 0)) {
      s = !0;
      break;
    }
    if (a = e.pos, e.md.inline.skipToken(e), o === 91) {
      if (a === e.pos - 1)
        r++;
      else if (i)
        return e.pos = u, -1;
    }
  }
  return s && (l = e.pos), e.pos = u, l;
}, fE = Nt.unescapeAll, w7e = function(e, t, i) {
  var r, s, o = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(o) === 60) {
    for (o++; o < i; ) {
      if (r = e.charCodeAt(o), r === 10 || r === 60)
        return a;
      if (r === 62)
        return a.pos = o + 1, a.str = fE(e.slice(t + 1, o)), a.ok = !0, a;
      if (r === 92 && o + 1 < i) {
        o += 2;
        continue;
      }
      o++;
    }
    return a;
  }
  for (s = 0; o < i && (r = e.charCodeAt(o), !(r === 32 || r < 32 || r === 127)); ) {
    if (r === 92 && o + 1 < i) {
      if (e.charCodeAt(o + 1) === 32)
        break;
      o += 2;
      continue;
    }
    if (r === 40 && (s++, s > 32))
      return a;
    if (r === 41) {
      if (s === 0)
        break;
      s--;
    }
    o++;
  }
  return t === o || s !== 0 || (a.str = fE(e.slice(t, o)), a.pos = o, a.ok = !0), a;
}, x7e = Nt.unescapeAll, S7e = function(e, t, i) {
  var r, s, o = 0, a = t, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (a >= i || (s = e.charCodeAt(a), s !== 34 && s !== 39 && s !== 40))
    return l;
  for (a++, s === 40 && (s = 41); a < i; ) {
    if (r = e.charCodeAt(a), r === s)
      return l.pos = a + 1, l.lines = o, l.str = x7e(e.slice(t + 1, a)), l.ok = !0, l;
    if (r === 40 && s === 41)
      return l;
    r === 10 ? o++ : r === 92 && a + 1 < i && (a++, e.charCodeAt(a) === 10 && o++), a++;
  }
  return l;
};
t0.parseLinkLabel = O7e;
t0.parseLinkDestination = w7e;
t0.parseLinkTitle = S7e;
var C7e = Nt.assign, k7e = Nt.unescapeAll, nc = Nt.escapeHtml, xo = {};
xo.code_inline = function(n, e, t, i, r) {
  var s = n[e];
  return "<code" + r.renderAttrs(s) + ">" + nc(s.content) + "</code>";
};
xo.code_block = function(n, e, t, i, r) {
  var s = n[e];
  return "<pre" + r.renderAttrs(s) + "><code>" + nc(n[e].content) + `</code></pre>
`;
};
xo.fence = function(n, e, t, i, r) {
  var s = n[e], o = s.info ? k7e(s.info).trim() : "", a = "", l = "", c, u, h, d, f;
  return o && (h = o.split(/(\s+)/g), a = h[0], l = h.slice(2).join("")), t.highlight ? c = t.highlight(s.content, a, l) || nc(s.content) : c = nc(s.content), c.indexOf("<pre") === 0 ? c + `
` : o ? (u = s.attrIndex("class"), d = s.attrs ? s.attrs.slice() : [], u < 0 ? d.push(["class", t.langPrefix + a]) : (d[u] = d[u].slice(), d[u][1] += " " + t.langPrefix + a), f = {
    attrs: d
  }, "<pre><code" + r.renderAttrs(f) + ">" + c + `</code></pre>
`) : "<pre><code" + r.renderAttrs(s) + ">" + c + `</code></pre>
`;
};
xo.image = function(n, e, t, i, r) {
  var s = n[e];
  return s.attrs[s.attrIndex("alt")][1] = r.renderInlineAsText(s.children, t, i), r.renderToken(n, e, t);
};
xo.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
xo.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
xo.text = function(n, e) {
  return nc(n[e].content);
};
xo.html_block = function(n, e) {
  return n[e].content;
};
xo.html_inline = function(n, e) {
  return n[e].content;
};
function Sh() {
  this.rules = C7e({}, xo);
}
Sh.prototype.renderAttrs = function(e) {
  var t, i, r;
  if (!e.attrs)
    return "";
  for (r = "", t = 0, i = e.attrs.length; t < i; t++)
    r += " " + nc(e.attrs[t][0]) + '="' + nc(e.attrs[t][1]) + '"';
  return r;
};
Sh.prototype.renderToken = function(e, t, i) {
  var r, s = "", o = !1, a = e[t];
  return a.hidden ? "" : (a.block && a.nesting !== -1 && t && e[t - 1].hidden && (s += `
`), s += (a.nesting === -1 ? "</" : "<") + a.tag, s += this.renderAttrs(a), a.nesting === 0 && i.xhtmlOut && (s += " /"), a.block && (o = !0, a.nesting === 1 && t + 1 < e.length && (r = e[t + 1], (r.type === "inline" || r.hidden || r.nesting === -1 && r.tag === a.tag) && (o = !1))), s += o ? `>
` : ">", s);
};
Sh.prototype.renderInline = function(n, e, t) {
  for (var i, r = "", s = this.rules, o = 0, a = n.length; o < a; o++)
    i = n[o].type, typeof s[i] < "u" ? r += s[i](n, o, e, t, this) : r += this.renderToken(n, o, e);
  return r;
};
Sh.prototype.renderInlineAsText = function(n, e, t) {
  for (var i = "", r = 0, s = n.length; r < s; r++)
    n[r].type === "text" ? i += n[r].content : n[r].type === "image" ? i += this.renderInlineAsText(n[r].children, e, t) : n[r].type === "softbreak" && (i += `
`);
  return i;
};
Sh.prototype.render = function(n, e, t) {
  var i, r, s, o = "", a = this.rules;
  for (i = 0, r = n.length; i < r; i++)
    s = n[i].type, s === "inline" ? o += this.renderInline(n[i].children, e, t) : typeof a[s] < "u" ? o += a[s](n, i, e, t, this) : o += this.renderToken(n, i, e, t);
  return o;
};
var P7e = Sh;
function Ms() {
  this.__rules__ = [], this.__cache__ = null;
}
Ms.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
Ms.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(i) {
      e.indexOf(i) < 0 && e.push(i);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(i) {
      i.enabled && (t && i.alt.indexOf(t) < 0 || n.__cache__[t].push(i.fn));
    });
  });
};
Ms.prototype.at = function(n, e, t) {
  var i = this.__find__(n), r = t || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[i].fn = e, this.__rules__[i].alt = r.alt || [], this.__cache__ = null;
};
Ms.prototype.before = function(n, e, t, i) {
  var r = this.__find__(n), s = i || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(r, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Ms.prototype.after = function(n, e, t, i) {
  var r = this.__find__(n), s = i || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(r + 1, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Ms.prototype.push = function(n, e, t) {
  var i = t || {};
  this.__rules__.push({
    name: n,
    enabled: !0,
    fn: e,
    alt: i.alt || []
  }), this.__cache__ = null;
};
Ms.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(i) {
    var r = this.__find__(i);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + i);
    }
    this.__rules__[r].enabled = !0, t.push(i);
  }, this), this.__cache__ = null, t;
};
Ms.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = !1;
  }), this.enable(n, e);
};
Ms.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(i) {
    var r = this.__find__(i);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + i);
    }
    this.__rules__[r].enabled = !1, t.push(i);
  }, this), this.__cache__ = null, t;
};
Ms.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var Qx = Ms, E7e = /\r\n?|\n/g, A7e = /\0/g, $7e = function(e) {
  var t;
  t = e.src.replace(E7e, `
`), t = t.replace(A7e, "�"), e.src = t;
}, T7e = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, _7e = function(e) {
  var t = e.tokens, i, r, s;
  for (r = 0, s = t.length; r < s; r++)
    i = t[r], i.type === "inline" && e.md.inline.parse(i.content, e.md, e.env, i.children);
}, M7e = Nt.arrayReplaceAt;
function R7e(n) {
  return /^<a[>\s]/i.test(n);
}
function N7e(n) {
  return /^<\/a\s*>/i.test(n);
}
var D7e = function(e) {
  var t, i, r, s, o, a, l, c, u, h, d, f, p, g, m, v, y = e.tokens, b;
  if (e.md.options.linkify) {
    for (i = 0, r = y.length; i < r; i++)
      if (!(y[i].type !== "inline" || !e.md.linkify.pretest(y[i].content)))
        for (s = y[i].children, p = 0, t = s.length - 1; t >= 0; t--) {
          if (a = s[t], a.type === "link_close") {
            for (t--; s[t].level !== a.level && s[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (a.type === "html_inline" && (R7e(a.content) && p > 0 && p--, N7e(a.content) && p++), !(p > 0) && a.type === "text" && e.md.linkify.test(a.content)) {
            for (u = a.content, b = e.md.linkify.match(u), l = [], f = a.level, d = 0, b.length > 0 && b[0].index === 0 && t > 0 && s[t - 1].type === "text_special" && (b = b.slice(1)), c = 0; c < b.length; c++)
              g = b[c].url, m = e.md.normalizeLink(g), e.md.validateLink(m) && (v = b[c].text, b[c].schema ? b[c].schema === "mailto:" && !/^mailto:/i.test(v) ? v = e.md.normalizeLinkText("mailto:" + v).replace(/^mailto:/, "") : v = e.md.normalizeLinkText(v) : v = e.md.normalizeLinkText("http://" + v).replace(/^http:\/\//, ""), h = b[c].index, h > d && (o = new e.Token("text", "", 0), o.content = u.slice(d, h), o.level = f, l.push(o)), o = new e.Token("link_open", "a", 1), o.attrs = [["href", m]], o.level = f++, o.markup = "linkify", o.info = "auto", l.push(o), o = new e.Token("text", "", 0), o.content = v, o.level = f, l.push(o), o = new e.Token("link_close", "a", -1), o.level = --f, o.markup = "linkify", o.info = "auto", l.push(o), d = b[c].lastIndex);
            d < u.length && (o = new e.Token("text", "", 0), o.content = u.slice(d), o.level = f, l.push(o)), y[i].children = s = M7e(s, t, l);
          }
        }
  }
}, u4 = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, L7e = /\((c|tm|r)\)/i, I7e = /\((c|tm|r)\)/ig, B7e = {
  c: "©",
  r: "®",
  tm: "™"
};
function Q7e(n, e) {
  return B7e[e.toLowerCase()];
}
function z7e(n) {
  var e, t, i = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !i && (t.content = t.content.replace(I7e, Q7e)), t.type === "link_open" && t.info === "auto" && i--, t.type === "link_close" && t.info === "auto" && i++;
}
function j7e(n) {
  var e, t, i = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !i && u4.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && i--, t.type === "link_close" && t.info === "auto" && i++;
}
var V7e = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (L7e.test(e.tokens[t].content) && z7e(e.tokens[t].children), u4.test(e.tokens[t].content) && j7e(e.tokens[t].children));
}, pE = Nt.isWhiteSpace, gE = Nt.isPunctChar, mE = Nt.isMdAsciiPunct, F7e = /['"]/, vE = /['"]/g, bE = "’";
function Fp(n, e, t) {
  return n.slice(0, e) + t + n.slice(e + 1);
}
function Z7e(n, e) {
  var t, i, r, s, o, a, l, c, u, h, d, f, p, g, m, v, y, b, w, x, S;
  for (w = [], t = 0; t < n.length; t++) {
    for (i = n[t], l = n[t].level, y = w.length - 1; y >= 0 && !(w[y].level <= l); y--)
      ;
    if (w.length = y + 1, i.type === "text") {
      r = i.content, o = 0, a = r.length;
      e:
        for (; o < a && (vE.lastIndex = o, s = vE.exec(r), !!s); ) {
          if (m = v = !0, o = s.index + 1, b = s[0] === "'", u = 32, s.index - 1 >= 0)
            u = r.charCodeAt(s.index - 1);
          else
            for (y = t - 1; y >= 0 && !(n[y].type === "softbreak" || n[y].type === "hardbreak"); y--)
              if (n[y].content) {
                u = n[y].content.charCodeAt(n[y].content.length - 1);
                break;
              }
          if (h = 32, o < a)
            h = r.charCodeAt(o);
          else
            for (y = t + 1; y < n.length && !(n[y].type === "softbreak" || n[y].type === "hardbreak"); y++)
              if (n[y].content) {
                h = n[y].content.charCodeAt(0);
                break;
              }
          if (d = mE(u) || gE(String.fromCharCode(u)), f = mE(h) || gE(String.fromCharCode(h)), p = pE(u), g = pE(h), g ? m = !1 : f && (p || d || (m = !1)), p ? v = !1 : d && (g || f || (v = !1)), h === 34 && s[0] === '"' && u >= 48 && u <= 57 && (v = m = !1), m && v && (m = d, v = f), !m && !v) {
            b && (i.content = Fp(i.content, s.index, bE));
            continue;
          }
          if (v) {
            for (y = w.length - 1; y >= 0 && (c = w[y], !(w[y].level < l)); y--)
              if (c.single === b && w[y].level === l) {
                c = w[y], b ? (x = e.md.options.quotes[2], S = e.md.options.quotes[3]) : (x = e.md.options.quotes[0], S = e.md.options.quotes[1]), i.content = Fp(i.content, s.index, S), n[c.token].content = Fp(
                  n[c.token].content,
                  c.pos,
                  x
                ), o += S.length - 1, c.token === t && (o += x.length - 1), r = i.content, a = r.length, w.length = y;
                continue e;
              }
          }
          m ? w.push({
            token: t,
            pos: s.index,
            single: b,
            level: l
          }) : v && b && (i.content = Fp(i.content, s.index, bE));
        }
    }
  }
}
var q7e = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !F7e.test(e.tokens[t].content) || Z7e(e.tokens[t].children, e);
}, W7e = function(e) {
  var t, i, r, s, o, a, l = e.tokens;
  for (t = 0, i = l.length; t < i; t++)
    if (l[t].type === "inline") {
      for (r = l[t].children, o = r.length, s = 0; s < o; s++)
        r[s].type === "text_special" && (r[s].type = "text");
      for (s = a = 0; s < o; s++)
        r[s].type === "text" && s + 1 < o && r[s + 1].type === "text" ? r[s + 1].content = r[s].content + r[s + 1].content : (s !== a && (r[a] = r[s]), a++);
      s !== a && (r.length = a);
    }
};
function Ch(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Ch.prototype.attrIndex = function(e) {
  var t, i, r;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, i = 0, r = t.length; i < r; i++)
    if (t[i][0] === e)
      return i;
  return -1;
};
Ch.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Ch.prototype.attrSet = function(e, t) {
  var i = this.attrIndex(e), r = [e, t];
  i < 0 ? this.attrPush(r) : this.attrs[i] = r;
};
Ch.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), i = null;
  return t >= 0 && (i = this.attrs[t][1]), i;
};
Ch.prototype.attrJoin = function(e, t) {
  var i = this.attrIndex(e);
  i < 0 ? this.attrPush([e, t]) : this.attrs[i][1] = this.attrs[i][1] + " " + t;
};
var zx = Ch, H7e = zx;
function h4(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
}
h4.prototype.Token = H7e;
var X7e = h4, Y7e = Qx, yb = [
  ["normalize", $7e],
  ["block", T7e],
  ["inline", _7e],
  ["linkify", D7e],
  ["replacements", V7e],
  ["smartquotes", q7e],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", W7e]
];
function jx() {
  this.ruler = new Y7e();
  for (var n = 0; n < yb.length; n++)
    this.ruler.push(yb[n][0], yb[n][1]);
}
jx.prototype.process = function(n) {
  var e, t, i;
  for (i = this.ruler.getRules(""), e = 0, t = i.length; e < t; e++)
    i[e](n);
};
jx.prototype.State = X7e;
var U7e = jx, Ob = Nt.isSpace;
function wb(n, e) {
  var t = n.bMarks[e] + n.tShift[e], i = n.eMarks[e];
  return n.src.slice(t, i);
}
function yE(n) {
  var e = [], t = 0, i = n.length, r, s = !1, o = 0, a = "";
  for (r = n.charCodeAt(t); t < i; )
    r === 124 && (s ? (a += n.substring(o, t - 1), o = t) : (e.push(a + n.substring(o, t)), a = "", o = t + 1)), s = r === 92, t++, r = n.charCodeAt(t);
  return e.push(a + n.substring(o)), e;
}
var G7e = function(e, t, i, r) {
  var s, o, a, l, c, u, h, d, f, p, g, m, v, y, b, w, x, S;
  if (t + 2 > i || (u = t + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (a = e.bMarks[u] + e.tShift[u], a >= e.eMarks[u]) || (x = e.src.charCodeAt(a++), x !== 124 && x !== 45 && x !== 58) || a >= e.eMarks[u] || (S = e.src.charCodeAt(a++), S !== 124 && S !== 45 && S !== 58 && !Ob(S)) || x === 45 && Ob(S))
    return !1;
  for (; a < e.eMarks[u]; ) {
    if (s = e.src.charCodeAt(a), s !== 124 && s !== 45 && s !== 58 && !Ob(s))
      return !1;
    a++;
  }
  for (o = wb(e, t + 1), h = o.split("|"), p = [], l = 0; l < h.length; l++) {
    if (g = h[l].trim(), !g) {
      if (l === 0 || l === h.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(g))
      return !1;
    g.charCodeAt(g.length - 1) === 58 ? p.push(g.charCodeAt(0) === 58 ? "center" : "right") : g.charCodeAt(0) === 58 ? p.push("left") : p.push("");
  }
  if (o = wb(e, t).trim(), o.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (h = yE(o), h.length && h[0] === "" && h.shift(), h.length && h[h.length - 1] === "" && h.pop(), d = h.length, d === 0 || d !== p.length))
    return !1;
  if (r)
    return !0;
  for (y = e.parentType, e.parentType = "table", w = e.md.block.ruler.getRules("blockquote"), f = e.push("table_open", "table", 1), f.map = m = [t, 0], f = e.push("thead_open", "thead", 1), f.map = [t, t + 1], f = e.push("tr_open", "tr", 1), f.map = [t, t + 1], l = 0; l < h.length; l++)
    f = e.push("th_open", "th", 1), p[l] && (f.attrs = [["style", "text-align:" + p[l]]]), f = e.push("inline", "", 0), f.content = h[l].trim(), f.children = [], f = e.push("th_close", "th", -1);
  for (f = e.push("tr_close", "tr", -1), f = e.push("thead_close", "thead", -1), u = t + 2; u < i && !(e.sCount[u] < e.blkIndent); u++) {
    for (b = !1, l = 0, c = w.length; l < c; l++)
      if (w[l](e, u, i, !0)) {
        b = !0;
        break;
      }
    if (b || (o = wb(e, u).trim(), !o) || e.sCount[u] - e.blkIndent >= 4)
      break;
    for (h = yE(o), h.length && h[0] === "" && h.shift(), h.length && h[h.length - 1] === "" && h.pop(), u === t + 2 && (f = e.push("tbody_open", "tbody", 1), f.map = v = [t + 2, 0]), f = e.push("tr_open", "tr", 1), f.map = [u, u + 1], l = 0; l < d; l++)
      f = e.push("td_open", "td", 1), p[l] && (f.attrs = [["style", "text-align:" + p[l]]]), f = e.push("inline", "", 0), f.content = h[l] ? h[l].trim() : "", f.children = [], f = e.push("td_close", "td", -1);
    f = e.push("tr_close", "tr", -1);
  }
  return v && (f = e.push("tbody_close", "tbody", -1), v[1] = u), f = e.push("table_close", "table", -1), m[1] = u, e.parentType = y, e.line = u, !0;
}, K7e = function(e, t, i) {
  var r, s, o;
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  for (s = r = t + 1; r < i; ) {
    if (e.isEmpty(r)) {
      r++;
      continue;
    }
    if (e.sCount[r] - e.blkIndent >= 4) {
      r++, s = r;
      continue;
    }
    break;
  }
  return e.line = s, o = e.push("code_block", "code", 0), o.content = e.getLines(t, s, 4 + e.blkIndent, !1) + `
`, o.map = [t, e.line], !0;
}, J7e = function(e, t, i, r) {
  var s, o, a, l, c, u, h, d = !1, f = e.bMarks[t] + e.tShift[t], p = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || f + 3 > p || (s = e.src.charCodeAt(f), s !== 126 && s !== 96) || (c = f, f = e.skipChars(f, s), o = f - c, o < 3) || (h = e.src.slice(c, f), a = e.src.slice(f, p), s === 96 && a.indexOf(String.fromCharCode(s)) >= 0))
    return !1;
  if (r)
    return !0;
  for (l = t; l++, !(l >= i || (f = c = e.bMarks[l] + e.tShift[l], p = e.eMarks[l], f < p && e.sCount[l] < e.blkIndent)); )
    if (e.src.charCodeAt(f) === s && !(e.sCount[l] - e.blkIndent >= 4) && (f = e.skipChars(f, s), !(f - c < o) && (f = e.skipSpaces(f), !(f < p)))) {
      d = !0;
      break;
    }
  return o = e.sCount[t], e.line = l + (d ? 1 : 0), u = e.push("fence", "code", 0), u.info = a, u.content = e.getLines(t + 1, l, o, !0), u.markup = h, u.map = [t, e.line], !0;
}, e9e = Nt.isSpace, t9e = function(e, t, i, r) {
  var s, o, a, l, c, u, h, d, f, p, g, m, v, y, b, w, x, S, C, k, E = e.lineMax, M = e.bMarks[t] + e.tShift[t], _ = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(M) !== 62)
    return !1;
  if (r)
    return !0;
  for (p = [], g = [], y = [], b = [], S = e.md.block.ruler.getRules("blockquote"), v = e.parentType, e.parentType = "blockquote", d = t; d < i && (k = e.sCount[d] < e.blkIndent, M = e.bMarks[d] + e.tShift[d], _ = e.eMarks[d], !(M >= _)); d++) {
    if (e.src.charCodeAt(M++) === 62 && !k) {
      for (l = e.sCount[d] + 1, e.src.charCodeAt(M) === 32 ? (M++, l++, s = !1, w = !0) : e.src.charCodeAt(M) === 9 ? (w = !0, (e.bsCount[d] + l) % 4 === 3 ? (M++, l++, s = !1) : s = !0) : w = !1, f = l, p.push(e.bMarks[d]), e.bMarks[d] = M; M < _ && (o = e.src.charCodeAt(M), e9e(o)); ) {
        o === 9 ? f += 4 - (f + e.bsCount[d] + (s ? 1 : 0)) % 4 : f++;
        M++;
      }
      u = M >= _, g.push(e.bsCount[d]), e.bsCount[d] = e.sCount[d] + 1 + (w ? 1 : 0), y.push(e.sCount[d]), e.sCount[d] = f - l, b.push(e.tShift[d]), e.tShift[d] = M - e.bMarks[d];
      continue;
    }
    if (u)
      break;
    for (x = !1, a = 0, c = S.length; a < c; a++)
      if (S[a](e, d, i, !0)) {
        x = !0;
        break;
      }
    if (x) {
      e.lineMax = d, e.blkIndent !== 0 && (p.push(e.bMarks[d]), g.push(e.bsCount[d]), b.push(e.tShift[d]), y.push(e.sCount[d]), e.sCount[d] -= e.blkIndent);
      break;
    }
    p.push(e.bMarks[d]), g.push(e.bsCount[d]), b.push(e.tShift[d]), y.push(e.sCount[d]), e.sCount[d] = -1;
  }
  for (m = e.blkIndent, e.blkIndent = 0, C = e.push("blockquote_open", "blockquote", 1), C.markup = ">", C.map = h = [t, 0], e.md.block.tokenize(e, t, d), C = e.push("blockquote_close", "blockquote", -1), C.markup = ">", e.lineMax = E, e.parentType = v, h[1] = e.line, a = 0; a < b.length; a++)
    e.bMarks[a + t] = p[a], e.tShift[a + t] = b[a], e.sCount[a + t] = y[a], e.bsCount[a + t] = g[a];
  return e.blkIndent = m, !0;
}, n9e = Nt.isSpace, i9e = function(e, t, i, r) {
  var s, o, a, l, c = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(c++), s !== 42 && s !== 45 && s !== 95))
    return !1;
  for (o = 1; c < u; ) {
    if (a = e.src.charCodeAt(c++), a !== s && !n9e(a))
      return !1;
    a === s && o++;
  }
  return o < 3 ? !1 : (r || (e.line = t + 1, l = e.push("hr", "hr", 0), l.map = [t, e.line], l.markup = Array(o + 1).join(String.fromCharCode(s))), !0);
}, d4 = Nt.isSpace;
function OE(n, e) {
  var t, i, r, s;
  return i = n.bMarks[e] + n.tShift[e], r = n.eMarks[e], t = n.src.charCodeAt(i++), t !== 42 && t !== 45 && t !== 43 || i < r && (s = n.src.charCodeAt(i), !d4(s)) ? -1 : i;
}
function wE(n, e) {
  var t, i = n.bMarks[e] + n.tShift[e], r = i, s = n.eMarks[e];
  if (r + 1 >= s || (t = n.src.charCodeAt(r++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (r >= s)
      return -1;
    if (t = n.src.charCodeAt(r++), t >= 48 && t <= 57) {
      if (r - i >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return r < s && (t = n.src.charCodeAt(r), !d4(t)) ? -1 : r;
}
function r9e(n, e) {
  var t, i, r = n.level + 2;
  for (t = e + 2, i = n.tokens.length - 2; t < i; t++)
    n.tokens[t].level === r && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = !0, n.tokens[t].hidden = !0, t += 2);
}
var s9e = function(e, t, i, r) {
  var s, o, a, l, c, u, h, d, f, p, g, m, v, y, b, w, x, S, C, k, E, M, _, T, B, I, P, A = t, N = !1, q = !0;
  if (e.sCount[A] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[A] - e.listIndent >= 4 && e.sCount[A] < e.blkIndent)
    return !1;
  if (r && e.parentType === "paragraph" && e.sCount[A] >= e.blkIndent && (N = !0), (M = wE(e, A)) >= 0) {
    if (h = !0, T = e.bMarks[A] + e.tShift[A], v = Number(e.src.slice(T, M - 1)), N && v !== 1)
      return !1;
  } else if ((M = OE(e, A)) >= 0)
    h = !1;
  else
    return !1;
  if (N && e.skipSpaces(M) >= e.eMarks[A])
    return !1;
  if (r)
    return !0;
  for (m = e.src.charCodeAt(M - 1), g = e.tokens.length, h ? (P = e.push("ordered_list_open", "ol", 1), v !== 1 && (P.attrs = [["start", v]])) : P = e.push("bullet_list_open", "ul", 1), P.map = p = [A, 0], P.markup = String.fromCharCode(m), _ = !1, I = e.md.block.ruler.getRules("list"), x = e.parentType, e.parentType = "list"; A < i; ) {
    for (E = M, y = e.eMarks[A], u = b = e.sCount[A] + M - (e.bMarks[A] + e.tShift[A]); E < y; ) {
      if (s = e.src.charCodeAt(E), s === 9)
        b += 4 - (b + e.bsCount[A]) % 4;
      else if (s === 32)
        b++;
      else
        break;
      E++;
    }
    if (o = E, o >= y ? c = 1 : c = b - u, c > 4 && (c = 1), l = u + c, P = e.push("list_item_open", "li", 1), P.markup = String.fromCharCode(m), P.map = d = [A, 0], h && (P.info = e.src.slice(T, M - 1)), k = e.tight, C = e.tShift[A], S = e.sCount[A], w = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = l, e.tight = !0, e.tShift[A] = o - e.bMarks[A], e.sCount[A] = b, o >= y && e.isEmpty(A + 1) ? e.line = Math.min(e.line + 2, i) : e.md.block.tokenize(e, A, i, !0), (!e.tight || _) && (q = !1), _ = e.line - A > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = w, e.tShift[A] = C, e.sCount[A] = S, e.tight = k, P = e.push("list_item_close", "li", -1), P.markup = String.fromCharCode(m), A = e.line, d[1] = A, A >= i || e.sCount[A] < e.blkIndent || e.sCount[A] - e.blkIndent >= 4)
      break;
    for (B = !1, a = 0, f = I.length; a < f; a++)
      if (I[a](e, A, i, !0)) {
        B = !0;
        break;
      }
    if (B)
      break;
    if (h) {
      if (M = wE(e, A), M < 0)
        break;
      T = e.bMarks[A] + e.tShift[A];
    } else if (M = OE(e, A), M < 0)
      break;
    if (m !== e.src.charCodeAt(M - 1))
      break;
  }
  return h ? P = e.push("ordered_list_close", "ol", -1) : P = e.push("bullet_list_close", "ul", -1), P.markup = String.fromCharCode(m), p[1] = A, e.line = A, e.parentType = x, q && r9e(e, g), !0;
}, o9e = Nt.normalizeReference, Zp = Nt.isSpace, a9e = function(e, t, i, r) {
  var s, o, a, l, c, u, h, d, f, p, g, m, v, y, b, w, x = 0, S = e.bMarks[t] + e.tShift[t], C = e.eMarks[t], k = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(S) !== 91)
    return !1;
  for (; ++S < C; )
    if (e.src.charCodeAt(S) === 93 && e.src.charCodeAt(S - 1) !== 92) {
      if (S + 1 === C || e.src.charCodeAt(S + 1) !== 58)
        return !1;
      break;
    }
  for (l = e.lineMax, b = e.md.block.ruler.getRules("reference"), p = e.parentType, e.parentType = "reference"; k < l && !e.isEmpty(k); k++)
    if (!(e.sCount[k] - e.blkIndent > 3) && !(e.sCount[k] < 0)) {
      for (y = !1, u = 0, h = b.length; u < h; u++)
        if (b[u](e, k, l, !0)) {
          y = !0;
          break;
        }
      if (y)
        break;
    }
  for (v = e.getLines(t, k, e.blkIndent, !1).trim(), C = v.length, S = 1; S < C; S++) {
    if (s = v.charCodeAt(S), s === 91)
      return !1;
    if (s === 93) {
      f = S;
      break;
    } else
      s === 10 ? x++ : s === 92 && (S++, S < C && v.charCodeAt(S) === 10 && x++);
  }
  if (f < 0 || v.charCodeAt(f + 1) !== 58)
    return !1;
  for (S = f + 2; S < C; S++)
    if (s = v.charCodeAt(S), s === 10)
      x++;
    else if (!Zp(s))
      break;
  if (g = e.md.helpers.parseLinkDestination(v, S, C), !g.ok || (c = e.md.normalizeLink(g.str), !e.md.validateLink(c)))
    return !1;
  for (S = g.pos, x += g.lines, o = S, a = x, m = S; S < C; S++)
    if (s = v.charCodeAt(S), s === 10)
      x++;
    else if (!Zp(s))
      break;
  for (g = e.md.helpers.parseLinkTitle(v, S, C), S < C && m !== S && g.ok ? (w = g.str, S = g.pos, x += g.lines) : (w = "", S = o, x = a); S < C && (s = v.charCodeAt(S), !!Zp(s)); )
    S++;
  if (S < C && v.charCodeAt(S) !== 10 && w)
    for (w = "", S = o, x = a; S < C && (s = v.charCodeAt(S), !!Zp(s)); )
      S++;
  return S < C && v.charCodeAt(S) !== 10 || (d = o9e(v.slice(1, f)), !d) ? !1 : (r || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[d] > "u" && (e.env.references[d] = { title: w, href: c }), e.parentType = p, e.line = t + x + 1), !0);
}, l9e = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], n0 = {}, c9e = "[a-zA-Z_:][a-zA-Z0-9:._-]*", u9e = "[^\"'=<>`\\x00-\\x20]+", h9e = "'[^']*'", d9e = '"[^"]*"', f9e = "(?:" + u9e + "|" + h9e + "|" + d9e + ")", p9e = "(?:\\s+" + c9e + "(?:\\s*=\\s*" + f9e + ")?)", f4 = "<[A-Za-z][A-Za-z0-9\\-]*" + p9e + "*\\s*\\/?>", p4 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", g9e = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", m9e = "<[?][\\s\\S]*?[?]>", v9e = "<![A-Z]+\\s+[^>]*>", b9e = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", y9e = new RegExp("^(?:" + f4 + "|" + p4 + "|" + g9e + "|" + m9e + "|" + v9e + "|" + b9e + ")"), O9e = new RegExp("^(?:" + f4 + "|" + p4 + ")");
n0.HTML_TAG_RE = y9e;
n0.HTML_OPEN_CLOSE_TAG_RE = O9e;
var w9e = l9e, x9e = n0.HTML_OPEN_CLOSE_TAG_RE, Ec = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + w9e.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(x9e.source + "\\s*$"), /^$/, !1]
], S9e = function(e, t, i, r) {
  var s, o, a, l, c = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(c) !== 60)
    return !1;
  for (l = e.src.slice(c, u), s = 0; s < Ec.length && !Ec[s][0].test(l); s++)
    ;
  if (s === Ec.length)
    return !1;
  if (r)
    return Ec[s][2];
  if (o = t + 1, !Ec[s][1].test(l)) {
    for (; o < i && !(e.sCount[o] < e.blkIndent); o++)
      if (c = e.bMarks[o] + e.tShift[o], u = e.eMarks[o], l = e.src.slice(c, u), Ec[s][1].test(l)) {
        l.length !== 0 && o++;
        break;
      }
  }
  return e.line = o, a = e.push("html_block", "", 0), a.map = [t, o], a.content = e.getLines(t, o, e.blkIndent, !0), !0;
}, xE = Nt.isSpace, C9e = function(e, t, i, r) {
  var s, o, a, l, c = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(c), s !== 35 || c >= u))
    return !1;
  for (o = 1, s = e.src.charCodeAt(++c); s === 35 && c < u && o <= 6; )
    o++, s = e.src.charCodeAt(++c);
  return o > 6 || c < u && !xE(s) ? !1 : (r || (u = e.skipSpacesBack(u, c), a = e.skipCharsBack(u, 35, c), a > c && xE(e.src.charCodeAt(a - 1)) && (u = a), e.line = t + 1, l = e.push("heading_open", "h" + String(o), 1), l.markup = "########".slice(0, o), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = e.src.slice(c, u).trim(), l.map = [t, e.line], l.children = [], l = e.push("heading_close", "h" + String(o), -1), l.markup = "########".slice(0, o)), !0);
}, k9e = function(e, t, i) {
  var r, s, o, a, l, c, u, h, d, f = t + 1, p, g = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  for (p = e.parentType, e.parentType = "paragraph"; f < i && !e.isEmpty(f); f++)
    if (!(e.sCount[f] - e.blkIndent > 3)) {
      if (e.sCount[f] >= e.blkIndent && (c = e.bMarks[f] + e.tShift[f], u = e.eMarks[f], c < u && (d = e.src.charCodeAt(c), (d === 45 || d === 61) && (c = e.skipChars(c, d), c = e.skipSpaces(c), c >= u)))) {
        h = d === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[f] < 0)) {
        for (s = !1, o = 0, a = g.length; o < a; o++)
          if (g[o](e, f, i, !0)) {
            s = !0;
            break;
          }
        if (s)
          break;
      }
    }
  return h ? (r = e.getLines(t, f, e.blkIndent, !1).trim(), e.line = f + 1, l = e.push("heading_open", "h" + String(h), 1), l.markup = String.fromCharCode(d), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = r, l.map = [t, e.line - 1], l.children = [], l = e.push("heading_close", "h" + String(h), -1), l.markup = String.fromCharCode(d), e.parentType = p, !0) : !1;
}, P9e = function(e, t, i) {
  var r, s, o, a, l, c, u = t + 1, h = e.md.block.ruler.getRules("paragraph");
  for (c = e.parentType, e.parentType = "paragraph"; u < i && !e.isEmpty(u); u++)
    if (!(e.sCount[u] - e.blkIndent > 3) && !(e.sCount[u] < 0)) {
      for (s = !1, o = 0, a = h.length; o < a; o++)
        if (h[o](e, u, i, !0)) {
          s = !0;
          break;
        }
      if (s)
        break;
    }
  return r = e.getLines(t, u, e.blkIndent, !1).trim(), e.line = u, l = e.push("paragraph_open", "p", 1), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = r, l.map = [t, e.line], l.children = [], l = e.push("paragraph_close", "p", -1), e.parentType = c, !0;
}, g4 = zx, i0 = Nt.isSpace;
function So(n, e, t, i) {
  var r, s, o, a, l, c, u, h;
  for (this.src = n, this.md = e, this.env = t, this.tokens = i, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, h = !1, o = a = c = u = 0, l = s.length; a < l; a++) {
    if (r = s.charCodeAt(a), !h)
      if (i0(r)) {
        c++, r === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        h = !0;
    (r === 10 || a === l - 1) && (r !== 10 && a++, this.bMarks.push(o), this.eMarks.push(a), this.tShift.push(c), this.sCount.push(u), this.bsCount.push(0), h = !1, c = 0, u = 0, o = a + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
So.prototype.push = function(n, e, t) {
  var i = new g4(n, e, t);
  return i.block = !0, t < 0 && this.level--, i.level = this.level, t > 0 && this.level++, this.tokens.push(i), i;
};
So.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
So.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
So.prototype.skipSpaces = function(e) {
  for (var t, i = this.src.length; e < i && (t = this.src.charCodeAt(e), !!i0(t)); e++)
    ;
  return e;
};
So.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!i0(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
So.prototype.skipChars = function(e, t) {
  for (var i = this.src.length; e < i && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
So.prototype.skipCharsBack = function(e, t, i) {
  if (e <= i)
    return e;
  for (; e > i; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
So.prototype.getLines = function(e, t, i, r) {
  var s, o, a, l, c, u, h, d = e;
  if (e >= t)
    return "";
  for (u = new Array(t - e), s = 0; d < t; d++, s++) {
    for (o = 0, h = l = this.bMarks[d], d + 1 < t || r ? c = this.eMarks[d] + 1 : c = this.eMarks[d]; l < c && o < i; ) {
      if (a = this.src.charCodeAt(l), i0(a))
        a === 9 ? o += 4 - (o + this.bsCount[d]) % 4 : o++;
      else if (l - h < this.tShift[d])
        o++;
      else
        break;
      l++;
    }
    o > i ? u[s] = new Array(o - i + 1).join(" ") + this.src.slice(l, c) : u[s] = this.src.slice(l, c);
  }
  return u.join("");
};
So.prototype.Token = g4;
var E9e = So, A9e = Qx, qp = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", G7e, ["paragraph", "reference"]],
  ["code", K7e],
  ["fence", J7e, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", t9e, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", i9e, ["paragraph", "reference", "blockquote", "list"]],
  ["list", s9e, ["paragraph", "reference", "blockquote"]],
  ["reference", a9e],
  ["html_block", S9e, ["paragraph", "reference", "blockquote"]],
  ["heading", C9e, ["paragraph", "reference", "blockquote"]],
  ["lheading", k9e],
  ["paragraph", P9e]
];
function r0() {
  this.ruler = new A9e();
  for (var n = 0; n < qp.length; n++)
    this.ruler.push(qp[n][0], qp[n][1], { alt: (qp[n][2] || []).slice() });
}
r0.prototype.tokenize = function(n, e, t) {
  for (var i, r, s, o = this.ruler.getRules(""), a = o.length, l = e, c = !1, u = n.md.options.maxNesting; l < t && (n.line = l = n.skipEmptyLines(l), !(l >= t || n.sCount[l] < n.blkIndent)); ) {
    if (n.level >= u) {
      n.line = t;
      break;
    }
    for (s = n.line, r = 0; r < a; r++)
      if (i = o[r](n, l, t, !1), i) {
        if (s >= n.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!i)
      throw new Error("none of the block rules matched");
    n.tight = !c, n.isEmpty(n.line - 1) && (c = !0), l = n.line, l < t && n.isEmpty(l) && (c = !0, l++, n.line = l);
  }
};
r0.prototype.parse = function(n, e, t, i) {
  var r;
  n && (r = new this.State(n, e, t, i), this.tokenize(r, r.line, r.lineMax));
};
r0.prototype.State = E9e;
var $9e = r0;
function T9e(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var _9e = function(e, t) {
  for (var i = e.pos; i < e.posMax && !T9e(e.src.charCodeAt(i)); )
    i++;
  return i === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, i)), e.pos = i, !0);
}, M9e = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i, R9e = function(e, t) {
  var i, r, s, o, a, l, c, u;
  return !e.md.options.linkify || e.linkLevel > 0 || (i = e.pos, r = e.posMax, i + 3 > r) || e.src.charCodeAt(i) !== 58 || e.src.charCodeAt(i + 1) !== 47 || e.src.charCodeAt(i + 2) !== 47 || (s = e.pending.match(M9e), !s) || (o = s[1], a = e.md.linkify.matchAtStart(e.src.slice(i - o.length)), !a) || (l = a.url, l.length <= o.length) || (l = l.replace(/\*+$/, ""), c = e.md.normalizeLink(l), !e.md.validateLink(c)) ? !1 : (t || (e.pending = e.pending.slice(0, -o.length), u = e.push("link_open", "a", 1), u.attrs = [["href", c]], u.markup = "linkify", u.info = "auto", u = e.push("text", "", 0), u.content = e.md.normalizeLinkText(l), u = e.push("link_close", "a", -1), u.markup = "linkify", u.info = "auto"), e.pos += l.length - o.length, !0);
}, N9e = Nt.isSpace, D9e = function(e, t) {
  var i, r, s, o = e.pos;
  if (e.src.charCodeAt(o) !== 10)
    return !1;
  if (i = e.pending.length - 1, r = e.posMax, !t)
    if (i >= 0 && e.pending.charCodeAt(i) === 32)
      if (i >= 1 && e.pending.charCodeAt(i - 1) === 32) {
        for (s = i - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (o++; o < r && N9e(e.src.charCodeAt(o)); )
    o++;
  return e.pos = o, !0;
}, L9e = Nt.isSpace, Vx = [];
for (var SE = 0; SE < 256; SE++)
  Vx.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  Vx[n.charCodeAt(0)] = 1;
});
var I9e = function(e, t) {
  var i, r, s, o, a, l = e.pos, c = e.posMax;
  if (e.src.charCodeAt(l) !== 92 || (l++, l >= c))
    return !1;
  if (i = e.src.charCodeAt(l), i === 10) {
    for (t || e.push("hardbreak", "br", 0), l++; l < c && (i = e.src.charCodeAt(l), !!L9e(i)); )
      l++;
    return e.pos = l, !0;
  }
  return o = e.src[l], i >= 55296 && i <= 56319 && l + 1 < c && (r = e.src.charCodeAt(l + 1), r >= 56320 && r <= 57343 && (o += e.src[l + 1], l++)), s = "\\" + o, t || (a = e.push("text_special", "", 0), i < 256 && Vx[i] !== 0 ? a.content = o : a.content = s, a.markup = s, a.info = "escape"), e.pos = l + 1, !0;
}, B9e = function(e, t) {
  var i, r, s, o, a, l, c, u, h = e.pos, d = e.src.charCodeAt(h);
  if (d !== 96)
    return !1;
  for (i = h, h++, r = e.posMax; h < r && e.src.charCodeAt(h) === 96; )
    h++;
  if (s = e.src.slice(i, h), c = s.length, e.backticksScanned && (e.backticks[c] || 0) <= i)
    return t || (e.pending += s), e.pos += c, !0;
  for (l = h; (a = e.src.indexOf("`", l)) !== -1; ) {
    for (l = a + 1; l < r && e.src.charCodeAt(l) === 96; )
      l++;
    if (u = l - a, u === c)
      return t || (o = e.push("code_inline", "code", 0), o.markup = s, o.content = e.src.slice(h, a).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = l, !0;
    e.backticks[u] = a;
  }
  return e.backticksScanned = !0, t || (e.pending += s), e.pos += c, !0;
}, s0 = {};
s0.tokenize = function(e, t) {
  var i, r, s, o, a, l = e.pos, c = e.src.charCodeAt(l);
  if (t || c !== 126 || (r = e.scanDelims(e.pos, !0), o = r.length, a = String.fromCharCode(c), o < 2))
    return !1;
  for (o % 2 && (s = e.push("text", "", 0), s.content = a, o--), i = 0; i < o; i += 2)
    s = e.push("text", "", 0), s.content = a + a, e.delimiters.push({
      marker: c,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
};
function CE(n, e) {
  var t, i, r, s, o, a = [], l = e.length;
  for (t = 0; t < l; t++)
    r = e[t], r.marker === 126 && r.end !== -1 && (s = e[r.end], o = n.tokens[r.token], o.type = "s_open", o.tag = "s", o.nesting = 1, o.markup = "~~", o.content = "", o = n.tokens[s.token], o.type = "s_close", o.tag = "s", o.nesting = -1, o.markup = "~~", o.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && a.push(s.token - 1));
  for (; a.length; ) {
    for (t = a.pop(), i = t + 1; i < n.tokens.length && n.tokens[i].type === "s_close"; )
      i++;
    i--, t !== i && (o = n.tokens[i], n.tokens[i] = n.tokens[t], n.tokens[t] = o);
  }
}
s0.postProcess = function(e) {
  var t, i = e.tokens_meta, r = e.tokens_meta.length;
  for (CE(e, e.delimiters), t = 0; t < r; t++)
    i[t] && i[t].delimiters && CE(e, i[t].delimiters);
};
var o0 = {};
o0.tokenize = function(e, t) {
  var i, r, s, o = e.pos, a = e.src.charCodeAt(o);
  if (t || a !== 95 && a !== 42)
    return !1;
  for (r = e.scanDelims(e.pos, a === 42), i = 0; i < r.length; i++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(a), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: a,
      // Total length of these series of delimiters.
      //
      length: r.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
};
function kE(n, e) {
  var t, i, r, s, o, a, l = e.length;
  for (t = l - 1; t >= 0; t--)
    i = e[t], !(i.marker !== 95 && i.marker !== 42) && i.end !== -1 && (r = e[i.end], a = t > 0 && e[t - 1].end === i.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === i.marker && e[t - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[i.end + 1].token === r.token + 1, o = String.fromCharCode(i.marker), s = n.tokens[i.token], s.type = a ? "strong_open" : "em_open", s.tag = a ? "strong" : "em", s.nesting = 1, s.markup = a ? o + o : o, s.content = "", s = n.tokens[r.token], s.type = a ? "strong_close" : "em_close", s.tag = a ? "strong" : "em", s.nesting = -1, s.markup = a ? o + o : o, s.content = "", a && (n.tokens[e[t - 1].token].content = "", n.tokens[e[i.end + 1].token].content = "", t--));
}
o0.postProcess = function(e) {
  var t, i = e.tokens_meta, r = e.tokens_meta.length;
  for (kE(e, e.delimiters), t = 0; t < r; t++)
    i[t] && i[t].delimiters && kE(e, i[t].delimiters);
};
var Q9e = Nt.normalizeReference, xb = Nt.isSpace, z9e = function(e, t) {
  var i, r, s, o, a, l, c, u, h, d = "", f = "", p = e.pos, g = e.posMax, m = e.pos, v = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (a = e.pos + 1, o = e.md.helpers.parseLinkLabel(e, e.pos, !0), o < 0))
    return !1;
  if (l = o + 1, l < g && e.src.charCodeAt(l) === 40) {
    for (v = !1, l++; l < g && (r = e.src.charCodeAt(l), !(!xb(r) && r !== 10)); l++)
      ;
    if (l >= g)
      return !1;
    if (m = l, c = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), c.ok) {
      for (d = e.md.normalizeLink(c.str), e.md.validateLink(d) ? l = c.pos : d = "", m = l; l < g && (r = e.src.charCodeAt(l), !(!xb(r) && r !== 10)); l++)
        ;
      if (c = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < g && m !== l && c.ok)
        for (f = c.str, l = c.pos; l < g && (r = e.src.charCodeAt(l), !(!xb(r) && r !== 10)); l++)
          ;
    }
    (l >= g || e.src.charCodeAt(l) !== 41) && (v = !0), l++;
  }
  if (v) {
    if (typeof e.env.references > "u")
      return !1;
    if (l < g && e.src.charCodeAt(l) === 91 ? (m = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? s = e.src.slice(m, l++) : l = o + 1) : l = o + 1, s || (s = e.src.slice(a, o)), u = e.env.references[Q9e(s)], !u)
      return e.pos = p, !1;
    d = u.href, f = u.title;
  }
  return t || (e.pos = a, e.posMax = o, h = e.push("link_open", "a", 1), h.attrs = i = [["href", d]], f && i.push(["title", f]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, h = e.push("link_close", "a", -1)), e.pos = l, e.posMax = g, !0;
}, j9e = Nt.normalizeReference, Sb = Nt.isSpace, V9e = function(e, t) {
  var i, r, s, o, a, l, c, u, h, d, f, p, g, m = "", v = e.pos, y = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (l = e.pos + 2, a = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), a < 0))
    return !1;
  if (c = a + 1, c < y && e.src.charCodeAt(c) === 40) {
    for (c++; c < y && (r = e.src.charCodeAt(c), !(!Sb(r) && r !== 10)); c++)
      ;
    if (c >= y)
      return !1;
    for (g = c, h = e.md.helpers.parseLinkDestination(e.src, c, e.posMax), h.ok && (m = e.md.normalizeLink(h.str), e.md.validateLink(m) ? c = h.pos : m = ""), g = c; c < y && (r = e.src.charCodeAt(c), !(!Sb(r) && r !== 10)); c++)
      ;
    if (h = e.md.helpers.parseLinkTitle(e.src, c, e.posMax), c < y && g !== c && h.ok)
      for (d = h.str, c = h.pos; c < y && (r = e.src.charCodeAt(c), !(!Sb(r) && r !== 10)); c++)
        ;
    else
      d = "";
    if (c >= y || e.src.charCodeAt(c) !== 41)
      return e.pos = v, !1;
    c++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (c < y && e.src.charCodeAt(c) === 91 ? (g = c + 1, c = e.md.helpers.parseLinkLabel(e, c), c >= 0 ? o = e.src.slice(g, c++) : c = a + 1) : c = a + 1, o || (o = e.src.slice(l, a)), u = e.env.references[j9e(o)], !u)
      return e.pos = v, !1;
    m = u.href, d = u.title;
  }
  return t || (s = e.src.slice(l, a), e.md.inline.parse(
    s,
    e.md,
    e.env,
    p = []
  ), f = e.push("image", "img", 0), f.attrs = i = [["src", m], ["alt", ""]], f.children = p, f.content = s, d && i.push(["title", d])), e.pos = c, e.posMax = y, !0;
}, F9e = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, Z9e = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, q9e = function(e, t) {
  var i, r, s, o, a, l, c = e.pos;
  if (e.src.charCodeAt(c) !== 60)
    return !1;
  for (a = e.pos, l = e.posMax; ; ) {
    if (++c >= l || (o = e.src.charCodeAt(c), o === 60))
      return !1;
    if (o === 62)
      break;
  }
  return i = e.src.slice(a + 1, c), Z9e.test(i) ? (r = e.md.normalizeLink(i), e.md.validateLink(r) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", r]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(i), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += i.length + 2, !0) : !1) : F9e.test(i) ? (r = e.md.normalizeLink("mailto:" + i), e.md.validateLink(r) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", r]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(i), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += i.length + 2, !0) : !1) : !1;
}, W9e = n0.HTML_TAG_RE;
function H9e(n) {
  return /^<a[>\s]/i.test(n);
}
function X9e(n) {
  return /^<\/a\s*>/i.test(n);
}
function Y9e(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var U9e = function(e, t) {
  var i, r, s, o, a = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(a) !== 60 || a + 2 >= s) || (i = e.src.charCodeAt(a + 1), i !== 33 && i !== 63 && i !== 47 && !Y9e(i)) || (r = e.src.slice(a).match(W9e), !r) ? !1 : (t || (o = e.push("html_inline", "", 0), o.content = r[0], H9e(o.content) && e.linkLevel++, X9e(o.content) && e.linkLevel--), e.pos += r[0].length, !0);
}, PE = o4, G9e = Nt.has, K9e = Nt.isValidEntityCode, EE = Nt.fromCodePoint, J9e = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, eWe = /^&([a-z][a-z0-9]{1,31});/i, tWe = function(e, t) {
  var i, r, s, o, a = e.pos, l = e.posMax;
  if (e.src.charCodeAt(a) !== 38 || a + 1 >= l)
    return !1;
  if (i = e.src.charCodeAt(a + 1), i === 35) {
    if (s = e.src.slice(a).match(J9e), s)
      return t || (r = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), o = e.push("text_special", "", 0), o.content = K9e(r) ? EE(r) : EE(65533), o.markup = s[0], o.info = "entity"), e.pos += s[0].length, !0;
  } else if (s = e.src.slice(a).match(eWe), s && G9e(PE, s[1]))
    return t || (o = e.push("text_special", "", 0), o.content = PE[s[1]], o.markup = s[0], o.info = "entity"), e.pos += s[0].length, !0;
  return !1;
};
function AE(n) {
  var e, t, i, r, s, o, a, l, c = {}, u = n.length;
  if (u) {
    var h = 0, d = -2, f = [];
    for (e = 0; e < u; e++)
      if (i = n[e], f.push(0), (n[h].marker !== i.marker || d !== i.token - 1) && (h = e), d = i.token, i.length = i.length || 0, !!i.close) {
        for (c.hasOwnProperty(i.marker) || (c[i.marker] = [-1, -1, -1, -1, -1, -1]), s = c[i.marker][(i.open ? 3 : 0) + i.length % 3], t = h - f[h] - 1, o = t; t > s; t -= f[t] + 1)
          if (r = n[t], r.marker === i.marker && r.open && r.end < 0 && (a = !1, (r.close || i.open) && (r.length + i.length) % 3 === 0 && (r.length % 3 !== 0 || i.length % 3 !== 0) && (a = !0), !a)) {
            l = t > 0 && !n[t - 1].open ? f[t - 1] + 1 : 0, f[e] = e - t + l, f[t] = l, i.open = !1, r.end = e, r.close = !1, o = -1, d = -2;
            break;
          }
        o !== -1 && (c[i.marker][(i.open ? 3 : 0) + (i.length || 0) % 3] = o);
      }
  }
}
var nWe = function(e) {
  var t, i = e.tokens_meta, r = e.tokens_meta.length;
  for (AE(e.delimiters), t = 0; t < r; t++)
    i[t] && i[t].delimiters && AE(i[t].delimiters);
}, iWe = function(e) {
  var t, i, r = 0, s = e.tokens, o = e.tokens.length;
  for (t = i = 0; t < o; t++)
    s[t].nesting < 0 && r--, s[t].level = r, s[t].nesting > 0 && r++, s[t].type === "text" && t + 1 < o && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== i && (s[i] = s[t]), i++);
  t !== i && (s.length = i);
}, Fx = zx, $E = Nt.isWhiteSpace, TE = Nt.isPunctChar, _E = Nt.isMdAsciiPunct;
function Wf(n, e, t, i) {
  this.src = n, this.env = t, this.md = e, this.tokens = i, this.tokens_meta = Array(i.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Wf.prototype.pushPending = function() {
  var n = new Fx("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
Wf.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var i = new Fx(n, e, t), r = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), i.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], r = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(i), this.tokens_meta.push(r), i;
};
Wf.prototype.scanDelims = function(n, e) {
  var t = n, i, r, s, o, a, l, c, u, h, d = !0, f = !0, p = this.posMax, g = this.src.charCodeAt(n);
  for (i = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < p && this.src.charCodeAt(t) === g; )
    t++;
  return s = t - n, r = t < p ? this.src.charCodeAt(t) : 32, c = _E(i) || TE(String.fromCharCode(i)), h = _E(r) || TE(String.fromCharCode(r)), l = $E(i), u = $E(r), u ? d = !1 : h && (l || c || (d = !1)), l ? f = !1 : c && (u || h || (f = !1)), e ? (o = d, a = f) : (o = d && (!f || c), a = f && (!d || h)), {
    can_open: o,
    can_close: a,
    length: s
  };
};
Wf.prototype.Token = Fx;
var rWe = Wf, ME = Qx, Cb = [
  ["text", _9e],
  ["linkify", R9e],
  ["newline", D9e],
  ["escape", I9e],
  ["backticks", B9e],
  ["strikethrough", s0.tokenize],
  ["emphasis", o0.tokenize],
  ["link", z9e],
  ["image", V9e],
  ["autolink", q9e],
  ["html_inline", U9e],
  ["entity", tWe]
], kb = [
  ["balance_pairs", nWe],
  ["strikethrough", s0.postProcess],
  ["emphasis", o0.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", iWe]
];
function Hf() {
  var n;
  for (this.ruler = new ME(), n = 0; n < Cb.length; n++)
    this.ruler.push(Cb[n][0], Cb[n][1]);
  for (this.ruler2 = new ME(), n = 0; n < kb.length; n++)
    this.ruler2.push(kb[n][0], kb[n][1]);
}
Hf.prototype.skipToken = function(n) {
  var e, t, i = n.pos, r = this.ruler.getRules(""), s = r.length, o = n.md.options.maxNesting, a = n.cache;
  if (typeof a[i] < "u") {
    n.pos = a[i];
    return;
  }
  if (n.level < o) {
    for (t = 0; t < s; t++)
      if (n.level++, e = r[t](n, !0), n.level--, e) {
        if (i >= n.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    n.pos = n.posMax;
  e || n.pos++, a[i] = n.pos;
};
Hf.prototype.tokenize = function(n) {
  for (var e, t, i, r = this.ruler.getRules(""), s = r.length, o = n.posMax, a = n.md.options.maxNesting; n.pos < o; ) {
    if (i = n.pos, n.level < a) {
      for (t = 0; t < s; t++)
        if (e = r[t](n, !1), e) {
          if (i >= n.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (e) {
      if (n.pos >= o)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Hf.prototype.parse = function(n, e, t, i) {
  var r, s, o, a = new this.State(n, e, t, i);
  for (this.tokenize(a), s = this.ruler2.getRules(""), o = s.length, r = 0; r < o; r++)
    s[r](a);
};
Hf.prototype.State = rWe;
var sWe = Hf, Pb, RE;
function oWe() {
  return RE || (RE = 1, Pb = function(n) {
    var e = {};
    n = n || {}, e.src_Any = a4().source, e.src_Cc = l4().source, e.src_Z = c4().source, e.src_P = Bx.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!" + (n["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Pb;
}
function e1(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(i) {
      n[i] = t[i];
    });
  }), n;
}
function a0(n) {
  return Object.prototype.toString.call(n);
}
function aWe(n) {
  return a0(n) === "[object String]";
}
function lWe(n) {
  return a0(n) === "[object Object]";
}
function cWe(n) {
  return a0(n) === "[object RegExp]";
}
function NE(n) {
  return a0(n) === "[object Function]";
}
function uWe(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var m4 = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function hWe(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || m4.hasOwnProperty(t);
  }, !1);
}
var dWe = {
  "http:": {
    validate: function(n, e, t) {
      var i = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(i) ? i.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var i = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(i) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : i.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var i = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(i) ? i.match(t.re.mailto)[0].length : 0;
    }
  }
}, fWe = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", pWe = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function gWe(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function mWe(n) {
  return function(e, t) {
    var i = e.slice(t);
    return n.test(i) ? i.match(n)[0].length : 0;
  };
}
function DE() {
  return function(n, e) {
    e.normalize(n);
  };
}
function Fm(n) {
  var e = n.re = oWe()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(fWe), t.push(e.src_xn), e.src_tlds = t.join("|");
  function i(a) {
    return a.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(i(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(i(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(i(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(i(e.tpl_host_fuzzy_test), "i");
  var r = [];
  n.__compiled__ = {};
  function s(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(n.__schemas__).forEach(function(a) {
    var l = n.__schemas__[a];
    if (l !== null) {
      var c = { validate: null, link: null };
      if (n.__compiled__[a] = c, lWe(l)) {
        cWe(l.validate) ? c.validate = mWe(l.validate) : NE(l.validate) ? c.validate = l.validate : s(a, l), NE(l.normalize) ? c.normalize = l.normalize : l.normalize ? s(a, l) : c.normalize = DE();
        return;
      }
      if (aWe(l)) {
        r.push(a);
        return;
      }
      s(a, l);
    }
  }), r.forEach(function(a) {
    n.__compiled__[n.__schemas__[a]] && (n.__compiled__[a].validate = n.__compiled__[n.__schemas__[a]].validate, n.__compiled__[a].normalize = n.__compiled__[n.__schemas__[a]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: DE() };
  var o = Object.keys(n.__compiled__).filter(function(a) {
    return a.length > 0 && n.__compiled__[a];
  }).map(uWe).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + o + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + o + ")", "ig"), n.re.schema_at_start = RegExp("^" + n.re.schema_search.source, "i"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), gWe(n);
}
function vWe(n, e) {
  var t = n.__index__, i = n.__last_index__, r = n.__text_cache__.slice(t, i);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = i + e, this.raw = r, this.text = r, this.url = r;
}
function t1(n, e) {
  var t = new vWe(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function Tr(n, e) {
  if (!(this instanceof Tr))
    return new Tr(n, e);
  e || hWe(n) && (e = n, n = {}), this.__opts__ = e1({}, m4, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = e1({}, dWe, n), this.__compiled__ = {}, this.__tlds__ = pWe, this.__tlds_replaced__ = !1, this.re = {}, Fm(this);
}
Tr.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, Fm(this), this;
};
Tr.prototype.set = function(e) {
  return this.__opts__ = e1(this.__opts__, e), this;
};
Tr.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var t, i, r, s, o, a, l, c, u;
  if (this.re.schema_test.test(e)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (t = l.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, t[2], l.lastIndex), s) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (c = e.search(this.re.host_fuzzy_test), c >= 0 && (this.__index__ < 0 || c < this.__index__) && (i = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = i.index + i[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = i.index + i[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (r = e.match(this.re.email_fuzzy)) !== null && (o = r.index + r[1].length, a = r.index + r[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && a > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = a))), this.__index__ >= 0;
};
Tr.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
Tr.prototype.testSchemaAt = function(e, t, i) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, i, this) : 0;
};
Tr.prototype.match = function(e) {
  var t = 0, i = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (i.push(t1(this, t)), t = this.__last_index__);
  for (var r = t ? e.slice(t) : e; this.test(r); )
    i.push(t1(this, t)), r = r.slice(this.__last_index__), t += this.__last_index__;
  return i.length ? i : null;
};
Tr.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return null;
  var t = this.re.schema_at_start.exec(e);
  if (!t)
    return null;
  var i = this.testSchemaAt(e, t[2], t[0].length);
  return i ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + i, t1(this, 0)) : null;
};
Tr.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(i, r, s) {
    return i !== s[r - 1];
  }).reverse(), Fm(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, Fm(this), this);
};
Tr.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
Tr.prototype.onCompile = function() {
};
var bWe = Tr;
const nu = 2147483647, to = 36, Zx = 1, gf = 26, yWe = 38, OWe = 700, v4 = 72, b4 = 128, y4 = "-", wWe = /^xn--/, xWe = /[^\0-\x7F]/, SWe = /[\x2E\u3002\uFF0E\uFF61]/g, CWe = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Eb = to - Zx, no = Math.floor, Ab = String.fromCharCode;
function va(n) {
  throw new RangeError(CWe[n]);
}
function kWe(n, e) {
  const t = [];
  let i = n.length;
  for (; i--; )
    t[i] = e(n[i]);
  return t;
}
function O4(n, e) {
  const t = n.split("@");
  let i = "";
  t.length > 1 && (i = t[0] + "@", n = t[1]), n = n.replace(SWe, ".");
  const r = n.split("."), s = kWe(r, e).join(".");
  return i + s;
}
function qx(n) {
  const e = [];
  let t = 0;
  const i = n.length;
  for (; t < i; ) {
    const r = n.charCodeAt(t++);
    if (r >= 55296 && r <= 56319 && t < i) {
      const s = n.charCodeAt(t++);
      (s & 64512) == 56320 ? e.push(((r & 1023) << 10) + (s & 1023) + 65536) : (e.push(r), t--);
    } else
      e.push(r);
  }
  return e;
}
const w4 = (n) => String.fromCodePoint(...n), PWe = function(n) {
  return n >= 48 && n < 58 ? 26 + (n - 48) : n >= 65 && n < 91 ? n - 65 : n >= 97 && n < 123 ? n - 97 : to;
}, LE = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
}, x4 = function(n, e, t) {
  let i = 0;
  for (n = t ? no(n / OWe) : n >> 1, n += no(n / e); n > Eb * gf >> 1; i += to)
    n = no(n / Eb);
  return no(i + (Eb + 1) * n / (n + yWe));
}, Wx = function(n) {
  const e = [], t = n.length;
  let i = 0, r = b4, s = v4, o = n.lastIndexOf(y4);
  o < 0 && (o = 0);
  for (let a = 0; a < o; ++a)
    n.charCodeAt(a) >= 128 && va("not-basic"), e.push(n.charCodeAt(a));
  for (let a = o > 0 ? o + 1 : 0; a < t; ) {
    const l = i;
    for (let u = 1, h = to; ; h += to) {
      a >= t && va("invalid-input");
      const d = PWe(n.charCodeAt(a++));
      d >= to && va("invalid-input"), d > no((nu - i) / u) && va("overflow"), i += d * u;
      const f = h <= s ? Zx : h >= s + gf ? gf : h - s;
      if (d < f)
        break;
      const p = to - f;
      u > no(nu / p) && va("overflow"), u *= p;
    }
    const c = e.length + 1;
    s = x4(i - l, c, l == 0), no(i / c) > nu - r && va("overflow"), r += no(i / c), i %= c, e.splice(i++, 0, r);
  }
  return String.fromCodePoint(...e);
}, Hx = function(n) {
  const e = [];
  n = qx(n);
  const t = n.length;
  let i = b4, r = 0, s = v4;
  for (const l of n)
    l < 128 && e.push(Ab(l));
  const o = e.length;
  let a = o;
  for (o && e.push(y4); a < t; ) {
    let l = nu;
    for (const u of n)
      u >= i && u < l && (l = u);
    const c = a + 1;
    l - i > no((nu - r) / c) && va("overflow"), r += (l - i) * c, i = l;
    for (const u of n)
      if (u < i && ++r > nu && va("overflow"), u === i) {
        let h = r;
        for (let d = to; ; d += to) {
          const f = d <= s ? Zx : d >= s + gf ? gf : d - s;
          if (h < f)
            break;
          const p = h - f, g = to - f;
          e.push(
            Ab(LE(f + p % g, 0))
          ), h = no(p / g);
        }
        e.push(Ab(LE(h, 0))), s = x4(r, c, a === o), r = 0, ++a;
      }
    ++r, ++i;
  }
  return e.join("");
}, S4 = function(n) {
  return O4(n, function(e) {
    return wWe.test(e) ? Wx(e.slice(4).toLowerCase()) : e;
  });
}, C4 = function(n) {
  return O4(n, function(e) {
    return xWe.test(e) ? "xn--" + Hx(e) : e;
  });
}, EWe = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: qx,
    encode: w4
  },
  decode: Wx,
  encode: Hx,
  toASCII: C4,
  toUnicode: S4
}, AWe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Wx,
  default: EWe,
  encode: Hx,
  toASCII: C4,
  toUnicode: S4,
  ucs2decode: qx,
  ucs2encode: w4
}, Symbol.toStringTag, { value: "Module" })), $We = /* @__PURE__ */ lW(AWe);
var TWe = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, _We = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, MWe = {
  options: {
    html: !0,
    // Enable HTML tags in source
    xhtmlOut: !0,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, wd = Nt, RWe = t0, NWe = P7e, DWe = U7e, LWe = $9e, IWe = sWe, BWe = bWe, _l = xh, k4 = $We, QWe = {
  default: TWe,
  zero: _We,
  commonmark: MWe
}, zWe = /^(vbscript|javascript|file|data):/, jWe = /^data:image\/(gif|png|jpeg|webp);/;
function VWe(n) {
  var e = n.trim().toLowerCase();
  return zWe.test(e) ? !!jWe.test(e) : !0;
}
var P4 = ["http:", "https:", "mailto:"];
function FWe(n) {
  var e = _l.parse(n, !0);
  if (e.hostname && (!e.protocol || P4.indexOf(e.protocol) >= 0))
    try {
      e.hostname = k4.toASCII(e.hostname);
    } catch {
    }
  return _l.encode(_l.format(e));
}
function ZWe(n) {
  var e = _l.parse(n, !0);
  if (e.hostname && (!e.protocol || P4.indexOf(e.protocol) >= 0))
    try {
      e.hostname = k4.toUnicode(e.hostname);
    } catch {
    }
  return _l.decode(_l.format(e), _l.decode.defaultChars + "%");
}
function es(n, e) {
  if (!(this instanceof es))
    return new es(n, e);
  e || wd.isString(n) || (e = n || {}, n = "default"), this.inline = new IWe(), this.block = new LWe(), this.core = new DWe(), this.renderer = new NWe(), this.linkify = new BWe(), this.validateLink = VWe, this.normalizeLink = FWe, this.normalizeLinkText = ZWe, this.utils = wd, this.helpers = wd.assign({}, RWe), this.options = {}, this.configure(n), e && this.set(e);
}
es.prototype.set = function(n) {
  return wd.assign(this.options, n), this;
};
es.prototype.configure = function(n) {
  var e = this, t;
  if (wd.isString(n) && (t = n, n = QWe[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(i) {
    n.components[i].rules && e[i].ruler.enableOnly(n.components[i].rules), n.components[i].rules2 && e[i].ruler2.enableOnly(n.components[i].rules2);
  }), this;
};
es.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(r) {
    t = t.concat(this[r].ruler.enable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.enable(n, !0));
  var i = n.filter(function(r) {
    return t.indexOf(r) < 0;
  });
  if (i.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + i);
  return this;
};
es.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(r) {
    t = t.concat(this[r].ruler.disable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.disable(n, !0));
  var i = n.filter(function(r) {
    return t.indexOf(r) < 0;
  });
  if (i.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + i);
  return this;
};
es.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
es.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
es.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
es.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = !0, this.core.process(t), t.tokens;
};
es.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var qWe = es, WWe = qWe;
const HWe = /* @__PURE__ */ Mf(WWe), IE = /* @__PURE__ */ new Set([!0, !1, "alt", "title"]);
function E4(n, e) {
  return (Array.isArray(n) ? n : []).filter(([t]) => t !== e);
}
function A4(n, e) {
  n && n.attrs && (n.attrs = E4(n.attrs, e));
}
function XWe(n, e) {
  if (!IE.has(n))
    throw new TypeError(`figcaption must be one of: ${[...IE]}.`);
  if (n === "alt")
    return e.content;
  const t = e.attrs.find(([i]) => i === "title");
  return Array.isArray(t) && t[1] ? (A4(e, "title"), t[1]) : void 0;
}
function YWe(n, e) {
  e = e || {}, n.core.ruler.before("linkify", "image_figures", function(t) {
    let i = 1;
    for (let r = 1, s = t.tokens.length; r < s - 1; ++r) {
      const o = t.tokens[r];
      if (o.type !== "inline" || !o.children || o.children.length !== 1 && o.children.length !== 3 || o.children.length === 1 && o.children[0].type !== "image")
        continue;
      if (o.children.length === 3) {
        const [c, u, h] = o.children;
        if (c.type !== "link_open" || u.type !== "image" || h.type !== "link_close")
          continue;
      }
      if (r !== 0 && t.tokens[r - 1].type !== "paragraph_open" || r !== s - 1 && t.tokens[r + 1].type !== "paragraph_close")
        continue;
      const a = t.tokens[r - 1];
      let l;
      if (a.type = "figure_open", a.tag = "figure", t.tokens[r + 1].type = "figure_close", t.tokens[r + 1].tag = "figure", e.dataType && t.tokens[r - 1].attrPush(["data-type", "image"]), e.link && o.children.length === 1) {
        [l] = o.children;
        const c = new t.Token("link_open", "a", 1);
        c.attrPush(["href", l.attrGet("src")]), o.children.unshift(c), o.children.push(new t.Token("link_close", "a", -1));
      }
      if (l = o.children.length === 1 ? o.children[0] : o.children[1], e.figcaption) {
        const c = XWe(e.figcaption, l);
        if (c) {
          const [u] = n.parseInline(c, t.env);
          o.children.push(new t.Token("figcaption_open", "figcaption", 1)), o.children.push(...u.children), o.children.push(new t.Token("figcaption_close", "figcaption", -1)), l.attrs && (l.attrs = E4(l.attrs, "title"));
        }
      }
      if (e.copyAttrs && l.attrs) {
        const c = e.copyAttrs === !0 ? "" : e.copyAttrs;
        a.attrs = l.attrs.filter(([u]) => u.match(c)).map((u) => Array.from(u));
      }
      if (e.tabindex && (t.tokens[r - 1].attrPush(["tabindex", i]), i++), e.lazy && (l.attrs.some(([c]) => c === "loading") || l.attrs.push(["loading", "lazy"])), e.async && (l.attrs.some(([c]) => c === "decoding") || l.attrs.push(["decoding", "async"])), e.classes && typeof e.classes == "string") {
        let c = !1;
        for (let u = 0, h = l.attrs.length; u < h && !c; u++) {
          const d = l.attrs[u];
          d[0] === "class" && (d[1] = `${d[1]} ${e.classes}`, c = !0);
        }
        c || l.attrs.push(["class", e.classes]);
      }
      if (e.removeSrc) {
        const c = l.attrs.find(([u]) => u === "src");
        l.attrs.push(["data-src", c[1]]), A4(l, "src");
      }
    }
  });
}
var n1 = !0, $4 = !1, T4 = !1, UWe = function(n, e) {
  e && (n1 = !e.enabled, $4 = !!e.label, T4 = !!e.labelAfter), n.core.ruler.after("inline", "github-task-lists", function(t) {
    for (var i = t.tokens, r = 2; r < i.length; r++)
      KWe(i, r) && (JWe(i[r], t.Token), BE(i[r - 2], "class", "task-list-item" + (n1 ? "" : " enabled")), BE(i[GWe(i, r - 2)], "class", "contains-task-list"));
  });
};
function BE(n, e, t) {
  var i = n.attrIndex(e), r = [e, t];
  i < 0 ? n.attrPush(r) : n.attrs[i] = r;
}
function GWe(n, e) {
  for (var t = n[e].level - 1, i = e - 1; i >= 0; i--)
    if (n[i].level === t)
      return i;
  return -1;
}
function KWe(n, e) {
  return rHe(n[e]) && sHe(n[e - 1]) && oHe(n[e - 2]) && aHe(n[e]);
}
function JWe(n, e) {
  if (n.children.unshift(eHe(n, e)), n.children[1].content = n.children[1].content.slice(3), n.content = n.content.slice(3), $4)
    if (T4) {
      n.children.pop();
      var t = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
      n.children[0].content = n.children[0].content.slice(0, -1) + ' id="' + t + '">', n.children.push(iHe(n.content, t, e));
    } else
      n.children.unshift(tHe(e)), n.children.push(nHe(e));
}
function eHe(n, e) {
  var t = new e("html_inline", "", 0), i = n1 ? ' disabled="" ' : "";
  return n.content.indexOf("[ ] ") === 0 ? t.content = '<input class="task-list-item-checkbox"' + i + 'type="checkbox">' : (n.content.indexOf("[x] ") === 0 || n.content.indexOf("[X] ") === 0) && (t.content = '<input class="task-list-item-checkbox" checked=""' + i + 'type="checkbox">'), t;
}
function tHe(n) {
  var e = new n("html_inline", "", 0);
  return e.content = "<label>", e;
}
function nHe(n) {
  var e = new n("html_inline", "", 0);
  return e.content = "</label>", e;
}
function iHe(n, e, t) {
  var i = new t("html_inline", "", 0);
  return i.content = '<label class="task-list-item-label" for="' + e + '">' + n + "</label>", i.attrs = [{ for: e }], i;
}
function rHe(n) {
  return n.type === "inline";
}
function sHe(n) {
  return n.type === "paragraph_open";
}
function oHe(n) {
  return n.type === "list_item_open";
}
function aHe(n) {
  return n.content.indexOf("[ ] ") === 0 || n.content.indexOf("[x] ") === 0 || n.content.indexOf("[X] ") === 0;
}
const lHe = /* @__PURE__ */ Mf(UWe);
var i1 = { exports: {} }, vn = {}, r1 = { exports: {} }, dc = {};
function _4() {
  var n = {};
  return n["align-content"] = !1, n["align-items"] = !1, n["align-self"] = !1, n["alignment-adjust"] = !1, n["alignment-baseline"] = !1, n.all = !1, n["anchor-point"] = !1, n.animation = !1, n["animation-delay"] = !1, n["animation-direction"] = !1, n["animation-duration"] = !1, n["animation-fill-mode"] = !1, n["animation-iteration-count"] = !1, n["animation-name"] = !1, n["animation-play-state"] = !1, n["animation-timing-function"] = !1, n.azimuth = !1, n["backface-visibility"] = !1, n.background = !0, n["background-attachment"] = !0, n["background-clip"] = !0, n["background-color"] = !0, n["background-image"] = !0, n["background-origin"] = !0, n["background-position"] = !0, n["background-repeat"] = !0, n["background-size"] = !0, n["baseline-shift"] = !1, n.binding = !1, n.bleed = !1, n["bookmark-label"] = !1, n["bookmark-level"] = !1, n["bookmark-state"] = !1, n.border = !0, n["border-bottom"] = !0, n["border-bottom-color"] = !0, n["border-bottom-left-radius"] = !0, n["border-bottom-right-radius"] = !0, n["border-bottom-style"] = !0, n["border-bottom-width"] = !0, n["border-collapse"] = !0, n["border-color"] = !0, n["border-image"] = !0, n["border-image-outset"] = !0, n["border-image-repeat"] = !0, n["border-image-slice"] = !0, n["border-image-source"] = !0, n["border-image-width"] = !0, n["border-left"] = !0, n["border-left-color"] = !0, n["border-left-style"] = !0, n["border-left-width"] = !0, n["border-radius"] = !0, n["border-right"] = !0, n["border-right-color"] = !0, n["border-right-style"] = !0, n["border-right-width"] = !0, n["border-spacing"] = !0, n["border-style"] = !0, n["border-top"] = !0, n["border-top-color"] = !0, n["border-top-left-radius"] = !0, n["border-top-right-radius"] = !0, n["border-top-style"] = !0, n["border-top-width"] = !0, n["border-width"] = !0, n.bottom = !1, n["box-decoration-break"] = !0, n["box-shadow"] = !0, n["box-sizing"] = !0, n["box-snap"] = !0, n["box-suppress"] = !0, n["break-after"] = !0, n["break-before"] = !0, n["break-inside"] = !0, n["caption-side"] = !1, n.chains = !1, n.clear = !0, n.clip = !1, n["clip-path"] = !1, n["clip-rule"] = !1, n.color = !0, n["color-interpolation-filters"] = !0, n["column-count"] = !1, n["column-fill"] = !1, n["column-gap"] = !1, n["column-rule"] = !1, n["column-rule-color"] = !1, n["column-rule-style"] = !1, n["column-rule-width"] = !1, n["column-span"] = !1, n["column-width"] = !1, n.columns = !1, n.contain = !1, n.content = !1, n["counter-increment"] = !1, n["counter-reset"] = !1, n["counter-set"] = !1, n.crop = !1, n.cue = !1, n["cue-after"] = !1, n["cue-before"] = !1, n.cursor = !1, n.direction = !1, n.display = !0, n["display-inside"] = !0, n["display-list"] = !0, n["display-outside"] = !0, n["dominant-baseline"] = !1, n.elevation = !1, n["empty-cells"] = !1, n.filter = !1, n.flex = !1, n["flex-basis"] = !1, n["flex-direction"] = !1, n["flex-flow"] = !1, n["flex-grow"] = !1, n["flex-shrink"] = !1, n["flex-wrap"] = !1, n.float = !1, n["float-offset"] = !1, n["flood-color"] = !1, n["flood-opacity"] = !1, n["flow-from"] = !1, n["flow-into"] = !1, n.font = !0, n["font-family"] = !0, n["font-feature-settings"] = !0, n["font-kerning"] = !0, n["font-language-override"] = !0, n["font-size"] = !0, n["font-size-adjust"] = !0, n["font-stretch"] = !0, n["font-style"] = !0, n["font-synthesis"] = !0, n["font-variant"] = !0, n["font-variant-alternates"] = !0, n["font-variant-caps"] = !0, n["font-variant-east-asian"] = !0, n["font-variant-ligatures"] = !0, n["font-variant-numeric"] = !0, n["font-variant-position"] = !0, n["font-weight"] = !0, n.grid = !1, n["grid-area"] = !1, n["grid-auto-columns"] = !1, n["grid-auto-flow"] = !1, n["grid-auto-rows"] = !1, n["grid-column"] = !1, n["grid-column-end"] = !1, n["grid-column-start"] = !1, n["grid-row"] = !1, n["grid-row-end"] = !1, n["grid-row-start"] = !1, n["grid-template"] = !1, n["grid-template-areas"] = !1, n["grid-template-columns"] = !1, n["grid-template-rows"] = !1, n["hanging-punctuation"] = !1, n.height = !0, n.hyphens = !1, n.icon = !1, n["image-orientation"] = !1, n["image-resolution"] = !1, n["ime-mode"] = !1, n["initial-letters"] = !1, n["inline-box-align"] = !1, n["justify-content"] = !1, n["justify-items"] = !1, n["justify-self"] = !1, n.left = !1, n["letter-spacing"] = !0, n["lighting-color"] = !0, n["line-box-contain"] = !1, n["line-break"] = !1, n["line-grid"] = !1, n["line-height"] = !1, n["line-snap"] = !1, n["line-stacking"] = !1, n["line-stacking-ruby"] = !1, n["line-stacking-shift"] = !1, n["line-stacking-strategy"] = !1, n["list-style"] = !0, n["list-style-image"] = !0, n["list-style-position"] = !0, n["list-style-type"] = !0, n.margin = !0, n["margin-bottom"] = !0, n["margin-left"] = !0, n["margin-right"] = !0, n["margin-top"] = !0, n["marker-offset"] = !1, n["marker-side"] = !1, n.marks = !1, n.mask = !1, n["mask-box"] = !1, n["mask-box-outset"] = !1, n["mask-box-repeat"] = !1, n["mask-box-slice"] = !1, n["mask-box-source"] = !1, n["mask-box-width"] = !1, n["mask-clip"] = !1, n["mask-image"] = !1, n["mask-origin"] = !1, n["mask-position"] = !1, n["mask-repeat"] = !1, n["mask-size"] = !1, n["mask-source-type"] = !1, n["mask-type"] = !1, n["max-height"] = !0, n["max-lines"] = !1, n["max-width"] = !0, n["min-height"] = !0, n["min-width"] = !0, n["move-to"] = !1, n["nav-down"] = !1, n["nav-index"] = !1, n["nav-left"] = !1, n["nav-right"] = !1, n["nav-up"] = !1, n["object-fit"] = !1, n["object-position"] = !1, n.opacity = !1, n.order = !1, n.orphans = !1, n.outline = !1, n["outline-color"] = !1, n["outline-offset"] = !1, n["outline-style"] = !1, n["outline-width"] = !1, n.overflow = !1, n["overflow-wrap"] = !1, n["overflow-x"] = !1, n["overflow-y"] = !1, n.padding = !0, n["padding-bottom"] = !0, n["padding-left"] = !0, n["padding-right"] = !0, n["padding-top"] = !0, n.page = !1, n["page-break-after"] = !1, n["page-break-before"] = !1, n["page-break-inside"] = !1, n["page-policy"] = !1, n.pause = !1, n["pause-after"] = !1, n["pause-before"] = !1, n.perspective = !1, n["perspective-origin"] = !1, n.pitch = !1, n["pitch-range"] = !1, n["play-during"] = !1, n.position = !1, n["presentation-level"] = !1, n.quotes = !1, n["region-fragment"] = !1, n.resize = !1, n.rest = !1, n["rest-after"] = !1, n["rest-before"] = !1, n.richness = !1, n.right = !1, n.rotation = !1, n["rotation-point"] = !1, n["ruby-align"] = !1, n["ruby-merge"] = !1, n["ruby-position"] = !1, n["shape-image-threshold"] = !1, n["shape-outside"] = !1, n["shape-margin"] = !1, n.size = !1, n.speak = !1, n["speak-as"] = !1, n["speak-header"] = !1, n["speak-numeral"] = !1, n["speak-punctuation"] = !1, n["speech-rate"] = !1, n.stress = !1, n["string-set"] = !1, n["tab-size"] = !1, n["table-layout"] = !1, n["text-align"] = !0, n["text-align-last"] = !0, n["text-combine-upright"] = !0, n["text-decoration"] = !0, n["text-decoration-color"] = !0, n["text-decoration-line"] = !0, n["text-decoration-skip"] = !0, n["text-decoration-style"] = !0, n["text-emphasis"] = !0, n["text-emphasis-color"] = !0, n["text-emphasis-position"] = !0, n["text-emphasis-style"] = !0, n["text-height"] = !0, n["text-indent"] = !0, n["text-justify"] = !0, n["text-orientation"] = !0, n["text-overflow"] = !0, n["text-shadow"] = !0, n["text-space-collapse"] = !0, n["text-transform"] = !0, n["text-underline-position"] = !0, n["text-wrap"] = !0, n.top = !1, n.transform = !1, n["transform-origin"] = !1, n["transform-style"] = !1, n.transition = !1, n["transition-delay"] = !1, n["transition-duration"] = !1, n["transition-property"] = !1, n["transition-timing-function"] = !1, n["unicode-bidi"] = !1, n["vertical-align"] = !1, n.visibility = !1, n["voice-balance"] = !1, n["voice-duration"] = !1, n["voice-family"] = !1, n["voice-pitch"] = !1, n["voice-range"] = !1, n["voice-rate"] = !1, n["voice-stress"] = !1, n["voice-volume"] = !1, n.volume = !1, n["white-space"] = !1, n.widows = !1, n.width = !0, n["will-change"] = !1, n["word-break"] = !0, n["word-spacing"] = !0, n["word-wrap"] = !0, n["wrap-flow"] = !1, n["wrap-through"] = !1, n["writing-mode"] = !1, n["z-index"] = !1, n;
}
function cHe(n, e, t) {
}
function uHe(n, e, t) {
}
var hHe = /javascript\s*\:/img;
function dHe(n, e) {
  return hHe.test(e) ? "" : e;
}
dc.whiteList = _4();
dc.getDefaultWhiteList = _4;
dc.onAttr = cHe;
dc.onIgnoreAttr = uHe;
dc.safeAttrValue = dHe;
var fHe = {
  indexOf: function(n, e) {
    var t, i;
    if (Array.prototype.indexOf)
      return n.indexOf(e);
    for (t = 0, i = n.length; t < i; t++)
      if (n[t] === e)
        return t;
    return -1;
  },
  forEach: function(n, e, t) {
    var i, r;
    if (Array.prototype.forEach)
      return n.forEach(e, t);
    for (i = 0, r = n.length; i < r; i++)
      e.call(t, n[i], i, n);
  },
  trim: function(n) {
    return String.prototype.trim ? n.trim() : n.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(n) {
    return String.prototype.trimRight ? n.trimRight() : n.replace(/(\s*$)/g, "");
  }
}, Ih = fHe;
function pHe(n, e) {
  n = Ih.trimRight(n), n[n.length - 1] !== ";" && (n += ";");
  var t = n.length, i = !1, r = 0, s = 0, o = "";
  function a() {
    if (!i) {
      var u = Ih.trim(n.slice(r, s)), h = u.indexOf(":");
      if (h !== -1) {
        var d = Ih.trim(u.slice(0, h)), f = Ih.trim(u.slice(h + 1));
        if (d) {
          var p = e(r, o.length, d, f, u);
          p && (o += p + "; ");
        }
      }
    }
    r = s + 1;
  }
  for (; s < t; s++) {
    var l = n[s];
    if (l === "/" && n[s + 1] === "*") {
      var c = n.indexOf("*/", s + 2);
      if (c === -1)
        break;
      s = c + 1, r = s + 1, i = !1;
    } else
      l === "(" ? i = !0 : l === ")" ? i = !1 : l === ";" ? i || a() : l === `
` && a();
  }
  return Ih.trim(o);
}
var gHe = pHe, Wp = dc, mHe = gHe;
function QE(n) {
  return n == null;
}
function vHe(n) {
  var e = {};
  for (var t in n)
    e[t] = n[t];
  return e;
}
function M4(n) {
  n = vHe(n || {}), n.whiteList = n.whiteList || Wp.whiteList, n.onAttr = n.onAttr || Wp.onAttr, n.onIgnoreAttr = n.onIgnoreAttr || Wp.onIgnoreAttr, n.safeAttrValue = n.safeAttrValue || Wp.safeAttrValue, this.options = n;
}
M4.prototype.process = function(n) {
  if (n = n || "", n = n.toString(), !n)
    return "";
  var e = this, t = e.options, i = t.whiteList, r = t.onAttr, s = t.onIgnoreAttr, o = t.safeAttrValue, a = mHe(n, function(l, c, u, h, d) {
    var f = i[u], p = !1;
    if (f === !0 ? p = f : typeof f == "function" ? p = f(h) : f instanceof RegExp && (p = f.test(h)), p !== !0 && (p = !1), h = o(u, h), !!h) {
      var g = {
        position: c,
        sourcePosition: l,
        source: d,
        isWhite: p
      };
      if (p) {
        var m = r(u, h, g);
        return QE(m) ? u + ":" + h : m;
      } else {
        var m = s(u, h, g);
        if (!QE(m))
          return m;
      }
    }
  });
  return a;
};
var bHe = M4;
(function(n, e) {
  var t = dc, i = bHe;
  function r(o, a) {
    var l = new i(a);
    return l.process(o);
  }
  e = n.exports = r, e.FilterCSS = i;
  for (var s in t)
    e[s] = t[s];
  typeof window < "u" && (window.filterCSS = n.exports);
})(r1, r1.exports);
var Xx = r1.exports, Yx = {
  indexOf: function(n, e) {
    var t, i;
    if (Array.prototype.indexOf)
      return n.indexOf(e);
    for (t = 0, i = n.length; t < i; t++)
      if (n[t] === e)
        return t;
    return -1;
  },
  forEach: function(n, e, t) {
    var i, r;
    if (Array.prototype.forEach)
      return n.forEach(e, t);
    for (i = 0, r = n.length; i < r; i++)
      e.call(t, n[i], i, n);
  },
  trim: function(n) {
    return String.prototype.trim ? n.trim() : n.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(n) {
    var e = /\s|\n|\t/, t = e.exec(n);
    return t ? t.index : -1;
  }
}, yHe = Xx.FilterCSS, OHe = Xx.getDefaultWhiteList, Zm = Yx;
function R4() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var N4 = new yHe();
function wHe(n, e, t) {
}
function xHe(n, e, t) {
}
function SHe(n, e, t) {
}
function CHe(n, e, t) {
}
function D4(n) {
  return n.replace(PHe, "&lt;").replace(EHe, "&gt;");
}
function kHe(n, e, t, i) {
  if (t = j4(t), e === "href" || e === "src") {
    if (t = Zm.trim(t), t === "#")
      return "#";
    if (!(t.substr(0, 7) === "http://" || t.substr(0, 8) === "https://" || t.substr(0, 7) === "mailto:" || t.substr(0, 4) === "tel:" || t.substr(0, 11) === "data:image/" || t.substr(0, 6) === "ftp://" || t.substr(0, 2) === "./" || t.substr(0, 3) === "../" || t[0] === "#" || t[0] === "/"))
      return "";
  } else if (e === "background") {
    if (Hp.lastIndex = 0, Hp.test(t))
      return "";
  } else if (e === "style") {
    if (zE.lastIndex = 0, zE.test(t) || (jE.lastIndex = 0, jE.test(t) && (Hp.lastIndex = 0, Hp.test(t))))
      return "";
    i !== !1 && (i = i || N4, t = i.process(t));
  }
  return t = V4(t), t;
}
var PHe = /</g, EHe = />/g, AHe = /"/g, $He = /&quot;/g, THe = /&#([a-zA-Z0-9]*);?/gim, _He = /&colon;?/gim, MHe = /&newline;?/gim, Hp = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi, zE = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, jE = /u\s*r\s*l\s*\(.*/gi;
function L4(n) {
  return n.replace(AHe, "&quot;");
}
function I4(n) {
  return n.replace($He, '"');
}
function B4(n) {
  return n.replace(THe, function(t, i) {
    return i[0] === "x" || i[0] === "X" ? String.fromCharCode(parseInt(i.substr(1), 16)) : String.fromCharCode(parseInt(i, 10));
  });
}
function Q4(n) {
  return n.replace(_He, ":").replace(MHe, " ");
}
function z4(n) {
  for (var e = "", t = 0, i = n.length; t < i; t++)
    e += n.charCodeAt(t) < 32 ? " " : n.charAt(t);
  return Zm.trim(e);
}
function j4(n) {
  return n = I4(n), n = B4(n), n = Q4(n), n = z4(n), n;
}
function V4(n) {
  return n = L4(n), n = D4(n), n;
}
function RHe() {
  return "";
}
function NHe(n, e) {
  typeof e != "function" && (e = function() {
  });
  var t = !Array.isArray(n);
  function i(o) {
    return t ? !0 : Zm.indexOf(n, o) !== -1;
  }
  var r = [], s = !1;
  return {
    onIgnoreTag: function(o, a, l) {
      if (i(o))
        if (l.isClosing) {
          var c = "[/removed]", u = l.position + c.length;
          return r.push([
            s !== !1 ? s : l.position,
            u
          ]), s = !1, c;
        } else
          return s || (s = l.position), "[removed]";
      else
        return e(o, a, l);
    },
    remove: function(o) {
      var a = "", l = 0;
      return Zm.forEach(r, function(c) {
        a += o.slice(l, c[0]), l = c[1];
      }), a += o.slice(l), a;
    }
  };
}
function DHe(n) {
  for (var e = "", t = 0; t < n.length; ) {
    var i = n.indexOf("<!--", t);
    if (i === -1) {
      e += n.slice(t);
      break;
    }
    e += n.slice(t, i);
    var r = n.indexOf("-->", i);
    if (r === -1)
      break;
    t = r + 3;
  }
  return e;
}
function LHe(n) {
  var e = n.split("");
  return e = e.filter(function(t) {
    var i = t.charCodeAt(0);
    return i === 127 ? !1 : i <= 31 ? i === 10 || i === 13 : !0;
  }), e.join("");
}
vn.whiteList = R4();
vn.getDefaultWhiteList = R4;
vn.onTag = wHe;
vn.onIgnoreTag = xHe;
vn.onTagAttr = SHe;
vn.onIgnoreTagAttr = CHe;
vn.safeAttrValue = kHe;
vn.escapeHtml = D4;
vn.escapeQuote = L4;
vn.unescapeQuote = I4;
vn.escapeHtmlEntities = B4;
vn.escapeDangerHtml5Entities = Q4;
vn.clearNonPrintableCharacter = z4;
vn.friendlyAttrValue = j4;
vn.escapeAttrValue = V4;
vn.onIgnoreTagStripAll = RHe;
vn.StripTagBody = NHe;
vn.stripCommentTag = DHe;
vn.stripBlankChar = LHe;
vn.cssFilter = N4;
vn.getDefaultCSSWhiteList = OHe;
var l0 = {}, ba = Yx;
function IHe(n) {
  var e = ba.spaceIndex(n), t;
  return e === -1 ? t = n.slice(1, -1) : t = n.slice(1, e + 1), t = ba.trim(t).toLowerCase(), t.slice(0, 1) === "/" && (t = t.slice(1)), t.slice(-1) === "/" && (t = t.slice(0, -1)), t;
}
function BHe(n) {
  return n.slice(0, 2) === "</";
}
function QHe(n, e, t) {
  var i = "", r = 0, s = !1, o = !1, a = 0, l = n.length, c = "", u = "";
  e:
    for (a = 0; a < l; a++) {
      var h = n.charAt(a);
      if (s === !1) {
        if (h === "<") {
          s = a;
          continue;
        }
      } else if (o === !1) {
        if (h === "<") {
          i += t(n.slice(r, a)), s = a, r = a;
          continue;
        }
        if (h === ">" || a === l - 1) {
          i += t(n.slice(r, s)), u = n.slice(s, a + 1), c = IHe(u), i += e(
            s,
            i.length,
            c,
            u,
            BHe(u)
          ), r = a + 1, s = !1;
          continue;
        }
        if (h === '"' || h === "'")
          for (var d = 1, f = n.charAt(a - d); f.trim() === "" || f === "="; ) {
            if (f === "=") {
              o = h;
              continue e;
            }
            f = n.charAt(a - ++d);
          }
      } else if (h === o) {
        o = !1;
        continue;
      }
    }
  return r < l && (i += t(n.substr(r))), i;
}
var zHe = /[^a-zA-Z0-9\\_:.-]/gim;
function jHe(n, e) {
  var t = 0, i = 0, r = [], s = !1, o = n.length;
  function a(d, f) {
    if (d = ba.trim(d), d = d.replace(zHe, "").toLowerCase(), !(d.length < 1)) {
      var p = e(d, f || "");
      p && r.push(p);
    }
  }
  for (var l = 0; l < o; l++) {
    var c = n.charAt(l), u, h;
    if (s === !1 && c === "=") {
      s = n.slice(t, l), t = l + 1, i = n.charAt(t) === '"' || n.charAt(t) === "'" ? t : FHe(n, l + 1);
      continue;
    }
    if (s !== !1 && l === i) {
      if (h = n.indexOf(c, l + 1), h === -1)
        break;
      u = ba.trim(n.slice(i + 1, h)), a(s, u), s = !1, l = h, t = l + 1;
      continue;
    }
    if (/\s|\n|\t/.test(c))
      if (n = n.replace(/\s|\n|\t/g, " "), s === !1)
        if (h = VHe(n, l), h === -1) {
          u = ba.trim(n.slice(t, l)), a(u), s = !1, t = l + 1;
          continue;
        } else {
          l = h - 1;
          continue;
        }
      else if (h = ZHe(n, l - 1), h === -1) {
        u = ba.trim(n.slice(t, l)), u = VE(u), a(s, u), s = !1, t = l + 1;
        continue;
      } else
        continue;
  }
  return t < n.length && (s === !1 ? a(n.slice(t)) : a(s, VE(ba.trim(n.slice(t))))), ba.trim(r.join(" "));
}
function VHe(n, e) {
  for (; e < n.length; e++) {
    var t = n[e];
    if (t !== " ")
      return t === "=" ? e : -1;
  }
}
function FHe(n, e) {
  for (; e < n.length; e++) {
    var t = n[e];
    if (t !== " ")
      return t === "'" || t === '"' ? e : -1;
  }
}
function ZHe(n, e) {
  for (; e > 0; e--) {
    var t = n[e];
    if (t !== " ")
      return t === "=" ? e : -1;
  }
}
function qHe(n) {
  return n[0] === '"' && n[n.length - 1] === '"' || n[0] === "'" && n[n.length - 1] === "'";
}
function VE(n) {
  return qHe(n) ? n.substr(1, n.length - 2) : n;
}
l0.parseTag = QHe;
l0.parseAttr = jHe;
var WHe = Xx.FilterCSS, cs = vn, F4 = l0, HHe = F4.parseTag, XHe = F4.parseAttr, Mg = Yx;
function Xp(n) {
  return n == null;
}
function YHe(n) {
  var e = Mg.spaceIndex(n);
  if (e === -1)
    return {
      html: "",
      closing: n[n.length - 2] === "/"
    };
  n = Mg.trim(n.slice(e + 1, -1));
  var t = n[n.length - 1] === "/";
  return t && (n = Mg.trim(n.slice(0, -1))), {
    html: n,
    closing: t
  };
}
function UHe(n) {
  var e = {};
  for (var t in n)
    e[t] = n[t];
  return e;
}
function GHe(n) {
  var e = {};
  for (var t in n)
    Array.isArray(n[t]) ? e[t.toLowerCase()] = n[t].map(function(i) {
      return i.toLowerCase();
    }) : e[t.toLowerCase()] = n[t];
  return e;
}
function Z4(n) {
  n = UHe(n || {}), n.stripIgnoreTag && (n.onIgnoreTag && console.error(
    'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
  ), n.onIgnoreTag = cs.onIgnoreTagStripAll), n.whiteList || n.allowList ? n.whiteList = GHe(n.whiteList || n.allowList) : n.whiteList = cs.whiteList, n.onTag = n.onTag || cs.onTag, n.onTagAttr = n.onTagAttr || cs.onTagAttr, n.onIgnoreTag = n.onIgnoreTag || cs.onIgnoreTag, n.onIgnoreTagAttr = n.onIgnoreTagAttr || cs.onIgnoreTagAttr, n.safeAttrValue = n.safeAttrValue || cs.safeAttrValue, n.escapeHtml = n.escapeHtml || cs.escapeHtml, this.options = n, n.css === !1 ? this.cssFilter = !1 : (n.css = n.css || {}, this.cssFilter = new WHe(n.css));
}
Z4.prototype.process = function(n) {
  if (n = n || "", n = n.toString(), !n)
    return "";
  var e = this, t = e.options, i = t.whiteList, r = t.onTag, s = t.onIgnoreTag, o = t.onTagAttr, a = t.onIgnoreTagAttr, l = t.safeAttrValue, c = t.escapeHtml, u = e.cssFilter;
  t.stripBlankChar && (n = cs.stripBlankChar(n)), t.allowCommentTag || (n = cs.stripCommentTag(n));
  var h = !1;
  t.stripIgnoreTagBody && (h = cs.StripTagBody(
    t.stripIgnoreTagBody,
    s
  ), s = h.onIgnoreTag);
  var d = HHe(
    n,
    function(f, p, g, m, v) {
      var y = {
        sourcePosition: f,
        position: p,
        isClosing: v,
        isWhite: Object.prototype.hasOwnProperty.call(i, g)
      }, b = r(g, m, y);
      if (!Xp(b))
        return b;
      if (y.isWhite) {
        if (y.isClosing)
          return "</" + g + ">";
        var w = YHe(m), x = i[g], S = XHe(w.html, function(C, k) {
          var E = Mg.indexOf(x, C) !== -1, M = o(g, C, k, E);
          return Xp(M) ? E ? (k = l(g, C, k, u), k ? C + '="' + k + '"' : C) : (M = a(g, C, k, E), Xp(M) ? void 0 : M) : M;
        });
        return m = "<" + g, S && (m += " " + S), w.closing && (m += " /"), m += ">", m;
      } else
        return b = s(g, m, y), Xp(b) ? c(m) : b;
    },
    c
  );
  return h && (d = h.remove(d)), d;
};
var KHe = Z4;
(function(n, e) {
  var t = vn, i = l0, r = KHe;
  function s(a, l) {
    var c = new r(l);
    return c.process(a);
  }
  e = n.exports = s, e.filterXSS = s, e.FilterXSS = r, function() {
    for (var a in t)
      e[a] = t[a];
    for (var l in i)
      e[l] = i[l];
  }(), typeof window < "u" && (window.filterXSS = n.exports);
  function o() {
    return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
  }
  o() && (self.filterXSS = n.exports);
})(i1, i1.exports);
var JHe = i1.exports;
const FE = JHe;
var eXe = function(e, { xss: t } = {}) {
  const i = new FE.FilterXSS(typeof t == "function" ? t(FE) : t);
  function r(o) {
    return o = i.process(o), o;
  }
  function s(o) {
    for (let a = 0; a < o.tokens.length; a++) {
      let l = o.tokens[a];
      if (l.type === "html_block" && (l.content = r(l.content)), l.type === "inline") {
        let c = l.children;
        for (let u = 0; u < c.length; u++)
          c[u].type === "html_inline" && (c[u].content = r(c[u].content));
      }
    }
  }
  e.core.ruler.after("linkify", "xss", s);
};
const tXe = /* @__PURE__ */ Mf(eXe), Bh = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, q4 = /* @__PURE__ */ new Set(), nXe = (n, e, t, i) => {
  typeof process == "object" && process && typeof process.emitWarning == "function" ? process.emitWarning(n, e, t, i) : console.error(`[${t}] ${e}: ${n}`);
}, iXe = (n) => !q4.has(n), ha = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), W4 = (n) => ha(n) ? n <= Math.pow(2, 8) ? Uint8Array : n <= Math.pow(2, 16) ? Uint16Array : n <= Math.pow(2, 32) ? Uint32Array : n <= Number.MAX_SAFE_INTEGER ? Rg : null : null;
class Rg extends Array {
  constructor(e) {
    super(e), this.fill(0);
  }
}
var ru;
const xl = class xl {
  constructor(e, t) {
    ii(this, "heap");
    ii(this, "length");
    if (!Q(xl, ru))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new t(e), this.length = 0;
  }
  static create(e) {
    const t = W4(e);
    if (!t)
      return [];
    Ge(xl, ru, !0);
    const i = new xl(e, t);
    return Ge(xl, ru, !1), i;
  }
  push(e) {
    this.heap[this.length++] = e;
  }
  pop() {
    return this.heap[--this.length];
  }
};
ru = new WeakMap(), // private constructor
ht(xl, ru, !1);
let s1 = xl;
var us, yr, Vs, hs, su, Vn, ds, Fn, Kt, st, Vi, Or, Ti, ri, fs, pi, Ro, No, ps, Fs, Sa, nr, vf, a1, Ml, Do, bf, wr, ev, H4, Rl, ou, yf, Zs, da, qs, fa, Of, l1, au, Ng, lu, Dg, qt, rn, wf, c1, Nl, Yh;
const oS = class oS {
  constructor(e) {
    ht(this, vf);
    ht(this, ev);
    ht(this, Zs);
    ht(this, qs);
    ht(this, Of);
    ht(this, au);
    ht(this, lu);
    ht(this, qt);
    ht(this, wf);
    ht(this, Nl);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    ht(this, us, void 0);
    ht(this, yr, void 0);
    ht(this, Vs, void 0);
    ht(this, hs, void 0);
    ht(this, su, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ii(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ii(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ii(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    ii(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    ii(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    ii(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    ii(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    ii(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    ii(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    ii(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    ii(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    ii(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    ii(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    ii(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ii(this, "ignoreFetchAbort");
    // computed properties
    ht(this, Vn, void 0);
    ht(this, ds, void 0);
    ht(this, Fn, void 0);
    ht(this, Kt, void 0);
    ht(this, st, void 0);
    ht(this, Vi, void 0);
    ht(this, Or, void 0);
    ht(this, Ti, void 0);
    ht(this, ri, void 0);
    ht(this, fs, void 0);
    ht(this, pi, void 0);
    ht(this, Ro, void 0);
    ht(this, No, void 0);
    ht(this, ps, void 0);
    ht(this, Fs, void 0);
    ht(this, Sa, void 0);
    ht(this, nr, void 0);
    // conditionally set private methods related to TTL
    ht(this, Ml, () => {
    });
    ht(this, Do, () => {
    });
    ht(this, bf, () => {
    });
    /* c8 ignore stop */
    ht(this, wr, () => !1);
    ht(this, Rl, (e) => {
    });
    ht(this, ou, (e, t, i) => {
    });
    ht(this, yf, (e, t, i, r) => {
      if (i || r)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    });
    const { max: t = 0, ttl: i, ttlResolution: r = 1, ttlAutopurge: s, updateAgeOnGet: o, updateAgeOnHas: a, allowStale: l, dispose: c, disposeAfter: u, noDisposeOnSet: h, noUpdateTTL: d, maxSize: f = 0, maxEntrySize: p = 0, sizeCalculation: g, fetchMethod: m, noDeleteOnFetchRejection: v, noDeleteOnStaleGet: y, allowStaleOnFetchRejection: b, allowStaleOnFetchAbort: w, ignoreFetchAbort: x } = e;
    if (t !== 0 && !ha(t))
      throw new TypeError("max option must be a nonnegative integer");
    const S = t ? W4(t) : Array;
    if (!S)
      throw new Error("invalid max value: " + t);
    if (Ge(this, us, t), Ge(this, yr, f), this.maxEntrySize = p || Q(this, yr), this.sizeCalculation = g, this.sizeCalculation) {
      if (!Q(this, yr) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (m !== void 0 && typeof m != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (Ge(this, su, m), Ge(this, Sa, !!m), Ge(this, Fn, /* @__PURE__ */ new Map()), Ge(this, Kt, new Array(t).fill(void 0)), Ge(this, st, new Array(t).fill(void 0)), Ge(this, Vi, new S(t)), Ge(this, Or, new S(t)), Ge(this, Ti, 0), Ge(this, ri, 0), Ge(this, fs, s1.create(t)), Ge(this, Vn, 0), Ge(this, ds, 0), typeof c == "function" && Ge(this, Vs, c), typeof u == "function" ? (Ge(this, hs, u), Ge(this, pi, [])) : (Ge(this, hs, void 0), Ge(this, pi, void 0)), Ge(this, Fs, !!Q(this, Vs)), Ge(this, nr, !!Q(this, hs)), this.noDisposeOnSet = !!h, this.noUpdateTTL = !!d, this.noDeleteOnFetchRejection = !!v, this.allowStaleOnFetchRejection = !!b, this.allowStaleOnFetchAbort = !!w, this.ignoreFetchAbort = !!x, this.maxEntrySize !== 0) {
      if (Q(this, yr) !== 0 && !ha(Q(this, yr)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!ha(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      ze(this, ev, H4).call(this);
    }
    if (this.allowStale = !!l, this.noDeleteOnStaleGet = !!y, this.updateAgeOnGet = !!o, this.updateAgeOnHas = !!a, this.ttlResolution = ha(r) || r === 0 ? r : 1, this.ttlAutopurge = !!s, this.ttl = i || 0, this.ttl) {
      if (!ha(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      ze(this, vf, a1).call(this);
    }
    if (Q(this, us) === 0 && this.ttl === 0 && Q(this, yr) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !Q(this, us) && !Q(this, yr)) {
      const C = "LRU_CACHE_UNBOUNDED";
      iXe(C) && (q4.add(C), nXe("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", C, oS));
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(e) {
    return {
      // properties
      starts: Q(e, No),
      ttls: Q(e, ps),
      sizes: Q(e, Ro),
      keyMap: Q(e, Fn),
      keyList: Q(e, Kt),
      valList: Q(e, st),
      next: Q(e, Vi),
      prev: Q(e, Or),
      get head() {
        return Q(e, Ti);
      },
      get tail() {
        return Q(e, ri);
      },
      free: Q(e, fs),
      // methods
      isBackgroundFetch: (t) => {
        var i;
        return ze(i = e, qt, rn).call(i, t);
      },
      backgroundFetch: (t, i, r, s) => {
        var o;
        return ze(o = e, lu, Dg).call(o, t, i, r, s);
      },
      moveToTail: (t) => {
        var i;
        return ze(i = e, Nl, Yh).call(i, t);
      },
      indexes: (t) => {
        var i;
        return ze(i = e, Zs, da).call(i, t);
      },
      rindexes: (t) => {
        var i;
        return ze(i = e, qs, fa).call(i, t);
      },
      isStale: (t) => {
        var i;
        return Q(i = e, wr).call(i, t);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return Q(this, us);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return Q(this, yr);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return Q(this, ds);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return Q(this, Vn);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return Q(this, su);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return Q(this, Vs);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return Q(this, hs);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(e) {
    return Q(this, Fn).has(e) ? 1 / 0 : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const e of ze(this, Zs, da).call(this))
      Q(this, st)[e] !== void 0 && Q(this, Kt)[e] !== void 0 && !ze(this, qt, rn).call(this, Q(this, st)[e]) && (yield [Q(this, Kt)[e], Q(this, st)[e]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const e of ze(this, qs, fa).call(this))
      Q(this, st)[e] !== void 0 && Q(this, Kt)[e] !== void 0 && !ze(this, qt, rn).call(this, Q(this, st)[e]) && (yield [Q(this, Kt)[e], Q(this, st)[e]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const e of ze(this, Zs, da).call(this)) {
      const t = Q(this, Kt)[e];
      t !== void 0 && !ze(this, qt, rn).call(this, Q(this, st)[e]) && (yield t);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const e of ze(this, qs, fa).call(this)) {
      const t = Q(this, Kt)[e];
      t !== void 0 && !ze(this, qt, rn).call(this, Q(this, st)[e]) && (yield t);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const e of ze(this, Zs, da).call(this))
      Q(this, st)[e] !== void 0 && !ze(this, qt, rn).call(this, Q(this, st)[e]) && (yield Q(this, st)[e]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const e of ze(this, qs, fa).call(this))
      Q(this, st)[e] !== void 0 && !ze(this, qt, rn).call(this, Q(this, st)[e]) && (yield Q(this, st)[e]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(e, t = {}) {
    for (const i of ze(this, Zs, da).call(this)) {
      const r = Q(this, st)[i], s = ze(this, qt, rn).call(this, r) ? r.__staleWhileFetching : r;
      if (s !== void 0 && e(s, Q(this, Kt)[i], this))
        return this.get(Q(this, Kt)[i], t);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(e, t = this) {
    for (const i of ze(this, Zs, da).call(this)) {
      const r = Q(this, st)[i], s = ze(this, qt, rn).call(this, r) ? r.__staleWhileFetching : r;
      s !== void 0 && e.call(t, s, Q(this, Kt)[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(e, t = this) {
    for (const i of ze(this, qs, fa).call(this)) {
      const r = Q(this, st)[i], s = ze(this, qt, rn).call(this, r) ? r.__staleWhileFetching : r;
      s !== void 0 && e.call(t, s, Q(this, Kt)[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let e = !1;
    for (const t of ze(this, qs, fa).call(this, { allowStale: !0 }))
      Q(this, wr).call(this, t) && (this.delete(Q(this, Kt)[t]), e = !0);
    return e;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const e = [];
    for (const t of ze(this, Zs, da).call(this, { allowStale: !0 })) {
      const i = Q(this, Kt)[t], r = Q(this, st)[t], s = ze(this, qt, rn).call(this, r) ? r.__staleWhileFetching : r;
      if (s === void 0 || i === void 0)
        continue;
      const o = { value: s };
      if (Q(this, ps) && Q(this, No)) {
        o.ttl = Q(this, ps)[t];
        const a = Bh.now() - Q(this, No)[t];
        o.start = Math.floor(Date.now() - a);
      }
      Q(this, Ro) && (o.size = Q(this, Ro)[t]), e.unshift([i, o]);
    }
    return e;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(e) {
    this.clear();
    for (const [t, i] of e) {
      if (i.start) {
        const r = Date.now() - i.start;
        i.start = Bh.now() - r;
      }
      this.set(t, i.value, i);
    }
  }
  /**
   * Add a value to the cache.
   */
  set(e, t, i = {}) {
    var d, f, p;
    const { ttl: r = this.ttl, start: s, noDisposeOnSet: o = this.noDisposeOnSet, sizeCalculation: a = this.sizeCalculation, status: l } = i;
    let { noUpdateTTL: c = this.noUpdateTTL } = i;
    const u = Q(this, yf).call(this, e, t, i.size || 0, a);
    if (this.maxEntrySize && u > this.maxEntrySize)
      return l && (l.set = "miss", l.maxEntrySizeExceeded = !0), this.delete(e), this;
    let h = Q(this, Vn) === 0 ? void 0 : Q(this, Fn).get(e);
    if (h === void 0)
      h = Q(this, Vn) === 0 ? Q(this, ri) : Q(this, fs).length !== 0 ? Q(this, fs).pop() : Q(this, Vn) === Q(this, us) ? ze(this, au, Ng).call(this, !1) : Q(this, Vn), Q(this, Kt)[h] = e, Q(this, st)[h] = t, Q(this, Fn).set(e, h), Q(this, Vi)[Q(this, ri)] = h, Q(this, Or)[h] = Q(this, ri), Ge(this, ri, h), ep(this, Vn)._++, Q(this, ou).call(this, h, u, l), l && (l.set = "add"), c = !1;
    else {
      ze(this, Nl, Yh).call(this, h);
      const g = Q(this, st)[h];
      if (t !== g) {
        if (Q(this, Sa) && ze(this, qt, rn).call(this, g) ? g.__abortController.abort(new Error("replaced")) : o || (Q(this, Fs) && ((d = Q(this, Vs)) == null || d.call(this, g, e, "set")), Q(this, nr) && ((f = Q(this, pi)) == null || f.push([g, e, "set"]))), Q(this, Rl).call(this, h), Q(this, ou).call(this, h, u, l), Q(this, st)[h] = t, l) {
          l.set = "replace";
          const m = g && ze(this, qt, rn).call(this, g) ? g.__staleWhileFetching : g;
          m !== void 0 && (l.oldValue = m);
        }
      } else
        l && (l.set = "update");
    }
    if (r !== 0 && !Q(this, ps) && ze(this, vf, a1).call(this), Q(this, ps) && (c || Q(this, bf).call(this, h, r, s), l && Q(this, Do).call(this, l, h)), !o && Q(this, nr) && Q(this, pi)) {
      const g = Q(this, pi);
      let m;
      for (; m = g == null ? void 0 : g.shift(); )
        (p = Q(this, hs)) == null || p.call(this, ...m);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var e;
    try {
      for (; Q(this, Vn); ) {
        const t = Q(this, st)[Q(this, Ti)];
        if (ze(this, au, Ng).call(this, !0), ze(this, qt, rn).call(this, t)) {
          if (t.__staleWhileFetching)
            return t.__staleWhileFetching;
        } else if (t !== void 0)
          return t;
      }
    } finally {
      if (Q(this, nr) && Q(this, pi)) {
        const t = Q(this, pi);
        let i;
        for (; i = t == null ? void 0 : t.shift(); )
          (e = Q(this, hs)) == null || e.call(this, ...i);
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(e, t = {}) {
    const { updateAgeOnHas: i = this.updateAgeOnHas, status: r } = t, s = Q(this, Fn).get(e);
    if (s !== void 0) {
      const o = Q(this, st)[s];
      if (ze(this, qt, rn).call(this, o) && o.__staleWhileFetching === void 0)
        return !1;
      if (Q(this, wr).call(this, s))
        r && (r.has = "stale", Q(this, Do).call(this, r, s));
      else
        return i && Q(this, Ml).call(this, s), r && (r.has = "hit", Q(this, Do).call(this, r, s)), !0;
    } else
      r && (r.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(e, t = {}) {
    const { allowStale: i = this.allowStale } = t, r = Q(this, Fn).get(e);
    if (r !== void 0 && (i || !Q(this, wr).call(this, r))) {
      const s = Q(this, st)[r];
      return ze(this, qt, rn).call(this, s) ? s.__staleWhileFetching : s;
    }
  }
  async fetch(e, t = {}) {
    const {
      // get options
      allowStale: i = this.allowStale,
      updateAgeOnGet: r = this.updateAgeOnGet,
      noDeleteOnStaleGet: s = this.noDeleteOnStaleGet,
      // set options
      ttl: o = this.ttl,
      noDisposeOnSet: a = this.noDisposeOnSet,
      size: l = 0,
      sizeCalculation: c = this.sizeCalculation,
      noUpdateTTL: u = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: h = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: d = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: f = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: p = this.allowStaleOnFetchAbort,
      context: g,
      forceRefresh: m = !1,
      status: v,
      signal: y
    } = t;
    if (!Q(this, Sa))
      return v && (v.fetch = "get"), this.get(e, {
        allowStale: i,
        updateAgeOnGet: r,
        noDeleteOnStaleGet: s,
        status: v
      });
    const b = {
      allowStale: i,
      updateAgeOnGet: r,
      noDeleteOnStaleGet: s,
      ttl: o,
      noDisposeOnSet: a,
      size: l,
      sizeCalculation: c,
      noUpdateTTL: u,
      noDeleteOnFetchRejection: h,
      allowStaleOnFetchRejection: d,
      allowStaleOnFetchAbort: p,
      ignoreFetchAbort: f,
      status: v,
      signal: y
    };
    let w = Q(this, Fn).get(e);
    if (w === void 0) {
      v && (v.fetch = "miss");
      const x = ze(this, lu, Dg).call(this, e, w, b, g);
      return x.__returned = x;
    } else {
      const x = Q(this, st)[w];
      if (ze(this, qt, rn).call(this, x)) {
        const M = i && x.__staleWhileFetching !== void 0;
        return v && (v.fetch = "inflight", M && (v.returnedStale = !0)), M ? x.__staleWhileFetching : x.__returned = x;
      }
      const S = Q(this, wr).call(this, w);
      if (!m && !S)
        return v && (v.fetch = "hit"), ze(this, Nl, Yh).call(this, w), r && Q(this, Ml).call(this, w), v && Q(this, Do).call(this, v, w), x;
      const C = ze(this, lu, Dg).call(this, e, w, b, g), E = C.__staleWhileFetching !== void 0 && i;
      return v && (v.fetch = S ? "stale" : "refresh", E && S && (v.returnedStale = !0)), E ? C.__staleWhileFetching : C.__returned = C;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(e, t = {}) {
    const { allowStale: i = this.allowStale, updateAgeOnGet: r = this.updateAgeOnGet, noDeleteOnStaleGet: s = this.noDeleteOnStaleGet, status: o } = t, a = Q(this, Fn).get(e);
    if (a !== void 0) {
      const l = Q(this, st)[a], c = ze(this, qt, rn).call(this, l);
      return o && Q(this, Do).call(this, o, a), Q(this, wr).call(this, a) ? (o && (o.get = "stale"), c ? (o && i && l.__staleWhileFetching !== void 0 && (o.returnedStale = !0), i ? l.__staleWhileFetching : void 0) : (s || this.delete(e), o && i && (o.returnedStale = !0), i ? l : void 0)) : (o && (o.get = "hit"), c ? l.__staleWhileFetching : (ze(this, Nl, Yh).call(this, a), r && Q(this, Ml).call(this, a), l));
    } else
      o && (o.get = "miss");
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(e) {
    var i, r, s, o;
    let t = !1;
    if (Q(this, Vn) !== 0) {
      const a = Q(this, Fn).get(e);
      if (a !== void 0)
        if (t = !0, Q(this, Vn) === 1)
          this.clear();
        else {
          Q(this, Rl).call(this, a);
          const l = Q(this, st)[a];
          ze(this, qt, rn).call(this, l) ? l.__abortController.abort(new Error("deleted")) : (Q(this, Fs) || Q(this, nr)) && (Q(this, Fs) && ((i = Q(this, Vs)) == null || i.call(this, l, e, "delete")), Q(this, nr) && ((r = Q(this, pi)) == null || r.push([l, e, "delete"]))), Q(this, Fn).delete(e), Q(this, Kt)[a] = void 0, Q(this, st)[a] = void 0, a === Q(this, ri) ? Ge(this, ri, Q(this, Or)[a]) : a === Q(this, Ti) ? Ge(this, Ti, Q(this, Vi)[a]) : (Q(this, Vi)[Q(this, Or)[a]] = Q(this, Vi)[a], Q(this, Or)[Q(this, Vi)[a]] = Q(this, Or)[a]), ep(this, Vn)._--, Q(this, fs).push(a);
        }
    }
    if (Q(this, nr) && ((s = Q(this, pi)) != null && s.length)) {
      const a = Q(this, pi);
      let l;
      for (; l = a == null ? void 0 : a.shift(); )
        (o = Q(this, hs)) == null || o.call(this, ...l);
    }
    return t;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var e, t, i;
    for (const r of ze(this, qs, fa).call(this, { allowStale: !0 })) {
      const s = Q(this, st)[r];
      if (ze(this, qt, rn).call(this, s))
        s.__abortController.abort(new Error("deleted"));
      else {
        const o = Q(this, Kt)[r];
        Q(this, Fs) && ((e = Q(this, Vs)) == null || e.call(this, s, o, "delete")), Q(this, nr) && ((t = Q(this, pi)) == null || t.push([s, o, "delete"]));
      }
    }
    if (Q(this, Fn).clear(), Q(this, st).fill(void 0), Q(this, Kt).fill(void 0), Q(this, ps) && Q(this, No) && (Q(this, ps).fill(0), Q(this, No).fill(0)), Q(this, Ro) && Q(this, Ro).fill(0), Ge(this, Ti, 0), Ge(this, ri, 0), Q(this, fs).length = 0, Ge(this, ds, 0), Ge(this, Vn, 0), Q(this, nr) && Q(this, pi)) {
      const r = Q(this, pi);
      let s;
      for (; s = r == null ? void 0 : r.shift(); )
        (i = Q(this, hs)) == null || i.call(this, ...s);
    }
  }
};
us = new WeakMap(), yr = new WeakMap(), Vs = new WeakMap(), hs = new WeakMap(), su = new WeakMap(), Vn = new WeakMap(), ds = new WeakMap(), Fn = new WeakMap(), Kt = new WeakMap(), st = new WeakMap(), Vi = new WeakMap(), Or = new WeakMap(), Ti = new WeakMap(), ri = new WeakMap(), fs = new WeakMap(), pi = new WeakMap(), Ro = new WeakMap(), No = new WeakMap(), ps = new WeakMap(), Fs = new WeakMap(), Sa = new WeakMap(), nr = new WeakMap(), vf = new WeakSet(), a1 = function() {
  const e = new Rg(Q(this, us)), t = new Rg(Q(this, us));
  Ge(this, ps, e), Ge(this, No, t), Ge(this, bf, (s, o, a = Bh.now()) => {
    if (t[s] = o !== 0 ? a : 0, e[s] = o, o !== 0 && this.ttlAutopurge) {
      const l = setTimeout(() => {
        Q(this, wr).call(this, s) && this.delete(Q(this, Kt)[s]);
      }, o + 1);
      l.unref && l.unref();
    }
  }), Ge(this, Ml, (s) => {
    t[s] = e[s] !== 0 ? Bh.now() : 0;
  }), Ge(this, Do, (s, o) => {
    if (e[o]) {
      const a = e[o], l = t[o];
      s.ttl = a, s.start = l, s.now = i || r(), s.remainingTTL = s.now + a - l;
    }
  });
  let i = 0;
  const r = () => {
    const s = Bh.now();
    if (this.ttlResolution > 0) {
      i = s;
      const o = setTimeout(() => i = 0, this.ttlResolution);
      o.unref && o.unref();
    }
    return s;
  };
  this.getRemainingTTL = (s) => {
    const o = Q(this, Fn).get(s);
    return o === void 0 ? 0 : e[o] === 0 || t[o] === 0 ? 1 / 0 : t[o] + e[o] - (i || r());
  }, Ge(this, wr, (s) => e[s] !== 0 && t[s] !== 0 && (i || r()) - t[s] > e[s]);
}, Ml = new WeakMap(), Do = new WeakMap(), bf = new WeakMap(), wr = new WeakMap(), ev = new WeakSet(), H4 = function() {
  const e = new Rg(Q(this, us));
  Ge(this, ds, 0), Ge(this, Ro, e), Ge(this, Rl, (t) => {
    Ge(this, ds, Q(this, ds) - e[t]), e[t] = 0;
  }), Ge(this, yf, (t, i, r, s) => {
    if (ze(this, qt, rn).call(this, i))
      return 0;
    if (!ha(r))
      if (s) {
        if (typeof s != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (r = s(i, t), !ha(r))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return r;
  }), Ge(this, ou, (t, i, r) => {
    if (e[t] = i, Q(this, yr)) {
      const s = Q(this, yr) - e[t];
      for (; Q(this, ds) > s; )
        ze(this, au, Ng).call(this, !0);
    }
    Ge(this, ds, Q(this, ds) + e[t]), r && (r.entrySize = i, r.totalCalculatedSize = Q(this, ds));
  });
}, Rl = new WeakMap(), ou = new WeakMap(), yf = new WeakMap(), Zs = new WeakSet(), da = function* ({ allowStale: e = this.allowStale } = {}) {
  if (Q(this, Vn))
    for (let t = Q(this, ri); !(!ze(this, Of, l1).call(this, t) || ((e || !Q(this, wr).call(this, t)) && (yield t), t === Q(this, Ti))); )
      t = Q(this, Or)[t];
}, qs = new WeakSet(), fa = function* ({ allowStale: e = this.allowStale } = {}) {
  if (Q(this, Vn))
    for (let t = Q(this, Ti); !(!ze(this, Of, l1).call(this, t) || ((e || !Q(this, wr).call(this, t)) && (yield t), t === Q(this, ri))); )
      t = Q(this, Vi)[t];
}, Of = new WeakSet(), l1 = function(e) {
  return e !== void 0 && Q(this, Fn).get(Q(this, Kt)[e]) === e;
}, au = new WeakSet(), Ng = function(e) {
  var s, o;
  const t = Q(this, Ti), i = Q(this, Kt)[t], r = Q(this, st)[t];
  return Q(this, Sa) && ze(this, qt, rn).call(this, r) ? r.__abortController.abort(new Error("evicted")) : (Q(this, Fs) || Q(this, nr)) && (Q(this, Fs) && ((s = Q(this, Vs)) == null || s.call(this, r, i, "evict")), Q(this, nr) && ((o = Q(this, pi)) == null || o.push([r, i, "evict"]))), Q(this, Rl).call(this, t), e && (Q(this, Kt)[t] = void 0, Q(this, st)[t] = void 0, Q(this, fs).push(t)), Q(this, Vn) === 1 ? (Ge(this, Ti, Ge(this, ri, 0)), Q(this, fs).length = 0) : Ge(this, Ti, Q(this, Vi)[t]), Q(this, Fn).delete(i), ep(this, Vn)._--, t;
}, lu = new WeakSet(), Dg = function(e, t, i, r) {
  const s = t === void 0 ? void 0 : Q(this, st)[t];
  if (ze(this, qt, rn).call(this, s))
    return s;
  const o = new AbortController(), { signal: a } = i;
  a == null || a.addEventListener("abort", () => o.abort(a.reason), {
    signal: o.signal
  });
  const l = {
    signal: o.signal,
    options: i,
    context: r
  }, c = (g, m = !1) => {
    const { aborted: v } = o.signal, y = i.ignoreFetchAbort && g !== void 0;
    if (i.status && (v && !m ? (i.status.fetchAborted = !0, i.status.fetchError = o.signal.reason, y && (i.status.fetchAbortIgnored = !0)) : i.status.fetchResolved = !0), v && !y && !m)
      return h(o.signal.reason);
    const b = f;
    return Q(this, st)[t] === f && (g === void 0 ? b.__staleWhileFetching ? Q(this, st)[t] = b.__staleWhileFetching : this.delete(e) : (i.status && (i.status.fetchUpdated = !0), this.set(e, g, l.options))), g;
  }, u = (g) => (i.status && (i.status.fetchRejected = !0, i.status.fetchError = g), h(g)), h = (g) => {
    const { aborted: m } = o.signal, v = m && i.allowStaleOnFetchAbort, y = v || i.allowStaleOnFetchRejection, b = y || i.noDeleteOnFetchRejection, w = f;
    if (Q(this, st)[t] === f && (!b || w.__staleWhileFetching === void 0 ? this.delete(e) : v || (Q(this, st)[t] = w.__staleWhileFetching)), y)
      return i.status && w.__staleWhileFetching !== void 0 && (i.status.returnedStale = !0), w.__staleWhileFetching;
    if (w.__returned === w)
      throw g;
  }, d = (g, m) => {
    var y;
    const v = (y = Q(this, su)) == null ? void 0 : y.call(this, e, s, l);
    v && v instanceof Promise && v.then((b) => g(b), m), o.signal.addEventListener("abort", () => {
      (!i.ignoreFetchAbort || i.allowStaleOnFetchAbort) && (g(), i.allowStaleOnFetchAbort && (g = (b) => c(b, !0)));
    });
  };
  i.status && (i.status.fetchDispatched = !0);
  const f = new Promise(d).then(c, u), p = Object.assign(f, {
    __abortController: o,
    __staleWhileFetching: s,
    __returned: void 0
  });
  return t === void 0 ? (this.set(e, p, { ...l.options, status: void 0 }), t = Q(this, Fn).get(e)) : Q(this, st)[t] = p, p;
}, qt = new WeakSet(), rn = function(e) {
  if (!Q(this, Sa))
    return !1;
  const t = e;
  return !!t && t instanceof Promise && t.hasOwnProperty("__staleWhileFetching") && t.__abortController instanceof AbortController;
}, wf = new WeakSet(), c1 = function(e, t) {
  Q(this, Or)[t] = e, Q(this, Vi)[e] = t;
}, Nl = new WeakSet(), Yh = function(e) {
  e !== Q(this, ri) && (e === Q(this, Ti) ? Ge(this, Ti, Q(this, Vi)[e]) : ze(this, wf, c1).call(this, Q(this, Or)[e], Q(this, Vi)[e]), ze(this, wf, c1).call(this, Q(this, ri), e), Ge(this, ri, e));
};
let o1 = oS;
const rXe = (n, e) => {
  const t = ke("editorId"), { noImgZoomIn: i } = n, r = nx(() => {
    const s = document.querySelectorAll(`#${t}-preview img`);
    s.length !== 0 && _pe(s, {
      background: "#00000073"
    });
  });
  qe(() => {
    !i && n.setting.preview && r();
  }), ne([e], () => {
    !i && r();
  });
}, sXe = rXe, oXe = (n, e) => {
  if (typeof e[n] == "string")
    return e[n];
  const t = `<i class="${Lt}-iconfont ${Lt}-icon-${n}"></i>`;
  switch (oo.iconfontType) {
    case "svg":
      return `<svg class="${Lt}-icon" aria-hidden="true"><use xlink:href="#${Lt}-icon-${n}"></use></svg>`;
    default:
      return t;
  }
}, aXe = (n, e, t) => {
  const i = ke("editorId"), r = ke("usedLanguageText"), s = ke("customIcon"), o = () => {
    document.querySelectorAll(`#${i}-preview pre`).forEach((c) => {
      var u, h;
      let d = -1;
      (u = c.querySelector(".copy-button")) == null || u.remove();
      const f = ((h = r.value.copyCode) == null ? void 0 : h.text) || "复制代码", p = document.createElement("span");
      p.setAttribute("class", "copy-button"), p.dataset.tips = f, p.innerHTML = oXe("copy", s.value), p.addEventListener("click", () => {
        var g, m;
        clearTimeout(d);
        const v = c.querySelector("code").innerText, y = Bpe(n.formatCopiedText(v)), b = ((g = r.value.copyCode) == null ? void 0 : g.successTips) || "已复制！", w = ((m = r.value.copyCode) == null ? void 0 : m.failTips) || "已复制！";
        p.dataset.tips = y ? b : w, d = window.setTimeout(() => {
          p.dataset.tips = f;
        }, 1500);
      }), c.appendChild(p);
    });
  }, a = () => {
    $e(o);
  }, l = (c) => {
    c && $e(o);
  };
  ne([e, t], a), ne(() => n.setting.preview, l), ne(() => n.setting.htmlPreview, l), ne(() => r.value, o), qe(o);
}, lXe = aXe, cXe = (n) => {
  var e;
  const t = (e = oo.editorExtensions) == null ? void 0 : e.highlight, i = t == null ? void 0 : t.instance, r = ke("highlight"), s = In(i);
  return qe(() => {
    if (!n.noHighlight && !s.value) {
      const o = document.createElement("script");
      o.src = r.value.js, o.onload = () => {
        s.value = window.hljs;
      }, o.id = `${Lt}-hljs`, Gl(o, "hljs");
      const a = document.createElement("link");
      a.rel = "stylesheet", a.href = r.value.css, a.id = `${Lt}-hlCss`, Gl(a);
    }
  }), ne(
    () => r.value.css,
    (o) => {
      Zoe(`${Lt}-hlCss`, "href", o);
    }
  ), s;
}, uXe = cXe, hXe = (n) => {
  const e = ke("theme"), { editorExtensions: t, mermaidConfig: i } = oo, r = t == null ? void 0 : t.mermaid, s = In(r == null ? void 0 : r.instance), o = In(-1), a = new o1({
    max: 1e3,
    // 缓存10分钟
    ttl: 6e5
  }), l = () => {
    const c = s.value;
    !n.noMermaid && c && (c.initialize(
      i({
        startOnLoad: !1,
        theme: e.value === "dark" ? "dark" : "default"
      })
    ), o.value = o.value + 1);
  };
  return ne(
    () => e.value,
    () => {
      a.clear(), l();
    }
  ), qe(() => {
    if (!n.noMermaid && !(r != null && r.instance)) {
      const c = (r == null ? void 0 : r.js) || Loe;
      if (/\.mjs/.test(c))
        import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          c
        ).then((u) => {
          s.value = u.default, l();
        });
      else {
        const u = document.createElement("script");
        u.id = `${Lt}-mermaid`, u.src = c, u.onload = () => {
          s.value = window.mermaid, l();
        }, Gl(u, "mermaid");
      }
    }
  }), { mermaidRef: s, reRenderRef: o, replaceMermaid: () => {
    $e(() => {
      if (!n.noMermaid && s.value) {
        const c = document.querySelectorAll(
          `div.${Lt}-mermaid`
        ), u = document.createElement("div");
        u.style.width = document.body.offsetWidth + "px", u.style.height = document.body.offsetHeight + "px", u.style.position = "fixed", u.style.zIndex = "-10000", u.style.top = "-10000";
        let h = c.length;
        h > 0 && document.body.appendChild(u), c.forEach(async (d) => {
          let f = a.get(d.innerText);
          if (!f) {
            const g = eO(), m = s.value.renderAsync || s.value.render;
            let v = "";
            try {
              v = await m(g, d.innerText, u);
            } catch {
            }
            f = await n.sanitizeMermaid(
              typeof v == "string" ? v : v.svg
            ), a.set(d.innerText, f);
          }
          const p = document.createElement("p");
          p.className = `${Lt}-mermaid`, p.setAttribute("data-processed", ""), p.innerHTML = f, d.dataset.line !== void 0 && (p.dataset.line = d.dataset.line), d.replaceWith(p), --h === 0 && u.remove();
        });
      }
    });
  } };
}, dXe = hXe, fXe = (n) => {
  var e;
  const t = (e = oo.editorExtensions) == null ? void 0 : e.katex, i = t == null ? void 0 : t.instance, r = In(i);
  return qe(() => {
    if (!n.noKatex && !r.value) {
      const s = document.createElement("script");
      s.src = (t == null ? void 0 : t.js) || i2.js, s.onload = () => {
        r.value = window.katex;
      }, s.id = `${Lt}-katex`;
      const o = document.createElement("link");
      o.rel = "stylesheet", o.href = (t == null ? void 0 : t.css) || i2.css, o.id = `${Lt}-katexCss`, Gl(s, "katex"), Gl(o);
    }
  }), r;
}, pXe = fXe, gXe = (n, e) => {
  const t = n.renderer.rules.fence.bind(n.renderer.rules);
  n.renderer.rules.fence = (i, r, s, o, a) => {
    const l = i[r], c = l.content.trim();
    if (l.info === "mermaid") {
      let u;
      return i[r].map && i[r].level === 0 && (u = i[r].map[0], i[r].attrSet("data-line", String(u))), `<div class="${Lt}-mermaid" ${u !== void 0 ? "data-line=" + u : ""} data-mermaid-theme=${e.themeRef.value}>${c}</div>`;
    }
    return t(i, r, s, o, a);
  };
}, mXe = gXe, ZE = (n, e) => {
  let t = !0, i = !0;
  const r = n.posMax, s = e > 0 ? n.src.charCodeAt(e - 1) : -1, o = e + 1 <= r ? n.src.charCodeAt(e + 1) : -1;
  return (s === 32 || s === 9 || o >= 48 && o <= 57) && (i = !1), (o === 32 || o === 9) && (t = !1), {
    can_open: t,
    can_close: i
  };
}, vXe = (n, e) => {
  let t, i, r, s;
  if (n.src[n.pos] !== "$")
    return !1;
  if (r = ZE(n, n.pos), !r.can_open)
    return e || (n.pending += "$"), n.pos += 1, !0;
  const o = n.pos + 1;
  for (t = o; (t = n.src.indexOf("$", t)) !== -1; ) {
    for (s = t - 1; n.src[s] === "\\"; )
      s -= 1;
    if ((t - s) % 2 == 1)
      break;
    t += 1;
  }
  return t === -1 ? (e || (n.pending += "$"), n.pos = o, !0) : t - o === 0 ? (e || (n.pending += "$$"), n.pos = o + 1, !0) : (r = ZE(n, t), r.can_close ? (e || (i = n.push("math_inline", "math", 0), i.markup = "$", i.content = n.src.slice(o, t)), n.pos = t + 1, !0) : (e || (n.pending += "$"), n.pos = o, !0));
}, bXe = (n, e, t, i) => {
  let r, s, o, a, l = !1, c = n.bMarks[e] + n.tShift[e], u = n.eMarks[e];
  if (c + 2 > u || n.src.slice(c, c + 2) !== "$$")
    return !1;
  if (c += 2, r = n.src.slice(c, u), i)
    return !0;
  for (r.trim().slice(-2) === "$$" && (r = r.trim().slice(0, -2), l = !0), o = e; !l && (o++, !(o >= t || (c = n.bMarks[o] + n.tShift[o], u = n.eMarks[o], c < u && n.tShift[o] < n.blkIndent))); )
    n.src.slice(c, u).trim().slice(-2) === "$$" && (a = n.src.slice(0, u).lastIndexOf("$$"), s = n.src.slice(c, a), l = !0);
  n.line = o + 1;
  const h = n.push("math_block", "math", 0);
  return h.block = !0, h.content = (r && r.trim() ? r + `
` : "") + n.getLines(e + 1, o, n.tShift[e], !0) + (s && s.trim() ? s : ""), h.map = [e, n.line], h.markup = "$$", !0;
}, yXe = (n, e) => {
  const t = (r) => {
    if (e.katexRef.value) {
      const s = e.katexRef.value.renderToString(r, {
        throwOnError: !1
      });
      return `<span class="${Lt}-katex-inline" data-processed>${s}</span>`;
    } else
      return `<span class="${Lt}-katex-inline">${r}</span>`;
  }, i = (r, s) => {
    if (e.katexRef.value) {
      const o = e.katexRef.value.renderToString(r, {
        throwOnError: !1,
        displayMode: !0
      });
      return `<p class="${Lt}-katex-block" data-line=${s} data-processed>${o}</p>`;
    } else
      return `<p class="${Lt}-katex-block" data-line=${s}>${r}</p>`;
  };
  n.inline.ruler.after("escape", "math_inline", vXe), n.block.ruler.after("blockquote", "math_block", bXe, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), n.renderer.rules.math_inline = (r, s) => t(r[s].content), n.renderer.rules.math_block = (r, s) => i(r[s].content, r[s].map[0]) + `
`;
}, OXe = yXe, wXe = (n, e) => {
  e = e || {};
  const t = 3, i = e.marker || "!", r = i.charCodeAt(0), s = i.length;
  let o = "", a = "";
  const l = (u, h, d, f, p) => {
    const g = u[h];
    return g.type === "admonition_open" ? (u[h].attrPush([
      "class",
      `${Lt}-admonition ${Lt}-admonition-${g.info}`
    ]), u[h].attrSet("data-line", String(u[h].map[0]))) : g.type === "admonition_title_open" && u[h].attrPush(["class", `${Lt}-admonition-title`]), p.renderToken(u, h, d);
  }, c = (u) => {
    const h = u.trim().split(" ", 2);
    a = "", o = h[0], h.length > 1 && (a = u.substring(o.length + 2)), (a === "" || !a) && (a = o);
  };
  n.block.ruler.before(
    "code",
    "admonition",
    (u, h, d, f) => {
      let p, g, m, v = !1, y = u.bMarks[h] + u.tShift[h], b = u.eMarks[h];
      if (r !== u.src.charCodeAt(y))
        return !1;
      for (p = y + 1; p <= b && i[(p - y) % s] === u.src[p]; p++)
        ;
      const w = Math.floor((p - y) / s);
      if (w !== t)
        return !1;
      p -= (p - y) % s;
      const x = u.src.slice(y, p), S = u.src.slice(p, b);
      if (c(S), f)
        return !0;
      for (g = h; g++, !(g >= d || (y = u.bMarks[g] + u.tShift[g], b = u.eMarks[g], y < b && u.sCount[g] < u.blkIndent)); )
        if (r === u.src.charCodeAt(y) && !(u.sCount[g] - u.blkIndent >= 4)) {
          for (p = y + 1; p <= b && i[(p - y) % s] === u.src[p]; p++)
            ;
          if (!(Math.floor((p - y) / s) < w) && (p -= (p - y) % s, p = u.skipSpaces(p), !(p < b))) {
            v = !0;
            break;
          }
        }
      const C = u.parentType, k = u.lineMax;
      return u.parentType = "root", u.lineMax = g, m = u.push("admonition_open", "div", 1), m.markup = x, m.block = !0, m.info = o, m.map = [h, g], m = u.push("admonition_title_open", "p", 1), m.markup = x + " " + o, m.map = [h, g], m = u.push("inline", "", 0), m.content = a, m.map = [h, u.line - 1], m.children = [], m = u.push("admonition_title_close", "p", -1), m.markup = x + " " + o, u.md.block.tokenize(u, h + 1, g), m = u.push("admonition_close", "div", -1), m.markup = u.src.slice(y, p), m.block = !0, u.parentType = C, u.lineMax = k, u.line = g + (v ? 1 : 0), !0;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  ), n.renderer.rules.admonition_open = l, n.renderer.rules.admonition_title_open = l, n.renderer.rules.admonition_title_close = l, n.renderer.rules.admonition_close = l;
}, xXe = wXe, SXe = (n, e) => {
  n.renderer.rules.heading_open = (t, i) => {
    var r;
    const s = t[i], o = ((r = t[i + 1].children) == null ? void 0 : r.reduce((l, c) => l + (c.content || ""), "")) || "", a = s.markup.length;
    return e.headsRef.value.push({
      text: o,
      level: a
    }), s.map && s.level === 0 && (s.attrSet("data-line", String(s.map[0])), s.attrSet(
      "id",
      e.mdHeadingId(o, a, e.headsRef.value.length)
    )), n.renderer.renderToken(t, i, e);
  }, n.renderer.rules.heading_close = (t, i, r, s, o) => o.renderToken(t, i, r);
}, CXe = SXe, kXe = (n, e) => {
  const t = n.renderer.rules.fence, i = n.utils.unescapeAll, r = /\[(\w*)(?::([\w ]*))?\]/;
  function s(c) {
    return c.info ? i(c.info).trim() : "";
  }
  function o(c) {
    const u = s(c), [h = null, d = ""] = (r.exec(u) || []).slice(1);
    return [h, d];
  }
  function a(c) {
    const u = s(c);
    return u ? u.split(/(\s+)/g)[0] : "";
  }
  const l = (c, u, h, d, f) => {
    if (c[u].hidden)
      return "";
    const [p, g] = o(c[u]);
    if (p === null)
      return t(c, u, h, d, f);
    let m, v, y, b, w = "", x = "";
    for (let S = u; S < c.length && (m = c[S], [v, y] = o(m), v === p); S++)
      m.info = m.info.replace(r, ""), m.hidden = !0, b = S - u > 0 ? "" : " checked", w += `<li><input type="radio" name="label-group-${e.editorId}-${u}"${b}><label for="group-${e.editorId}-${u}-tab-${S - u}" onclick="this.previousElementSibling.click()">${y || a(m)}</label></li>
`, x += `<input type="radio" id="group-${e.editorId}-${u}-tab-${S - u}" name="group-${e.editorId}-${u}"${b}>
` + t(c, S, h, d, f);
    return `<div class="code-tabs">
<ul>
` + w + `</ul>
` + x + "</div>";
  };
  n.renderer.rules.fence = l;
}, PXe = kXe, EXe = (n) => {
  [
    "paragraph_open",
    "table_open",
    "ordered_list_open",
    "bullet_list_open",
    "blockquote_open",
    "hr",
    "html_block",
    "fence"
  ].forEach((e) => {
    const t = n.renderer.rules[e];
    t ? n.renderer.rules[e] = (i, r, s, o, a) => {
      let l;
      const c = t(i, r, s, o, a);
      return i[r].map && i[r].level === 0 && !/^<!--/.test(c) ? (l = i[r].map[0], c.replace(/^(<[^>]*)/, `$1 data-line="${l}"`)) : c;
    } : n.renderer.rules[e] = (i, r, s, o, a) => {
      let l;
      return i[r].map && i[r].level === 0 && (l = i[r].map[0], i[r].attrSet("data-line", String(l))), a.renderToken(i, r, s);
    };
  });
}, AXe = (n, e) => {
  const { editorConfig: t, markdownItConfig: i, markdownItPlugins: r } = oo, s = ke("editorId"), o = ke("showCodeRowNumber"), a = ke("theme"), l = D([]), c = uXe(n), u = pXe(n), { reRenderRef: h, replaceMermaid: d } = dXe(n), f = HWe({
    html: !0,
    breaks: !0
  });
  i(f, {
    editorId: s
  });
  const p = [
    {
      type: "katex",
      plugin: OXe,
      options: { katexRef: u }
    },
    {
      type: "image",
      plugin: YWe,
      options: { figcaption: !0, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: xXe,
      options: {}
    },
    {
      type: "taskList",
      plugin: lHe,
      options: {}
    },
    {
      type: "heading",
      plugin: CXe,
      options: { mdHeadingId: n.mdHeadingId, headsRef: l }
    },
    {
      type: "codeTabs",
      plugin: PXe,
      options: { editorId: s }
    },
    {
      type: "xss",
      plugin: tXe,
      options: {
        // https://github.com/leizongmin/js-xss/blob/master/README.zh.md
        xss(x) {
          return {
            whiteList: Object.assign({}, x.getDefaultWhiteList(), {
              input: ["class", "disabled", "type", "checked"]
            })
          };
        }
      }
    }
  ];
  n.noMermaid || p.push({
    type: "mermaid",
    plugin: mXe,
    options: { themeRef: a }
  }), r(p, {
    editorId: s
  }).forEach((x) => {
    f.use(x.plugin, x.options);
  });
  const g = f.options.highlight;
  f.set({
    highlight: (x, S, C) => {
      if (g) {
        const M = g(x, S, C);
        if (M)
          return M;
      }
      let k;
      !n.noHighlight && c.value ? c.value.getLanguage(S) ? k = c.value.highlight(x, {
        language: S,
        ignoreIllegals: !0
      }).value : k = c.value.highlightAuto(x).value : k = f.utils.escapeHtml(x);
      const E = o ? Foe(k.replace(/^\n+|\n+$/g, "")) : `<span class="code-block">${k.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${S}" language=${S}>${E}</code></pre>`;
    }
  }), EXe(f);
  const m = D(`_article-key_${eO()}`), v = D(n.sanitize(f.render(n.modelValue))), y = () => {
    yl.emit(s, joe, v.value), n.onHtmlChanged(v.value), n.onGetCatalog(l.value), yl.emit(s, s2, l.value), d();
  };
  qe(y);
  const b = () => {
    l.value = [], v.value = n.sanitize(f.render(n.modelValue)), y();
  }, w = $(() => (n.noKatex || u.value) && (n.noHighlight || c.value));
  return ne(
    [Pr(n, "modelValue"), w, h],
    nx(
      b,
      (t == null ? void 0 : t.renderDelay) !== void 0 ? t == null ? void 0 : t.renderDelay : e ? 0 : 500
    )
  ), qe(() => {
    yl.on(s, {
      name: Voe,
      callback() {
        yl.emit(s, s2, l.value);
      }
    }), yl.on(s, {
      name: KR,
      callback: () => {
        b(), m.value = `_article-key_${eO()}`;
      }
    });
  }), { html: v, key: m };
}, $Xe = AXe, X4 = {
  modelValue: {
    type: String,
    default: ""
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: !1
  },
  sanitize: {
    type: Function,
    default: (n) => n
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: !1
  },
  formatCopiedText: {
    type: Function,
    default: (n) => n
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  previewOnly: {
    type: Boolean,
    default: !1
  },
  noImgZoomIn: {
    type: Boolean
  },
  sanitizeMermaid: {
    type: Function
  }
};
({
  ...X4
});
const TXe = /* @__PURE__ */ F({
  name: "ContentPreview",
  props: X4,
  setup(n) {
    const e = ke("editorId"), t = ke("previewTheme"), i = ke("showCodeRowNumber"), {
      html: r,
      key: s
    } = $Xe(n, n.previewOnly);
    return lXe(n, r, s), sXe(n, r), () => K(Tt, null, [K("div", {
      id: `${e}-preview-wrapper`,
      class: `${Lt}-preview-wrapper`,
      "data-show": n.setting.preview,
      key: "content-preview-wrapper"
    }, [K("div", {
      key: s.value,
      id: `${e}-preview`,
      class: [`${Lt}-preview`, `${t == null ? void 0 : t.value}-theme`, i && `${Lt}-scrn`],
      innerHTML: r.value
    }, null)]), !n.previewOnly && K("div", {
      id: `${e}-html-wrapper`,
      class: `${Lt}-preview-wrapper`,
      "data-show": n.setting.htmlPreview,
      key: "html-preview-wrapper"
    }, [K("div", {
      class: `${Lt}-html`
    }, [r.value])])]);
  }
}), _Xe = (n) => {
  var e, t;
  const { editorId: i } = n, r = (t = (e = oo) == null ? void 0 : e.editorExtensions) == null ? void 0 : t.highlight;
  ft("editorId", i), ft(
    "theme",
    $(() => n.theme)
  ), ft(
    "language",
    $(() => n.language)
  ), ft(
    "highlight",
    $(() => {
      const o = {
        ...r2,
        ...r == null ? void 0 : r.css
      }, a = n.codeStyleReverse && n.codeStyleReverseList.includes(n.previewTheme) ? "dark" : n.theme;
      return {
        js: (r == null ? void 0 : r.js) || Roe,
        css: o[n.codeTheme] ? o[n.codeTheme][a] : r2.atom[a]
      };
    })
  ), ft("showCodeRowNumber", n.showCodeRowNumber);
  const s = $(() => {
    var o, a;
    const l = {
      ...n2,
      ...(a = (o = oo) == null ? void 0 : o.editorConfig) == null ? void 0 : a.languageUserDefined
    };
    return l[n.language] ? l[n.language] : n2["zh-CN"];
  });
  ft("usedLanguageText", s), ft(
    "previewTheme",
    $(() => n.previewTheme)
  ), ft(
    "customIcon",
    $(() => n.customIcon)
  );
}, MXe = (n) => {
  qe(() => {
    var e, t;
    if (!n.noIconfont)
      if (oo.iconfontType === "svg") {
        const i = document.createElement("script");
        i.src = ((e = oo.editorExtensions) == null ? void 0 : e.iconfont) || _oe, i.id = `${Lt}-icon`, Gl(i);
      } else {
        const i = document.createElement("link");
        i.rel = "stylesheet", i.href = ((t = oo.editorExtensions) == null ? void 0 : t.iconfontClass) || Moe, i.id = `${Lt}-icon-class`, Gl(i);
      }
  });
}, RXe = (n) => n, Y4 = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: Toe
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default false
   */
  showCodeRowNumber: {
    type: Boolean,
    default: !1
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: RXe
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (n) => n
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: !1
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: !1
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (n) => n
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: !0
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: !1
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  },
  sanitizeMermaid: {
    type: Function,
    default: (n) => Promise.resolve(n)
  }
};
({
  ...Y4
});
const U4 = ["onHtmlChanged", "onGetCatalog"];
[
  ...U4
];
const NXe = (n, e) => {
  const { editorId: t } = n, i = {
    rerender() {
      yl.emit(t, KR);
    }
  };
  e.expose(i);
}, DXe = /* @__PURE__ */ F({
  name: "MdPreview",
  props: Y4,
  emits: U4,
  setup(n, e) {
    const {
      editorId: t,
      noKatex: i,
      noMermaid: r,
      noHighlight: s
    } = n;
    return _Xe(n), MXe(n), NXe(n, e), Kn(() => {
      yl.clear(t);
    }), () => K("div", {
      id: t,
      class: [Lt, n.class, n.theme === "dark" && `${Lt}-dark`, `${Lt}-previewOnly`],
      style: n.style
    }, [K(TXe, {
      modelValue: n.modelValue,
      onHtmlChanged: (o) => {
        n.onHtmlChanged ? n.onHtmlChanged(o) : e.emit("onHtmlChanged", o);
      },
      onGetCatalog: (o) => {
        n.onGetCatalog ? n.onGetCatalog(o) : e.emit("onGetCatalog", o);
      },
      mdHeadingId: n.mdHeadingId,
      noMermaid: r,
      sanitize: n.sanitize,
      noKatex: i,
      formatCopiedText: n.formatCopiedText,
      noHighlight: s,
      noImgZoomIn: n.noImgZoomIn,
      previewOnly: !0,
      sanitizeMermaid: n.sanitizeMermaid
    }, null)]);
  }
}), $b = DXe;
$b.install = (n) => (n.component($b.name, $b), n);
const LXe = zv({
  String: X.string,
  Number: X.number,
  "True False": X.bool,
  PropertyName: X.propertyName,
  Null: X.null,
  ",": X.separator,
  "[ ]": X.squareBracket,
  "{ }": X.brace
}), IXe = Yu.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [LXe],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), BXe = /* @__PURE__ */ qu.define({
  name: "json",
  parser: /* @__PURE__ */ IXe.configure({
    props: [
      /* @__PURE__ */ Fv.add({
        Object: /* @__PURE__ */ Kc({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ Kc({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Zv.add({
        "Object Array": NN
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function gJe() {
  return new wx(BXe);
}
var QXe = Object.defineProperty, qm = Object.getOwnPropertySymbols, G4 = Object.prototype.hasOwnProperty, K4 = Object.prototype.propertyIsEnumerable, qE = (n, e, t) => e in n ? QXe(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, zc = (n, e) => {
  for (var t in e || (e = {}))
    G4.call(e, t) && qE(n, t, e[t]);
  if (qm)
    for (var t of qm(e))
      K4.call(e, t) && qE(n, t, e[t]);
  return n;
}, J4 = (n, e) => {
  var t = {};
  for (var i in n)
    G4.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && qm)
    for (var i of qm(n))
      e.indexOf(i) < 0 && K4.call(n, i) && (t[i] = n[i]);
  return t;
};
const eL = "[vue-draggable-plus]: ";
function zXe(n) {
  console.warn(eL + n);
}
function jXe(n) {
  console.error(eL + n);
}
function WE(n, e, t) {
  return t >= 0 && t < n.length && n.splice(t, 0, n.splice(e, 1)[0]), n;
}
function VXe(n) {
  return n.replace(/-(\w)/g, (e, t) => t ? t.toUpperCase() : "");
}
function FXe(n) {
  return Object.keys(n).reduce((e, t) => (typeof n[t] < "u" && (e[VXe(t)] = n[t]), e), {});
}
function ZXe(n, e) {
  if (Array.isArray(n))
    return n.splice(e, 1);
}
function qXe(n, e, t) {
  if (Array.isArray(n))
    return n.splice(e, 0, t);
}
function WXe(n) {
  return typeof n > "u";
}
function HXe(n) {
  return typeof n == "string";
}
function HE(n, e, t) {
  const i = n.children[t];
  n.insertBefore(e, i);
}
function Tb(n) {
  n.parentNode && n.parentNode.removeChild(n);
}
function XXe(n, e = document) {
  var t;
  let i = null;
  return typeof (e == null ? void 0 : e.querySelector) == "function" ? i = (t = e == null ? void 0 : e.querySelector) == null ? void 0 : t.call(e, n) : i = document.querySelector(n), i || zXe(`Element not found: ${n}`), i;
}
function YXe(n, e, t = null) {
  return function(...i) {
    return n.apply(t, i), e.apply(t, i);
  };
}
function UXe(n, e) {
  const t = zc({}, n);
  return Object.keys(e).forEach((i) => {
    t[i] ? t[i] = YXe(n[i], e[i]) : t[i] = e[i];
  }), t;
}
function GXe(n) {
  return n instanceof HTMLElement;
}
function KXe(n, e) {
  Object.keys(n).forEach((t) => {
    e(t, n[t]);
  });
}
/**!
 * Sortable 1.15.1
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function XE(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function mo(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? XE(Object(t), !0).forEach(function(i) {
      JXe(n, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : XE(Object(t)).forEach(function(i) {
      Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return n;
}
function Lg(n) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Lg = function(e) {
    return typeof e;
  } : Lg = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Lg(n);
}
function JXe(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Go() {
  return Go = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Go.apply(this, arguments);
}
function eYe(n, e) {
  if (n == null)
    return {};
  var t = {}, i = Object.keys(n), r, s;
  for (s = 0; s < i.length; s++)
    r = i[s], !(e.indexOf(r) >= 0) && (t[r] = n[r]);
  return t;
}
function tYe(n, e) {
  if (n == null)
    return {};
  var t = eYe(n, e), i, r;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (r = 0; r < s.length; r++)
      i = s[r], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i]);
  }
  return t;
}
var nYe = "1.15.1";
function Qo(n) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(n);
}
var ra = Qo(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), Xf = Qo(/Edge/i), YE = Qo(/firefox/i), xd = Qo(/safari/i) && !Qo(/chrome/i) && !Qo(/android/i), tL = Qo(/iP(ad|od|hone)/i), nL = Qo(/chrome/i) && Qo(/android/i), iL = {
  capture: !1,
  passive: !1
};
function Mt(n, e, t) {
  n.addEventListener(e, t, !ra && iL);
}
function Ct(n, e, t) {
  n.removeEventListener(e, t, !ra && iL);
}
function Wm(n, e) {
  if (e) {
    if (e[0] === ">" && (e = e.substring(1)), n)
      try {
        if (n.matches)
          return n.matches(e);
        if (n.msMatchesSelector)
          return n.msMatchesSelector(e);
        if (n.webkitMatchesSelector)
          return n.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function iYe(n) {
  return n.host && n !== document && n.host.nodeType ? n.host : n.parentNode;
}
function js(n, e, t, i) {
  if (n) {
    t = t || document;
    do {
      if (e != null && (e[0] === ">" ? n.parentNode === t && Wm(n, e) : Wm(n, e)) || i && n === t)
        return n;
      if (n === t)
        break;
    } while (n = iYe(n));
  }
  return null;
}
var UE = /\s+/g;
function vr(n, e, t) {
  if (n && e)
    if (n.classList)
      n.classList[t ? "add" : "remove"](e);
    else {
      var i = (" " + n.className + " ").replace(UE, " ").replace(" " + e + " ", " ");
      n.className = (i + (t ? " " + e : "")).replace(UE, " ");
    }
}
function Ve(n, e, t) {
  var i = n && n.style;
  if (i) {
    if (t === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? t = document.defaultView.getComputedStyle(n, "") : n.currentStyle && (t = n.currentStyle), e === void 0 ? t : t[e];
    !(e in i) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), i[e] = t + (typeof t == "string" ? "" : "px");
  }
}
function iu(n, e) {
  var t = "";
  if (typeof n == "string")
    t = n;
  else
    do {
      var i = Ve(n, "transform");
      i && i !== "none" && (t = i + " " + t);
    } while (!e && (n = n.parentNode));
  var r = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return r && new r(t);
}
function rL(n, e, t) {
  if (n) {
    var i = n.getElementsByTagName(e), r = 0, s = i.length;
    if (t)
      for (; r < s; r++)
        t(i[r], r);
    return i;
  }
  return [];
}
function lo() {
  var n = document.scrollingElement;
  return n || document.documentElement;
}
function Rn(n, e, t, i, r) {
  if (!(!n.getBoundingClientRect && n !== window)) {
    var s, o, a, l, c, u, h;
    if (n !== window && n.parentNode && n !== lo() ? (s = n.getBoundingClientRect(), o = s.top, a = s.left, l = s.bottom, c = s.right, u = s.height, h = s.width) : (o = 0, a = 0, l = window.innerHeight, c = window.innerWidth, u = window.innerHeight, h = window.innerWidth), (e || t) && n !== window && (r = r || n.parentNode, !ra))
      do
        if (r && r.getBoundingClientRect && (Ve(r, "transform") !== "none" || t && Ve(r, "position") !== "static")) {
          var d = r.getBoundingClientRect();
          o -= d.top + parseInt(Ve(r, "border-top-width")), a -= d.left + parseInt(Ve(r, "border-left-width")), l = o + s.height, c = a + s.width;
          break;
        }
      while (r = r.parentNode);
    if (i && n !== window) {
      var f = iu(r || n), p = f && f.a, g = f && f.d;
      f && (o /= g, a /= p, h /= p, u /= g, l = o + u, c = a + h);
    }
    return {
      top: o,
      left: a,
      bottom: l,
      right: c,
      width: h,
      height: u
    };
  }
}
function sL(n) {
  var e = Rn(n), t = parseInt(Ve(n, "padding-left")), i = parseInt(Ve(n, "padding-top")), r = parseInt(Ve(n, "padding-right")), s = parseInt(Ve(n, "padding-bottom"));
  return e.top += i + parseInt(Ve(n, "border-top-width")), e.left += t + parseInt(Ve(n, "border-left-width")), e.width = n.clientWidth - t - r, e.height = n.clientHeight - i - s, e.bottom = e.top + e.height, e.right = e.left + e.width, e;
}
function GE(n, e, t) {
  for (var i = Ta(n, !0), r = Rn(n)[e]; i; ) {
    var s = Rn(i)[t], o = void 0;
    if (t === "top" || t === "left" ? o = r >= s : o = r <= s, !o)
      return i;
    if (i === lo())
      break;
    i = Ta(i, !1);
  }
  return !1;
}
function Uu(n, e, t, i) {
  for (var r = 0, s = 0, o = n.children; s < o.length; ) {
    if (o[s].style.display !== "none" && o[s] !== et.ghost && (i || o[s] !== et.dragged) && js(o[s], t.draggable, n, !1)) {
      if (r === e)
        return o[s];
      r++;
    }
    s++;
  }
  return null;
}
function Ux(n, e) {
  for (var t = n.lastElementChild; t && (t === et.ghost || Ve(t, "display") === "none" || e && !Wm(t, e)); )
    t = t.previousElementSibling;
  return t || null;
}
function Ir(n, e) {
  var t = 0;
  if (!n || !n.parentNode)
    return -1;
  for (; n = n.previousElementSibling; )
    n.nodeName.toUpperCase() !== "TEMPLATE" && n !== et.clone && (!e || Wm(n, e)) && t++;
  return t;
}
function KE(n) {
  var e = 0, t = 0, i = lo();
  if (n)
    do {
      var r = iu(n), s = r.a, o = r.d;
      e += n.scrollLeft * s, t += n.scrollTop * o;
    } while (n !== i && (n = n.parentNode));
  return [e, t];
}
function rYe(n, e) {
  for (var t in n)
    if (n.hasOwnProperty(t)) {
      for (var i in e)
        if (e.hasOwnProperty(i) && e[i] === n[t][i])
          return Number(t);
    }
  return -1;
}
function Ta(n, e) {
  if (!n || !n.getBoundingClientRect)
    return lo();
  var t = n, i = !1;
  do
    if (t.clientWidth < t.scrollWidth || t.clientHeight < t.scrollHeight) {
      var r = Ve(t);
      if (t.clientWidth < t.scrollWidth && (r.overflowX == "auto" || r.overflowX == "scroll") || t.clientHeight < t.scrollHeight && (r.overflowY == "auto" || r.overflowY == "scroll")) {
        if (!t.getBoundingClientRect || t === document.body)
          return lo();
        if (i || e)
          return t;
        i = !0;
      }
    }
  while (t = t.parentNode);
  return lo();
}
function sYe(n, e) {
  if (n && e)
    for (var t in e)
      e.hasOwnProperty(t) && (n[t] = e[t]);
  return n;
}
function _b(n, e) {
  return Math.round(n.top) === Math.round(e.top) && Math.round(n.left) === Math.round(e.left) && Math.round(n.height) === Math.round(e.height) && Math.round(n.width) === Math.round(e.width);
}
var Sd;
function oL(n, e) {
  return function() {
    if (!Sd) {
      var t = arguments, i = this;
      t.length === 1 ? n.call(i, t[0]) : n.apply(i, t), Sd = setTimeout(function() {
        Sd = void 0;
      }, e);
    }
  };
}
function oYe() {
  clearTimeout(Sd), Sd = void 0;
}
function aL(n, e, t) {
  n.scrollLeft += e, n.scrollTop += t;
}
function lL(n) {
  var e = window.Polymer, t = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(n).cloneNode(!0) : t ? t(n).clone(!0)[0] : n.cloneNode(!0);
}
var kr = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function aYe() {
  var n = [], e;
  return {
    captureAnimationState: function() {
      if (n = [], !!this.options.animation) {
        var t = [].slice.call(this.el.children);
        t.forEach(function(i) {
          if (!(Ve(i, "display") === "none" || i === et.ghost)) {
            n.push({
              target: i,
              rect: Rn(i)
            });
            var r = mo({}, n[n.length - 1].rect);
            if (i.thisAnimationDuration) {
              var s = iu(i, !0);
              s && (r.top -= s.f, r.left -= s.e);
            }
            i.fromRect = r;
          }
        });
      }
    },
    addAnimationState: function(t) {
      n.push(t);
    },
    removeAnimationState: function(t) {
      n.splice(rYe(n, {
        target: t
      }), 1);
    },
    animateAll: function(t) {
      var i = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof t == "function" && t();
        return;
      }
      var r = !1, s = 0;
      n.forEach(function(o) {
        var a = 0, l = o.target, c = l.fromRect, u = Rn(l), h = l.prevFromRect, d = l.prevToRect, f = o.rect, p = iu(l, !0);
        p && (u.top -= p.f, u.left -= p.e), l.toRect = u, l.thisAnimationDuration && _b(h, u) && !_b(c, u) && // Make sure animatingRect is on line between toRect & fromRect
        (f.top - u.top) / (f.left - u.left) === (c.top - u.top) / (c.left - u.left) && (a = cYe(f, h, d, i.options)), _b(u, c) || (l.prevFromRect = c, l.prevToRect = u, a || (a = i.options.animation), i.animate(l, f, u, a)), a && (r = !0, s = Math.max(s, a), clearTimeout(l.animationResetTimer), l.animationResetTimer = setTimeout(function() {
          l.animationTime = 0, l.prevFromRect = null, l.fromRect = null, l.prevToRect = null, l.thisAnimationDuration = null;
        }, a), l.thisAnimationDuration = a);
      }), clearTimeout(e), r ? e = setTimeout(function() {
        typeof t == "function" && t();
      }, s) : typeof t == "function" && t(), n = [];
    },
    animate: function(t, i, r, s) {
      if (s) {
        Ve(t, "transition", ""), Ve(t, "transform", "");
        var o = iu(this.el), a = o && o.a, l = o && o.d, c = (i.left - r.left) / (a || 1), u = (i.top - r.top) / (l || 1);
        t.animatingX = !!c, t.animatingY = !!u, Ve(t, "transform", "translate3d(" + c + "px," + u + "px,0)"), this.forRepaintDummy = lYe(t), Ve(t, "transition", "transform " + s + "ms" + (this.options.easing ? " " + this.options.easing : "")), Ve(t, "transform", "translate3d(0,0,0)"), typeof t.animated == "number" && clearTimeout(t.animated), t.animated = setTimeout(function() {
          Ve(t, "transition", ""), Ve(t, "transform", ""), t.animated = !1, t.animatingX = !1, t.animatingY = !1;
        }, s);
      }
    }
  };
}
function lYe(n) {
  return n.offsetWidth;
}
function cYe(n, e, t, i) {
  return Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2)) / Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) * i.animation;
}
var Ac = [], Mb = {
  initializeByDefault: !0
}, Yf = {
  mount: function(n) {
    for (var e in Mb)
      Mb.hasOwnProperty(e) && !(e in n) && (n[e] = Mb[e]);
    Ac.forEach(function(t) {
      if (t.pluginName === n.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(n.pluginName, " more than once");
    }), Ac.push(n);
  },
  pluginEvent: function(n, e, t) {
    var i = this;
    this.eventCanceled = !1, t.cancel = function() {
      i.eventCanceled = !0;
    };
    var r = n + "Global";
    Ac.forEach(function(s) {
      e[s.pluginName] && (e[s.pluginName][r] && e[s.pluginName][r](mo({
        sortable: e
      }, t)), e.options[s.pluginName] && e[s.pluginName][n] && e[s.pluginName][n](mo({
        sortable: e
      }, t)));
    });
  },
  initializePlugins: function(n, e, t, i) {
    Ac.forEach(function(o) {
      var a = o.pluginName;
      if (!(!n.options[a] && !o.initializeByDefault)) {
        var l = new o(n, e, n.options);
        l.sortable = n, l.options = n.options, n[a] = l, Go(t, l.defaults);
      }
    });
    for (var r in n.options)
      if (n.options.hasOwnProperty(r)) {
        var s = this.modifyOption(n, r, n.options[r]);
        typeof s < "u" && (n.options[r] = s);
      }
  },
  getEventProperties: function(n, e) {
    var t = {};
    return Ac.forEach(function(i) {
      typeof i.eventProperties == "function" && Go(t, i.eventProperties.call(e[i.pluginName], n));
    }), t;
  },
  modifyOption: function(n, e, t) {
    var i;
    return Ac.forEach(function(r) {
      n[r.pluginName] && r.optionListeners && typeof r.optionListeners[e] == "function" && (i = r.optionListeners[e].call(n[r.pluginName], t));
    }), i;
  }
};
function uYe(n) {
  var e = n.sortable, t = n.rootEl, i = n.name, r = n.targetEl, s = n.cloneEl, o = n.toEl, a = n.fromEl, l = n.oldIndex, c = n.newIndex, u = n.oldDraggableIndex, h = n.newDraggableIndex, d = n.originalEvent, f = n.putSortable, p = n.extraEventProperties;
  if (e = e || t && t[kr], !!e) {
    var g, m = e.options, v = "on" + i.charAt(0).toUpperCase() + i.substr(1);
    window.CustomEvent && !ra && !Xf ? g = new CustomEvent(i, {
      bubbles: !0,
      cancelable: !0
    }) : (g = document.createEvent("Event"), g.initEvent(i, !0, !0)), g.to = o || t, g.from = a || t, g.item = r || t, g.clone = s, g.oldIndex = l, g.newIndex = c, g.oldDraggableIndex = u, g.newDraggableIndex = h, g.originalEvent = d, g.pullMode = f ? f.lastPutMode : void 0;
    var y = mo(mo({}, p), Yf.getEventProperties(i, e));
    for (var b in y)
      g[b] = y[b];
    t && t.dispatchEvent(g), m[v] && m[v].call(e, g);
  }
}
var hYe = ["evt"], Ki = function(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = t.evt, r = tYe(t, hYe);
  Yf.pluginEvent.bind(et)(n, e, mo({
    dragEl: Oe,
    parentEl: bn,
    ghostEl: lt,
    rootEl: sn,
    nextEl: pl,
    lastDownEl: Ig,
    cloneEl: fn,
    cloneHidden: xa,
    dragStarted: Uh,
    putSortable: fi,
    activeSortable: et.active,
    originalEvent: i,
    oldIndex: jc,
    oldDraggableIndex: Cd,
    newIndex: br,
    newDraggableIndex: ya,
    hideGhostForTarget: dL,
    unhideGhostForTarget: fL,
    cloneNowHidden: function() {
      xa = !0;
    },
    cloneNowShown: function() {
      xa = !1;
    },
    dispatchSortableEvent: function(s) {
      ji({
        sortable: e,
        name: s,
        originalEvent: i
      });
    }
  }, r));
};
function ji(n) {
  uYe(mo({
    putSortable: fi,
    cloneEl: fn,
    targetEl: Oe,
    rootEl: sn,
    oldIndex: jc,
    oldDraggableIndex: Cd,
    newIndex: br,
    newDraggableIndex: ya
  }, n));
}
var Oe, bn, lt, sn, pl, Ig, fn, xa, jc, br, Cd, ya, Yp, fi, Dc = !1, Hm = !1, Xm = [], cl, os, Rb, Nb, JE, eA, Uh, $c, kd, Pd = !1, Up = !1, Bg, $i, Db = [], u1 = !1, Ym = [], c0 = typeof document < "u", Gp = tL, tA = Xf || ra ? "cssFloat" : "float", dYe = c0 && !nL && !tL && "draggable" in document.createElement("div"), cL = function() {
  if (c0) {
    if (ra)
      return !1;
    var n = document.createElement("x");
    return n.style.cssText = "pointer-events:auto", n.style.pointerEvents === "auto";
  }
}(), uL = function(n, e) {
  var t = Ve(n), i = parseInt(t.width) - parseInt(t.paddingLeft) - parseInt(t.paddingRight) - parseInt(t.borderLeftWidth) - parseInt(t.borderRightWidth), r = Uu(n, 0, e), s = Uu(n, 1, e), o = r && Ve(r), a = s && Ve(s), l = o && parseInt(o.marginLeft) + parseInt(o.marginRight) + Rn(r).width, c = a && parseInt(a.marginLeft) + parseInt(a.marginRight) + Rn(s).width;
  if (t.display === "flex")
    return t.flexDirection === "column" || t.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (t.display === "grid")
    return t.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (r && o.float && o.float !== "none") {
    var u = o.float === "left" ? "left" : "right";
    return s && (a.clear === "both" || a.clear === u) ? "vertical" : "horizontal";
  }
  return r && (o.display === "block" || o.display === "flex" || o.display === "table" || o.display === "grid" || l >= i && t[tA] === "none" || s && t[tA] === "none" && l + c > i) ? "vertical" : "horizontal";
}, fYe = function(n, e, t) {
  var i = t ? n.left : n.top, r = t ? n.right : n.bottom, s = t ? n.width : n.height, o = t ? e.left : e.top, a = t ? e.right : e.bottom, l = t ? e.width : e.height;
  return i === o || r === a || i + s / 2 === o + l / 2;
}, pYe = function(n, e) {
  var t;
  return Xm.some(function(i) {
    var r = i[kr].options.emptyInsertThreshold;
    if (!(!r || Ux(i))) {
      var s = Rn(i), o = n >= s.left - r && n <= s.right + r, a = e >= s.top - r && e <= s.bottom + r;
      if (o && a)
        return t = i;
    }
  }), t;
}, hL = function(n) {
  function e(r, s) {
    return function(o, a, l, c) {
      var u = o.options.group.name && a.options.group.name && o.options.group.name === a.options.group.name;
      if (r == null && (s || u))
        return !0;
      if (r == null || r === !1)
        return !1;
      if (s && r === "clone")
        return r;
      if (typeof r == "function")
        return e(r(o, a, l, c), s)(o, a, l, c);
      var h = (s ? o : a).options.group.name;
      return r === !0 || typeof r == "string" && r === h || r.join && r.indexOf(h) > -1;
    };
  }
  var t = {}, i = n.group;
  (!i || Lg(i) != "object") && (i = {
    name: i
  }), t.name = i.name, t.checkPull = e(i.pull, !0), t.checkPut = e(i.put), t.revertClone = i.revertClone, n.group = t;
}, dL = function() {
  !cL && lt && Ve(lt, "display", "none");
}, fL = function() {
  !cL && lt && Ve(lt, "display", "");
};
c0 && !nL && document.addEventListener("click", function(n) {
  if (Hm)
    return n.preventDefault(), n.stopPropagation && n.stopPropagation(), n.stopImmediatePropagation && n.stopImmediatePropagation(), Hm = !1, !1;
}, !0);
var ul = function(n) {
  if (Oe) {
    n = n.touches ? n.touches[0] : n;
    var e = pYe(n.clientX, n.clientY);
    if (e) {
      var t = {};
      for (var i in n)
        n.hasOwnProperty(i) && (t[i] = n[i]);
      t.target = t.rootEl = e, t.preventDefault = void 0, t.stopPropagation = void 0, e[kr]._onDragOver(t);
    }
  }
}, gYe = function(n) {
  Oe && Oe.parentNode[kr]._isOutsideThisEl(n.target);
};
function et(n, e) {
  if (!(n && n.nodeType && n.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(n));
  this.el = n, this.options = e = Go({}, e), n[kr] = this;
  var t = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(n.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: !1,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: !0,
    direction: function() {
      return uL(n, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(s, o) {
      s.setData("Text", o.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: et.supportPointer !== !1 && "PointerEvent" in window && !xd,
    emptyInsertThreshold: 5
  };
  Yf.initializePlugins(this, n, t);
  for (var i in t)
    !(i in e) && (e[i] = t[i]);
  hL(e);
  for (var r in this)
    r.charAt(0) === "_" && typeof this[r] == "function" && (this[r] = this[r].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : dYe, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? Mt(n, "pointerdown", this._onTapStart) : (Mt(n, "mousedown", this._onTapStart), Mt(n, "touchstart", this._onTapStart)), this.nativeDraggable && (Mt(n, "dragover", this), Mt(n, "dragenter", this)), Xm.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Go(this, aYe());
}
et.prototype = /** @lends Sortable.prototype */
{
  constructor: et,
  _isOutsideThisEl: function(n) {
    !this.el.contains(n) && n !== this.el && ($c = null);
  },
  _getDirection: function(n, e) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, n, e, Oe) : this.options.direction;
  },
  _onTapStart: function(n) {
    if (n.cancelable) {
      var e = this, t = this.el, i = this.options, r = i.preventOnFilter, s = n.type, o = n.touches && n.touches[0] || n.pointerType && n.pointerType === "touch" && n, a = (o || n).target, l = n.target.shadowRoot && (n.path && n.path[0] || n.composedPath && n.composedPath()[0]) || a, c = i.filter;
      if (SYe(t), !Oe && !(/mousedown|pointerdown/.test(s) && n.button !== 0 || i.disabled) && !l.isContentEditable && !(!this.nativeDraggable && xd && a && a.tagName.toUpperCase() === "SELECT") && (a = js(a, i.draggable, t, !1), !(a && a.animated) && Ig !== a)) {
        if (jc = Ir(a), Cd = Ir(a, i.draggable), typeof c == "function") {
          if (c.call(this, n, a, this)) {
            ji({
              sortable: e,
              rootEl: l,
              name: "filter",
              targetEl: a,
              toEl: t,
              fromEl: t
            }), Ki("filter", e, {
              evt: n
            }), r && n.cancelable && n.preventDefault();
            return;
          }
        } else if (c && (c = c.split(",").some(function(u) {
          if (u = js(l, u.trim(), t, !1), u)
            return ji({
              sortable: e,
              rootEl: u,
              name: "filter",
              targetEl: a,
              fromEl: t,
              toEl: t
            }), Ki("filter", e, {
              evt: n
            }), !0;
        }), c)) {
          r && n.cancelable && n.preventDefault();
          return;
        }
        i.handle && !js(l, i.handle, t, !1) || this._prepareDragStart(n, o, a);
      }
    }
  },
  _prepareDragStart: function(n, e, t) {
    var i = this, r = i.el, s = i.options, o = r.ownerDocument, a;
    if (t && !Oe && t.parentNode === r) {
      var l = Rn(t);
      if (sn = r, Oe = t, bn = Oe.parentNode, pl = Oe.nextSibling, Ig = t, Yp = s.group, et.dragged = Oe, cl = {
        target: Oe,
        clientX: (e || n).clientX,
        clientY: (e || n).clientY
      }, JE = cl.clientX - l.left, eA = cl.clientY - l.top, this._lastX = (e || n).clientX, this._lastY = (e || n).clientY, Oe.style["will-change"] = "all", a = function() {
        if (Ki("delayEnded", i, {
          evt: n
        }), et.eventCanceled) {
          i._onDrop();
          return;
        }
        i._disableDelayedDragEvents(), !YE && i.nativeDraggable && (Oe.draggable = !0), i._triggerDragStart(n, e), ji({
          sortable: i,
          name: "choose",
          originalEvent: n
        }), vr(Oe, s.chosenClass, !0);
      }, s.ignore.split(",").forEach(function(c) {
        rL(Oe, c.trim(), Lb);
      }), Mt(o, "dragover", ul), Mt(o, "mousemove", ul), Mt(o, "touchmove", ul), Mt(o, "mouseup", i._onDrop), Mt(o, "touchend", i._onDrop), Mt(o, "touchcancel", i._onDrop), YE && this.nativeDraggable && (this.options.touchStartThreshold = 4, Oe.draggable = !0), Ki("delayStart", this, {
        evt: n
      }), s.delay && (!s.delayOnTouchOnly || e) && (!this.nativeDraggable || !(Xf || ra))) {
        if (et.eventCanceled) {
          this._onDrop();
          return;
        }
        Mt(o, "mouseup", i._disableDelayedDrag), Mt(o, "touchend", i._disableDelayedDrag), Mt(o, "touchcancel", i._disableDelayedDrag), Mt(o, "mousemove", i._delayedDragTouchMoveHandler), Mt(o, "touchmove", i._delayedDragTouchMoveHandler), s.supportPointer && Mt(o, "pointermove", i._delayedDragTouchMoveHandler), i._dragStartTimer = setTimeout(a, s.delay);
      } else
        a();
    }
  },
  _delayedDragTouchMoveHandler: function(n) {
    var e = n.touches ? n.touches[0] : n;
    Math.max(Math.abs(e.clientX - this._lastX), Math.abs(e.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    Oe && Lb(Oe), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var n = this.el.ownerDocument;
    Ct(n, "mouseup", this._disableDelayedDrag), Ct(n, "touchend", this._disableDelayedDrag), Ct(n, "touchcancel", this._disableDelayedDrag), Ct(n, "mousemove", this._delayedDragTouchMoveHandler), Ct(n, "touchmove", this._delayedDragTouchMoveHandler), Ct(n, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(n, e) {
    e = e || n.pointerType == "touch" && n, !this.nativeDraggable || e ? this.options.supportPointer ? Mt(document, "pointermove", this._onTouchMove) : e ? Mt(document, "touchmove", this._onTouchMove) : Mt(document, "mousemove", this._onTouchMove) : (Mt(Oe, "dragend", this), Mt(sn, "dragstart", this._onDragStart));
    try {
      document.selection ? Qg(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(n, e) {
    if (Dc = !1, sn && Oe) {
      Ki("dragStarted", this, {
        evt: e
      }), this.nativeDraggable && Mt(document, "dragover", gYe);
      var t = this.options;
      !n && vr(Oe, t.dragClass, !1), vr(Oe, t.ghostClass, !0), et.active = this, n && this._appendGhost(), ji({
        sortable: this,
        name: "start",
        originalEvent: e
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (os) {
      this._lastX = os.clientX, this._lastY = os.clientY, dL();
      for (var n = document.elementFromPoint(os.clientX, os.clientY), e = n; n && n.shadowRoot && (n = n.shadowRoot.elementFromPoint(os.clientX, os.clientY), n !== e); )
        e = n;
      if (Oe.parentNode[kr]._isOutsideThisEl(n), e)
        do {
          if (e[kr]) {
            var t = void 0;
            if (t = e[kr]._onDragOver({
              clientX: os.clientX,
              clientY: os.clientY,
              target: n,
              rootEl: e
            }), t && !this.options.dragoverBubble)
              break;
          }
          n = e;
        } while (e = e.parentNode);
      fL();
    }
  },
  _onTouchMove: function(n) {
    if (cl) {
      var e = this.options, t = e.fallbackTolerance, i = e.fallbackOffset, r = n.touches ? n.touches[0] : n, s = lt && iu(lt, !0), o = lt && s && s.a, a = lt && s && s.d, l = Gp && $i && KE($i), c = (r.clientX - cl.clientX + i.x) / (o || 1) + (l ? l[0] - Db[0] : 0) / (o || 1), u = (r.clientY - cl.clientY + i.y) / (a || 1) + (l ? l[1] - Db[1] : 0) / (a || 1);
      if (!et.active && !Dc) {
        if (t && Math.max(Math.abs(r.clientX - this._lastX), Math.abs(r.clientY - this._lastY)) < t)
          return;
        this._onDragStart(n, !0);
      }
      if (lt) {
        s ? (s.e += c - (Rb || 0), s.f += u - (Nb || 0)) : s = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: c,
          f: u
        };
        var h = "matrix(".concat(s.a, ",").concat(s.b, ",").concat(s.c, ",").concat(s.d, ",").concat(s.e, ",").concat(s.f, ")");
        Ve(lt, "webkitTransform", h), Ve(lt, "mozTransform", h), Ve(lt, "msTransform", h), Ve(lt, "transform", h), Rb = c, Nb = u, os = r;
      }
      n.cancelable && n.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!lt) {
      var n = this.options.fallbackOnBody ? document.body : sn, e = Rn(Oe, !0, Gp, !0, n), t = this.options;
      if (Gp) {
        for ($i = n; Ve($i, "position") === "static" && Ve($i, "transform") === "none" && $i !== document; )
          $i = $i.parentNode;
        $i !== document.body && $i !== document.documentElement ? ($i === document && ($i = lo()), e.top += $i.scrollTop, e.left += $i.scrollLeft) : $i = lo(), Db = KE($i);
      }
      lt = Oe.cloneNode(!0), vr(lt, t.ghostClass, !1), vr(lt, t.fallbackClass, !0), vr(lt, t.dragClass, !0), Ve(lt, "transition", ""), Ve(lt, "transform", ""), Ve(lt, "box-sizing", "border-box"), Ve(lt, "margin", 0), Ve(lt, "top", e.top), Ve(lt, "left", e.left), Ve(lt, "width", e.width), Ve(lt, "height", e.height), Ve(lt, "opacity", "0.8"), Ve(lt, "position", Gp ? "absolute" : "fixed"), Ve(lt, "zIndex", "100000"), Ve(lt, "pointerEvents", "none"), et.ghost = lt, n.appendChild(lt), Ve(lt, "transform-origin", JE / parseInt(lt.style.width) * 100 + "% " + eA / parseInt(lt.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(n, e) {
    var t = this, i = n.dataTransfer, r = t.options;
    if (Ki("dragStart", this, {
      evt: n
    }), et.eventCanceled) {
      this._onDrop();
      return;
    }
    Ki("setupClone", this), et.eventCanceled || (fn = lL(Oe), fn.removeAttribute("id"), fn.draggable = !1, fn.style["will-change"] = "", this._hideClone(), vr(fn, this.options.chosenClass, !1), et.clone = fn), t.cloneId = Qg(function() {
      Ki("clone", t), !et.eventCanceled && (t.options.removeCloneOnHide || sn.insertBefore(fn, Oe), t._hideClone(), ji({
        sortable: t,
        name: "clone"
      }));
    }), !e && vr(Oe, r.dragClass, !0), e ? (Hm = !0, t._loopId = setInterval(t._emulateDragOver, 50)) : (Ct(document, "mouseup", t._onDrop), Ct(document, "touchend", t._onDrop), Ct(document, "touchcancel", t._onDrop), i && (i.effectAllowed = "move", r.setData && r.setData.call(t, i, Oe)), Mt(document, "drop", t), Ve(Oe, "transform", "translateZ(0)")), Dc = !0, t._dragStartId = Qg(t._dragStarted.bind(t, e, n)), Mt(document, "selectstart", t), Uh = !0, xd && Ve(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(n) {
    var e = this.el, t = n.target, i, r, s, o = this.options, a = o.group, l = et.active, c = Yp === a, u = o.sort, h = fi || l, d, f = this, p = !1;
    if (u1)
      return;
    function g(N, q) {
      Ki(N, f, mo({
        evt: n,
        isOwner: c,
        axis: d ? "vertical" : "horizontal",
        revert: s,
        dragRect: i,
        targetRect: r,
        canSort: u,
        fromSortable: h,
        target: t,
        completed: v,
        onMove: function(j, H) {
          return Kp(sn, e, Oe, i, j, Rn(j), n, H);
        },
        changed: y
      }, q));
    }
    function m() {
      g("dragOverAnimationCapture"), f.captureAnimationState(), f !== h && h.captureAnimationState();
    }
    function v(N) {
      return g("dragOverCompleted", {
        insertion: N
      }), N && (c ? l._hideClone() : l._showClone(f), f !== h && (vr(Oe, fi ? fi.options.ghostClass : l.options.ghostClass, !1), vr(Oe, o.ghostClass, !0)), fi !== f && f !== et.active ? fi = f : f === et.active && fi && (fi = null), h === f && (f._ignoreWhileAnimating = t), f.animateAll(function() {
        g("dragOverAnimationComplete"), f._ignoreWhileAnimating = null;
      }), f !== h && (h.animateAll(), h._ignoreWhileAnimating = null)), (t === Oe && !Oe.animated || t === e && !t.animated) && ($c = null), !o.dragoverBubble && !n.rootEl && t !== document && (Oe.parentNode[kr]._isOutsideThisEl(n.target), !N && ul(n)), !o.dragoverBubble && n.stopPropagation && n.stopPropagation(), p = !0;
    }
    function y() {
      br = Ir(Oe), ya = Ir(Oe, o.draggable), ji({
        sortable: f,
        name: "change",
        toEl: e,
        newIndex: br,
        newDraggableIndex: ya,
        originalEvent: n
      });
    }
    if (n.preventDefault !== void 0 && n.cancelable && n.preventDefault(), t = js(t, o.draggable, e, !0), g("dragOver"), et.eventCanceled)
      return p;
    if (Oe.contains(n.target) || t.animated && t.animatingX && t.animatingY || f._ignoreWhileAnimating === t)
      return v(!1);
    if (Hm = !1, l && !o.disabled && (c ? u || (s = bn !== sn) : fi === this || (this.lastPutMode = Yp.checkPull(this, l, Oe, n)) && a.checkPut(this, l, Oe, n))) {
      if (d = this._getDirection(n, t) === "vertical", i = Rn(Oe), g("dragOverValid"), et.eventCanceled)
        return p;
      if (s)
        return bn = sn, m(), this._hideClone(), g("revert"), et.eventCanceled || (pl ? sn.insertBefore(Oe, pl) : sn.appendChild(Oe)), v(!0);
      var b = Ux(e, o.draggable);
      if (!b || yYe(n, d, this) && !b.animated) {
        if (b === Oe)
          return v(!1);
        if (b && e === n.target && (t = b), t && (r = Rn(t)), Kp(sn, e, Oe, i, t, r, n, !!t) !== !1)
          return m(), b && b.nextSibling ? e.insertBefore(Oe, b.nextSibling) : e.appendChild(Oe), bn = e, y(), v(!0);
      } else if (b && bYe(n, d, this)) {
        var w = Uu(e, 0, o, !0);
        if (w === Oe)
          return v(!1);
        if (t = w, r = Rn(t), Kp(sn, e, Oe, i, t, r, n, !1) !== !1)
          return m(), e.insertBefore(Oe, w), bn = e, y(), v(!0);
      } else if (t.parentNode === e) {
        r = Rn(t);
        var x = 0, S, C = Oe.parentNode !== e, k = !fYe(Oe.animated && Oe.toRect || i, t.animated && t.toRect || r, d), E = d ? "top" : "left", M = GE(t, "top", "top") || GE(Oe, "top", "top"), _ = M ? M.scrollTop : void 0;
        $c !== t && (S = r[E], Pd = !1, Up = !k && o.invertSwap || C), x = OYe(n, t, r, d, k ? 1 : o.swapThreshold, o.invertedSwapThreshold == null ? o.swapThreshold : o.invertedSwapThreshold, Up, $c === t);
        var T;
        if (x !== 0) {
          var B = Ir(Oe);
          do
            B -= x, T = bn.children[B];
          while (T && (Ve(T, "display") === "none" || T === lt));
        }
        if (x === 0 || T === t)
          return v(!1);
        $c = t, kd = x;
        var I = t.nextElementSibling, P = !1;
        P = x === 1;
        var A = Kp(sn, e, Oe, i, t, r, n, P);
        if (A !== !1)
          return (A === 1 || A === -1) && (P = A === 1), u1 = !0, setTimeout(vYe, 30), m(), P && !I ? e.appendChild(Oe) : t.parentNode.insertBefore(Oe, P ? I : t), M && aL(M, 0, _ - M.scrollTop), bn = Oe.parentNode, S !== void 0 && !Up && (Bg = Math.abs(S - Rn(t)[E])), y(), v(!0);
      }
      if (e.contains(Oe))
        return v(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    Ct(document, "mousemove", this._onTouchMove), Ct(document, "touchmove", this._onTouchMove), Ct(document, "pointermove", this._onTouchMove), Ct(document, "dragover", ul), Ct(document, "mousemove", ul), Ct(document, "touchmove", ul);
  },
  _offUpEvents: function() {
    var n = this.el.ownerDocument;
    Ct(n, "mouseup", this._onDrop), Ct(n, "touchend", this._onDrop), Ct(n, "pointerup", this._onDrop), Ct(n, "touchcancel", this._onDrop), Ct(document, "selectstart", this);
  },
  _onDrop: function(n) {
    var e = this.el, t = this.options;
    if (br = Ir(Oe), ya = Ir(Oe, t.draggable), Ki("drop", this, {
      evt: n
    }), bn = Oe && Oe.parentNode, br = Ir(Oe), ya = Ir(Oe, t.draggable), et.eventCanceled) {
      this._nulling();
      return;
    }
    Dc = !1, Up = !1, Pd = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), h1(this.cloneId), h1(this._dragStartId), this.nativeDraggable && (Ct(document, "drop", this), Ct(e, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), xd && Ve(document.body, "user-select", ""), Ve(Oe, "transform", ""), n && (Uh && (n.cancelable && n.preventDefault(), !t.dropBubble && n.stopPropagation()), lt && lt.parentNode && lt.parentNode.removeChild(lt), (sn === bn || fi && fi.lastPutMode !== "clone") && fn && fn.parentNode && fn.parentNode.removeChild(fn), Oe && (this.nativeDraggable && Ct(Oe, "dragend", this), Lb(Oe), Oe.style["will-change"] = "", Uh && !Dc && vr(Oe, fi ? fi.options.ghostClass : this.options.ghostClass, !1), vr(Oe, this.options.chosenClass, !1), ji({
      sortable: this,
      name: "unchoose",
      toEl: bn,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: n
    }), sn !== bn ? (br >= 0 && (ji({
      rootEl: bn,
      name: "add",
      toEl: bn,
      fromEl: sn,
      originalEvent: n
    }), ji({
      sortable: this,
      name: "remove",
      toEl: bn,
      originalEvent: n
    }), ji({
      rootEl: bn,
      name: "sort",
      toEl: bn,
      fromEl: sn,
      originalEvent: n
    }), ji({
      sortable: this,
      name: "sort",
      toEl: bn,
      originalEvent: n
    })), fi && fi.save()) : br !== jc && br >= 0 && (ji({
      sortable: this,
      name: "update",
      toEl: bn,
      originalEvent: n
    }), ji({
      sortable: this,
      name: "sort",
      toEl: bn,
      originalEvent: n
    })), et.active && ((br == null || br === -1) && (br = jc, ya = Cd), ji({
      sortable: this,
      name: "end",
      toEl: bn,
      originalEvent: n
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    Ki("nulling", this), sn = Oe = bn = lt = pl = fn = Ig = xa = cl = os = Uh = br = ya = jc = Cd = $c = kd = fi = Yp = et.dragged = et.ghost = et.clone = et.active = null, Ym.forEach(function(n) {
      n.checked = !0;
    }), Ym.length = Rb = Nb = 0;
  },
  handleEvent: function(n) {
    switch (n.type) {
      case "drop":
      case "dragend":
        this._onDrop(n);
        break;
      case "dragenter":
      case "dragover":
        Oe && (this._onDragOver(n), mYe(n));
        break;
      case "selectstart":
        n.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var n = [], e, t = this.el.children, i = 0, r = t.length, s = this.options; i < r; i++)
      e = t[i], js(e, s.draggable, this.el, !1) && n.push(e.getAttribute(s.dataIdAttr) || xYe(e));
    return n;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(n, e) {
    var t = {}, i = this.el;
    this.toArray().forEach(function(r, s) {
      var o = i.children[s];
      js(o, this.options.draggable, i, !1) && (t[r] = o);
    }, this), e && this.captureAnimationState(), n.forEach(function(r) {
      t[r] && (i.removeChild(t[r]), i.appendChild(t[r]));
    }), e && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var n = this.options.store;
    n && n.set && n.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(n, e) {
    return js(n, e || this.options.draggable, this.el, !1);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(n, e) {
    var t = this.options;
    if (e === void 0)
      return t[n];
    var i = Yf.modifyOption(this, n, e);
    typeof i < "u" ? t[n] = i : t[n] = e, n === "group" && hL(t);
  },
  /**
   * Destroy
   */
  destroy: function() {
    Ki("destroy", this);
    var n = this.el;
    n[kr] = null, Ct(n, "mousedown", this._onTapStart), Ct(n, "touchstart", this._onTapStart), Ct(n, "pointerdown", this._onTapStart), this.nativeDraggable && (Ct(n, "dragover", this), Ct(n, "dragenter", this)), Array.prototype.forEach.call(n.querySelectorAll("[draggable]"), function(e) {
      e.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), Xm.splice(Xm.indexOf(this.el), 1), this.el = n = null;
  },
  _hideClone: function() {
    if (!xa) {
      if (Ki("hideClone", this), et.eventCanceled)
        return;
      Ve(fn, "display", "none"), this.options.removeCloneOnHide && fn.parentNode && fn.parentNode.removeChild(fn), xa = !0;
    }
  },
  _showClone: function(n) {
    if (n.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (xa) {
      if (Ki("showClone", this), et.eventCanceled)
        return;
      Oe.parentNode == sn && !this.options.group.revertClone ? sn.insertBefore(fn, Oe) : pl ? sn.insertBefore(fn, pl) : sn.appendChild(fn), this.options.group.revertClone && this.animate(Oe, fn), Ve(fn, "display", ""), xa = !1;
    }
  }
};
function mYe(n) {
  n.dataTransfer && (n.dataTransfer.dropEffect = "move"), n.cancelable && n.preventDefault();
}
function Kp(n, e, t, i, r, s, o, a) {
  var l, c = n[kr], u = c.options.onMove, h;
  return window.CustomEvent && !ra && !Xf ? l = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (l = document.createEvent("Event"), l.initEvent("move", !0, !0)), l.to = e, l.from = n, l.dragged = t, l.draggedRect = i, l.related = r || e, l.relatedRect = s || Rn(e), l.willInsertAfter = a, l.originalEvent = o, n.dispatchEvent(l), u && (h = u.call(c, l, o)), h;
}
function Lb(n) {
  n.draggable = !1;
}
function vYe() {
  u1 = !1;
}
function bYe(n, e, t) {
  var i = Rn(Uu(t.el, 0, t.options, !0)), r = sL(t.el), s = 10;
  return e ? n.clientX < r.left - s || n.clientY < i.top && n.clientX < i.right : n.clientY < r.top - s || n.clientY < i.bottom && n.clientX < i.left;
}
function yYe(n, e, t) {
  var i = Rn(Ux(t.el, t.options.draggable)), r = sL(t.el), s = 10;
  return e ? n.clientX > r.right + s || n.clientY > i.bottom && n.clientX > i.left : n.clientY > r.bottom + s || n.clientX > i.right && n.clientY > i.top;
}
function OYe(n, e, t, i, r, s, o, a) {
  var l = i ? n.clientY : n.clientX, c = i ? t.height : t.width, u = i ? t.top : t.left, h = i ? t.bottom : t.right, d = !1;
  if (!o) {
    if (a && Bg < c * r) {
      if (!Pd && (kd === 1 ? l > u + c * s / 2 : l < h - c * s / 2) && (Pd = !0), Pd)
        d = !0;
      else if (kd === 1 ? l < u + Bg : l > h - Bg)
        return -kd;
    } else if (l > u + c * (1 - r) / 2 && l < h - c * (1 - r) / 2)
      return wYe(e);
  }
  return d = d || o, d && (l < u + c * s / 2 || l > h - c * s / 2) ? l > u + c / 2 ? 1 : -1 : 0;
}
function wYe(n) {
  return Ir(Oe) < Ir(n) ? 1 : -1;
}
function xYe(n) {
  for (var e = n.tagName + n.className + n.src + n.href + n.textContent, t = e.length, i = 0; t--; )
    i += e.charCodeAt(t);
  return i.toString(36);
}
function SYe(n) {
  Ym.length = 0;
  for (var e = n.getElementsByTagName("input"), t = e.length; t--; ) {
    var i = e[t];
    i.checked && Ym.push(i);
  }
}
function Qg(n) {
  return setTimeout(n, 0);
}
function h1(n) {
  return clearTimeout(n);
}
c0 && Mt(document, "touchmove", function(n) {
  (et.active || Dc) && n.cancelable && n.preventDefault();
});
et.utils = {
  on: Mt,
  off: Ct,
  css: Ve,
  find: rL,
  is: function(n, e) {
    return !!js(n, e, n, !1);
  },
  extend: sYe,
  throttle: oL,
  closest: js,
  toggleClass: vr,
  clone: lL,
  index: Ir,
  nextTick: Qg,
  cancelNextTick: h1,
  detectDirection: uL,
  getChild: Uu
};
et.get = function(n) {
  return n[kr];
};
et.mount = function() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(i) {
    if (!i.prototype || !i.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(i));
    i.utils && (et.utils = mo(mo({}, et.utils), i.utils)), Yf.mount(i);
  });
};
et.create = function(n, e) {
  return new et(n, e);
};
et.version = nYe;
var _n = [], Gh, d1, f1 = !1, Ib, Bb, Um, Kh;
function CYe() {
  function n() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return n.prototype = {
    dragStarted: function(e) {
      var t = e.originalEvent;
      this.sortable.nativeDraggable ? Mt(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? Mt(document, "pointermove", this._handleFallbackAutoScroll) : t.touches ? Mt(document, "touchmove", this._handleFallbackAutoScroll) : Mt(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(e) {
      var t = e.originalEvent;
      !this.options.dragOverBubble && !t.rootEl && this._handleAutoScroll(t);
    },
    drop: function() {
      this.sortable.nativeDraggable ? Ct(document, "dragover", this._handleAutoScroll) : (Ct(document, "pointermove", this._handleFallbackAutoScroll), Ct(document, "touchmove", this._handleFallbackAutoScroll), Ct(document, "mousemove", this._handleFallbackAutoScroll)), nA(), zg(), oYe();
    },
    nulling: function() {
      Um = d1 = Gh = f1 = Kh = Ib = Bb = null, _n.length = 0;
    },
    _handleFallbackAutoScroll: function(e) {
      this._handleAutoScroll(e, !0);
    },
    _handleAutoScroll: function(e, t) {
      var i = this, r = (e.touches ? e.touches[0] : e).clientX, s = (e.touches ? e.touches[0] : e).clientY, o = document.elementFromPoint(r, s);
      if (Um = e, t || this.options.forceAutoScrollFallback || Xf || ra || xd) {
        Qb(e, this.options, o, t);
        var a = Ta(o, !0);
        f1 && (!Kh || r !== Ib || s !== Bb) && (Kh && nA(), Kh = setInterval(function() {
          var l = Ta(document.elementFromPoint(r, s), !0);
          l !== a && (a = l, zg()), Qb(e, i.options, l, t);
        }, 10), Ib = r, Bb = s);
      } else {
        if (!this.options.bubbleScroll || Ta(o, !0) === lo()) {
          zg();
          return;
        }
        Qb(e, this.options, Ta(o, !1), !1);
      }
    }
  }, Go(n, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function zg() {
  _n.forEach(function(n) {
    clearInterval(n.pid);
  }), _n = [];
}
function nA() {
  clearInterval(Kh);
}
var Qb = oL(function(n, e, t, i) {
  if (e.scroll) {
    var r = (n.touches ? n.touches[0] : n).clientX, s = (n.touches ? n.touches[0] : n).clientY, o = e.scrollSensitivity, a = e.scrollSpeed, l = lo(), c = !1, u;
    d1 !== t && (d1 = t, zg(), Gh = e.scroll, u = e.scrollFn, Gh === !0 && (Gh = Ta(t, !0)));
    var h = 0, d = Gh;
    do {
      var f = d, p = Rn(f), g = p.top, m = p.bottom, v = p.left, y = p.right, b = p.width, w = p.height, x = void 0, S = void 0, C = f.scrollWidth, k = f.scrollHeight, E = Ve(f), M = f.scrollLeft, _ = f.scrollTop;
      f === l ? (x = b < C && (E.overflowX === "auto" || E.overflowX === "scroll" || E.overflowX === "visible"), S = w < k && (E.overflowY === "auto" || E.overflowY === "scroll" || E.overflowY === "visible")) : (x = b < C && (E.overflowX === "auto" || E.overflowX === "scroll"), S = w < k && (E.overflowY === "auto" || E.overflowY === "scroll"));
      var T = x && (Math.abs(y - r) <= o && M + b < C) - (Math.abs(v - r) <= o && !!M), B = S && (Math.abs(m - s) <= o && _ + w < k) - (Math.abs(g - s) <= o && !!_);
      if (!_n[h])
        for (var I = 0; I <= h; I++)
          _n[I] || (_n[I] = {});
      (_n[h].vx != T || _n[h].vy != B || _n[h].el !== f) && (_n[h].el = f, _n[h].vx = T, _n[h].vy = B, clearInterval(_n[h].pid), (T != 0 || B != 0) && (c = !0, _n[h].pid = setInterval((function() {
        i && this.layer === 0 && et.active._onTouchMove(Um);
        var P = _n[this.layer].vy ? _n[this.layer].vy * a : 0, A = _n[this.layer].vx ? _n[this.layer].vx * a : 0;
        typeof u == "function" && u.call(et.dragged.parentNode[kr], A, P, n, Um, _n[this.layer].el) !== "continue" || aL(_n[this.layer].el, A, P);
      }).bind({
        layer: h
      }), 24))), h++;
    } while (e.bubbleScroll && d !== l && (d = Ta(d, !1)));
    f1 = c;
  }
}, 30), pL = function(n) {
  var e = n.originalEvent, t = n.putSortable, i = n.dragEl, r = n.activeSortable, s = n.dispatchSortableEvent, o = n.hideGhostForTarget, a = n.unhideGhostForTarget;
  if (e) {
    var l = t || r;
    o();
    var c = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e, u = document.elementFromPoint(c.clientX, c.clientY);
    a(), l && !l.el.contains(u) && (s("spill"), this.onSpill({
      dragEl: i,
      putSortable: t
    }));
  }
};
function Gx() {
}
Gx.prototype = {
  startIndex: null,
  dragStart: function(n) {
    var e = n.oldDraggableIndex;
    this.startIndex = e;
  },
  onSpill: function(n) {
    var e = n.dragEl, t = n.putSortable;
    this.sortable.captureAnimationState(), t && t.captureAnimationState();
    var i = Uu(this.sortable.el, this.startIndex, this.options);
    i ? this.sortable.el.insertBefore(e, i) : this.sortable.el.appendChild(e), this.sortable.animateAll(), t && t.animateAll();
  },
  drop: pL
};
Go(Gx, {
  pluginName: "revertOnSpill"
});
function Kx() {
}
Kx.prototype = {
  onSpill: function(n) {
    var e = n.dragEl, t = n.putSortable, i = t || this.sortable;
    i.captureAnimationState(), e.parentNode && e.parentNode.removeChild(e), i.animateAll();
  },
  drop: pL
};
Go(Kx, {
  pluginName: "removeOnSpill"
});
et.mount(new CYe());
et.mount(Kx, Gx);
function kYe(n) {
  return n == null ? n : JSON.parse(JSON.stringify(n));
}
function PYe(n) {
  Xe() && Gu(n);
}
function EYe(n) {
  Xe() ? qe(n) : $e(n);
}
const iA = Symbol("cloneElement");
function AYe(...n) {
  var e, t;
  const i = (e = Xe()) == null ? void 0 : e.proxy, r = n[0];
  let [, s, o] = n;
  Array.isArray(O(s)) || (o = s, s = null);
  let a = null;
  const {
    immediate: l = !0,
    clone: c = kYe,
    customUpdate: u
  } = (t = O(o)) != null ? t : {};
  function h(S) {
    var C;
    S.item[iA] = c(O((C = O(s)) == null ? void 0 : C[S.oldIndex]));
  }
  function d(S) {
    const C = S.item[iA];
    WXe(C) || (Tb(S.item), qXe(O(s), S.newDraggableIndex, C));
  }
  function f(S) {
    const { from: C, item: k, oldIndex: E, oldDraggableIndex: M, pullMode: _, clone: T } = S;
    if (_ === "clone") {
      HE(C, k, E), Tb(T);
      return;
    }
    ZXe(O(s), M);
  }
  function p(S) {
    if (u) {
      u(S);
      return;
    }
    const { from: C, item: k, oldIndex: E, newIndex: M } = S;
    if (Tb(k), HE(C, k, E), Zi(s)) {
      const _ = [...O(s)];
      s.value = WE(
        _,
        E,
        M
      );
      return;
    }
    WE(O(s), E, M);
  }
  const g = {
    onUpdate: p,
    onStart: h,
    onAdd: d,
    onRemove: f
  };
  function m(S) {
    const C = O(r);
    return S || (S = HXe(C) ? XXe(C, i == null ? void 0 : i.$el) : C), S && !GXe(S) && (S = S.$el), S || jXe("Root element not found"), S;
  }
  function v() {
    var S;
    const C = (S = O(o)) != null ? S : {}, k = J4(C, ["immediate", "clone"]);
    return UXe(
      s === null ? {} : g,
      k
    );
  }
  const y = (S) => {
    S = m(S), a && b.destroy(), a = new et(S, v());
  };
  ne(
    () => o,
    () => {
      a && KXe(v(), (S, C) => {
        a == null || a.option(S, C);
      });
    },
    { deep: !0 }
  );
  const b = {
    option: (S, C) => a == null ? void 0 : a.option(S, C),
    destroy: () => {
      a == null || a.destroy(), a = null;
    },
    save: () => a == null ? void 0 : a.save(),
    toArray: () => a == null ? void 0 : a.toArray(),
    closest: (...S) => a == null ? void 0 : a.closest(...S)
  }, w = () => b == null ? void 0 : b.option("disabled", !0), x = () => b == null ? void 0 : b.option("disabled", !1);
  return EYe(() => {
    l && y();
  }), PYe(b.destroy), zc({ start: y, pause: w, resume: x }, b);
}
const p1 = [
  "update",
  "start",
  "add",
  "remove",
  "choose",
  "unchoose",
  "end",
  "sort",
  "filter",
  "clone",
  "move",
  "change"
], $Ye = [
  "animation",
  "ghostClass",
  "group",
  "sort",
  "disabled",
  "store",
  "handle",
  "draggable",
  "swapThreshold",
  "invertSwap",
  "invertedSwapThreshold",
  "removeCloneOnHide",
  "direction",
  "chosenClass",
  "dragClass",
  "ignore",
  "filter",
  "preventOnFilter",
  "easing",
  "setData",
  "dropBubble",
  "dragoverBubble",
  "dataIdAttr",
  "delay",
  "delayOnTouchOnly",
  "touchStartThreshold",
  "forceFallback",
  "fallbackClass",
  "fallbackOnBody",
  "fallbackTolerance",
  "fallbackOffset",
  "supportPointer",
  "emptyInsertThreshold",
  "scroll",
  "forceAutoScrollFallback",
  "scrollSensitivity",
  "scrollSpeed",
  "bubbleScroll",
  "modelValue",
  "tag",
  "target",
  "customUpdate",
  ...p1.map((n) => `on${n.replace(/^\S/, (e) => e.toUpperCase())}`)
], mJe = F({
  name: "VueDraggable",
  model: {
    prop: "modelValue",
    event: "update:modelValue"
  },
  props: $Ye,
  emits: ["update:modelValue", ...p1],
  setup(n, { slots: e, emit: t, expose: i, attrs: r }) {
    const s = p1.reduce((u, h) => {
      const d = `on${h.replace(/^\S/, (f) => f.toUpperCase())}`;
      return u[d] = (f) => t(h, f), u;
    }, {}), o = $(() => {
      const u = Hr(n), h = J4(u, ["modelValue"]), d = Object.entries(h).reduce((f, [p, g]) => {
        const m = O(g);
        return m !== void 0 && (f[p] = m), f;
      }, {});
      return zc(zc({}, s), FXe(zc(zc({}, r), d)));
    }), a = $({
      get: () => n.modelValue,
      set: (u) => t("update:modelValue", u)
    }), l = D(), c = Gt(
      AYe(n.target || l, a, o)
    );
    return i(c), () => {
      var u;
      return Re(n.tag || "div", { ref: l }, (u = e == null ? void 0 : e.default) == null ? void 0 : u.call(e, c));
    };
  }
}), TYe = 36, rA = 1, _Ye = 2, Qh = 3, zb = 4, MYe = 5, RYe = 6, NYe = 7, DYe = 8, LYe = 9, IYe = 10, BYe = 11, QYe = 12, zYe = 13, jYe = 14, VYe = 15, FYe = 16, ZYe = 17, sA = 18, qYe = 19, gL = 20, mL = 21, oA = 22, WYe = 23, HYe = 24;
function g1(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n >= 48 && n <= 57;
}
function XYe(n) {
  return n >= 48 && n <= 57 || n >= 97 && n <= 102 || n >= 65 && n <= 70;
}
function gl(n, e, t) {
  for (let i = !1; ; ) {
    if (n.next < 0)
      return;
    if (n.next == e && !i) {
      n.advance();
      return;
    }
    i = t && !i && n.next == 92, n.advance();
  }
}
function YYe(n) {
  for (; ; ) {
    if (n.next < 0 || n.peek(1) < 0)
      return;
    if (n.next == 36 && n.peek(1) == 36) {
      n.advance(2);
      return;
    }
    n.advance();
  }
}
function UYe(n, e) {
  let t = "[{<(".indexOf(String.fromCharCode(e)), i = t < 0 ? e : "]}>)".charCodeAt(t);
  for (; ; ) {
    if (n.next < 0)
      return;
    if (n.next == i && n.peek(1) == 39) {
      n.advance(2);
      return;
    }
    n.advance();
  }
}
function vL(n, e) {
  for (; !(n.next != 95 && !g1(n.next)); )
    e != null && (e += String.fromCharCode(n.next)), n.advance();
  return e;
}
function GYe(n) {
  if (n.next == 39 || n.next == 34 || n.next == 96) {
    let e = n.next;
    n.advance(), gl(n, e, !1);
  } else
    vL(n);
}
function aA(n, e) {
  for (; n.next == 48 || n.next == 49; )
    n.advance();
  e && n.next == e && n.advance();
}
function lA(n, e) {
  for (; ; ) {
    if (n.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (n.next < 48 || n.next > 57)
      break;
    n.advance();
  }
  if (n.next == 69 || n.next == 101)
    for (n.advance(), (n.next == 43 || n.next == 45) && n.advance(); n.next >= 48 && n.next <= 57; )
      n.advance();
}
function cA(n) {
  for (; !(n.next < 0 || n.next == 10); )
    n.advance();
}
function hl(n, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == n)
      return !0;
  return !1;
}
const jb = ` 	\r
`;
function bL(n, e, t) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = MYe, i.null = i.unknown = RYe;
  for (let r of n.split(" "))
    r && (i[r] = gL);
  for (let r of e.split(" "))
    r && (i[r] = mL);
  for (let r of (t || "").split(" "))
    r && (i[r] = HYe);
  return i;
}
const KYe = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", JYe = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", m1 = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: /* @__PURE__ */ bL(JYe, KYe)
};
function eUe(n, e, t, i) {
  let r = {};
  for (let s in m1)
    r[s] = (n.hasOwnProperty(s) ? n : m1)[s];
  return e && (r.words = bL(e, t || "", i)), r;
}
function yL(n) {
  return new qf((e) => {
    var t;
    let { next: i } = e;
    if (e.advance(), hl(i, jb)) {
      for (; hl(e.next, jb); )
        e.advance();
      e.acceptToken(TYe);
    } else if (i == 36 && e.next == 36 && n.doubleDollarQuotedStrings)
      YYe(e), e.acceptToken(Qh);
    else if (i == 39 || i == 34 && n.doubleQuotedStrings)
      gl(e, i, n.backslashEscapes), e.acceptToken(Qh);
    else if (i == 35 && n.hashComments || i == 47 && e.next == 47 && n.slashComments)
      cA(e), e.acceptToken(rA);
    else if (i == 45 && e.next == 45 && (!n.spaceAfterDashes || e.peek(1) == 32))
      cA(e), e.acceptToken(rA);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let r = 1; ; ) {
        let s = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), s == 42 && e.next == 47) {
          if (r--, e.advance(), !r)
            break;
        } else
          s == 47 && e.next == 42 && (r++, e.advance());
      }
      e.acceptToken(_Ye);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), gl(e, 39, !0);
    else if ((i == 110 || i == 78) && e.next == 39 && n.charSetCasts)
      e.advance(), gl(e, 39, n.backslashEscapes), e.acceptToken(Qh);
    else if (i == 95 && n.charSetCasts)
      for (let r = 0; ; r++) {
        if (e.next == 39 && r > 1) {
          e.advance(), gl(e, 39, n.backslashEscapes), e.acceptToken(Qh);
          break;
        }
        if (!g1(e.next))
          break;
        e.advance();
      }
    else if (n.plsqlQuotingMechanism && (i == 113 || i == 81) && e.next == 39 && e.peek(1) > 0 && !hl(e.peek(1), jb)) {
      let r = e.peek(1);
      e.advance(2), UYe(e, r), e.acceptToken(Qh);
    } else if (i == 40)
      e.acceptToken(NYe);
    else if (i == 41)
      e.acceptToken(DYe);
    else if (i == 123)
      e.acceptToken(LYe);
    else if (i == 125)
      e.acceptToken(IYe);
    else if (i == 91)
      e.acceptToken(BYe);
    else if (i == 93)
      e.acceptToken(QYe);
    else if (i == 59)
      e.acceptToken(zYe);
    else if (n.unquotedBitLiterals && i == 48 && e.next == 98)
      e.advance(), aA(e), e.acceptToken(oA);
    else if ((i == 98 || i == 66) && (e.next == 39 || e.next == 34)) {
      const r = e.next;
      e.advance(), n.treatBitsAsBytes ? (gl(e, r, n.backslashEscapes), e.acceptToken(WYe)) : (aA(e, r), e.acceptToken(oA));
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let r = e.next == 39;
      for (e.advance(); XYe(e.next); )
        e.advance();
      r && e.next == 39 && e.advance(), e.acceptToken(zb);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      lA(e, !0), e.acceptToken(zb);
    else if (i == 46)
      e.acceptToken(jYe);
    else if (i >= 48 && i <= 57)
      lA(e, !1), e.acceptToken(zb);
    else if (hl(i, n.operatorChars)) {
      for (; hl(e.next, n.operatorChars); )
        e.advance();
      e.acceptToken(VYe);
    } else if (hl(i, n.specialVar))
      e.next == i && e.advance(), GYe(e), e.acceptToken(ZYe);
    else if (hl(i, n.identifierQuotes))
      gl(e, i, !1), e.acceptToken(qYe);
    else if (i == 58 || i == 44)
      e.acceptToken(FYe);
    else if (g1(i)) {
      let r = vL(e, String.fromCharCode(i));
      e.acceptToken(e.next == 46 || e.peek(-r.length - 1) == 46 ? sA : (t = n.words[r.toLowerCase()]) !== null && t !== void 0 ? t : sA);
    }
  });
}
const OL = /* @__PURE__ */ yL(m1), tUe = /* @__PURE__ */ Yu.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, OL],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function v1(n) {
  let e = n.cursor().moveTo(n.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function mf(n, e) {
  let t = n.sliceString(e.from, e.to), i = /^([`'"])(.*)\1$/.exec(t);
  return i ? i[2] : t;
}
function Gm(n) {
  return n && (n.name == "Identifier" || n.name == "QuotedIdentifier");
}
function nUe(n, e) {
  if (e.name == "CompositeIdentifier") {
    let t = [];
    for (let i = e.firstChild; i; i = i.nextSibling)
      Gm(i) && t.push(mf(n, i));
    return t;
  }
  return [mf(n, e)];
}
function uA(n, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let i = v1(e);
    if (!Gm(i))
      return t;
    t.unshift(mf(n, i)), e = v1(i);
  }
}
function iUe(n, e) {
  let t = zn(n).resolveInner(e, -1), i = sUe(n.doc, t);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" || t.name == "Keyword" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? n.doc.sliceString(t.from, t.from + 1) : null,
    parents: uA(n.doc, v1(t)),
    aliases: i
  } : t.name == "." ? { from: e, quoted: null, parents: uA(n.doc, t), aliases: i } : { from: e, quoted: null, parents: [], empty: !0, aliases: i };
}
const rUe = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function sUe(n, e) {
  let t;
  for (let r = e; !t; r = r.parent) {
    if (!r)
      return null;
    r.name == "Statement" && (t = r);
  }
  let i = null;
  for (let r = t.firstChild, s = !1, o = null; r; r = r.nextSibling) {
    let a = r.name == "Keyword" ? n.sliceString(r.from, r.to).toLowerCase() : null, l = null;
    if (!s)
      s = a == "from";
    else if (a == "as" && o && Gm(r.nextSibling))
      l = mf(n, r.nextSibling);
    else {
      if (a && rUe.has(a))
        break;
      o && Gm(r) && (l = mf(n, r));
    }
    l && (i || (i = /* @__PURE__ */ Object.create(null)), i[l] = nUe(n, o)), o = /Identifier$/.test(r.name) ? r : null;
  }
  return i;
}
function oUe(n, e) {
  return n ? e.map((t) => Object.assign(Object.assign({}, t), { label: t.label[0] == n ? t.label : n + t.label + n, apply: void 0 })) : e;
}
const aUe = /^\w*$/, lUe = /^[`'"]?\w*[`'"]?$/;
function hA(n) {
  return n.self && typeof n.self.label == "string";
}
class Jx {
  constructor(e) {
    this.idQuote = e, this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null)), i = t[e];
    return i || (e && !this.list.some((r) => r.label == e) && this.list.push(dA(e, "type", this.idQuote)), t[e] = new Jx(this.idQuote));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let t = this.list.findIndex((i) => i.label == e.label);
    t > -1 ? this.list[t] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let t of e)
      this.addCompletion(typeof t == "string" ? dA(t, "property", this.idQuote) : t);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : hA(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let t of Object.keys(e)) {
      let i = e[t], r = null, s = t.replace(/\\?\./g, (a) => a == "." ? "\0" : a).split("\0"), o = this;
      hA(i) && (r = i.self, i = i.children);
      for (let a = 0; a < s.length; a++)
        r && a == s.length - 1 && o.addCompletion(r), o = o.child(s[a].replace(/\\\./g, "."));
      o.addNamespace(i);
    }
  }
}
function dA(n, e, t) {
  return /^[a-z_][a-z_\d]*$/.test(n) ? { label: n, type: e } : { label: n, type: e, apply: t + n + t };
}
function cUe(n, e, t, i, r, s) {
  var o;
  let a = ((o = s == null ? void 0 : s.spec.identifierQuotes) === null || o === void 0 ? void 0 : o[0]) || '"', l = new Jx(a), c = r ? l.child(r) : null;
  return l.addNamespace(n), e && (c || l).addCompletions(e), t && l.addCompletions(t), c && l.addCompletions(c.list), i && l.addCompletions((c || l).child(i).list), (u) => {
    let { parents: h, from: d, quoted: f, empty: p, aliases: g } = iUe(u.state, u.pos);
    if (p && !u.explicit)
      return null;
    g && h.length == 1 && (h = g[h[0]] || h);
    let m = l;
    for (let b of h) {
      for (; !m.children || !m.children[b]; )
        if (m == l)
          m = c;
        else if (m == c && i)
          m = m.child(i);
        else
          return null;
      let w = m.maybeChild(b);
      if (!w)
        return null;
      m = w;
    }
    let v = f && u.state.sliceDoc(u.pos, u.pos + 1) == f, y = m.list;
    return m == l && g && (y = y.concat(Object.keys(g).map((b) => ({ label: b, type: "constant" })))), {
      from: d,
      to: v ? u.pos + 1 : void 0,
      options: oUe(f, y),
      validFor: f ? lUe : aUe
    };
  };
}
function uUe(n, e) {
  let t = Object.keys(n).map((i) => ({
    label: e ? i.toUpperCase() : i,
    type: n[i] == mL ? "type" : n[i] == gL ? "keyword" : "variable",
    boost: -1
  }));
  return RD(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], Mx(t));
}
let hUe = /* @__PURE__ */ tUe.configure({
  props: [
    /* @__PURE__ */ Fv.add({
      Statement: /* @__PURE__ */ Kc()
    }),
    /* @__PURE__ */ Zv.add({
      Statement(n) {
        return { from: n.firstChild.to, to: n.to };
      },
      BlockComment(n) {
        return { from: n.from + 2, to: n.to - 2 };
      }
    }),
    /* @__PURE__ */ zv({
      Keyword: X.keyword,
      Type: X.typeName,
      Builtin: /* @__PURE__ */ X.standard(X.name),
      Bits: X.number,
      Bytes: X.string,
      Bool: X.bool,
      Null: X.null,
      Number: X.number,
      String: X.string,
      Identifier: X.name,
      QuotedIdentifier: /* @__PURE__ */ X.special(X.string),
      SpecialVar: /* @__PURE__ */ X.special(X.name),
      LineComment: X.lineComment,
      BlockComment: X.blockComment,
      Operator: X.operator,
      "Semi Punctuation": X.punctuation,
      "( )": X.paren,
      "{ }": X.brace,
      "[ ]": X.squareBracket
    })
  ]
});
class eS {
  constructor(e, t, i) {
    this.dialect = e, this.language = t, this.spec = i;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = eUe(e, e.keywords, e.types, e.builtin), i = qu.define({
      name: "sql",
      parser: hUe.configure({
        tokenizers: [{ from: OL, to: yL(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new eS(t, i, e);
  }
}
function dUe(n, e = !1) {
  return uUe(n.dialect.words, e);
}
function fUe(n, e = !1) {
  return n.language.data.of({
    autocomplete: dUe(n, e)
  });
}
function pUe(n) {
  return n.schema ? cUe(n.schema, n.tables, n.schemas, n.defaultTable, n.defaultSchema, n.dialect || tS) : () => null;
}
function gUe(n) {
  return n.schema ? (n.dialect || tS).language.data.of({
    autocomplete: pUe(n)
  }) : [];
}
function vJe(n = {}) {
  let e = n.dialect || tS;
  return new wx(e.language, [gUe(n), fUe(e, !!n.upperCaseKeywords)]);
}
const tS = /* @__PURE__ */ eS.define({});
var b1 = { exports: {} }, Rs = {}, Sn = {};
Sn.__esModule = !0;
Sn.extend = wL;
Sn.indexOf = OUe;
Sn.escapeExpression = wUe;
Sn.isEmpty = xUe;
Sn.createFrame = SUe;
Sn.blockParams = CUe;
Sn.appendContextPath = kUe;
var mUe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;",
  "=": "&#x3D;"
}, vUe = /[&<>"'`=]/g, bUe = /[&<>"'`=]/;
function yUe(n) {
  return mUe[n];
}
function wL(n) {
  for (var e = 1; e < arguments.length; e++)
    for (var t in arguments[e])
      Object.prototype.hasOwnProperty.call(arguments[e], t) && (n[t] = arguments[e][t]);
  return n;
}
var nS = Object.prototype.toString;
Sn.toString = nS;
var y1 = function(e) {
  return typeof e == "function";
};
y1(/x/) && (Sn.isFunction = y1 = function(n) {
  return typeof n == "function" && nS.call(n) === "[object Function]";
});
Sn.isFunction = y1;
var xL = Array.isArray || function(n) {
  return n && typeof n == "object" ? nS.call(n) === "[object Array]" : !1;
};
Sn.isArray = xL;
function OUe(n, e) {
  for (var t = 0, i = n.length; t < i; t++)
    if (n[t] === e)
      return t;
  return -1;
}
function wUe(n) {
  if (typeof n != "string") {
    if (n && n.toHTML)
      return n.toHTML();
    if (n == null)
      return "";
    if (!n)
      return n + "";
    n = "" + n;
  }
  return bUe.test(n) ? n.replace(vUe, yUe) : n;
}
function xUe(n) {
  return !n && n !== 0 ? !0 : !!(xL(n) && n.length === 0);
}
function SUe(n) {
  var e = wL({}, n);
  return e._parent = n, e;
}
function CUe(n, e) {
  return n.path = e, n;
}
function kUe(n, e) {
  return (n ? n + "." : "") + e;
}
var O1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  var t = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function i(r, s) {
    var o = s && s.loc, a = void 0, l = void 0, c = void 0, u = void 0;
    o && (a = o.start.line, l = o.end.line, c = o.start.column, u = o.end.column, r += " - " + a + ":" + c);
    for (var h = Error.prototype.constructor.call(this, r), d = 0; d < t.length; d++)
      this[t[d]] = h[t[d]];
    Error.captureStackTrace && Error.captureStackTrace(this, i);
    try {
      o && (this.lineNumber = a, this.endLineNumber = l, Object.defineProperty ? (Object.defineProperty(this, "column", {
        value: c,
        enumerable: !0
      }), Object.defineProperty(this, "endColumn", {
        value: u,
        enumerable: !0
      })) : (this.column = c, this.endColumn = u));
    } catch {
    }
  }
  i.prototype = new Error(), e.default = i, n.exports = e.default;
})(O1, O1.exports);
var fc = O1.exports, Uf = {}, w1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  var t = Sn;
  e.default = function(i) {
    i.registerHelper("blockHelperMissing", function(r, s) {
      var o = s.inverse, a = s.fn;
      if (r === !0)
        return a(this);
      if (r === !1 || r == null)
        return o(this);
      if (t.isArray(r))
        return r.length > 0 ? (s.ids && (s.ids = [s.name]), i.helpers.each(r, s)) : o(this);
      if (s.data && s.ids) {
        var l = t.createFrame(s.data);
        l.contextPath = t.appendContextPath(s.data.contextPath, s.name), s = { data: l };
      }
      return a(r, s);
    });
  }, n.exports = e.default;
})(w1, w1.exports);
var PUe = w1.exports, x1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  function t(o) {
    return o && o.__esModule ? o : { default: o };
  }
  var i = Sn, r = fc, s = t(r);
  e.default = function(o) {
    o.registerHelper("each", function(a, l) {
      if (!l)
        throw new s.default("Must pass iterator to #each");
      var c = l.fn, u = l.inverse, h = 0, d = "", f = void 0, p = void 0;
      l.data && l.ids && (p = i.appendContextPath(l.data.contextPath, l.ids[0]) + "."), i.isFunction(a) && (a = a.call(this)), l.data && (f = i.createFrame(l.data));
      function g(w, x, S) {
        f && (f.key = w, f.index = x, f.first = x === 0, f.last = !!S, p && (f.contextPath = p + w)), d = d + c(a[w], {
          data: f,
          blockParams: i.blockParams([a[w], w], [p + w, null])
        });
      }
      if (a && typeof a == "object")
        if (i.isArray(a))
          for (var m = a.length; h < m; h++)
            h in a && g(h, h, h === a.length - 1);
        else if (typeof Symbol == "function" && a[Symbol.iterator]) {
          for (var v = [], y = a[Symbol.iterator](), b = y.next(); !b.done; b = y.next())
            v.push(b.value);
          a = v;
          for (var m = a.length; h < m; h++)
            g(h, h, h === a.length - 1);
        } else
          (function() {
            var w = void 0;
            Object.keys(a).forEach(function(x) {
              w !== void 0 && g(w, h - 1), w = x, h++;
            }), w !== void 0 && g(w, h - 1, !0);
          })();
      return h === 0 && (d = u(this)), d;
    });
  }, n.exports = e.default;
})(x1, x1.exports);
var EUe = x1.exports, S1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var i = fc, r = t(i);
  e.default = function(s) {
    s.registerHelper("helperMissing", function() {
      if (arguments.length !== 1)
        throw new r.default('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    });
  }, n.exports = e.default;
})(S1, S1.exports);
var AUe = S1.exports, C1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  function t(o) {
    return o && o.__esModule ? o : { default: o };
  }
  var i = Sn, r = fc, s = t(r);
  e.default = function(o) {
    o.registerHelper("if", function(a, l) {
      if (arguments.length != 2)
        throw new s.default("#if requires exactly one argument");
      return i.isFunction(a) && (a = a.call(this)), !l.hash.includeZero && !a || i.isEmpty(a) ? l.inverse(this) : l.fn(this);
    }), o.registerHelper("unless", function(a, l) {
      if (arguments.length != 2)
        throw new s.default("#unless requires exactly one argument");
      return o.helpers.if.call(this, a, {
        fn: l.inverse,
        inverse: l.fn,
        hash: l.hash
      });
    });
  }, n.exports = e.default;
})(C1, C1.exports);
var $Ue = C1.exports, k1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0, e.default = function(t) {
    t.registerHelper("log", function() {
      for (var i = [void 0], r = arguments[arguments.length - 1], s = 0; s < arguments.length - 1; s++)
        i.push(arguments[s]);
      var o = 1;
      r.hash.level != null ? o = r.hash.level : r.data && r.data.level != null && (o = r.data.level), i[0] = o, t.log.apply(t, i);
    });
  }, n.exports = e.default;
})(k1, k1.exports);
var TUe = k1.exports, P1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0, e.default = function(t) {
    t.registerHelper("lookup", function(i, r, s) {
      return i && s.lookupProperty(i, r);
    });
  }, n.exports = e.default;
})(P1, P1.exports);
var _Ue = P1.exports, E1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  function t(o) {
    return o && o.__esModule ? o : { default: o };
  }
  var i = Sn, r = fc, s = t(r);
  e.default = function(o) {
    o.registerHelper("with", function(a, l) {
      if (arguments.length != 2)
        throw new s.default("#with requires exactly one argument");
      i.isFunction(a) && (a = a.call(this));
      var c = l.fn;
      if (i.isEmpty(a))
        return l.inverse(this);
      var u = l.data;
      return l.data && l.ids && (u = i.createFrame(l.data), u.contextPath = i.appendContextPath(l.data.contextPath, l.ids[0])), c(a, {
        data: u,
        blockParams: i.blockParams([a], [u && u.contextPath])
      });
    });
  }, n.exports = e.default;
})(E1, E1.exports);
var MUe = E1.exports;
Uf.__esModule = !0;
Uf.registerDefaultHelpers = HUe;
Uf.moveHelperToHooks = XUe;
function pc(n) {
  return n && n.__esModule ? n : { default: n };
}
var RUe = PUe, NUe = pc(RUe), DUe = EUe, LUe = pc(DUe), IUe = AUe, BUe = pc(IUe), QUe = $Ue, zUe = pc(QUe), jUe = TUe, VUe = pc(jUe), FUe = _Ue, ZUe = pc(FUe), qUe = MUe, WUe = pc(qUe);
function HUe(n) {
  NUe.default(n), LUe.default(n), BUe.default(n), zUe.default(n), VUe.default(n), ZUe.default(n), WUe.default(n);
}
function XUe(n, e, t) {
  n.helpers[e] && (n.hooks[e] = n.helpers[e], t || delete n.helpers[e]);
}
var iS = {}, A1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  var t = Sn;
  e.default = function(i) {
    i.registerDecorator("inline", function(r, s, o, a) {
      var l = r;
      return s.partials || (s.partials = {}, l = function(c, u) {
        var h = o.partials;
        o.partials = t.extend({}, h, s.partials);
        var d = r(c, u);
        return o.partials = h, d;
      }), s.partials[a.args[0]] = a.fn, l;
    });
  }, n.exports = e.default;
})(A1, A1.exports);
var YUe = A1.exports;
iS.__esModule = !0;
iS.registerDefaultDecorators = JUe;
function UUe(n) {
  return n && n.__esModule ? n : { default: n };
}
var GUe = YUe, KUe = UUe(GUe);
function JUe(n) {
  KUe.default(n);
}
var $1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  var t = Sn, i = {
    methodMap: ["debug", "info", "warn", "error"],
    level: "info",
    // Maps a given level value to the `methodMap` indexes above.
    lookupLevel: function(s) {
      if (typeof s == "string") {
        var o = t.indexOf(i.methodMap, s.toLowerCase());
        o >= 0 ? s = o : s = parseInt(s, 10);
      }
      return s;
    },
    // Can be overridden in the host environment
    log: function(s) {
      if (s = i.lookupLevel(s), typeof console < "u" && i.lookupLevel(i.level) <= s) {
        var o = i.methodMap[s];
        console[o] || (o = "log");
        for (var a = arguments.length, l = Array(a > 1 ? a - 1 : 0), c = 1; c < a; c++)
          l[c - 1] = arguments[c];
        console[o].apply(console, l);
      }
    }
  };
  e.default = i, n.exports = e.default;
})($1, $1.exports);
var SL = $1.exports, kh = {}, rS = {};
rS.__esModule = !0;
rS.createNewLookupObject = tGe;
var eGe = Sn;
function tGe() {
  for (var n = arguments.length, e = Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return eGe.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(e));
}
kh.__esModule = !0;
kh.createProtoAccessControl = sGe;
kh.resultIsAllowed = oGe;
kh.resetLoggedProperties = lGe;
function nGe(n) {
  return n && n.__esModule ? n : { default: n };
}
var fA = rS, iGe = SL, rGe = nGe(iGe), Km = /* @__PURE__ */ Object.create(null);
function sGe(n) {
  var e = /* @__PURE__ */ Object.create(null);
  e.constructor = !1, e.__defineGetter__ = !1, e.__defineSetter__ = !1, e.__lookupGetter__ = !1;
  var t = /* @__PURE__ */ Object.create(null);
  return t.__proto__ = !1, {
    properties: {
      whitelist: fA.createNewLookupObject(t, n.allowedProtoProperties),
      defaultValue: n.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: fA.createNewLookupObject(e, n.allowedProtoMethods),
      defaultValue: n.allowProtoMethodsByDefault
    }
  };
}
function oGe(n, e, t) {
  return pA(typeof n == "function" ? e.methods : e.properties, t);
}
function pA(n, e) {
  return n.whitelist[e] !== void 0 ? n.whitelist[e] === !0 : n.defaultValue !== void 0 ? n.defaultValue : (aGe(e), !1);
}
function aGe(n) {
  Km[n] !== !0 && (Km[n] = !0, rGe.default.log("error", 'Handlebars: Access has been denied to resolve the property "' + n + `" because it is not an "own property" of its parent.
You can add a runtime option to disable the check or this warning:
See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details`));
}
function lGe() {
  Object.keys(Km).forEach(function(n) {
    delete Km[n];
  });
}
Rs.__esModule = !0;
Rs.HandlebarsEnvironment = T1;
function CL(n) {
  return n && n.__esModule ? n : { default: n };
}
var ml = Sn, cGe = fc, Vb = CL(cGe), uGe = Uf, hGe = iS, dGe = SL, Jm = CL(dGe), fGe = kh, pGe = "4.7.8";
Rs.VERSION = pGe;
var gGe = 8;
Rs.COMPILER_REVISION = gGe;
var mGe = 7;
Rs.LAST_COMPATIBLE_COMPILER_REVISION = mGe;
var vGe = {
  1: "<= 1.0.rc.2",
  // 1.0.rc.2 is actually rev2 but doesn't report it
  2: "== 1.0.0-rc.3",
  3: "== 1.0.0-rc.4",
  4: "== 1.x.x",
  5: "== 2.0.0-alpha.x",
  6: ">= 2.0.0-beta.1",
  7: ">= 4.0.0 <4.3.0",
  8: ">= 4.3.0"
};
Rs.REVISION_CHANGES = vGe;
var Fb = "[object Object]";
function T1(n, e, t) {
  this.helpers = n || {}, this.partials = e || {}, this.decorators = t || {}, uGe.registerDefaultHelpers(this), hGe.registerDefaultDecorators(this);
}
T1.prototype = {
  constructor: T1,
  logger: Jm.default,
  log: Jm.default.log,
  registerHelper: function(e, t) {
    if (ml.toString.call(e) === Fb) {
      if (t)
        throw new Vb.default("Arg not supported with multiple helpers");
      ml.extend(this.helpers, e);
    } else
      this.helpers[e] = t;
  },
  unregisterHelper: function(e) {
    delete this.helpers[e];
  },
  registerPartial: function(e, t) {
    if (ml.toString.call(e) === Fb)
      ml.extend(this.partials, e);
    else {
      if (typeof t > "u")
        throw new Vb.default('Attempting to register a partial called "' + e + '" as undefined');
      this.partials[e] = t;
    }
  },
  unregisterPartial: function(e) {
    delete this.partials[e];
  },
  registerDecorator: function(e, t) {
    if (ml.toString.call(e) === Fb) {
      if (t)
        throw new Vb.default("Arg not supported with multiple decorators");
      ml.extend(this.decorators, e);
    } else
      this.decorators[e] = t;
  },
  unregisterDecorator: function(e) {
    delete this.decorators[e];
  },
  /**
   * Reset the memory of illegal property accesses that have already been logged.
   * @deprecated should only be used in handlebars test-cases
   */
  resetLoggedPropertyAccesses: function() {
    fGe.resetLoggedProperties();
  }
};
var bGe = Jm.default.log;
Rs.log = bGe;
Rs.createFrame = ml.createFrame;
Rs.logger = Jm.default;
var _1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0;
  function t(i) {
    this.string = i;
  }
  t.prototype.toString = t.prototype.toHTML = function() {
    return "" + this.string;
  }, e.default = t, n.exports = e.default;
})(_1, _1.exports);
var yGe = _1.exports, rl = {}, sS = {};
sS.__esModule = !0;
sS.wrapHelper = OGe;
function OGe(n, e) {
  if (typeof n != "function")
    return n;
  var t = function() {
    var r = arguments[arguments.length - 1];
    return arguments[arguments.length - 1] = e(r), n.apply(this, arguments);
  };
  return t;
}
rl.__esModule = !0;
rl.checkRevision = PGe;
rl.template = EGe;
rl.wrapProgram = jg;
rl.resolvePartial = AGe;
rl.invokePartial = $Ge;
rl.noop = kL;
function wGe(n) {
  return n && n.__esModule ? n : { default: n };
}
function xGe(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}
var SGe = Sn, To = xGe(SGe), CGe = fc, _o = wGe(CGe), Mo = Rs, gA = Uf, kGe = sS, mA = kh;
function PGe(n) {
  var e = n && n[0] || 1, t = Mo.COMPILER_REVISION;
  if (!(e >= Mo.LAST_COMPATIBLE_COMPILER_REVISION && e <= Mo.COMPILER_REVISION))
    if (e < Mo.LAST_COMPATIBLE_COMPILER_REVISION) {
      var i = Mo.REVISION_CHANGES[t], r = Mo.REVISION_CHANGES[e];
      throw new _o.default("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + i + ") or downgrade your runtime to an older version (" + r + ").");
    } else
      throw new _o.default("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + n[1] + ").");
}
function EGe(n, e) {
  if (!e)
    throw new _o.default("No environment passed to template");
  if (!n || !n.main)
    throw new _o.default("Unknown template object: " + typeof n);
  n.main.decorator = n.main_d, e.VM.checkRevision(n.compiler);
  var t = n.compiler && n.compiler[0] === 7;
  function i(o, a, l) {
    l.hash && (a = To.extend({}, a, l.hash), l.ids && (l.ids[0] = !0)), o = e.VM.resolvePartial.call(this, o, a, l);
    var c = To.extend({}, l, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    }), u = e.VM.invokePartial.call(this, o, a, c);
    if (u == null && e.compile && (l.partials[l.name] = e.compile(o, n.compilerOptions, e), u = l.partials[l.name](a, c)), u != null) {
      if (l.indent) {
        for (var h = u.split(`
`), d = 0, f = h.length; d < f && !(!h[d] && d + 1 === f); d++)
          h[d] = l.indent + h[d];
        u = h.join(`
`);
      }
      return u;
    } else
      throw new _o.default("The partial " + l.name + " could not be compiled when running in runtime-only mode");
  }
  var r = {
    strict: function(a, l, c) {
      if (!a || !(l in a))
        throw new _o.default('"' + l + '" not defined in ' + a, {
          loc: c
        });
      return r.lookupProperty(a, l);
    },
    lookupProperty: function(a, l) {
      var c = a[l];
      if (c == null || Object.prototype.hasOwnProperty.call(a, l) || mA.resultIsAllowed(c, r.protoAccessControl, l))
        return c;
    },
    lookup: function(a, l) {
      for (var c = a.length, u = 0; u < c; u++) {
        var h = a[u] && r.lookupProperty(a[u], l);
        if (h != null)
          return a[u][l];
      }
    },
    lambda: function(a, l) {
      return typeof a == "function" ? a.call(l) : a;
    },
    escapeExpression: To.escapeExpression,
    invokePartial: i,
    fn: function(a) {
      var l = n[a];
      return l.decorator = n[a + "_d"], l;
    },
    programs: [],
    program: function(a, l, c, u, h) {
      var d = this.programs[a], f = this.fn(a);
      return l || h || u || c ? d = jg(this, a, f, l, c, u, h) : d || (d = this.programs[a] = jg(this, a, f)), d;
    },
    data: function(a, l) {
      for (; a && l--; )
        a = a._parent;
      return a;
    },
    mergeIfNeeded: function(a, l) {
      var c = a || l;
      return a && l && a !== l && (c = To.extend({}, l, a)), c;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),
    noop: e.VM.noop,
    compilerInfo: n.compiler
  };
  function s(o) {
    var a = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], l = a.data;
    s._setup(a), !a.partial && n.useData && (l = TGe(o, l));
    var c = void 0, u = n.useBlockParams ? [] : void 0;
    n.useDepths && (a.depths ? c = o != a.depths[0] ? [o].concat(a.depths) : a.depths : c = [o]);
    function h(d) {
      return "" + n.main(r, d, r.helpers, r.partials, l, u, c);
    }
    return h = PL(n.main, h, r, a.depths || [], l, u), h(o, a);
  }
  return s.isTop = !0, s._setup = function(o) {
    if (o.partial)
      r.protoAccessControl = o.protoAccessControl, r.helpers = o.helpers, r.partials = o.partials, r.decorators = o.decorators, r.hooks = o.hooks;
    else {
      var a = To.extend({}, e.helpers, o.helpers);
      _Ge(a, r), r.helpers = a, n.usePartial && (r.partials = r.mergeIfNeeded(o.partials, e.partials)), (n.usePartial || n.useDecorators) && (r.decorators = To.extend({}, e.decorators, o.decorators)), r.hooks = {}, r.protoAccessControl = mA.createProtoAccessControl(o);
      var l = o.allowCallsToHelperMissing || t;
      gA.moveHelperToHooks(r, "helperMissing", l), gA.moveHelperToHooks(r, "blockHelperMissing", l);
    }
  }, s._child = function(o, a, l, c) {
    if (n.useBlockParams && !l)
      throw new _o.default("must pass block params");
    if (n.useDepths && !c)
      throw new _o.default("must pass parent depths");
    return jg(r, o, n[o], a, 0, l, c);
  }, s;
}
function jg(n, e, t, i, r, s, o) {
  function a(l) {
    var c = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], u = o;
    return o && l != o[0] && !(l === n.nullContext && o[0] === null) && (u = [l].concat(o)), t(n, l, n.helpers, n.partials, c.data || i, s && [c.blockParams].concat(s), u);
  }
  return a = PL(t, a, n, o, i, s), a.program = e, a.depth = o ? o.length : 0, a.blockParams = r || 0, a;
}
function AGe(n, e, t) {
  return n ? !n.call && !t.name && (t.name = n, n = t.partials[n]) : t.name === "@partial-block" ? n = t.data["partial-block"] : n = t.partials[t.name], n;
}
function $Ge(n, e, t) {
  var i = t.data && t.data["partial-block"];
  t.partial = !0, t.ids && (t.data.contextPath = t.ids[0] || t.data.contextPath);
  var r = void 0;
  if (t.fn && t.fn !== kL && function() {
    t.data = Mo.createFrame(t.data);
    var s = t.fn;
    r = t.data["partial-block"] = function(a) {
      var l = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
      return l.data = Mo.createFrame(l.data), l.data["partial-block"] = i, s(a, l);
    }, s.partials && (t.partials = To.extend({}, t.partials, s.partials));
  }(), n === void 0 && r && (n = r), n === void 0)
    throw new _o.default("The partial " + t.name + " could not be found");
  if (n instanceof Function)
    return n(e, t);
}
function kL() {
  return "";
}
function TGe(n, e) {
  return (!e || !("root" in e)) && (e = e ? Mo.createFrame(e) : {}, e.root = n), e;
}
function PL(n, e, t, i, r, s) {
  if (n.decorator) {
    var o = {};
    e = n.decorator(e, o, t, i && i[0], r, s, i), To.extend(e, o);
  }
  return e;
}
function _Ge(n, e) {
  Object.keys(n).forEach(function(t) {
    var i = n[t];
    n[t] = MGe(i, e);
  });
}
function MGe(n, e) {
  var t = e.lookupProperty;
  return kGe.wrapHelper(n, function(i) {
    return To.extend({ lookupProperty: t }, i);
  });
}
var M1 = { exports: {} };
(function(n, e) {
  e.__esModule = !0, e.default = function(t) {
    (function() {
      typeof globalThis != "object" && (Object.prototype.__defineGetter__("__magic__", function() {
        return this;
      }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__);
    })();
    var i = globalThis.Handlebars;
    t.noConflict = function() {
      return globalThis.Handlebars === t && (globalThis.Handlebars = i), t;
    };
  }, n.exports = e.default;
})(M1, M1.exports);
var RGe = M1.exports;
(function(n, e) {
  e.__esModule = !0;
  function t(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function i(y) {
    if (y && y.__esModule)
      return y;
    var b = {};
    if (y != null)
      for (var w in y)
        Object.prototype.hasOwnProperty.call(y, w) && (b[w] = y[w]);
    return b.default = y, b;
  }
  var r = Rs, s = i(r), o = yGe, a = t(o), l = fc, c = t(l), u = Sn, h = i(u), d = rl, f = i(d), p = RGe, g = t(p);
  function m() {
    var y = new s.HandlebarsEnvironment();
    return h.extend(y, s), y.SafeString = a.default, y.Exception = c.default, y.Utils = h, y.escapeExpression = h.escapeExpression, y.VM = f, y.template = function(b) {
      return f.template(b, y);
    }, y;
  }
  var v = m();
  v.create = m, g.default(v), v.default = v, e.default = v, n.exports = e.default;
})(b1, b1.exports);
var NGe = b1.exports, bJe = NGe.default;
export {
  N$ as $,
  IKe as A,
  J1 as B,
  On as C,
  lJe as D,
  XKe as E,
  gKe as F,
  Pe as G,
  iV as H,
  lc as I,
  yKe as J,
  uKe as K,
  WGe as L,
  Yt as M,
  UGe as N,
  MKe as O,
  JGe as P,
  iJe as Q,
  tJe as R,
  nJe as S,
  VKe as T,
  FKe as U,
  np as V,
  UKe as W,
  EKe as X,
  AKe as Y,
  ju as Z,
  jS as _,
  HKe as a,
  uv as a$,
  aKe as a0,
  lKe as a1,
  CV as a2,
  OKe as a3,
  eKe as a4,
  _Ke as a5,
  Vu as a6,
  Gd as a7,
  $oe as a8,
  Kd as a9,
  mJe as aA,
  fv as aB,
  Bt as aC,
  oKe as aD,
  dKe as aE,
  iKe as aF,
  Jg as aG,
  jo as aH,
  VY as aI,
  fM as aJ,
  z$ as aK,
  TKe as aL,
  CKe as aM,
  pJe as aN,
  gJe as aO,
  KKe as aP,
  _e as aQ,
  Et as aR,
  fJe as aS,
  rKe as aT,
  $b as aU,
  Md as aV,
  li as aW,
  wn as aX,
  ZGe as aY,
  jGe as aZ,
  Pf as a_,
  RKe as aa,
  YKe as ab,
  cJe as ac,
  pKe as ad,
  vKe as ae,
  QU as af,
  GGe as ag,
  fKe as ah,
  XGe as ai,
  sKe as aj,
  tKe as ak,
  IW as al,
  NKe as am,
  SKe as an,
  KW as ao,
  jY as ap,
  QKe as aq,
  Gz as ar,
  wKe as as,
  xKe as at,
  BKe as au,
  zo as av,
  LKe as aw,
  WKe as ax,
  Fo as ay,
  qKe as az,
  eJe as b,
  B1 as b0,
  gz as b1,
  Ps as b2,
  RB as b3,
  qg as b4,
  FGe as b5,
  BGe as b6,
  VGe as b7,
  rJe as b8,
  ZKe as b9,
  zGe as ba,
  vJe as bb,
  PKe as bc,
  ac as bd,
  mKe as be,
  qGe as bf,
  nKe as bg,
  bJe as bh,
  Fi as c,
  zKe as d,
  jKe as e,
  Wl as f,
  on as g,
  Fj as h,
  YGe as i,
  _j as j,
  bKe as k,
  HGe as l,
  cV as m,
  QGe as n,
  Fe as o,
  j$ as p,
  KGe as q,
  cKe as r,
  hKe as s,
  DKe as t,
  JKe as u,
  OV as v,
  GKe as w,
  fo as x,
  uc as y,
  VS as z
};
